<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="Python-Standard Library, JackHCC">
    <meta name="description" content="Python标准库详解【2】">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Python-Standard Library | JackHCC</title>
    <link rel="icon" type="image/png" href="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/medias/favicon.png">

    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/css/matery.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/css/my.css">
    
    <script src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/jquery/jquery.min.js"></script>
    
<meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="JackHCC" type="application/atom+xml">
<link rel="stylesheet" href="/css/prism-hopscotch.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper head-container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/medias/me.jpg" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">JackHCC</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="" class="waves-effect waves-light">

      
      <i class="fas fa-list" style="zoom: 0.6;"></i>
      
      <span>Tools</span>
      <i class="fas fa-chevron-down" aria-hidden="true" style="zoom: 0.6;"></i>
    </a>
    <ul class="sub-nav menus_item_child ">
      
      <li>
        <a href="https://creativecc.cn/" target="_blank" rel="noopener">
          
          <i class="fas fa-book" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>Creative工具导航</span>
        </a>
      </li>
      
      <li>
        <a href="https://blog.creativecc.cn/Arxiv-NLP-Reporter/" target="_blank" rel="noopener">
          
          <i class="fas fa-film" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>NLP每日论文</span>
        </a>
      </li>
      
      <li>
        <a href="http://chat.creativecc.cn/" target="_blank" rel="noopener">
          
          <i class="fas fa-music" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>RocketChat聊天室</span>
        </a>
      </li>
      
      <li>
        <a href="/contact">
          
          <i class="fas fa-comments" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>Contact留言板</span>
        </a>
      </li>
      
    </ul>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>

<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/medias/me.jpg" class="logo-img circle responsive-img">
        
        <div class="logo-name">JackHCC</div>
        <div class="logo-desc">
            
            Make the world betterrrr!!!
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="javascript:;">
			
				<i class="fa-fw fas fa-list"></i>
			
			Tools
			<span class="m-icon"><i class="fas fa-chevron-right"></i></span>
		</a>
            <ul  style="background:  ;" >
              
                <li>   
				
                  <a href="https://creativecc.cn/ " target="_blank" rel="noopener" style="margin-left:75px";>
				  
				   <i class="fa fas fa-book" style="position: absolute;left:50px" ></i>
			      
		          <span>Creative工具导航</span>
                  </a>
                </li>
              
                <li>   
				
                  <a href="https://blog.creativecc.cn/Arxiv-NLP-Reporter/ " target="_blank" rel="noopener" style="margin-left:75px";>
				  
				   <i class="fa fas fa-film" style="position: absolute;left:50px" ></i>
			      
		          <span>NLP每日论文</span>
                  </a>
                </li>
              
                <li>   
				
                  <a href="http://chat.creativecc.cn/ " target="_blank" rel="noopener" style="margin-left:75px";>
				  
				   <i class="fa fas fa-music" style="position: absolute;left:50px" ></i>
			      
		          <span>RocketChat聊天室</span>
                  </a>
                </li>
              
                <li>   
				
                  <a href="/contact " style="margin-left:75px";>
				  
				   <i class="fa fas fa-comments" style="position: absolute;left:50px" ></i>
			      
		          <span>Contact留言板</span>
                  </a>
                </li>
               
            </ul>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/JackHCC/JackHCC.github.io" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>

        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/JackHCC/JackHCC.github.io" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    
<script src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/cryptojs/crypto-js.min.js"></script>
<script>
    (function() {
        let pwd = '';
        if (pwd && pwd.length > 0) {
            if (pwd !== CryptoJS.SHA256(prompt('请输入访问本文章的密码')).toString(CryptoJS.enc.Hex)) {
                alert('密码错误，将返回主页！');
                location.href = '/';
            }
        }
    })();
</script>




<div class="bg-cover pd-header post-cover" style="background-image: url('https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/medias/featureimages/7.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">Python-Standard Library</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        margin: 35px 0 15px 0;
        padding-left: 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        height: calc(100vh - 250px);
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #toc-content .is-active-link::before {
        background-color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 30px;
        bottom: 146px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/Python/">
                                <span class="chip bg-color">Python</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/Python/" class="post-category">
                                Python
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2021-11-04
                </div>
                

                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-check fa-fw"></i>更新日期:&nbsp;&nbsp;
                    2021-11-17
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    218.3k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    852 分
                </div>
                

                
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="far fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>

        </div>
        <hr class="clearfix">
        <div class="card-content article-card-content">
            <div id="articleContent">
                <h1 id="Python-标准库"><a href="#Python-标准库" class="headerlink" title="Python 标准库"></a>Python 标准库</h1><ul>
<li>函数式编程模块<ul>
<li><code>itertools</code> —- 为高效循环而创建迭代器的函数</li>
<li><code>functools</code> —- 高阶函数和可调用对象上的操作</li>
<li><code>operator</code> —- 标准运算符替代函数</li>
</ul>
</li>
<li>文件和目录访问<ul>
<li><code>pathlib</code> —- 面向对象的文件系统路径</li>
<li><code>os.path</code> —- 常用路径操作</li>
<li><code>fileinput</code> —- 迭代来自多个输入流的行</li>
<li><code>stat</code> —- 解析 <code>stat()</code> 结果</li>
<li><code>filecmp</code> —- 文件及目录的比较</li>
<li><code>tempfile</code> —- 生成临时文件和目录</li>
<li><code>glob</code> —- Unix 风格路径名模式扩展</li>
<li><code>fnmatch</code> —- Unix 文件名模式匹配</li>
<li><code>linecache</code> —- 随机读写文本行</li>
<li><code>shutil</code> —- 高阶文件操作</li>
</ul>
</li>
<li>数据持久化<ul>
<li><code>pickle</code> —- Python 对象序列化</li>
<li><code>copyreg</code> —- 注册配合 <code>pickle</code> 模块使用的函数</li>
<li><code>shelve</code> —- Python 对象持久化</li>
<li><code>marshal</code> —- 内部 Python 对象序列化</li>
<li><code>dbm</code> —- Unix “数据库” 接口</li>
<li><code>sqlite3</code> —- SQLite 数据库 DB-API 2.0 接口模块</li>
</ul>
</li>
<li>数据压缩和存档<ul>
<li><code>zlib</code> —- 与 <strong>gzip</strong> 兼容的压缩</li>
<li><code>gzip</code> —- 对 <strong>gzip</strong> 格式的支持</li>
<li><code>bz2</code> —- 对 <strong>bzip2</strong> 压缩算法的支持</li>
<li><code>lzma</code> —- 用 LZMA 算法压缩</li>
<li><code>zipfile</code> —- 使用ZIP存档</li>
<li><code>tarfile</code> —- 读写tar归档文件</li>
</ul>
</li>
<li>文件格式<ul>
<li><code>csv</code> —- CSV 文件读写</li>
<li><code>configparser</code> —- 配置文件解析器</li>
<li><code>netrc</code> —- netrc 文件处理</li>
<li><code>xdrlib</code> —- 编码与解码 XDR 数据</li>
<li><code>plistlib</code> —- 生成与解析 Apple <code>.plist</code> 文件</li>
</ul>
</li>
<li>加密服务<ul>
<li><code>hashlib</code> —- 安全哈希与消息摘要</li>
<li><code>hmac</code> —- 基于密钥的消息验证</li>
<li><code>secrets</code> —- 生成管理密码的安全随机数</li>
</ul>
</li>
<li>通用操作系统服务<ul>
<li><code>os</code> —- 多种操作系统接口</li>
<li><code>io</code> —- 处理流的核心工具</li>
<li><code>time</code> —- 时间的访问和转换</li>
<li><code>argparse</code> —- 命令行选项、参数和子命令解析器</li>
<li><code>getopt</code> —- C 风格的命令行选项解析器</li>
<li><code>logging</code> —- Python 的日志记录工具</li>
<li><code>logging.config</code> —- 日志记录配置</li>
<li><code>logging.handlers</code> —- 日志处理程序</li>
<li><code>getpass</code> —- 便携式密码输入工具</li>
<li><code>curses</code> —- 终端字符单元显示的处理</li>
<li><code>curses.textpad</code> —- 用于 curses 程序的文本输入控件</li>
<li><code>curses.ascii</code> —- 用于 ASCII 字符的工具</li>
<li><code>curses.panel</code> —- curses 的面板栈扩展</li>
<li><code>platform</code> —- 获取底层平台的标识数据</li>
<li><code>errno</code> —- 标准 errno 系统符号</li>
<li><code>ctypes</code> —- Python 的外部函数库</li>
</ul>
</li>
</ul>
<h1 id="函数式编程模块"><a href="#函数式编程模块" class="headerlink" title="函数式编程模块"></a>函数式编程模块</h1><ul>
<li><code>itertools</code> —- 为高效循环而创建迭代器的函数<ul>
<li>Itertool函数</li>
<li>itertools 配方</li>
</ul>
</li>
<li><code>functools</code> —- 高阶函数和可调用对象上的操作<ul>
<li><code>partial</code> 对象</li>
</ul>
</li>
<li><code>operator</code> —- 标准运算符替代函数<ul>
<li>将运算符映射到函数</li>
<li>原地运算符</li>
</ul>
</li>
</ul>
<h2 id="itertools-—-为高效循环而创建迭代器的函数"><a href="#itertools-—-为高效循环而创建迭代器的函数" class="headerlink" title="itertools —- 为高效循环而创建迭代器的函数"></a><code>itertools</code> —- 为高效循环而创建迭代器的函数</h2><p>本模块实现一系列 iterator ，这些迭代器受到APL，Haskell和SML的启发。为了适用于Python，它们都被重新写过。</p>
<p>本模块标准化了一个快速、高效利用内存的核心工具集，这些工具本身或组合都很有用。它们一起形成了“迭代器代数”，这使得在纯Python中有可能创建简洁又高效的专用工具。</p>
<p>例如，SML有一个制表工具： <code>tabulate(f)</code>，它可产生一个序列 <code>f(0), f(1), ...</code>。在Python中可以组合 <code>map()</code> 和 <code>count()</code> 实现： <code>map(f, count())</code>。</p>
<p>这些内置工具同时也能很好地与 <code>operator</code> 模块中的高效函数配合使用。例如，我们可以将两个向量的点积映射到乘法运算符： <code>sum(map(operator.mul, vector1, vector2))</code> 。</p>
<p><strong>无穷迭代器：</strong></p>
<table>
<thead>
<tr>
<th align="left">迭代器</th>
<th align="left">实参</th>
<th align="left">结果</th>
<th align="left">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>count()</code></td>
<td align="left">start, [step]</td>
<td align="left">start, start+step, start+2*step, …</td>
<td align="left"><code>count(10) —&gt; 10 11 12 13 14 …</code></td>
</tr>
<tr>
<td align="left"><code>cycle()</code></td>
<td align="left">p</td>
<td align="left">p0, p1, … plast, p0, p1, …</td>
<td align="left"><code>cycle(‘ABCD’) —&gt; A B C D A B C D …</code></td>
</tr>
<tr>
<td align="left"><code>repeat()</code></td>
<td align="left">elem [,n]</td>
<td align="left">elem, elem, elem, … 重复无限次或n次</td>
<td align="left"><code>repeat(10, 3) —&gt; 10 10 10</code></td>
</tr>
</tbody></table>
<p><strong>根据最短输入序列长度停止的迭代器：</strong></p>
<table>
<thead>
<tr>
<th align="left">迭代器</th>
<th align="left">实参</th>
<th align="left">结果</th>
<th align="left">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>accumulate()</code></td>
<td align="left">p [,func]</td>
<td align="left">p0, p0+p1, p0+p1+p2, …</td>
<td align="left"><code>accumulate([1,2,3,4,5]) —&gt; 1 3 6 10 15</code></td>
</tr>
<tr>
<td align="left"><code>chain()</code></td>
<td align="left">p, q, …</td>
<td align="left">p0, p1, … plast, q0, q1, …</td>
<td align="left"><code>chain(‘ABC’, ‘DEF’) —&gt; A B C D E F</code></td>
</tr>
<tr>
<td align="left"><code>chain.from_iterable()</code></td>
<td align="left">iterable — 可迭代对象</td>
<td align="left">p0, p1, … plast, q0, q1, …</td>
<td align="left"><code>chain.from_iterable([‘ABC’, ‘DEF’]) —&gt; A B C D E F</code></td>
</tr>
<tr>
<td align="left"><code>compress()</code></td>
<td align="left">data, selectors</td>
<td align="left">(d[0] if s[0]), (d[1] if s[1]), …</td>
<td align="left"><code>compress(‘ABCDEF’, [1,0,1,0,1,1]) —&gt; A C E F</code></td>
</tr>
<tr>
<td align="left"><code>dropwhile()</code></td>
<td align="left">pred, seq</td>
<td align="left">seq[n], seq[n+1], … 从pred首次真值测试失败开始</td>
<td align="left"><code>dropwhile(lambda x: x&lt;5, [1,4,6,4,1]) —&gt; 6 4 1</code></td>
</tr>
<tr>
<td align="left"><code>filterfalse()</code></td>
<td align="left">pred, seq</td>
<td align="left">seq中pred(x)为假值的元素，x是seq中的元素。</td>
<td align="left"><code>filterfalse(lambda x: x%2, range(10)) —&gt; 0 2 4 6 8</code></td>
</tr>
<tr>
<td align="left"><code>groupby()</code></td>
<td align="left">iterable[, key]</td>
<td align="left">根据key(v)值分组的迭代器</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>islice()</code></td>
<td align="left">seq, [start,] stop [, step]</td>
<td align="left">seq[start:stop:step]中的元素</td>
<td align="left"><code>islice(‘ABCDEFG’, 2, None) —&gt; C D E F G</code></td>
</tr>
<tr>
<td align="left"><code>pairwise()</code></td>
<td align="left">iterable — 可迭代对象</td>
<td align="left">(p[0], p[1]), (p[1], p[2])</td>
<td align="left"><code>pairwise(‘ABCDEFG’) —&gt; AB BC CD DE EF FG</code></td>
</tr>
<tr>
<td align="left"><code>starmap()</code></td>
<td align="left">func, seq</td>
<td align="left">func(<em>seq[0]), func(</em>seq[1]), …</td>
<td align="left"><code>starmap(pow, [(2,5), (3,2), (10,3)]) —&gt; 32 9 1000</code></td>
</tr>
<tr>
<td align="left"><code>takewhile()</code></td>
<td align="left">pred, seq</td>
<td align="left">seq[0], seq[1], …, 直到pred真值测试失败</td>
<td align="left"><code>takewhile(lambda x: x&lt;5, [1,4,6,4,1]) —&gt; 1 4</code></td>
</tr>
<tr>
<td align="left"><code>tee()</code></td>
<td align="left">it, n</td>
<td align="left">it1, it2, … itn 将一个迭代器拆分为n个迭代器</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>zip_longest()</code></td>
<td align="left">p, q, …</td>
<td align="left">(p[0], q[0]), (p[1], q[1]), …</td>
<td align="left"><code>zip_longest(‘ABCD’, ‘xy’, fillvalue=’-‘) —&gt; Ax By C- D-</code></td>
</tr>
</tbody></table>
<p><strong>排列组合迭代器：</strong></p>
<table>
<thead>
<tr>
<th align="left">迭代器</th>
<th align="left">实参</th>
<th align="left">结果</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>product()</code></td>
<td align="left">p, q, … [repeat=1]</td>
<td align="left">笛卡尔积，相当于嵌套的for循环</td>
</tr>
<tr>
<td align="left"><code>permutations()</code></td>
<td align="left">p[, r]</td>
<td align="left">长度r元组，所有可能的排列，无重复元素</td>
</tr>
<tr>
<td align="left"><code>combinations()</code></td>
<td align="left">p, r</td>
<td align="left">长度r元组，有序，无重复元素</td>
</tr>
<tr>
<td align="left"><code>combinations_with_replacement()</code></td>
<td align="left">p, r</td>
<td align="left">长度r元组，有序，元素可重复</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">例子</th>
<th align="left">结果</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>product(‘ABCD’, repeat=2)</code></td>
<td align="left"><code>AA AB AC AD BA BB BC BD CA CB CC CD DA DB DC DD</code></td>
</tr>
<tr>
<td align="left"><code>permutations(‘ABCD’, 2)</code></td>
<td align="left"><code>AB AC AD BA BC BD CA CB CD DA DB DC</code></td>
</tr>
<tr>
<td align="left"><code>combinations(‘ABCD’, 2)</code></td>
<td align="left"><code>AB AC AD BC BD CD</code></td>
</tr>
<tr>
<td align="left"><code>combinations_with_replacement(‘ABCD’, 2)</code></td>
<td align="left"><code>AA AB AC AD BB BC BD CC CD DD</code></td>
</tr>
</tbody></table>
<h3 id="Itertool函数"><a href="#Itertool函数" class="headerlink" title="Itertool函数"></a>Itertool函数</h3><p>下列模块函数均创建并返回迭代器。有些迭代器不限制输出流长度，所以它们只应在能截断输出流的函数或循环中使用。</p>
<p><code>itertools.accumulate</code>(<em>iterable</em>[, <em>func</em>, <em>**,</em> initial=None*])</p>
<p>创建一个迭代器，返回累积汇总值或其他双目运算函数的累积结果值（通过可选的 <em>func</em> 参数指定）。</p>
<p>如果提供了 <em>func*，它应当为带有两个参数的函数。 输入 *iterable</em> 的元素可以是能被 <em>func</em> 接受为参数的任意类型。 （例如，对于默认的加法运算，元素可以是任何可相加的类型包括 <code>Decimal</code> 或 <code>Fraction</code>。）</p>
<p>通常，输出的元素数量与输入的可迭代对象是一致的。 但是，如果提供了关键字参数 <em>initial*，则累加会以 *initial</em> 值开始，这样输出就比输入的可迭代对象多一个元素。</p>
<p>大致相当于：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">accumulate</span><span class="token punctuation">(</span>iterable<span class="token punctuation">,</span> func<span class="token operator">=</span>operator<span class="token punctuation">.</span>add<span class="token punctuation">,</span><span class="token operator">*</span><span class="token punctuation">,</span> initial<span class="token operator">=</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token string">'Return running totals'</span>
<span class="token comment" spellcheck="true"># accumulate([1,2,3,4,5]) --> 1 3 6 10 15</span>
<span class="token comment" spellcheck="true"># accumulate([1,2,3,4,5], initial=100) --> 100 101 103 106 110 115</span>
<span class="token comment" spellcheck="true"># accumulate([1,2,3,4,5], operator.mul) --> 1 2 6 24 120</span>
    it <span class="token operator">=</span> iter<span class="token punctuation">(</span>iterable<span class="token punctuation">)</span>
    total <span class="token operator">=</span> initial
<span class="token keyword">if</span> initial isNone<span class="token punctuation">:</span>
<span class="token keyword">try</span><span class="token punctuation">:</span>
            total <span class="token operator">=</span>next<span class="token punctuation">(</span>it<span class="token punctuation">)</span>
exceptStopIteration<span class="token punctuation">:</span>
<span class="token keyword">return</span>
<span class="token keyword">yield</span> total
<span class="token keyword">for</span> element <span class="token keyword">in</span> it<span class="token punctuation">:</span>
        total <span class="token operator">=</span> func<span class="token punctuation">(</span>total<span class="token punctuation">,</span> element<span class="token punctuation">)</span>
<span class="token keyword">yield</span> total<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><em>func</em> 参数有几种用法。它可以被设为 <code>min()</code> 最终得到一个最小值，或者设为 <code>max()</code> 最终得到一个最大值，或设为 <code>operator.mul()</code> 最终得到一个乘积。摊销表可通过累加利息和支付款项得到。给iterable设置初始值并只将参数 <em>func</em> 设为累加总数可以对一阶 递归关系 建模。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> data <span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> list<span class="token punctuation">(</span>accumulate<span class="token punctuation">(</span>data<span class="token punctuation">,</span>operator<span class="token punctuation">.</span>mul<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># running product</span>
<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">12</span><span class="token punctuation">,</span><span class="token number">72</span><span class="token punctuation">,</span><span class="token number">144</span><span class="token punctuation">,</span><span class="token number">144</span><span class="token punctuation">,</span><span class="token number">1296</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> list<span class="token punctuation">(</span>accumulate<span class="token punctuation">(</span>data<span class="token punctuation">,</span> max<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># running maximum</span>
<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">]</span>
<span class="token comment" spellcheck="true"># Amortize a 5% loan of 1000 with 4 annual payments of 90</span>
<span class="token operator">>></span><span class="token operator">></span> cashflows <span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">1000</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">90</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">90</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">90</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">90</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> list<span class="token punctuation">(</span>accumulate<span class="token punctuation">(</span>cashflows<span class="token punctuation">,</span><span class="token keyword">lambda</span> bal<span class="token punctuation">,</span> pmt<span class="token punctuation">:</span> bal<span class="token operator">*</span><span class="token number">1.05</span><span class="token operator">+</span> pmt<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token number">1000</span><span class="token punctuation">,</span><span class="token number">960.0</span><span class="token punctuation">,</span><span class="token number">918.0</span><span class="token punctuation">,</span><span class="token number">873.9000000000001</span><span class="token punctuation">,</span><span class="token number">827.5950000000001</span><span class="token punctuation">]</span>
<span class="token comment" spellcheck="true"># Chaotic recurrence relation https://en.wikipedia.org/wiki/Logistic_map</span>
<span class="token operator">>></span><span class="token operator">></span> logistic_map <span class="token operator">=</span><span class="token keyword">lambda</span> x<span class="token punctuation">,</span> _<span class="token punctuation">:</span>  r <span class="token operator">*</span> x <span class="token operator">*</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">-</span> x<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> r <span class="token operator">=</span><span class="token number">3.8</span>
<span class="token operator">>></span><span class="token operator">></span> x0 <span class="token operator">=</span><span class="token number">0.4</span>
<span class="token operator">>></span><span class="token operator">></span> inputs <span class="token operator">=</span> repeat<span class="token punctuation">(</span>x0<span class="token punctuation">,</span><span class="token number">36</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># only the initial value is used</span>
<span class="token operator">>></span><span class="token operator">></span><span class="token punctuation">[</span>format<span class="token punctuation">(</span>x<span class="token punctuation">,</span><span class="token string">'.2f'</span><span class="token punctuation">)</span><span class="token keyword">for</span> x <span class="token keyword">in</span> accumulate<span class="token punctuation">(</span>inputs<span class="token punctuation">,</span> logistic_map<span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token string">'0.40'</span><span class="token punctuation">,</span><span class="token string">'0.91'</span><span class="token punctuation">,</span><span class="token string">'0.30'</span><span class="token punctuation">,</span><span class="token string">'0.81'</span><span class="token punctuation">,</span><span class="token string">'0.60'</span><span class="token punctuation">,</span><span class="token string">'0.92'</span><span class="token punctuation">,</span><span class="token string">'0.29'</span><span class="token punctuation">,</span><span class="token string">'0.79'</span><span class="token punctuation">,</span><span class="token string">'0.63'</span><span class="token punctuation">,</span>
<span class="token string">'0.88'</span><span class="token punctuation">,</span><span class="token string">'0.39'</span><span class="token punctuation">,</span><span class="token string">'0.90'</span><span class="token punctuation">,</span><span class="token string">'0.33'</span><span class="token punctuation">,</span><span class="token string">'0.84'</span><span class="token punctuation">,</span><span class="token string">'0.52'</span><span class="token punctuation">,</span><span class="token string">'0.95'</span><span class="token punctuation">,</span><span class="token string">'0.18'</span><span class="token punctuation">,</span><span class="token string">'0.57'</span><span class="token punctuation">,</span>
<span class="token string">'0.93'</span><span class="token punctuation">,</span><span class="token string">'0.25'</span><span class="token punctuation">,</span><span class="token string">'0.71'</span><span class="token punctuation">,</span><span class="token string">'0.79'</span><span class="token punctuation">,</span><span class="token string">'0.63'</span><span class="token punctuation">,</span><span class="token string">'0.88'</span><span class="token punctuation">,</span><span class="token string">'0.39'</span><span class="token punctuation">,</span><span class="token string">'0.91'</span><span class="token punctuation">,</span><span class="token string">'0.32'</span><span class="token punctuation">,</span>
<span class="token string">'0.83'</span><span class="token punctuation">,</span><span class="token string">'0.54'</span><span class="token punctuation">,</span><span class="token string">'0.95'</span><span class="token punctuation">,</span><span class="token string">'0.20'</span><span class="token punctuation">,</span><span class="token string">'0.60'</span><span class="token punctuation">,</span><span class="token string">'0.91'</span><span class="token punctuation">,</span><span class="token string">'0.30'</span><span class="token punctuation">,</span><span class="token string">'0.80'</span><span class="token punctuation">,</span><span class="token string">'0.60'</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>参考一个类似函数 <code>functools.reduce()</code> ，它只返回一个最终累积值。</p>
<p>3.2 新版功能.</p>
<p>在 3.3 版更改: 增加可选参数 <em>func</em> 。</p>
<p>在 3.8 版更改: 添加了可选的 <em>initial</em> 形参。</p>
<p><code>itertools.chain</code>(<em>\</em>iterables*)</p>
<p>创建一个迭代器，它首先返回第一个可迭代对象中所有元素，接着返回下一个可迭代对象中所有元素，直到耗尽所有可迭代对象中的元素。可将多个序列处理为单个序列。大致相当于：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">chain</span><span class="token punctuation">(</span><span class="token operator">*</span>iterables<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token comment" spellcheck="true"># chain('ABC', 'DEF') --> A B C D E F</span>
<span class="token keyword">for</span> it <span class="token keyword">in</span> iterables<span class="token punctuation">:</span>
<span class="token keyword">for</span> element <span class="token keyword">in</span> it<span class="token punctuation">:</span>
<span class="token keyword">yield</span> element<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><em>classmethod<em><code>chain.from_iterable</code>(</em>iterable</em>)</p>
<p>构建类似 <code>chain()</code> 迭代器的另一个选择。从一个单独的可迭代参数中得到链式输入，该参数是延迟计算的。大致相当于：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">from_iterable</span><span class="token punctuation">(</span>iterables<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token comment" spellcheck="true"># chain.from_iterable(['ABC', 'DEF']) --> A B C D E F</span>
<span class="token keyword">for</span> it <span class="token keyword">in</span> iterables<span class="token punctuation">:</span>
<span class="token keyword">for</span> element <span class="token keyword">in</span> it<span class="token punctuation">:</span>
<span class="token keyword">yield</span> element<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>itertools.combinations</code>(<em>iterable</em>, <em>r</em>)</p>
<p>返回由输入 <em>iterable</em> 中元素组成长度为 <em>r</em> 的子序列。</p>
<p>组合元组会以字典顺序根据所输入 <em>iterable</em> 的顺序发出。 因此，如果所输入 <em>iterable</em> 是已排序的，组合元组也将按已排序的顺序生成。</p>
<p>即使元素的值相同，不同位置的元素也被认为是不同的。如果元素各自不同，那么每个组合中没有重复元素。</p>
<p>大致相当于：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">combinations</span><span class="token punctuation">(</span>iterable<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token comment" spellcheck="true"># combinations('ABCD', 2) --> AB AC AD BC BD CD</span>
<span class="token comment" spellcheck="true"># combinations(range(4), 3) --> 012 013 023 123</span>
    pool <span class="token operator">=</span> tuple<span class="token punctuation">(</span>iterable<span class="token punctuation">)</span>
    n <span class="token operator">=</span> len<span class="token punctuation">(</span>pool<span class="token punctuation">)</span>
<span class="token keyword">if</span> r <span class="token operator">></span> n<span class="token punctuation">:</span>
<span class="token keyword">return</span>
    indices <span class="token operator">=</span> list<span class="token punctuation">(</span>range<span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">yield</span> tuple<span class="token punctuation">(</span>pool<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token keyword">for</span> i <span class="token keyword">in</span> indices<span class="token punctuation">)</span>
whileTrue<span class="token punctuation">:</span>
<span class="token keyword">for</span> i <span class="token keyword">in</span> reversed<span class="token punctuation">(</span>range<span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token keyword">if</span> indices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">!=</span> i <span class="token operator">+</span> n <span class="token operator">-</span> r<span class="token punctuation">:</span>
<span class="token keyword">break</span>
<span class="token keyword">else</span><span class="token punctuation">:</span>
<span class="token keyword">return</span>
        indices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">+=</span><span class="token number">1</span>
<span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">:</span>
            indices<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span> indices<span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span>
<span class="token keyword">yield</span> tuple<span class="token punctuation">(</span>pool<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token keyword">for</span> i <span class="token keyword">in</span> indices<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>combinations()</code> 的代码可被改写为 <code>permutations()</code> 过滤后的子序列，（相对于元素在输入中的位置）元素不是有序的。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">combinations</span><span class="token punctuation">(</span>iterable<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">:</span>
    pool <span class="token operator">=</span> tuple<span class="token punctuation">(</span>iterable<span class="token punctuation">)</span>
    n <span class="token operator">=</span> len<span class="token punctuation">(</span>pool<span class="token punctuation">)</span>
<span class="token keyword">for</span> indices <span class="token keyword">in</span> permutations<span class="token punctuation">(</span>range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token keyword">if</span> sorted<span class="token punctuation">(</span>indices<span class="token punctuation">)</span><span class="token operator">==</span> list<span class="token punctuation">(</span>indices<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token keyword">yield</span> tuple<span class="token punctuation">(</span>pool<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token keyword">for</span> i <span class="token keyword">in</span> indices<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>当 <code>0 &lt;= r &lt;= n</code> 时，返回项的个数是 <code>n! / r! / (n-r)!</code>；当 <code>r &gt; n</code> 时，返回项个数为0。</p>
<p><code>itertools.combinations_with_replacement</code>(<em>iterable</em>, <em>r</em>)</p>
<p>返回由输入 <em>iterable</em> 中元素组成的长度为 <em>r</em> 的子序列，允许每个元素可重复出现。</p>
<p>组合元组会以字典顺序根据所输入 <em>iterable</em> 的顺序发出。 因此，如果所输入 <em>iterable</em> 是已排序的，组合元组也将按已排序的顺序生成。</p>
<p>不同位置的元素是不同的，即使它们的值相同。因此如果输入中的元素都是不同的话，返回的组合中元素也都会不同。</p>
<p>大致相当于：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">combinations_with_replacement</span><span class="token punctuation">(</span>iterable<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token comment" spellcheck="true"># combinations_with_replacement('ABC', 2) --> AA AB AC BB BC CC</span>
    pool <span class="token operator">=</span> tuple<span class="token punctuation">(</span>iterable<span class="token punctuation">)</span>
    n <span class="token operator">=</span> len<span class="token punctuation">(</span>pool<span class="token punctuation">)</span>
ifnot n <span class="token operator">and</span> r<span class="token punctuation">:</span>
<span class="token keyword">return</span>
    indices <span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">*</span> r
<span class="token keyword">yield</span> tuple<span class="token punctuation">(</span>pool<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token keyword">for</span> i <span class="token keyword">in</span> indices<span class="token punctuation">)</span>
whileTrue<span class="token punctuation">:</span>
<span class="token keyword">for</span> i <span class="token keyword">in</span> reversed<span class="token punctuation">(</span>range<span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token keyword">if</span> indices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">!=</span> n <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span>
<span class="token keyword">break</span>
<span class="token keyword">else</span><span class="token punctuation">:</span>
<span class="token keyword">return</span>
        indices<span class="token punctuation">[</span>i<span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">[</span>indices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">*</span><span class="token punctuation">(</span>r <span class="token operator">-</span> i<span class="token punctuation">)</span>
<span class="token keyword">yield</span> tuple<span class="token punctuation">(</span>pool<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token keyword">for</span> i <span class="token keyword">in</span> indices<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>combinations_with_replacement()</code> 的代码可被改写为 <code>production()</code> 过滤后的子序列，（相对于元素在输入中的位置）元素不是有序的。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">combinations_with_replacement</span><span class="token punctuation">(</span>iterable<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">:</span>
    pool <span class="token operator">=</span> tuple<span class="token punctuation">(</span>iterable<span class="token punctuation">)</span>
    n <span class="token operator">=</span> len<span class="token punctuation">(</span>pool<span class="token punctuation">)</span>
<span class="token keyword">for</span> indices <span class="token keyword">in</span> product<span class="token punctuation">(</span>range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">,</span> repeat<span class="token operator">=</span>r<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token keyword">if</span> sorted<span class="token punctuation">(</span>indices<span class="token punctuation">)</span><span class="token operator">==</span> list<span class="token punctuation">(</span>indices<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token keyword">yield</span> tuple<span class="token punctuation">(</span>pool<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token keyword">for</span> i <span class="token keyword">in</span> indices<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>当 <code>n &gt; 0</code> 时，返回项个数为 <code>(n+r-1)! / r! / (n-1)!</code>.</p>
<p>3.1 新版功能.</p>
<p><code>itertools.compress</code>(<em>data</em>, <em>selectors</em>)</p>
<p>创建一个迭代器，它返回 <em>data</em> 中经 <em>selectors</em> 真值测试为 <code>True</code> 的元素。迭代器在两者较短的长度处停止。大致相当于：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">compress</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> selectors<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token comment" spellcheck="true"># compress('ABCDEF', [1,0,1,0,1,1]) --> A C E F</span>
<span class="token keyword">return</span><span class="token punctuation">(</span>d <span class="token keyword">for</span> d<span class="token punctuation">,</span> s <span class="token keyword">in</span> zip<span class="token punctuation">(</span>data<span class="token punctuation">,</span> selectors<span class="token punctuation">)</span><span class="token keyword">if</span> s<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>3.1 新版功能.</p>
<p><code>itertools.count</code>(<em>start=0</em>, <em>step=1</em>)</p>
<p>创建一个迭代器，它从 <em>start</em> 值开始，返回均匀间隔的值。常用于 <code>map()</code> 中的实参来生成连续的数据点。此外，还用于 <code>zip()</code> 来添加序列号。大致相当于：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">count</span><span class="token punctuation">(</span>start<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> step<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token comment" spellcheck="true"># count(10) --> 10 11 12 13 14 ...</span>
<span class="token comment" spellcheck="true"># count(2.5, 0.5) -> 2.5 3.0 3.5 ...</span>
    n <span class="token operator">=</span> start
whileTrue<span class="token punctuation">:</span>
<span class="token keyword">yield</span> n
        n <span class="token operator">+=</span> step<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>当对浮点数计数时，替换为乘法代码有时精度会更好，例如： <code>(start + step * i for i in count())</code> 。</p>
<p>在 3.1 版更改: 增加参数 <em>step</em> ，允许非整型。</p>
<p><code>itertools.cycle</code>(<em>iterable</em>)</p>
<p>创建一个迭代器，返回 <em>iterable</em> 中所有元素并保存一个副本。当取完 <em>iterable</em> 中所有元素，返回副本中的所有元素。无限重复。大致相当于：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">cycle</span><span class="token punctuation">(</span>iterable<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token comment" spellcheck="true"># cycle('ABCD') --> A B C D A B C D A B C D ...</span>
    saved <span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token keyword">for</span> element <span class="token keyword">in</span> iterable<span class="token punctuation">:</span>
<span class="token keyword">yield</span> element
        saved<span class="token punctuation">.</span>append<span class="token punctuation">(</span>element<span class="token punctuation">)</span>
<span class="token keyword">while</span> saved<span class="token punctuation">:</span>
<span class="token keyword">for</span> element <span class="token keyword">in</span> saved<span class="token punctuation">:</span>
<span class="token keyword">yield</span> element<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>注意，该函数可能需要相当大的辅助空间（取决于 <em>iterable</em> 的长度）。</p>
<p><code>itertools.dropwhile</code>(<em>predicate</em>, <em>iterable</em>)</p>
<p>创建一个迭代器，如果 <em>predicate</em> 为true，迭代器丢弃这些元素，然后返回其他元素。注意，迭代器在 <em>predicate</em> 首次为false之前不会产生任何输出，所以可能需要一定长度的启动时间。大致相当于：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">dropwhile</span><span class="token punctuation">(</span>predicate<span class="token punctuation">,</span> iterable<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token comment" spellcheck="true"># dropwhile(lambda x: x&lt;5, [1,4,6,4,1]) --> 6 4 1</span>
    iterable <span class="token operator">=</span> iter<span class="token punctuation">(</span>iterable<span class="token punctuation">)</span>
<span class="token keyword">for</span> x <span class="token keyword">in</span> iterable<span class="token punctuation">:</span>
ifnot predicate<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token keyword">yield</span> x
<span class="token keyword">break</span>
<span class="token keyword">for</span> x <span class="token keyword">in</span> iterable<span class="token punctuation">:</span>
<span class="token keyword">yield</span> x<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>itertools.filterfalse</code>(<em>predicate</em>, <em>iterable</em>)</p>
<p>创建一个迭代器，只返回 <em>iterable</em> 中 <em>predicate</em> 为 <code>False</code> 的元素。如果 <em>predicate</em> 是 <code>None</code>，返回真值测试为false的元素。大致相当于：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">filterfalse</span><span class="token punctuation">(</span>predicate<span class="token punctuation">,</span> iterable<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token comment" spellcheck="true"># filterfalse(lambda x: x%2, range(10)) --> 0 2 4 6 8</span>
<span class="token keyword">if</span> predicate isNone<span class="token punctuation">:</span>
        predicate <span class="token operator">=</span>bool
<span class="token keyword">for</span> x <span class="token keyword">in</span> iterable<span class="token punctuation">:</span>
ifnot predicate<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token keyword">yield</span> x<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>itertools.groupby</code>(<em>iterable</em>, <em>key=None</em>)</p>
<p>创建一个迭代器，返回 <em>iterable</em> 中连续的键和组。<em>key</em> 是一个计算元素键值函数。如果未指定或为 <code>None</code>，<em>key</em> 缺省为恒等函数（identity function），返回元素不变。一般来说，<em>iterable</em> 需用同一个键值函数预先排序。</p>
<p><code>groupby()</code> 操作类似于Unix中的 <code>uniq</code>。当每次 <em>key</em> 函数产生的键值改变时，迭代器会分组或生成一个新组（这就是为什么通常需要使用同一个键值函数先对数据进行排序）。这种行为与SQL的GROUP BY操作不同，SQL的操作会忽略输入的顺序将相同键值的元素分在同组中。</p>
<p>返回的组本身也是一个迭代器，它与 <code>groupby()</code> 共享底层的可迭代对象。因为源是共享的，当 <code>groupby()</code> 对象向后迭代时，前一个组将消失。因此如果稍后还需要返回结果，可保存为列表：</p>
<pre class="line-numbers language-python"><code class="language-python">groups <span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>
uniquekeys <span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>
data <span class="token operator">=</span> sorted<span class="token punctuation">(</span>data<span class="token punctuation">,</span> key<span class="token operator">=</span>keyfunc<span class="token punctuation">)</span>
<span class="token keyword">for</span> k<span class="token punctuation">,</span> g <span class="token keyword">in</span> groupby<span class="token punctuation">(</span>data<span class="token punctuation">,</span> keyfunc<span class="token punctuation">)</span><span class="token punctuation">:</span>
    groups<span class="token punctuation">.</span>append<span class="token punctuation">(</span>list<span class="token punctuation">(</span>g<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># Store group iterator as a list</span>
    uniquekeys<span class="token punctuation">.</span>append<span class="token punctuation">(</span>k<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>groupby()</code> 大致相当于：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">groupby</span><span class="token punctuation">:</span>
<span class="token comment" spellcheck="true"># [k for k, g in groupby('AAAABBBCCDAABBB')] --> A B C D A B</span>
<span class="token comment" spellcheck="true"># [list(g) for k, g in groupby('AAAABBBCCD')] --> AAAA BBB CC D</span>
<span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> iterable<span class="token punctuation">,</span> key<span class="token operator">=</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token keyword">if</span> key isNone<span class="token punctuation">:</span>
            key <span class="token operator">=</span><span class="token keyword">lambda</span> x<span class="token punctuation">:</span> x
self<span class="token punctuation">.</span>keyfunc <span class="token operator">=</span> key
self<span class="token punctuation">.</span>it <span class="token operator">=</span> iter<span class="token punctuation">(</span>iterable<span class="token punctuation">)</span>
self<span class="token punctuation">.</span>tgtkey <span class="token operator">=</span>self<span class="token punctuation">.</span>currkey <span class="token operator">=</span>self<span class="token punctuation">.</span>currvalue <span class="token operator">=</span>object<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">__iter__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
returnself
<span class="token keyword">def</span> <span class="token function">__next__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
self<span class="token punctuation">.</span>id <span class="token operator">=</span>object<span class="token punctuation">(</span><span class="token punctuation">)</span>
whileself<span class="token punctuation">.</span>currkey <span class="token operator">==</span>self<span class="token punctuation">.</span>tgtkey<span class="token punctuation">:</span>
self<span class="token punctuation">.</span>currvalue <span class="token operator">=</span>next<span class="token punctuation">(</span>self<span class="token punctuation">.</span>it<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># Exit on StopIteration</span>
self<span class="token punctuation">.</span>currkey <span class="token operator">=</span>self<span class="token punctuation">.</span>keyfunc<span class="token punctuation">(</span>self<span class="token punctuation">.</span>currvalue<span class="token punctuation">)</span>
self<span class="token punctuation">.</span>tgtkey <span class="token operator">=</span>self<span class="token punctuation">.</span>currkey
<span class="token keyword">return</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>currkey<span class="token punctuation">,</span>self<span class="token punctuation">.</span>_grouper<span class="token punctuation">(</span>self<span class="token punctuation">.</span>tgtkey<span class="token punctuation">,</span>self<span class="token punctuation">.</span>id<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">_grouper</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> tgtkey<span class="token punctuation">,</span> id<span class="token punctuation">)</span><span class="token punctuation">:</span>
whileself<span class="token punctuation">.</span>id <span class="token keyword">is</span> id andself<span class="token punctuation">.</span>currkey <span class="token operator">==</span> tgtkey<span class="token punctuation">:</span>
yieldself<span class="token punctuation">.</span>currvalue
<span class="token keyword">try</span><span class="token punctuation">:</span>
self<span class="token punctuation">.</span>currvalue <span class="token operator">=</span>next<span class="token punctuation">(</span>self<span class="token punctuation">.</span>it<span class="token punctuation">)</span>
exceptStopIteration<span class="token punctuation">:</span>
<span class="token keyword">return</span>
self<span class="token punctuation">.</span>currkey <span class="token operator">=</span>self<span class="token punctuation">.</span>keyfunc<span class="token punctuation">(</span>self<span class="token punctuation">.</span>currvalue<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>itertools.islice</code>(<em>iterable</em>, <em>stop</em>)</p>
<p><code>itertools.islice</code>(<em>iterable</em>, <em>start</em>, <em>stop</em>[, <em>step</em>])</p>
<p>创建一个迭代器，返回从 <em>iterable</em> 里选中的元素。如果 <em>start</em> 不是0，跳过 <em>iterable</em> 中的元素，直到到达 <em>start</em> 这个位置。之后迭代器连续返回元素，除非 <em>step</em> 设置的值很高导致被跳过。如果 <em>stop</em> 为 <code>None</code>，迭代器耗光为止；否则，在指定的位置停止。与普通的切片不同，<code>islice()</code> 不支持将 <em>start</em> ， <em>stop</em> ，或 <em>step</em> 设为负值。可用来从内部数据结构被压平的数据中提取相关字段（例如一个多行报告，它的名称字段出现在每三行上）。大致相当于：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">islice</span><span class="token punctuation">(</span>iterable<span class="token punctuation">,</span><span class="token operator">*</span>args<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token comment" spellcheck="true"># islice('ABCDEFG', 2) --> A B</span>
<span class="token comment" spellcheck="true"># islice('ABCDEFG', 2, 4) --> C D</span>
<span class="token comment" spellcheck="true"># islice('ABCDEFG', 2, None) --> C D E F G</span>
<span class="token comment" spellcheck="true"># islice('ABCDEFG', 0, None, 2) --> A C E G</span>
    s <span class="token operator">=</span> slice<span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">)</span>
    start<span class="token punctuation">,</span> stop<span class="token punctuation">,</span> step <span class="token operator">=</span> s<span class="token punctuation">.</span>start or0<span class="token punctuation">,</span> s<span class="token punctuation">.</span>stop <span class="token operator">or</span> sys<span class="token punctuation">.</span>maxsize<span class="token punctuation">,</span> s<span class="token punctuation">.</span>step or1
    it <span class="token operator">=</span> iter<span class="token punctuation">(</span>range<span class="token punctuation">(</span>start<span class="token punctuation">,</span> stop<span class="token punctuation">,</span> step<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">try</span><span class="token punctuation">:</span>
        nexti <span class="token operator">=</span>next<span class="token punctuation">(</span>it<span class="token punctuation">)</span>
exceptStopIteration<span class="token punctuation">:</span>
<span class="token comment" spellcheck="true"># Consume *iterable* up to the *start* position.</span>
<span class="token keyword">for</span> i<span class="token punctuation">,</span> element <span class="token keyword">in</span> zip<span class="token punctuation">(</span>range<span class="token punctuation">(</span>start<span class="token punctuation">)</span><span class="token punctuation">,</span> iterable<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token keyword">pass</span>
<span class="token keyword">return</span>
<span class="token keyword">try</span><span class="token punctuation">:</span>
<span class="token keyword">for</span> i<span class="token punctuation">,</span> element <span class="token keyword">in</span> enumerate<span class="token punctuation">(</span>iterable<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token keyword">if</span> i <span class="token operator">==</span> nexti<span class="token punctuation">:</span>
<span class="token keyword">yield</span> element
                nexti <span class="token operator">=</span>next<span class="token punctuation">(</span>it<span class="token punctuation">)</span>
exceptStopIteration<span class="token punctuation">:</span>
<span class="token comment" spellcheck="true"># Consume to *stop*.</span>
<span class="token keyword">for</span> i<span class="token punctuation">,</span> element <span class="token keyword">in</span> zip<span class="token punctuation">(</span>range<span class="token punctuation">(</span>i <span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> stop<span class="token punctuation">)</span><span class="token punctuation">,</span> iterable<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token keyword">pass</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果 <em>start</em> 为 <code>None</code>，迭代从0开始。如果 <em>step</em> 为 <code>None</code> ，步长缺省为1。</p>
<p><code>itertools.pairwise</code>(<em>iterable</em>)</p>
<p>返回从输入 <em>iterable</em> 中获取的连续重叠对。</p>
<p>输出迭代器中 2 元组的数量将比输入的数量少一个。 如果输入可迭代对象中少于两个值则它将为空。</p>
<p>大致相当于：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">pairwise</span><span class="token punctuation">(</span>iterable<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token comment" spellcheck="true"># pairwise('ABCDEFG') --> AB BC CD DE EF FG</span>
    a<span class="token punctuation">,</span> b <span class="token operator">=</span> tee<span class="token punctuation">(</span>iterable<span class="token punctuation">)</span>
next<span class="token punctuation">(</span>b<span class="token punctuation">,</span>None<span class="token punctuation">)</span>
<span class="token keyword">return</span> zip<span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>3.10 新版功能.</p>
<p><code>itertools.permutations</code>(<em>iterable</em>, <em>r=None</em>)</p>
<p>连续返回由 <em>iterable</em> 元素生成长度为 <em>r</em> 的排列。</p>
<p>如果 <em>r</em> 未指定或为 <code>None</code> ，<em>r</em> 默认设置为 <em>iterable</em> 的长度，这种情况下，生成所有全长排列。</p>
<p>排列元组会以字典顺序根据所输入 <em>iterable</em> 的顺序发出。 因此，如果所输入 <em>iterable</em> 是已排序的，组合元组也将按已排序的顺序生成。</p>
<p>即使元素的值相同，不同位置的元素也被认为是不同的。如果元素值都不同，每个排列中的元素值不会重复。</p>
<p>大致相当于：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">permutations</span><span class="token punctuation">(</span>iterable<span class="token punctuation">,</span> r<span class="token operator">=</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token comment" spellcheck="true"># permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC</span>
<span class="token comment" spellcheck="true"># permutations(range(3)) --> 012 021 102 120 201 210</span>
    pool <span class="token operator">=</span> tuple<span class="token punctuation">(</span>iterable<span class="token punctuation">)</span>
    n <span class="token operator">=</span> len<span class="token punctuation">(</span>pool<span class="token punctuation">)</span>
    r <span class="token operator">=</span> n <span class="token keyword">if</span> r isNoneelse r
<span class="token keyword">if</span> r <span class="token operator">></span> n<span class="token punctuation">:</span>
<span class="token keyword">return</span>
    indices <span class="token operator">=</span> list<span class="token punctuation">(</span>range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span>
    cycles <span class="token operator">=</span> list<span class="token punctuation">(</span>range<span class="token punctuation">(</span>n<span class="token punctuation">,</span> n<span class="token operator">-</span>r<span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">yield</span> tuple<span class="token punctuation">(</span>pool<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token keyword">for</span> i <span class="token keyword">in</span> indices<span class="token punctuation">[</span><span class="token punctuation">:</span>r<span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token keyword">while</span> n<span class="token punctuation">:</span>
<span class="token keyword">for</span> i <span class="token keyword">in</span> reversed<span class="token punctuation">(</span>range<span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            cycles<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-=</span><span class="token number">1</span>
<span class="token keyword">if</span> cycles<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>
                indices<span class="token punctuation">[</span>i<span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token operator">=</span> indices<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token operator">+</span> indices<span class="token punctuation">[</span>i<span class="token punctuation">:</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span>
                cycles<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span> n <span class="token operator">-</span> i
<span class="token keyword">else</span><span class="token punctuation">:</span>
                j <span class="token operator">=</span> cycles<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
                indices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> indices<span class="token punctuation">[</span><span class="token operator">-</span>j<span class="token punctuation">]</span><span class="token operator">=</span> indices<span class="token punctuation">[</span><span class="token operator">-</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> indices<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
<span class="token keyword">yield</span> tuple<span class="token punctuation">(</span>pool<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token keyword">for</span> i <span class="token keyword">in</span> indices<span class="token punctuation">[</span><span class="token punctuation">:</span>r<span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token keyword">break</span>
<span class="token keyword">else</span><span class="token punctuation">:</span>
<span class="token keyword">return</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>permutations()</code> 的代码也可被改写为 <code>product()</code> 的子序列，只要将含有重复元素（来自输入中同一位置的）的项排除。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">permutations</span><span class="token punctuation">(</span>iterable<span class="token punctuation">,</span> r<span class="token operator">=</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>
    pool <span class="token operator">=</span> tuple<span class="token punctuation">(</span>iterable<span class="token punctuation">)</span>
    n <span class="token operator">=</span> len<span class="token punctuation">(</span>pool<span class="token punctuation">)</span>
    r <span class="token operator">=</span> n <span class="token keyword">if</span> r isNoneelse r
<span class="token keyword">for</span> indices <span class="token keyword">in</span> product<span class="token punctuation">(</span>range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">,</span> repeat<span class="token operator">=</span>r<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token keyword">if</span> len<span class="token punctuation">(</span>set<span class="token punctuation">(</span>indices<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">==</span> r<span class="token punctuation">:</span>
<span class="token keyword">yield</span> tuple<span class="token punctuation">(</span>pool<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token keyword">for</span> i <span class="token keyword">in</span> indices<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>当 <code>0 &lt;= r &lt;= n</code> ，返回项个数为 <code>n! / (n-r)!</code> ；当 <code>r &gt; n</code> ，返回项个数为0。</p>
<p><code>itertools.product</code>(<em>\</em>iterables<em>,</em> repeat=1*)</p>
<p>可迭代对象输入的笛卡儿积。</p>
<p>大致相当于生成器表达式中的嵌套循环。例如， <code>product(A, B)</code> 和 <code>((x,y) for x in A for y in B)</code> 返回结果一样。</p>
<p>嵌套循环像里程表那样循环变动，每次迭代时将最右侧的元素向后迭代。这种模式形成了一种字典序，因此如果输入的可迭代对象是已排序的，笛卡尔积元组依次序发出。</p>
<p>要计算可迭代对象自身的笛卡尔积，将可选参数 <em>repeat</em> 设定为要重复的次数。例如，<code>product(A, repeat=4)</code> 和 <code>product(A, A, A, A)</code> 是一样的。</p>
<p>该函数大致相当于下面的代码，只不过实际实现方案不会在内存中创建中间结果。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">product</span><span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> repeat<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token comment" spellcheck="true"># product('ABCD', 'xy') --> Ax Ay Bx By Cx Cy Dx Dy</span>
<span class="token comment" spellcheck="true"># product(range(2), repeat=3) --> 000 001 010 011 100 101 110 111</span>
    pools <span class="token operator">=</span><span class="token punctuation">[</span>tuple<span class="token punctuation">(</span>pool<span class="token punctuation">)</span><span class="token keyword">for</span> pool <span class="token keyword">in</span> args<span class="token punctuation">]</span><span class="token operator">*</span> repeat
    result <span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
<span class="token keyword">for</span> pool <span class="token keyword">in</span> pools<span class="token punctuation">:</span>
        result <span class="token operator">=</span><span class="token punctuation">[</span>x<span class="token operator">+</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token keyword">for</span> x <span class="token keyword">in</span> result <span class="token keyword">for</span> y <span class="token keyword">in</span> pool<span class="token punctuation">]</span>
<span class="token keyword">for</span> prod <span class="token keyword">in</span> result<span class="token punctuation">:</span>
<span class="token keyword">yield</span> tuple<span class="token punctuation">(</span>prod<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在 <code>product()</code> 运行之前，它会完全耗尽输入的可迭代对象，在内存中保留值的临时池以生成结果积。 相应地，它只适用于有限的输入。</p>
<p><code>itertools.repeat</code>(<em>object</em>[, <em>times</em>])</p>
<p>创建一个迭代器，不断重复 <em>object</em> 。除非设定参数 <em>times</em> ，否则将无限重复。可用于 <code>map()</code> 函数中的参数，被调用函数可得到一个不变参数。也可用于 <code>zip()</code> 的参数以在元组记录中创建一个不变的部分。</p>
<p>大致相当于：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">repeat</span><span class="token punctuation">(</span>object<span class="token punctuation">,</span> times<span class="token operator">=</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token comment" spellcheck="true"># repeat(10, 3) --> 10 10 10</span>
<span class="token keyword">if</span> times isNone<span class="token punctuation">:</span>
whileTrue<span class="token punctuation">:</span>
yieldobject
<span class="token keyword">else</span><span class="token punctuation">:</span>
<span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>times<span class="token punctuation">)</span><span class="token punctuation">:</span>
yieldobject<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><em>repeat</em> 最常见的用途就是在 <em>map</em> 或 <em>zip</em> 提供一个常量流：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> list<span class="token punctuation">(</span>map<span class="token punctuation">(</span>pow<span class="token punctuation">,</span> range<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span> repeat<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">16</span><span class="token punctuation">,</span><span class="token number">25</span><span class="token punctuation">,</span><span class="token number">36</span><span class="token punctuation">,</span><span class="token number">49</span><span class="token punctuation">,</span><span class="token number">64</span><span class="token punctuation">,</span><span class="token number">81</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><code>itertools.starmap</code>(<em>function</em>, <em>iterable</em>)</p>
<p>创建一个迭代器，使用从可迭代对象中获取的参数来计算该函数。当参数对应的形参已从一个单独可迭代对象组合为元组时（数据已被“预组对”）可用此函数代替 <code>map()</code>。<code>map()</code> 与 <code>starmap()</code> 之间的区别可以类比 <code>function(a,b)</code> 与 <code>function(*c)</code> 的区别。大致相当于:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">starmap</span><span class="token punctuation">(</span>function<span class="token punctuation">,</span> iterable<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token comment" spellcheck="true"># starmap(pow, [(2,5), (3,2), (10,3)]) --> 32 9 1000</span>
<span class="token keyword">for</span> args <span class="token keyword">in</span> iterable<span class="token punctuation">:</span>
yieldfunction<span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>itertools.takewhile</code>(<em>predicate</em>, <em>iterable</em>)</p>
<p>创建一个迭代器，只要 predicate 为真就从可迭代对象中返回元素。大致相当于:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">takewhile</span><span class="token punctuation">(</span>predicate<span class="token punctuation">,</span> iterable<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token comment" spellcheck="true"># takewhile(lambda x: x&lt;5, [1,4,6,4,1]) --> 1 4</span>
<span class="token keyword">for</span> x <span class="token keyword">in</span> iterable<span class="token punctuation">:</span>
<span class="token keyword">if</span> predicate<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token keyword">yield</span> x
<span class="token keyword">else</span><span class="token punctuation">:</span>
<span class="token keyword">break</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>itertools.tee</code>(<em>iterable</em>, <em>n=2</em>)</p>
<p>从一个可迭代对象中返回 <em>n</em> 个独立的迭代器。</p>
<p>下面的Python代码能帮助解释 <em>tee</em> 做了什么（尽管实际的实现更复杂，而且仅使用了一个底层的 FIFO 队列）。</p>
<p>大致相当于：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">tee</span><span class="token punctuation">(</span>iterable<span class="token punctuation">,</span> n<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    it <span class="token operator">=</span> iter<span class="token punctuation">(</span>iterable<span class="token punctuation">)</span>
    deques <span class="token operator">=</span><span class="token punctuation">[</span>collections<span class="token punctuation">.</span>deque<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token keyword">def</span> <span class="token function">gen</span><span class="token punctuation">(</span>mydeque<span class="token punctuation">)</span><span class="token punctuation">:</span>
whileTrue<span class="token punctuation">:</span>
ifnot mydeque<span class="token punctuation">:</span><span class="token comment" spellcheck="true"># when the local deque is empty</span>
<span class="token keyword">try</span><span class="token punctuation">:</span>
                    newval <span class="token operator">=</span>next<span class="token punctuation">(</span>it<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># fetch a new value and</span>
exceptStopIteration<span class="token punctuation">:</span>
<span class="token keyword">return</span>
<span class="token keyword">for</span> d <span class="token keyword">in</span> deques<span class="token punctuation">:</span><span class="token comment" spellcheck="true"># load it to all the deques</span>
                    d<span class="token punctuation">.</span>append<span class="token punctuation">(</span>newval<span class="token punctuation">)</span>
<span class="token keyword">yield</span> mydeque<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">return</span> tuple<span class="token punctuation">(</span>gen<span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token keyword">for</span> d <span class="token keyword">in</span> deques<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>一旦 <code>tee()</code> 实施了一次分裂，原有的 <em>iterable</em> 不应再被使用；否则tee对象无法得知 <em>iterable</em> 可能已向后迭代。</p>
<p><code>tee</code> 迭代器不是线程安全的。当同时使用由同一个 <code>tee()</code> 调用所返回的迭代器时可能引发 <code>RuntimeError</code>，即使原本的 <em>iterable</em> 是线程安全的。</p>
<p>该迭代工具可能需要相当大的辅助存储空间（这取决于要保存多少临时数据）。通常，如果一个迭代器在另一个迭代器开始之前就要使用大部份或全部数据，使用 <code>list()</code> 会比 <code>tee()</code> 更快。</p>
<p><code>itertools.zip_longest</code>(<em>\</em>iterables<em>,</em> fillvalue=None*)</p>
<p>创建一个迭代器，从每个可迭代对象中收集元素。如果可迭代对象的长度未对齐，将根据 <em>fillvalue</em> 填充缺失值。迭代持续到耗光最长的可迭代对象。大致相当于：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">zip_longest</span><span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> fillvalue<span class="token operator">=</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token comment" spellcheck="true"># zip_longest('ABCD', 'xy', fillvalue='-') --> Ax By C- D-</span>
    iterators <span class="token operator">=</span><span class="token punctuation">[</span>iter<span class="token punctuation">(</span>it<span class="token punctuation">)</span><span class="token keyword">for</span> it <span class="token keyword">in</span> args<span class="token punctuation">]</span>
    num_active <span class="token operator">=</span> len<span class="token punctuation">(</span>iterators<span class="token punctuation">)</span>
ifnot num_active<span class="token punctuation">:</span>
<span class="token keyword">return</span>
whileTrue<span class="token punctuation">:</span>
        values <span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token keyword">for</span> i<span class="token punctuation">,</span> it <span class="token keyword">in</span> enumerate<span class="token punctuation">(</span>iterators<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token keyword">try</span><span class="token punctuation">:</span>
                value <span class="token operator">=</span>next<span class="token punctuation">(</span>it<span class="token punctuation">)</span>
exceptStopIteration<span class="token punctuation">:</span>
                num_active <span class="token operator">-=</span><span class="token number">1</span>
ifnot num_active<span class="token punctuation">:</span>
<span class="token keyword">return</span>
                iterators<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span> repeat<span class="token punctuation">(</span>fillvalue<span class="token punctuation">)</span>
                value <span class="token operator">=</span> fillvalue
            values<span class="token punctuation">.</span>append<span class="token punctuation">(</span>value<span class="token punctuation">)</span>
<span class="token keyword">yield</span> tuple<span class="token punctuation">(</span>values<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果其中一个可迭代对象有无限长度，<code>zip_longest()</code> 函数应封装在限制调用次数的场景中（例如 <code>islice()</code> 或 <code>takewhile()</code>）。除非指定， <em>fillvalue</em> 默认为 <code>None</code> 。</p>
<h3 id="itertools-配方"><a href="#itertools-配方" class="headerlink" title="itertools 配方"></a>itertools 配方</h3><p>本节将展示如何使用现有的 itertools 作为基础构件来创建扩展的工具集。</p>
<p>基本上所有这些西方和许许多多其他的配方都可以通过 Python Package Index 上的 more-itertools 项目 来安装:</p>
<pre><code>pip install more-itertools</code></pre><p>扩展的工具提供了与底层工具集相同的高性能。保持了超棒的内存利用率，因为一次只处理一个元素，而不是将整个可迭代对象加载到内存。代码量保持得很小，以函数式风格将这些工具连接在一起，有助于消除临时变量。速度依然很快，因为倾向于使用“矢量化”构件来取代解释器开销大的 for 循环和 generator 。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">take</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> iterable<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token string">"Return first n items of the iterable as a list"</span>
<span class="token keyword">return</span> list<span class="token punctuation">(</span>islice<span class="token punctuation">(</span>iterable<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">prepend</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> iterator<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token string">"Prepend a single value in front of an iterator"</span>
<span class="token comment" spellcheck="true"># prepend(1, [2, 3, 4]) -> 1 2 3 4</span>
<span class="token keyword">return</span> chain<span class="token punctuation">(</span><span class="token punctuation">[</span>value<span class="token punctuation">]</span><span class="token punctuation">,</span> iterator<span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">tabulate</span><span class="token punctuation">(</span>function<span class="token punctuation">,</span> start<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token string">"Return function(0), function(1), ..."</span>
<span class="token keyword">return</span> map<span class="token punctuation">(</span>function<span class="token punctuation">,</span> count<span class="token punctuation">(</span>start<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">tail</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> iterable<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token string">"Return an iterator over the last n items"</span>
<span class="token comment" spellcheck="true"># tail(3, 'ABCDEFG') --> E F G</span>
<span class="token keyword">return</span> iter<span class="token punctuation">(</span>collections<span class="token punctuation">.</span>deque<span class="token punctuation">(</span>iterable<span class="token punctuation">,</span> maxlen<span class="token operator">=</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">consume</span><span class="token punctuation">(</span>iterator<span class="token punctuation">,</span> n<span class="token operator">=</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token string">"Advance the iterator n-steps ahead. If n is None, consume entirely."</span>
<span class="token comment" spellcheck="true"># Use functions that consume iterators at C speed.</span>
<span class="token keyword">if</span> n isNone<span class="token punctuation">:</span>
<span class="token comment" spellcheck="true"># feed the entire iterator into a zero-length deque</span>
        collections<span class="token punctuation">.</span>deque<span class="token punctuation">(</span>iterator<span class="token punctuation">,</span> maxlen<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span>
<span class="token keyword">else</span><span class="token punctuation">:</span>
<span class="token comment" spellcheck="true"># advance to the empty slice starting at position n</span>
next<span class="token punctuation">(</span>islice<span class="token punctuation">(</span>iterator<span class="token punctuation">,</span> n<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">,</span>None<span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">nth</span><span class="token punctuation">(</span>iterable<span class="token punctuation">,</span> n<span class="token punctuation">,</span>default<span class="token operator">=</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token string">"Returns the nth item or a default value"</span>
returnnext<span class="token punctuation">(</span>islice<span class="token punctuation">(</span>iterable<span class="token punctuation">,</span> n<span class="token punctuation">,</span>None<span class="token punctuation">)</span><span class="token punctuation">,</span>default<span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">all_equal</span><span class="token punctuation">(</span>iterable<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token string">"Returns True if all the elements are equal to each other"</span>
    g <span class="token operator">=</span> groupby<span class="token punctuation">(</span>iterable<span class="token punctuation">)</span>
returnnext<span class="token punctuation">(</span>g<span class="token punctuation">,</span><span class="token boolean">True</span><span class="token punctuation">)</span>andnotnext<span class="token punctuation">(</span>g<span class="token punctuation">,</span><span class="token boolean">False</span><span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">quantify</span><span class="token punctuation">(</span>iterable<span class="token punctuation">,</span> pred<span class="token operator">=</span>bool<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token string">"Count how many times the predicate is true"</span>
<span class="token keyword">return</span> sum<span class="token punctuation">(</span>map<span class="token punctuation">(</span>pred<span class="token punctuation">,</span> iterable<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">pad_none</span><span class="token punctuation">(</span>iterable<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token triple-quoted-string string">"""Returns the sequence elements and then returns None indefinitely.
    Useful for emulating the behavior of the built-in map() function.
    """</span>
<span class="token keyword">return</span> chain<span class="token punctuation">(</span>iterable<span class="token punctuation">,</span> repeat<span class="token punctuation">(</span>None<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">ncycles</span><span class="token punctuation">(</span>iterable<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token string">"Returns the sequence elements n times"</span>
<span class="token keyword">return</span> chain<span class="token punctuation">.</span>from_iterable<span class="token punctuation">(</span>repeat<span class="token punctuation">(</span>tuple<span class="token punctuation">(</span>iterable<span class="token punctuation">)</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">dotproduct</span><span class="token punctuation">(</span>vec1<span class="token punctuation">,</span> vec2<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token keyword">return</span> sum<span class="token punctuation">(</span>map<span class="token punctuation">(</span>operator<span class="token punctuation">.</span>mul<span class="token punctuation">,</span> vec1<span class="token punctuation">,</span> vec2<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">convolve</span><span class="token punctuation">(</span>signal<span class="token punctuation">,</span> kernel<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token comment" spellcheck="true"># See:  https://betterexplained.com/articles/intuitive-convolution/</span>
<span class="token comment" spellcheck="true"># convolve(data, [0.25, 0.25, 0.25, 0.25]) --> Moving average (blur)</span>
<span class="token comment" spellcheck="true"># convolve(data, [1, -1]) --> 1st finite difference (1st derivative)</span>
<span class="token comment" spellcheck="true"># convolve(data, [1, -2, 1]) --> 2nd finite difference (2nd derivative)</span>
    kernel <span class="token operator">=</span> tuple<span class="token punctuation">(</span>kernel<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>
    n <span class="token operator">=</span> len<span class="token punctuation">(</span>kernel<span class="token punctuation">)</span>
    window <span class="token operator">=</span> collections<span class="token punctuation">.</span>deque<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> maxlen<span class="token operator">=</span>n<span class="token punctuation">)</span><span class="token operator">*</span> n
<span class="token keyword">for</span> x <span class="token keyword">in</span> chain<span class="token punctuation">(</span>signal<span class="token punctuation">,</span> repeat<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> n<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        window<span class="token punctuation">.</span>append<span class="token punctuation">(</span>x<span class="token punctuation">)</span>
<span class="token keyword">yield</span> sum<span class="token punctuation">(</span>map<span class="token punctuation">(</span>operator<span class="token punctuation">.</span>mul<span class="token punctuation">,</span> kernel<span class="token punctuation">,</span> window<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">flatten</span><span class="token punctuation">(</span>list_of_lists<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token string">"Flatten one level of nesting"</span>
<span class="token keyword">return</span> chain<span class="token punctuation">.</span>from_iterable<span class="token punctuation">(</span>list_of_lists<span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">repeatfunc</span><span class="token punctuation">(</span>func<span class="token punctuation">,</span> times<span class="token operator">=</span>None<span class="token punctuation">,</span><span class="token operator">*</span>args<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token triple-quoted-string string">"""Repeat calls to func with specified arguments.
    Example:  repeatfunc(random.random)
    """</span>
<span class="token keyword">if</span> times isNone<span class="token punctuation">:</span>
<span class="token keyword">return</span> starmap<span class="token punctuation">(</span>func<span class="token punctuation">,</span> repeat<span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">return</span> starmap<span class="token punctuation">(</span>func<span class="token punctuation">,</span> repeat<span class="token punctuation">(</span>args<span class="token punctuation">,</span> times<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">grouper</span><span class="token punctuation">(</span>iterable<span class="token punctuation">,</span> n<span class="token punctuation">,</span> fillvalue<span class="token operator">=</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token string">"Collect data into non-overlapping fixed-length chunks or blocks"</span>
<span class="token comment" spellcheck="true"># grouper('ABCDEFG', 3, 'x') --> ABC DEF Gxx</span>
    args <span class="token operator">=</span><span class="token punctuation">[</span>iter<span class="token punctuation">(</span>iterable<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token operator">*</span> n
<span class="token keyword">return</span> zip_longest<span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> fillvalue<span class="token operator">=</span>fillvalue<span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">triplewise</span><span class="token punctuation">(</span>iterable<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token string">"Return overlapping triplets from an iterable"</span>
<span class="token comment" spellcheck="true"># triplewise('ABCDEFG') -> ABC BCD CDE DEF EFG</span>
<span class="token keyword">for</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> _<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token keyword">in</span> pairwise<span class="token punctuation">(</span>pairwise<span class="token punctuation">(</span>iterable<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token keyword">yield</span> a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c
<span class="token keyword">def</span> <span class="token function">sliding_window</span><span class="token punctuation">(</span>iterable<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token comment" spellcheck="true"># sliding_window('ABCDEFG', 4) -> ABCD BCDE CDEF DEFG</span>
    it <span class="token operator">=</span> iter<span class="token punctuation">(</span>iterable<span class="token punctuation">)</span>
    window <span class="token operator">=</span> collections<span class="token punctuation">.</span>deque<span class="token punctuation">(</span>islice<span class="token punctuation">(</span>it<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">,</span> maxlen<span class="token operator">=</span>n<span class="token punctuation">)</span>
<span class="token keyword">if</span> len<span class="token punctuation">(</span>window<span class="token punctuation">)</span><span class="token operator">==</span> n<span class="token punctuation">:</span>
<span class="token keyword">yield</span> tuple<span class="token punctuation">(</span>window<span class="token punctuation">)</span>
<span class="token keyword">for</span> x <span class="token keyword">in</span> it<span class="token punctuation">:</span>
        window<span class="token punctuation">.</span>append<span class="token punctuation">(</span>x<span class="token punctuation">)</span>
<span class="token keyword">yield</span> tuple<span class="token punctuation">(</span>window<span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">roundrobin</span><span class="token punctuation">(</span><span class="token operator">*</span>iterables<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token string">"roundrobin('ABC', 'D', 'EF') --> A D E B F C"</span>
<span class="token comment" spellcheck="true"># Recipe credited to George Sakkis</span>
    num_active <span class="token operator">=</span> len<span class="token punctuation">(</span>iterables<span class="token punctuation">)</span>
    nexts <span class="token operator">=</span> cycle<span class="token punctuation">(</span>iter<span class="token punctuation">(</span>it<span class="token punctuation">)</span><span class="token punctuation">.</span>__next__ <span class="token keyword">for</span> it <span class="token keyword">in</span> iterables<span class="token punctuation">)</span>
<span class="token keyword">while</span> num_active<span class="token punctuation">:</span>
<span class="token keyword">try</span><span class="token punctuation">:</span>
fornextin nexts<span class="token punctuation">:</span>
yieldnext<span class="token punctuation">(</span><span class="token punctuation">)</span>
exceptStopIteration<span class="token punctuation">:</span>
<span class="token comment" spellcheck="true"># Remove the iterator we just exhausted from the cycle.</span>
            num_active <span class="token operator">-=</span><span class="token number">1</span>
            nexts <span class="token operator">=</span> cycle<span class="token punctuation">(</span>islice<span class="token punctuation">(</span>nexts<span class="token punctuation">,</span> num_active<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">partition</span><span class="token punctuation">(</span>pred<span class="token punctuation">,</span> iterable<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token string">"Use a predicate to partition entries into false entries and true entries"</span>
<span class="token comment" spellcheck="true"># partition(is_odd, range(10)) --> 0 2 4 6 8   and  1 3 5 7 9</span>
    t1<span class="token punctuation">,</span> t2 <span class="token operator">=</span> tee<span class="token punctuation">(</span>iterable<span class="token punctuation">)</span>
<span class="token keyword">return</span> filterfalse<span class="token punctuation">(</span>pred<span class="token punctuation">,</span> t1<span class="token punctuation">)</span><span class="token punctuation">,</span> filter<span class="token punctuation">(</span>pred<span class="token punctuation">,</span> t2<span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">before_and_after</span><span class="token punctuation">(</span>predicate<span class="token punctuation">,</span> it<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token triple-quoted-string string">""" Variant of takewhile() that allows complete
        access to the remainder of the iterator.
        >>> it = iter('ABCdEfGhI')
        >>> all_upper, remainder = before_and_after(str.isupper, it)
        >>> ''.join(all_upper)
        'ABC'
        >>> ''.join(remainder)     # takewhile() would lose the 'd'
        'dEfGhI'
        Note that the first iterator must be fully
        consumed before the second iterator can
        generate valid results.
    """</span>
    it <span class="token operator">=</span> iter<span class="token punctuation">(</span>it<span class="token punctuation">)</span>
    transition <span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token keyword">def</span> <span class="token function">true_iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token keyword">for</span> elem <span class="token keyword">in</span> it<span class="token punctuation">:</span>
<span class="token keyword">if</span> predicate<span class="token punctuation">(</span>elem<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token keyword">yield</span> elem
<span class="token keyword">else</span><span class="token punctuation">:</span>
                transition<span class="token punctuation">.</span>append<span class="token punctuation">(</span>elem<span class="token punctuation">)</span>
<span class="token keyword">return</span>
<span class="token keyword">def</span> <span class="token function">remainder_iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
yieldfrom transition
yieldfrom it
<span class="token keyword">return</span> true_iterator<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> remainder_iterator<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">powerset</span><span class="token punctuation">(</span>iterable<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token string">"powerset([1,2,3]) --> () (1,) (2,) (3,) (1,2) (1,3) (2,3) (1,2,3)"</span>
    s <span class="token operator">=</span> list<span class="token punctuation">(</span>iterable<span class="token punctuation">)</span>
<span class="token keyword">return</span> chain<span class="token punctuation">.</span>from_iterable<span class="token punctuation">(</span>combinations<span class="token punctuation">(</span>s<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token keyword">for</span> r <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">unique_everseen</span><span class="token punctuation">(</span>iterable<span class="token punctuation">,</span> key<span class="token operator">=</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token string">"List unique elements, preserving order. Remember all elements ever seen."</span>
<span class="token comment" spellcheck="true"># unique_everseen('AAAABBBCCDAABBB') --> A B C D</span>
<span class="token comment" spellcheck="true"># unique_everseen('ABBCcAD', str.lower) --> A B C D</span>
    seen <span class="token operator">=</span>set<span class="token punctuation">(</span><span class="token punctuation">)</span>
    seen_add <span class="token operator">=</span> seen<span class="token punctuation">.</span>add
<span class="token keyword">if</span> key isNone<span class="token punctuation">:</span>
<span class="token keyword">for</span> element <span class="token keyword">in</span> filterfalse<span class="token punctuation">(</span>seen<span class="token punctuation">.</span>__contains__<span class="token punctuation">,</span> iterable<span class="token punctuation">)</span><span class="token punctuation">:</span>
            seen_add<span class="token punctuation">(</span>element<span class="token punctuation">)</span>
<span class="token keyword">yield</span> element
<span class="token keyword">else</span><span class="token punctuation">:</span>
<span class="token keyword">for</span> element <span class="token keyword">in</span> iterable<span class="token punctuation">:</span>
            k <span class="token operator">=</span> key<span class="token punctuation">(</span>element<span class="token punctuation">)</span>
<span class="token keyword">if</span> k notin seen<span class="token punctuation">:</span>
                seen_add<span class="token punctuation">(</span>k<span class="token punctuation">)</span>
<span class="token keyword">yield</span> element
<span class="token keyword">def</span> <span class="token function">unique_justseen</span><span class="token punctuation">(</span>iterable<span class="token punctuation">,</span> key<span class="token operator">=</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token string">"List unique elements, preserving order. Remember only the element just seen."</span>
<span class="token comment" spellcheck="true"># unique_justseen('AAAABBBCCDAABBB') --> A B C D A B</span>
<span class="token comment" spellcheck="true"># unique_justseen('ABBCcAD', str.lower) --> A B C A D</span>
<span class="token keyword">return</span> map<span class="token punctuation">(</span>next<span class="token punctuation">,</span> map<span class="token punctuation">(</span>operator<span class="token punctuation">.</span>itemgetter<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> groupby<span class="token punctuation">(</span>iterable<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">iter_except</span><span class="token punctuation">(</span>func<span class="token punctuation">,</span> exception<span class="token punctuation">,</span> first<span class="token operator">=</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token triple-quoted-string string">""" Call a function repeatedly until an exception is raised.
    Converts a call-until-exception interface to an iterator interface.
    Like builtins.iter(func, sentinel) but uses an exception instead
    of a sentinel to end the loop.
    Examples:
        iter_except(functools.partial(heappop, h), IndexError)   # priority queue iterator
        iter_except(d.popitem, KeyError)                         # non-blocking dict iterator
        iter_except(d.popleft, IndexError)                       # non-blocking deque iterator
        iter_except(q.get_nowait, Queue.Empty)                   # loop over a producer Queue
        iter_except(s.pop, KeyError)                             # non-blocking set iterator
    """</span>
<span class="token keyword">try</span><span class="token punctuation">:</span>
<span class="token keyword">if</span> first isnotNone<span class="token punctuation">:</span>
<span class="token keyword">yield</span> first<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># For database APIs needing an initial cast to db.first()</span>
whileTrue<span class="token punctuation">:</span>
<span class="token keyword">yield</span> func<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">except</span> exception<span class="token punctuation">:</span>
<span class="token keyword">pass</span>
<span class="token keyword">def</span> <span class="token function">first_true</span><span class="token punctuation">(</span>iterable<span class="token punctuation">,</span>default<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">,</span> pred<span class="token operator">=</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token triple-quoted-string string">"""Returns the first true value in the iterable.
    If no true value is found, returns *default*
    If *pred* is not None, returns the first item
    for which pred(item) is true.
    """</span>
<span class="token comment" spellcheck="true"># first_true([a,b,c], x) --> a or b or c or x</span>
<span class="token comment" spellcheck="true"># first_true([a,b], x, f) --> a if f(a) else b if f(b) else x</span>
returnnext<span class="token punctuation">(</span>filter<span class="token punctuation">(</span>pred<span class="token punctuation">,</span> iterable<span class="token punctuation">)</span><span class="token punctuation">,</span>default<span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">random_product</span><span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> repeat<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token string">"Random selection from itertools.product(*args, **kwds)"</span>
    pools <span class="token operator">=</span><span class="token punctuation">[</span>tuple<span class="token punctuation">(</span>pool<span class="token punctuation">)</span><span class="token keyword">for</span> pool <span class="token keyword">in</span> args<span class="token punctuation">]</span><span class="token operator">*</span> repeat
<span class="token keyword">return</span> tuple<span class="token punctuation">(</span>map<span class="token punctuation">(</span>random<span class="token punctuation">.</span>choice<span class="token punctuation">,</span> pools<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">random_permutation</span><span class="token punctuation">(</span>iterable<span class="token punctuation">,</span> r<span class="token operator">=</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token string">"Random selection from itertools.permutations(iterable, r)"</span>
    pool <span class="token operator">=</span> tuple<span class="token punctuation">(</span>iterable<span class="token punctuation">)</span>
    r <span class="token operator">=</span> len<span class="token punctuation">(</span>pool<span class="token punctuation">)</span><span class="token keyword">if</span> r isNoneelse r
<span class="token keyword">return</span> tuple<span class="token punctuation">(</span>random<span class="token punctuation">.</span>sample<span class="token punctuation">(</span>pool<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">random_combination</span><span class="token punctuation">(</span>iterable<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token string">"Random selection from itertools.combinations(iterable, r)"</span>
    pool <span class="token operator">=</span> tuple<span class="token punctuation">(</span>iterable<span class="token punctuation">)</span>
    n <span class="token operator">=</span> len<span class="token punctuation">(</span>pool<span class="token punctuation">)</span>
    indices <span class="token operator">=</span> sorted<span class="token punctuation">(</span>random<span class="token punctuation">.</span>sample<span class="token punctuation">(</span>range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">return</span> tuple<span class="token punctuation">(</span>pool<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token keyword">for</span> i <span class="token keyword">in</span> indices<span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">random_combination_with_replacement</span><span class="token punctuation">(</span>iterable<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token string">"Random selection from itertools.combinations_with_replacement(iterable, r)"</span>
    pool <span class="token operator">=</span> tuple<span class="token punctuation">(</span>iterable<span class="token punctuation">)</span>
    n <span class="token operator">=</span> len<span class="token punctuation">(</span>pool<span class="token punctuation">)</span>
    indices <span class="token operator">=</span> sorted<span class="token punctuation">(</span>random<span class="token punctuation">.</span>choices<span class="token punctuation">(</span>range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">,</span> k<span class="token operator">=</span>r<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">return</span> tuple<span class="token punctuation">(</span>pool<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token keyword">for</span> i <span class="token keyword">in</span> indices<span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">nth_combination</span><span class="token punctuation">(</span>iterable<span class="token punctuation">,</span> r<span class="token punctuation">,</span> index<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token string">"Equivalent to list(combinations(iterable, r))[index]"</span>
    pool <span class="token operator">=</span> tuple<span class="token punctuation">(</span>iterable<span class="token punctuation">)</span>
    n <span class="token operator">=</span> len<span class="token punctuation">(</span>pool<span class="token punctuation">)</span>
<span class="token keyword">if</span> r <span class="token operator">&lt;</span>0or r <span class="token operator">></span> n<span class="token punctuation">:</span>
raiseValueError
    c <span class="token operator">=</span><span class="token number">1</span>
    k <span class="token operator">=</span> min<span class="token punctuation">(</span>r<span class="token punctuation">,</span> n<span class="token operator">-</span>r<span class="token punctuation">)</span>
<span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> k<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        c <span class="token operator">=</span> c <span class="token operator">*</span><span class="token punctuation">(</span>n <span class="token operator">-</span> k <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token operator">//</span> i
<span class="token keyword">if</span> index <span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">:</span>
        index <span class="token operator">+=</span> c
<span class="token keyword">if</span> index <span class="token operator">&lt;</span>0or index <span class="token operator">>=</span> c<span class="token punctuation">:</span>
raiseIndexError
    result <span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token keyword">while</span> r<span class="token punctuation">:</span>
        c<span class="token punctuation">,</span> n<span class="token punctuation">,</span> r <span class="token operator">=</span> c<span class="token operator">*</span>r<span class="token operator">//</span>n<span class="token punctuation">,</span> n<span class="token number">-1</span><span class="token punctuation">,</span> r<span class="token number">-1</span>
<span class="token keyword">while</span> index <span class="token operator">>=</span> c<span class="token punctuation">:</span>
            index <span class="token operator">-=</span> c
            c<span class="token punctuation">,</span> n <span class="token operator">=</span> c<span class="token operator">*</span><span class="token punctuation">(</span>n<span class="token operator">-</span>r<span class="token punctuation">)</span><span class="token operator">//</span>n<span class="token punctuation">,</span> n<span class="token number">-1</span>
        result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>pool<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>n<span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token keyword">return</span> tuple<span class="token punctuation">(</span>result<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="functools-—-高阶函数和可调用对象上的操作"><a href="#functools-—-高阶函数和可调用对象上的操作" class="headerlink" title="functools —- 高阶函数和可调用对象上的操作"></a><code>functools</code> —- 高阶函数和可调用对象上的操作</h2><p><strong>源代码:</strong> <a href="https://github.com/python/cpython/tree/3.10/Lib/functools.py" target="_blank" rel="noopener">Lib/functools.py</a></p>
<hr>
<p><code>functools</code> 模块应用于高阶函数，即参数或（和）返回值为其他函数的函数。 通常来说，此模块的功能适用于所有可调用对象。</p>
<p><code>functools</code> 模块定义了以下函数:</p>
<p><code>@functools.cache</code>(<em>user_function</em>)</p>
<p>简单轻量级未绑定函数缓存。 有时称为 “memoize”。</p>
<p>返回值与 <code>lru_cache(maxsize=None)</code> 相同，创建一个查找函数参数的字典的简单包装器。 因为它不需要移出旧值，所以比带有大小限制的 <code>lru_cache()</code> 更小更快。</p>
<p>例如：</p>
<pre class="line-numbers language-python"><code class="language-python">@cache
<span class="token keyword">def</span> <span class="token function">factorial</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">return</span> n <span class="token operator">*</span> factorial<span class="token punctuation">(</span>n<span class="token number">-1</span><span class="token punctuation">)</span> <span class="token keyword">if</span> n <span class="token keyword">else</span> <span class="token number">1</span>
<span class="token operator">>></span><span class="token operator">></span> factorial<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span>      <span class="token comment" spellcheck="true"># no previously cached result, makes 11 recursive calls</span>
<span class="token number">3628800</span>
<span class="token operator">>></span><span class="token operator">></span> factorial<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>       <span class="token comment" spellcheck="true"># just looks up cached value result</span>
<span class="token number">120</span>
<span class="token operator">>></span><span class="token operator">></span> factorial<span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">)</span>      <span class="token comment" spellcheck="true"># makes two new recursive calls, the other 10 are cached</span>
<span class="token number">479001600</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>3.9 新版功能.</p>
<p><code>@functools.cached_property</code>(<em>func</em>)</p>
<p>将一个类方法转换为特征属性，一次性计算该特征属性的值，然后将其缓存为实例生命周期内的普通属性。 类似于 <code>property()</code> 但增加了缓存功能。 对于在其他情况下实际不可变的高计算资源消耗的实例特征属性来说该函数非常有用。</p>
<p>示例:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">DataSet</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> sequence_of_numbers<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>_data <span class="token operator">=</span> tuple<span class="token punctuation">(</span>sequence_of_numbers<span class="token punctuation">)</span>
    @cached_property
    <span class="token keyword">def</span> <span class="token function">stdev</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> statistics<span class="token punctuation">.</span>stdev<span class="token punctuation">(</span>self<span class="token punctuation">.</span>_data<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>cached_property()</code> 的设定与 <code>property()</code> 有所不同。 常规的 property 会阻止属性写入，除非定义了 setter。 与之相反，<em>cached_property</em> 则允许写入。</p>
<p><em>cached_property</em> 装饰器仅在执行查找且不存在同名属性时才会运行。 当运行时，<em>cached_property</em> 会写入同名的属性。 后续的属性读取和写入操作会优先于 <em>cached_property</em> 方法，其行为就像普通的属性一样。</p>
<p>缓存的值可通过删除该属性来清空。 这允许 <em>cached_property</em> 方法再次运行。</p>
<p>注意，这个装饰器会影响 <a href="https://www.python.org/dev/peps/pep-0412" target="_blank" rel="noopener"><strong>PEP 412</strong></a> 键共享字典的操作。 这意味着相应的字典实例可能占用比通常时更多的空间。</p>
<p>而且，这个装饰器要求每个实例上的 <code>__dict__</code> 是可变的映射。 这意味着它将不适用于某些类型，例如元类（因为类型实例上的 <code>__dict__</code> 属性是类命名空间的只读代理），以及那些指定了 <code>__slots__</code> 但未包括 <code>__dict__</code> 作为所定义的空位之一的类（因为这样的类根本没有提供 <code>__dict__</code> 属性）。</p>
<p>如果可变的映射不可用或者如果想要节省空间的键共享，可以通过在 <code>cache()</code> 之上堆叠一个 <code>property()</code> 来实现类似 <code>cached_property()</code> 的效果:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">DataSet</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> sequence_of_numbers<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>_data <span class="token operator">=</span> sequence_of_numbers
    @property
    @cache
    <span class="token keyword">def</span> <span class="token function">stdev</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> statistics<span class="token punctuation">.</span>stdev<span class="token punctuation">(</span>self<span class="token punctuation">.</span>_data<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>3.8 新版功能.</p>
<p><code>functools.cmp_to_key</code>(<em>func</em>)</p>
<p>将(旧式的)比较函数转换为新式的 key function . 在类似于 <code>sorted()</code> ， <code>min()</code> ， <code>max()</code> ， <code>heapq.nlargest()</code> ， <code>heapq.nsmallest()</code> ， <code>itertools.groupby()</code> 等函数的 key 参数中使用。此函数主要用作将 Python 2 程序转换至新版的转换工具，以保持对比较函数的兼容。</p>
<p>比较函数意为一个可调用对象，该对象接受两个参数并比较它们，结果为小于则返回一个负数，相等则返回零，大于则返回一个正数。key function则是一个接受一个参数，并返回另一个用以排序的值的可调用对象。</p>
<p>示例:</p>
<pre><code>sorted(iterable, key=cmp_to_key(locale.strcoll))  # locale-aware sort order</code></pre><p>3.2 新版功能.</p>
<p><code>@``functools.lru_cache</code>(<em>user_function</em>)</p>
<p><code>@``functools.lru_cache</code>(<em>maxsize=128</em>, <em>typed=False</em>)</p>
<p>一个为函数提供缓存功能的装饰器，缓存 <em>maxsize</em> 组传入参数，在下次以相同参数调用时直接返回上一次的结果。用以节约高开销或I/O函数的调用时间。</p>
<p>由于使用了字典存储缓存，所以该函数的固定参数和关键字参数必须是可哈希的。</p>
<p>不同模式的参数可能被视为不同从而产生多个缓存项，例如, f(a=1, b=2) 和 f(b=2, a=1) 因其参数顺序不同，可能会被缓存两次。</p>
<p>如果指定了 <em>user_function*，它必须是一个可调用对象。 这允许 *lru_cache</em> 装饰器被直接应用于一个用户自定义函数，让 <em>maxsize</em> 保持其默认值 128:</p>
<pre class="line-numbers language-python"><code class="language-python">@lru_cache
<span class="token keyword">def</span> <span class="token function">count_vowels</span><span class="token punctuation">(</span>sentence<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">return</span> sum<span class="token punctuation">(</span>sentence<span class="token punctuation">.</span>count<span class="token punctuation">(</span>vowel<span class="token punctuation">)</span> <span class="token keyword">for</span> vowel <span class="token keyword">in</span> <span class="token string">'AEIOUaeiou'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>如果 <em>maxsize</em> 设为 <code>None</code>，LRU 特性将被禁用且缓存可无限增长。</p>
<p>如果 <em>typed</em> 被设为真值，则不同类型的函数参数将被分别缓存。 例如，<code>f(3)</code> 和 <code>f(3.0)</code> 将总是会被当作具有不同结果的不同调用。 如果 <em>typed</em> 为假值，则具体实现通常会把它们当作相同调用并且只缓存一个结果，虽然并不一定总是会这样做。</p>
<p>被包装的函数配有一个 <code>cache_parameters()</code> 函数，该函数返回一个新的 <code>dict</code> 用来显示 <em>maxsize</em> 和 <em>typed</em> 的值。 这只是出于显示信息的目的。 改变值没有任何效果。</p>
<p>为了帮助衡量缓存的有效性以及调整 <em>maxsize</em> 形参，被包装的函数会带有一个 <code>cache_info()</code> 函数，它返回一个 named tuple 以显示 <em>hits</em>, <em>misses</em>, <em>maxsize</em> 和 <em>currsize</em>。</p>
<p>该装饰器也提供了一个用于清理/使缓存失效的函数 <code>cache_clear()</code> 。</p>
<p>原始的未经装饰的函数可以通过 <code>__wrapped__</code> 属性访问。它可以用于检查、绕过缓存，或使用不同的缓存再次装饰原始函数。</p>
<p>缓存会保持对参数的引用并返回值，直到它们结束生命期退出缓存或者直到缓存被清空。</p>
<p><a href="https://en.wikipedia.org/wiki/Cache_replacement_policies#Least_recently_used_(LRU)" target="_blank" rel="noopener">LRU（最久未使用算法）缓存</a> 在最近的调用是即将到来的调用的最佳预测值时性能最好（例如，新闻服务器上最热门文章倾向于每天更改）。 缓存的大小限制可确保缓存不会在长期运行进程如网站服务器上无限制地增长。</p>
<p>一般来说，LRU缓存只在当你想要重用之前计算的结果时使用。因此，用它缓存具有副作用的函数、需要在每次调用时创建不同、易变的对象的函数或者诸如time（）或random（）之类的不纯函数是没有意义的。</p>
<p>静态 Web 内容的 LRU 缓存示例:</p>
<pre class="line-numbers language-python"><code class="language-python">@lru_cache<span class="token punctuation">(</span>maxsize<span class="token operator">=</span><span class="token number">32</span><span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">get_pep</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token string">'Retrieve text of a Python Enhancement Proposal'</span>
    resource <span class="token operator">=</span> <span class="token string">'https://www.python.org/dev/peps/pep-%04d/'</span> <span class="token operator">%</span> num
    <span class="token keyword">try</span><span class="token punctuation">:</span>
        <span class="token keyword">with</span> urllib<span class="token punctuation">.</span>request<span class="token punctuation">.</span>urlopen<span class="token punctuation">(</span>resource<span class="token punctuation">)</span> <span class="token keyword">as</span> s<span class="token punctuation">:</span>
            <span class="token keyword">return</span> s<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">except</span> urllib<span class="token punctuation">.</span>error<span class="token punctuation">.</span>HTTPError<span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token string">'Not Found'</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">for</span> n <span class="token keyword">in</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">290</span><span class="token punctuation">,</span> <span class="token number">308</span><span class="token punctuation">,</span> <span class="token number">320</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">218</span><span class="token punctuation">,</span> <span class="token number">320</span><span class="token punctuation">,</span> <span class="token number">279</span><span class="token punctuation">,</span> <span class="token number">289</span><span class="token punctuation">,</span> <span class="token number">320</span><span class="token punctuation">,</span> <span class="token number">9991</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     pep <span class="token operator">=</span> get_pep<span class="token punctuation">(</span>n<span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">print</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> len<span class="token punctuation">(</span>pep<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> get_pep<span class="token punctuation">.</span>cache_info<span class="token punctuation">(</span><span class="token punctuation">)</span>
CacheInfo<span class="token punctuation">(</span>hits<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">,</span> misses<span class="token operator">=</span><span class="token number">8</span><span class="token punctuation">,</span> maxsize<span class="token operator">=</span><span class="token number">32</span><span class="token punctuation">,</span> currsize<span class="token operator">=</span><span class="token number">8</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>以下是使用缓存通过 <a href="https://zh.wikipedia.org/wiki/动态规划" target="_blank" rel="noopener">动态规划</a> 计算 <a href="https://zh.wikipedia.org/wiki/斐波那契数列" target="_blank" rel="noopener">斐波那契数列</a> 的例子。</p>
<pre class="line-numbers language-python"><code class="language-python">@lru_cache<span class="token punctuation">(</span>maxsize<span class="token operator">=</span>None<span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">fib</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> n <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> n
    <span class="token keyword">return</span> fib<span class="token punctuation">(</span>n<span class="token number">-1</span><span class="token punctuation">)</span> <span class="token operator">+</span> fib<span class="token punctuation">(</span>n<span class="token number">-2</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token punctuation">[</span>fib<span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token keyword">for</span> n <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">13</span><span class="token punctuation">,</span> <span class="token number">21</span><span class="token punctuation">,</span> <span class="token number">34</span><span class="token punctuation">,</span> <span class="token number">55</span><span class="token punctuation">,</span> <span class="token number">89</span><span class="token punctuation">,</span> <span class="token number">144</span><span class="token punctuation">,</span> <span class="token number">233</span><span class="token punctuation">,</span> <span class="token number">377</span><span class="token punctuation">,</span> <span class="token number">610</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> fib<span class="token punctuation">.</span>cache_info<span class="token punctuation">(</span><span class="token punctuation">)</span>
CacheInfo<span class="token punctuation">(</span>hits<span class="token operator">=</span><span class="token number">28</span><span class="token punctuation">,</span> misses<span class="token operator">=</span><span class="token number">16</span><span class="token punctuation">,</span> maxsize<span class="token operator">=</span>None<span class="token punctuation">,</span> currsize<span class="token operator">=</span><span class="token number">16</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>3.2 新版功能.</p>
<p>在 3.3 版更改: 添加 <em>typed</em> 选项。</p>
<p>在 3.8 版更改: 添加了 <em>user_function</em> 选项。</p>
<p>3.9 新版功能: 新增函数 <code>cache_parameters()</code></p>
<pre><code>@``functools.total_ordering</code></pre><p>给定一个声明一个或多个全比较排序方法的类，这个类装饰器实现剩余的方法。这减轻了指定所有可能的全比较操作的工作。</p>
<p>此类必须包含以下方法之一：<code>__lt__()</code> 、<code>__le__()</code>、<code>__gt__()</code> 或 <code>__ge__()</code>。另外，此类必须支持 <code>__eq__()</code> 方法。</p>
<p>例如：</p>
<pre class="line-numbers language-python"><code class="language-python">@total_ordering
<span class="token keyword">class</span> <span class="token class-name">Student</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">_is_valid_operand</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> other<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token punctuation">(</span>hasattr<span class="token punctuation">(</span>other<span class="token punctuation">,</span> <span class="token string">"lastname"</span><span class="token punctuation">)</span> <span class="token operator">and</span>
                hasattr<span class="token punctuation">(</span>other<span class="token punctuation">,</span> <span class="token string">"firstname"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">def</span> <span class="token function">__eq__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> other<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token operator">not</span> self<span class="token punctuation">.</span>_is_valid_operand<span class="token punctuation">(</span>other<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> NotImplemented
        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>lastname<span class="token punctuation">.</span>lower<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> self<span class="token punctuation">.</span>firstname<span class="token punctuation">.</span>lower<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span>
                <span class="token punctuation">(</span>other<span class="token punctuation">.</span>lastname<span class="token punctuation">.</span>lower<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> other<span class="token punctuation">.</span>firstname<span class="token punctuation">.</span>lower<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">def</span> <span class="token function">__lt__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> other<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token operator">not</span> self<span class="token punctuation">.</span>_is_valid_operand<span class="token punctuation">(</span>other<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> NotImplemented
        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>lastname<span class="token punctuation">.</span>lower<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> self<span class="token punctuation">.</span>firstname<span class="token punctuation">.</span>lower<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span>
                <span class="token punctuation">(</span>other<span class="token punctuation">.</span>lastname<span class="token punctuation">.</span>lower<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> other<span class="token punctuation">.</span>firstname<span class="token punctuation">.</span>lower<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>注解</p>
<p>虽然此装饰器使得创建具有良好行为的完全有序类型变得非常容易，但它 <em>确实</em> 是以执行速度更缓慢和派生比较方法的堆栈回溯更复杂为代价的。 如果性能基准测试表明这是特定应用的瓶颈所在，则改为实现全部六个富比较方法应该会轻松提升速度。</p>
<p>注解</p>
<p>这个装饰器不会尝试重载类 <em>或其上级类</em> 中已经被声明的方法。 这意味着如果某个上级类定义了比较运算符，则 <em>total_ordering</em> 将不会再次实现它，即使原方法是抽象方法。</p>
<p>3.2 新版功能.</p>
<p>在 3.4 版更改: 现在已支持从未识别类型的下层比较函数返回 NotImplemented 异常。</p>
<p><code>functools.partial</code>(<em>func</em>, <em>/</em>, <em>\</em>args<em>,</em> <em>*keywords</em>)</p>
<p>返回一个新的 部分对象，当被调用时其行为类似于 <em>func</em> 附带位置参数 <em>args</em> 和关键字参数 <em>keywords</em> 被调用。 如果为调用提供了更多的参数，它们会被附加到 <em>args</em>。 如果提供了额外的关键字参数，它们会扩展并重载 <em>keywords</em>。 大致等价于:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">partial</span><span class="token punctuation">(</span>func<span class="token punctuation">,</span> <span class="token operator">/</span><span class="token punctuation">,</span> <span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>keywords<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">newfunc</span><span class="token punctuation">(</span><span class="token operator">*</span>fargs<span class="token punctuation">,</span> <span class="token operator">**</span>fkeywords<span class="token punctuation">)</span><span class="token punctuation">:</span>
        newkeywords <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token operator">**</span>keywords<span class="token punctuation">,</span> <span class="token operator">**</span>fkeywords<span class="token punctuation">}</span>
        <span class="token keyword">return</span> func<span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">*</span>fargs<span class="token punctuation">,</span> <span class="token operator">**</span>newkeywords<span class="token punctuation">)</span>
    newfunc<span class="token punctuation">.</span>func <span class="token operator">=</span> func
    newfunc<span class="token punctuation">.</span>args <span class="token operator">=</span> args
    newfunc<span class="token punctuation">.</span>keywords <span class="token operator">=</span> keywords
    <span class="token keyword">return</span> newfunc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>partial()</code> 会被“冻结了”一部分函数参数和/或关键字的部分函数应用所使用，从而得到一个具有简化签名的新对象。 例如，<code>partial()</code> 可用来创建一个行为类似于 <code>int()</code> 函数的可调用对象，其中 <em>base</em> 参数默认为二：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> functools <span class="token keyword">import</span> partial
<span class="token operator">>></span><span class="token operator">></span> basetwo <span class="token operator">=</span> partial<span class="token punctuation">(</span>int<span class="token punctuation">,</span> base<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> basetwo<span class="token punctuation">.</span>__doc__ <span class="token operator">=</span> <span class="token string">'Convert base 2 string to an int.'</span>
<span class="token operator">>></span><span class="token operator">></span> basetwo<span class="token punctuation">(</span><span class="token string">'10010'</span><span class="token punctuation">)</span>
<span class="token number">18</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><em>class</em> <code>functools.partialmethod</code>(<em>func</em>, <em>/</em>, <em>\</em>args<em>,</em> <em>*keywords</em>)</p>
<p>返回一个新的 <code>partialmethod</code> 描述器，其行为类似 <code>partial</code> 但它被设计用作方法定义而非直接用作可调用对象。</p>
<p><em>func</em> 必须是一个 descriptor 或可调用对象（同属两者的对象例如普通函数会被当作描述器来处理）。</p>
<p>当 <em>func</em> 是一个描述器（例如普通 Python 函数, <code>classmethod()</code>, <code>staticmethod()</code>, <code>abstractmethod()</code> 或其他 <code>partialmethod</code> 的实例）时, 对 <code>__get__</code> 的调用会被委托给底层的描述器，并会返回一个适当的 部分对象 作为结果。</p>
<p>当 <em>func</em> 是一个非描述器类可调用对象时，则会动态创建一个适当的绑定方法。 当用作方法时其行为类似普通 Python 函数：将会插入 <em>self</em> 参数作为第一个位置参数，其位置甚至会处于提供给 <code>partialmethod</code> 构造器的 <em>args</em> 和 <em>keywords</em> 之前。</p>
<p>示例:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">class</span> <span class="token class-name">Cell</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         self<span class="token punctuation">.</span>_alive <span class="token operator">=</span> <span class="token boolean">False</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     @property
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">def</span> <span class="token function">alive</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         <span class="token keyword">return</span> self<span class="token punctuation">.</span>_alive
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">def</span> <span class="token function">set_state</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> state<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         self<span class="token punctuation">.</span>_alive <span class="token operator">=</span> bool<span class="token punctuation">(</span>state<span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     set_alive <span class="token operator">=</span> partialmethod<span class="token punctuation">(</span>set_state<span class="token punctuation">,</span> <span class="token boolean">True</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     set_dead <span class="token operator">=</span> partialmethod<span class="token punctuation">(</span>set_state<span class="token punctuation">,</span> <span class="token boolean">False</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> c <span class="token operator">=</span> Cell<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> c<span class="token punctuation">.</span>alive
<span class="token boolean">False</span>
<span class="token operator">>></span><span class="token operator">></span> c<span class="token punctuation">.</span>set_alive<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> c<span class="token punctuation">.</span>alive
<span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>3.4 新版功能.</p>
<p><code>functools.reduce</code>(<em>function</em>, <em>iterable</em>[, <em>initializer</em>])</p>
<p>将两个参数的 <em>function</em> 从左至右积累地应用到 <em>iterable</em> 的条目，以便将该可迭代对象缩减为单一的值。 例如，<code>reduce(lambda x, y: x+y, [1, 2, 3, 4, 5])</code> 是计算 <code>((((1+2)+3)+4)+5)</code> 的值。 左边的参数 <em>x</em> 是积累值而右边的参数 <em>y</em> 则是来自 <em>iterable</em> 的更新值。 如果存在可选项 <em>initializer*，它会被放在参与计算的可迭代对象的条目之前，并在可迭代对象为空时作为默认值。 如果没有给出 *initializer</em> 并且 <em>iterable</em> 仅包含一个条目，则将返回第一项。</p>
<p>大致相当于：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">reduce</span><span class="token punctuation">(</span>function<span class="token punctuation">,</span> iterable<span class="token punctuation">,</span> initializer<span class="token operator">=</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>
    it <span class="token operator">=</span> iter<span class="token punctuation">(</span>iterable<span class="token punctuation">)</span>
    <span class="token keyword">if</span> initializer <span class="token keyword">is</span> None<span class="token punctuation">:</span>
        value <span class="token operator">=</span> next<span class="token punctuation">(</span>it<span class="token punctuation">)</span>
    <span class="token keyword">else</span><span class="token punctuation">:</span>
        value <span class="token operator">=</span> initializer
    <span class="token keyword">for</span> element <span class="token keyword">in</span> it<span class="token punctuation">:</span>
        value <span class="token operator">=</span> function<span class="token punctuation">(</span>value<span class="token punctuation">,</span> element<span class="token punctuation">)</span>
    <span class="token keyword">return</span> value<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>请参阅 <code>itertools.accumulate()</code> 了解有关可产生所有中间值的迭代器。</p>
<pre><code>@``functools.singledispatch</code></pre><p>将一个函数转换为 单分派 generic function。</p>
<p>要定义一个泛型函数，应使用 <code>@singledispatch</code> 装饰器进行装饰。 请注意分派是作用于第一个参数的类型，要相应地创建你的函数:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> functools <span class="token keyword">import</span> singledispatch
<span class="token operator">>></span><span class="token operator">></span> @singledispatch
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">def</span> <span class="token function">fun</span><span class="token punctuation">(</span>arg<span class="token punctuation">,</span> verbose<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">if</span> verbose<span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Let me just say,"</span><span class="token punctuation">,</span> end<span class="token operator">=</span><span class="token string">" "</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">print</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>要将重载的实现添加到函数中，请使用泛型函数的 <code>register()</code> 属性。 它是一个装饰器。 对于带有类型标注的函数，该装饰器将自动推断第一个参数的类型:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> @fun<span class="token punctuation">.</span>register
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">def</span> <span class="token function">_</span><span class="token punctuation">(</span>arg<span class="token punctuation">:</span> int<span class="token punctuation">,</span> verbose<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">if</span> verbose<span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Strength in numbers, eh?"</span><span class="token punctuation">,</span> end<span class="token operator">=</span><span class="token string">" "</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">print</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> @fun<span class="token punctuation">.</span>register
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">def</span> <span class="token function">_</span><span class="token punctuation">(</span>arg<span class="token punctuation">:</span> list<span class="token punctuation">,</span> verbose<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">if</span> verbose<span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Enumerate this:"</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">for</span> i<span class="token punctuation">,</span> elem <span class="token keyword">in</span> enumerate<span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         <span class="token keyword">print</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> elem<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>对于不使用类型标注的代码，可以将适当的类型参数显式地传给装饰器本身:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> @fun<span class="token punctuation">.</span>register<span class="token punctuation">(</span>complex<span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">def</span> <span class="token function">_</span><span class="token punctuation">(</span>arg<span class="token punctuation">,</span> verbose<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">if</span> verbose<span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Better than complicated."</span><span class="token punctuation">,</span> end<span class="token operator">=</span><span class="token string">" "</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">print</span><span class="token punctuation">(</span>arg<span class="token punctuation">.</span>real<span class="token punctuation">,</span> arg<span class="token punctuation">.</span>imag<span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>要启用注册 lambda 和现有函数，可以使用函数形式的 <code>register()</code> 属性:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">def</span> <span class="token function">nothing</span><span class="token punctuation">(</span>arg<span class="token punctuation">,</span> verbose<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Nothing."</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> fun<span class="token punctuation">.</span>register<span class="token punctuation">(</span>type<span class="token punctuation">(</span>None<span class="token punctuation">)</span><span class="token punctuation">,</span> nothing<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>register()</code> 属性将返回启用了装饰器堆栈、封存的未装饰函数，并会为每个变量单独创建单元测试:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> @fun<span class="token punctuation">.</span>register<span class="token punctuation">(</span>float<span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> @fun<span class="token punctuation">.</span>register<span class="token punctuation">(</span>Decimal<span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">def</span> <span class="token function">fun_num</span><span class="token punctuation">(</span>arg<span class="token punctuation">,</span> verbose<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">if</span> verbose<span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Half of your number:"</span><span class="token punctuation">,</span> end<span class="token operator">=</span><span class="token string">" "</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">print</span><span class="token punctuation">(</span>arg <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> fun_num <span class="token keyword">is</span> fun
<span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在调用时，泛型函数会根据第一个参数的类型进行分派:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> fun<span class="token punctuation">(</span><span class="token string">"Hello, world."</span><span class="token punctuation">)</span>
Hello<span class="token punctuation">,</span> world<span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> fun<span class="token punctuation">(</span><span class="token string">"test."</span><span class="token punctuation">,</span> verbose<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>
Let me just say<span class="token punctuation">,</span> test<span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> fun<span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">,</span> verbose<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>
Strength <span class="token keyword">in</span> numbers<span class="token punctuation">,</span> eh? <span class="token number">42</span>
<span class="token operator">>></span><span class="token operator">></span> fun<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'spam'</span><span class="token punctuation">,</span> <span class="token string">'spam'</span><span class="token punctuation">,</span> <span class="token string">'eggs'</span><span class="token punctuation">,</span> <span class="token string">'spam'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> verbose<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>
Enumerate this<span class="token punctuation">:</span>
<span class="token number">0</span> spam
<span class="token number">1</span> spam
<span class="token number">2</span> eggs
<span class="token number">3</span> spam
<span class="token operator">>></span><span class="token operator">></span> fun<span class="token punctuation">(</span>None<span class="token punctuation">)</span>
Nothing<span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> fun<span class="token punctuation">(</span><span class="token number">1.23</span><span class="token punctuation">)</span>
<span class="token number">0.615</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在没有用于特定类型的已注册实现的情况下，则会使用其方法解析顺序来查找更通用的实现。 以 <code>@singledispatch</code> 装饰的原始函数将为最基本的 <code>object</code> 类型进行注册，这意味着它将在找不到更好的实现时被使用。</p>
<p>如果一个实现注册到了 abstract base class，虚拟子类将会被发送到该实现:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> collections<span class="token punctuation">.</span>abc <span class="token keyword">import</span> Mapping
<span class="token operator">>></span><span class="token operator">></span> @fun<span class="token punctuation">.</span>register
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">def</span> <span class="token function">_</span><span class="token punctuation">(</span>arg<span class="token punctuation">:</span> Mapping<span class="token punctuation">,</span> verbose<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">if</span> verbose<span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Keys &amp; Values"</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">for</span> key<span class="token punctuation">,</span> value <span class="token keyword">in</span> arg<span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         <span class="token keyword">print</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token string">"=>"</span><span class="token punctuation">,</span> value<span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> fun<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">"a"</span><span class="token punctuation">:</span> <span class="token string">"b"</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
a <span class="token operator">=</span><span class="token operator">></span> b<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>要检查泛型函数将为给定类型选择哪个实现，请使用 <code>dispatch()</code> 属性:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> fun<span class="token punctuation">.</span>dispatch<span class="token punctuation">(</span>float<span class="token punctuation">)</span>
<span class="token operator">&lt;</span>function fun_num at <span class="token number">0x1035a2840</span><span class="token operator">></span>
<span class="token operator">>></span><span class="token operator">></span> fun<span class="token punctuation">.</span>dispatch<span class="token punctuation">(</span>dict<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># note: default implementation</span>
<span class="token operator">&lt;</span>function fun at <span class="token number">0x103fe0000</span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>要访问所有忆注册实现，请使用只读的 <code>registry</code> 属性:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> fun<span class="token punctuation">.</span>registry<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span>
dict_keys<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token string">'NoneType'</span><span class="token operator">></span><span class="token punctuation">,</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token string">'int'</span><span class="token operator">></span><span class="token punctuation">,</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token string">'object'</span><span class="token operator">></span><span class="token punctuation">,</span>
          <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token string">'decimal.Decimal'</span><span class="token operator">></span><span class="token punctuation">,</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token string">'list'</span><span class="token operator">></span><span class="token punctuation">,</span>
          <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token string">'float'</span><span class="token operator">></span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> fun<span class="token punctuation">.</span>registry<span class="token punctuation">[</span>float<span class="token punctuation">]</span>
<span class="token operator">&lt;</span>function fun_num at <span class="token number">0x1035a2840</span><span class="token operator">></span>
<span class="token operator">>></span><span class="token operator">></span> fun<span class="token punctuation">.</span>registry<span class="token punctuation">[</span>object<span class="token punctuation">]</span>
<span class="token operator">&lt;</span>function fun at <span class="token number">0x103fe0000</span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>3.4 新版功能.</p>
<p>在 3.7 版更改: <code>register()</code> 属性支持使用类型标注。</p>
<p><em>class</em> <code>functools.singledispatchmethod</code>(<em>func</em>)</p>
<p>将一个方法转换为 单分派 generic function。</p>
<p>要定义一个泛型方法，应使用 <code>@singledispatchmethod</code> 装饰器进行装饰。 请注意分派是作用于第一个非 self 或非 cls 参数的类型，要相应地创建你的函数:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Negator</span><span class="token punctuation">:</span>
    @singledispatchmethod
    <span class="token keyword">def</span> <span class="token function">neg</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> arg<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">raise</span> NotImplementedError<span class="token punctuation">(</span><span class="token string">"Cannot negate a"</span><span class="token punctuation">)</span>
    @neg<span class="token punctuation">.</span>register
    <span class="token keyword">def</span> <span class="token function">_</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> arg<span class="token punctuation">:</span> int<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token operator">-</span>arg
    @neg<span class="token punctuation">.</span>register
    <span class="token keyword">def</span> <span class="token function">_</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> arg<span class="token punctuation">:</span> bool<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token operator">not</span> arg<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>@singledispatchmethod</code> 支持与其他装饰器如 <code>@classmethod</code> 相嵌套。 请注意如果要允许 <code>dispatcher.register</code>，则 <code>singledispatchmethod</code> 必须是 <em>最外层</em> 的装饰器。 下面的示例定义了 <code>Negator</code> 类，其中包含绑定到类的 <code>neg</code> 方法:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Negator</span><span class="token punctuation">:</span>
    @singledispatchmethod
    @classmethod
    <span class="token keyword">def</span> <span class="token function">neg</span><span class="token punctuation">(</span>cls<span class="token punctuation">,</span> arg<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">raise</span> NotImplementedError<span class="token punctuation">(</span><span class="token string">"Cannot negate a"</span><span class="token punctuation">)</span>
    @neg<span class="token punctuation">.</span>register
    @classmethod
    <span class="token keyword">def</span> <span class="token function">_</span><span class="token punctuation">(</span>cls<span class="token punctuation">,</span> arg<span class="token punctuation">:</span> int<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token operator">-</span>arg
    @neg<span class="token punctuation">.</span>register
    @classmethod
    <span class="token keyword">def</span> <span class="token function">_</span><span class="token punctuation">(</span>cls<span class="token punctuation">,</span> arg<span class="token punctuation">:</span> bool<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token operator">not</span> arg<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>同样的模式也被用于其他类似的装饰器: <code>staticmethod</code>, <code>abstractmethod</code> 等等。</p>
<p>3.8 新版功能.</p>
<p><code>functools.update_wrapper</code>(<em>wrapper</em>, <em>wrapped</em>, <em>assigned=WRAPPER_ASSIGNMENTS</em>, <em>updated=WRAPPER_UPDATES</em>)</p>
<p>更新一个 <em>wrapper</em> 函数以使其类似于 <em>wrapped</em> 函数。 可选参数为指明原函数的哪些属性要直接被赋值给 wrapper 函数的匹配属性的元组，并且这些 wrapper 函数的属性将使用原函数的对应属性来更新。 这些参数的默认值是模块级常量 <code>WRAPPER_ASSIGNMENTS</code> (它将被赋值给 wrapper 函数的 <code>__module__</code>, <code>__name__</code>, <code>__qualname__</code>, <code>__annotations__</code> 和 <code>__doc__</code> 即文档字符串) 以及 <code>WRAPPER_UPDATES</code> (它将更新 wrapper 函数的 <code>__dict__</code> 即实例字典)。</p>
<p>为了允许出于内省和其他目的访问原始函数（例如绕过 <code>lru_cache()</code> 之类的缓存装饰器），此函数会自动为 wrapper 添加一个指向被包装函数的 <code>__wrapped__</code> 属性。</p>
<p>此函数的主要目的是在 decorator 函数中用来包装被装饰的函数并返回包装器。 如果包装器函数未被更新，则被返回函数的元数据将反映包装器定义而不是原始函数定义，这通常没有什么用处。</p>
<p><code>update_wrapper()</code> 可以与函数之外的可调用对象一同使用。 在 <em>assigned</em> 或 <em>updated</em> 中命名的任何属性如果不存在于被包装对象则会被忽略（即该函数将不会尝试在包装器函数上设置它们）。 如果包装器函数自身缺少在 <em>updated</em> 中命名的任何属性则仍将引发 <code>AttributeError</code>。</p>
<p>3.2 新版功能: 自动添加 <code>__wrapped__</code> 属性。</p>
<p>3.2 新版功能: 默认拷贝 <code>__annotations__</code> 属性。</p>
<p>在 3.2 版更改: 不存在的属性将不再触发 <code>AttributeError</code>。</p>
<p>在 3.4 版更改: <code>__wrapped__</code> 属性现在总是指向被包装的函数，即使该函数定义了 <code>__wrapped__</code> 属性。 (参见 <a href="https://bugs.python.org/issue17482" target="_blank" rel="noopener">bpo-17482</a>)</p>
<p><code>@``functools.wraps</code>(<em>wrapped</em>, <em>assigned=WRAPPER_ASSIGNMENTS</em>, <em>updated=WRAPPER_UPDATES</em>)</p>
<p>这是一个便捷函数，用于在定义包装器函数时发起调用 <code>update_wrapper()</code> 作为函数装饰器。 它等价于 <code>partial(update_wrapper, wrapped=wrapped, assigned=assigned, updated=updated)</code>。 例如:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> functools <span class="token keyword">import</span> wraps
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">def</span> <span class="token function">my_decorator</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     @wraps<span class="token punctuation">(</span>f<span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">def</span> <span class="token function">wrapper</span><span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwds<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Calling decorated function'</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         <span class="token keyword">return</span> f<span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwds<span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">return</span> wrapper
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> @my_decorator
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">def</span> <span class="token function">example</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token triple-quoted-string string">"""Docstring"""</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Called example function'</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> example<span class="token punctuation">(</span><span class="token punctuation">)</span>
Calling decorated function
Called example function
<span class="token operator">>></span><span class="token operator">></span> example<span class="token punctuation">.</span>__name__
<span class="token string">'example'</span>
<span class="token operator">>></span><span class="token operator">></span> example<span class="token punctuation">.</span>__doc__
<span class="token string">'Docstring'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果不使用这个装饰器工厂函数，则 example 函数的名称将变为 <code>'wrapper'</code>，并且 <code>example()</code> 原本的文档字符串将会丢失。</p>
<h3 id="partial-对象"><a href="#partial-对象" class="headerlink" title="partial 对象"></a><code>partial</code> 对象</h3><p><code>partial</code> 对象是由 <code>partial()</code> 创建的可调用对象。 它们具有三个只读属性：</p>
<pre><code>partial.func</code></pre><p>一个可调用对象或函数。 对 <code>partial</code> 对象的调用将被转发给 <code>func</code> 并附带新的参数和关键字。</p>
<pre><code>partial.args</code></pre><p>最左边的位置参数将放置在提供给 <code>partial</code> 对象调用的位置参数之前。</p>
<pre><code>partial.keywords</code></pre><p>当调用 <code>partial</code> 对象时将要提供的关键字参数。</p>
<p><code>partial</code> 对象与 <code>function</code> 对象的类似之处在于它们都是可调用、可弱引用的对象并可拥有属性。 但两者也存在一些重要的区别。 例如前者不会自动创建 <code>__name__</code> 和 <code>__doc__</code> 属性。 而且，在类中定义的 <code>partial</code> 对象的行为类似于静态方法，并且不会在实例属性查找期间转换为绑定方法。</p>
<h2 id="operator-—-标准运算符替代函数"><a href="#operator-—-标准运算符替代函数" class="headerlink" title="operator —- 标准运算符替代函数"></a><code>operator</code> —- 标准运算符替代函数</h2><p><strong>源代码:</strong> <a href="https://github.com/python/cpython/tree/3.10/Lib/operator.py" target="_blank" rel="noopener">Lib/operator.py</a></p>
<hr>
<p><code>operator</code> 模块提供了一套与Python的内置运算符对应的高效率函数。例如，<code>operator.add(x, y)</code> 与表达式 <code>x+y</code> 相同。 许多函数名与特殊方法名相同，只是没有双下划线。为了向后兼容性，也保留了许多包含双下划线的函数。为了表述清楚，建议使用没有双下划线的函数。</p>
<p>函数包含的种类有：对象的比较运算、逻辑运算、数学运算以及序列运算。</p>
<p>对象比较函数适用于所有的对象，函数名根据它们对应的比较运算符命名。</p>
<p><code>operator.lt</code>(<em>a</em>, <em>b</em>)</p>
<p><code>operator.le</code>(<em>a</em>, <em>b</em>)</p>
<p><code>operator.eq</code>(<em>a</em>, <em>b</em>)</p>
<p><code>operator.ne</code>(<em>a</em>, <em>b</em>)</p>
<p><code>operator.ge</code>(<em>a</em>, <em>b</em>)</p>
<p><code>operator.gt</code>(<em>a</em>, <em>b</em>)</p>
<p><code>operator.__lt__</code>(<em>a</em>, <em>b</em>)</p>
<p><code>operator.__le__</code>(<em>a</em>, <em>b</em>)</p>
<p><code>operator.__eq__</code>(<em>a</em>, <em>b</em>)</p>
<p><code>operator.__ne__</code>(<em>a</em>, <em>b</em>)</p>
<p><code>operator.__ge__</code>(<em>a</em>, <em>b</em>)</p>
<p><code>operator.__gt__</code>(<em>a</em>, <em>b</em>)</p>
<p>在 <em>a</em> 和 <em>b</em> 之间进行全比较。具体的，<code>lt(a, b)</code> 与 <code>a &lt; b</code> 相同， <code>le(a, b)</code> 与 <code>a &lt;= b</code> 相同，<code>eq(a, b)</code> 与 <code>a == b</code> 相同，<code>ne(a, b)</code> 与 <code>a != b</code> 相同，<code>gt(a, b)</code> 与 <code>a &gt; b</code> 相同，<code>ge(a, b)</code>与 <code>a &gt;= b</code> 相同。注意这些函数可以返回任何值，无论它是否可当作布尔值。</p>
<p>逻辑运算通常也适用于所有对象，并且支持真值检测、标识检测和布尔运算：</p>
<p><code>operator.not_</code>(<em>obj</em>)</p>
<p><code>operator.__not__</code>(<em>obj</em>)</p>
<p>返回 <code>not</code> <em>obj</em> 的结果。 （请注意对象实例并没有 <code>__not__()</code> 方法；只有解释器核心可定义此操作。 结果会受 <code>__bool__()</code> 和 <code>__len__()</code> 方法影响。）</p>
<p><code>operator.truth</code>(<em>obj</em>)</p>
<p>如果 <em>obj</em> 为真值则返回 <code>True</code>，否则返回 <code>False</code>。 这等价于使用 <code>bool</code> 构造器。</p>
<p><code>operator.is_</code>(<em>a</em>, <em>b</em>)</p>
<p>返回 <code>a is b</code>。 检测对象标识。</p>
<p><code>operator.is_not</code>(<em>a</em>, <em>b</em>)</p>
<p>返回 <code>a is not b</code>。 检测对象标识。</p>
<p>数学和按位运算的种类是最多的：</p>
<p><code>operator.abs</code>(<em>obj</em>)</p>
<p><code>operator.__abs__</code>(<em>obj</em>)</p>
<p>返回 <em>obj</em> 的绝对值。</p>
<p><code>operator.add</code>(<em>a</em>, <em>b</em>)</p>
<p><code>operator.__add__</code>(<em>a</em>, <em>b</em>)</p>
<p>对于数字 <em>a</em> 和 <em>b</em>，返回 <code>a + b</code>。</p>
<p><code>operator.and_</code>(<em>a</em>, <em>b</em>)</p>
<p><code>operator.__and__</code>(<em>a</em>, <em>b</em>)</p>
<p>返回 <em>x</em> 和 <em>y</em> 按位与的结果。</p>
<p><code>operator.floordiv</code>(<em>a</em>, <em>b</em>)</p>
<p><code>operator.__floordiv__</code>(<em>a</em>, <em>b</em>)</p>
<p>返回 <code>a // b</code>。</p>
<p><code>operator.index</code>(<em>a</em>)</p>
<p><code>operator.__index__</code>(<em>a</em>)</p>
<p>返回 <em>a</em> 转换为整数的结果。 等价于 <code>a.__index__()</code>。</p>
<p>在 3.10 版更改: 结果总是为 <code>int</code> 类型。 在之前版本中，结果可能为 <code>int</code> 的子类的实例。</p>
<p><code>operator.inv</code>(<em>obj</em>)</p>
<p><code>operator.invert</code>(<em>obj</em>)</p>
<p><code>operator.__inv__</code>(<em>obj</em>)</p>
<p><code>operator.__invert__</code>(<em>obj</em>)</p>
<p>返回数字 <em>obj</em> 按位取反的结果。 这等价于 <code>~obj</code>。</p>
<p><code>operator.lshift</code>(<em>a</em>, <em>b</em>)</p>
<p><code>operator.__lshift__</code>(<em>a</em>, <em>b</em>)</p>
<p>返回 <em>a</em> 左移 <em>b</em> 位的结果。</p>
<p><code>operator.mod</code>(<em>a</em>, <em>b</em>)</p>
<p><code>operator.__mod__</code>(<em>a</em>, <em>b</em>)</p>
<p>返回 <code>a % b</code>。</p>
<p><code>operator.mul</code>(<em>a</em>, <em>b</em>)</p>
<p><code>operator.__mul__</code>(<em>a</em>, <em>b</em>)</p>
<p>对于数字 <em>a</em> 和 <em>b</em>，返回 <code>a * b</code>。</p>
<p><code>operator.matmul</code>(<em>a</em>, <em>b</em>)</p>
<p><code>operator.__matmul__</code>(<em>a</em>, <em>b</em>)</p>
<p>返回 <code>a @ b</code>。</p>
<p>3.5 新版功能.</p>
<p><code>operator.neg</code>(<em>obj</em>)</p>
<p><code>operator.__neg__</code>(<em>obj</em>)</p>
<p>返回 <em>obj</em> 取负的结果 (<code>-obj</code>)。</p>
<p><code>operator.or_</code>(<em>a</em>, <em>b</em>)</p>
<p><code>operator.__or__</code>(<em>a</em>, <em>b</em>)</p>
<p>返回 <em>a</em> 和 <em>b</em> 按位或的结果。</p>
<p><code>operator.pos</code>(<em>obj</em>)</p>
<p><code>operator.__pos__</code>(<em>obj</em>)</p>
<p>返回 <em>obj</em> 取正的结果 (<code>+obj</code>)。</p>
<p><code>operator.pow</code>(<em>a</em>, <em>b</em>)</p>
<p><code>operator.__pow__</code>(<em>a</em>, <em>b</em>)</p>
<p>对于数字 <em>a</em> 和 <em>b</em>，返回 <code>a ** b</code>。</p>
<p><code>operator.rshift</code>(<em>a</em>, <em>b</em>)</p>
<p><code>operator.__rshift__</code>(<em>a</em>, <em>b</em>)</p>
<p>返回 <em>a</em> 右移 <em>b</em> 位的结果。</p>
<p><code>operator.sub</code>(<em>a</em>, <em>b</em>)</p>
<p><code>operator.__sub__</code>(<em>a</em>, <em>b</em>)</p>
<p>返回 <code>a - b</code>。</p>
<p><code>operator.truediv</code>(<em>a</em>, <em>b</em>)</p>
<p><code>operator.__truediv__</code>(<em>a</em>, <em>b</em>)</p>
<p>返回 <code>a / b</code> 例如 2/3 将等于 .66 而不是 0。 这也被称为“真”除法。</p>
<p><code>operator.xor</code>(<em>a</em>, <em>b</em>)</p>
<p><code>operator.__xor__</code>(<em>a</em>, <em>b</em>)</p>
<p>返回 <em>a</em> 和 <em>b</em> 按位异或的结果。</p>
<p>适用于序列的操作（其中一些也适用于映射）包括：</p>
<p><code>operator.concat</code>(<em>a</em>, <em>b</em>)</p>
<p><code>operator.__concat__</code>(<em>a</em>, <em>b</em>)</p>
<p>对于序列 <em>a</em> 和 <em>b</em>，返回 <code>a + b</code>。</p>
<p><code>operator.contains</code>(<em>a</em>, <em>b</em>)</p>
<p><code>operator.__contains__</code>(<em>a</em>, <em>b</em>)</p>
<p>返回 <code>b in a</code> 检测的结果。 请注意操作数是反序的。</p>
<p><code>operator.countOf</code>(<em>a</em>, <em>b</em>)</p>
<p>返回 <em>b</em> 在 <em>a</em> 中的出现次数。</p>
<p><code>operator.delitem</code>(<em>a</em>, <em>b</em>)</p>
<p><code>operator.__delitem__</code>(<em>a</em>, <em>b</em>)</p>
<p>移除 <em>a</em> 中索引号为 <em>b</em> 的值。</p>
<p><code>operator.getitem</code>(<em>a</em>, <em>b</em>)</p>
<p><code>operator.__getitem__</code>(<em>a</em>, <em>b</em>)</p>
<p>返回 <em>a</em> 中索引为 <em>b</em> 的值。</p>
<p><code>operator.indexOf</code>(<em>a</em>, <em>b</em>)</p>
<p>返回 <em>b</em> 在 <em>a</em> 中首次出现所在的索引号。</p>
<p><code>operator.setitem</code>(<em>a</em>, <em>b</em>, <em>c</em>)</p>
<p><code>operator.__setitem__</code>(<em>a</em>, <em>b</em>, <em>c</em>)</p>
<p>将 <em>a</em> 中索引号为 <em>b</em> 的值设为 <em>c</em>。</p>
<p><code>operator.length_hint</code>(<em>obj</em>, <em>default=0</em>)</p>
<p>返回对象 <em>o</em> 的估计长度。 首先尝试返回其实际长度，再使用 <code>object.__length_hint__()</code> 得出估计值，最后返回默认值。</p>
<p>3.4 新版功能.</p>
<p><code>operator</code> 模块还定义了一些用于常规属性和条目查找的工具。 这些工具适合用来编写快速字段提取器作为 <code>map()</code>, <code>sorted()</code>, <code>itertools.groupby()</code> 或其他需要相应函数参数的函数的参数。</p>
<p><code>operator.attrgetter</code>(<em>attr</em>)</p>
<p><code>operator.attrgetter</code>(<em>\</em>attrs*)</p>
<p>返回一个可从操作数中获取 <em>attr</em> 的可调用对象。 如果请求了一个以上的属性，则返回一个属性元组。 属性名称还可包含点号。 例如：</p>
<ul>
<li>在 <code>f = attrgetter('name')</code> 之后，调用 <code>f(b)</code> 将返回 <code>b.name</code>。</li>
<li>在 <code>f = attrgetter('name', 'date')</code> 之后，调用 <code>f(b)</code> 将返回 <code>(b.name, b.date)</code>。</li>
<li>在 <code>f = attrgetter('name.first', 'name.last')</code> 之后，调用 <code>f(b)</code> 将返回 <code>(b.name.first, b.name.last)</code>。</li>
</ul>
<p>等价于:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">attrgetter</span><span class="token punctuation">(</span><span class="token operator">*</span>items<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> any<span class="token punctuation">(</span><span class="token operator">not</span> isinstance<span class="token punctuation">(</span>item<span class="token punctuation">,</span> str<span class="token punctuation">)</span> <span class="token keyword">for</span> item <span class="token keyword">in</span> items<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">raise</span> TypeError<span class="token punctuation">(</span><span class="token string">'attribute name must be a string'</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> len<span class="token punctuation">(</span>items<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>
        attr <span class="token operator">=</span> items<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
        <span class="token keyword">def</span> <span class="token function">g</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> resolve_attr<span class="token punctuation">(</span>obj<span class="token punctuation">,</span> attr<span class="token punctuation">)</span>
    <span class="token keyword">else</span><span class="token punctuation">:</span>
        <span class="token keyword">def</span> <span class="token function">g</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> tuple<span class="token punctuation">(</span>resolve_attr<span class="token punctuation">(</span>obj<span class="token punctuation">,</span> attr<span class="token punctuation">)</span> <span class="token keyword">for</span> attr <span class="token keyword">in</span> items<span class="token punctuation">)</span>
    <span class="token keyword">return</span> g
<span class="token keyword">def</span> <span class="token function">resolve_attr</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> attr<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">for</span> name <span class="token keyword">in</span> attr<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">"."</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        obj <span class="token operator">=</span> getattr<span class="token punctuation">(</span>obj<span class="token punctuation">,</span> name<span class="token punctuation">)</span>
    <span class="token keyword">return</span> obj<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>operator.itemgetter</code>(<em>item</em>)</p>
<p><code>operator.itemgetter</code>(<em>\</em>items*)</p>
<p>返回一个使用操作数的 <code>__getitem__()</code> 方法从操作数中获取 <em>item</em> 的可调用对象。 如果指定了多个条目，则返回一个查找值的元组。 例如：</p>
<ul>
<li>在 <code>f = itemgetter(2)</code> 之后，调用 <code>f(r)</code> 将返回 <code>r[2]</code>。</li>
<li>在 <code>g = itemgetter(2, 5, 3)</code> 之后，调用 <code>g(r)</code> 将返回 <code>(r[2], r[5], r[3])</code>。</li>
</ul>
<p>等价于:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">itemgetter</span><span class="token punctuation">(</span><span class="token operator">*</span>items<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> len<span class="token punctuation">(</span>items<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>
        item <span class="token operator">=</span> items<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
        <span class="token keyword">def</span> <span class="token function">g</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> obj<span class="token punctuation">[</span>item<span class="token punctuation">]</span>
    <span class="token keyword">else</span><span class="token punctuation">:</span>
        <span class="token keyword">def</span> <span class="token function">g</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> tuple<span class="token punctuation">(</span>obj<span class="token punctuation">[</span>item<span class="token punctuation">]</span> <span class="token keyword">for</span> item <span class="token keyword">in</span> items<span class="token punctuation">)</span>
    <span class="token keyword">return</span> g<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>传入的条目可以为操作数的 <code>__getitem__()</code> 所接受的任何类型。 字典接受任意可哈希的值。 列表、元组和字符串接受 index 或 slice 对象：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> itemgetter<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token string">'ABCDEFG'</span><span class="token punctuation">)</span>
<span class="token string">'B'</span>
<span class="token operator">>></span><span class="token operator">></span> itemgetter<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token string">'ABCDEFG'</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token string">'B'</span><span class="token punctuation">,</span> <span class="token string">'D'</span><span class="token punctuation">,</span> <span class="token string">'F'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> itemgetter<span class="token punctuation">(</span>slice<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> None<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token string">'ABCDEFG'</span><span class="token punctuation">)</span>
<span class="token string">'CDEFG'</span>
<span class="token operator">>></span><span class="token operator">></span> soldier <span class="token operator">=</span> dict<span class="token punctuation">(</span>rank<span class="token operator">=</span><span class="token string">'captain'</span><span class="token punctuation">,</span> name<span class="token operator">=</span><span class="token string">'dotterbart'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> itemgetter<span class="token punctuation">(</span><span class="token string">'rank'</span><span class="token punctuation">)</span><span class="token punctuation">(</span>soldier<span class="token punctuation">)</span>
<span class="token string">'captain'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>使用 <code>itemgetter()</code> 从元组的记录中提取特定字段的例子：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> inventory <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token string">'apple'</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'banana'</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'pear'</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'orange'</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> getcount <span class="token operator">=</span> itemgetter<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> list<span class="token punctuation">(</span>map<span class="token punctuation">(</span>getcount<span class="token punctuation">,</span> inventory<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> sorted<span class="token punctuation">(</span>inventory<span class="token punctuation">,</span> key<span class="token operator">=</span>getcount<span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token string">'orange'</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'banana'</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'apple'</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'pear'</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>operator.methodcaller</code>(<em>name</em>, <em>/</em>, <em>\</em>args<em>,</em> <em>*kwargs</em>)</p>
<p>返回一个在操作数上调用 <em>name</em> 方法的可调用对象。 如果给出额外的参数和/或关键字参数，它们也将被传给该方法。 例如：</p>
<ul>
<li>在 <code>f = methodcaller('name')</code> 之后，调用 <code>f(b)</code> 将返回 <code>b.name()</code>。</li>
<li>在 <code>f = methodcaller('name', 'foo', bar=1)</code> 之后，调用 <code>f(b)</code> 将返回 <code>b.name('foo', bar=1)</code>。</li>
</ul>
<p>等价于:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">methodcaller</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token operator">/</span><span class="token punctuation">,</span> <span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">caller</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> getattr<span class="token punctuation">(</span>obj<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span>
    <span class="token keyword">return</span> caller<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="将运算符映射到函数"><a href="#将运算符映射到函数" class="headerlink" title="将运算符映射到函数"></a>将运算符映射到函数</h3><p>以下表格显示了抽象运算是如何对应于 Python 语法中的运算符和 <code>operator</code> 模块中的函数的。</p>
<table>
<thead>
<tr>
<th align="left">运算</th>
<th align="left">语法</th>
<th align="left">函数</th>
</tr>
</thead>
<tbody><tr>
<td align="left">加法</td>
<td align="left"><code>a + b</code></td>
<td align="left"><code>add(a, b)</code></td>
</tr>
<tr>
<td align="left">字符串拼接</td>
<td align="left"><code>seq1 + seq2</code></td>
<td align="left"><code>concat(seq1, seq2)</code></td>
</tr>
<tr>
<td align="left">包含测试</td>
<td align="left"><code>obj in seq</code></td>
<td align="left"><code>contains(seq, obj)</code></td>
</tr>
<tr>
<td align="left">除法</td>
<td align="left"><code>a / b</code></td>
<td align="left"><code>truediv(a, b)</code></td>
</tr>
<tr>
<td align="left">除法</td>
<td align="left"><code>a // b</code></td>
<td align="left"><code>floordiv(a, b)</code></td>
</tr>
<tr>
<td align="left">按位与</td>
<td align="left"><code>a &amp; b</code></td>
<td align="left"><code>and*(a, b)*</code></td>
</tr>
<tr>
<td align="left">按位异或</td>
<td align="left"><code>a ^ b</code></td>
<td align="left"><code>xor(a, b)</code></td>
</tr>
<tr>
<td align="left">按位取反</td>
<td align="left"><code>~ a</code></td>
<td align="left"><code>invert(a)</code></td>
</tr>
<tr>
<td align="left">按位或</td>
<td align="left">`a</td>
<td align="left">b`</td>
</tr>
<tr>
<td align="left">取幂</td>
<td align="left"><code>a ** b*</code></td>
<td align="left"><code>pow(a, b)</code></td>
</tr>
<tr>
<td align="left">标识</td>
<td align="left"><code>a is b</code></td>
<td align="left"><code>is_(a, b)</code></td>
</tr>
<tr>
<td align="left">标识</td>
<td align="left"><code>a is not b</code></td>
<td align="left"><code>is_not(a, b)</code></td>
</tr>
<tr>
<td align="left">索引赋值</td>
<td align="left"><code>obj[k] = v</code></td>
<td align="left"><code>setitem(obj, k, v)</code></td>
</tr>
<tr>
<td align="left">索引删除</td>
<td align="left"><code>del obj[k]</code></td>
<td align="left"><code>delitem(obj, k)</code></td>
</tr>
<tr>
<td align="left">索引取值</td>
<td align="left"><code>obj[k]</code></td>
<td align="left"><code>getitem(obj, k)</code></td>
</tr>
<tr>
<td align="left">左移</td>
<td align="left"><code>a &lt;&lt; b</code></td>
<td align="left"><code>lshift(a, b)</code></td>
</tr>
<tr>
<td align="left">取模</td>
<td align="left"><code>a % b</code></td>
<td align="left"><code>mod(a, b)</code></td>
</tr>
<tr>
<td align="left">乘法</td>
<td align="left"><code>a b</code></td>
<td align="left"><code>mul(a, b)</code></td>
</tr>
<tr>
<td align="left">矩阵乘法</td>
<td align="left"><code>a @ b</code></td>
<td align="left"><code>matmul(a, b)</code></td>
</tr>
<tr>
<td align="left">取反（算术）</td>
<td align="left"><code>- a</code></td>
<td align="left"><code>neg(a)</code></td>
</tr>
<tr>
<td align="left">取反（逻辑）</td>
<td align="left"><code>not a</code></td>
<td align="left"><code>not_(a)</code></td>
</tr>
<tr>
<td align="left">正数</td>
<td align="left"><code>+ a</code></td>
<td align="left"><code>pos(a)</code></td>
</tr>
<tr>
<td align="left">右移</td>
<td align="left"><code>a &gt;&gt; b</code></td>
<td align="left"><code>rshift(a, b)</code></td>
</tr>
<tr>
<td align="left">切片赋值</td>
<td align="left"><code>seq[i:j] = values</code></td>
<td align="left"><code>setitem(seq, slice(i, j), values)</code></td>
</tr>
<tr>
<td align="left">切片删除</td>
<td align="left"><code>del seq[i:j]</code></td>
<td align="left"><code>delitem(seq, slice(i, j))</code></td>
</tr>
<tr>
<td align="left">切片取值</td>
<td align="left"><code>seq[i:j]</code></td>
<td align="left"><code>getitem(seq, slice(i, j))</code></td>
</tr>
<tr>
<td align="left">字符串格式化</td>
<td align="left"><code>s % obj</code></td>
<td align="left"><code>mod(s, obj)</code></td>
</tr>
<tr>
<td align="left">减法</td>
<td align="left"><code>a - b</code></td>
<td align="left"><code>sub(a, b)</code></td>
</tr>
<tr>
<td align="left">真值测试</td>
<td align="left"><code>obj</code></td>
<td align="left"><code>truth(obj)</code></td>
</tr>
<tr>
<td align="left">比较</td>
<td align="left"><code>a &lt; b</code></td>
<td align="left"><code>lt(a, b)</code></td>
</tr>
<tr>
<td align="left">比较</td>
<td align="left"><code>a &lt;= b</code></td>
<td align="left"><code>le(a, b)</code></td>
</tr>
<tr>
<td align="left">相等</td>
<td align="left"><code>a == b</code></td>
<td align="left"><code>eq(a, b)</code></td>
</tr>
<tr>
<td align="left">不等</td>
<td align="left"><code>a != b</code></td>
<td align="left"><code>ne(a, b)</code></td>
</tr>
<tr>
<td align="left">比较</td>
<td align="left"><code>a &gt;= b</code></td>
<td align="left"><code>ge(a, b)</code></td>
</tr>
<tr>
<td align="left">比较</td>
<td align="left"><code>a &gt; b</code></td>
<td align="left"><code>gt(a, b)</code></td>
</tr>
</tbody></table>
<h3 id="原地运算符"><a href="#原地运算符" class="headerlink" title="原地运算符"></a>原地运算符</h3><p>许多运算都有“原地”版本。 以下列出的是提供对原地运算符相比通常语法更底层访问的函数，例如 statement <code>x += y</code> 相当于 <code>x = operator.iadd(x, y)</code>。 换一种方式来讲就是 <code>z = operator.iadd(x, y)</code> 等价于语句块 <code>z = x; z += y</code>。</p>
<p>在这些例子中，请注意当调用一个原地方法时，运算和赋值是分成两个步骤来执行的。 下面列出的原地函数只执行第一步即调用原地方法。 第二步赋值则不加处理。</p>
<p>对于不可变的目标例如字符串、数字和元组，更新的值会被计算，但不会被再被赋值给输入变量：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> a <span class="token operator">=</span> <span class="token string">'hello'</span>
<span class="token operator">>></span><span class="token operator">></span> iadd<span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token string">' world'</span><span class="token punctuation">)</span>
<span class="token string">'hello world'</span>
<span class="token operator">>></span><span class="token operator">></span> a
<span class="token string">'hello'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>对于可变的目标例如列表和字典，原地方法将执行更新，因此不需要后续赋值操作：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> s <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'h'</span><span class="token punctuation">,</span> <span class="token string">'e'</span><span class="token punctuation">,</span> <span class="token string">'l'</span><span class="token punctuation">,</span> <span class="token string">'l'</span><span class="token punctuation">,</span> <span class="token string">'o'</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> iadd<span class="token punctuation">(</span>s<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">' '</span><span class="token punctuation">,</span> <span class="token string">'w'</span><span class="token punctuation">,</span> <span class="token string">'o'</span><span class="token punctuation">,</span> <span class="token string">'r'</span><span class="token punctuation">,</span> <span class="token string">'l'</span><span class="token punctuation">,</span> <span class="token string">'d'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token string">'h'</span><span class="token punctuation">,</span> <span class="token string">'e'</span><span class="token punctuation">,</span> <span class="token string">'l'</span><span class="token punctuation">,</span> <span class="token string">'l'</span><span class="token punctuation">,</span> <span class="token string">'o'</span><span class="token punctuation">,</span> <span class="token string">' '</span><span class="token punctuation">,</span> <span class="token string">'w'</span><span class="token punctuation">,</span> <span class="token string">'o'</span><span class="token punctuation">,</span> <span class="token string">'r'</span><span class="token punctuation">,</span> <span class="token string">'l'</span><span class="token punctuation">,</span> <span class="token string">'d'</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> s
<span class="token punctuation">[</span><span class="token string">'h'</span><span class="token punctuation">,</span> <span class="token string">'e'</span><span class="token punctuation">,</span> <span class="token string">'l'</span><span class="token punctuation">,</span> <span class="token string">'l'</span><span class="token punctuation">,</span> <span class="token string">'o'</span><span class="token punctuation">,</span> <span class="token string">' '</span><span class="token punctuation">,</span> <span class="token string">'w'</span><span class="token punctuation">,</span> <span class="token string">'o'</span><span class="token punctuation">,</span> <span class="token string">'r'</span><span class="token punctuation">,</span> <span class="token string">'l'</span><span class="token punctuation">,</span> <span class="token string">'d'</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>operator.iadd</code>(<em>a</em>, <em>b</em>)</p>
<p><code>operator.__iadd__</code>(<em>a</em>, <em>b</em>)</p>
<p><code>a = iadd(a, b)</code> 等价于 <code>a += b</code>。</p>
<p><code>operator.iand</code>(<em>a</em>, <em>b</em>)</p>
<p><code>operator.__iand__</code>(<em>a</em>, <em>b</em>)</p>
<p><code>a = iand(a, b)</code> 等价于 <code>a &amp;= b</code>。</p>
<p><code>operator.iconcat</code>(<em>a</em>, <em>b</em>)</p>
<p><code>operator.__iconcat__</code>(<em>a</em>, <em>b</em>)</p>
<p><code>a = iconcat(a, b)</code> 等价于 <code>a += b</code> 其中 <em>a</em> 和 <em>b</em> 为序列。</p>
<p><code>operator.ifloordiv</code>(<em>a</em>, <em>b</em>)</p>
<p><code>operator.__ifloordiv__</code>(<em>a</em>, <em>b</em>)</p>
<p><code>a = ifloordiv(a, b)</code> 等价于 <code>a //= b</code>。</p>
<p><code>operator.ilshift</code>(<em>a</em>, <em>b</em>)</p>
<p><code>operator.__ilshift__</code>(<em>a</em>, <em>b</em>)</p>
<p><code>a = ilshift(a, b)</code> 等价于 <code>a &lt;&lt;= b</code>。</p>
<p><code>operator.imod</code>(<em>a</em>, <em>b</em>)</p>
<p><code>operator.__imod__</code>(<em>a</em>, <em>b</em>)</p>
<p><code>a = imod(a, b)</code> 等价于 <code>a %= b</code>。</p>
<p><code>operator.imul</code>(<em>a</em>, <em>b</em>)</p>
<p><code>operator.__imul__</code>(<em>a</em>, <em>b</em>)</p>
<p><code>a = imul(a, b)</code> 等价于 <code>a *= b</code>。</p>
<p><code>operator.imatmul</code>(<em>a</em>, <em>b</em>)</p>
<p><code>operator.__imatmul__</code>(<em>a</em>, <em>b</em>)</p>
<p><code>a = imatmul(a, b)</code> 等价于 <code>a @= b</code>。</p>
<p>3.5 新版功能.</p>
<p><code>operator.ior</code>(<em>a</em>, <em>b</em>)</p>
<p><code>operator.__ior__</code>(<em>a</em>, <em>b</em>)</p>
<p><code>a = ior(a, b)</code> 等价于 <code>a |= b</code>。</p>
<p><code>operator.ipow</code>(<em>a</em>, <em>b</em>)</p>
<p><code>operator.__ipow__</code>(<em>a</em>, <em>b</em>)</p>
<p><code>a = ipow(a, b)</code> 等价于 <code>a **= b</code>。</p>
<p><code>operator.irshift</code>(<em>a</em>, <em>b</em>)</p>
<p><code>operator.__irshift__</code>(<em>a</em>, <em>b</em>)</p>
<p><code>a = irshift(a, b)</code> 等价于 <code>a &gt;&gt;= b</code>。</p>
<p><code>operator.isub</code>(<em>a</em>, <em>b</em>)</p>
<p><code>operator.__isub__</code>(<em>a</em>, <em>b</em>)</p>
<p><code>a = isub(a, b)</code> 等价于 <code>a -= b</code>。</p>
<p><code>operator.itruediv</code>(<em>a</em>, <em>b</em>)</p>
<p><code>operator.__itruediv__</code>(<em>a</em>, <em>b</em>)</p>
<p><code>a = itruediv(a, b)</code> 等价于 <code>a /= b</code>。</p>
<p><code>operator.ixor</code>(<em>a</em>, <em>b</em>)</p>
<p><code>operator.__ixor__</code>(<em>a</em>, <em>b</em>)</p>
<p><code>a = ixor(a, b)</code> 等价于 <code>a ^= b</code>。</p>
<h1 id="文件和目录访问"><a href="#文件和目录访问" class="headerlink" title="文件和目录访问"></a>文件和目录访问</h1><ul>
<li><code>pathlib</code> —- 面向对象的文件系统路径<ul>
<li>基础使用</li>
<li>纯路径<ul>
<li>通用性质</li>
<li>运算符</li>
<li>访问个别部分</li>
<li>方法和特征属性</li>
</ul>
</li>
<li>具体路径<ul>
<li>方法</li>
</ul>
</li>
<li>对应的 <code>os</code> 模块的工具</li>
</ul>
</li>
<li><code>os.path</code> —- 常用路径操作</li>
<li><code>fileinput</code> —- 迭代来自多个输入流的行</li>
<li><code>stat</code> —- 解析 <code>stat()</code> 结果</li>
<li><code>filecmp</code> —- 文件及目录的比较<ul>
<li><code>dircmp</code> 类</li>
</ul>
</li>
<li><code>tempfile</code> —- 生成临时文件和目录<ul>
<li>例子</li>
<li>已弃用的函数和变量</li>
</ul>
</li>
<li><code>glob</code> —- Unix 风格路径名模式扩展</li>
<li><code>fnmatch</code> —- Unix 文件名模式匹配</li>
<li><code>linecache</code> —- 随机读写文本行</li>
<li><code>shutil</code> —- 高阶文件操作<ul>
<li>目录和文件操作<ul>
<li>依赖于具体平台的高效拷贝操作</li>
<li>copytree 示例</li>
<li>rmtree 示例</li>
</ul>
</li>
<li>归档操作<ul>
<li>归档程序示例</li>
<li>使用 <em>base_dir</em> 的归档程序示例</li>
</ul>
</li>
<li>查询输出终端的尺寸</li>
</ul>
</li>
</ul>
<h2 id="pathlib-—-面向对象的文件系统路径"><a href="#pathlib-—-面向对象的文件系统路径" class="headerlink" title="pathlib —- 面向对象的文件系统路径"></a><code>pathlib</code> —- 面向对象的文件系统路径</h2><p>3.4 新版功能.</p>
<p><strong>源代码</strong> <a href="https://github.com/python/cpython/tree/3.10/Lib/pathlib.py" target="_blank" rel="noopener">Lib/pathlib.py</a></p>
<hr>
<p>该模块提供表示文件系统路径的类，其语义适用于不同的操作系统。路径类被分为提供纯计算操作而没有 I/O 的 纯路径，以及从纯路径继承而来但提供 I/O 操作的 具体路径。</p>
<p><img src="/images/loading.gif" data-original="../images/basic/7630eaca04bc0113c9884a446d903e20.png" alt=""></p>
<p>如果以前从未用过此模块，或不确定哪个类适合完成任务，那要用的可能就是 <code>Path</code>。它在运行代码的平台上实例化为 具体路径。</p>
<p>在一些用例中纯路径很有用，例如：</p>
<ol>
<li>如果你想要在 Unix 设备上操作 Windows 路径（或者相反）。你不应在 Unix 上实例化一个 <code>WindowsPath</code>，但是你可以实例化 <code>PureWindowsPath</code>。</li>
<li>你只想操作路径但不想实际访问操作系统。在这种情况下，实例化一个纯路径是有用的，因为它们没有任何访问操作系统的操作。</li>
</ol>
<p>参见</p>
<p><a href="https://www.python.org/dev/peps/pep-0428" target="_blank" rel="noopener"><strong>PEP 428</strong></a>：pathlib 模块 — 面向对象的的文件系统路径。</p>
<p>参见</p>
<p>对于底层的路径字符串操作，你也可以使用 <code>os.path</code> 模块。</p>
<h3 id="基础使用"><a href="#基础使用" class="headerlink" title="基础使用"></a>基础使用</h3><p>导入主类:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> pathlib <span class="token keyword">import</span> Path<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>列出子目录:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> p <span class="token operator">=</span> Path<span class="token punctuation">(</span><span class="token string">'.'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token punctuation">[</span>x <span class="token keyword">for</span> x <span class="token keyword">in</span> p<span class="token punctuation">.</span>iterdir<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">if</span> x<span class="token punctuation">.</span>is_dir<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span>PosixPath<span class="token punctuation">(</span><span class="token string">'.hg'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> PosixPath<span class="token punctuation">(</span><span class="token string">'docs'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> PosixPath<span class="token punctuation">(</span><span class="token string">'dist'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
 PosixPath<span class="token punctuation">(</span><span class="token string">'__pycache__'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> PosixPath<span class="token punctuation">(</span><span class="token string">'build'</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>列出当前目录树下的所有 Python 源代码文件:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> list<span class="token punctuation">(</span>p<span class="token punctuation">.</span>glob<span class="token punctuation">(</span><span class="token string">'**/*.py'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span>PosixPath<span class="token punctuation">(</span><span class="token string">'test_pathlib.py'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> PosixPath<span class="token punctuation">(</span><span class="token string">'setup.py'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
 PosixPath<span class="token punctuation">(</span><span class="token string">'pathlib.py'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> PosixPath<span class="token punctuation">(</span><span class="token string">'docs/conf.py'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
 PosixPath<span class="token punctuation">(</span><span class="token string">'build/lib/pathlib.py'</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>在目录树中移动:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> p <span class="token operator">=</span> Path<span class="token punctuation">(</span><span class="token string">'/etc'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> q <span class="token operator">=</span> p <span class="token operator">/</span> <span class="token string">'init.d'</span> <span class="token operator">/</span> <span class="token string">'reboot'</span>
<span class="token operator">>></span><span class="token operator">></span> q
PosixPath<span class="token punctuation">(</span><span class="token string">'/etc/init.d/reboot'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> q<span class="token punctuation">.</span>resolve<span class="token punctuation">(</span><span class="token punctuation">)</span>
PosixPath<span class="token punctuation">(</span><span class="token string">'/etc/rc.d/init.d/halt'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>查询路径的属性:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> q<span class="token punctuation">.</span>exists<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token boolean">True</span>
<span class="token operator">>></span><span class="token operator">></span> q<span class="token punctuation">.</span>is_dir<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>打开一个文件:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">with</span> q<span class="token punctuation">.</span>open<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span> f<span class="token punctuation">.</span>readline<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token string">'#!/bin/bash\n'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h3 id="纯路径"><a href="#纯路径" class="headerlink" title="纯路径"></a>纯路径</h3><p>纯路径对象提供了不实际访问文件系统的路径处理操作。有三种方式来访问这些类，也是不同的风格：</p>
<p><em>class</em> <code>pathlib.PurePath</code>(<em>\</em>pathsegments*)</p>
<p>一个通用的类，代表当前系统的路径风格（实例化为 <code>PurePosixPath</code> 或者 <code>PureWindowsPath</code>）:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> PurePath<span class="token punctuation">(</span><span class="token string">'setup.py'</span><span class="token punctuation">)</span>      <span class="token comment" spellcheck="true"># Running on a Unix machine</span>
PurePosixPath<span class="token punctuation">(</span><span class="token string">'setup.py'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>每一个 <em>pathsegments</em> 的元素可能是一个代表路径片段的字符串，一个返回字符串的实现了 <code>os.PathLike</code> 接口的对象，或者另一个路径对象:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> PurePath<span class="token punctuation">(</span><span class="token string">'foo'</span><span class="token punctuation">,</span> <span class="token string">'some/path'</span><span class="token punctuation">,</span> <span class="token string">'bar'</span><span class="token punctuation">)</span>
PurePosixPath<span class="token punctuation">(</span><span class="token string">'foo/some/path/bar'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> PurePath<span class="token punctuation">(</span>Path<span class="token punctuation">(</span><span class="token string">'foo'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> Path<span class="token punctuation">(</span><span class="token string">'bar'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
PurePosixPath<span class="token punctuation">(</span><span class="token string">'foo/bar'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>当 <em>pathsegments</em> 为空的时候，假定为当前目录:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> PurePath<span class="token punctuation">(</span><span class="token punctuation">)</span>
PurePosixPath<span class="token punctuation">(</span><span class="token string">'.'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>当给出一些绝对路径，最后一位将被当作锚（模仿 <code>os.path.join()</code> 的行为）:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> PurePath<span class="token punctuation">(</span><span class="token string">'/etc'</span><span class="token punctuation">,</span> <span class="token string">'/usr'</span><span class="token punctuation">,</span> <span class="token string">'lib64'</span><span class="token punctuation">)</span>
PurePosixPath<span class="token punctuation">(</span><span class="token string">'/usr/lib64'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> PureWindowsPath<span class="token punctuation">(</span><span class="token string">'c:/Windows'</span><span class="token punctuation">,</span> <span class="token string">'d:bar'</span><span class="token punctuation">)</span>
PureWindowsPath<span class="token punctuation">(</span><span class="token string">'d:bar'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>但是，在 Windows 路径中，改变本地根目录并不会丢弃之前盘符的设置:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> PureWindowsPath<span class="token punctuation">(</span><span class="token string">'c:/Windows'</span><span class="token punctuation">,</span> <span class="token string">'/Program Files'</span><span class="token punctuation">)</span>
PureWindowsPath<span class="token punctuation">(</span><span class="token string">'c:/Program Files'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>假斜线和单独的点都会被消除，但是双点 （<code>‘..’</code>） 不会，以防改变符号链接的含义。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> PurePath<span class="token punctuation">(</span><span class="token string">'foo//bar'</span><span class="token punctuation">)</span>
PurePosixPath<span class="token punctuation">(</span><span class="token string">'foo/bar'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> PurePath<span class="token punctuation">(</span><span class="token string">'foo/./bar'</span><span class="token punctuation">)</span>
PurePosixPath<span class="token punctuation">(</span><span class="token string">'foo/bar'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> PurePath<span class="token punctuation">(</span><span class="token string">'foo/../bar'</span><span class="token punctuation">)</span>
PurePosixPath<span class="token punctuation">(</span><span class="token string">'foo/../bar'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>（一个很 naïve 的做法是让 <code>PurePosixPath('foo/../bar')</code> 等同于 <code>PurePosixPath('bar')</code>，如果 <code>foo</code> 是一个指向其他目录的符号链接那么这个做法就将出错）</p>
<p>纯路径对象实现了 <code>os.PathLike</code> 接口，允许它们在任何接受此接口的地方使用。</p>
<p>在 3.6 版更改: 添加了 <code>os.PathLike</code> 接口支持。</p>
<p><em>class</em> <code>pathlib.PurePosixPath</code>(<em>\</em>pathsegments*)</p>
<p>一个 <code>PurePath</code> 的子类，路径风格不同于 Windows 文件系统:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> PurePosixPath<span class="token punctuation">(</span><span class="token string">'/etc'</span><span class="token punctuation">)</span>
PurePosixPath<span class="token punctuation">(</span><span class="token string">'/etc'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><em>pathsegments</em> 参数的指定和 <code>PurePath</code> 相同。</p>
<p><em>class</em> <code>pathlib.PureWindowsPath</code>(<em>\</em>pathsegments*)</p>
<p><code>PurePath</code> 的一个子类，路径风格为 Windows 文件系统路径:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> PureWindowsPath<span class="token punctuation">(</span><span class="token string">'c:/Program Files/'</span><span class="token punctuation">)</span>
PureWindowsPath<span class="token punctuation">(</span><span class="token string">'c:/Program Files'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><em>pathsegments</em> 参数的指定和 <code>PurePath</code> 相同。</p>
<p>无论你正运行什么系统，你都可以实例化这些类，因为它们提供的操作不做任何系统调用。</p>
<h4 id="通用性质"><a href="#通用性质" class="headerlink" title="通用性质"></a>通用性质</h4><p>路径是不可变并可哈希的。相同风格的路径可以排序与比较。这些性质尊重对应风格的大小写转换语义:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> PurePosixPath<span class="token punctuation">(</span><span class="token string">'foo'</span><span class="token punctuation">)</span> <span class="token operator">==</span> PurePosixPath<span class="token punctuation">(</span><span class="token string">'FOO'</span><span class="token punctuation">)</span>
<span class="token boolean">False</span>
<span class="token operator">>></span><span class="token operator">></span> PureWindowsPath<span class="token punctuation">(</span><span class="token string">'foo'</span><span class="token punctuation">)</span> <span class="token operator">==</span> PureWindowsPath<span class="token punctuation">(</span><span class="token string">'FOO'</span><span class="token punctuation">)</span>
<span class="token boolean">True</span>
<span class="token operator">>></span><span class="token operator">></span> PureWindowsPath<span class="token punctuation">(</span><span class="token string">'FOO'</span><span class="token punctuation">)</span> <span class="token keyword">in</span> <span class="token punctuation">{</span> PureWindowsPath<span class="token punctuation">(</span><span class="token string">'foo'</span><span class="token punctuation">)</span> <span class="token punctuation">}</span>
<span class="token boolean">True</span>
<span class="token operator">>></span><span class="token operator">></span> PureWindowsPath<span class="token punctuation">(</span><span class="token string">'C:'</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> PureWindowsPath<span class="token punctuation">(</span><span class="token string">'d:'</span><span class="token punctuation">)</span>
<span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>不同风格的路径比较得到不等的结果并且无法被排序:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> PureWindowsPath<span class="token punctuation">(</span><span class="token string">'foo'</span><span class="token punctuation">)</span> <span class="token operator">==</span> PurePosixPath<span class="token punctuation">(</span><span class="token string">'foo'</span><span class="token punctuation">)</span>
<span class="token boolean">False</span>
<span class="token operator">>></span><span class="token operator">></span> PureWindowsPath<span class="token punctuation">(</span><span class="token string">'foo'</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> PurePosixPath<span class="token punctuation">(</span><span class="token string">'foo'</span><span class="token punctuation">)</span>
Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>
  File <span class="token string">"&lt;stdin>"</span><span class="token punctuation">,</span> line <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">></span>
TypeError<span class="token punctuation">:</span> <span class="token string">'&lt;'</span> <span class="token operator">not</span> supported between instances of <span class="token string">'PureWindowsPath'</span> <span class="token operator">and</span> <span class="token string">'PurePosixPath'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h4><p>斜杠 <code>/</code> 操作符有助于创建子路径，就像 <code>os.path.join()</code> 一样:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> p <span class="token operator">=</span> PurePath<span class="token punctuation">(</span><span class="token string">'/etc'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p
PurePosixPath<span class="token punctuation">(</span><span class="token string">'/etc'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p <span class="token operator">/</span> <span class="token string">'init.d'</span> <span class="token operator">/</span> <span class="token string">'apache2'</span>
PurePosixPath<span class="token punctuation">(</span><span class="token string">'/etc/init.d/apache2'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> q <span class="token operator">=</span> PurePath<span class="token punctuation">(</span><span class="token string">'bin'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token string">'/usr'</span> <span class="token operator">/</span> q
PurePosixPath<span class="token punctuation">(</span><span class="token string">'/usr/bin'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>文件对象可用于任何接受 <code>os.PathLike</code> 接口实现的地方。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> os
<span class="token operator">>></span><span class="token operator">></span> p <span class="token operator">=</span> PurePath<span class="token punctuation">(</span><span class="token string">'/etc'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> os<span class="token punctuation">.</span>fspath<span class="token punctuation">(</span>p<span class="token punctuation">)</span>
<span class="token string">'/etc'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>路径的字符串表示法为它自己原始的文件系统路径（以原生形式，例如在 Windows 下使用反斜杠）。你可以传递给任何需要字符串形式路径的函数。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> p <span class="token operator">=</span> PurePath<span class="token punctuation">(</span><span class="token string">'/etc'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> str<span class="token punctuation">(</span>p<span class="token punctuation">)</span>
<span class="token string">'/etc'</span>
<span class="token operator">>></span><span class="token operator">></span> p <span class="token operator">=</span> PureWindowsPath<span class="token punctuation">(</span><span class="token string">'c:/Program Files'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> str<span class="token punctuation">(</span>p<span class="token punctuation">)</span>
<span class="token string">'c:\\Program Files'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>类似地，在路径上调用 <code>bytes</code> 将原始文件系统路径作为字节对象给出，就像被 <code>os.fsencode()</code> 编码一样:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> bytes<span class="token punctuation">(</span>p<span class="token punctuation">)</span>
b<span class="token string">'/etc'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>注解</p>
<p>只推荐在 Unix 下调用 <code>bytes</code>。在 Windows， unicode 形式是文件系统路径的规范表示法。</p>
<h4 id="访问个别部分"><a href="#访问个别部分" class="headerlink" title="访问个别部分"></a>访问个别部分</h4><p>为了访问路径独立的部分 （组件），使用以下特征属性：</p>
<pre><code>PurePath.parts</code></pre><p>一个元组，可以访问路径的多个组件:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> p <span class="token operator">=</span> PurePath<span class="token punctuation">(</span><span class="token string">'/usr/bin/python3'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>parts
<span class="token punctuation">(</span><span class="token string">'/'</span><span class="token punctuation">,</span> <span class="token string">'usr'</span><span class="token punctuation">,</span> <span class="token string">'bin'</span><span class="token punctuation">,</span> <span class="token string">'python3'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p <span class="token operator">=</span> PureWindowsPath<span class="token punctuation">(</span><span class="token string">'c:/Program Files/PSF'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>parts
<span class="token punctuation">(</span><span class="token string">'c:\\'</span><span class="token punctuation">,</span> <span class="token string">'Program Files'</span><span class="token punctuation">,</span> <span class="token string">'PSF'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>（注意盘符和本地根目录是如何重组的）</p>
<h4 id="方法和特征属性"><a href="#方法和特征属性" class="headerlink" title="方法和特征属性"></a>方法和特征属性</h4><p>纯路径提供以下方法和特征属性：</p>
<pre><code>PurePath.drive</code></pre><p>一个表示驱动器盘符或命名的字符串，如果存在:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> PureWindowsPath<span class="token punctuation">(</span><span class="token string">'c:/Program Files/'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>drive
<span class="token string">'c:'</span>
<span class="token operator">>></span><span class="token operator">></span> PureWindowsPath<span class="token punctuation">(</span><span class="token string">'/Program Files/'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>drive
<span class="token string">''</span>
<span class="token operator">>></span><span class="token operator">></span> PurePosixPath<span class="token punctuation">(</span><span class="token string">'/etc'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>drive
<span class="token string">''</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>UNC 分享也被认作驱动器:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> PureWindowsPath<span class="token punctuation">(</span><span class="token string">'//host/share/foo.txt'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>drive
<span class="token string">'\\\\host\\share'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><code>PurePath.root</code></p>
<p>一个表示（本地或全局）根的字符串，如果存在:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> PureWindowsPath<span class="token punctuation">(</span><span class="token string">'c:/Program Files/'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>root
<span class="token string">'\\'</span>
<span class="token operator">>></span><span class="token operator">></span> PureWindowsPath<span class="token punctuation">(</span><span class="token string">'c:Program Files/'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>root
<span class="token string">''</span>
<span class="token operator">>></span><span class="token operator">></span> PurePosixPath<span class="token punctuation">(</span><span class="token string">'/etc'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>root
<span class="token string">'/'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>UNC 分享一样拥有根:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> PureWindowsPath<span class="token punctuation">(</span><span class="token string">'//host/share'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>root
<span class="token string">'\\'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><code>PurePath.anchor</code></p>
<p>驱动器和根的联合:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> PureWindowsPath<span class="token punctuation">(</span><span class="token string">'c:/Program Files/'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>anchor
<span class="token string">'c:\\'</span>
<span class="token operator">>></span><span class="token operator">></span> PureWindowsPath<span class="token punctuation">(</span><span class="token string">'c:Program Files/'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>anchor
<span class="token string">'c:'</span>
<span class="token operator">>></span><span class="token operator">></span> PurePosixPath<span class="token punctuation">(</span><span class="token string">'/etc'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>anchor
<span class="token string">'/'</span>
<span class="token operator">>></span><span class="token operator">></span> PureWindowsPath<span class="token punctuation">(</span><span class="token string">'//host/share'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>anchor
<span class="token string">'\\\\host\\share\\'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>An immutable sequence providing access to the logical ancestors of the path:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> p <span class="token operator">=</span> PureWindowsPath<span class="token punctuation">(</span><span class="token string">'c:/foo/bar/setup.py'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>parents<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
PureWindowsPath<span class="token punctuation">(</span><span class="token string">'c:/foo/bar'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>parents<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>
PureWindowsPath<span class="token punctuation">(</span><span class="token string">'c:/foo'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>parents<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span>
PureWindowsPath<span class="token punctuation">(</span><span class="token string">'c:/'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在 3.10 版更改: parents 序列现在支持 切片 负的索引值。</p>
<pre><code>PurePath.parent</code></pre><p>此路径的逻辑父路径:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> p <span class="token operator">=</span> PurePosixPath<span class="token punctuation">(</span><span class="token string">'/a/b/c/d'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>parent
PurePosixPath<span class="token punctuation">(</span><span class="token string">'/a/b/c'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>你不能超过一个 anchor 或空路径:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> p <span class="token operator">=</span> PurePosixPath<span class="token punctuation">(</span><span class="token string">'/'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>parent
PurePosixPath<span class="token punctuation">(</span><span class="token string">'/'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p <span class="token operator">=</span> PurePosixPath<span class="token punctuation">(</span><span class="token string">'.'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>parent
PurePosixPath<span class="token punctuation">(</span><span class="token string">'.'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>注解</p>
<p>这是一个单纯的词法操作，因此有以下行为:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> p <span class="token operator">=</span> PurePosixPath<span class="token punctuation">(</span><span class="token string">'foo/..'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>parent
PurePosixPath<span class="token punctuation">(</span><span class="token string">'foo'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>如果你想要向上移动任意文件系统路径，推荐先使用 <code>Path.resolve()</code> 来解析符号链接以及消除 <code>".."</code> 组件。</p>
<pre><code>PurePath.name</code></pre><p>一个表示最后路径组件的字符串，排除了驱动器与根目录，如果存在的话:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> PurePosixPath<span class="token punctuation">(</span><span class="token string">'my/library/setup.py'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>name
<span class="token string">'setup.py'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>UNC 驱动器名不被考虑:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> PureWindowsPath<span class="token punctuation">(</span><span class="token string">'//some/share/setup.py'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>name
<span class="token string">'setup.py'</span>
<span class="token operator">>></span><span class="token operator">></span> PureWindowsPath<span class="token punctuation">(</span><span class="token string">'//some/share'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>name
<span class="token string">''</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>PurePath.suffix</code></p>
<p>最后一个组件的文件扩展名，如果存在:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> PurePosixPath<span class="token punctuation">(</span><span class="token string">'my/library/setup.py'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>suffix
<span class="token string">'.py'</span>
<span class="token operator">>></span><span class="token operator">></span> PurePosixPath<span class="token punctuation">(</span><span class="token string">'my/library.tar.gz'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>suffix
<span class="token string">'.gz'</span>
<span class="token operator">>></span><span class="token operator">></span> PurePosixPath<span class="token punctuation">(</span><span class="token string">'my/library'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>suffix
<span class="token string">''</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>PurePath.suffixes</code></p>
<p>路径的文件扩展名列表:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> PurePosixPath<span class="token punctuation">(</span><span class="token string">'my/library.tar.gar'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>suffixes
<span class="token punctuation">[</span><span class="token string">'.tar'</span><span class="token punctuation">,</span> <span class="token string">'.gar'</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> PurePosixPath<span class="token punctuation">(</span><span class="token string">'my/library.tar.gz'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>suffixes
<span class="token punctuation">[</span><span class="token string">'.tar'</span><span class="token punctuation">,</span> <span class="token string">'.gz'</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> PurePosixPath<span class="token punctuation">(</span><span class="token string">'my/library'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>suffixes
<span class="token punctuation">[</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>PurePath.stem</code></p>
<p>最后一个路径组件，除去后缀:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> PurePosixPath<span class="token punctuation">(</span><span class="token string">'my/library.tar.gz'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>stem
<span class="token string">'library.tar'</span>
<span class="token operator">>></span><span class="token operator">></span> PurePosixPath<span class="token punctuation">(</span><span class="token string">'my/library.tar'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>stem
<span class="token string">'library'</span>
<span class="token operator">>></span><span class="token operator">></span> PurePosixPath<span class="token punctuation">(</span><span class="token string">'my/library'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>stem
<span class="token string">'library'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>PurePath.as_posix</code>()</p>
<p>返回使用正斜杠（<code>/</code>）的路径字符串:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> p <span class="token operator">=</span> PureWindowsPath<span class="token punctuation">(</span><span class="token string">'c:\\windows'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> str<span class="token punctuation">(</span>p<span class="token punctuation">)</span>
<span class="token string">'c:\\windows'</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>as_posix<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token string">'c:/windows'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>PurePath.as_uri</code>()</p>
<p>将路径表示为 <code>file</code> URL。如果并非绝对路径，抛出 <code>ValueError</code>。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> p <span class="token operator">=</span> PurePosixPath<span class="token punctuation">(</span><span class="token string">'/etc/passwd'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>as_uri<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token string">'file:///etc/passwd'</span>
<span class="token operator">>></span><span class="token operator">></span> p <span class="token operator">=</span> PureWindowsPath<span class="token punctuation">(</span><span class="token string">'c:/Windows'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>as_uri<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token string">'file:///c:/Windows'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>PurePath.is_absolute</code>()</p>
<p>返回此路径是否为绝对路径。如果路径同时拥有驱动器符与根路径（如果风格允许）则将被认作绝对路径。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> PurePosixPath<span class="token punctuation">(</span><span class="token string">'/a/b'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>is_absolute<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token boolean">True</span>
<span class="token operator">>></span><span class="token operator">></span> PurePosixPath<span class="token punctuation">(</span><span class="token string">'a/b'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>is_absolute<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token boolean">False</span>
<span class="token operator">>></span><span class="token operator">></span> PureWindowsPath<span class="token punctuation">(</span><span class="token string">'c:/a/b'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>is_absolute<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token boolean">True</span>
<span class="token operator">>></span><span class="token operator">></span> PureWindowsPath<span class="token punctuation">(</span><span class="token string">'/a/b'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>is_absolute<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token boolean">False</span>
<span class="token operator">>></span><span class="token operator">></span> PureWindowsPath<span class="token punctuation">(</span><span class="token string">'c:'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>is_absolute<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token boolean">False</span>
<span class="token operator">>></span><span class="token operator">></span> PureWindowsPath<span class="token punctuation">(</span><span class="token string">'//some/share'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>is_absolute<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>PurePath.is_relative_to</code>(<em>\</em>other*)</p>
<p>返回此路径是否相对于 <em>other</em> 的路径。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> p <span class="token operator">=</span> PurePath<span class="token punctuation">(</span><span class="token string">'/etc/passwd'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>is_relative_to<span class="token punctuation">(</span><span class="token string">'/etc'</span><span class="token punctuation">)</span>
<span class="token boolean">True</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>is_relative_to<span class="token punctuation">(</span><span class="token string">'/usr'</span><span class="token punctuation">)</span>
<span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>3.9 新版功能.</p>
<p><code>PurePath.is_reserved</code>()</p>
<p>在 <code>PureWindowsPath</code>，如果路径是被 Windows 保留的则返回 <code>True</code>，否则 <code>False</code>。在 <code>PurePosixPath</code>，总是返回 <code>False</code>。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> PureWindowsPath<span class="token punctuation">(</span><span class="token string">'nul'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>is_reserved<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token boolean">True</span>
<span class="token operator">>></span><span class="token operator">></span> PurePosixPath<span class="token punctuation">(</span><span class="token string">'nul'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>is_reserved<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>当保留路径上的文件系统被调用，则可能出现玄学失败或者意料之外的效应。</p>
<p><code>PurePath.joinpath</code>(<em>\</em>other*)</p>
<p>调用此方法等同于将每个 <em>other</em> 参数中的项目连接在一起:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> PurePosixPath<span class="token punctuation">(</span><span class="token string">'/etc'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>joinpath<span class="token punctuation">(</span><span class="token string">'passwd'</span><span class="token punctuation">)</span>
PurePosixPath<span class="token punctuation">(</span><span class="token string">'/etc/passwd'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> PurePosixPath<span class="token punctuation">(</span><span class="token string">'/etc'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>joinpath<span class="token punctuation">(</span>PurePosixPath<span class="token punctuation">(</span><span class="token string">'passwd'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
PurePosixPath<span class="token punctuation">(</span><span class="token string">'/etc/passwd'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> PurePosixPath<span class="token punctuation">(</span><span class="token string">'/etc'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>joinpath<span class="token punctuation">(</span><span class="token string">'init.d'</span><span class="token punctuation">,</span> <span class="token string">'apache2'</span><span class="token punctuation">)</span>
PurePosixPath<span class="token punctuation">(</span><span class="token string">'/etc/init.d/apache2'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> PureWindowsPath<span class="token punctuation">(</span><span class="token string">'c:'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>joinpath<span class="token punctuation">(</span><span class="token string">'/Program Files'</span><span class="token punctuation">)</span>
PureWindowsPath<span class="token punctuation">(</span><span class="token string">'c:/Program Files'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>PurePath.match</code>(<em>pattern</em>)</p>
<p>将此路径与提供的通配符风格的模式匹配。如果匹配成功则返回 <code>True</code>，否则返回 <code>False</code>。</p>
<p>如果 <em>pattern</em> 是相对的，则路径可以是相对路径或绝对路径，并且匹配是从右侧完成的：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> PurePath<span class="token punctuation">(</span><span class="token string">'a/b.py'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>match<span class="token punctuation">(</span><span class="token string">'*.py'</span><span class="token punctuation">)</span>
<span class="token boolean">True</span>
<span class="token operator">>></span><span class="token operator">></span> PurePath<span class="token punctuation">(</span><span class="token string">'/a/b/c.py'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>match<span class="token punctuation">(</span><span class="token string">'b/*.py'</span><span class="token punctuation">)</span>
<span class="token boolean">True</span>
<span class="token operator">>></span><span class="token operator">></span> PurePath<span class="token punctuation">(</span><span class="token string">'/a/b/c.py'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>match<span class="token punctuation">(</span><span class="token string">'a/*.py'</span><span class="token punctuation">)</span>
<span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果 <em>pattern</em> 是绝对的，则路径必须是绝对的，并且路径必须完全匹配:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> PurePath<span class="token punctuation">(</span><span class="token string">'/a.py'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>match<span class="token punctuation">(</span><span class="token string">'/*.py'</span><span class="token punctuation">)</span>
<span class="token boolean">True</span>
<span class="token operator">>></span><span class="token operator">></span> PurePath<span class="token punctuation">(</span><span class="token string">'a/b.py'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>match<span class="token punctuation">(</span><span class="token string">'/*.py'</span><span class="token punctuation">)</span>
<span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>与其他方法一样，是否大小写敏感遵循平台的默认规则:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> PurePosixPath<span class="token punctuation">(</span><span class="token string">'b.py'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>match<span class="token punctuation">(</span><span class="token string">'*.PY'</span><span class="token punctuation">)</span>
<span class="token boolean">False</span>
<span class="token operator">>></span><span class="token operator">></span> PureWindowsPath<span class="token punctuation">(</span><span class="token string">'b.py'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>match<span class="token punctuation">(</span><span class="token string">'*.PY'</span><span class="token punctuation">)</span>
<span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>PurePath.relative_to</code>(<em>\</em>other*)</p>
<p>计算此路径相对 <em>other</em> 表示路径的版本。如果不可计算，则抛出 ValueError:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> p <span class="token operator">=</span> PurePosixPath<span class="token punctuation">(</span><span class="token string">'/etc/passwd'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>relative_to<span class="token punctuation">(</span><span class="token string">'/'</span><span class="token punctuation">)</span>
PurePosixPath<span class="token punctuation">(</span><span class="token string">'etc/passwd'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>relative_to<span class="token punctuation">(</span><span class="token string">'/etc'</span><span class="token punctuation">)</span>
PurePosixPath<span class="token punctuation">(</span><span class="token string">'passwd'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>relative_to<span class="token punctuation">(</span><span class="token string">'/usr'</span><span class="token punctuation">)</span>
Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>
  File <span class="token string">"&lt;stdin>"</span><span class="token punctuation">,</span> line <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">></span>
  File <span class="token string">"pathlib.py"</span><span class="token punctuation">,</span> line <span class="token number">694</span><span class="token punctuation">,</span> <span class="token keyword">in</span> relative_to
    <span class="token punctuation">.</span>format<span class="token punctuation">(</span>str<span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">,</span> str<span class="token punctuation">(</span>formatted<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
ValueError<span class="token punctuation">:</span> <span class="token string">'/etc/passwd'</span> <span class="token keyword">is</span> <span class="token operator">not</span> <span class="token keyword">in</span> the subpath of <span class="token string">'/usr'</span> OR one path <span class="token keyword">is</span> relative <span class="token operator">and</span> the other absolute<span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>注意：此函数是 <code>PurePath</code> 的一部分并且适用于字符串。 它不会检查或访问下层的文件结构。</p>
<p><code>PurePath.with_name</code>(<em>name</em>)</p>
<p>返回一个新的路径并修改 <code>name</code>。如果原本路径没有 name，ValueError 被抛出:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> p <span class="token operator">=</span> PureWindowsPath<span class="token punctuation">(</span><span class="token string">'c:/Downloads/pathlib.tar.gz'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>with_name<span class="token punctuation">(</span><span class="token string">'setup.py'</span><span class="token punctuation">)</span>
PureWindowsPath<span class="token punctuation">(</span><span class="token string">'c:/Downloads/setup.py'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p <span class="token operator">=</span> PureWindowsPath<span class="token punctuation">(</span><span class="token string">'c:/'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>with_name<span class="token punctuation">(</span><span class="token string">'setup.py'</span><span class="token punctuation">)</span>
Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>
  File <span class="token string">"&lt;stdin>"</span><span class="token punctuation">,</span> line <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">></span>
  File <span class="token string">"/home/antoine/cpython/default/Lib/pathlib.py"</span><span class="token punctuation">,</span> line <span class="token number">751</span><span class="token punctuation">,</span> <span class="token keyword">in</span> with_name
    <span class="token keyword">raise</span> ValueError<span class="token punctuation">(</span><span class="token string">"%r has an empty name"</span> <span class="token operator">%</span> <span class="token punctuation">(</span>self<span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
ValueError<span class="token punctuation">:</span> PureWindowsPath<span class="token punctuation">(</span><span class="token string">'c:/'</span><span class="token punctuation">)</span> has an empty name<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>PurePath.with_stem</code>(<em>stem</em>)</p>
<p>返回一个带有修改后 <code>stem</code> 的新路径。 如果原路径没有名称，则会引发 ValueError:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> p <span class="token operator">=</span> PureWindowsPath<span class="token punctuation">(</span><span class="token string">'c:/Downloads/draft.txt'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>with_stem<span class="token punctuation">(</span><span class="token string">'final'</span><span class="token punctuation">)</span>
PureWindowsPath<span class="token punctuation">(</span><span class="token string">'c:/Downloads/final.txt'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p <span class="token operator">=</span> PureWindowsPath<span class="token punctuation">(</span><span class="token string">'c:/Downloads/pathlib.tar.gz'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>with_stem<span class="token punctuation">(</span><span class="token string">'lib'</span><span class="token punctuation">)</span>
PureWindowsPath<span class="token punctuation">(</span><span class="token string">'c:/Downloads/lib.gz'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p <span class="token operator">=</span> PureWindowsPath<span class="token punctuation">(</span><span class="token string">'c:/'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>with_stem<span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span>
Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>
  File <span class="token string">"&lt;stdin>"</span><span class="token punctuation">,</span> line <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">></span>
  File <span class="token string">"/home/antoine/cpython/default/Lib/pathlib.py"</span><span class="token punctuation">,</span> line <span class="token number">861</span><span class="token punctuation">,</span> <span class="token keyword">in</span> with_stem
    <span class="token keyword">return</span> self<span class="token punctuation">.</span>with_name<span class="token punctuation">(</span>stem <span class="token operator">+</span> self<span class="token punctuation">.</span>suffix<span class="token punctuation">)</span>
  File <span class="token string">"/home/antoine/cpython/default/Lib/pathlib.py"</span><span class="token punctuation">,</span> line <span class="token number">851</span><span class="token punctuation">,</span> <span class="token keyword">in</span> with_name
    <span class="token keyword">raise</span> ValueError<span class="token punctuation">(</span><span class="token string">"%r has an empty name"</span> <span class="token operator">%</span> <span class="token punctuation">(</span>self<span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
ValueError<span class="token punctuation">:</span> PureWindowsPath<span class="token punctuation">(</span><span class="token string">'c:/'</span><span class="token punctuation">)</span> has an empty name<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>3.9 新版功能.</p>
<p><code>PurePath.with_suffix</code>(<em>suffix</em>)</p>
<p>返回一个新的路径并修改 <code>suffix</code>。如果原本的路径没有后缀，新的 <em>suffix</em> 则被追加以代替。如果 <em>suffix</em> 是空字符串，则原本的后缀被移除:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> p <span class="token operator">=</span> PureWindowsPath<span class="token punctuation">(</span><span class="token string">'c:/Downloads/pathlib.tar.gz'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>with_suffix<span class="token punctuation">(</span><span class="token string">'.bz2'</span><span class="token punctuation">)</span>
PureWindowsPath<span class="token punctuation">(</span><span class="token string">'c:/Downloads/pathlib.tar.bz2'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p <span class="token operator">=</span> PureWindowsPath<span class="token punctuation">(</span><span class="token string">'README'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>with_suffix<span class="token punctuation">(</span><span class="token string">'.txt'</span><span class="token punctuation">)</span>
PureWindowsPath<span class="token punctuation">(</span><span class="token string">'README.txt'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p <span class="token operator">=</span> PureWindowsPath<span class="token punctuation">(</span><span class="token string">'README.txt'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>with_suffix<span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span>
PureWindowsPath<span class="token punctuation">(</span><span class="token string">'README'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="具体路径"><a href="#具体路径" class="headerlink" title="具体路径"></a>具体路径</h3><p>具体路径是纯路径的子类。除了后者提供的操作之外，它们还提供了对路径对象进行系统调用的方法。有三种方法可以实例化具体路径:</p>
<p><em>class</em> <code>pathlib.Path</code>(<em>\</em>pathsegments*)</p>
<p>一个 <code>PurePath</code> 的子类，此类以当前系统的路径风格表示路径（实例化为 <code>PosixPath</code> 或 <code>WindowsPath</code>）:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> Path<span class="token punctuation">(</span><span class="token string">'setup.py'</span><span class="token punctuation">)</span>
PosixPath<span class="token punctuation">(</span><span class="token string">'setup.py'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><em>pathsegments</em> 参数的指定和 <code>PurePath</code> 相同。</p>
<p><em>class</em> <code>pathlib.PosixPath</code>(<em>\</em>pathsegments*)</p>
<p>一个 <code>Path</code> 和 <code>PurePosixPath</code> 的子类，此类表示一个非 Windows 文件系统的具体路径:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> PosixPath<span class="token punctuation">(</span><span class="token string">'/etc'</span><span class="token punctuation">)</span>
PosixPath<span class="token punctuation">(</span><span class="token string">'/etc'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><em>pathsegments</em> 参数的指定和 <code>PurePath</code> 相同。</p>
<p><em>class</em> <code>pathlib.WindowsPath</code>(<em>\</em>pathsegments*)</p>
<p><code>Path</code> 和 <code>PureWindowsPath</code> 的子类，从类表示一个 Windows 文件系统的具体路径:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> WindowsPath<span class="token punctuation">(</span><span class="token string">'c:/Program Files/'</span><span class="token punctuation">)</span>
WindowsPath<span class="token punctuation">(</span><span class="token string">'c:/Program Files'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><em>pathsegments</em> 参数的指定和 <code>PurePath</code> 相同。</p>
<p>你只能实例化与当前系统风格相同的类（允许系统调用作用于不兼容的路径风格可能在应用程序中导致缺陷或失败）:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> os
<span class="token operator">>></span><span class="token operator">></span> os<span class="token punctuation">.</span>name
<span class="token string">'posix'</span>
<span class="token operator">>></span><span class="token operator">></span> Path<span class="token punctuation">(</span><span class="token string">'setup.py'</span><span class="token punctuation">)</span>
PosixPath<span class="token punctuation">(</span><span class="token string">'setup.py'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> PosixPath<span class="token punctuation">(</span><span class="token string">'setup.py'</span><span class="token punctuation">)</span>
PosixPath<span class="token punctuation">(</span><span class="token string">'setup.py'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> WindowsPath<span class="token punctuation">(</span><span class="token string">'setup.py'</span><span class="token punctuation">)</span>
Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>
  File <span class="token string">"&lt;stdin>"</span><span class="token punctuation">,</span> line <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">></span>
  File <span class="token string">"pathlib.py"</span><span class="token punctuation">,</span> line <span class="token number">798</span><span class="token punctuation">,</span> <span class="token keyword">in</span> __new__
    <span class="token operator">%</span> <span class="token punctuation">(</span>cls<span class="token punctuation">.</span>__name__<span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
NotImplementedError<span class="token punctuation">:</span> cannot instantiate <span class="token string">'WindowsPath'</span> on your system<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>除纯路径方法外，实体路径还提供以下方法。 如果系统调用失败（例如因为路径不存在）这些方法中许多都会引发 <code>OSError</code>。</p>
<p>在 3.8 版更改: 对于包含 OS 层级无法表示字符的路径，<code>exists()</code>, <code>is_dir()</code>, <code>is_file()</code>, <code>is_mount()</code>, <code>is_symlink()</code>, <code>is_block_device()</code>, <code>is_char_device()</code>, <code>is_fifo()</code>, <code>is_socket()</code> 现在将返回 <code>False</code> 而不是引发异常。</p>
<p><em>classmethod</em> <code>Path.cwd</code>()</p>
<p>返回一个新的表示当前目录的路径对象（和 <code>os.getcwd()</code> 返回的相同）:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> Path<span class="token punctuation">.</span>cwd<span class="token punctuation">(</span><span class="token punctuation">)</span>
PosixPath<span class="token punctuation">(</span><span class="token string">'/home/antoine/pathlib'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><em>classmethod</em> <code>Path.home</code>()</p>
<p>返回一个表示用户家目录的新路径对象（与带 <code>~</code> 构造的 <code>os.path.expanduser()</code> 所返回的相同）。 如果无法解析家目录，则会引发 <code>RuntimeError</code>。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> Path<span class="token punctuation">.</span>home<span class="token punctuation">(</span><span class="token punctuation">)</span>
PosixPath<span class="token punctuation">(</span><span class="token string">'/home/antoine'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>3.5 新版功能.</p>
<p><code>Path.stat</code>(<em>**,</em> follow_symlinks=True*)</p>
<p>返回一个 <code>os.stat_result</code> 对象，其中包含有关此路径的信息，例如 <code>os.stat()</code>。 结果会在每次调用此方法时重新搜索。</p>
<p>此方法通常会跟随符号链接；要对 symlink 使用 stat 请添加参数 <code>follow_symlinks=False</code>，或者使用 <code>lstat()</code>。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> p <span class="token operator">=</span> Path<span class="token punctuation">(</span><span class="token string">'setup.py'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>stat<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>st_size
<span class="token number">956</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>stat<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>st_mtime
<span class="token number">1327883547.852554</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在 3.10 版更改: 增加了 <em>follow_symlinks</em> 形参。</p>
<p><code>Path.chmod</code>(<em>mode</em>, <em>**,</em> follow_symlinks=True*)</p>
<p>改变文件模式和权限，和 <code>os.chmod()</code> 一样。</p>
<p>此方法通常会跟随符号链接。 某些 Unix 变种支持改变 symlink 本身的权限；在这些平台上你可以添加参数 <code>follow_symlinks=False</code>，或者使用 <code>lchmod()</code>。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> p <span class="token operator">=</span> Path<span class="token punctuation">(</span><span class="token string">'setup.py'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>stat<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>st_mode
<span class="token number">33277</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>chmod<span class="token punctuation">(</span><span class="token number">0o444</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>stat<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>st_mode
<span class="token number">33060</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在 3.10 版更改: 增加了 <em>follow_symlinks</em> 形参。</p>
<p><code>Path.exists</code>()</p>
<p>此路径是否指向一个已存在的文件或目录:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> Path<span class="token punctuation">(</span><span class="token string">'.'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>exists<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token boolean">True</span>
<span class="token operator">>></span><span class="token operator">></span> Path<span class="token punctuation">(</span><span class="token string">'setup.py'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>exists<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token boolean">True</span>
<span class="token operator">>></span><span class="token operator">></span> Path<span class="token punctuation">(</span><span class="token string">'/etc'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>exists<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token boolean">True</span>
<span class="token operator">>></span><span class="token operator">></span> Path<span class="token punctuation">(</span><span class="token string">'nonexistentfile'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>exists<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>注解</p>
<p>如果路径指向一个符号链接， <code>exists()</code> 返回此符号链接是否指向存在的文件或目录。</p>
<p><code>Path.expanduser</code>()</p>
<p>返回带有扩展 <code>~</code> 和 <code>~user</code> 构造的新路径，与 <code>os.path.expanduser()</code> 所返回的相同。 如果无法解析家目录，则会引发 <code>RuntimeError</code>。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> p <span class="token operator">=</span> PosixPath<span class="token punctuation">(</span><span class="token string">'~/films/Monty Python'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>expanduser<span class="token punctuation">(</span><span class="token punctuation">)</span>
PosixPath<span class="token punctuation">(</span><span class="token string">'/home/eric/films/Monty Python'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>3.5 新版功能.</p>
<p><code>Path.glob</code>(<em>pattern</em>)</p>
<p>解析相对于此路径的通配符 <em>pattern</em>，产生所有匹配的文件:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> sorted<span class="token punctuation">(</span>Path<span class="token punctuation">(</span><span class="token string">'.'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>glob<span class="token punctuation">(</span><span class="token string">'*.py'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span>PosixPath<span class="token punctuation">(</span><span class="token string">'pathlib.py'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> PosixPath<span class="token punctuation">(</span><span class="token string">'setup.py'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> PosixPath<span class="token punctuation">(</span><span class="token string">'test_pathlib.py'</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> sorted<span class="token punctuation">(</span>Path<span class="token punctuation">(</span><span class="token string">'.'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>glob<span class="token punctuation">(</span><span class="token string">'*/*.py'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span>PosixPath<span class="token punctuation">(</span><span class="token string">'docs/conf.py'</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>pattern 的形式与 <code>fnmatch</code> 的相同，还增加了 “<code>**</code>“ 表示 “此目录以及所有子目录，递归”。 换句话说，它启用递归通配:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> sorted<span class="token punctuation">(</span>Path<span class="token punctuation">(</span><span class="token string">'.'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>glob<span class="token punctuation">(</span><span class="token string">'**/*.py'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span>PosixPath<span class="token punctuation">(</span><span class="token string">'build/lib/pathlib.py'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
 PosixPath<span class="token punctuation">(</span><span class="token string">'docs/conf.py'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
 PosixPath<span class="token punctuation">(</span><span class="token string">'pathlib.py'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
 PosixPath<span class="token punctuation">(</span><span class="token string">'setup.py'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
 PosixPath<span class="token punctuation">(</span><span class="token string">'test_pathlib.py'</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>注解</p>
<p>在一个较大的目录树中使用 “<code>**</code>“ 模式可能会消耗非常多的时间。</p>
<p>引发一个 审计事件 <code>pathlib.Path.glob</code> 附带参数 <code>self</code>, <code>pattern</code>。</p>
<p><code>Path.group</code>()</p>
<p>返回拥有此文件的用户组。如果文件的 GID 无法在系统数据库中找到，将抛出 <code>KeyError</code> 。</p>
<p><code>Path.is_dir</code>()</p>
<p>如果路径指向一个目录（或者一个指向目录的符号链接）则返回 <code>True</code>，如果指向其他类型的文件则返回 <code>False</code>。</p>
<p>当路径不存在或者是一个破损的符号链接时也会返回 <code>False</code>；其他错误（例如权限错误）被传播。</p>
<p><code>Path.is_file</code>()</p>
<p>如果路径指向一个正常的文件（或者一个指向正常文件的符号链接）则返回 <code>True</code>，如果指向其他类型的文件则返回 <code>False</code>。</p>
<p>当路径不存在或者是一个破损的符号链接时也会返回 <code>False</code>；其他错误（例如权限错误）被传播。</p>
<p><code>Path.is_mount</code>()</p>
<p>如果路径是一个 <em>挂载点 &lt;mount point&gt;*：在文件系统中被其他不同的文件系统挂载的地点。在 POSIX 系统，此函数检查 *path</em> 的父级 —— <code>path/..</code> 是否处于一个和 <em>path</em> 不同的设备中，或者 file:path/.. 和 <em>path</em> 是否指向相同设备的相同 i-node —— 这能检测所有 Unix 以及 POSIX 变种上的挂载点。 Windows 上未实现。</p>
<p>3.7 新版功能.</p>
<p><code>Path.is_symlink</code>()</p>
<p>如果路径指向符号链接则返回 <code>True</code>， 否则 <code>False</code>。</p>
<p>如果路径不存在也返回 <code>False</code>；其他错误（例如权限错误）被传播。</p>
<p><code>Path.is_socket</code>()</p>
<p>如果路径指向一个 Unix socket 文件（或者指向 Unix socket 文件的符号链接）则返回 <code>True</code>，如果指向其他类型的文件则返回 <code>False</code>。</p>
<p>当路径不存在或者是一个破损的符号链接时也会返回 <code>False</code>；其他错误（例如权限错误）被传播。</p>
<p><code>Path.is_fifo</code>()</p>
<p>如果路径指向一个先进先出存储（或者指向先进先出存储的符号链接）则返回 <code>True</code> ，指向其他类型的文件则返回 <code>False</code>。</p>
<p>当路径不存在或者是一个破损的符号链接时也会返回 <code>False</code>；其他错误（例如权限错误）被传播。</p>
<p><code>Path.is_block_device</code>()</p>
<p>如果文件指向一个块设备（或者指向块设备的符号链接）则返回 <code>True</code>，指向其他类型的文件则返回 <code>False</code>。</p>
<p>当路径不存在或者是一个破损的符号链接时也会返回 <code>False</code>；其他错误（例如权限错误）被传播。</p>
<p><code>Path.is_char_device</code>()</p>
<p>如果路径指向一个字符设备（或指向字符设备的符号链接）则返回 <code>True</code>，指向其他类型的文件则返回 <code>False</code>。</p>
<p>当路径不存在或者是一个破损的符号链接时也会返回 <code>False</code>；其他错误（例如权限错误）被传播。</p>
<p><code>Path.iterdir</code>()</p>
<p>当路径指向一个目录时，产生该路径下的对象的路径:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> p <span class="token operator">=</span> Path<span class="token punctuation">(</span><span class="token string">'docs'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">for</span> child <span class="token keyword">in</span> p<span class="token punctuation">.</span>iterdir<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> child
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
PosixPath<span class="token punctuation">(</span><span class="token string">'docs/conf.py'</span><span class="token punctuation">)</span>
PosixPath<span class="token punctuation">(</span><span class="token string">'docs/_templates'</span><span class="token punctuation">)</span>
PosixPath<span class="token punctuation">(</span><span class="token string">'docs/make.bat'</span><span class="token punctuation">)</span>
PosixPath<span class="token punctuation">(</span><span class="token string">'docs/index.rst'</span><span class="token punctuation">)</span>
PosixPath<span class="token punctuation">(</span><span class="token string">'docs/_build'</span><span class="token punctuation">)</span>
PosixPath<span class="token punctuation">(</span><span class="token string">'docs/_static'</span><span class="token punctuation">)</span>
PosixPath<span class="token punctuation">(</span><span class="token string">'docs/Makefile'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>子条目会以任意顺序生成，并且不包括特殊条目 <code>'.'</code> 和 <code>'..'</code>。 如果有文件在迭代器创建之后在目录中被移除或添加，是否要包括该文件对应的路径对象并没有规定。</p>
<p><code>Path.lchmod</code>(<em>mode</em>)</p>
<p>就像 <code>Path.chmod()</code> 但是如果路径指向符号链接则是修改符号链接的模式，而不是修改符号链接的目标。</p>
<p><code>Path.lstat</code>()</p>
<p>就和 <code>Path.stat()</code> 一样，但是如果路径指向符号链接，则是返回符号链接而不是目标的信息。</p>
<p><code>Path.mkdir</code>(<em>mode=511</em>, <em>parents=False</em>, <em>exist_ok=False</em>)</p>
<p>新建给定路径的目录。如果给出了 <em>mode</em> ，它将与当前进程的 <code>umask</code> 值合并来决定文件模式和访问标志。如果路径已经存在，则抛出 <code>FileExistsError</code>。</p>
<p>如果 <em>parents</em> 为 true，任何找不到的父目录都会伴随着此路径被创建；它们会以默认权限被创建，而不考虑 <em>mode</em> 设置（模仿 POSIX 的 <code>mkdir -p</code> 命令）。</p>
<p>如果 <em>parents</em> 为 false（默认），则找不到的父级目录会导致 <code>FileNotFoundError</code> 被抛出。</p>
<p>如果 <em>exist_ok</em> 为 false（默认），则在目标已存在的情况下抛出 <code>FileExistsError</code>。</p>
<p>如果 <em>exist_ok</em> 为 true， 则 <code>FileExistsError</code> 异常将被忽略（和 POSIX <code>mkdir -p</code> 命令行为相同），但是只有在最后一个路径组件不是现存的非目录文件时才生效。</p>
<p>在 3.5 版更改: <em>exist_ok</em> 形参被加入。</p>
<p><code>Path.open</code>(<em>mode=’r’</em>, <em>buffering=- 1</em>, <em>encoding=None</em>, <em>errors=None</em>, <em>newline=None</em>)</p>
<p>打开路径指向的文件，就像内置的 <code>open()</code> 函数所做的一样:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> p <span class="token operator">=</span> Path<span class="token punctuation">(</span><span class="token string">'setup.py'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">with</span> p<span class="token punctuation">.</span>open<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     f<span class="token punctuation">.</span>readline<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token string">'#!/usr/bin/env python3\n'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>Path.owner</code>()</p>
<p>返回拥有此文件的用户名。如果文件的 UID 无法在系统数据库中找到，则抛出 <code>KeyError</code>。</p>
<p><code>Path.read_bytes</code>()</p>
<p>以字节对象的形式返回路径指向的文件的二进制内容:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> p <span class="token operator">=</span> Path<span class="token punctuation">(</span><span class="token string">'my_binary_file'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>write_bytes<span class="token punctuation">(</span>b<span class="token string">'Binary file contents'</span><span class="token punctuation">)</span>
<span class="token number">20</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>read_bytes<span class="token punctuation">(</span><span class="token punctuation">)</span>
b<span class="token string">'Binary file contents'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>3.5 新版功能.</p>
<p><code>Path.read_text</code>(<em>encoding=None</em>, <em>errors=None</em>)</p>
<p>以字符串形式返回路径指向的文件的解码后文本内容。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> p <span class="token operator">=</span> Path<span class="token punctuation">(</span><span class="token string">'my_text_file'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>write_text<span class="token punctuation">(</span><span class="token string">'Text file contents'</span><span class="token punctuation">)</span>
<span class="token number">18</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>read_text<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token string">'Text file contents'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>文件先被打开然后关闭。有和 <code>open()</code> 一样的可选形参。</p>
<p>3.5 新版功能.</p>
<p><code>Path.readlink</code>()</p>
<p>返回符号链接所指向的路径（即 <code>os.readlink()</code> 的返回值）:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> p <span class="token operator">=</span> Path<span class="token punctuation">(</span><span class="token string">'mylink'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>symlink_to<span class="token punctuation">(</span><span class="token string">'setup.py'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>readlink<span class="token punctuation">(</span><span class="token punctuation">)</span>
PosixPath<span class="token punctuation">(</span><span class="token string">'setup.py'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>3.9 新版功能.</p>
<p><code>Path.rename</code>(<em>target</em>)</p>
<p>将文件或目录重命名为给定的 <em>target*，并返回一个新的指向 *target</em> 的 Path 实例。 在 Unix 上，如果 <em>target</em> 存在且为一个文件，如果用户有足够权限，则它将被静默地替换。 <em>target</em> 可以是一个字符串或者另一个路径对象:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> p <span class="token operator">=</span> Path<span class="token punctuation">(</span><span class="token string">'foo'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>open<span class="token punctuation">(</span><span class="token string">'w'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">'some text'</span><span class="token punctuation">)</span>
<span class="token number">9</span>
<span class="token operator">>></span><span class="token operator">></span> target <span class="token operator">=</span> Path<span class="token punctuation">(</span><span class="token string">'bar'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>rename<span class="token punctuation">(</span>target<span class="token punctuation">)</span>
PosixPath<span class="token punctuation">(</span><span class="token string">'bar'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> target<span class="token punctuation">.</span>open<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token string">'some text'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>目标路径可能为绝对或相对路径。 相对路径将被解释为相对于当前工作目录，而 <em>不是</em> 相对于 Path 对象的目录。</p>
<p>在 3.8 版更改: 添加了返回值，返回新的 Path 实例。</p>
<p><code>Path.replace</code>(<em>target</em>)</p>
<p>将文件名目录重命名为给定的 <em>target*，并返回一个新的指向 *target</em> 的 Path 实例。 如果 <em>target</em> 指向一个现有文件或目录，则它将被无条件地替换。</p>
<p>目标路径可能为绝对或相对路径。 相对路径将被解释为相对于当前工作目录，而 <em>不是</em> 相对于 Path 对象的目录。</p>
<p>在 3.8 版更改: 添加了返回值，返回新的 Path 实例。</p>
<p><code>Path.resolve</code>(<em>strict=False</em>)</p>
<p>将路径绝对化，解析任何符号链接。返回新的路径对象:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> p <span class="token operator">=</span> Path<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p
PosixPath<span class="token punctuation">(</span><span class="token string">'.'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>resolve<span class="token punctuation">(</span><span class="token punctuation">)</span>
PosixPath<span class="token punctuation">(</span><span class="token string">'/home/antoine/pathlib'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>“<code>..</code>“ 组件也将被消除（只有这一种方法这么做）:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> p <span class="token operator">=</span> Path<span class="token punctuation">(</span><span class="token string">'docs/../setup.py'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>resolve<span class="token punctuation">(</span><span class="token punctuation">)</span>
PosixPath<span class="token punctuation">(</span><span class="token string">'/home/antoine/pathlib/setup.py'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>如果路径不存在并且 <em>strict</em> 设为 <code>True</code>，则抛出 <code>FileNotFoundError</code>。如果 <em>strict</em> 为 <code>False</code>，则路径将被尽可能地解析并且任何剩余部分都会被不检查是否存在地追加。如果在解析路径上发生无限循环，则抛出 <code>RuntimeError</code>。</p>
<p>3.6 新版功能: 加入<em>strict</em> 参数（3.6之前的版本相当于strict值为True）</p>
<p><code>Path.rglob</code>(<em>pattern</em>)</p>
<p>这就像调用 <code>Path.glob</code>时在给定的相对 <em>pattern</em> 前面添加了”``**/<code>()</code>“</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> sorted<span class="token punctuation">(</span>Path<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>rglob<span class="token punctuation">(</span><span class="token string">"*.py"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span>PosixPath<span class="token punctuation">(</span><span class="token string">'build/lib/pathlib.py'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
 PosixPath<span class="token punctuation">(</span><span class="token string">'docs/conf.py'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
 PosixPath<span class="token punctuation">(</span><span class="token string">'pathlib.py'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
 PosixPath<span class="token punctuation">(</span><span class="token string">'setup.py'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
 PosixPath<span class="token punctuation">(</span><span class="token string">'test_pathlib.py'</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>引发一个 审计事件 <code>pathlib.Path.rglob</code> 附带参数 <code>self</code>, <code>pattern</code>。</p>
<p><code>Path.rmdir</code>()</p>
<p>移除此目录。此目录必须为空的。</p>
<p><code>Path.samefile</code>(<em>other_path</em>)</p>
<p>返回此目录是否指向与可能是字符串或者另一个路径对象的 <em>other_path</em> 相同的文件。语义类似于 <code>os.path.samefile()</code> 与 <code>os.path.samestat()</code>。</p>
<p>如果两者都以同一原因无法访问，则抛出 <code>OSError</code>。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> p <span class="token operator">=</span> Path<span class="token punctuation">(</span><span class="token string">'spam'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> q <span class="token operator">=</span> Path<span class="token punctuation">(</span><span class="token string">'eggs'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>samefile<span class="token punctuation">(</span>q<span class="token punctuation">)</span>
<span class="token boolean">False</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>samefile<span class="token punctuation">(</span><span class="token string">'spam'</span><span class="token punctuation">)</span>
<span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>3.5 新版功能.</p>
<p><code>Path.symlink_to</code>(<em>target</em>, <em>target_is_directory=False</em>)</p>
<p>将此路径创建为指向 <em>target</em> 的符号链接。在 Windows 下，如果链接的目标是一个目录则 <em>target_is_directory</em> 必须为 true （默认为 <code>False</code>）。在 POSIX 下， <em>target_is_directory</em> 的值将被忽略。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> p <span class="token operator">=</span> Path<span class="token punctuation">(</span><span class="token string">'mylink'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>symlink_to<span class="token punctuation">(</span><span class="token string">'setup.py'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>resolve<span class="token punctuation">(</span><span class="token punctuation">)</span>
PosixPath<span class="token punctuation">(</span><span class="token string">'/home/antoine/pathlib/setup.py'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>stat<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>st_size
<span class="token number">956</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>lstat<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>st_size
<span class="token number">8</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>注解</p>
<p>参数的顺序（link, target) 和 <code>os.symlink()</code> 是相反的。</p>
<p><code>Path.hardlink_to</code>(<em>target</em>)</p>
<p>将此路径设为一个指向与 <em>target</em> 相同文件的硬链接。</p>
<p>注解</p>
<p>参数顺序 (link, target) 和 <code>os.link()</code> 是相反的。</p>
<p>3.10 新版功能.</p>
<p><code>Path.link_to</code>(<em>target</em>)</p>
<p>创建硬链接 <em>target</em> 指向此路径。</p>
<p>警告</p>
<p>此函数不会将此路径设为指向 <em>target</em> 的硬链接，尽管此函数名和参数名有此含义。 参数顺序 (target, link) 与 <code>Path.symlink_to()</code> 和 <code>Path.hardlink_to()</code> 相反，而与 <code>os.link()</code> 的一致。</p>
<p>3.8 新版功能.</p>
<p>3.10 版后已移除: 此方法已被弃用而建议改用 <code>Path.hardlink_to()</code>，因为 <code>Path.link_to()</code> 的参数顺序与 <code>Path.symlink_to()</code> 的不相匹配。</p>
<p><code>Path.touch</code>(<em>mode=438</em>, <em>exist_ok=True</em>)</p>
<p>将给定的路径创建为文件。如果给出了 <em>mode</em> 它将与当前进程的 <code>umask</code> 值合并以确定文件的模式和访问标志。如果文件已经存在，则当 <em>exist_ok</em> 为 true 则函数仍会成功（并且将它的修改事件更新为当前事件），否则抛出 <code>FileExistsError</code>。</p>
<p><code>Path.unlink</code>(<em>missing_ok=False</em>)</p>
<p>移除此文件或符号链接。如果路径指向目录，则用 <code>Path.rmdir()</code> 代替。</p>
<p>如果 <em>missing_ok</em> 为假值（默认），则如果路径不存在将会引发 <code>FileNotFoundError</code>。</p>
<p>如果 <em>missing_ok</em> 为真值，则 <code>FileNotFoundError</code> 异常将被忽略（和 POSIX <code>rm -f</code> 命令的行为相同）。</p>
<p>在 3.8 版更改: 增加了 <em>missing_ok</em> 形参。</p>
<p><code>Path.write_bytes</code>(<em>data</em>)</p>
<p>将文件以二进制模式打开，写入 <em>data</em> 并关闭:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> p <span class="token operator">=</span> Path<span class="token punctuation">(</span><span class="token string">'my_binary_file'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>write_bytes<span class="token punctuation">(</span>b<span class="token string">'Binary file contents'</span><span class="token punctuation">)</span>
<span class="token number">20</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>read_bytes<span class="token punctuation">(</span><span class="token punctuation">)</span>
b<span class="token string">'Binary file contents'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>一个同名的现存文件将被覆盖。</p>
<p>3.5 新版功能.</p>
<p><code>Path.write_text</code>(<em>data</em>, <em>encoding=None</em>, <em>errors=None</em>, <em>newline=None</em>)</p>
<p>将文件以文本模式打开，写入 <em>data</em> 并关闭:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> p <span class="token operator">=</span> Path<span class="token punctuation">(</span><span class="token string">'my_text_file'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>write_text<span class="token punctuation">(</span><span class="token string">'Text file contents'</span><span class="token punctuation">)</span>
<span class="token number">18</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>read_text<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token string">'Text file contents'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>同名的现有文件会被覆盖。 可选形参的含义与 <code>open()</code> 的相同。</p>
<p>3.5 新版功能.</p>
<p>在 3.10 版更改: 增加了 <em>newline</em> 形参。</p>
<h3 id="对应的-os-模块的工具"><a href="#对应的-os-模块的工具" class="headerlink" title="对应的 os 模块的工具"></a>对应的 <code>os</code> 模块的工具</h3><p>以下是一个映射了 <code>os</code> 与 <code>PurePath</code>/<code>Path</code> 对应相同的函数的表。</p>
<p>注解</p>
<p>以下函数/方法对并不完全等价。 它们有些虽然具有相互重叠的使用场景，但语义并不相同。 这包括了 <code>os.path.abspath()</code> 和 <code>Path.resolve()</code>，以及 <code>os.path.relpath()</code> 和 <code>PurePath.relative_to()</code>。</p>
<table>
<thead>
<tr>
<th align="left"><code>os</code> 和 <code>os.path</code></th>
<th align="left"><code>pathlib</code></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>os.path.abspath()</code></td>
<td align="left"><code>Path.resolve()</code></td>
</tr>
<tr>
<td align="left"><code>os.chmod()</code></td>
<td align="left"><code>Path.chmod()</code></td>
</tr>
<tr>
<td align="left"><code>os.mkdir()</code></td>
<td align="left"><code>Path.mkdir()</code></td>
</tr>
<tr>
<td align="left"><code>os.makedirs()</code></td>
<td align="left"><code>Path.mkdir()</code></td>
</tr>
<tr>
<td align="left"><code>os.rename()</code></td>
<td align="left"><code>Path.rename()</code></td>
</tr>
<tr>
<td align="left"><code>os.replace()</code></td>
<td align="left"><code>Path.replace()</code></td>
</tr>
<tr>
<td align="left"><code>os.rmdir()</code></td>
<td align="left"><code>Path.rmdir()</code></td>
</tr>
<tr>
<td align="left"><code>os.remove()</code>, <code>os.unlink()</code></td>
<td align="left"><code>Path.unlink()</code></td>
</tr>
<tr>
<td align="left"><code>os.getcwd()</code></td>
<td align="left"><code>Path.cwd()</code></td>
</tr>
<tr>
<td align="left"><code>os.path.exists()</code></td>
<td align="left"><code>Path.exists()</code></td>
</tr>
<tr>
<td align="left"><code>os.path.expanduser()</code></td>
<td align="left"><code>Path.expanduser()</code> 和 <code>Path.home()</code></td>
</tr>
<tr>
<td align="left"><code>os.listdir()</code></td>
<td align="left"><code>Path.iterdir()</code></td>
</tr>
<tr>
<td align="left"><code>os.path.isdir()</code></td>
<td align="left"><code>Path.is_dir()</code></td>
</tr>
<tr>
<td align="left"><code>os.path.isfile()</code></td>
<td align="left"><code>Path.is_file()</code></td>
</tr>
<tr>
<td align="left"><code>os.path.islink()</code></td>
<td align="left"><code>Path.is_symlink()</code></td>
</tr>
<tr>
<td align="left"><code>os.link()</code></td>
<td align="left"><code>Path.hardlink_to()</code></td>
</tr>
<tr>
<td align="left"><code>os.symlink()</code></td>
<td align="left"><code>Path.symlink_to()</code></td>
</tr>
<tr>
<td align="left"><code>os.readlink()</code></td>
<td align="left"><code>Path.readlink()</code></td>
</tr>
<tr>
<td align="left"><code>os.path.relpath()</code></td>
<td align="left"><code>Path.relative_to()</code></td>
</tr>
<tr>
<td align="left"><code>os.stat()</code></td>
<td align="left"><code>Path.stat()</code>, <code>Path.owner()</code>, <code>Path.group()</code></td>
</tr>
<tr>
<td align="left"><code>os.path.isabs()</code></td>
<td align="left"><code>PurePath.is_absolute()</code></td>
</tr>
<tr>
<td align="left"><code>os.path.join()</code></td>
<td align="left"><code>PurePath.joinpath()</code></td>
</tr>
<tr>
<td align="left"><code>os.path.basename()</code></td>
<td align="left"><code>PurePath.name</code></td>
</tr>
<tr>
<td align="left"><code>os.path.dirname()</code></td>
<td align="left"><code>PurePath.parent</code></td>
</tr>
<tr>
<td align="left"><code>os.path.samefile()</code></td>
<td align="left"><code>Path.samefile()</code></td>
</tr>
<tr>
<td align="left"><code>os.path.splitext()</code></td>
<td align="left"><code>PurePath.suffix</code></td>
</tr>
</tbody></table>
<h2 id="os-path-—-常用路径操作"><a href="#os-path-—-常用路径操作" class="headerlink" title="os.path —- 常用路径操作"></a><code>os.path</code> —- 常用路径操作</h2><p><strong>源代码：</strong> <a href="https://github.com/python/cpython/tree/3.10/Lib/posixpath.py" target="_blank" rel="noopener">Lib/posixpath.py</a> （用于 POSIX）和 <a href="https://github.com/python/cpython/tree/3.10/Lib/ntpath.py" target="_blank" rel="noopener">Lib/ntpath.py</a> （用于 Windows NT）</p>
<hr>
<p>该模块在路径名上实现了一些有用的功能。路径参数可以字符串或字节形式传递。我们鼓励应用程序将文件名表示为（Unicode）字符串。不幸的是，某些文件名在Unix上可能无法用字符串表示，因此在Unix上平台上需要支持任意文件名的应用程序，应使用字节对象来表示路径名。反之亦然，在Windows平台上仅使用字节对象，不能表示的所有文件名（以标准 <code>mbcs</code> 编码），因此Windows应用程序应使用字符串对象来访问所有文件。</p>
<p>与unix shell不同，Python不执行任何 <em>自动</em> 路径扩展。当应用程序需要类似shell的路径扩展时，可以显式调用诸如 <code>expanduser()</code> 和 <code>expandvars()</code> 之类的函数。 </p>
<p>参见</p>
<p><code>pathlib</code> 模块提供高级路径对象。</p>
<p>注解</p>
<p>所有这些函数都仅接受字节或字符串对象作为其参数。如果返回路径或文件名，则结果是相同类型的对象。</p>
<p>注解</p>
<p>由于不同的操作系统具有不同的路径名称约定，因此标准库中有此模块的几个版本。<code>os.path</code> 模块始终是适合 Python 运行的操作系统的路径模块，因此可用于本地路径。但是，如果操作的路径 <em>总是</em> 以一种不同的格式显示，那么也可以分别导入和使用各个模块。它们都具有相同的接口：</p>
<ul>
<li><code>posixpath</code> 用于Unix 样式的路径</li>
<li><code>ntpath</code> 用于 Windows 路径</li>
</ul>
<p>在 3.8 版更改: <code>exists()</code>、<code>lexists()</code>、<code>isdir()</code>、<code>isfile()</code>、<code>islink()</code> 和 <code>ismount()</code> 现在遇到系统层面上不可表示的字符或字节的路径时，会返回 <code>False</code>，而不是抛出异常。</p>
<p><code>os.path.abspath</code>(<em>path</em>)</p>
<p>返回路径 <em>path</em> 的绝对路径（标准化的）。在大多数平台上，这等同于用 <code>normpath(join(os.getcwd(), path))</code> 的方式调用 <code>normpath()</code> 函数。</p>
<p>在 3.6 版更改: 接受一个 path-like object。</p>
<p><code>os.path.basename</code>(<em>path</em>)</p>
<p>返回路径 <em>path</em> 的基本名称。这是将 <em>path</em> 传入函数 <code>split()</code> 之后，返回的一对值中的第二个元素。请注意，此函数的结果与Unix <strong>basename</strong> 程序不同。<strong>basename</strong> 在 <code>'/foo/bar/'</code> 上返回 <code>'bar'</code>，而 <code>basename()</code> 函数返回一个空字符串 (<code>''</code>)。</p>
<p>在 3.6 版更改: 接受一个 path-like object。</p>
<p><code>os.path.commonpath</code>(<em>paths</em>)</p>
<p>接受包含多个路径的序列 <em>paths*，返回 *paths</em> 的最长公共子路径。如果 <em>paths</em> 同时包含绝对路径和相对路径，或 <em>paths</em> 在不同的驱动器上，或 <em>paths</em> 为空，则抛出 <code>ValueError</code> 异常。与 <code>commonprefix()</code> 不同，本方法返回有效路径。</p>
<p>可用性: Unix, Windows。</p>
<p>3.5 新版功能.</p>
<p>在 3.6 版更改: 接受一个 类路径对象 序列。</p>
<p><code>os.path.commonprefix</code>(<em>list</em>)</p>
<p>接受包含多个路径的 <em>列表*，返回所有路径的最长公共前缀（逐字符比较）。如果 *列表</em> 为空，则返回空字符串 (<code>''</code>)。</p>
<p>注解</p>
<p>此函数是逐字符比较，因此可能返回无效路径。要获取有效路径，参见 <code>commonpath()</code>。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>commonprefix<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'/usr/lib'</span><span class="token punctuation">,</span> <span class="token string">'/usr/local/lib'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token string">'/usr/l'</span>
<span class="token operator">>></span><span class="token operator">></span> os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>commonpath<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'/usr/lib'</span><span class="token punctuation">,</span> <span class="token string">'/usr/local/lib'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token string">'/usr'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>在 3.6 版更改: 接受一个 path-like object。</p>
<p><code>os.path.dirname</code>(<em>path</em>)</p>
<p>返回路径 <em>path</em> 的目录名称。这是将 <em>path</em> 传入函数 <code>split()</code> 之后，返回的一对值中的第一个元素。</p>
<p>在 3.6 版更改: 接受一个 path-like object。</p>
<p><code>os.path.exists</code>(<em>path</em>)</p>
<p>如果 <em>path</em> 指向一个已存在的路径或已打开的文件描述符，返回 <code>True</code>。对于失效的符号链接，返回 <code>False</code>。在某些平台上，如果使用 <code>os.stat()</code> 查询到目标文件没有执行权限，即使 <em>path</em> 确实存在，本函数也可能返回 <code>False</code>。</p>
<p>在 3.3 版更改: <em>path</em> 现在可以是一个整数：如果该整数是一个已打开的文件描述符，返回 <code>True</code>，否则返回 <code>False</code>。</p>
<p>在 3.6 版更改: 接受一个 path-like object。</p>
<p><code>os.path.lexists</code>(<em>path</em>)</p>
<p>如果 <em>path</em> 指向一个已存在的路径，返回 <code>True</code>。对于失效的符号链接，也返回 <code>True</code>。在缺失 <code>os.lstat()</code> 的平台上等同于 <code>exists()</code>。</p>
<p>在 3.6 版更改: 接受一个 path-like object。</p>
<p><code>os.path.expanduser</code>(<em>path</em>)</p>
<p>在 Unix 和 Windows 上，将参数中开头部分的 <code>~</code> 或 <code>~user</code> 替换为当前 <em>用户</em> 的家目录并返回。</p>
<p>在 Unix 上，开头的 <code>~</code> 会被环境变量 <code>HOME</code> 代替，如果变量未设置，则通过内置模块 <code>pwd</code> 在 password 目录中查找当前用户的主目录。以 <code>~user</code> 开头则直接在 password 目录中查找。</p>
<p>在 Windows 上，如果 <code>USERPROFILE</code> 已设置将会被使用，否则 <code>HOMEPATH</code> 和 <code>HOMEDRIVE</code> 将被组合起来使用。 初始的 <code>~user</code> 会通过检查当前用户的家目录中匹配 <code>USERNAME</code> 的最后一部分目录名并执行替换来处理。</p>
<p>如果展开路径失败，或者路径不是以波浪号开头，则路径将保持不变。</p>
<p>在 3.6 版更改: 接受一个 path-like object。</p>
<p>在 3.8 版更改: Windows 不再使用 <code>HOME</code>。</p>
<p><code>os.path.expandvars</code>(<em>path</em>)</p>
<p>输入带有环境变量的路径作为参数，返回展开变量以后的路径。<code>$name</code> 或 <code>${name}</code> 形式的子字符串被环境变量 <em>name</em> 的值替换。格式错误的变量名称和对不存在变量的引用保持不变。</p>
<p>在 Windows 上，除了 <code>$name</code> 和 <code>${name}</code> 外，还可以展开 <code>%name%</code>。</p>
<p>在 3.6 版更改: 接受一个 path-like object。</p>
<p><code>os.path.getatime</code>(<em>path</em>)</p>
<p>返回 <em>path</em> 的最后访问时间。返回值是一个浮点数，为纪元秒数。如果该文件不存在或不可访问，则抛出 <code>OSError</code> 异常。</p>
<p><code>os.path.getmtime</code>(<em>path</em>)</p>
<p>返回 <em>path</em> 的最后修改时间。返回值是一个浮点数，为纪元秒数。如果该文件不存在或不可访问，则抛出 <code>OSError</code> 异常。</p>
<p>在 3.6 版更改: 接受一个 path-like object。</p>
<p><code>os.path.getctime</code>(<em>path</em>)</p>
<p>返回 <em>path</em> 在系统中的 ctime，在有些系统（比如 Unix）上，它是元数据的最后修改时间，其他系统（比如 Windows）上，它是 <em>path</em> 的创建时间。返回值是一个数，为纪元秒数。如果该文件不存在或不可访问，则抛出 <code>OSError</code> 异常。</p>
<p>在 3.6 版更改: 接受一个 path-like object。</p>
<p><code>os.path.getsize</code>(<em>path</em>)</p>
<p>返回 <em>path</em> 的大小，以字节为单位。如果该文件不存在或不可访问，则抛出 <code>OSError</code> 异常。</p>
<p>在 3.6 版更改: 接受一个 path-like object。</p>
<p><code>os.path.isabs</code>(<em>path</em>)</p>
<p>如果 <em>path</em> 是一个绝对路径，则返回 <code>True</code>。在 Unix 上，它就是以斜杠开头，而在 Windows 上，它可以是去掉驱动器号后以斜杠（或反斜杠）开头。</p>
<p>在 3.6 版更改: 接受一个 path-like object。</p>
<p><code>os.path.isfile</code>(<em>path</em>)</p>
<p>如果 <em>path</em> 是 <code>现有的</code> 常规文件，则返回 <code>True</code>。本方法会跟踪符号链接，因此，对于同一路径，<code>islink()</code> 和 <code>isfile()</code> 都可能为 <code>True</code>。</p>
<p>在 3.6 版更改: 接受一个 path-like object。</p>
<p><code>os.path.isdir</code>(<em>path</em>)</p>
<p>如果 <em>path</em> 是 <code>现有的</code> 目录，则返回 <code>True</code>。本方法会跟踪符号链接，因此，对于同一路径，<code>islink()</code> 和 <code>isdir()</code> 都可能为 <code>True</code>。</p>
<p>在 3.6 版更改: 接受一个 path-like object。</p>
<p><code>os.path.islink</code>(<em>path</em>)</p>
<p>如果 <em>path</em> 指向的 <code>现有</code> 目录条目是一个符号链接，则返回 <code>True</code>。如果 Python 运行时不支持符号链接，则总是返回 <code>False</code>。</p>
<p>在 3.6 版更改: 接受一个 path-like object。</p>
<p><code>os.path.ismount</code>(<em>path</em>)</p>
<p>如果路径 <em>path</em> 是 <em>挂载点</em> （文件系统中挂载其他文件系统的点），则返回 <code>True</code>。在 POSIX 上，该函数检查 <em>path</em> 的父目录 <code>*path*/..</code> 是否在与 <em>path</em> 不同的设备上，或者 <code>*path*/..</code> 和 <em>path</em> 是否指向同一设备上的同一 inode（这一检测挂载点的方法适用于所有 Unix 和 POSIX 变体）。本方法不能可靠地检测同一文件系统上的绑定挂载 (bind mount)。在 Windows 上，盘符和共享 UNC 始终是挂载点，对于任何其他路径，将调用 <code>GetVolumePathName</code> 来查看它是否与输入的路径不同。</p>
<p>3.4 新版功能: 支持在 Windows 上检测非根挂载点。</p>
<p>在 3.6 版更改: 接受一个 path-like object。</p>
<p><code>os.path.join</code>(<em>path</em>, <em>\</em>paths*)</p>
<p>智能地拼接一个或多个路径部分。 返回值是 <em>path</em> 和 <em>\</em>paths* 的所有成员的拼接，其中每个非空部分后面都紧跟一个目录分隔符，最后一个部分除外，这意味着如果最后一个部分为空，则结果将以分隔符结尾。 如果某个部分为绝对路径，则之前的所有部分会被丢弃并从绝对路径部分开始继续拼接。</p>
<p>在 Windows 上，遇到绝对路径部分（例如 <code>r'\foo'</code>）时，不会重置盘符。如果某部分路径包含盘符，则会丢弃所有先前的部分，并重置盘符。请注意，由于每个驱动器都有一个“当前目录”，所以 <code>os.path.join("c:", "foo")</code> 表示驱动器 <code>C:</code> 上当前目录的相对路径 (<code>c:foo</code>)，而不是 <code>c:\foo</code>。</p>
<p>在 3.6 版更改: 接受一个 类路径对象 用于 <em>path</em> 和 <em>paths</em> 。</p>
<p><code>os.path.normcase</code>(<em>path</em>)</p>
<p>规范路径的大小写。在 Windows 上，将路径中的所有字符都转换为小写，并将正斜杠转换为反斜杠。在其他操作系统上返回原路径。</p>
<p>在 3.6 版更改: 接受一个 path-like object。</p>
<p><code>os.path.normpath</code>(<em>path</em>)</p>
<blockquote>
<p>通过折叠多余的分隔符和对上级目录的引用来标准化路径名，所以 <code>A//B</code>、<code>A/B/</code>、<code>A/./B</code> 和 <code>A/foo/../B</code> 都会转换成 <code>A/B</code>。这个字符串操作可能会改变带有符号链接的路径的含义。在 Windows 上，本方法将正斜杠转换为反斜杠。要规范大小写，请使用 <code>normcase()</code>。</p>
</blockquote>
<p>注解</p>
<blockquote>
<p>在 POSIX 系统上，根据 <a href="http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap04.html#tag_04_13" target="_blank" rel="noopener">IEEE Std 1003.1 2013 Edition; 4.13 Pathname Resolution</a>，如果一个路径名称以两个斜杠开始，则开始字符之后的第一个部分将以具体实现所定义的方式来解读，但是超过两个开始字符则将被视为单个字符。</p>
</blockquote>
<p>在 3.6 版更改: 接受一个 path-like object。</p>
<p><code>os.path.realpath</code>(<em>path</em>, <em>**,</em> strict=False*)</p>
<p>返回指定文件的规范路径，消除路径中存在的任何符号链接（如果操作系统支持）。</p>
<p>如果一个路径不存在或是遇到了符号链接循环，并且 <em>strict</em> 为 <code>True</code>，则会引发 <code>OSError</code>。 如果 <em>strict</em> 为 <code>False</code>，则会尽可能地解析路径并添加结果而不检查路径是否存在。</p>
<p>注解</p>
<p>这个函数会模拟操作系统生成规范路径的过程，Windows 与 UNIX 的这个过程在处理链接和后续路径组成部分的交互方式上有所差异。</p>
<p>操作系统 API 会根据需要来规范化路径，因此通常不需要调用此函数。</p>
<p>在 3.6 版更改: 接受一个 path-like object。</p>
<p>在 3.8 版更改: 在 Windows 上现在可以正确解析符号链接和交接点 (junction point)。</p>
<p>在 3.10 版更改: 增加了 <em>strict</em> 形参。</p>
<p><code>os.path.relpath</code>(<em>path</em>, <em>start=os.curdir</em>)</p>
<p>返回从当前目录或可选的 <em>start</em> 目录至 <em>path</em> 的相对文件路径。 这只是一个路径计算：不会访问文件系统来确认 <em>path</em> 或 <em>start</em> 是否存在或其性质。 在 Windows 上，当 <em>path</em> 和 <em>start</em> 位于不同驱动器时将引发 <code>ValueError</code>。</p>
<p><em>start</em> 默认为 <code>os.curdir</code>。</p>
<p>可用性: Unix, Windows。</p>
<p>在 3.6 版更改: 接受一个 path-like object。</p>
<p><code>os.path.samefile</code>(<em>path1</em>, <em>path2</em>)</p>
<p>如果两个路径都指向相同的文件或目录，则返回 <code>True</code>。这由设备号和 inode 号确定，在任一路径上调用 <code>os.stat()</code> 失败则抛出异常。</p>
<p>可用性: Unix, Windows。</p>
<p>在 3.2 版更改: 添加了对 Windows 的支持。</p>
<p>在 3.4 版更改: Windows现在使用与其他所有平台相同的实现。</p>
<p>在 3.6 版更改: 接受一个 path-like object。</p>
<p><code>os.path.sameopenfile</code>(<em>fp1</em>, <em>fp2</em>)</p>
<p>如果文件描述符 <em>fp1</em> 和 <em>fp2</em> 指向相同文件，则返回 <code>True</code>。</p>
<p>可用性: Unix, Windows。</p>
<p>在 3.2 版更改: 添加了对 Windows 的支持。</p>
<p>在 3.6 版更改: 接受一个 path-like object。</p>
<p><code>os.path.samestat</code>(<em>stat1</em>, <em>stat2</em>)</p>
<p>如果 stat 元组 <em>stat1</em> 和 <em>stat2</em> 指向相同文件，则返回 <code>True</code>。这些 stat 元组可能是由 <code>os.fstat()</code>、<code>os.lstat()</code> 或 <code>os.stat()</code> 返回的。本函数实现了 <code>samefile()</code> 和 <code>sameopenfile()</code> 底层所使用的比较过程。</p>
<p>可用性: Unix, Windows。</p>
<p>在 3.4 版更改: 添加了对 Windows 的支持。</p>
<p>在 3.6 版更改: 接受一个 path-like object。</p>
<p><code>os.path.split</code>(<em>path</em>)</p>
<p>将路径 <em>path</em> 拆分为一对，即 <code>(head, tail)</code>，其中，<em>tail</em> 是路径的最后一部分，而 <em>head</em> 里是除最后部分外的所有内容。<em>tail</em> 部分不会包含斜杠，如果 <em>path</em> 以斜杠结尾，则 <em>tail</em> 将为空。如果 <em>path</em> 中没有斜杠，<em>head</em> 将为空。如果 <em>path</em> 为空，则 <em>head</em> 和 <em>tail</em> 均为空。<em>head</em> 末尾的斜杠会被去掉，除非它是根目录（即它仅包含一个或多个斜杠）。在所有情况下，<code>join(head, tail)</code> 指向的位置都与 <em>path</em> 相同（但字符串可能不同）。另请参见函数 <code>dirname()</code> 和 <code>basename()</code>。</p>
<p>在 3.6 版更改: 接受一个 path-like object。</p>
<p><code>os.path.splitdrive</code>(<em>path</em>)</p>
<p>将路径 <em>path</em> 拆分为一对，即 <code>(drive, tail)</code>，其中 <em>drive</em> 是挂载点或空字符串。在没有驱动器概念的系统上，<em>drive</em> 将始终为空字符串。在所有情况下，<code>drive + tail</code> 都与 <em>path</em> 相同。</p>
<p>在 Windows 上，本方法将路径拆分为驱动器/UNC 根节点和相对路径。</p>
<p>如果路径 path 包含盘符，则 drive 将包含冒号之前的所有内容包括冒号本身:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> splitdrive<span class="token punctuation">(</span><span class="token string">"c:/dir"</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token string">"c:"</span><span class="token punctuation">,</span> <span class="token string">"/dir"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>如果路径 path 包含 UNC 路径，则 drive 将包含主机名和 share，直至第四个分隔符但不包括该分隔符:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> splitdrive<span class="token punctuation">(</span><span class="token string">"//host/computer/dir"</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token string">"//host/computer"</span><span class="token punctuation">,</span> <span class="token string">"/dir"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>在 3.6 版更改: 接受一个 path-like object。</p>
<p><code>os.path.splitext</code>(<em>path</em>)</p>
<p>将路径名称 <em>path</em> 拆分为 <code>(root, ext)</code> 对使得 <code>root + ext == path</code>，并且扩展名 <em>ext</em> 为空或以句点打头并最多只包含一个句点。</p>
<p>如果路径 path 不包含扩展名，则 <em>ext</em> 将为 <code>''</code>:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> splitext<span class="token punctuation">(</span><span class="token string">'bar'</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token string">'bar'</span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>如果路径 path 包含扩展名，则 <em>ext</em> 将被设为该扩展名，包括打头的句点。 请注意在其之前的句点将被忽略:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> splitext<span class="token punctuation">(</span><span class="token string">'foo.bar.exe'</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token string">'foo.bar'</span><span class="token punctuation">,</span> <span class="token string">'.exe'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>基本名中打头的句点会被忽略:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> splitext<span class="token punctuation">(</span><span class="token string">'.cshrc'</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token string">'.cshrc'</span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>在 3.6 版更改: 接受一个 path-like object。</p>
<pre><code>os.path.supports_unicode_filenames</code></pre><h2 id="fileinput-—-迭代来自多个输入流的行"><a href="#fileinput-—-迭代来自多个输入流的行" class="headerlink" title="fileinput —- 迭代来自多个输入流的行"></a><code>fileinput</code> —- 迭代来自多个输入流的行</h2><p><strong>源代码:</strong> <a href="https://github.com/python/cpython/tree/3.10/Lib/fileinput.py" target="_blank" rel="noopener">Lib/fileinput.py</a></p>
<hr>
<p>此模块实现了一个辅助类和一些函数用来快速编写访问标准输入或文件列表的循环。 </p>
<p>典型用法为:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> fileinput
<span class="token keyword">for</span> line <span class="token keyword">in</span> fileinput<span class="token punctuation">.</span>input<span class="token punctuation">(</span>encoding<span class="token operator">=</span><span class="token string">"utf-8"</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    process<span class="token punctuation">(</span>line<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>此程序会迭代 <code>sys.argv[1:]</code> 中列出的所有文件内的行，如果列表为空则会使用 <code>sys.stdin</code>。 如果有一个文件名为 <code>'-'</code>，它也会被替换为 <code>sys.stdin</code> 并且可选参数 <em>mode</em> 和 <em>openhook</em> 会被忽略。 要指定替代文件列表，请将其作为第一个参数传给 <code>input()</code>。 也允许使用单个文件。</p>
<p>所有文件都默认以文本模式打开，但你可以通过在调用 <code>input()</code> 或 <code>FileInput</code> 时指定 <em>mode</em> 形参来重载此行为。 如果在打开或读取文件时发生了 I/O 错误，将会引发 <code>OSError</code>。</p>
<p>在 3.3 版更改: 原来会引发 <code>IOError</code>；现在它是 <code>OSError</code> 的别名。</p>
<p>如果 <code>sys.stdin</code> 被使用超过一次，则第二次之后的使用将不返回任何行，除非是被交互式的使用，或都是被显式地重置 (例如使用 <code>sys.stdin.seek(0)</code>)。</p>
<p>空文件打开后将立即被关闭；它们在文件列表中会被注意到的唯一情况只有当最后打开的文件为空的时候。</p>
<p>反回的行不会对换行符做任何处理，这意味着文件中的最后一行可能不带换行符。</p>
<p>You can control how files are opened by providing an opening hook via the <em>openhook</em> parameter to <code>fileinput.input()</code> or <code>FileInput()</code>. The hook must be a function that takes two arguments, <em>filename</em> and <em>mode</em>, and returns an accordingly opened file-like object. If <em>encoding</em> and/or <em>errors</em> are specified, they will be passed to the hook as aditional keyword arguments. This module provides a <code>hook_compressed()</code> to support compressed files.</p>
<p>以下函数是此模块的初始接口：</p>
<p><code>fileinput.input</code>(<em>files=None</em>, <em>inplace=False</em>, <em>backup=’’</em>, <em>**,</em> mode=’r’<em>,</em> openhook=None<em>,</em> encoding=None<em>,</em> errors=None*)</p>
<p>创建一个 <code>FileInput</code> 类的实例。 该实例将被用作此模块中函数的全局状态，并且还将在迭代期间被返回使用。 此函数的形参将被继续传递给 <code>FileInput</code> 类的构造器。</p>
<p><code>FileInput</code> 实例可以在 <code>with</code> 语句中被用作上下文管理器。 在这个例子中，<em>input</em> 在 <code>with</code> 语句结束后将会被关闭，即使发生了异常也是如此:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">with</span> fileinput<span class="token punctuation">.</span>input<span class="token punctuation">(</span>files<span class="token operator">=</span><span class="token punctuation">(</span><span class="token string">'spam.txt'</span><span class="token punctuation">,</span> <span class="token string">'eggs.txt'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> encoding<span class="token operator">=</span><span class="token string">"utf-8"</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span>
    <span class="token keyword">for</span> line <span class="token keyword">in</span> f<span class="token punctuation">:</span>
        process<span class="token punctuation">(</span>line<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>在 3.2 版更改: 可以被用作上下文管理器。</p>
<p>在 3.8 版更改: 关键字形参 <em>mode</em> 和 <em>openhook</em> 现在是仅限关键字形参。</p>
<p>在 3.10 版更改: 增加了仅限关键字形参 <em>encoding</em> 和 <em>errors</em>。</p>
<p>下列函数会使用 <code>fileinput.input()</code> 所创建的全局状态；如果没有活动的状态，则会引发 <code>RuntimeError</code>。</p>
<p><code>fileinput.filename</code>()</p>
<p>返回当前被读取的文件名。 在第一行被读取之前，返回 <code>None</code>。</p>
<p><code>fileinput.fileno</code>()</p>
<p>返回以整数表示的当前文件“文件描述符”。 当未打开文件时（处在第一行和文件之间），返回 <code>-1</code>。</p>
<p><code>fileinput.lineno</code>()</p>
<p>返回已被读取的累计行号。 在第一行被读取之前，返回 <code>0</code>。 在最后一个文件的最后一行被读取之后，返回该行的行号。</p>
<p><code>fileinput.filelineno</code>()</p>
<p>返回当前文件中的行号。 在第一行被读取之前，返回 <code>0</code>。 在最后一个文件的最后一行被读取之后，返回此文件中该行的行号。</p>
<p><code>fileinput.isfirstline</code>()</p>
<p>如果刚读取的行是其所在文件的第一行则返回 <code>True</code>，否则返回 <code>False</code>。</p>
<p><code>fileinput.isstdin</code>()</p>
<p>如果最后读取的行来自 <code>sys.stdin</code> 则返回 <code>True</code>，否则返回 <code>False</code>。</p>
<p><code>fileinput.nextfile</code>()</p>
<p>关闭当前文件以使下次迭代将从下一个文件（如果存在）读取第一行；不是从该文件读取的行将不会被计入累计行数。 直到下一个文件的第一行被读取之后文件名才会改变。 在第一行被读取之前，此函数将不会生效；它不能被用来跳过第一个文件。 在最后一个文件的最后一行被读取之后，此函数将不再生效。</p>
<p><code>fileinput.close</code>()</p>
<p>关闭序列。</p>
<p>此模块所提供的实现了序列行为的类同样也可用于子类化：</p>
<p><em>class</em> <code>fileinput.FileInput</code>(<em>files=None</em>, <em>inplace=False</em>, <em>backup=’’</em>, <em>**,</em> mode=’r’<em>,</em> openhook=None<em>,</em> encoding=None<em>,</em> errors=None*)</p>
<p>类 <code>FileInput</code> 是一个实现；它的方法 <code>filename()</code>, <code>fileno()</code>, <code>lineno()</code>, <code>filelineno()</code>, <code>isfirstline()</code>, <code>isstdin()</code>, <code>nextfile()</code> 和 <code>close()</code> 对应于此模块中具有相同名称的函数。 此外它还有一个 <code>readline()</code> 方法可返回下一个输入行，以及一个 <code>__getitem__()</code> 方法，该方法实现了序列行为。 这种序列必须以严格的序列顺序来读写；随机读写和 <code>readline()</code> 不可以被混用。</p>
<p>通过 <em>mode</em> 你可以指定要传给 <code>open()</code> 的文件模式。 它必须为 <code>'r'</code>, <code>'rU'</code>, <code>'U'</code> 和 <code>'rb'</code> 中的一个。</p>
<p><em>openhook</em> 如果给出则必须为一个函数，它接受两个参数 <em>filename</em> 和 <em>mode*，并相应地返回一个打开的文件类对象。 你不能同时使用 *inplace</em> 和 <em>openhook</em>。</p>
<p>你可以指定 <em>encoding</em> 和 <em>errors</em> 来将其传给 <code>open()</code> 或 <em>openhook</em>。</p>
<p><code>FileInput</code> 实例可以在 <code>with</code> 语句中被用作上下文管理器。 在这个例子中，<em>input</em> 在 <code>with</code> 语句结束后将会被关闭，即使发生了异常也是如此:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">with</span> FileInput<span class="token punctuation">(</span>files<span class="token operator">=</span><span class="token punctuation">(</span><span class="token string">'spam.txt'</span><span class="token punctuation">,</span> <span class="token string">'eggs.txt'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">as</span> input<span class="token punctuation">:</span>
    process<span class="token punctuation">(</span>input<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>在 3.2 版更改: 可以被用作上下文管理器。</p>
<p>3.4 版后已移除: <code>'rU'</code> 和 <code>'U'</code> 模式。</p>
<p>3.8 版后已移除: 对 <code>__getitem__()</code> 方法的支持已弃用。</p>
<p>在 3.8 版更改: 关键字形参 <em>mode</em> 和 <em>openhook</em> 现在是仅限关键字形参。</p>
<p>在 3.10 版更改: 增加了仅限关键字形参 <em>encoding</em> 和 <em>errors</em>。</p>
<p><strong>可选的原地过滤:</strong> 如果传递了关键字参数 <code>inplace=True</code> 给 <code>fileinput.input()</code> 或 <code>FileInput</code> 构造器，则文件会被移至备份文件并将标准输出定向到输入文件（如果已存在与备份文件同名的文件，它将被静默地替换）。 这使得编写一个能够原地重写其输入文件的过滤器成为可能。 如果给出了 <em>backup</em> 形参 (通常形式为 <code>backup='.&lt;some extension&gt;'</code>)，它将指定备份文件的扩展名，并且备份文件会被保留；默认情况下扩展名为 <code>'.bak'</code> 并且它会在输出文件关闭时被删除。 在读取标准输入时原地过滤会被禁用。</p>
<p>此模块提供了以下两种打开文件钩子：</p>
<p><code>fileinput.hook_compressed</code>(<em>filename</em>, <em>mode</em>, <em>**,</em> encoding=None<em>,</em> errors=None*)</p>
<p>使用 <code>gzip</code> 和 <code>bz2</code> 模块透明地打开 gzip 和 bzip2 压缩的文件（通过扩展名 <code>'.gz'</code> 和 <code>'.bz2'</code> 来识别）。 如果文件扩展名不是 <code>'.gz'</code> 或 <code>'.bz2'</code>，文件会以正常方式打开（即使用 <code>open()</code> 并且不带任何解压操作）。</p>
<p><em>encoding</em> 和 <em>errors</em> 值会被传给 <code>io.TextIOWrapper</code> 用于压缩文件以及打开普通文件。</p>
<p>用法示例: <code>fi = fileinput.FileInput(openhook=fileinput.hook_compressed, encoding="utf-8")</code></p>
<p>在 3.10 版更改: 增加了仅限关键字形参 <em>encoding</em> 和 <em>errors</em>。</p>
<p><code>fileinput.hook_encoded</code>(<em>encoding</em>, <em>errors=None</em>)</p>
<p>返回一个通过 <code>open()</code> 打开每个文件的钩子，使用给定的 <em>encoding</em> 和 <em>errors</em> 来读取文件。</p>
<p>使用示例: <code>fi = fileinput.FileInput(openhook=fileinput.hook_encoded("utf-8", "surrogateescape"))</code></p>
<p>在 3.6 版更改: 添加了可选的 <em>errors</em> 形参。</p>
<p>3.10 版后已移除: 此函数已被弃用，因为 <code>input()</code> 和 <code>FileInput</code> 现在有了 <em>encoding</em> 和 <em>errors</em> 形参。</p>
<h2 id="stat-—-解析-stat-结果"><a href="#stat-—-解析-stat-结果" class="headerlink" title="stat —- 解析 stat() 结果"></a><code>stat</code> —- 解析 <code>stat()</code> 结果</h2><p><strong>源代码：</strong> <a href="https://github.com/python/cpython/tree/3.10/Lib/stat.py" target="_blank" rel="noopener">Lib/stat.py</a></p>
<hr>
<p><code>stat</code> 模块定义了一些用于解析 <code>os.stat()</code>, <code>os.fstat()</code> 和 <code>os.lstat()</code> (如果它们存在) 输出结果的常量和函数。 有关 <code>stat()</code>, <code>fstat()</code> 和 <code>lstat()</code> 调用的完整细节，请参阅你的系统文档。</p>
<p>在 3.4 版更改: stat 模块是通过 C 实现来支持的。</p>
<p><code>stat</code> 模块定义了以下函数来检测特定文件类型：</p>
<p><code>stat.S_ISDIR</code>(<em>mode</em>)</p>
<p>如果 mode 来自一个目录则返回非零值。</p>
<p><code>stat.S_ISCHR</code>(<em>mode</em>)</p>
<p>如果 mode 来自一个字符特殊设备文件则返回非零值。</p>
<p><code>stat.S_ISBLK</code>(<em>mode</em>)</p>
<p>如果 mode 来自一个块特殊设备文件则返回非零值。</p>
<p><code>stat.S_ISREG</code>(<em>mode</em>)</p>
<p>如果 mode 来自一个常规文件则返回非零值。</p>
<p><code>stat.S_ISFIFO</code>(<em>mode</em>)</p>
<p>如果 mode 来自一个 FIFO (命名管道) 则返回非零值。</p>
<p><code>stat.S_ISLNK</code>(<em>mode</em>)</p>
<p>如果 mode 来自一个符号链接则返回非零值。</p>
<p><code>stat.S_ISSOCK</code>(<em>mode</em>)</p>
<p>如果 mode 来自一个套接字则返回非零值。</p>
<p><code>stat.S_ISDOOR</code>(<em>mode</em>)</p>
<p>如果 mode 来自一个门则返回非零值。</p>
<p>3.4 新版功能.</p>
<p><code>stat.S_ISPORT</code>(<em>mode</em>)</p>
<p>如果 mode 来自一个事件端口则返回非零值。</p>
<p>3.4 新版功能.</p>
<p><code>stat.S_ISWHT</code>(<em>mode</em>)</p>
<p>如果 mode 来自一个白输出则返回非零值。</p>
<p>3.4 新版功能.</p>
<p>定义了两个附加函数用于对文件模式进行更一般化的操作：</p>
<p><code>stat.S_IMODE</code>(<em>mode</em>)</p>
<p>返回文件模式中可由 <code>os.chmod()</code> 进行设置的部分 —- 即文件的 permission 位，加上 sticky 位、set-group-id 以及 set-user-id 位（在支持这些部分的系统上）。</p>
<p><code>stat.S_IFMT</code>(<em>mode</em>)</p>
<p>返回文件模式中描述文件类型的部分（供上面的 <code>S_IS*()</code> 函数使用）。</p>
<p>通常，你应当使用 <code>os.path.is*()</code> 函数来检测文件的类型；这里提供的函数则适用于当你要对同一文件执行多项检测并且希望避免每项检测的 <code>stat()</code> 系统调用开销的情况。 这些函数也适用于检测有关未被 <code>os.path</code> 处理的信息，例如检测块和字符设备等。</p>
<p>示例:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> os<span class="token punctuation">,</span> sys
<span class="token keyword">from</span> stat <span class="token keyword">import</span> <span class="token operator">*</span>
<span class="token keyword">def</span> <span class="token function">walktree</span><span class="token punctuation">(</span>top<span class="token punctuation">,</span> callback<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">'''recursively descend the directory tree rooted at top,
       calling the callback function for each regular file'''</span>
    <span class="token keyword">for</span> f <span class="token keyword">in</span> os<span class="token punctuation">.</span>listdir<span class="token punctuation">(</span>top<span class="token punctuation">)</span><span class="token punctuation">:</span>
        pathname <span class="token operator">=</span> os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>join<span class="token punctuation">(</span>top<span class="token punctuation">,</span> f<span class="token punctuation">)</span>
        mode <span class="token operator">=</span> os<span class="token punctuation">.</span>stat<span class="token punctuation">(</span>pathname<span class="token punctuation">)</span><span class="token punctuation">.</span>st_mode
        <span class="token keyword">if</span> S_ISDIR<span class="token punctuation">(</span>mode<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token comment" spellcheck="true"># It's a directory, recurse into it</span>
            walktree<span class="token punctuation">(</span>pathname<span class="token punctuation">,</span> callback<span class="token punctuation">)</span>
        <span class="token keyword">elif</span> S_ISREG<span class="token punctuation">(</span>mode<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token comment" spellcheck="true"># It's a file, call the callback function</span>
            callback<span class="token punctuation">(</span>pathname<span class="token punctuation">)</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            <span class="token comment" spellcheck="true"># Unknown file type, print a message</span>
            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Skipping %s'</span> <span class="token operator">%</span> pathname<span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">visitfile</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'visiting'</span><span class="token punctuation">,</span> file<span class="token punctuation">)</span>
<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>
    walktree<span class="token punctuation">(</span>sys<span class="token punctuation">.</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> visitfile<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>另外还提供了一个附加的辅助函数用来将文件模式转换为人类易读的字符串：</p>
<p><code>stat.filemode</code>(<em>mode</em>)</p>
<p>将文件模式转换为 ‘-rwxrwxrwx’ 形式的字符串。</p>
<p>3.3 新版功能.</p>
<p>在 3.4 版更改: 此函数支持 <code>S_IFDOOR</code>, <code>S_IFPORT</code> and <code>S_IFWHT</code>。</p>
<p>以下所有变量是一些简单的符号索引，用于访问 <code>os.stat()</code>, <code>os.fstat()</code> 或 <code>os.lstat()</code> 所返回的 10 条目元组。</p>
<pre><code>stat.ST_MODE</code></pre><p>inode 保护模式。</p>
<pre><code>stat.ST_INO</code></pre><p>Inode 号</p>
<pre><code>stat.ST_DEV</code></pre><p>Inode 所在的设备。</p>
<pre><code>stat.ST_NLINK</code></pre><p>Inode 拥有的链接数量。</p>
<pre><code>stat.ST_UID</code></pre><p>所有者的用户 ID。</p>
<pre><code>stat.ST_GID</code></pre><p>所有者的用户组ID。</p>
<pre><code>stat.ST_SIZE</code></pre><p>以字节为单位的普通文件大小；对于某些特殊文件则是所等待的数据量。</p>
<pre><code>stat.ST_ATIME</code></pre><p>上次访问的时间。</p>
<pre><code>stat.ST_MTIME</code></pre><p>上次修改的时间。</p>
<pre><code>stat.ST_CTIME</code></pre><p>操作系统所报告的 “ctime”。 在某些系统上（例如 Unix）是元数据的最后修改时间，而在其他系统上（例如 Windows）则是创建时间（请参阅系统平台的文档了解相关细节）。</p>
<p>对于“文件大小”的解析可因文件类型的不同而变化。 对于普通文件就是文件的字节数。 对于大部分种类的 Unix（特别包括 Linux）的 FIFO 和套接字来说，“大小”则是指在调用 <code>os.stat()</code>, <code>os.fstat()</code> 或 <code>os.lstat()</code> 时等待读取的字节数；这在某些时候很有用处，特别是在一个非阻塞的打开后轮询这些特殊文件中的一个时。 其他字符和块设备的文件大小字段的含义还会有更多变化，具体取决于底层系统调用的实现方式。</p>
<p>以下变量定义了在 <code>ST_MODE</code> 字段中使用的旗标。</p>
<p>使用上面的函数会比使用第一组旗标更容易移植：</p>
<pre><code>stat.S_IFSOCK</code></pre><p>套接字。</p>
<pre><code>stat.S_IFLNK</code></pre><p>符号链接。</p>
<pre><code>stat.S_IFREG</code></pre><p>普通文件。</p>
<pre><code>stat.S_IFBLK</code></pre><p>块设备。</p>
<pre><code>stat.S_IFDIR</code></pre><p>目录。</p>
<pre><code>stat.S_IFCHR</code></pre><p>字符设备。</p>
<pre><code>stat.S_IFIFO</code></pre><p>先进先出。</p>
<pre><code>stat.S_IFDOOR</code></pre><p>门。</p>
<p>3.4 新版功能.</p>
<pre><code>stat.S_IFPORT</code></pre><p>事件端口。</p>
<p>3.4 新版功能.</p>
<pre><code>stat.S_IFWHT</code></pre><p>白输出。</p>
<p>3.4 新版功能.</p>
<p>注解</p>
<p><code>S_IFDOOR</code>, <code>S_IFPORT</code> or <code>S_IFWHT</code> 等文件类型在不受系统平台支持时会被定义为 0。</p>
<p>以下旗标还可以 <code>os.chmod()</code> 的在 <em>mode</em> 参数中使用：</p>
<pre><code>stat.S_ISUID</code></pre><p>设置 UID 位。</p>
<pre><code>stat.S_ISGID</code></pre><p>设置分组 ID 位。 这个位有几种特殊用途。 对于目录它表示该目录将使用 BSD 语义：在其中创建的文件将从目录继承其分组 ID，而不是从创建进程的有效分组 ID 继承，并且在其中创建的目录也将设置 <code>S_ISGID</code> 位。 对于没有设置分组执行位 (<code>S_IXGRP</code>) 的文件，设置分组 ID 位表示强制性文件/记录锁定。</p>
<pre><code>stat.S_ISVTX</code></pre><p>固定位。 当对目录设置该位时则意味着此目录中的文件只能由文件所有者、目录所有者或特权进程来重命名或删除。</p>
<pre><code>stat.S_IRWXU</code></pre><p>文件所有者权限的掩码。</p>
<pre><code>stat.S_IRUSR</code></pre><p>所有者具有读取权限。</p>
<pre><code>stat.S_IWUSR</code></pre><p>所有者具有写入权限。</p>
<pre><code>stat.S_IXUSR</code></pre><p>所有者具有执行权限。</p>
<pre><code>stat.S_IRWXG</code></pre><p>组权限的掩码。</p>
<pre><code>stat.S_IRGRP</code></pre><p>组具有读取权限。</p>
<pre><code>stat.S_IWGRP</code></pre><p>组具有写入权限。</p>
<pre><code>stat.S_IXGRP</code></pre><p>组具有执行权限。</p>
<pre><code>stat.S_IRWXO</code></pre><p>其他人（不在组中）的权限掩码。</p>
<pre><code>stat.S_IROTH</code></pre><p>其他人具有读取权限。</p>
<pre><code>stat.S_IWOTH</code></pre><p>其他人具有写入权限。</p>
<pre><code>stat.S_IXOTH</code></pre><p>其他人具有执行权限。</p>
<pre><code>stat.S_ENFMT</code></pre><p>System V 执行文件锁定。 此旗标是与 <code>S_ISGID</code> 共享的：文件/记录锁定会针对未设置分组执行位 (<code>S_IXGRP</code>) 的文件强制执行。</p>
<pre><code>stat.S_IREAD</code></pre><p>Unix V7 中 <code>S_IRUSR</code> 的同义词。</p>
<pre><code>stat.S_IWRITE</code></pre><p>Unix V7 中 <code>S_IWUSR</code> 的同义词。</p>
<pre><code>stat.S_IEXEC</code></pre><p>Unix V7 中 <code>S_IXUSR</code> 的同义词。</p>
<p>以下旗标可以在 <code>os.chflags()</code> 的 <em>flags</em> 参数中使用：</p>
<pre><code>stat.UF_NODUMP</code></pre><p>不要转储文件。</p>
<pre><code>stat.UF_IMMUTABLE</code></pre><p>文件不能被更改。</p>
<pre><code>stat.UF_APPEND</code></pre><p>文件只能被附加。</p>
<pre><code>stat.UF_OPAQUE</code></pre><p>当通过联合堆栈查看时，目录是不透明的。</p>
<pre><code>stat.UF_NOUNLINK</code></pre><p>文件不能重命名或删除。</p>
<pre><code>stat.UF_COMPRESSED</code></pre><p>The file is stored compressed (macOS 10.6+).</p>
<pre><code>stat.UF_HIDDEN</code></pre><p>The file should not be displayed in a GUI (macOS 10.5+).</p>
<pre><code>stat.SF_ARCHIVED</code></pre><p>文件可能已存档。</p>
<pre><code>stat.SF_IMMUTABLE</code></pre><p>文件不能被更改。</p>
<pre><code>stat.SF_APPEND</code></pre><p>文件只能被附加。</p>
<pre><code>stat.SF_NOUNLINK</code></pre><p>文件不能重命名或删除。</p>
<pre><code>stat.SF_SNAPSHOT</code></pre><p>文件有一个快照文件</p>
<p>See the <em>BSD or macOS systems man page *<a href="https://manpages.debian.org/chflags(2)" target="_blank" rel="noopener">chflags(2)</a></em> for more information.</p>
<p>在 Windows 上，以下文件属性常量可被用来检测 <code>os.stat()</code> 所返回的 <code>st_file_attributes</code> 成员中的位。 请参阅 <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/gg258117.aspx" target="_blank" rel="noopener">Windows API 文档</a> 了解有关这些常量含义的详情。</p>
<pre class="line-numbers language-python"><code class="language-python">stat<span class="token punctuation">.</span>FILE_ATTRIBUTE_ARCHIVE
stat<span class="token punctuation">.</span>FILE_ATTRIBUTE_COMPRESSED
stat<span class="token punctuation">.</span>FILE_ATTRIBUTE_DEVICE
stat<span class="token punctuation">.</span>FILE_ATTRIBUTE_DIRECTORY
stat<span class="token punctuation">.</span>FILE_ATTRIBUTE_ENCRYPTED
stat<span class="token punctuation">.</span>FILE_ATTRIBUTE_HIDDEN
stat<span class="token punctuation">.</span>FILE_ATTRIBUTE_INTEGRITY_STREAM
stat<span class="token punctuation">.</span>FILE_ATTRIBUTE_NORMAL
stat<span class="token punctuation">.</span>FILE_ATTRIBUTE_NOT_CONTENT_INDEXED
stat<span class="token punctuation">.</span>FILE_ATTRIBUTE_NO_SCRUB_DATA
stat<span class="token punctuation">.</span>FILE_ATTRIBUTE_OFFLINE
stat<span class="token punctuation">.</span>FILE_ATTRIBUTE_READONLY
stat<span class="token punctuation">.</span>FILE_ATTRIBUTE_REPARSE_POINT
stat<span class="token punctuation">.</span>FILE_ATTRIBUTE_SPARSE_FILE
stat<span class="token punctuation">.</span>FILE_ATTRIBUTE_SYSTEM
stat<span class="token punctuation">.</span>FILE_ATTRIBUTE_TEMPORARY
stat<span class="token punctuation">.</span>FILE_ATTRIBUTE_VIRTUAL<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>3.5 新版功能.</p>
<p>在 Windows 上，以下常量可被用来与 <code>os.lstat()</code> 所返回的 <code>st_reparse_tag</code> 成员进行比较。 这些是最主要的常量，而不是详尽的清单。</p>
<pre class="line-numbers language-python"><code class="language-python">stat<span class="token punctuation">.</span>IO_REPARSE_TAG_SYMLINK
stat<span class="token punctuation">.</span>IO_REPARSE_TAG_MOUNT_POINT
stat<span class="token punctuation">.</span>IO_REPARSE_TAG_APPEXECLINK<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>3.8 新版功能.</p>
<h2 id="filecmp-—-文件及目录的比较"><a href="#filecmp-—-文件及目录的比较" class="headerlink" title="filecmp —- 文件及目录的比较"></a><code>filecmp</code> —- 文件及目录的比较</h2><p><strong>源代码:</strong> <a href="https://github.com/python/cpython/tree/3.10/Lib/filecmp.py" target="_blank" rel="noopener">Lib/filecmp.py</a></p>
<hr>
<p><code>filecmp</code> 模块定义了用于比较文件及目录的函数，并且可以选取多种关于时间和准确性的折衷方案。</p>
<p><code>filecmp</code> 模块定义了如下函数：</p>
<p><code>filecmp.cmp</code>(<em>f1</em>, <em>f2</em>, <em>shallow=True</em>)</p>
<p>比较名为 <em>f1</em> 和 <em>f2</em> 的文件，如果它们似乎相等则返回 <code>True</code> ，否则返回 <code>False</code> 。</p>
<p>如果 <em>shallow</em> 为真值且两个文件的 <code>os.stat()</code> 签名信息（文件类型、大小和修改时间）一致，则文件会被视为相同。</p>
<p>在其他情况下，如果文件大小或内容不同则它们会被视为不同。</p>
<p>需要注意，没有外部程序被该函数调用，这赋予了该函数可移植性与效率。</p>
<p>该函数会缓存过去的比较及其结果，且在文件的 <code>os.stat()</code> 信息变化后缓存条目失效。所有的缓存可以通过使用 <code>clear_cache()</code> 来清除。</p>
<p><code>filecmp.cmpfiles</code>(<em>dir1</em>, <em>dir2</em>, <em>common</em>, <em>shallow=True</em>)</p>
<p>比较在两个目录 <em>dir1</em> 和 <em>dir2</em> 中，由 <em>common</em> 所确定名称的文件。</p>
<p>返回三组文件名列表： <em>match</em>, <em>mismatch</em>, <em>errors</em> 。 <em>match</em> 含有相匹配的文件， <em>mismatch</em> 含有那些不匹配的，然后 <em>errors</em> 列出那些未被比较文件的名称。如果文件不存在于两目录中的任一个，或者用户缺少读取它们的权限，又或者因为其他的一些原因而无法比较，那么这些文件将会被列在 <em>errors</em> 中。</p>
<p>参数 <em>shallow</em> 具有同 <code>filecmp.cmp()</code> 一致的含义与默认值。</p>
<p>例如， <code>cmpfiles('a', 'b', ['c', 'd/e'])</code> 将会比较 <code>a/c</code> 与 <code>b/c</code> 以及 <code>a/d/e</code> 与 <code>b/d/e</code> 。 <code>'c'</code> 和 <code>'d/e'</code> 将会各自出现在返回的三个列表里的某一个列表中。</p>
<p><code>filecmp.clear_cache</code>()</p>
<p>清除 filecmp 缓存。如果一个文件过快地修改，以至于超过底层文件系统记录修改时间的精度，那么该函数可能有助于比较该类文件。</p>
<p>3.4 新版功能.</p>
<h2 id="dircmp-类"><a href="#dircmp-类" class="headerlink" title="dircmp 类"></a><code>dircmp</code> 类</h2><p><em>class</em> <code>filecmp.dircmp</code>(<em>a</em>, <em>b</em>, <em>ignore=None</em>, <em>hide=None</em>)</p>
<p>创建一个用于比较目录 <em>a</em> 和 <em>b</em> 的新的目录比较对象。 <em>ignore</em> 是需要忽略的文件名列表，且默认为 <code>filecmp.DEFAULT_IGNORES</code> 。 <em>hide</em> 是需要隐藏的文件名列表，且默认为 <code>[os.curdir, os.pardir]</code> 。</p>
<p><code>dircmp</code> 类如 <code>filecmp.cmp()</code> 中所描述的那样对文件进行 <em>shallow</em> 比较。</p>
<p><code>dircmp</code> 类提供以下方法：</p>
<ul>
<li><p><code>report</code>()</p>
<p>将 <em>a</em> 与 <em>b</em> 之间的比较结果打印（到 <code>sys.stdout</code> ）。</p>
</li>
<li><p><code>report_partial_closure</code>()</p>
<p>打印 <em>a</em> 与 <em>b</em> 及共同直接子目录的比较结果。</p>
</li>
<li><p><code>report_full_closure</code>()</p>
<p>打印 <em>a</em> 与 <em>b</em> 及共同子目录比较结果（递归地）。</p>
</li>
</ul>
<p><code>dircmp</code> 类提供了一些有趣的属性，用以得到关于参与比较的目录树的各种信息。</p>
<p>需要注意，通过 <code>__getattr__()</code> 钩子，所有的属性将会惰性求值，因此如果只使用那些计算简便的属性，将不会有速度损失。</p>
<ul>
<li><p><code>left</code></p>
<p>目录 <em>a</em> 。</p>
</li>
<li><p><code>right</code></p>
<p>目录 <em>b</em> 。</p>
</li>
<li><p><code>left_list</code></p>
<p>经 <em>hide</em> 和 <em>ignore</em> 过滤，目录 <em>a</em> 中的文件与子目录。</p>
</li>
<li><p><code>right_list</code></p>
<p>经 <em>hide</em> 和 <em>ignore</em> 过滤，目录 <em>b</em> 中的文件与子目录。</p>
</li>
<li><p><code>common</code></p>
<p>同时存在于目录 <em>a</em> 和 <em>b</em> 中的文件和子目录。</p>
</li>
<li><p><code>left_only</code></p>
<p>仅在目录 <em>a</em> 中的文件和子目录。</p>
</li>
<li><p><code>right_only</code></p>
<p>仅在目录 <em>b</em> 中的文件和子目录。</p>
</li>
<li><p><code>common_dirs</code></p>
<p>同时存在于目录 <em>a</em> 和 <em>b</em> 中的子目录。</p>
</li>
<li><p><code>common_files</code></p>
<p>同时存在于目录 <em>a</em> 和 <em>b</em> 中的文件。</p>
</li>
<li><p><code>common_funny</code></p>
<p>在目录 <em>a</em> 和 <em>b</em> 中类型不同的名字，或者那些 <code>os.stat()</code> 报告错误的名字。</p>
</li>
<li><p><code>same_files</code></p>
<p>在目录 <em>a</em> 和 <em>b</em> 中，使用类的文件比较操作符判定相等的文件。</p>
</li>
<li><p><code>diff_files</code></p>
<p>在目录 <em>a</em> 和 <em>b</em> 中，根据类的文件比较操作符判定内容不等的文件。</p>
</li>
<li><p><code>funny_files</code></p>
<p>在目录 <em>a</em> 和 <em>b</em> 中无法比较的文件。</p>
</li>
<li><p><code>subdirs</code></p>
<p>一个将 <code>common_dirs</code> 中的名称映射到 <code>dircmp</code> 实例（或者 MyDirCmp 实例，如果该实例类型为 <code>dircmp</code> 的子类 MyDirCmp 的话）的字典。</p>
<p>在 3.10 版更改: 在之前版本中字典条目总是为 <code>dircmp</code> 实例。 现在条目将与 <em>self</em> 的类型相同，如果 <em>self</em> 为 <code>dircmp</code> 的子类的话。</p>
</li>
</ul>
<pre><code>filecmp.DEFAULT_IGNORES</code></pre><p>3.4 新版功能.</p>
<p>默认被 <code>dircmp</code> 忽略的目录列表。</p>
<p>下面是一个简单的例子，使用 <code>subdirs</code> 属性递归搜索两个目录以显示公共差异文件：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> filecmp <span class="token keyword">import</span> dircmp
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">def</span> <span class="token function">print_diff_files</span><span class="token punctuation">(</span>dcmp<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">for</span> name <span class="token keyword">in</span> dcmp<span class="token punctuation">.</span>diff_files<span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"diff_file %s found in %s and %s"</span> <span class="token operator">%</span> <span class="token punctuation">(</span>name<span class="token punctuation">,</span> dcmp<span class="token punctuation">.</span>left<span class="token punctuation">,</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>               dcmp<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">for</span> sub_dcmp <span class="token keyword">in</span> dcmp<span class="token punctuation">.</span>subdirs<span class="token punctuation">.</span>values<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         print_diff_files<span class="token punctuation">(</span>sub_dcmp<span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> dcmp <span class="token operator">=</span> dircmp<span class="token punctuation">(</span><span class="token string">'dir1'</span><span class="token punctuation">,</span> <span class="token string">'dir2'</span><span class="token punctuation">)</span> 
<span class="token operator">>></span><span class="token operator">></span> print_diff_files<span class="token punctuation">(</span>dcmp<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="tempfile-—-生成临时文件和目录"><a href="#tempfile-—-生成临时文件和目录" class="headerlink" title="tempfile —- 生成临时文件和目录"></a><code>tempfile</code> —- 生成临时文件和目录</h2><p><strong>源代码：</strong> <a href="https://github.com/python/cpython/tree/3.10/Lib/tempfile.py" target="_blank" rel="noopener">Lib/tempfile.py</a></p>
<hr>
<p>该模块用于创建临时文件和目录，它可以跨平台使用。<code>TemporaryFile</code>、<code>NamedTemporaryFile</code>、<code>TemporaryDirectory</code> 和 <code>SpooledTemporaryFile</code> 是带有自动清理功能的高级接口，可用作上下文管理器。<code>mkstemp()</code> 和 <code>mkdtemp()</code> 是低级函数，使用完毕需手动清理。</p>
<p>所有由用户调用的函数和构造函数都带有参数，这些参数可以设置临时文件和临时目录的路径和名称。该模块生成的文件名包括一串随机字符，在公共的临时目录中，这些字符可以让创建文件更加安全。为了保持向后兼容性，参数的顺序有些奇怪。所以为了代码清晰，建议使用关键字参数。</p>
<p>这个模块定义了以下内容供用户调用：</p>
<p><code>tempfile.TemporaryFile</code>(<em>mode=’w+b’</em>, <em>buffering=- 1</em>, <em>encoding=None</em>, <em>newline=None</em>, <em>suffix=None</em>, <em>prefix=None</em>, <em>dir=None</em>, <em>**,</em> errors=None*)</p>
<p>返回一个 file-like object （文件类对象）作为临时存储区域。创建该文件使用了与 <code>mkstemp()</code> 相同的安全规则。它将在关闭后立即销毁（包括垃圾回收机制关闭该对象时）。在 Unix 下，该文件在目录中的条目根本不创建，或者创建文件后立即就被删除了，其他平台不支持此功能。您的代码不应依赖使用此功能创建的临时文件名称，因为它在文件系统中的名称可能是可见的，也可能是不可见的。</p>
<p>生成的对象可以用作上下文管理器。完成上下文或销毁临时文件对象后，临时文件将从文件系统中删除。</p>
<p><em>mode</em> 参数默认值为 <code>'w+b'</code>，所以创建的文件不用关闭，就可以读取或写入。因为用的是二进制模式，所以无论存的是什么数据，它在所有平台上都表现一致。<em>buffering<em>、</em>encoding<em>、</em>errors</em> 和 <em>newline</em> 的含义与 <code>open()</code> 中的相同。</p>
<p>参数 <em>dir<em>、</em>prefix</em> 和 <em>suffix</em> 的含义和默认值都与它们在 <code>mkstemp()</code> 中的相同。</p>
<p>在 POSIX 平台上，它返回的对象是真实的文件对象。在其他平台上，它是一个文件类对象 (file-like object)，它的 <code>file</code> 属性是底层的真实文件对象。</p>
<p>如果可用，则使用 <code>os.O_TMPFILE</code> 标志（仅限于 Linux，需要 3.11 及更高版本的内核）。</p>
<p>引发一个 <code>tempfile.mkstemp</code> 审计事件，附带参数 <code>fullpath</code>。</p>
<p>在 3.5 版更改: 如果可用，现在用的是 <code>os.O_TMPFILE</code> 标志。</p>
<p>在 3.8 版更改: 添加了 <em>errors</em> 参数。</p>
<p><code>tempfile.NamedTemporaryFile</code>(<em>mode=’w+b’</em>, <em>buffering=- 1</em>, <em>encoding=None</em>, <em>newline=None</em>, <em>suffix=None</em>, <em>prefix=None</em>, <em>dir=None</em>, <em>delete=True</em>, <em>**,</em> errors=None*)</p>
<p>此函数执行的操作与 <code>TemporaryFile()</code> 完全相同，但确保了该临时文件在文件系统中具有可见的名称（在 Unix 上表现为目录条目不取消链接）。从返回的文件类对象的 <code>name</code> 属性中可以检索到文件名。在临时文件仍打开时，是否允许用文件名第二次打开文件，在各个平台上是不同的（在 Unix 上可以，但在 Windows NT 或更高版本上不行）。如果 <em>delete</em> 为 true（默认值），则文件会在关闭后立即被删除。该函数返回的对象始终是文件类对象 (file-like object)，它的 <code>file</code> 属性是底层的真实文件对象。文件类对象可以像普通文件一样在 <code>with</code> 语句中使用。</p>
<p>引发一个 <code>tempfile.mkstemp</code> 审计事件，附带参数 <code>fullpath</code>。</p>
<p>在 3.8 版更改: 添加了 <em>errors</em> 参数。</p>
<p><code>tempfile.SpooledTemporaryFile</code>(<em>max_size=0</em>, <em>mode=’w+b’</em>, <em>buffering=- 1</em>, <em>encoding=None</em>, <em>newline=None</em>, <em>suffix=None</em>, <em>prefix=None</em>, <em>dir=None</em>, <em>**,</em> errors=None*)</p>
<p>此函数执行的操作与 <code>TemporaryFile()</code> 完全相同，但会将数据缓存在内存中，直到文件大小超过 <em>max_size</em>，或调用文件的 <code>fileno()</code> 方法为止，此时数据会被写入磁盘，并且写入操作与 <code>TemporaryFile()</code> 相同。</p>
<p>此函数生成的文件对象有一个额外的方法——<code>rollover()</code>，可以忽略文件大小，让文件立即写入磁盘。</p>
<p>返回的对象是文件类对象 (file-like object)，它的 <code>_file</code> 属性是 <code>io.BytesIO</code> 或 <code>io.TextIOWrapper</code> 对象（取决于指定的是二进制模式还是文本模式）或真实的文件对象（取决于是否已调用 <code>rollover()</code>）。文件类对象可以像普通文件一样在 <code>with</code> 语句中使用。</p>
<p>在 3.3 版更改: 现在，文件的 truncate 方法可接受一个 <code>size</code> 参数。</p>
<p>在 3.8 版更改: 添加了 <em>errors</em> 参数。</p>
<p><code>tempfile.TemporaryDirectory</code>(<em>suffix=None</em>, <em>prefix=None</em>, <em>dir=None</em>, <em>ignore_cleanup_errors=False</em>)</p>
<p>此函数会使用与 <code>mkdtemp()</code> 相同的规则安全地创建一个临时目录。 结果对象可被用作上下文管理器。 在完成上下文或销毁临时目录对象时，新创建的临时目录及其所有内容会从文件系统中被移除。</p>
<p>可以从返回对象的 <code>name</code> 属性中找到临时目录的名称。当返回的对象用作上下文管理器时，这个 <code>name</code> 会作为 <code>with</code> 语句中 <code>as</code> 子句的目标（如果有 as 的话）。</p>
<p>此目录可通过调用 <code>cleanup()</code> 方法来显式地清理。 如果 <em>ignore_cleanup_errors</em> 为真值，则在显式或隐式清理（例如在 Windows 上 <code>PermissionError</code> 移除打开的文件）期间出现的未处理异常将被忽略，并且剩余的可移除条目会被“尽可能”地删除。 在其他情况下，错误将在任何上下文清理发生时被引发 (<code>cleanup()</code> 调用、退出上下文管理器、对象被作为垃圾回收或解释器关闭等)。</p>
<p>引发一个 <code>tempfile.mkdtemp</code> 审计事件，附带参数 <code>fullpath</code>。</p>
<p>3.2 新版功能.</p>
<p>在 3.10 版更改: 添加了 <em>ignore_cleanup_errors</em> 形参。</p>
<p><code>tempfile.mkstemp</code>(<em>suffix=None</em>, <em>prefix=None</em>, <em>dir=None</em>, <em>text=False</em>)</p>
<p>以最安全的方式创建一个临时文件。假设所在平台正确实现了 <code>os.open()</code> 的 <code>os.O_EXCL</code> 标志，则创建文件时不会有竞争的情况。该文件只能由创建者读写，如果所在平台用权限位来标记文件是否可执行，那么没有人有执行权。文件描述符不会过继给子进程。</p>
<p>与 <code>TemporaryFile()</code> 不同，<code>mkstemp()</code> 用户用完临时文件后需要自行将其删除。</p>
<p>如果 <em>suffix</em> 不是 <code>None</code> 则文件名将以该后缀结尾，是 <code>None</code> 则没有后缀。<code>mkstemp()</code> 不会在文件名和后缀之间加点，如果需要加一个点号，请将其放在 <em>suffix</em> 的开头。</p>
<p>如果 <em>prefix</em> 不是 <code>None</code>，则文件名将以该前缀开头，是 <code>None</code> 则使用默认前缀。默认前缀是 <code>gettempprefix()</code> 或 <code>gettempprefixb()</code> 函数的返回值（自动调用合适的函数）。</p>
<p>如果 <em>dir</em> 不为 <code>None</code>，则在指定的目录创建文件，是 <code>None</code> 则使用默认目录。默认目录是从一个列表中选择出来的，这个列表不同平台不一样，但是用户可以设置 <em>TMPDIR<em>、</em>TEMP</em> 或 <em>TMP</em> 环境变量来设置目录的位置。因此，不能保证生成的临时文件路径很规范，比如，通过 <code>os.popen()</code> 将路径传递给外部命令时仍需要加引号。</p>
<p>如果 <em>suffix<em>、</em>prefix</em> 和 <em>dir</em> 中的任何一个不是 <code>None</code>，就要保证它们是同一数据类型。如果它们是 bytes，则返回的名称的类型就是 bytes 而不是 str。如果确实要用默认参数，但又想要返回值是 bytes 类型，请传入 <code>suffix=b''</code>。</p>
<p>如果指定了 <em>text</em> 且为真值，文件会以文本模式打开。 否则，文件（默认）会以二进制模式打开。</p>
<p><code>mkstemp()</code> 返回一个元组，元组中第一个元素是句柄，它是一个系统级句柄，指向一个打开的文件（等同于 <code>os.open()</code> 的返回值），第二元素是该文件的绝对路径。</p>
<p>引发一个 <code>tempfile.mkstemp</code> 审计事件，附带参数 <code>fullpath</code>。</p>
<p>在 3.5 版更改: 现在，<em>suffix<em>、</em>prefix</em> 和 <em>dir</em> 可以以 bytes 类型按顺序提供，以获得 bytes 类型的返回值。之前只允许使用 str。<em>suffix</em> 和 <em>prefix</em> 现在可以接受 <code>None</code>，并且默认为 <code>None</code> 以使用合适的默认值。</p>
<p>在 3.6 版更改: <em>dir</em> 参数现在可接受一个路径类对象 (path-like object)。</p>
<p><code>tempfile.mkdtemp</code>(<em>suffix=None</em>, <em>prefix=None</em>, <em>dir=None</em>)</p>
<p>以最安全的方式创建一个临时目录，创建该目录时不会有竞争的情况。该目录只能由创建者读取、写入和搜索。</p>
<p><code>mkdtemp()</code> 用户用完临时目录后需要自行将其删除。</p>
<p><em>prefix<em>、</em>suffix</em> 和 <em>dir</em> 的含义与它们在 <code>mkstemp()</code> 中的相同。</p>
<p><code>mkdtemp()</code> 返回新目录的绝对路径。</p>
<p>引发一个 <code>tempfile.mkdtemp</code> 审计事件，附带参数 <code>fullpath</code>。</p>
<p>在 3.5 版更改: 现在，<em>suffix<em>、</em>prefix</em> 和 <em>dir</em> 可以以 bytes 类型按顺序提供，以获得 bytes 类型的返回值。之前只允许使用 str。<em>suffix</em> 和 <em>prefix</em> 现在可以接受 <code>None</code>，并且默认为 <code>None</code> 以使用合适的默认值。</p>
<p>在 3.6 版更改: <em>dir</em> 参数现在可接受一个路径类对象 (path-like object)。</p>
<p><code>tempfile.gettempdir</code>()</p>
<p>返回放置临时文件的目录的名称。这个方法的返回值就是本模块所有函数的 <em>dir</em> 参数的默认值。</p>
<p>Python 搜索标准目录列表，以找到调用者可以在其中创建文件的目录。这个列表是：</p>
<ol>
<li><code>TMPDIR</code> 环境变量指向的目录。</li>
<li><code>TEMP</code> 环境变量指向的目录。</li>
<li><code>TMP</code> 环境变量指向的目录。</li>
<li>与平台相关的位置：<ul>
<li>在 Windows 上，依次为 <code>C:\TEMP</code>、<code>C:\TMP</code>、<code>\TEMP</code> 和 <code>\TMP</code>。</li>
<li>在所有其他平台上，依次为 <code>/tmp</code>、<code>/var/tmp</code> 和 <code>/usr/tmp</code>。</li>
</ul>
</li>
<li>不得已时，使用当前工作目录。</li>
</ol>
<p>在 3.10 版更改: 总是返回一个字符串。 在之前的版本中它会返回任意 <code>tempdir</code> 值而不考虑它的类型，只要它不为 <code>None</code>。</p>
<p><code>tempfile.gettempdirb</code>()</p>
<p>与 <code>gettempdir()</code> 相同，但返回值为字节类型。</p>
<p>3.5 新版功能.</p>
<p><code>tempfile.gettempprefix</code>()</p>
<p>返回用于创建临时文件的文件名前缀，它不包含目录部分。</p>
<p><code>tempfile.gettempprefixb</code>()</p>
<p>与 <code>gettempprefix()</code> 相同，但返回值为字节类型。</p>
<p>3.5 新版功能.</p>
<p>本模块使用一个全局变量来存储由 <code>gettempdir()</code> 返回的临时文件使用的目录路径。 它可被直接设置以覆盖选择过程，但不建议这样做。 本模块中的所有函数都接受一个 <em>dir</em> 参数，它可被用于指定目录。 这是不会通过改变全局 API 行为对其他无准备代码造成影响的推荐做法。</p>
<pre><code>tempfile.tempdir</code></pre><p>当设为 <code>None</code> 以外的值时，此变量会为本模块中定义的函数的 <em>dir</em> 参数定义默认值，包括确定其类型为字节串还是字符串。 它不可以为 path-like object。</p>
<p>如果在调用除 <code>gettempprefix()</code> 外的上述任何函数时 <code>tempdir</code> 为 <code>None</code> (默认值) 则它会按照 <code>gettempdir()</code> 中所描述的算法来初始化。</p>
<p>注解</p>
<p>请注意如果你将 <code>tempdir</code> 设为字节串值，会有一个麻烦的副作用: <code>mkstemp()</code> 和 <code>mkdtemp()</code> 的全局默认返回类型会在没有显式提供字符串类型的when no explicit <code>prefix</code>, <code>suffix</code> 或 <code>dir</code> 的时候被改为字节串。 请不要编写预期或依赖于此入围的代码。 这个笨拙行为是为了保持与历史实现的兼容性。</p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>以下是 <code>tempfile</code> 模块典型用法的一些示例:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> tempfile
<span class="token comment" spellcheck="true"># create a temporary file and write some data to it</span>
<span class="token operator">>></span><span class="token operator">></span> fp <span class="token operator">=</span> tempfile<span class="token punctuation">.</span>TemporaryFile<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> fp<span class="token punctuation">.</span>write<span class="token punctuation">(</span>b<span class="token string">'Hello world!'</span><span class="token punctuation">)</span>
<span class="token comment" spellcheck="true"># read data from file</span>
<span class="token operator">>></span><span class="token operator">></span> fp<span class="token punctuation">.</span>seek<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> fp<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span>
b<span class="token string">'Hello world!'</span>
<span class="token comment" spellcheck="true"># close the file, it will be removed</span>
<span class="token operator">>></span><span class="token operator">></span> fp<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment" spellcheck="true"># create a temporary file using a context manager</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">with</span> tempfile<span class="token punctuation">.</span>TemporaryFile<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">as</span> fp<span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     fp<span class="token punctuation">.</span>write<span class="token punctuation">(</span>b<span class="token string">'Hello world!'</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     fp<span class="token punctuation">.</span>seek<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     fp<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span>
b<span class="token string">'Hello world!'</span>
<span class="token operator">>></span><span class="token operator">></span>
<span class="token comment" spellcheck="true"># file is now closed and removed</span>
<span class="token comment" spellcheck="true"># create a temporary directory using the context manager</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">with</span> tempfile<span class="token punctuation">.</span>TemporaryDirectory<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">as</span> tmpdirname<span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'created temporary directory'</span><span class="token punctuation">,</span> tmpdirname<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span>
<span class="token comment" spellcheck="true"># directory and contents have been removed</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="已弃用的函数和变量"><a href="#已弃用的函数和变量" class="headerlink" title="已弃用的函数和变量"></a>已弃用的函数和变量</h3><p>创建临时文件有一种历史方法，首先使用 <code>mktemp()</code> 函数生成一个文件名，然后使用该文件名创建文件。不幸的是，这是不安全的，因为在调用 <code>mktemp()</code> 与随后尝试创建文件的进程之间的时间里，其他进程可能会使用该名称创建文件。解决方案是将两个步骤结合起来，立即创建文件。这个方案目前被 <code>mkstemp()</code> 和上述其他函数所采用。</p>
<p><code>tempfile.mktemp</code>(<em>suffix=’’</em>, <em>prefix=’tmp’</em>, <em>dir=None</em>)</p>
<p>2.3 版后已移除: 使用 <code>mkstemp()</code> 来代替。</p>
<p>返回一个绝对路径，这个路径指向的文件在调用本方法时不存在。<em>prefix<em>、</em>suffix</em> 和 <em>dir</em> 参数与 <code>mkstemp()</code> 中的同名参数类似，不同之处在于不支持字节类型的文件名，不支持 <code>suffix=None</code> 和 <code>prefix=None</code>。</p>
<p>警告</p>
<p>使用此功能可能会在程序中引入安全漏洞。当你开始使用本方法返回的文件执行任何操作时，可能有人已经捷足先登了。<code>mktemp()</code> 的功能可以很轻松地用 <code>NamedTemporaryFile()</code> 代替，当然需要传递 <code>delete=False</code> 参数:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> f <span class="token operator">=</span> NamedTemporaryFile<span class="token punctuation">(</span>delete<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> f<span class="token punctuation">.</span>name
<span class="token string">'/tmp/tmptjujjt'</span>
<span class="token operator">>></span><span class="token operator">></span> f<span class="token punctuation">.</span>write<span class="token punctuation">(</span>b<span class="token string">"Hello World!\n"</span><span class="token punctuation">)</span>
<span class="token number">13</span>
<span class="token operator">>></span><span class="token operator">></span> f<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> os<span class="token punctuation">.</span>unlink<span class="token punctuation">(</span>f<span class="token punctuation">.</span>name<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>exists<span class="token punctuation">(</span>f<span class="token punctuation">.</span>name<span class="token punctuation">)</span>
<span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="glob-—-Unix-风格路径名模式扩展"><a href="#glob-—-Unix-风格路径名模式扩展" class="headerlink" title="glob —- Unix 风格路径名模式扩展"></a><code>glob</code> —- Unix 风格路径名模式扩展</h2><p><strong>源代码:</strong> <a href="https://github.com/python/cpython/tree/3.10/Lib/glob.py" target="_blank" rel="noopener">Lib/glob.py</a></p>
<hr>
<p><code>glob</code> 模块可根据 Unix 终端所用规则找出所有匹配特定模式的路径名，但会按不确定的顺序返回结果。 波浪号扩展不会生效，但 <code>*</code>, <code>?</code> 以及表示为 <code>[]</code> 的字符范围将被正确地匹配。 这是通过配合使用 <code>os.scandir()</code> 和 <code>fnmatch.fnmatch()</code> 函数来实现的，而不是通过实际发起调用子终端。 请注意不同于 <code>fnmatch.fnmatch()</code>，<code>glob</code> 会将以点号 (<code>.</code>) 开头的文件名作为特殊情况来处理。 （对于波浪号和终端变量扩展，请使用 <code>os.path.expanduser()</code> 和 <code>os.path.expandvars()</code>。）</p>
<p>对于字面值匹配，请将原字符用方括号括起来。 例如，<code>'[?]'</code> 将匹配字符 <code>'?'</code>。</p>
<p>参见</p>
<p><code>pathlib</code> 模块提供高级路径对象。</p>
<p><code>glob.glob</code>(<em>pathname</em>, <em>**,</em> root_dir=None<em>,</em> dir_fd=None<em>,</em> recursive=False*)</p>
<p>返回匹配 <em>pathname</em> 的可能为空的路径名列表，其中的元素必须为包含路径信息的字符串。 <em>pathname</em> 可以是绝对路径 (如 <code>/usr/src/Python-1.5/Makefile</code>) 或相对路径 (如 <code>../../Tools/*/*.gif</code>)，并且可包含 shell 风格的通配符。 结果也将包含无效的符号链接（与在 shell 中一样）。 结果是否排序取决于具体文件系统。 如果某个符合条件的文件在调用此函数期间被移除或添加，是否包括该文件的路径是没有规定的。</p>
<p>如果 <em>root_dir</em> 不为 <code>None</code>，则它应当是指明要搜索的根目录的 path-like object。 它用在 <code>glob()</code> 上与在调用它之前改变当前目录有相同的效果。 如果 <em>pathname</em> 为相对路径，结果将包含相对于 <em>root_dir</em> 的路径。</p>
<p>本函数带有 <em>dir_fd</em> 参数，支持 基于目录描述符的相对路径。</p>
<p>如果 <em>recursive</em> 为真值，则模式 “<code>**</code>“ 将匹配目录中的任何文件以及零个或多个目录、子目录和符号链接。 如果模式加了一个 <code>os.sep</code> 或 <code>os.altsep</code> 则将不匹配文件。</p>
<p>引发一个 审计事件 <code>glob.glob</code> 附带参数 <code>pathname</code>, <code>recursive</code>。</p>
<p>引发一个 审计事件 <code>glob.glob/2</code>，附带参数 <code>pathname</code>, <code>recursive</code>, <code>root_dir</code>, <code>dir_fd</code>。</p>
<p>注解</p>
<p>在一个较大的目录树中使用 “<code>**</code>“ 模式可能会消耗非常多的时间。</p>
<p>在 3.5 版更改: 支持使用 “<code>**</code>“ 的递归 glob。</p>
<p>在 3.10 版更改: 添加了 <em>root_dir</em> 和 <em>dir_fd</em> 形参。</p>
<p><code>glob.iglob</code>(<em>pathname</em>, <em>**,</em> root_dir=None<em>,</em> dir_fd=None<em>,</em> recursive=False*)</p>
<p>返回一个 iterator，它会产生与 <code>glob()</code> 相同的结果，但不会实际地同时保存它们。</p>
<p>引发一个 审计事件 <code>glob.glob</code> 附带参数 <code>pathname</code>, <code>recursive</code>。</p>
<p>引发一个 审计事件 <code>glob.glob/2</code>，附带参数 <code>pathname</code>, <code>recursive</code>, <code>root_dir</code>, <code>dir_fd</code>。</p>
<p>在 3.5 版更改: 支持使用 “<code>**</code>“ 的递归 glob。</p>
<p>在 3.10 版更改: 添加了 <em>root_dir</em> 和 <em>dir_fd</em> 形参。</p>
<p><code>glob.escape</code>(<em>pathname</em>)</p>
<p>转义所有特殊字符 (<code>'?'</code>, <code>'*'</code> 和 <code>'['</code>)。 这适用于当你想要匹配可能带有特殊字符的任意字符串字面值的情况。 在 drive/UNC 共享点中的特殊字符不会被转义，例如在 Windows 上 <code>escape('//?/c:/Quo vadis?.txt')</code> 将返回 <code>'//?/c:/Quo vadis[?].txt'</code>。</p>
<p>3.4 新版功能.</p>
<p>例如，考虑一个包含以下内容的目录：文件 <code>1.gif</code>, <code>2.txt</code>, <code>card.gif</code> 以及一个子目录 <code>sub</code> 其中只包含一个文件 <code>3.txt</code>. <code>glob()</code> 将产生如下结果。 请注意路径的任何开头部分都将被保留。:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> glob
<span class="token operator">>></span><span class="token operator">></span> glob<span class="token punctuation">.</span>glob<span class="token punctuation">(</span><span class="token string">'./[0-9].*'</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token string">'./1.gif'</span><span class="token punctuation">,</span> <span class="token string">'./2.txt'</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> glob<span class="token punctuation">.</span>glob<span class="token punctuation">(</span><span class="token string">'*.gif'</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token string">'1.gif'</span><span class="token punctuation">,</span> <span class="token string">'card.gif'</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> glob<span class="token punctuation">.</span>glob<span class="token punctuation">(</span><span class="token string">'?.gif'</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token string">'1.gif'</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> glob<span class="token punctuation">.</span>glob<span class="token punctuation">(</span><span class="token string">'**/*.txt'</span><span class="token punctuation">,</span> recursive<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token string">'2.txt'</span><span class="token punctuation">,</span> <span class="token string">'sub/3.txt'</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> glob<span class="token punctuation">.</span>glob<span class="token punctuation">(</span><span class="token string">'./**/'</span><span class="token punctuation">,</span> recursive<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token string">'./'</span><span class="token punctuation">,</span> <span class="token string">'./sub/'</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果目录包含以 <code>.</code> 打头的文件，它们默认将不会被匹配。 例如，考虑一个包含 <code>card.gif</code> 和 <code>.card.gif</code> 的目录:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> glob
<span class="token operator">>></span><span class="token operator">></span> glob<span class="token punctuation">.</span>glob<span class="token punctuation">(</span><span class="token string">'*.gif'</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token string">'card.gif'</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> glob<span class="token punctuation">.</span>glob<span class="token punctuation">(</span><span class="token string">'.c*'</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token string">'.card.gif'</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="fnmatch-—-Unix-文件名模式匹配"><a href="#fnmatch-—-Unix-文件名模式匹配" class="headerlink" title="fnmatch —- Unix 文件名模式匹配"></a><code>fnmatch</code> —- Unix 文件名模式匹配</h2><p><strong>源代码:</strong> <a href="https://github.com/python/cpython/tree/3.10/Lib/fnmatch.py" target="_blank" rel="noopener">Lib/fnmatch.py</a></p>
<hr>
<p>此模块提供了 Unix shell 风格的通配符，它们 <em>并不</em> 等同于正则表达式。 shell 风格通配符所使用的特殊字符如下：</p>
<table>
<thead>
<tr>
<th align="left">模式</th>
<th align="left">含意</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>*</code></td>
<td align="left">匹配所有</td>
</tr>
<tr>
<td align="left"><code>?</code></td>
<td align="left">匹配任何单个字符</td>
</tr>
<tr>
<td align="left"><code>[seq]</code></td>
<td align="left">匹配 <em>seq</em> 中的任何字符</td>
</tr>
<tr>
<td align="left"><code>[!seq]</code></td>
<td align="left">匹配任何不在 <em>seq</em> 中的字符</td>
</tr>
</tbody></table>
<p>对于字面值匹配，请将原字符用方括号括起来。 例如，<code>'[?]'</code> 将匹配字符 <code>'?'</code>。</p>
<p>注意文件名分隔符 (Unix 上为 <code>'/'</code>) <em>不是</em> 此模块所特有的。 请参见 <code>glob</code> 模块了解文件名扩展 (<code>glob</code> 使用 <code>filter()</code> 来匹配文件名的各个部分)。 类似地，以一个句点打头的文件名也不是此模块所特有的，可以通过 <code>*</code> 和 <code>?</code> 模式来匹配。</p>
<p><code>fnmatch.fnmatch</code>(<em>filename</em>, <em>pattern</em>)</p>
<p>检测 <em>filename</em> 字符串是否匹配 <em>pattern</em> 字符串，返回 <code>True</code> 或 <code>False</code>。 两个形参都会使用 <code>os.path.normcase()</code> 进行大小写正规化。 <code>fnmatchcase()</code> 可被用于执行大小写敏感的比较，无论这是否为所在操作系统的标准。</p>
<p>这个例子将打印当前目录下带有扩展名 <code>.txt</code> 的所有文件名:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> fnmatch
<span class="token keyword">import</span> os
<span class="token keyword">for</span> file <span class="token keyword">in</span> os<span class="token punctuation">.</span>listdir<span class="token punctuation">(</span><span class="token string">'.'</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> fnmatch<span class="token punctuation">.</span>fnmatch<span class="token punctuation">(</span>file<span class="token punctuation">,</span> <span class="token string">'*.txt'</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>fnmatch.fnmatchcase</code>(<em>filename</em>, <em>pattern</em>)</p>
<p>检测 <em>filename</em> 是否匹配 <em>pattern</em>，返回 <code>True</code> 或 <code>False</code>；此比较是大小写敏感的，并且不会应用 <code>os.path.normcase()</code>。</p>
<p><code>fnmatch.filter</code>(<em>names</em>, <em>pattern</em>)</p>
<p>基于可迭代对象 <em>names</em> 中匹配 <em>pattern</em> 的元素构造一个列表。 它等价于 <code>[n for n in names if fnmatch(n, pattern)]</code>，但实现得更有效率。</p>
<p><code>fnmatch.translate</code>(<em>pattern</em>)</p>
<p>返回 shell 风格 <em>pattern</em> 转换成的正则表达式以便用于 <code>re.match()</code>。</p>
<p>示例:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> fnmatch<span class="token punctuation">,</span> re
<span class="token operator">>></span><span class="token operator">></span>
<span class="token operator">>></span><span class="token operator">></span> regex <span class="token operator">=</span> fnmatch<span class="token punctuation">.</span>translate<span class="token punctuation">(</span><span class="token string">'*.txt'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> regex
<span class="token string">'(?s:.*\\.txt)\\Z'</span>
<span class="token operator">>></span><span class="token operator">></span> reobj <span class="token operator">=</span> re<span class="token punctuation">.</span>compile<span class="token punctuation">(</span>regex<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> reobj<span class="token punctuation">.</span>match<span class="token punctuation">(</span><span class="token string">'foobar.txt'</span><span class="token punctuation">)</span>
<span class="token operator">&lt;</span>re<span class="token punctuation">.</span>Match object<span class="token punctuation">;</span> span<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span> match<span class="token operator">=</span><span class="token string">'foobar.txt'</span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="linecache-—-随机读写文本行"><a href="#linecache-—-随机读写文本行" class="headerlink" title="linecache —- 随机读写文本行"></a><code>linecache</code> —- 随机读写文本行</h2><p><strong>源代码:</strong> <a href="https://github.com/python/cpython/tree/3.10/Lib/linecache.py" target="_blank" rel="noopener">Lib/linecache.py</a></p>
<hr>
<p><code>linecache</code> 模块允许从一个 Python 源文件中获取任意的行，并会尝试使用缓存进行内部优化，常应用于从单个文件读取多行的场合。 此模块被 <code>traceback</code> 模块用来提取源码行以便包含在格式化的回溯中。</p>
<p><code>tokenize.open()</code> 函数被用于打开文件。 此函数使用 <code>tokenize.detect_encoding()</code> 来获取文件的编码格式；如果未指明编码格式，则默认编码为 UTF-8。</p>
<p><code>linecache</code> 模块定义了下列函数：</p>
<p><code>linecache.getline</code>(<em>filename</em>, <em>lineno</em>, <em>module_globals=None</em>)</p>
<p>从名为 <em>filename</em> 的文件中获取 <em>lineno</em> 行，此函数绝不会引发异常 —- 出现错误时它将返回 <code>''</code> (所有找到的行都将包含换行符作为结束)。</p>
<p>如果找不到名为 <em>filename</em> 的文件，此函数会先在 <em>module_globals</em> 中检查 <a href="https://www.python.org/dev/peps/pep-0302" target="_blank" rel="noopener"><strong>PEP 302</strong></a> <code>__loader__</code>。 如果存在这样的加载器并且它定义了 <code>get_source</code> 方法，则由该方法来确定源行 (如果 <code>get_source()</code> 返回 <code>None</code>，则该函数返回 <code>''</code>)。 最后，如果 <em>filename</em> 是一个相对路径文件名，则它会在模块搜索路径 <code>sys.path</code> 中按条目的相对位置进行查找。</p>
<p><code>linecache.clearcache</code>()</p>
<p>清空缓存。 如果你不再需要之前使用 <code>getline()</code> 从文件读取的行即可使用此函数。</p>
<p><code>linecache.checkcache</code>(<em>filename=None</em>)</p>
<p>检查缓存有效性。 如果缓存中的文件在磁盘上发生了改变，而你需要更新后的版本即可使用此函数。 如果省略了 <em>filename</em>，它会检查缓存中的所有条目。</p>
<p><code>linecache.lazycache</code>(<em>filename</em>, <em>module_globals</em>)</p>
<p>捕获有关某个非基于文件的模块的足够细节信息，以允许稍后再通过 <code>getline()</code> 来获取其中的行，即使当稍后调用时 <em>module_globals</em> 为 <code>None</code>。 这可以避免在实际需要读取行之前执行 I/O，也不必始终保持模块全局变量。</p>
<p>3.5 新版功能.</p>
<p>示例:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> linecache
<span class="token operator">>></span><span class="token operator">></span> linecache<span class="token punctuation">.</span>getline<span class="token punctuation">(</span>linecache<span class="token punctuation">.</span>__file__<span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span>
<span class="token string">'import sys\n'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h2 id="shutil-—-高阶文件操作"><a href="#shutil-—-高阶文件操作" class="headerlink" title="shutil —- 高阶文件操作"></a><code>shutil</code> —- 高阶文件操作</h2><p><strong>源代码：</strong> <a href="https://github.com/python/cpython/tree/3.10/Lib/shutil.py" target="_blank" rel="noopener">Lib/shutil.py</a></p>
<hr>
<p><code>shutil</code> 模块提供了一系列对文件和文件集合的高阶操作。 特别是提供了一些支持文件拷贝和删除的函数。 </p>
<p>警告</p>
<p>即便是高阶文件拷贝函数 (<code>shutil.copy()</code>, <code>shutil.copy2()</code>) 也无法拷贝所有的文件元数据。</p>
<p>在 POSIX 平台上，这意味着将丢失文件所有者和组以及 ACL 数据。 在 Mac OS 上，资源钩子和其他元数据不被使用。 这意味着将丢失这些资源并且文件类型和创建者代码将不正确。 在 Windows 上，将不会拷贝文件所有者、ACL 和替代数据流。</p>
<h3 id="目录和文件操作"><a href="#目录和文件操作" class="headerlink" title="目录和文件操作"></a>目录和文件操作</h3><p><code>shutil.copyfileobj</code>(<em>fsrc</em>, <em>fdst</em>[, <em>length</em>])</p>
<p>将文件类对象 <em>fsrc</em> 的内容拷贝到文件类对象 <em>fdst*。 整数值 *length</em> 如果给出则为缓冲区大小。 特别地， <em>length</em> 为负值表示拷贝数据时不对源数据进行分块循环处理；默认情况下会分块读取数据以避免不受控制的内存消耗。 请注意如果 <em>fsrc</em> 对象的当前文件位置不为 0，则只有从当前文件位置到文件末尾的内容会被拷贝。</p>
<p><code>shutil.copyfile</code>(<em>src</em>, <em>dst</em>, <em>**,</em> follow_symlinks=True*)</p>
<p>将名为 <em>src</em> 的文件的内容（不包括元数据）拷贝到名为 <em>dst</em> 的文件并以尽可能高效的方式返回 <em>dst*。 *src</em> 和 <em>dst</em> 均为路径类对象或以字符串形式给出的路径名。</p>
<p><em>dst</em> 必须是完整的目标文件名。 如果 <em>src</em> 和 <em>dst</em> 指定了同一个文件，则将引发 <code>SameFileError</code>。</p>
<p>目标位置必须是可写的；否则将引发 <code>OSError</code> 异常。 如果 <em>dst</em> 已经存在，它将被替换。 特殊文件如字符或块设备以及管道无法用此函数来拷贝。</p>
<p>如果 <em>follow_symlinks</em> 为假值且 <em>src</em> 为符号链接，则将创建一个新的符号链接而不是拷贝 <em>src</em> 所指向的文件。</p>
<p>引发一个 审计事件 <code>shutil.copyfile</code> 附带参数 <code>src</code>, <code>dst</code>。</p>
<p>在 3.3 版更改: 曾经是引发 <code>IOError</code> 而不是 <code>OSError</code>。 增加了 <em>follow_symlinks</em> 参数。 现在是返回 <em>dst</em>。</p>
<p>在 3.4 版更改: 引发 <code>SameFileError</code> 而不是 <code>Error</code>。 由于前者是后者的子类，此改变是向后兼容的。</p>
<p>在 3.8 版更改: 可能会在内部使用平台专属的快速拷贝系统调用以更高效地拷贝文件。 </p>
<p><em>exception</em> <code>shutil.SameFileError</code></p>
<p>此异常会在 <code>copyfile()</code> 中的源和目标为同一文件时被引发。</p>
<p>3.4 新版功能.</p>
<p><code>shutil.copymode</code>(<em>src</em>, <em>dst</em>, <em>**,</em> follow_symlinks=True*)</p>
<p>从 <em>src</em> 拷贝权限位到 <em>dst*。 文件的内容、所有者和分组将不受影响。 *src</em> 和 <em>dst</em> 均为路径类对象或字符串形式的路径名。 如果 <em>follow_symlinks</em> 为假值，并且 <em>src</em> 和 <em>dst</em> 均为符号链接，<code>copymode()</code> 将尝试修改 <em>dst</em> 本身的模式（而非它所指向的文件）。 此功能并不是在所有平台上均可用；请参阅 <code>copystat()</code> 了解详情。 如果 <code>copymode()</code> 无法修改本机平台上的符号链接，而它被要求这样做，它将不做任何操作即返回。</p>
<p>引发一个 审计事件 <code>shutil.copymode</code> 附带参数 <code>src</code>, <code>dst</code>。</p>
<p>在 3.3 版更改: 加入 <em>follow_symlinks</em> 参数。</p>
<p><code>shutil.copystat</code>(<em>src</em>, <em>dst</em>, <em>**,</em> follow_symlinks=True*)</p>
<p>从 <em>src</em> 拷贝权限位、最近访问时间、最近修改时间以及旗标到 <em>dst*。 在 Linux上，<code>copystat()</code> 还会在可能的情况下拷贝“扩展属性”。 文件的内容、所有者和分组将不受影响。 *src</em> 和 <em>dst</em> 均为路径类对象或字符串形式的路径名。</p>
<p>如果 <em>follow_symlinks</em> 为假值，并且 <em>src</em> 和 <em>dst</em> 均指向符号链接，<code>copystat()</code> 将作用于符号链接本身而非该符号链接所指向的文件 — 从 <em>src</em> 符号链接读取信息，并将信息写入 <em>dst</em> 符号链接。</p>
<p>注解</p>
<p>并非所有平台者提供检查和修改符号链接的功能。 Python 本身可以告诉你哪些功能是在本机上可用的。</p>
<ul>
<li>如果 <code>os.chmod in os.supports_follow_symlinks</code> 为 <code>True</code>，则 <code>copystat()</code> 可以修改符号链接的权限位。</li>
<li>如果 <code>os.utime in os.supports_follow_symlinks</code> 为 <code>True</code>，则 <code>copystat()</code> 可以修改符号链接的最近访问和修改时间。</li>
<li>如果 <code>os.chflags in os.supports_follow_symlinks</code> 为 <code>True</code>，则 <code>copystat()</code> 可以修改符号链接的旗标。 (<code>os.chflags</code> 不是在所有平台上均可用。)</li>
</ul>
<p>在此功能部分或全部不可用的平台上，当被要求修改一个符号链接时，<code>copystat()</code> 将尽量拷贝所有内容。 <code>copystat()</code> 一定不会返回失败信息。</p>
<p>引发一个 审计事件 <code>shutil.copystat</code> 附带参数 <code>src</code>, <code>dst</code>。</p>
<p>在 3.3 版更改: 添加了 <em>follow_symlinks</em> 参数并且支持 Linux 扩展属性。</p>
<p><code>shutil.copy</code>(<em>src</em>, <em>dst</em>, <em>**,</em> follow_symlinks=True*)</p>
<p>将文件 <em>src</em> 拷贝到文件或目录 <em>dst*。 *src</em> 和 <em>dst</em> 应为 路径类对象 或字符串。 如果 <em>dst</em> 指定了一个目录，文件将使用 <em>src</em> 中的基准文件名拷贝到 <em>dst</em> 中。 将返回新创建文件所对应的路径。</p>
<p>如果 <em>follow_symlinks</em> 为假值且 <em>src</em> 为符号链接，则 <em>dst</em> 也将被创建为符号链接。 如果 <em>follow_symlinks</em> 为真值且 <em>src</em> 为符号链接，<em>dst</em> 将成为 <em>src</em> 所指向的文件的一个副本。</p>
<p><code>copy()</code> 会拷贝文件数据和文件的权限模式 (参见 <code>os.chmod()</code>)。 其他元数据，例如文件的创建和修改时间不会被保留。 要保留所有原有的元数据，请改用 <code>copy2()</code> 。</p>
<p>引发一个 审计事件 <code>shutil.copyfile</code> 附带参数 <code>src</code>, <code>dst</code>。</p>
<p>引发一个 审计事件 <code>shutil.copymode</code> 附带参数 <code>src</code>, <code>dst</code>。</p>
<p>在 3.3 版更改: 添加了 <em>follow_symlinks</em> 参数。 现在会返回新创建文件的路径。</p>
<p>在 3.8 版更改: 可能会在内部使用平台专属的快速拷贝系统调用以更高效地拷贝文件。 </p>
<p><code>shutil.copy2</code>(<em>src</em>, <em>dst</em>, <em>**,</em> follow_symlinks=True*)</p>
<p>类似于 <code>copy()</code>，区别在于 <code>copy2()</code> 还会尝试保留文件的元数据。</p>
<p>当 <em>follow_symlinks</em> 为假值且 <em>src</em> 为符号链接时，<code>copy2()</code> 会尝试将来自 <em>src</em> 符号链接的所有元数据拷贝到新创建的 <em>dst</em> 符号链接。 但是，此功能不是在所有平台上均可用。 在此功能部分或全部不可用的平台上，<code>copy2()</code> 将尽量保留所有元数据；<code>copy2()</code> 一定不会由于无法保留文件元数据而引发异常。</p>
<p><code>copy2()</code> 会使用 <code>copystat()</code> 来拷贝文件元数据。 </p>
<p>引发一个 审计事件 <code>shutil.copyfile</code> 附带参数 <code>src</code>, <code>dst</code>。</p>
<p>引发一个 审计事件 <code>shutil.copystat</code> 附带参数 <code>src</code>, <code>dst</code>。</p>
<p>在 3.3 版更改: 添加了 <em>follow_symlinks</em> 参数，还会尝试拷贝扩展文件系统属性（目前仅限 Linux）。 现在会返回新创建文件的路径。</p>
<p>在 3.8 版更改: 可能会在内部使用平台专属的快速拷贝系统调用以更高效地拷贝文件。 </p>
<p><code>shutil.ignore_patterns</code>(<em>\</em>patterns*)</p>
<p>这个工厂函数会创建一个函数，它可被用作 <code>copytree()</code> 的 <em>ignore</em> 可调用对象参数，以忽略那些匹配所提供的 glob 风格的 <em>patterns</em> 之一的文件和目录。 参见以下示例。</p>
<p><code>shutil.copytree</code>(<em>src</em>, <em>dst</em>, <em>symlinks=False</em>, <em>ignore=None</em>, <em>copy_function=copy2</em>, <em>ignore_dangling_symlinks=False</em>, <em>dirs_exist_ok=False</em>)</p>
<p>将以 <em>src</em> 为根起点的整个目录树拷贝到名为 <em>dst</em> 的目录并返回目标目录。 <em>dirs_exist_ok</em> 指明是否要在 <em>dst</em> 或任何丢失的父目录已存在的情况下引发异常。</p>
<p>目录的权限和时间会通过 <code>copystat()</code> 来拷贝，单个文件则会使用 <code>copy2()</code> 来拷贝。</p>
<p>如果 <em>symlinks</em> 为真值，源目录树中的符号链接会在新目录树中表示为符号链接，并且原链接的元数据在平台允许的情况下也会被拷贝；如果为假值或省略，则会将被链接文件的内容和元数据拷贝到新目录树。</p>
<p>当 <em>symlinks</em> 为假值时，如果符号链接所指向的文件不存在，则会在拷贝进程的末尾将一个异常添加到 <code>Error</code> 异常中的错误列表。 如果你希望屏蔽此异常那就将可选的 <em>ignore_dangling_symlinks</em> 旗标设为真值。 请注意此选项在不支持 <code>os.symlink()</code> 的平台上将不起作用。</p>
<p>如果给出了 <em>ignore<em>，它必须是一个可调用对象，该对象将接受 <code>copytree()</code> 所访问的目录以及 <code>os.listdir()</code> 所返回的目录内容列表作为其参数。 由于 <code>copytree()</code> 是递归地被调用的，</em>ignore</em> 可调用对象对于每个被拷贝目录都将被调用一次。 该可调用对象必须返回一个相对于当前目录的目录和文件名序列（即其第二个参数的子集）；随后这些名称将在拷贝进程中被忽略。 <code>ignore_patterns()</code> 可被用于创建这种基于 glob 风格模式来忽略特定名称的可调用对象。</p>
<p>如果发生了（一个或多个）异常，将引发一个附带原因列表的 <code>Error</code>。</p>
<p>如果给出了 <em>copy_function</em>，它必须是一个将被用来拷贝每个文件的可调用对象。 它在被调用时会将源路径和目标路径作为参数传入。 默认情况下，<code>copy2()</code> 将被使用，但任何支持同样签名（与 <code>copy()</code> 一致）都可以使用。</p>
<p>引发一个 审计事件 <code>shutil.copytree</code> 附带参数 <code>src</code>, <code>dst</code>。</p>
<p>在 3.3 版更改: 当 <em>symlinks</em> 为假值时拷贝元数据。 现在会返回 <em>dst</em>。</p>
<p>在 3.2 版更改: 添加了 <em>copy_function</em> 参数以允许提供定制的拷贝函数。 添加了 <em>ignore_dangling_symlinks</em> 参数以便在 <em>symlinks</em> 为假值时屏蔽符号链接错误。</p>
<p>在 3.8 版更改: 可能会在内部使用平台专属的快速拷贝系统调用以更高效地拷贝文件。 </p>
<p>3.8 新版功能: <em>dirs_exist_ok</em> 形参。</p>
<p><code>shutil.rmtree</code>(<em>path</em>, <em>ignore_errors=False</em>, <em>onerror=None</em>)</p>
<p>删除一个完整的目录树；<em>path</em> 必须指向一个目录（但不能是一个目录的符号链接）。 如果 <em>ignore_errors</em> 为真值，删除失败导致的错误将被忽略；如果为假值或是省略，此类错误将通过调用由 <em>onerror</em> 所指定的处理程序来处理，或者如果此参数被省略则将引发一个异常。</p>
<p>注解</p>
<p>在支持必要的基于 fd 的函数的平台上，默认会使用 <code>rmtree()</code> 的可防御符号链接攻击的版本。 在其他平台上，<code>rmtree()</code> 较易遭受符号链接攻击：给定适当的时间和环境，攻击者可以操纵文件系统中的符号链接来删除他们在其他情况下无法访问的文件。 应用程序可以使用 <code>rmtree.avoids_symlink_attacks</code> 函数属性来确定此类情况具体是哪一些。</p>
<p>如果提供了 <em>onerror*，它必须为接受三个形参的可调用对象: *function</em>, <em>path</em> 和 <em>excinfo</em>。</p>
<p>第一个形参 <em>function</em> 是引发异常的函数；它依赖于具体的平台和实现。 第二个形参 <em>path</em> 将是传递给 <em>function</em> 的路径名。 第三个形参 <em>excinfo</em> 将是由 <code>sys.exc_info()</code> 所返回的异常信息。 由 <em>onerror</em> 所引发的异常将不会被捕获。</p>
<p>引发一个 审计事件 <code>shutil.rmtree</code> 附带参数 <code>path</code>。</p>
<p>在 3.3 版更改: 添加了一个防御符号链接攻击的版本，如果平台支持基于 fd 的函数就会被使用。</p>
<p>在 3.8 版更改: 在 Windows 上将不会再在移除连接之前删除目录连接中的内容。</p>
<ul>
<li><p><code>rmtree.avoids_symlink_attacks</code></p>
<p>指明当前平台和实现是否提供防御符号链接攻击的 <code>rmtree()</code> 版本。 目前它仅在平台支持基于 fd 的目录访问函数时才返回真值。</p>
<p>3.3 新版功能.</p>
</li>
</ul>
<p><code>shutil.move</code>(<em>src</em>, <em>dst</em>, <em>copy_function=copy2</em>)</p>
<p>递归地将一个文件或目录 (<em>src</em>) 移至另一位置 (<em>dst</em>) 并返回目标位置。</p>
<p>如果目标是已存在的目录，则 <em>src</em> 会被移至该目录下。 如果目标已存在但不是目录，它可能会被覆盖，具体取决于 <code>os.rename()</code> 的语义。</p>
<p>如果目标是在当前文件系统中，则会使用 <code>os.rename()</code>。 在其他情况下，<em>src</em> 将被拷贝至 <em>dst<em>，使用的函数为 *copy_function</em>，然后目标会被移除。 对于符号链接，则将在 *dst</em> 之下或以其本身为名称创建一个指向 <em>src</em> 目标的新符号链接，并且 <em>src</em> 将被移除。</p>
<p>如果给出了 <em>copy_function*，则它必须为接受两个参数 *src</em> 和 <em>dst</em> 的可调用对象，并将在 <code>os.rename()</code> 无法使用时被用来将 <em>src</em> 拷贝到 <em>dst*。 如果源是一个目录，则会调用 <code>copytree()</code>，并向它传入 <code>copy_function()</code>。 默认的 *copy_function</em> 是 <code>copy2()</code>。 使用 <code>copy()</code> 作为 <em>copy_function</em> 允许在无法附带拷贝元数据时让移动操作成功执行，但其代价是不拷贝任何元数据。</p>
<p>引发一个 审计事件 <code>shutil.move</code> 附带参数 <code>src</code>, <code>dst</code>。</p>
<p>在 3.3 版更改: 为异类文件系统添加了显式的符号链接处理，以便使它适应 GNU 的 <strong>mv</strong> 的行为。 现在会返回 <em>dst</em>。</p>
<p>在 3.5 版更改: 增加了 <em>copy_function</em> 关键字参数。</p>
<p>在 3.8 版更改: 可能会在内部使用平台专属的快速拷贝系统调用以更高效地拷贝文件。 </p>
<p>在 3.9 版更改: 接受一个 path-like object 作为 <em>src</em> 和 <em>dst</em>。</p>
<p><code>shutil.disk_usage</code>(<em>path</em>)</p>
<p>返回给定路径的磁盘使用统计数据，形式为一个 named tuple，其中包含 <em>total</em>, <em>used</em> 和 <em>free</em> 属性，分别表示总计、已使用和未使用空间的字节数。 <em>path</em> 可以是一个文件或是一个目录。</p>
<p>3.3 新版功能.</p>
<p>在 3.8 版更改: 在 Windows 上，<em>path</em> 现在可以是一个文件或目录。</p>
<p>可用性: Unix, Windows。</p>
<p><code>shutil.chown</code>(<em>path</em>, <em>user=None</em>, <em>group=None</em>)</p>
<p>修改给定 <em>path</em> 的所有者 <em>user</em> 和/或 <em>group</em>。</p>
<p><em>user</em> 可以是一个系统用户名或 uid；<em>group</em> 同样如此。 要求至少有一个参数。</p>
<p>另请参阅下层的函数 <code>os.chown()</code>。</p>
<p>引发一个 审计事件 <code>shutil.chown</code> 附带参数 <code>path</code>, <code>user</code>, <code>group</code>。</p>
<p>可用性: Unix。</p>
<p>3.3 新版功能.</p>
<p><code>shutil.which</code>(<em>cmd</em>, <em>mode=os.F_OK | os.X_OK</em>, <em>path=None</em>)</p>
<p>返回当给定的 <em>cmd</em> 被调用时将要运行的可执行文件的路径。 如果没有 <em>cmd</em> 会被调用则返回 <code>None</code>。</p>
<p><em>mode</em> 是一个传递给 <code>os.access()</code> 的权限掩码，在默认情况下将确定文件是否存在并且为可执行文件。</p>
<p>当未指定 <em>path</em> 时，将会使用 <code>os.environ()</code> 的结果，返回 “PATH” 的值或回退为 <code>os.defpath</code>。</p>
<p>在 Windows 上当前目录总是会被添加为 <em>path</em> 的第一项，无论你是否使用默认值或提供你自己的路径，这是命令行终端在查找可执行文件时所采用的行为方式。 此外，当在 <em>path</em> 中查找 <em>cmd</em> 时，还会检查 <code>PATHEXT</code> 环境变量。 例如，如果你调用 <code>shutil.which("python")</code>，<code>which()</code> 将搜索 <code>PATHEXT</code> 来确定它要在 <em>path</em> 目录中查找 <code>python.exe</code>。 例如，在 Windows 上:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> shutil<span class="token punctuation">.</span>which<span class="token punctuation">(</span><span class="token string">"python"</span><span class="token punctuation">)</span>
<span class="token string">'C:\\Python33\\python.EXE'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>3.3 新版功能.</p>
<p>在 3.8 版更改: 现在可以接受 <code>bytes</code> 类型。 如果 <em>cmd</em> 的类型为 <code>bytes</code>，结果的类型也将为 <code>bytes</code>。</p>
<p><em>exception</em> <code>shutil.Error</code></p>
<p>此异常会收集在多文件操作期间所引发的异常。 对于 <code>copytree()</code>，此异常参数将是一个由三元组 (<em>srcname</em>, <em>dstname</em>, <em>exception</em>) 构成的列表。</p>
<h4 id="依赖于具体平台的高效拷贝操作"><a href="#依赖于具体平台的高效拷贝操作" class="headerlink" title="依赖于具体平台的高效拷贝操作"></a>依赖于具体平台的高效拷贝操作</h4><p>从 Python 3.8 开始，所有涉及文件拷贝的函数 (<code>copyfile()</code>, <code>copy()</code>, <code>copy2()</code>, <code>copytree()</code> 以及 <code>move()</code>) 将会使用平台专属的 “fast-copy” 系统调用以便更高效地拷贝文件 。 “fast-copy” 意味着拷贝操作将发生于内核之中，避免像在 “<code>outfd.write(infd.read())</code>“ 中那样使用 Python 用户空间的缓冲区。</p>
<p>在 macOS 上将会使用 fcopyfile 来拷贝文件内容（不含元数据）。</p>
<p>在 Linux 上将会使用 <code>os.sendfile()</code>。</p>
<p>在 Windows 上 <code>shutil.copyfile()</code> 将会使用更大的默认缓冲区（1 MiB 而非 64 KiB）并且会使用基于 <code>memoryview()</code> 的 <code>shutil.copyfileobj()</code> 变种形式。</p>
<p>如果快速拷贝操作失败并且没有数据被写入目标文件，则 shutil 将在内部静默地回退到使用效率较低的 <code>copyfileobj()</code> 函数。</p>
<p>在 3.8 版更改.</p>
<h4 id="copytree-示例"><a href="#copytree-示例" class="headerlink" title="copytree 示例"></a>copytree 示例</h4><p>这个示例就是上面所描述的 <code>copytree()</code> 函数的实现，其中省略了文档字符串。 它还展示了此模块所提供的许多其他函数。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">copytree</span><span class="token punctuation">(</span>src<span class="token punctuation">,</span> dst<span class="token punctuation">,</span> symlinks<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    names <span class="token operator">=</span> os<span class="token punctuation">.</span>listdir<span class="token punctuation">(</span>src<span class="token punctuation">)</span>
    os<span class="token punctuation">.</span>makedirs<span class="token punctuation">(</span>dst<span class="token punctuation">)</span>
    errors <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    <span class="token keyword">for</span> name <span class="token keyword">in</span> names<span class="token punctuation">:</span>
        srcname <span class="token operator">=</span> os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>join<span class="token punctuation">(</span>src<span class="token punctuation">,</span> name<span class="token punctuation">)</span>
        dstname <span class="token operator">=</span> os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>join<span class="token punctuation">(</span>dst<span class="token punctuation">,</span> name<span class="token punctuation">)</span>
        <span class="token keyword">try</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> symlinks <span class="token operator">and</span> os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>islink<span class="token punctuation">(</span>srcname<span class="token punctuation">)</span><span class="token punctuation">:</span>
                linkto <span class="token operator">=</span> os<span class="token punctuation">.</span>readlink<span class="token punctuation">(</span>srcname<span class="token punctuation">)</span>
                os<span class="token punctuation">.</span>symlink<span class="token punctuation">(</span>linkto<span class="token punctuation">,</span> dstname<span class="token punctuation">)</span>
            <span class="token keyword">elif</span> os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>isdir<span class="token punctuation">(</span>srcname<span class="token punctuation">)</span><span class="token punctuation">:</span>
                copytree<span class="token punctuation">(</span>srcname<span class="token punctuation">,</span> dstname<span class="token punctuation">,</span> symlinks<span class="token punctuation">)</span>
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                copy2<span class="token punctuation">(</span>srcname<span class="token punctuation">,</span> dstname<span class="token punctuation">)</span>
            <span class="token comment" spellcheck="true"># XXX What about devices, sockets etc.?</span>
        <span class="token keyword">except</span> OSError <span class="token keyword">as</span> why<span class="token punctuation">:</span>
            errors<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">(</span>srcname<span class="token punctuation">,</span> dstname<span class="token punctuation">,</span> str<span class="token punctuation">(</span>why<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token comment" spellcheck="true"># catch the Error from the recursive copytree so that we can</span>
        <span class="token comment" spellcheck="true"># continue with other files</span>
        <span class="token keyword">except</span> Error <span class="token keyword">as</span> err<span class="token punctuation">:</span>
            errors<span class="token punctuation">.</span>extend<span class="token punctuation">(</span>err<span class="token punctuation">.</span>args<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token keyword">try</span><span class="token punctuation">:</span>
        copystat<span class="token punctuation">(</span>src<span class="token punctuation">,</span> dst<span class="token punctuation">)</span>
    <span class="token keyword">except</span> OSError <span class="token keyword">as</span> why<span class="token punctuation">:</span>
        <span class="token comment" spellcheck="true"># can't copy file access times on Windows</span>
        <span class="token keyword">if</span> why<span class="token punctuation">.</span>winerror <span class="token keyword">is</span> None<span class="token punctuation">:</span>
            errors<span class="token punctuation">.</span>extend<span class="token punctuation">(</span><span class="token punctuation">(</span>src<span class="token punctuation">,</span> dst<span class="token punctuation">,</span> str<span class="token punctuation">(</span>why<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> errors<span class="token punctuation">:</span>
        <span class="token keyword">raise</span> Error<span class="token punctuation">(</span>errors<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>另一个使用 <code>ignore_patterns()</code> 辅助函数的例子:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> shutil <span class="token keyword">import</span> copytree<span class="token punctuation">,</span> ignore_patterns
copytree<span class="token punctuation">(</span>source<span class="token punctuation">,</span> destination<span class="token punctuation">,</span> ignore<span class="token operator">=</span>ignore_patterns<span class="token punctuation">(</span><span class="token string">'*.pyc'</span><span class="token punctuation">,</span> <span class="token string">'tmp*'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>这将会拷贝除 <code>.pyc</code> 文件和以 <code>tmp</code> 打头的文件或目录以外的所有条目.</p>
<p>另一个使用 <em>ignore</em> 参数来添加记录调用的例子:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> shutil <span class="token keyword">import</span> copytree
<span class="token keyword">import</span> logging
<span class="token keyword">def</span> <span class="token function">_logpath</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span> names<span class="token punctuation">)</span><span class="token punctuation">:</span>
    logging<span class="token punctuation">.</span>info<span class="token punctuation">(</span><span class="token string">'Working in %s'</span><span class="token punctuation">,</span> path<span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>   <span class="token comment" spellcheck="true"># nothing will be ignored</span>
copytree<span class="token punctuation">(</span>source<span class="token punctuation">,</span> destination<span class="token punctuation">,</span> ignore<span class="token operator">=</span>_logpath<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="rmtree-示例"><a href="#rmtree-示例" class="headerlink" title="rmtree 示例"></a>rmtree 示例</h4><p>这个例子演示了如何在 Windows 上删除一个目录树，其中部分文件设置了只读属性位。 它会使用 onerror 回调函数来清除只读属性位并再次尝试删除。 任何后续的失败都将被传播。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> os<span class="token punctuation">,</span> stat
<span class="token keyword">import</span> shutil
<span class="token keyword">def</span> <span class="token function">remove_readonly</span><span class="token punctuation">(</span>func<span class="token punctuation">,</span> path<span class="token punctuation">,</span> _<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token string">"Clear the readonly bit and reattempt the removal"</span>
    os<span class="token punctuation">.</span>chmod<span class="token punctuation">(</span>path<span class="token punctuation">,</span> stat<span class="token punctuation">.</span>S_IWRITE<span class="token punctuation">)</span>
    func<span class="token punctuation">(</span>path<span class="token punctuation">)</span>
shutil<span class="token punctuation">.</span>rmtree<span class="token punctuation">(</span>directory<span class="token punctuation">,</span> onerror<span class="token operator">=</span>remove_readonly<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="归档操作"><a href="#归档操作" class="headerlink" title="归档操作"></a>归档操作</h3><p>3.2 新版功能.</p>
<p>在 3.5 版更改: 添加了对 <em>xztar</em> 格式的支持。</p>
<p>本模块也提供了用于创建和读取压缩和归档文件的高层级工具。 它们依赖于 <code>zipfile</code> 和 <code>tarfile</code> 模块。</p>
<p><code>shutil.make_archive</code>(<em>base_name</em>, <em>format</em>[, <em>root_dir</em>[, <em>base_dir</em>[, <em>verbose</em>[, <em>dry_run</em>[, <em>owner</em>[, <em>group</em>[, <em>logger</em>]]]]]]])</p>
<p>创建一个归档文件（例如 zip 或 tar）并返回其名称。</p>
<p><em>base_name</em> 是要创建的文件名称，包括路径，去除任何特定格式的扩展名。 <em>format</em> 是归档格式：为 “zip” (如果 <code>zlib</code> 模块可用), “tar”, “gztar” (如果 <code>zlib</code> 模块可用), “bztar” (如果 <code>bz2</code> 模块可用) 或 “xztar” (如果 <code>lzma</code> 模块可用) 中的一个。</p>
<p><em>root_dir</em> 是一个目录，它将作为归档文件的根目录，归档中的所有路径都将是它的相对路径；例如，我们通常会在创建归档之前用 chdir 命令切换到 <em>root_dir</em>。</p>
<p><em>base_dir</em> 是我们要执行归档的起始目录；也就是说 <em>base_dir</em> 将成为归档中所有文件和目录共有的路径前缀。 <em>base_dir</em> 必须相对于 <em>root_dir</em> 给出。</p>
<p><em>root_dir</em> 和 <em>base_dir</em> 默认均为当前目录。</p>
<p>如果 <em>dry_run</em> 为真值，则不会创建归档文件，但将要被执行的操作会被记录到 <em>logger</em>。</p>
<p><em>owner</em> 和 <em>group</em> 将在创建 tar 归档文件时被使用。 默认会使用当前的所有者和分组。</p>
<p><em>logger</em> 必须是一个兼容 <a href="https://www.python.org/dev/peps/pep-0282" target="_blank" rel="noopener"><strong>PEP 282</strong></a> 的对象，通常为 <code>logging.Logger</code> 的实例。</p>
<p><em>verbose</em> 参数已不再使用并进入弃用状态。</p>
<p>引发一个 审计事件 <code>shutil.make_archive</code> 并附带参数 <code>base_name</code>, <code>format</code>, <code>root_dir</code>, <code>base_dir</code>。</p>
<p>注解</p>
<p>这个函数不是线程安全的。</p>
<p>在 3.8 版更改: 现在对于通过 <code>format="tar"</code> 创建的归档文件将使用新式的 pax (POSIX.1-2001) 格式而非旧式的 GNU 格式。</p>
<p><code>shutil.get_archive_formats</code>()</p>
<p>返回支持的归档格式列表。 所返回序列中的每个元素为一个元组 <code>(name, description)</code>。</p>
<p>默认情况下 <code>shutil</code> 提供以下格式:</p>
<ul>
<li><em>zip</em>: ZIP 文件（如果 <code>zlib</code> 模块可用）。</li>
<li><em>tar</em>: 未压缩的 tar 文件。 对于新归档文件将使用 POSIX.1-2001 pax 格式。</li>
<li><em>gztar</em>: gzip 压缩的 tar 文件（如果 <code>zlib</code> 模块可用）。</li>
<li><em>bztar</em>: bzip2 压缩的 tar 文件（如果 <code>bz2</code> 模块可用）。</li>
<li><em>xztar</em>: xz 压缩的 tar 文件（如果 <code>lzma</code> 模块可用）。</li>
</ul>
<p>你可以通过使用 <code>register_archive_format()</code> 注册新的格式或为任何现有格式提供你自己的归档器。</p>
<p><code>shutil.register_archive_format</code>(<em>name</em>, <em>function</em>[, <em>extra_args</em>[, <em>description</em>]])</p>
<p>为 <em>name</em> 格式注册一个归档器。</p>
<p><em>function</em> 是将被用来解包归档文件的可调用对象。 该可调用对象将接收要创建文件的 <em>base_name*，再加上要归档内容的 *base_dir</em> (其默认值为 <code>os.curdir</code>)。 更多参数会被作为关键字参数传入: <em>owner</em>, <em>group</em>, <em>dry_run</em> 和 <em>logger</em> (与向 <code>make_archive()</code> 传入的参数一致)。</p>
<p>如果给出了 <em>extra_args</em>，则其应为一个 <code>(name, value)</code> 对的序列，将在归档器可调用对象被使用时作为附加的关键字参数。</p>
<p><em>description</em> 由 <code>get_archive_formats()</code> 使用，它将返回归档器的列表。 默认值为一个空字符串。</p>
<p><code>shutil.unregister_archive_format</code>(<em>name</em>)</p>
<p>从支持的格式中移除归档格式 <em>name</em>。</p>
<p><code>shutil.unpack_archive</code>(<em>filename</em>[, <em>extract_dir</em>[, <em>format</em>]])</p>
<p>解包一个归档文件。 <em>filename</em> 是归档文件的完整路径。</p>
<p><em>extract_dir</em> 是归档文件解包的目标目录名称。 如果未提供，则将使用当前工作目录。</p>
<p><em>format</em> 是归档格式：应为 “zip”, “tar”, “gztar”, “bztar” 或 “xztar” 之一。 或者任何通过 <code>register_unpack_format()</code> 注册的其他格式。 如果未提供，<code>unpack_archive()</code> 将使用归档文件的扩展名来检查是否注册了对应于该扩展名的解包器。 在未找到任何解包器的情况下，将引发 <code>ValueError</code>。</p>
<p>引发一个 审计事件 <code>shutil.unpack_archive</code> 附带参数 <code>filename</code>, <code>extract_dir</code>, <code>format</code>。</p>
<p>在 3.7 版更改: 接受一个 path-like object 作为 <em>filename</em> 和 <em>extract_dir</em>。</p>
<p><code>shutil.register_unpack_format</code>(<em>name</em>, <em>extensions</em>, <em>function</em>[, <em>extra_args</em>[, <em>description</em>]])</p>
<p>注册一个解包格式。 <em>name</em> 为格式名称而 <em>extensions</em> 为对应于该格式的扩展名列表，例如 Zip 文件的扩展名为 <code>.zip</code>。</p>
<p><em>function</em> 是将被用来解包归档文件的可调用对象。 该可调用对象将接受归档文件的路径，加上该归档文件要被解包的目标目录。</p>
<p>如果提供了 <em>extra_args</em>，则其应为一个 <code>(name, value)</code> 元组的序列，将被作为关键字参数传递给该可调用对象。</p>
<p>可以提供 <em>description</em> 来描述该格式，它将被 <code>get_unpack_formats()</code> 返回。</p>
<p><code>shutil.unregister_unpack_format</code>(<em>name</em>)</p>
<p>撤销注册一个解包格式。 <em>name</em> 为格式的名称。</p>
<p><code>shutil.get_unpack_formats</code>()</p>
<p>返回所有已注册的解包格式列表。 所返回序列中的每个元素为一个元组 <code>(name, extensions, description)</code>。</p>
<p>默认情况下 <code>shutil</code> 提供以下格式:</p>
<ul>
<li><em>zip</em>: ZIP 文件（只有在相应模块可用时才能解包压缩文件）。</li>
<li><em>tar</em>: 未压缩的 tar 文件。</li>
<li><em>gztar</em>: gzip 压缩的 tar 文件（如果 <code>zlib</code> 模块可用）。</li>
<li><em>bztar</em>: bzip2 压缩的 tar 文件（如果 <code>bz2</code> 模块可用）。</li>
<li><em>xztar</em>: xz 压缩的 tar 文件（如果 <code>lzma</code> 模块可用）。</li>
</ul>
<p>你可以通过使用 <code>register_unpack_format()</code> 注册新的格式或为任何现有格式提供你自己的解包器。</p>
<h4 id="归档程序示例"><a href="#归档程序示例" class="headerlink" title="归档程序示例"></a>归档程序示例</h4><p>在这个示例中，我们创建了一个 gzip 压缩的 tar 归档文件，其中包含用户的 <code>.ssh</code> 目录下的所有文件:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> shutil <span class="token keyword">import</span> make_archive
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> os
<span class="token operator">>></span><span class="token operator">></span> archive_name <span class="token operator">=</span> os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>expanduser<span class="token punctuation">(</span>os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token string">'~'</span><span class="token punctuation">,</span> <span class="token string">'myarchive'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> root_dir <span class="token operator">=</span> os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>expanduser<span class="token punctuation">(</span>os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token string">'~'</span><span class="token punctuation">,</span> <span class="token string">'.ssh'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> make_archive<span class="token punctuation">(</span>archive_name<span class="token punctuation">,</span> <span class="token string">'gztar'</span><span class="token punctuation">,</span> root_dir<span class="token punctuation">)</span>
<span class="token string">'/Users/tarek/myarchive.tar.gz'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>结果归档文件中包含有:</p>
<pre><code>$ tar -tzvf /Users/tarek/myarchive.tar.gz
drwx------ tarek/staff       0 2010-02-01 16:23:40 ./
-rw-r--r-- tarek/staff     609 2008-06-09 13:26:54 ./authorized_keys
-rwxr-xr-x tarek/staff      65 2008-06-09 13:26:54 ./config
-rwx------ tarek/staff     668 2008-06-09 13:26:54 ./id_dsa
-rwxr-xr-x tarek/staff     609 2008-06-09 13:26:54 ./id_dsa.pub
-rw------- tarek/staff    1675 2008-06-09 13:26:54 ./id_rsa
-rw-r--r-- tarek/staff     397 2008-06-09 13:26:54 ./id_rsa.pub
-rw-r--r-- tarek/staff   37192 2010-02-06 18:23:10 ./known_hosts</code></pre><h4 id="使用-base-dir-的归档程序示例"><a href="#使用-base-dir-的归档程序示例" class="headerlink" title="使用 base_dir 的归档程序示例"></a>使用 <em>base_dir</em> 的归档程序示例</h4><p>在这个例子中，与 上面的例子 类似，我们演示了如何使用 <code>make_archive()</code>，但这次是使用 <em>base_dir</em>。 我们现在具有如下的目录结构:</p>
<pre><code>$ tree tmp
tmp
└── root
    └── structure
        ├── content
            └── please_add.txt
        └── do_not_add.txt</code></pre><p>在最终的归档中，应当会包括 <code>please_add.txt</code>，但不应当包括 <code>do_not_add.txt</code>。 因此我们使用以下代码:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> shutil <span class="token keyword">import</span> make_archive
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> os
<span class="token operator">>></span><span class="token operator">></span> archive_name <span class="token operator">=</span> os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>expanduser<span class="token punctuation">(</span>os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token string">'~'</span><span class="token punctuation">,</span> <span class="token string">'myarchive'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> make_archive<span class="token punctuation">(</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     archive_name<span class="token punctuation">,</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token string">'tar'</span><span class="token punctuation">,</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     root_dir<span class="token operator">=</span><span class="token string">'tmp/root'</span><span class="token punctuation">,</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     base_dir<span class="token operator">=</span><span class="token string">'structure/content'</span><span class="token punctuation">,</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">)</span>
<span class="token string">'/Users/tarek/my_archive.tar'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>列出结果归档中的文件我们将会得到:</p>
<pre><code>$ python -m tarfile -l /Users/tarek/myarchive.tarstructure/content/structure/content/please_add.txt</code></pre><h3 id="查询输出终端的尺寸"><a href="#查询输出终端的尺寸" class="headerlink" title="查询输出终端的尺寸"></a>查询输出终端的尺寸</h3><p><code>shutil.get_terminal_size</code>(<em>fallback=columns, lines</em>)</p>
<p>获取终端窗口的尺寸。</p>
<p>对于两个维度中的每一个，会分别检查环境变量 <code>COLUMNS</code> 和 <code>LINES</code>。 如果定义了这些变量并且其值为正整数，则将使用这些值。</p>
<p>如果未定义 <code>COLUMNS</code> 或 <code>LINES</code>，这是通常的情况，则连接到 <code>sys.__stdout__</code> 的终端将通过发起调用 <code>os.get_terminal_size()</code> 被查询。</p>
<p>如果由于系统不支持查询，或是由于我们未连接到某个终端而导致查询终端尺寸不成功，则会使用在 <code>fallback</code> 形参中给出的值。 <code>fallback</code> 默认为 <code>(80, 24)</code>，这是许多终端模拟器所使用的默认尺寸。</p>
<p>返回的值是一个 <code>os.terminal_size</code> 类型的具名元组。</p>
<p>3.3 新版功能.</p>
<h1 id="数据持久化"><a href="#数据持久化" class="headerlink" title="数据持久化"></a>数据持久化</h1><p> <code>pickle</code> 和 <code>marshal</code> 模块可以将许多 Python 数据类型转换为字节流，然后从字节中重新创建对象。 各种与 DBM 相关的模块支持一系列基于散列的文件格式，这些格式存储字符串到其他字符串的映射。</p>
<p>本章中描述的模块列表是：</p>
<ul>
<li><code>pickle</code> —- Python 对象序列化<ul>
<li>与其他 Python 模块间的关系<ul>
<li>与 <code>marshal</code> 间的关系</li>
<li>与 <code>json</code> 模块的比较</li>
</ul>
</li>
<li>数据流格式</li>
<li>模块接口</li>
<li>可以被封存/解封的对象</li>
<li>封存类实例<ul>
<li>持久化外部对象</li>
<li>Dispatch 表</li>
<li>处理有状态的对象</li>
</ul>
</li>
<li>类型，函数和其他对象的自定义归约</li>
<li>外部缓冲区<ul>
<li>提供方 API</li>
<li>使用方 API</li>
<li>示例</li>
</ul>
</li>
<li>限制全局变量</li>
<li>性能</li>
<li>例子</li>
</ul>
</li>
<li><code>copyreg</code> —- 注册配合 <code>pickle</code> 模块使用的函数<ul>
<li>示例</li>
</ul>
</li>
<li><code>shelve</code> —- Python 对象持久化<ul>
<li>限制</li>
<li>示例</li>
</ul>
</li>
<li><code>marshal</code> —- 内部 Python 对象序列化</li>
<li><code>dbm</code> —- Unix “数据库” 接口<ul>
<li><code>dbm.gnu</code> —- GNU 对 dbm 的重解析</li>
<li><code>dbm.ndbm</code> —- 基于 ndbm 的接口</li>
<li><code>dbm.dumb</code> —- 便携式 DBM 实现</li>
</ul>
</li>
<li><code>sqlite3</code> —- SQLite 数据库 DB-API 2.0 接口模块<ul>
<li>模块函数和常量</li>
<li>连接对象（Connection）</li>
<li>Cursor 对象</li>
<li>行对象</li>
<li>异常</li>
<li>SQLite 与 Python 类型<ul>
<li>概述</li>
<li>使用适配器将额外的 Python 类型保存在 SQLite 数据库中。<ul>
<li>让对象自行适配</li>
<li>注册可调用的适配器</li>
</ul>
</li>
<li>将SQLite 值转换为自定义Python 类型</li>
<li>默认适配器和转换器</li>
</ul>
</li>
<li>控制事务</li>
<li>有效使用 <code>sqlite3</code><ul>
<li>使用快捷方式</li>
<li>通过名称而不是索引访问索引</li>
<li>使用连接作为上下文管理器</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="pickle-—-Python-对象序列化"><a href="#pickle-—-Python-对象序列化" class="headerlink" title="pickle —- Python 对象序列化"></a><code>pickle</code> —- Python 对象序列化</h2><p><strong>源代码：</strong><a href="https://github.com/python/cpython/tree/3.10/Lib/pickle.py" target="_blank" rel="noopener">Lib/pickle.py</a></p>
<hr>
<p>模块 <code>pickle</code> 实现了对一个 Python 对象结构的二进制序列化和反序列化。 <em>“pickling”</em> 是将 Python 对象及其所拥有的层次结构转化为一个字节流的过程，而 <em>“unpickling”</em> 是相反的操作，会将（来自一个 binary file 或者 bytes-like object 的）字节流转化回一个对象层次结构。 pickling（和 unpickling）也被称为“序列化”, “编组” 或者 “平面化”。而为了避免混乱，此处采用术语 “封存 (pickling)” 和 “解封 (unpickling)”。</p>
<p>警告</p>
<p><code>pickle</code> 模块<strong>并不安全</strong>。你只应该对你信任的数据进行unpickle操作。</p>
<p>构建恶意的 pickle 数据来<strong>在解封时执行任意代码</strong>是可能的。绝对不要对不信任来源的数据和可能被篡改过的数据进行解封。</p>
<p>请考虑使用 <code>hmac</code> 来对数据进行签名，确保数据没有被篡改。</p>
<p>在你处理不信任数据时，更安全的序列化格式如 <code>json</code> 可能更为适合.</p>
<h3 id="与其他-Python-模块间的关系"><a href="#与其他-Python-模块间的关系" class="headerlink" title="与其他 Python 模块间的关系"></a>与其他 Python 模块间的关系</h3><h4 id="与-marshal-间的关系"><a href="#与-marshal-间的关系" class="headerlink" title="与 marshal 间的关系"></a>与 <code>marshal</code> 间的关系</h4><p>Python 有一个更原始的序列化模块称为 <code>marshal</code>，但一般地 <code>pickle</code> 应该是序列化 Python 对象时的首选。<code>marshal</code> 存在主要是为了支持 Python 的 <code>.pyc</code> 文件.</p>
<p><code>pickle</code> 模块与 <code>marshal</code> 在如下几方面显著地不同：</p>
<ul>
<li><p><code>pickle</code> 模块会跟踪已被序列化的对象，所以该对象之后再次被引用时不会再次被序列化。<code>marshal</code> 不会这么做。</p>
<p>这隐含了递归对象和共享对象。递归对象指包含对自己的引用的对象。这种对象并不会被 marshal 接受，并且实际上尝试 marshal 递归对象会让你的 Python 解释器崩溃。对象共享发生在对象层级中存在多处引用同一对象时。<code>pickle</code> 只会存储这些对象一次，并确保其他的引用指向同一个主副本。共享对象将保持共享，这可能对可变对象非常重要。</p>
</li>
<li><p><code>marshal</code> 不能被用于序列化用户定义类及其实例。<code>pickle</code> 能够透明地存储并保存类实例，然而此时类定义必须能够从与被存储时相同的模块被引入。</p>
</li>
<li><p>同样用于序列化的 <code>marshal</code> 格式不保证数据能移植到不同的 Python 版本中。因为它的主要任务是支持 <code>.pyc</code> 文件，必要时会以破坏向后兼容的方式更改这种序列化格式，为此 Python 的实现者保留了更改格式的权利。<code>pickle</code> 序列化格式可以在不同版本的 Python 中实现向后兼容，前提是选择了合适的 pickle 协议。如果你的数据要在 Python 2 与 Python 3 之间跨越传递，封存和解封的代码在 2 和 3 之间也是不同的。</p>
</li>
</ul>
<h4 id="与-json-模块的比较"><a href="#与-json-模块的比较" class="headerlink" title="与 json 模块的比较"></a>与 <code>json</code> 模块的比较</h4><p>Pickle 协议和 <a href="http://json.org/" target="_blank" rel="noopener">JSON (JavaScript Object Notation)</a> 间有着本质的不同：</p>
<ul>
<li>JSON 是一个文本序列化格式（它输出 unicode 文本，尽管在大多数时候它会接着以 <code>utf-8</code> 编码），而 pickle 是一个二进制序列化格式；</li>
<li>JSON 是我们可以直观阅读的，而 pickle 不是；</li>
<li>JSON是可互操作的，在Python系统之外广泛使用，而pickle则是Python专用的；</li>
<li>默认情况下，JSON 只能表示 Python 内置类型的子集，不能表示自定义的类；但 pickle 可以表示大量的 Python 数据类型（可以合理使用 Python 的对象内省功能自动地表示大多数类型，复杂情况可以通过实现 specific object APIs 来解决）。</li>
<li>不像pickle，对一个不信任的JSON进行反序列化的操作本身不会造成任意代码执行漏洞。</li>
</ul>
<h3 id="数据流格式"><a href="#数据流格式" class="headerlink" title="数据流格式"></a>数据流格式</h3><p><code>pickle</code> 所使用的数据格式仅可用于 Python。这样做的好处是没有外部标准给该格式强加限制，比如 JSON 或 XDR（不能表示共享指针）标准；但这也意味着非 Python 程序可能无法重新读取 pickle 封存的 Python 对象。</p>
<p>默认情况下，<code>pickle</code> 格式使用相对紧凑的二进制来存储。如果需要让文件更小，可以高效地 压缩 由 pickle 封存的数据。</p>
<p><code>pickletools</code> 模块包含了相应的工具用于分析 <code>pickle</code> 生成的数据流。<code>pickletools</code> 源码中包含了对 pickle 协议使用的操作码的大量注释。</p>
<p>当前共有 6 种不同的协议可用于封存操作。 使用的协议版本越高，读取所生成 pickle 对象所需的 Python 版本就要越新。</p>
<ul>
<li>v0 版协议是原始的“人类可读”协议，并且向后兼容早期版本的 Python。</li>
<li>v1 版协议是较早的二进制格式，它也与早期版本的 Python 兼容。</li>
<li>v2 版协议是在 Python 2.3 中引入的。它为存储 new-style class 提供了更高效的机制。欲了解有关第 2 版协议带来的改进，请参阅 <a href="https://www.python.org/dev/peps/pep-0307" target="_blank" rel="noopener"><strong>PEP 307</strong></a>。</li>
<li>v3 版协议是在 Python 3.0 中引入的。 它显式地支持 <code>bytes</code> 字节对象，不能使用 Python 2.x 解封。这是 Python 3.0-3.7 的默认协议。</li>
<li>v4 版协议添加于 Python 3.4。它支持存储非常大的对象，能存储更多种类的对象，还包括一些针对数据格式的优化。它是Python 3.8使用的默认协议。有关第 4 版协议带来改进的信息，请参阅 <a href="https://www.python.org/dev/peps/pep-3154" target="_blank" rel="noopener"><strong>PEP 3154</strong></a>。</li>
<li>第 5 版协议是在 Python 3.8 中加入的。 它增加了对带外数据的支持，并可加速带内数据处理。 请参阅 <a href="https://www.python.org/dev/peps/pep-0574" target="_blank" rel="noopener"><strong>PEP 574</strong></a> 了解第 5 版协议所带来的改进的详情。</li>
</ul>
<p>注解</p>
<p>序列化是一种比持久化更底层的概念，虽然 <code>pickle</code> 读取和写入的是文件对象，但它不处理持久对象的命名问题，也不处理对持久对象的并发访问（甚至更复杂）的问题。<code>pickle</code> 模块可以将复杂对象转换为字节流，也可以将字节流转换为具有相同内部结构的对象。处理这些字节流最常见的做法是将它们写入文件，但它们也可以通过网络发送或存储在数据库中。<code>shelve</code> 模块提供了一个简单的接口，用于在 DBM 类型的数据库文件上封存和解封对象。</p>
<h3 id="模块接口"><a href="#模块接口" class="headerlink" title="模块接口"></a>模块接口</h3><p>要序列化某个包含层次结构的对象，只需调用 <code>dumps()</code> 函数即可。同样，要反序列化数据流，可以调用 <code>loads()</code> 函数。但是，如果要对序列化和反序列化加以更多的控制，可以分别创建 <code>Pickler</code> 或 <code>Unpickler</code> 对象。</p>
<p><code>pickle</code> 模块包含了以下常量：</p>
<pre><code>pickle.HIGHEST_PROTOCOL</code></pre><p>整数，可用的最高 协议版本。此值可以作为 <em>协议</em> 值传递给 <code>dump()</code> 和 <code>dumps()</code> 函数，以及 <code>Pickler</code> 的构造函数。</p>
<pre><code>pickle.DEFAULT_PROTOCOL</code></pre><p>整数，用于 pickle 数据的默认 协议版本。它可能小于 <code>HIGHEST_PROTOCOL</code>。当前默认协议是 v4，它在 Python 3.4 中首次引入，与之前的版本不兼容。</p>
<p>在 3.0 版更改: 默认协议版本是 3。</p>
<p>在 3.8 版更改: 默认协议版本是 4。</p>
<p><code>pickle</code> 模块提供了以下方法，让封存过程更加方便：</p>
<p><code>pickle.dump</code>(<em>obj</em>, <em>file</em>, <em>protocol=None</em>, <em>**,</em> fix_imports=True<em>,</em> buffer_callback=None*)</p>
<p>将对象 <em>obj</em> 封存以后的对象写入已打开的 file object <em>file</em>。它等同于 <code>Pickler(file, protocol).dump(obj)</code>。</p>
<p>参数 <em>file<em>、</em>protocol<em>、</em>fix_imports</em> 和 <em>buffer_callback</em> 的含义与它们在 <code>Pickler</code> 的构造函数中的含义相同。</p>
<p>在 3.8 版更改: 加入了 <em>buffer_callback</em> 参数。</p>
<p><code>pickle.dumps</code>(<em>obj</em>, <em>protocol=None</em>, <em>**,</em> fix_imports=True<em>,</em> buffer_callback=None*)</p>
<p>将 <em>obj</em> 封存以后的对象作为 <code>bytes</code> 类型直接返回，而不是将其写入到文件。</p>
<p>参数 <em>protocol<em>、</em>fix_imports</em> 和 <em>buffer_callback</em> 的含义与它们在 <code>Pickler</code> 的构造函数中的含义相同。</p>
<p>在 3.8 版更改: 加入了 <em>buffer_callback</em> 参数。</p>
<p><code>pickle.load</code>(<em>file</em>, <em>**,</em> fix_imports=True<em>,</em> encoding=’ASCII’<em>,</em> errors=’strict’<em>,</em> buffers=None*)</p>
<p>从已打开的 file object<em>文件</em> 中读取封存后的对象，重建其中特定对象的层次结构并返回。它相当于 <code>Unpickler(file).load()</code>。</p>
<p>Pickle 协议版本是自动检测出来的，所以不需要参数来指定协议。封存对象以外的其他字节将被忽略。</p>
<p>参数 <em>file<em>、</em>fix_imports<em>、</em>encoding<em>、</em>errors<em>、</em>strict</em> 和 <em>buffers</em> 的含义与它们在 <code>Unpickler</code> 的构造函数中的含义相同。</p>
<p>在 3.8 版更改: 加入了 <em>buffers</em> 参数。</p>
<p><code>pickle.loads</code>(<em>data</em>, <em>/</em>, <em>**,</em> fix_imports=True<em>,</em> encoding=”ASCII”<em>,</em> errors=”strict”<em>,</em> buffers=None*)</p>
<p>重建并返回一个对象的封存表示形式 <em>data</em> 的对象层级结构。 <em>data</em> 必须为 bytes-like object。</p>
<p>Pickle 协议版本是自动检测出来的，所以不需要参数来指定协议。封存对象以外的其他字节将被忽略。</p>
<p>参数 <em>file<em>、</em>fix_imports<em>、</em>encoding<em>、</em>errors<em>、</em>strict</em> 和 <em>buffers</em> 的含义与它们在 <code>Unpickler</code> 的构造函数中的含义相同。</p>
<p>在 3.8 版更改: 加入了 <em>buffers</em> 参数。</p>
<p><code>pickle</code> 模块定义了以下 3 个异常：</p>
<p><em>exception</em><code>pickle.PickleError</code></p>
<p>其他 pickle 异常的基类。它是 <code>Exception</code> 的一个子类。</p>
<p><em>exception</em><code>pickle.PicklingError</code></p>
<p>当 <code>Pickler</code> 遇到无法解封的对象时抛出此错误。它是 <code>PickleError</code> 的子类。</p>
<p><em>exception</em><code>pickle.UnpicklingError</code></p>
<p>当解封出错时抛出此异常，例如数据损坏或对象不安全。它是 <code>PickleError</code> 的子类。</p>
<p>注意，解封时可能还会抛出其他异常，包括（但不限于） AttributeError、EOFError、ImportError 和 IndexError。</p>
<p><code>pickle</code> 模块包含了 3 个类，<code>Pickler</code>、<code>Unpickler</code> 和 <code>PickleBuffer</code>：</p>
<p><em>class<em><code>pickle.Pickler</code>(</em>file</em>, <em>protocol=None</em>, <em>**,</em> fix_imports=True<em>,</em> buffer_callback=None*)</p>
<p>它接受一个二进制文件用于写入 pickle 数据流。</p>
<p>可选参数 <em>protocol</em> 是一个整数，告知 pickler 使用指定的协议，可选择的协议范围从 0 到 <code>HIGHEST_PROTOCOL</code>。如果没有指定，这一参数默认值为 <code>DEFAULT_PROTOCOL</code>。指定一个负数就相当于指定 <code>HIGHEST_PROTOCOL</code>。</p>
<p>参数 <em>file</em> 必须有一个 write() 方法，该 write() 方法要能接收字节作为其唯一参数。因此，它可以是一个打开的磁盘文件（用于写入二进制内容），也可以是一个 <code>io.BytesIO</code> 实例，也可以是满足这一接口的其他任何自定义对象。</p>
<p>如果 <em>fix_imports</em> 为 True 且 <em>protocol</em> 小于 3，pickle 将尝试将 Python 3 中的新名称映射到 Python 2 中的旧模块名称，因此 Python 2 也可以读取封存的数据流。</p>
<p>如果 <em>buffer_callback</em> 为 None（默认情况），缓冲区视图（buffer view）将会作为 pickle 流的一部分被序列化到 <em>file</em> 中。</p>
<p>如果 <em>buffer_callback</em> 不为 None，那它可以用缓冲区视图调用任意次。如果某次调用返回了 False 值（例如 None），则给定的缓冲区是 带外的，否则缓冲区是带内的（例如保存在了 pickle 流里面）。</p>
<p>如果 <em>buffer_callback</em> 不是 None 且 <em>protocol</em> 是 None 或小于 5，就会出错。</p>
<p>在 3.8 版更改: 加入了 <em>buffer_callback</em> 参数。</p>
<ul>
<li><p><code>dump</code>(<em>obj</em>)</p>
<p>将 <em>obj</em> 封存后的内容写入已打开的文件对象，该文件对象已经在构造函数中指定。</p>
</li>
<li><p><code>persistent_id</code>(<em>obj</em>)</p>
<p>默认无动作，子类继承重载时使用。</p>
<p>如果 <code>persistent_id()</code> 返回 <code>None</code>，<em>obj</em> 会被照常 pickle。如果返回其他值，<code>Pickler</code> 会将这个函数的返回值作为 <em>obj</em> 的持久化 ID（Pickler 本应得到序列化数据流并将其写入文件，若此函数有返回值，则得到此函数的返回值并写入文件）。这个持久化 ID 的解释应当定义在 <code>Unpickler.persistent_load()</code> 中（该方法定义还原对象的过程，并返回得到的对象）。注意，<code>persistent_id()</code> 的返回值本身不能拥有持久化 ID。</p>
</li>
<li><p><code>dispatch_table</code></p>
<p>Pickler 对象的 dispatch 表是 <code>copyreg.pickle()</code> 中用到的 <em>reduction 函数</em> 的注册。dispatch 表本身是一个 class 到其 reduction 函数的映射键值对。一个 reduction 函数只接受一个参数，就是其关联的 class，函数行为应当遵守 <code>__reduce__()</code> 接口规范。</p>
<p>Pickler 对象默认并没有 <code>dispatch_table</code> 属性，该对象默认使用 <code>copyreg</code> 模块中定义的全局 dispatch 表。如果要为特定 Pickler 对象自定义序列化过程，可以将 <code>dispatch_table</code> 属性设置为类字典对象（dict-like object）。另外，如果 <code>Pickler</code> 的子类设置了 <code>dispatch_table</code> 属性，则该子类的实例会使用这个表作为默认的 dispatch 表。</p>
<p>3.3 新版功能.</p>
</li>
<li><p><code>reducer_override</code>(<em>self</em>, <em>obj</em>)</p>
<p>可以在 <code>Pickler</code> 的子类中定义的特殊 reducer。此方法的优先级高于 <code>dispatch_table</code> 中的任何 reducer。它应该与 <code>__reduce__()</code> 方法遵循相同的接口，它也可以返回 <code>NotImplemented</code>，这将使用 <code>dispatch_table</code> 里注册的 reducer 来封存 <code>obj</code>。</p>
<p>3.8 新版功能.</p>
</li>
<li><p><code>fast</code></p>
<p>已弃用。设为 True 则启用快速模式。快速模式禁用了“备忘录” (memo) 的使用，即不生成多余的 PUT 操作码来加快封存过程。不应将其与自指 (self-referential) 对象一起使用，否则将导致 <code>Pickler</code> 无限递归。</p>
<p>如果需要进一步提高 pickle 的压缩率，请使用 <code>pickletools.optimize()</code>。</p>
</li>
</ul>
<p><em>class<em><code>pickle.Unpickler</code>(</em>file</em>, <em>**,</em> fix_imports=True<em>,</em> encoding=’ASCII’<em>,</em> errors=’strict’<em>,</em> buffers=None*)</p>
<p>它接受一个二进制文件用于读取 pickle 数据流。</p>
<p>Pickle 协议版本是自动检测出来的，所以不需要参数来指定协议。</p>
<p>参数 <em>file</em> 必须有三个方法，read() 方法接受一个整数参数，readinto() 方法接受一个缓冲区作为参数，readline() 方法不需要参数，这与 <code>io.BufferedIOBase</code> 里定义的接口是相同的。因此 <em>file</em> 可以是一个磁盘上用于二进制读取的文件，也可以是一个 <code>io.BytesIO</code> 实例，也可以是满足这一接口的其他任何自定义对象。</p>
<p>可选的参数是 <em>fix_imports</em>, <em>encoding</em> 和 <em>errors*，用于控制由Python 2 生成的 pickle 流的兼容性。如果 *fix_imports</em> 为 True，则 pickle 将尝试将旧的 Python 2 名称映射到 Python 3 中对应的新名称。<em>encoding</em> 和 <em>errors</em> 参数告诉 pickle 如何解码 Python 2 存储的 8 位字符串实例；这两个参数默认分别为 ‘ASCII’ 和 ‘strict’。<em>encoding</em> 参数可置为 ‘bytes’ 来将这些 8 位字符串实例读取为字节对象。读取 NumPy array 和 Python 2 存储的 <code>datetime</code>、<code>date</code> 和 <code>time</code> 实例时，请使用 <code>encoding='latin1'</code>。</p>
<p>如果 <em>buffers</em> 为 None（默认值），则反序列化所需的所有数据都必须包含在 pickle 流中。这意味着在实例化 <code>Pickler</code> 时（或调用 <code>dump()</code> 或 <code>dumps()</code> 时），参数 <em>buffer_callback</em> 为 None。</p>
<p>如果 <em>buffers</em> 不为 None，则每次 pickle 流引用 带外 缓冲区视图时，消耗的对象都应该是可迭代的启用缓冲区的对象。这样的缓冲区应该按顺序地提供给 Pickler 对象的 <em>buffer_callback</em> 方法。</p>
<p>在 3.8 版更改: 加入了 <em>buffers</em> 参数。</p>
<ul>
<li><p><code>load</code>()</p>
<p>从构造函数中指定的文件对象里读取封存好的对象，重建其中特定对象的层次结构并返回。封存对象以外的其他字节将被忽略。</p>
</li>
<li><p><code>persistent_load</code>(<em>pid</em>)</p>
<p>默认抛出 <code>UnpicklingError</code> 异常。</p>
<p>如果定义了此方法，<code>persistent_load()</code> 应当返回持久化 ID <em>pid</em> 所指定的对象。 如果遇到无效的持久化 ID，则应当引发 <code>UnpicklingError</code>。</p>
</li>
<li><p><code>find_class</code>(<em>module</em>, <em>name</em>)</p>
<p>如有必要，导入 <em>module</em> 模块并返回其中名叫 <em>name</em> 的对象，其中 <em>module</em> 和 <em>name</em> 参数都是 <code>str</code> 对象。注意，不要被这个函数的名字迷惑， <code>find_class()</code> 同样可以用来导入函数。</p>
<p>子类可以重载此方法，来控制加载对象的类型和加载对象的方式，从而尽可能降低安全风险。</p>
<p>引发一个 审计事件<code>pickle.find_class</code> 附带参数 <code>module</code>、<code>name</code>。</p>
</li>
</ul>
<p><em>class<em><code>pickle.PickleBuffer</code>(</em>buffer</em>)</p>
<p>缓冲区的包装器 (wrapper)，缓冲区中包含着可封存的数据。<em>buffer</em> 必须是一个 buffer-providing 对象，比如 bytes-like object 或多维数组。</p>
<p><code>PickleBuffer</code> 本身就可以生成缓冲区对象，因此可以将其传递给需要缓冲区生成器的其他 API，比如 <code>memoryview</code>。</p>
<p><code>PickleBuffer</code> 对象只能用 pickle 版本 5 及以上协议进行序列化。它们符合 带外序列化 的条件。</p>
<p>3.8 新版功能.</p>
<ul>
<li><p><code>raw</code>()</p>
<p>返回该缓冲区底层内存区域的 <code>memoryview</code>。 返回的对象是一维的、C 连续布局的 memoryview，格式为 <code>B</code> (无符号字节)。 如果缓冲区既不是 C 连续布局也不是 Fortran 连续布局的，则抛出 <code>BufferError</code> 异常。</p>
</li>
<li><p><code>release</code>()</p>
<p>释放由 PickleBuffer 占用的底层缓冲区。</p>
</li>
</ul>
<h3 id="可以被封存-解封的对象"><a href="#可以被封存-解封的对象" class="headerlink" title="可以被封存/解封的对象"></a>可以被封存/解封的对象</h3><p>下列类型可以被封存：</p>
<ul>
<li><code>None</code>、<code>True</code> 和 <code>False</code></li>
<li>整数、浮点数、复数</li>
<li>str、byte、bytearray</li>
<li>只包含可封存对象的集合，包括 tuple、list、set 和 dict</li>
<li>定义在模块最外层的函数（使用 <code>def</code> 定义，<code>lambda</code> 函数则不可以）</li>
<li>定义在模块最外层的内置函数</li>
<li>定义在模块最外层的类</li>
<li>某些类实例，这些类的 <code>__dict__</code> 属性值或 <code>__getstate__()</code> 函数的返回值可以被封存。</li>
</ul>
<p>尝试封存不能被封存的对象会抛出 <code>PicklingError</code> 异常，异常发生时，可能有部分字节已经被写入指定文件中。尝试封存递归层级很深的对象时，可能会超出最大递归层级限制，此时会抛出 <code>RecursionError</code> 异常，可以通过 <code>sys.setrecursionlimit()</code> 调整递归层级，不过请谨慎使用这个函数，因为可能会导致解释器崩溃。</p>
<p>注意，函数（内置函数或用户自定义函数）在被封存时，引用的是函数全名。这意味着只有函数所在的模块名，与函数名会被封存，函数体及其属性不会被封存。因此，在解封的环境中，函数所属的模块必须是可以被导入的，而且模块必须包含这个函数被封存时的名称，否则会抛出异常.</p>
<p>同样的，类也只封存名称，所以在解封环境中也有和函数相同的限制。注意，类体及其数据不会被封存，所以在下面的例子中类属性 <code>attr</code> 不会存在于解封后的环境中：</p>
<pre><code>classFoo:    attr ='A class attribute'picklestring = pickle.dumps(Foo)</code></pre><p>这些限制决定了为什么必须在一个模块的最外层定义可封存的函数和类。</p>
<p>类似的，在封存类的实例时，其类体和类数据不会跟着实例一起被封存，只有实例数据会被封存。这样设计是有目的的，在将来修复类中的错误、给类增加方法之后，仍然可以载入原来版本类实例的封存数据来还原该实例。如果你准备长期使用一个对象，可能会同时存在较多版本的类体，可以为对象添加版本号，这样就可以通过类的 <code>__setstate__()</code> 方法将老版本转换成新版本。</p>
<h3 id="封存类实例"><a href="#封存类实例" class="headerlink" title="封存类实例"></a>封存类实例</h3><p>在本节中，我们描述了可用于定义、自定义和控制如何封存和解封类实例的通用流程。</p>
<p>通常，使一个实例可被封存不需要附加任何代码。Pickle 默认会通过 Python 的内省机制获得实例的类及属性。而当实例解封时，它的 <code>__init__()</code> 方法通常 <em>不会</em> 被调用。其默认动作是：先创建一个未初始化的实例，然后还原其属性，下面的代码展示了这种行为的实现机制：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">save</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token keyword">return</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>__class__<span class="token punctuation">,</span> obj<span class="token punctuation">.</span>__dict__<span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">load</span><span class="token punctuation">(</span>cls<span class="token punctuation">,</span> attributes<span class="token punctuation">)</span><span class="token punctuation">:</span>
    obj <span class="token operator">=</span> cls<span class="token punctuation">.</span>__new__<span class="token punctuation">(</span>cls<span class="token punctuation">)</span>
    obj<span class="token punctuation">.</span>__dict__<span class="token punctuation">.</span>update<span class="token punctuation">(</span>attributes<span class="token punctuation">)</span>
<span class="token keyword">return</span> obj<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>类可以改变默认行为，只需定义以下一种或几种特殊方法：</p>
<p><code>object.__getnewargs_ex__</code>()</p>
<p>对于使用第 2 版或更高版协议的 pickle，实现了 <code>__getnewargs_ex__()</code> 方法的类可以控制在解封时传给 <code>__new__()</code> 方法的参数。本方法必须返回一对 <code>(args, kwargs)</code> 用于构建对象，其中 <em>args</em> 是表示位置参数的 tuple，而 <em>kwargs</em> 是表示命名参数的 dict。它们会在解封时传递给 <code>__new__()</code> 方法。</p>
<p>如果类的 <code>__new__()</code> 方法只接受关键字参数，则应当实现这个方法。否则，为了兼容性，更推荐实现 <code>__getnewargs__()</code> 方法。</p>
<p>在 3.6 版更改: <code>__getnewargs_ex__()</code> 现在可用于第 2 和第 3 版协议。</p>
<p><code>object.__getnewargs__</code>()</p>
<p>这个方法与上一个 <code>__getnewargs_ex__()</code> 方法类似，但仅支持位置参数。它要求返回一个 tuple 类型的 <code>args</code>，用于解封时传递给 <code>__new__()</code> 方法。</p>
<p>如果定义了 <code>__getnewargs_ex__()</code>，那么 <code>__getnewargs__()</code> 就不会被调用。</p>
<p>在 3.6 版更改: 在 Python 3.6 前，第 2、3 版协议会调用 <code>__getnewargs__()</code>，更高版本协议会调用 <code>__getnewargs_ex__()</code>。</p>
<p><code>object.__getstate__</code>()</p>
<p>类还可以进一步控制其实例的封存过程。如果类定义了 <code>__getstate__()</code>，它就会被调用，其返回的对象是被当做实例内容来封存的，否则封存的是实例的 <strong>dict</strong>。如果 <code>__getstate__()</code> 未定义，实例的 <code>__dict__</code> 会被照常封存。</p>
<p><code>object.__setstate__</code>(<em>state</em>)</p>
<p>当解封时，如果类定义了 <code>__setstate__()</code>，就会在已解封状态下调用它。此时不要求实例的 state 对象必须是 dict。没有定义此方法的话，先前封存的 state 对象必须是 dict，且该 dict 内容会在解封时赋给新实例的 <strong>dict</strong>。</p>
<p>注解</p>
<p>如果 <code>__getstate__()</code> 返回 False，那么在解封时就不会调用 <code>__setstate__()</code> 方法。</p>
<p>注解</p>
<p>在解封时，实例的某些方法例如 <code>__getattr__()</code>, <code>__getattribute__()</code> 或 <code>__setattr__()</code> 可能会被调用。 由于这些方法可能要求某些内部不变量为真值，因此该类型应当实现 <code>__new__()</code> 以建立这样的不变量，因为当解封一个实例时 <code>__init__()</code> 并不会被调用。</p>
<p>可以看出，其实 pickle 并不直接调用上面的几个函数。事实上，这几个函数是复制协议的一部分，它们实现了 <code>__reduce__()</code> 这一特殊接口。复制协议提供了统一的接口，用于在封存或复制对象的过程中取得所需数据.</p>
<p>尽管这个协议功能很强，但是直接在类中实现 <code>__reduce__()</code> 接口容易产生错误。因此，设计类时应当尽可能的使用高级接口（比如 <code>__getnewargs_ex__()</code>、<code>__getstate__()</code> 和 <code>__setstate__()</code>）。后面仍然可以看到直接实现 <code>__reduce__()</code> 接口的状况，可能别无他法，可能为了获得更好的性能，或者两者皆有之。</p>
<p><code>object.__reduce__</code>()</p>
<p>该接口当前定义如下。<code>__reduce__()</code> 方法不带任何参数，并且应返回字符串或最好返回一个元组（返回的对象通常称为“reduce 值”）。</p>
<p>如果返回字符串，该字符串会被当做一个全局变量的名称。它应该是对象相对于其模块的本地名称，pickle 模块会搜索模块命名空间来确定对象所属的模块。这种行为常在单例模式使用。</p>
<p>如果返回的是元组，则应当包含 2 到 6 个元素，可选元素可以省略或设置为 <code>None</code>。每个元素代表的意义如下：</p>
<ul>
<li><p>一个可调用对象，该对象会在创建对象的最初版本时调用。</p>
</li>
<li><p>可调用对象的参数，是一个元组。如果可调用对象不接受参数，必须提供一个空元组。</p>
</li>
<li><p>可选元素，用于表示对象的状态，将被传给前述的 <code>__setstate__()</code> 方法。 如果对象没有此方法，则这个元素必须是字典类型，并会被添加至 <code>__dict__</code> 属性中。</p>
</li>
<li><p>可选元素，一个返回连续项的迭代器（而不是序列）。这些项会被 <code>obj.append(item)</code> 逐个加入对象，或被 <code>obj.extend(list_of_items)</code> 批量加入对象。这个元素主要用于 list 的子类，也可以用于那些正确实现了 <code>append()</code> 和 <code>extend()</code> 方法的类。（具体是使用 <code>append()</code> 还是 <code>extend()</code> 取决于 pickle 协议版本以及待插入元素的项数，所以这两个方法必须同时被类支持。）</p>
</li>
<li><p>可选元素，一个返回连续键值对的迭代器（而不是序列）。这些键值对将会以 <code>obj[key] = value</code> 的方式存储于对象中。该元素主要用于 dict 子类，也可以用于那些实现了 <code>__setitem__()</code> 的类。</p>
</li>
<li><p>可选元素，一个带有 <code>(obj, state)</code> 签名的可调用对象。该可调用对象允许用户以编程方式控制特定对象的状态更新行为，而不是使用 <code>obj</code> 的静态 <code>__setstate__()</code> 方法。如果此处不是 <code>None</code>，则此可调用对象的优先级高于 <code>obj</code> 的 <code>__setstate__()</code>。</p>
<p>3.8 新版功能: 新增了元组的第 6 项，可选元素 <code>(obj, state)</code>。</p>
</li>
</ul>
<p><code>object.__reduce_ex__</code>(<em>protocol</em>)</p>
<p>作为替代选项，也可以实现 <code>__reduce_ex__()</code> 方法。 此方法的唯一不同之处在于它应接受一个整型参数用于指定协议版本。 如果定义了这个函数，则会覆盖 <code>__reduce__()</code> 的行为。 此外，<code>__reduce__()</code> 方法会自动成为扩展版方法的同义词。 这个函数主要用于为以前的 Python 版本提供向后兼容的 reduce 值。</p>
<h4 id="持久化外部对象"><a href="#持久化外部对象" class="headerlink" title="持久化外部对象"></a>持久化外部对象</h4><p>为了获取对象持久化的利益， <code>pickle</code> 模块支持引用已封存数据流之外的对象。 这样的对象是通过一个持久化 ID 来引用的，它应当是一个由字母数字类字符组成的字符串 (对于第 0 版协议) 或是一个任意对象 (用于任意新版协议)。</p>
<p><code>pickle</code> 模块不提供对持久化 ID 的解析工作，它将解析工作分配给用户定义的方法，分别是 pickler 中的 <code>persistent_id()</code> 方法和 unpickler 中的 <code>persistent_load()</code> 方法。</p>
<p>要通过持久化 ID 将外部对象封存，必须在 pickler 中实现 <code>persistent_id()</code> 方法，该方法接受需要被封存的对象作为参数，返回一个 <code>None</code> 或返回该对象的持久化 ID。如果返回 <code>None</code>，该对象会被按照默认方式封存为数据流。如果返回字符串形式的持久化 ID，则会封存这个字符串并加上一个标记，这样 unpickler 才能将其识别为持久化 ID。</p>
<p>要解封外部对象，Unpickler 必须实现 <code>persistent_load()</code> 方法，接受一个持久化 ID 对象作为参数并返回一个引用的对象。</p>
<p>下面是一个全面的例子，展示了如何使用持久化 ID 来封存外部对象。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Simple example presenting how persistent ID can be used to pickle</span>
<span class="token comment" spellcheck="true"># external objects by reference.</span>
<span class="token keyword">import</span> pickle
<span class="token keyword">import</span> sqlite3
<span class="token keyword">from</span> collections <span class="token keyword">import</span> namedtuple
<span class="token comment" spellcheck="true"># Simple class representing a record in our database.</span>
MemoRecord<span class="token operator">=</span> namedtuple<span class="token punctuation">(</span><span class="token string">"MemoRecord"</span><span class="token punctuation">,</span><span class="token string">"key, task"</span><span class="token punctuation">)</span>
classDBPickler<span class="token punctuation">(</span>pickle<span class="token punctuation">.</span>Pickler<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token keyword">def</span> <span class="token function">persistent_id</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> obj<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token comment" spellcheck="true"># Instead of pickling MemoRecord as a regular class instance, we emit a</span>
<span class="token comment" spellcheck="true"># persistent ID.</span>
<span class="token keyword">if</span> isinstance<span class="token punctuation">(</span>obj<span class="token punctuation">,</span>MemoRecord<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token comment" spellcheck="true"># Here, our persistent ID is simply a tuple, containing a tag and a</span>
<span class="token comment" spellcheck="true"># key, which refers to a specific record in the database.</span>
<span class="token keyword">return</span><span class="token punctuation">(</span><span class="token string">"MemoRecord"</span><span class="token punctuation">,</span> obj<span class="token punctuation">.</span>key<span class="token punctuation">)</span>
<span class="token keyword">else</span><span class="token punctuation">:</span>
<span class="token comment" spellcheck="true"># If obj does not have a persistent ID, return None. This means obj</span>
<span class="token comment" spellcheck="true"># needs to be pickled as usual.</span>
returnNone
classDBUnpickler<span class="token punctuation">(</span>pickle<span class="token punctuation">.</span>Unpickler<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> file<span class="token punctuation">,</span> connection<span class="token punctuation">)</span><span class="token punctuation">:</span>
super<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span>file<span class="token punctuation">)</span>
self<span class="token punctuation">.</span>connection <span class="token operator">=</span> connection
<span class="token keyword">def</span> <span class="token function">persistent_load</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> pid<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token comment" spellcheck="true"># This method is invoked whenever a persistent ID is encountered.</span>
<span class="token comment" spellcheck="true"># Here, pid is the tuple returned by DBPickler.</span>
        cursor <span class="token operator">=</span>self<span class="token punctuation">.</span>connection<span class="token punctuation">.</span>cursor<span class="token punctuation">(</span><span class="token punctuation">)</span>
        type_tag<span class="token punctuation">,</span> key_id <span class="token operator">=</span> pid
<span class="token keyword">if</span> type_tag <span class="token operator">==</span><span class="token string">"MemoRecord"</span><span class="token punctuation">:</span>
<span class="token comment" spellcheck="true"># Fetch the referenced record from the database and return it.</span>
            cursor<span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token string">"SELECT * FROM memos WHERE key=?"</span><span class="token punctuation">,</span><span class="token punctuation">(</span>str<span class="token punctuation">(</span>key_id<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            key<span class="token punctuation">,</span> task <span class="token operator">=</span> cursor<span class="token punctuation">.</span>fetchone<span class="token punctuation">(</span><span class="token punctuation">)</span>
returnMemoRecord<span class="token punctuation">(</span>key<span class="token punctuation">,</span> task<span class="token punctuation">)</span>
<span class="token keyword">else</span><span class="token punctuation">:</span>
<span class="token comment" spellcheck="true"># Always raises an error if you cannot return the correct object.</span>
<span class="token comment" spellcheck="true"># Otherwise, the unpickler will think None is the object referenced</span>
<span class="token comment" spellcheck="true"># by the persistent ID.</span>
<span class="token keyword">raise</span> pickle<span class="token punctuation">.</span>UnpicklingError<span class="token punctuation">(</span><span class="token string">"unsupported persistent object"</span><span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token keyword">import</span> io
<span class="token keyword">import</span> pprint
<span class="token comment" spellcheck="true"># Initialize and populate our database.</span>
    conn <span class="token operator">=</span> sqlite3<span class="token punctuation">.</span>connect<span class="token punctuation">(</span><span class="token string">":memory:"</span><span class="token punctuation">)</span>
    cursor <span class="token operator">=</span> conn<span class="token punctuation">.</span>cursor<span class="token punctuation">(</span><span class="token punctuation">)</span>
    cursor<span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token string">"CREATE TABLE memos(key INTEGER PRIMARY KEY, task TEXT)"</span><span class="token punctuation">)</span>
    tasks <span class="token operator">=</span><span class="token punctuation">(</span>
<span class="token string">'give food to fish'</span><span class="token punctuation">,</span>
<span class="token string">'prepare group meeting'</span><span class="token punctuation">,</span>
<span class="token string">'fight with a zebra'</span><span class="token punctuation">,</span>
<span class="token punctuation">)</span>
<span class="token keyword">for</span> task <span class="token keyword">in</span> tasks<span class="token punctuation">:</span>
        cursor<span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token string">"INSERT INTO memos VALUES(NULL, ?)"</span><span class="token punctuation">,</span><span class="token punctuation">(</span>task<span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment" spellcheck="true"># Fetch the records to be pickled.</span>
    cursor<span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token string">"SELECT * FROM memos"</span><span class="token punctuation">)</span>
    memos <span class="token operator">=</span><span class="token punctuation">[</span>MemoRecord<span class="token punctuation">(</span>key<span class="token punctuation">,</span> task<span class="token punctuation">)</span><span class="token keyword">for</span> key<span class="token punctuation">,</span> task <span class="token keyword">in</span> cursor<span class="token punctuation">]</span>
<span class="token comment" spellcheck="true"># Save the records using our custom DBPickler.</span>
    file <span class="token operator">=</span> io<span class="token punctuation">.</span>BytesIO<span class="token punctuation">(</span><span class="token punctuation">)</span>
DBPickler<span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token punctuation">.</span>dump<span class="token punctuation">(</span>memos<span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Pickled records:"</span><span class="token punctuation">)</span>
    pprint<span class="token punctuation">.</span>pprint<span class="token punctuation">(</span>memos<span class="token punctuation">)</span>
<span class="token comment" spellcheck="true"># Update a record, just for good measure.</span>
    cursor<span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token string">"UPDATE memos SET task='learn italian' WHERE key=1"</span><span class="token punctuation">)</span>
<span class="token comment" spellcheck="true"># Load the records from the pickle data stream.</span>
    file<span class="token punctuation">.</span>seek<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
    memos <span class="token operator">=</span>DBUnpickler<span class="token punctuation">(</span>file<span class="token punctuation">,</span> conn<span class="token punctuation">)</span><span class="token punctuation">.</span>load<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Unpickled records:"</span><span class="token punctuation">)</span>
    pprint<span class="token punctuation">.</span>pprint<span class="token punctuation">(</span>memos<span class="token punctuation">)</span>
<span class="token keyword">if</span> __name__ <span class="token operator">==</span><span class="token string">'__main__'</span><span class="token punctuation">:</span>
    main<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="Dispatch-表"><a href="#Dispatch-表" class="headerlink" title="Dispatch 表"></a>Dispatch 表</h4><p>如果想对某些类进行自定义封存，而又不想在类中增加用于封存的代码，就可以创建带有特殊 dispatch 表的 pickler。</p>
<p>在 <code>copyreg</code> 模块的 <code>copyreg.dispatch_table</code> 中定义了全局 dispatch 表。因此，可以使用 <code>copyreg.dispatch_table</code> 修改后的副本作为自有 dispatch 表。</p>
<p>例如</p>
<pre class="line-numbers language-python"><code class="language-python">f <span class="token operator">=</span> io<span class="token punctuation">.</span>BytesIO<span class="token punctuation">(</span><span class="token punctuation">)</span>
p <span class="token operator">=</span> pickle<span class="token punctuation">.</span>Pickler<span class="token punctuation">(</span>f<span class="token punctuation">)</span>
p<span class="token punctuation">.</span>dispatch_table <span class="token operator">=</span> copyreg<span class="token punctuation">.</span>dispatch_table<span class="token punctuation">.</span>copy<span class="token punctuation">(</span><span class="token punctuation">)</span>
p<span class="token punctuation">.</span>dispatch_table<span class="token punctuation">[</span>SomeClass<span class="token punctuation">]</span><span class="token operator">=</span> reduce_SomeClass<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>创建了一个带有自有 dispatch 表的 <code>pickle.Pickler</code> 实例，它可以对 <code>SomeClass</code> 类进行特殊处理。另外，下列代码</p>
<pre class="line-numbers language-python"><code class="language-python">classMyPickler<span class="token punctuation">(</span>pickle<span class="token punctuation">.</span>Pickler<span class="token punctuation">)</span><span class="token punctuation">:</span>
    dispatch_table <span class="token operator">=</span> copyreg<span class="token punctuation">.</span>dispatch_table<span class="token punctuation">.</span>copy<span class="token punctuation">(</span><span class="token punctuation">)</span>
    dispatch_table<span class="token punctuation">[</span>SomeClass<span class="token punctuation">]</span><span class="token operator">=</span> reduce_SomeClass
f <span class="token operator">=</span> io<span class="token punctuation">.</span>BytesIO<span class="token punctuation">(</span><span class="token punctuation">)</span>
p <span class="token operator">=</span>MyPickler<span class="token punctuation">(</span>f<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>完成了相同的操作，但所有 <code>MyPickler</code> 的实例都会共用同一份 dispatch 表。使用 <code>copyreg</code> 模块实现的等效代码是</p>
<pre class="line-numbers language-python"><code class="language-python">copyreg<span class="token punctuation">.</span>pickle<span class="token punctuation">(</span>SomeClass<span class="token punctuation">,</span> reduce_SomeClass<span class="token punctuation">)</span>
f <span class="token operator">=</span> io<span class="token punctuation">.</span>BytesIO<span class="token punctuation">(</span><span class="token punctuation">)</span>
p <span class="token operator">=</span> pickle<span class="token punctuation">.</span>Pickler<span class="token punctuation">(</span>f<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h4 id="处理有状态的对象"><a href="#处理有状态的对象" class="headerlink" title="处理有状态的对象"></a>处理有状态的对象</h4><p>下面的示例展示了如何修改类在封存时的行为。其中 <code>TextReader</code> 类打开了一个文本文件，每次调用其 <code>readline()</code> 方法则返回行号和该行的字符。 在封存这个 <code>TextReader</code> 的实例时，<em>除了</em> 文件对象，其他属性都会被保存。 当解封实例时，需要重新打开文件，然后从上次的位置开始继续读取。实现这些功能需要实现 <code>__setstate__()</code> 和 <code>__getstate__()</code> 方法。</p>
<pre class="line-numbers language-python"><code class="language-python">classTextReader<span class="token punctuation">:</span>
<span class="token triple-quoted-string string">"""Print and number lines in a text file."""</span>
<span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> filename<span class="token punctuation">)</span><span class="token punctuation">:</span>
self<span class="token punctuation">.</span>filename <span class="token operator">=</span> filename
self<span class="token punctuation">.</span>file <span class="token operator">=</span> open<span class="token punctuation">(</span>filename<span class="token punctuation">)</span>
self<span class="token punctuation">.</span>lineno <span class="token operator">=</span><span class="token number">0</span>
<span class="token keyword">def</span> <span class="token function">readline</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
self<span class="token punctuation">.</span>lineno <span class="token operator">+=</span><span class="token number">1</span>
        line <span class="token operator">=</span>self<span class="token punctuation">.</span>file<span class="token punctuation">.</span>readline<span class="token punctuation">(</span><span class="token punctuation">)</span>
ifnot line<span class="token punctuation">:</span>
returnNone
<span class="token keyword">if</span> line<span class="token punctuation">.</span>endswith<span class="token punctuation">(</span><span class="token string">'\n'</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            line <span class="token operator">=</span> line<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>
<span class="token keyword">return</span><span class="token string">"%i: %s"</span><span class="token operator">%</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>lineno<span class="token punctuation">,</span> line<span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">__getstate__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token comment" spellcheck="true"># Copy the object's state from self.__dict__ which contains</span>
<span class="token comment" spellcheck="true"># all our instance attributes. Always use the dict.copy()</span>
<span class="token comment" spellcheck="true"># method to avoid modifying the original state.</span>
        state <span class="token operator">=</span>self<span class="token punctuation">.</span>__dict__<span class="token punctuation">.</span>copy<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment" spellcheck="true"># Remove the unpicklable entries.</span>
<span class="token keyword">del</span> state<span class="token punctuation">[</span><span class="token string">'file'</span><span class="token punctuation">]</span>
<span class="token keyword">return</span> state
<span class="token keyword">def</span> <span class="token function">__setstate__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> state<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token comment" spellcheck="true"># Restore instance attributes (i.e., filename and lineno).</span>
self<span class="token punctuation">.</span>__dict__<span class="token punctuation">.</span>update<span class="token punctuation">(</span>state<span class="token punctuation">)</span>
<span class="token comment" spellcheck="true"># Restore the previously opened file's state. To do so, we need to</span>
<span class="token comment" spellcheck="true"># reopen it and read from it until the line count is restored.</span>
        file <span class="token operator">=</span> open<span class="token punctuation">(</span>self<span class="token punctuation">.</span>filename<span class="token punctuation">)</span>
<span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>self<span class="token punctuation">.</span>lineno<span class="token punctuation">)</span><span class="token punctuation">:</span>
            file<span class="token punctuation">.</span>readline<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment" spellcheck="true"># Finally, save the file.</span>
self<span class="token punctuation">.</span>file <span class="token operator">=</span> file<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>使用方法如下所示：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> reader <span class="token operator">=</span>TextReader<span class="token punctuation">(</span><span class="token string">"hello.txt"</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> reader<span class="token punctuation">.</span>readline<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token string">'1: Hello world!'</span>
<span class="token operator">>></span><span class="token operator">></span> reader<span class="token punctuation">.</span>readline<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token string">'2: I am line number two.'</span>
<span class="token operator">>></span><span class="token operator">></span> new_reader <span class="token operator">=</span> pickle<span class="token punctuation">.</span>loads<span class="token punctuation">(</span>pickle<span class="token punctuation">.</span>dumps<span class="token punctuation">(</span>reader<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> new_reader<span class="token punctuation">.</span>readline<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token string">'3: Goodbye!'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="类型，函数和其他对象的自定义归约"><a href="#类型，函数和其他对象的自定义归约" class="headerlink" title="类型，函数和其他对象的自定义归约"></a>类型，函数和其他对象的自定义归约</h3><p>3.8 新版功能.</p>
<p>有时，<code>dispatch_table</code> 可能不够灵活。 特别是当我们想要基于对象类型以外的其他规则来对封存进行定制，或是当我们想要对函数和类的封存进行定制的时候。</p>
<p>对于那些情况，可能要基于 <code>Pickler</code> 类进行子类化并实现 <code>reducer_override()</code> 方法。 此方法可返回任意的归约元组 (参见 <code>__reduce__()</code>)。 它也可以选择返回 <code>NotImplemented</code> 来回退到传统行为。</p>
<p>如果同时定义了 <code>dispatch_table</code> 和 <code>reducer_override()</code>，则 <code>reducer_override()</code> 方法具有优先权。</p>
<p>注解</p>
<p>出于性能理由，可能不会为以下对象调用 <code>reducer_override()</code>: <code>None</code>, <code>True</code>, <code>False</code>, 以及 <code>int</code>, <code>float</code>, <code>bytes</code>, <code>str</code>, <code>dict</code>, <code>set</code>, <code>frozenset</code>, <code>list</code> 和 <code>tuple</code> 的具体实例。</p>
<p>以下是一个简单的例子，其中我们允许封存并重新构建一个给定的类:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> io
<span class="token keyword">import</span> pickle
classMyClass<span class="token punctuation">:</span>
    my_attribute <span class="token operator">=</span><span class="token number">1</span>
classMyPickler<span class="token punctuation">(</span>pickle<span class="token punctuation">.</span>Pickler<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token keyword">def</span> <span class="token function">reducer_override</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> obj<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token triple-quoted-string string">"""Custom reducer for MyClass."""</span>
<span class="token keyword">if</span> getattr<span class="token punctuation">(</span>obj<span class="token punctuation">,</span><span class="token string">"__name__"</span><span class="token punctuation">,</span>None<span class="token punctuation">)</span><span class="token operator">==</span><span class="token string">"MyClass"</span><span class="token punctuation">:</span>
<span class="token keyword">return</span> type<span class="token punctuation">,</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>__name__<span class="token punctuation">,</span> obj<span class="token punctuation">.</span>__bases__<span class="token punctuation">,</span>
<span class="token punctuation">{</span><span class="token string">'my_attribute'</span><span class="token punctuation">:</span> obj<span class="token punctuation">.</span>my_attribute<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token keyword">else</span><span class="token punctuation">:</span>
<span class="token comment" spellcheck="true"># For any other object, fallback to usual reduction</span>
returnNotImplemented
f <span class="token operator">=</span> io<span class="token punctuation">.</span>BytesIO<span class="token punctuation">(</span><span class="token punctuation">)</span>
p <span class="token operator">=</span>MyPickler<span class="token punctuation">(</span>f<span class="token punctuation">)</span>
p<span class="token punctuation">.</span>dump<span class="token punctuation">(</span>MyClass<span class="token punctuation">)</span>
delMyClass
unpickled_class <span class="token operator">=</span> pickle<span class="token punctuation">.</span>loads<span class="token punctuation">(</span>f<span class="token punctuation">.</span>getvalue<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">assert</span> isinstance<span class="token punctuation">(</span>unpickled_class<span class="token punctuation">,</span> type<span class="token punctuation">)</span>
<span class="token keyword">assert</span> unpickled_class<span class="token punctuation">.</span>__name__ <span class="token operator">==</span><span class="token string">"MyClass"</span>
<span class="token keyword">assert</span> unpickled_class<span class="token punctuation">.</span>my_attribute <span class="token operator">==</span><span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="外部缓冲区"><a href="#外部缓冲区" class="headerlink" title="外部缓冲区"></a>外部缓冲区</h3><p>3.8 新版功能.</p>
<p>在某些场景中，<code>pickle</code> 模块会被用来传输海量的数据。 因此，最小化内存复制次数以保证性能和节省资源是很重要的。 但是 <code>pickle</code> 模块的正常运作会将图类对象结构转换为字节序列流，因此在本质上就要从封存流中来回复制数据。</p>
<p>如果 <em>provider</em> (待传输对象类型的实现) 和 <em>consumer</em> (通信系统的实现) 都支持 pickle 第 5 版或更高版本所提供的外部传输功能，则此约束可以被撤销。</p>
<h4 id="提供方-API"><a href="#提供方-API" class="headerlink" title="提供方 API"></a>提供方 API</h4><p>大的待封存数据对象必须实现协议 5 及以上版本专属的 <code>__reduce_ex__()</code> 方法，该方法将为任意大的数据返回一个 <code>PickleBuffer</code> 实例（而不是 <code>bytes</code> 对象等）。</p>
<p><code>PickleBuffer</code> 对象会 <em>表明</em> 底层缓冲区可被用于外部数据传输。 那些对象仍将保持与 <code>pickle</code> 模块的正常用法兼容。 但是，使用方也可以选择告知 <code>pickle</code> 它们将自行处理那些缓冲区。</p>
<h4 id="使用方-API"><a href="#使用方-API" class="headerlink" title="使用方 API"></a>使用方 API</h4><p>当序列化一个对象图时，通信系统可以启用对所生成 <code>PickleBuffer</code> 对象的定制处理。</p>
<p>发送端需要传递 <em>buffer_callback</em> 参数到 <code>Pickler</code> (或是到 <code>dump()</code> 或 <code>dumps()</code> 函数)，该回调函数将在封存对象图时附带每个所生成的 <code>PickleBuffer</code> 被调用。 由 <em>buffer_callback</em> 所累积的缓冲区的数据将不会被拷贝到 pickle 流，而是仅插入一个简单的标记。</p>
<p>接收端需要传递 <em>buffers</em> 参数到 <code>Unpickler</code> (或是到 <code>load()</code> 或 <code>loads()</code> 函数)，其值是一个由缓冲区组成的可迭代对象，它会被传递给 <em>buffer_callback*。 该可迭代对象应当按其被传递给 *buffer_callback</em> 时的顺序产生缓冲区。 这些缓冲区将提供对象重构造器所期望的数据，对这些数据的封存产生了原本的 <code>PickleBuffer</code> 对象。</p>
<p>在发送端和接受端之间，通信系统可以自由地实现它自己用于外部缓冲区的传输机制。 潜在的优化包括使用共享内存或基于特定数据类型的压缩等。</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>下面是一个小例子，在其中我们实现了一个 <code>bytearray</code> 的子类，能够用于外部缓冲区封存:</p>
<pre class="line-numbers language-python"><code class="language-python">classZeroCopyByteArray<span class="token punctuation">(</span>bytearray<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token keyword">def</span> <span class="token function">__reduce_ex__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> protocol<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token keyword">if</span> protocol <span class="token operator">>=</span><span class="token number">5</span><span class="token punctuation">:</span>
<span class="token keyword">return</span> type<span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">.</span>_reconstruct<span class="token punctuation">,</span><span class="token punctuation">(</span>PickleBuffer<span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">,</span>None
<span class="token keyword">else</span><span class="token punctuation">:</span>
<span class="token comment" spellcheck="true"># PickleBuffer is forbidden with pickle protocols &lt;= 4.</span>
<span class="token keyword">return</span> type<span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">.</span>_reconstruct<span class="token punctuation">,</span><span class="token punctuation">(</span>bytearray<span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">)</span>
@classmethod
<span class="token keyword">def</span> <span class="token function">_reconstruct</span><span class="token punctuation">(</span>cls<span class="token punctuation">,</span> obj<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token keyword">with</span> memoryview<span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token keyword">as</span> m<span class="token punctuation">:</span>
<span class="token comment" spellcheck="true"># Get a handle over the original buffer object</span>
            obj <span class="token operator">=</span> m<span class="token punctuation">.</span>obj
<span class="token keyword">if</span> type<span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token keyword">is</span> cls<span class="token punctuation">:</span>
<span class="token comment" spellcheck="true"># Original buffer object is a ZeroCopyByteArray, return it</span>
<span class="token comment" spellcheck="true"># as-is.</span>
<span class="token keyword">return</span> obj
<span class="token keyword">else</span><span class="token punctuation">:</span>
<span class="token keyword">return</span> cls<span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>重构造器 (<code>_reconstruct</code> 类方法) 会在缓冲区的提供对象具有正确类型时返回该对象。 在此小示例中这是模拟零拷贝行为的便捷方式。</p>
<p>在使用方，我们可以按通常方式封存那些对象，它们在反序列化时将提供原始对象的一个副本:</p>
<pre class="line-numbers language-python"><code class="language-python">b <span class="token operator">=</span>ZeroCopyByteArray<span class="token punctuation">(</span>b<span class="token string">"abc"</span><span class="token punctuation">)</span>
data <span class="token operator">=</span> pickle<span class="token punctuation">.</span>dumps<span class="token punctuation">(</span>b<span class="token punctuation">,</span> protocol<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">)</span>
new_b <span class="token operator">=</span> pickle<span class="token punctuation">.</span>loads<span class="token punctuation">(</span>data<span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>b <span class="token operator">==</span> new_b<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># True</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>b <span class="token keyword">is</span> new_b<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># False: a copy was made</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>但是如果我们传入 <em>buffer_callback</em> 然后在反序列化时给回累积的缓冲区，我们就能够取回原始对象:</p>
<pre class="line-numbers language-python"><code class="language-python">b <span class="token operator">=</span>ZeroCopyByteArray<span class="token punctuation">(</span>b<span class="token string">"abc"</span><span class="token punctuation">)</span>
buffers <span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>
data <span class="token operator">=</span> pickle<span class="token punctuation">.</span>dumps<span class="token punctuation">(</span>b<span class="token punctuation">,</span> protocol<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">,</span> buffer_callback<span class="token operator">=</span>buffers<span class="token punctuation">.</span>append<span class="token punctuation">)</span>
new_b <span class="token operator">=</span> pickle<span class="token punctuation">.</span>loads<span class="token punctuation">(</span>data<span class="token punctuation">,</span> buffers<span class="token operator">=</span>buffers<span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>b <span class="token operator">==</span> new_b<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># True</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>b <span class="token keyword">is</span> new_b<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># True: no copy was made</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这个例子受限于 <code>bytearray</code> 会自行分配内存这一事实：你无法基于另一个对象的内存创建 <code>bytearray</code> 的实例。 但是，第三方数据类型例如 NumPy 数组则没有这种限制，允许在单独进程或系统间传输时使用零拷贝的封存（或是尽可能少地拷贝） 。</p>
<p>参见</p>
<p><a href="https://www.python.org/dev/peps/pep-0574" target="_blank" rel="noopener"><strong>PEP 574</strong></a> — 带有外部数据缓冲区的 pickle 协议 5</p>
<h3 id="限制全局变量"><a href="#限制全局变量" class="headerlink" title="限制全局变量"></a>限制全局变量</h3><p>默认情况下，解封将会导入在 pickle 数据中找到的任何类或函数。 对于许多应用来说，此行为是不可接受的，因为它会允许解封器导入并发起调用任意代码。 只须考虑当这个手工构建的 pickle 数据流被加载时会做什么:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span><span class="token keyword">import</span> pickle
<span class="token operator">>></span><span class="token operator">></span> pickle<span class="token punctuation">.</span>loads<span class="token punctuation">(</span>b<span class="token string">"cos\nsystem\n(S'echo hello world'\ntR."</span><span class="token punctuation">)</span>
hello world
<span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>在这个例子里，解封器导入 <code>os.system()</code> 函数然后应用字符串参数 “echo hello world”。 虽然这个例子不具攻击性，但是不难想象别人能够通过此方式对你的系统造成损害。</p>
<p>出于这样的理由，你可能会希望通过定制 <code>Unpickler.find_class()</code> 来控制要解封的对象。 与其名称所提示的不同，<code>Unpickler.find_class()</code> 会在执行对任何全局对象（例如一个类或一个函数）的请求时被调用。 因此可以完全禁止全局对象或是将它们限制在一个安全的子集中。</p>
<p>下面的例子是一个解封器，它只允许某一些安全的来自 <code>builtins</code> 模块的类被加载:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> builtins
<span class="token keyword">import</span> io
<span class="token keyword">import</span> pickle
safe_builtins <span class="token operator">=</span><span class="token punctuation">{</span>
<span class="token string">'range'</span><span class="token punctuation">,</span>
<span class="token string">'complex'</span><span class="token punctuation">,</span>
<span class="token string">'set'</span><span class="token punctuation">,</span>
<span class="token string">'frozenset'</span><span class="token punctuation">,</span>
<span class="token string">'slice'</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
classRestrictedUnpickler<span class="token punctuation">(</span>pickle<span class="token punctuation">.</span>Unpickler<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token keyword">def</span> <span class="token function">find_class</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>module<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token comment" spellcheck="true"># Only allow safe classes from builtins.</span>
ifmodule<span class="token operator">==</span><span class="token string">"builtins"</span><span class="token operator">and</span> name <span class="token keyword">in</span> safe_builtins<span class="token punctuation">:</span>
<span class="token keyword">return</span> getattr<span class="token punctuation">(</span>builtins<span class="token punctuation">,</span> name<span class="token punctuation">)</span>
<span class="token comment" spellcheck="true"># Forbid everything else.</span>
<span class="token keyword">raise</span> pickle<span class="token punctuation">.</span>UnpicklingError<span class="token punctuation">(</span><span class="token string">"global '%s.%s' is forbidden"</span><span class="token operator">%</span>
<span class="token punctuation">(</span>module<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">restricted_loads</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token triple-quoted-string string">"""Helper function analogous to pickle.loads()."""</span>
returnRestrictedUnpickler<span class="token punctuation">(</span>io<span class="token punctuation">.</span>BytesIO<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>load<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们这个解封器的一个示例用法所达成的目标:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> restricted_loads<span class="token punctuation">(</span>pickle<span class="token punctuation">.</span>dumps<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span> range<span class="token punctuation">(</span><span class="token number">15</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span> range<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">15</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> restricted_loads<span class="token punctuation">(</span>b<span class="token string">"cos\nsystem\n(S'echo hello world'\ntR."</span><span class="token punctuation">)</span>
Traceback<span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
pickle<span class="token punctuation">.</span>UnpicklingError<span class="token punctuation">:</span><span class="token keyword">global</span><span class="token string">'os.system'</span><span class="token keyword">is</span> forbidden
<span class="token operator">>></span><span class="token operator">></span> restricted_loads<span class="token punctuation">(</span>b<span class="token string">'cbuiltins\neval\n'</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                  b<span class="token string">'(S\'getattr(__import__("os"), "system")'</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                  b<span class="token string">'("echo hello world")\'\ntR.'</span><span class="token punctuation">)</span>
Traceback<span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
pickle<span class="token punctuation">.</span>UnpicklingError<span class="token punctuation">:</span><span class="token keyword">global</span><span class="token string">'builtins.eval'</span><span class="token keyword">is</span> forbidden<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>正如我们这个例子所显示的，对于允许解封的对象你必须要保持谨慎。 因此如果要保证安全，你可以考虑其他选择例如 <code>xmlrpc.client</code> 中的编组 API 或是第三方解决方案。</p>
<h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>较新版本的 pickle 协议（第 2 版或更高）具有针对某些常见特性和内置类型的高效二进制编码格式。 此外，<code>pickle</code> 模块还拥有一个以 C 编写的透明优化器。</p>
<h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h3><p>对于最简单的代码，请使用 <code>dump()</code> 和 <code>load()</code> 函数。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> pickle
<span class="token comment" spellcheck="true"># An arbitrary collection of objects supported by pickle.</span>
data <span class="token operator">=</span><span class="token punctuation">{</span>
<span class="token string">'a'</span><span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2.0</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token operator">+</span><span class="token number">6j</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token string">'b'</span><span class="token punctuation">:</span><span class="token punctuation">(</span><span class="token string">"character string"</span><span class="token punctuation">,</span> b<span class="token string">"byte string"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token string">'c'</span><span class="token punctuation">:</span><span class="token punctuation">{</span>None<span class="token punctuation">,</span><span class="token boolean">True</span><span class="token punctuation">,</span><span class="token boolean">False</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">with</span> open<span class="token punctuation">(</span><span class="token string">'data.pickle'</span><span class="token punctuation">,</span><span class="token string">'wb'</span><span class="token punctuation">)</span><span class="token keyword">as</span> f<span class="token punctuation">:</span>
<span class="token comment" spellcheck="true"># Pickle the 'data' dictionary using the highest protocol available.</span>
    pickle<span class="token punctuation">.</span>dump<span class="token punctuation">(</span>data<span class="token punctuation">,</span> f<span class="token punctuation">,</span> pickle<span class="token punctuation">.</span>HIGHEST_PROTOCOL<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>以下示例读取之前封存的数据。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> pickle
<span class="token keyword">with</span> open<span class="token punctuation">(</span><span class="token string">'data.pickle'</span><span class="token punctuation">,</span><span class="token string">'rb'</span><span class="token punctuation">)</span><span class="token keyword">as</span> f<span class="token punctuation">:</span>
<span class="token comment" spellcheck="true"># The protocol version used is detected automatically, so we do not</span>
<span class="token comment" spellcheck="true"># have to specify it.</span>
    data <span class="token operator">=</span> pickle<span class="token punctuation">.</span>load<span class="token punctuation">(</span>f<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="copyreg-—-注册配合-pickle-模块使用的函数"><a href="#copyreg-—-注册配合-pickle-模块使用的函数" class="headerlink" title="copyreg —- 注册配合 pickle 模块使用的函数"></a><code>copyreg</code> —- 注册配合 <code>pickle</code> 模块使用的函数</h2><p><strong>源代码:</strong> <a href="https://github.com/python/cpython/tree/3.10/Lib/copyreg.py" target="_blank" rel="noopener">Lib/copyreg.py</a></p>
<hr>
<p><code>copyreg</code> 模块提供了可在封存特定对象时使用的一种定义函数方式。 <code>pickle</code> 和 <code>copy</code> 模块会在封存/拷贝特定对象时使用这些函数。 此模块提供了非类对象构造器的相关配置信息。 这样的构造器可以是工厂函数或类实例。</p>
<p><code>copyreg.constructor</code>(<em>object</em>)</p>
<p>将 <em>object</em> 声明为一个有效的构造器。 如果 <em>object</em> 是不可调用的（因而不是一个有效的构造器）则会引发 <code>TypeError</code>。</p>
<p><code>copyreg.pickle</code>(<em>type</em>, <em>function</em>, <em>constructor=None</em>)</p>
<p>声明该 <em>function</em> 应当被用作 <em>type</em> 类型对象的“归约函数”。 <em>function</em> 应当返回字符串或包含两到三个元素的元组。</p>
<p>如果提供了可选的 <em>constructor</em> 形参，它应当是一个可用来重建相应对象的可调用对象，在调用该对象时应传入由 <em>function</em> 所返回的参数元组。 如果 <em>object</em> 是一个类或 <em>constructor</em> 是不可调用的则将引发 <code>TypeError</code>。</p>
<p>请查看 <code>pickle</code> 模块了解 <em>function</em> 和 <em>constructor</em> 所要求的接口的详情。 请注意一个 pickler 对象或 <code>pickle.Pickler</code> 的子类的 <code>dispatch_table</code> 属性也可以被用来声明归约函数。</p>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><p>以下示例将会显示如何注册一个封存函数，以及如何来使用它：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> copyreg<span class="token punctuation">,</span> copy<span class="token punctuation">,</span> pickle
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">class</span> <span class="token class-name">C</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         self<span class="token punctuation">.</span>a <span class="token operator">=</span> a
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">def</span> <span class="token function">pickle_c</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"pickling a C instance..."</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">return</span> C<span class="token punctuation">,</span> <span class="token punctuation">(</span>c<span class="token punctuation">.</span>a<span class="token punctuation">,</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> copyreg<span class="token punctuation">.</span>pickle<span class="token punctuation">(</span>C<span class="token punctuation">,</span> pickle_c<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> c <span class="token operator">=</span> C<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> d <span class="token operator">=</span> copy<span class="token punctuation">.</span>copy<span class="token punctuation">(</span>c<span class="token punctuation">)</span>  
pickling a C instance<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> p <span class="token operator">=</span> pickle<span class="token punctuation">.</span>dumps<span class="token punctuation">(</span>c<span class="token punctuation">)</span>  
pickling a C instance<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="shelve-—-Python-对象持久化"><a href="#shelve-—-Python-对象持久化" class="headerlink" title="shelve —- Python 对象持久化"></a><code>shelve</code> —- Python 对象持久化</h2><p><strong>源代码:</strong> <a href="https://github.com/python/cpython/tree/3.10/Lib/shelve.py" target="_blank" rel="noopener">Lib/shelve.py</a></p>
<hr>
<p>“Shelf” 是一种持久化的类似字典的对象。 与 “dbm” 数据库的区别在于 Shelf 中的值（不是键！）实际上可以为任意 Python 对象 —- 即 <code>pickle</code> 模块能够处理的任何东西。 这包括大部分类实例、递归数据类型，以及包含大量共享子对象的对象。 键则为普通的字符串。</p>
<p><code>shelve.open</code>(<em>filename</em>, <em>flag=’c’</em>, <em>protocol=None</em>, <em>writeback=False</em>)</p>
<p>打开一个持久化字典。 filename 指定下层数据库的基准文件名。 作为附带效果，会为 filename 添加一个扩展名并且可能创建更多的文件。 默认情况下，下层数据库会以读写模式打开。 可选的 <em>flag</em> 形参具有与 <code>dbm.open()</code> <em>flag</em> 形参相同的含义。</p>
<p>在默认情况下，会使用以 <code>pickle.DEFAULT_PROTOCOL</code> 创建的 pickle 来序列化值。 pickle 协议的版本可通过 <em>protocol</em> 形参来指定。</p>
<p>由于 Python 语义的限制，Shelf 对象无法确定一个可变的持久化字典条目在何时被修改。 默认情况下 <em>只有</em> 在被修改对象再赋值给 shelf 时才会写入该对象。 如果可选的 <em>writeback</em> 形参设为 <code>True</code>，则所有被访问的条目都将在内存中被缓存，并会在 <code>sync()</code> 和 <code>close()</code> 时被写入；这可以使得对持久化字典中可变条目的修改更方便，但是如果访问的条目很多，这会消耗大量内存作为缓存，并会使得关闭操作变得非常缓慢，因为所有被访问的条目都需要写回到字典（无法确定被访问的条目中哪个是可变的，也无法确定哪个被实际修改了）。</p>
<p>在 3.10 版更改: <code>pickle.DEFAULT_PROTOCOL</code> 现在会被用作默认的 pickle 协议。</p>
<p>注解</p>
<p>请不要依赖于 Shelf 的自动关闭功能；当你不再需要时应当总是显式地调用 <code>close()</code>，或者使用 <code>shelve.open()</code> 作为上下文管理器:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">with</span> shelve<span class="token punctuation">.</span>open<span class="token punctuation">(</span><span class="token string">'spam'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> db<span class="token punctuation">:</span>
    db<span class="token punctuation">[</span><span class="token string">'eggs'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'eggs'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>警告</p>
<p>由于 <code>shelve</code> 模块需要 <code>pickle</code> 的支持，因此从不可靠的来源载入 shelf 是不安全的。 与 pickle 一样，载入 Shelf 时可以执行任意代码。</p>
<p>Shelf 对象支持字典所支持的大多数方法和运算（除了拷贝、构造器以及 <code>|</code> 和 <code>|=</code> 运算符）。 这样就能方便地将基于字典的脚本转换为要求持久化存储的脚本。</p>
<p>额外支持的两个方法：</p>
<p><code>Shelf.sync</code>()</p>
<p>如果 Shelf 打开时将 <em>writeback</em> 设为 <code>True</code> 则写回缓存中的所有条目。 如果可行还会清空缓存并将持久化字典同步到磁盘。 此方法会在使用 <code>close()</code> 关闭 Shelf 时自动被调用。</p>
<p><code>Shelf.close</code>()</p>
<p>同步并关闭持久化 <em>dict</em> 对象。 对已关闭 Shelf 的操作将失败并引发 <code>ValueError</code>。</p>
<h3 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h3><ul>
<li>可选择使用哪种数据库包 (例如 <code>dbm.ndbm</code> 或 <code>dbm.gnu</code>) 取决于支持哪种接口。 因此使用 <code>dbm</code> 直接打开数据库是不安全的。 如果使用了 <code>dbm</code>，数据库同样会（不幸地）受限于它 —- 这意味着存储在数据库中的（封存形式的）对象尺寸应当较小，并且在少数情况下键冲突有可能导致数据库拒绝更新。</li>
<li><code>shelve</code> 模块不支持对 Shelf 对象的 <em>并发</em> 读/写访问。 （多个同时读取访问则是安全的。） 当一个程序打开一个 shelve 对象来写入时，不应再有其他程序同时打开它来读取或写入。 Unix 文件锁定可被用来解决此问题，但这在不同 Unix 版本上会存在差异，并且需要有关所用数据库实现的细节知识。</li>
</ul>
<p><em>class</em> <code>shelve.Shelf</code>(<em>dict</em>, <em>protocol=None</em>, <em>writeback=False</em>, <em>keyencoding=’utf-8’</em>)</p>
<p><code>collections.abc.MutableMapping</code> 的一个子类，它会将封存的值保存在 <em>dict</em> 对象中。</p>
<p>在默认情况下，会使用以 <code>pickle.DEFAULT_PROTOCOL</code> 创建的 pickle 来序列化值。 pickle 协议的版本可通过 <em>protocol</em> 形参来指定。</p>
<p>如果 <em>writeback</em> 形参为 <code>True</code>，对象将为所有访问过的条目保留缓存并在同步和关闭时将它们写回到 <em>dict</em>。 这允许对可变的条目执行自然操作，但是会消耗更多内存并让同步和关闭花费更长时间。</p>
<p><em>keyencoding</em> 形参是在下层字典被使用之前用于编码键的编码格式。</p>
<p><code>Shelf</code> 对象还可以被用作上下文管理器，在这种情况下它将在 <code>with</code> 语句块结束时自动被关闭。</p>
<p>在 3.2 版更改: 添加了 <em>keyencoding</em> 形参；之前，键总是使用 UTF-8 编码。</p>
<p>在 3.4 版更改: 添加了上下文管理器支持。</p>
<p>在 3.10 版更改: <code>pickle.DEFAULT_PROTOCOL</code> 现在会被用作默认的 pickle 协议。</p>
<p><em>class</em> <code>shelve.BsdDbShelf</code>(<em>dict</em>, <em>protocol=None</em>, <em>writeback=False</em>, <em>keyencoding=’utf-8’</em>)</p>
<p><code>Shelf</code> 的一个子类，将 <code>first()</code>, <code>next()</code>, <code>previous()</code>, <code>last()</code> 和 <code>set_location()</code> 对外公开，在来自 pybsddb 的第三方 <code>bsddb</code> 模块中可用，但在其他数据库模块中不可用。 传给构造器的 <em>dict</em> 对象必须支持这些方法。 这通常是通过调用 <code>bsddb.hashopen()</code>, <code>bsddb.btopen()</code> 或 <code>bsddb.rnopen()</code> 之一来完成的。 可选的 <em>protocol</em>, <em>writeback</em> 和 <em>keyencoding</em> 形参具有与 <code>Shelf</code> 类相同的含义。</p>
<p><em>class</em> <code>shelve.DbfilenameShelf</code>(<em>filename</em>, <em>flag=’c’</em>, <em>protocol=None</em>, <em>writeback=False</em>)</p>
<p><code>Shelf</code> 的一个子类，它接受一个 <em>filename</em> 而非字典类对象。 下层文件将使用 <code>dbm.open()</code> 来打开。 默认情况下，文件将以读写模式打开。 可选的 <em>flag</em> 形参具有与 <code>open()</code> 函数相同的含义。 可选的 <em>protocol</em> 和 <em>writeback</em> 形参具有与 <code>Shelf</code> 类相同的含义。</p>
<h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h3><p>对接口的总结如下 (<code>key</code> 为字符串，<code>data</code> 为任意对象):</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> shelve
d <span class="token operator">=</span> shelve<span class="token punctuation">.</span>open<span class="token punctuation">(</span>filename<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># open -- file may get suffix added by low-level</span>
                           <span class="token comment" spellcheck="true"># library</span>
d<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> data              <span class="token comment" spellcheck="true"># store data at key (overwrites old data if</span>
                           <span class="token comment" spellcheck="true"># using an existing key)</span>
data <span class="token operator">=</span> d<span class="token punctuation">[</span>key<span class="token punctuation">]</span>              <span class="token comment" spellcheck="true"># retrieve a COPY of data at key (raise KeyError</span>
                           <span class="token comment" spellcheck="true"># if no such key)</span>
<span class="token keyword">del</span> d<span class="token punctuation">[</span>key<span class="token punctuation">]</span>                 <span class="token comment" spellcheck="true"># delete data stored at key (raises KeyError</span>
                           <span class="token comment" spellcheck="true"># if no such key)</span>
flag <span class="token operator">=</span> key <span class="token keyword">in</span> d            <span class="token comment" spellcheck="true"># true if the key exists</span>
klist <span class="token operator">=</span> list<span class="token punctuation">(</span>d<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>     <span class="token comment" spellcheck="true"># a list of all existing keys (slow!)</span>
<span class="token comment" spellcheck="true"># as d was opened WITHOUT writeback=True, beware:</span>
d<span class="token punctuation">[</span><span class="token string">'xx'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span>        <span class="token comment" spellcheck="true"># this works as expected, but...</span>
d<span class="token punctuation">[</span><span class="token string">'xx'</span><span class="token punctuation">]</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>          <span class="token comment" spellcheck="true"># *this doesn't!* -- d['xx'] is STILL [0, 1, 2]!</span>
<span class="token comment" spellcheck="true"># having opened d without writeback=True, you need to code carefully:</span>
temp <span class="token operator">=</span> d<span class="token punctuation">[</span><span class="token string">'xx'</span><span class="token punctuation">]</span>             <span class="token comment" spellcheck="true"># extracts the copy</span>
temp<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>             <span class="token comment" spellcheck="true"># mutates the copy</span>
d<span class="token punctuation">[</span><span class="token string">'xx'</span><span class="token punctuation">]</span> <span class="token operator">=</span> temp             <span class="token comment" spellcheck="true"># stores the copy right back, to persist it</span>
<span class="token comment" spellcheck="true"># or, d=shelve.open(filename,writeback=True) would let you just code</span>
<span class="token comment" spellcheck="true"># d['xx'].append(5) and have it work as expected, BUT it would also</span>
<span class="token comment" spellcheck="true"># consume more memory and make the d.close() operation slower.</span>
d<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>                  <span class="token comment" spellcheck="true"># close it</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="marshal-—-内部-Python-对象序列化"><a href="#marshal-—-内部-Python-对象序列化" class="headerlink" title="marshal —- 内部 Python 对象序列化"></a><code>marshal</code> —- 内部 Python 对象序列化</h2><p>此模块包含一此能以二进制格式来读写 Python 值的函数。 这种格式是 Python 专属的，但是独立于特定的机器架构（即你可以在一台 PC 上写入某个 Python 值，将文件传到一台 Sun 上并在那里读取它）。 这种格式的细节有意不带文档说明；它可能在不同 Python 版本中发生改变（但这种情况极少发生）。</p>
<p>这不是一个通用的“持久化”模块。 <code>marshal</code> 模块主要是为了支持读写 <code>.pyc</code> 文件形式“伪编译”代码的 Python 模块。 因此，Python 维护者保留在必要时以不向下兼容的方式修改 marshal 格式的权利。 如果你要序列化和反序列化 Python 对象，请改用 <code>pickle</code> 模块 — 其执行效率相当，版本独立性有保证，并且 pickle 还支持比 marshal 更多样的对象类型。</p>
<p>警告</p>
<p><code>marshal</code> 模块对于错误或恶意构建的数据来说是不安全的。 永远不要 unmarshal 来自不受信任的或未经验证的来源的数据。</p>
<p>不是所有 Python 对象类型都受支持；一般来说，此模块只能写入和读取不依赖于特定 Python 调用的对象。 下列类型是受支持的：布尔值、整数、浮点数、复数、字符串、字节串、字节数组、元组、列表、集合、冻结集合、字典和代码对象，需要了解的一点是元组、列表、集合、冻结集合和字典只在其所包含的值也是这些值时才受支持。 单例对象 <code>None</code>, <code>Ellipsis</code> and <code>StopIteration</code> 也可以被 marshal 和 unmarshal。 对于 <em>version</em> 低于 3 的格式，递归列表、集合和字典无法被写入（见下文）。</p>
<p>有些函数可以读/写文件，还有些函数可以操作字节类对象。</p>
<p>这个模块定义了以下函数：</p>
<p><code>marshal.dump</code>(<em>value</em>, <em>file</em>[, <em>version</em>])</p>
<p>向打开的文件写入值。 值必须为受支持的类型。 文件必须为可写的 binary file。</p>
<p>如果值具有（或所包含的对象具有）不受支持的类型，则会引发 <code>ValueError</code> —- 但是将向文件写入垃圾数据。 对象也将不能正确地通过 <code>load()</code> 重新读取。</p>
<p><em>version</em> 参数指明 <code>dump</code> 应当使用的数据格式（见下文）。</p>
<p>引发一个 审计事件 <code>marshal.dumps</code>，附带参数 <code>value</code>, <code>version</code>。</p>
<p><code>marshal.load</code>(<em>file</em>)</p>
<p>从打开的文件读取一个值并返回。 如果读不到有效的值（例如由于数据为不同 Python 版本的不兼容 marshal 格式），则会引发 <code>EOFError</code>, <code>ValueError</code> 或 <code>TypeError</code>。 文件必须为可读的 binary file。</p>
<p>引发一个 审计事件 <code>marshal.load</code>，没有附带参数。</p>
<p>注解</p>
<p>如果通过 <code>dump()</code> marshal 了一个包含不受支持类型的对象，<code>load()</code> 将为不可 marshal 的类型替换 <code>None</code>。</p>
<p>在 3.10 版更改: 使用此调用为每个代码对象引发一个 <code>code.__new__</code> 审计事件。 现在它会为整个载入操作引发单个 <code>marshal.load</code> 事件。</p>
<p><code>marshal.dumps</code>(<em>value</em>[, <em>version</em>])</p>
<p>返回将通过 <code>dump(value, file)</code> 被写入一个文件的字节串对象。 值必须属于受支持的类型。 如果值属于（或包含的对象属于）不受支持的类型则会引发 <code>ValueError</code>。</p>
<p><em>version</em> 参数指明 <code>dumps</code> 应当使用的数据类型（见下文）。</p>
<p>引发一个 审计事件 <code>marshal.dumps</code>，附带参数 <code>value</code>, <code>version</code>。</p>
<p><code>marshal.loads</code>(<em>bytes</em>)</p>
<p>将 bytes-like object 转换为一个值。 如果找不到有效的值，则会引发 <code>EOFError</code>, <code>ValueError</code> 或 <code>TypeError</code>。 输入的额外字节串会被忽略。</p>
<p>引发一个 审计事件 <code>marshal.loads</code>，附带参数 <code>bytes</code>。</p>
<p>在 3.10 版更改: 使用此调用为每个代码对象引发一个 <code>code.__new__</code> 审计事件。 现在它会为整个载入操作引发单个 <code>marshal.loads</code> 事件。</p>
<p>此外，还定义了以下常量：</p>
<pre><code>marshal.version</code></pre><p>指明模块所使用的格式。 第 0 版为历史格式，第 1 版为共享固化的字符串，第 2 版对浮点数使用二进制格式。 第 3 版添加了对于对象实例化和递归的支持。 目前使用的为第 4 版。</p>
<p>此模块的名称来源于 Modula-3 (及其他语言) 的设计者所使用的术语，他们使用术语 “marshal” 来表示以自包含的形式传输数据。 严格地说，将数据从内部形式转换为外部形式 (例如用于 RPC 缓冲区) 称为 “marshal” 而其逆过程则称为 “unmarshal”。</p>
<h2 id="dbm-—-Unix-“数据库”-接口"><a href="#dbm-—-Unix-“数据库”-接口" class="headerlink" title="dbm —- Unix “数据库” 接口"></a><code>dbm</code> —- Unix “数据库” 接口</h2><p><strong>源代码:</strong> <a href="https://github.com/python/cpython/tree/3.10/Lib/dbm/__init__.py" target="_blank" rel="noopener">Lib/dbm/<strong>init</strong>.py</a></p>
<hr>
<p><code>dbm</code> 是一种泛用接口，针对各种 DBM 数据库 —- 包括 <code>dbm.gnu</code> 或 <code>dbm.ndbm</code>。 如果未安装这些模块中的任何一种，则将使用 <code>dbm.dumb</code> 模块中慢速但简单的实现。 还有一个适用于 Oracle Berkeley DB 的 第三方接口。</p>
<p><em>exception</em> <code>dbm.error</code></p>
<p>一个元组，其中包含每个受支持的模块可引发的异常，另外还有一个名为 <code>dbm.error</code> 的特殊异常作为第一项 —- 后者最在引发 <code>dbm.error</code> 时被使用。</p>
<p><code>dbm.whichdb</code>(<em>filename</em>)</p>
<p>此函数会猜测各种简单数据库模块中的哪一个是可用的 —- <code>dbm.gnu</code>, <code>dbm.ndbm</code> 还是 <code>dbm.dumb</code> —- 应该被用来打开给定的文件。</p>
<p>返回下列值中的一个：如果文件由于不可读或不存在而无法打开则返回 <code>None</code>；如果文件的格式无法猜测则返回空字符串 (<code>''</code>)；或是包含所需模块名称的字符串，例如 <code>'dbm.ndbm'</code> 或 <code>'dbm.gnu'</code>。</p>
<p><code>dbm.open</code>(<em>file</em>, <em>flag=’r’</em>, <em>mode=438</em>)</p>
<p>打开数据库文件 <em>file</em> 并返回一个相应的对象。</p>
<p>如果数据库文件已存在，则使用 <code>whichdb()</code> 函数来确定其类型和要使用的适当模块；如果文件不存在，则会使用上述可导入模块中的第一个。</p>
<p>可选的 <em>flag</em> 参数可以是：</p>
<table>
<thead>
<tr>
<th align="left">值</th>
<th align="left">含意</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>‘r’</code></td>
<td align="left">以只读方式打开现有数据库（默认）</td>
</tr>
<tr>
<td align="left"><code>‘w’</code></td>
<td align="left">以读写方式打开现有数据库</td>
</tr>
<tr>
<td align="left"><code>‘c’</code></td>
<td align="left">以读写方式打开数据库，如果不存在则创建它</td>
</tr>
<tr>
<td align="left"><code>‘n’</code></td>
<td align="left">始终创建一个新的空数据库，以读写方式打开</td>
</tr>
</tbody></table>
<p>可选的 <em>mode</em> 参数是文件的 Unix 模式，仅在要创建数据库时才会被使用。 其默认值为八进制数 <code>0o666</code> (并将被当前的 umask 所修改)。</p>
<p><code>open()</code> 所返回的对象支持与字典相同的基本功能；可以存储、获取和删除键及其对应的值，并可使用 <code>in</code> 运算符和 <code>keys()</code> 方法，以及 <code>get()</code> 和 <code>setdefault()</code>。</p>
<p>在 3.2 版更改: 现在 <code>get()</code> 和 <code>setdefault()</code> 在所有数据库模块中均可用。</p>
<p>在 3.8 版更改: 从只读数据库中删除键将引发数据库模块专属的错误而不是 <code>KeyError</code>。</p>
<p>键和值总是被存储为字节串。 这意味着当使用字符串时它们会在被存储之前隐式地转换至默认编码格式。</p>
<p>这些对象也支持在 <code>with</code> 语句中使用，当语句结束时将自动关闭它们。</p>
<p>在 3.4 版更改: 向 <code>open()</code> 所返回的对象添加了上下文管理协议的原生支持。</p>
<p>以下示例记录了一些主机名和对应的标题，随后将数据库的内容打印出来。:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> dbm
<span class="token comment" spellcheck="true"># Open database, creating it if necessary.</span>
<span class="token keyword">with</span> dbm<span class="token punctuation">.</span>open<span class="token punctuation">(</span><span class="token string">'cache'</span><span class="token punctuation">,</span> <span class="token string">'c'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> db<span class="token punctuation">:</span>
    <span class="token comment" spellcheck="true"># Record some values</span>
    db<span class="token punctuation">[</span>b<span class="token string">'hello'</span><span class="token punctuation">]</span> <span class="token operator">=</span> b<span class="token string">'there'</span>
    db<span class="token punctuation">[</span><span class="token string">'www.python.org'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'Python Website'</span>
    db<span class="token punctuation">[</span><span class="token string">'www.cnn.com'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'Cable News Network'</span>
    <span class="token comment" spellcheck="true"># Note that the keys are considered bytes now.</span>
    <span class="token keyword">assert</span> db<span class="token punctuation">[</span>b<span class="token string">'www.python.org'</span><span class="token punctuation">]</span> <span class="token operator">==</span> b<span class="token string">'Python Website'</span>
    <span class="token comment" spellcheck="true"># Notice how the value is now in bytes.</span>
    <span class="token keyword">assert</span> db<span class="token punctuation">[</span><span class="token string">'www.cnn.com'</span><span class="token punctuation">]</span> <span class="token operator">==</span> b<span class="token string">'Cable News Network'</span>
    <span class="token comment" spellcheck="true"># Often-used methods of the dict interface work too.</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>db<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">'python.org'</span><span class="token punctuation">,</span> b<span class="token string">'not present'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token comment" spellcheck="true"># Storing a non-string key or value will raise an exception (most</span>
    <span class="token comment" spellcheck="true"># likely a TypeError).</span>
    db<span class="token punctuation">[</span><span class="token string">'www.yahoo.com'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">4</span>
<span class="token comment" spellcheck="true"># db is automatically closed when leaving the with statement.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>存储非字符串数据的持久化模块。</p>
<p>以下部分描述了各个单独的子模块。</p>
<h3 id="dbm-gnu-—-GNU-对-dbm-的重解析"><a href="#dbm-gnu-—-GNU-对-dbm-的重解析" class="headerlink" title="dbm.gnu —- GNU 对 dbm 的重解析"></a><code>dbm.gnu</code> —- GNU 对 dbm 的重解析</h3><p><strong>源代码:</strong> <a href="https://github.com/python/cpython/tree/3.10/Lib/dbm/gnu.py" target="_blank" rel="noopener">Lib/dbm/gnu.py</a></p>
<hr>
<p>此模块与 <code>dbm</code> 模块很相似，但是改用 GNU 库 <code>gdbm</code> 来提供某些附加功能。 请注意由 <code>dbm.gnu</code> 与 <code>dbm.ndbm</code> 所创建的文件格式是不兼容的。</p>
<p><code>dbm.gnu</code> 模块提供了对 GNU DBM 库的接口。 <code>dbm.gnu.gdbm</code> 对象的行为类似于映射（字典），区别在于其键和值总是会在存储之前被转换为字节串。 打印 <code>gdbm</code> 对象不会打印出键和值，并且 <code>items()</code> 和 <code>values()</code> 等方法也不受支持。</p>
<p><em>exception</em> <code>dbm.gnu.error</code></p>
<p>针对 <code>dbm.gnu</code> 专属错误例如 I/O 错误引发。 <code>KeyError</code> 的引发则针对一般映射错误例如指定了不正确的键。</p>
<p><code>dbm.gnu.open</code>(<em>filename</em>[, <em>flag</em>[, <em>mode</em>]])</p>
<p>打开一个 <code>gdbm</code> 数据库并返回 <code>gdbm</code> 对象。 <em>filename</em> 参数为数据库文件名称。</p>
<p>可选的 <em>flag</em> 参数可以是：</p>
<table>
<thead>
<tr>
<th align="left">值</th>
<th align="left">含意</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>‘r’</code></td>
<td align="left">以只读方式打开现有数据库（默认）</td>
</tr>
<tr>
<td align="left"><code>‘w’</code></td>
<td align="left">以读写方式打开现有数据库</td>
</tr>
<tr>
<td align="left"><code>‘c’</code></td>
<td align="left">以读写方式打开数据库，如果不存在则创建它</td>
</tr>
<tr>
<td align="left"><code>‘n’</code></td>
<td align="left">始终创建一个新的空数据库，以读写方式打开</td>
</tr>
</tbody></table>
<p>下列附加字符可被添加至旗标以控制数据库的打开方式：</p>
<table>
<thead>
<tr>
<th align="left">值</th>
<th align="left">含意</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>‘f’</code></td>
<td align="left">以快速模式打开数据库。写入数据库将不会同步。</td>
</tr>
<tr>
<td align="left"><code>‘s’</code></td>
<td align="left">同步模式。这将导致数据库的更改立即写入文件。</td>
</tr>
<tr>
<td align="left"><code>‘u’</code></td>
<td align="left">不要锁定数据库。</td>
</tr>
</tbody></table>
<p>不是所有旗标都可用于所有版本的 <code>gdbm</code>。 模块常量 <code>open_flags</code> 为包含受支持旗标字符的字符串。 如果指定了无效的旗标则会引发 <code>error</code>。</p>
<p>可选的 <em>mode</em> 参数是文件的 Unix 模式，仅在要创建数据库时才会被使用。 其默认值为八进制数 <code>0o666</code>。</p>
<p>除了与字典类似的方法，<code>gdbm</code> 对象还有以下方法：</p>
<ul>
<li><p><code>gdbm.firstkey</code>()</p>
<p>使用此方法和 <code>nextkey()</code> 方法可以循环遍历数据库中的每个键。 遍历的顺序是按照 <code>gdbm</code> 的内部哈希值，而不会根据键的值排序。 此方法将返回起始键。</p>
</li>
<li><p><code>gdbm.nextkey</code>(<em>key</em>)</p>
<p>在遍历中返回 <em>key</em> 之后的的下一个键。 以下代码将打印数据库 <code>db</code> 中的每个键，而不会在内存中创建一个包含所有键的列表:</p>
<pre class="line-numbers language-python"><code class="language-python">k <span class="token operator">=</span> db<span class="token punctuation">.</span>firstkey<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">while</span> k <span class="token keyword">is</span> <span class="token operator">not</span> None<span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span>
    k <span class="token operator">=</span> db<span class="token punctuation">.</span>nextkey<span class="token punctuation">(</span>k<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><code>gdbm.reorganize</code>()</p>
<p>如果你进行了大量删除操作并且想要缩减 <code>gdbm</code> 文件所使用的空间，此例程将可重新组织数据库。 除非使用此重组功能否则 <code>gdbm</code> 对象不会缩减数据库文件大小；在其他情况下，被删除的文件空间将会保留并在添加新的 (键, 值) 对时被重用。</p>
</li>
<li><p><code>gdbm.sync</code>()</p>
<p>当以快速模式打开数据库时，此方法会将任何未写入数据强制写入磁盘。</p>
</li>
<li><p><code>gdbm.close</code>()</p>
<p>关闭 <code>gdbm</code> 数据库。</p>
</li>
</ul>
<h3 id="dbm-ndbm-—-基于-ndbm-的接口"><a href="#dbm-ndbm-—-基于-ndbm-的接口" class="headerlink" title="dbm.ndbm —- 基于 ndbm 的接口"></a><code>dbm.ndbm</code> —- 基于 ndbm 的接口</h3><p><strong>源代码:</strong> <a href="https://github.com/python/cpython/tree/3.10/Lib/dbm/ndbm.py" target="_blank" rel="noopener">Lib/dbm/ndbm.py</a></p>
<hr>
<p><code>dbm.ndbm</code> 模块提供了对 Unix “(n)dbm” 库的接口。 Dbm 对象的行为类似于映射（字典），区别在于其键和值总是被存储为字节串。 打印 <code>dbm</code> 对象不会打印出键和值，并且 <code>items()</code> 和 <code>values()</code> 等方法也不受支持。</p>
<p>此模块可与 “经典classic” ndbm 接口或 GNU GDBM 兼容接口一同使用。 在 Unix 上，<strong>configure</strong> 脚本将尝试定位适当的头文件来简化此模块的构建。</p>
<p><em>exception</em> <code>dbm.ndbm.error</code></p>
<p>针对 <code>dbm.ndbm</code> 专属错误例如 I/O 错误引发。 <code>KeyError</code> 的引发则针对一般映射错误例如指定了不正确的键。</p>
<pre><code>dbm.ndbm.library</code></pre><p>所使用的 <code>ndbm</code> 实现库的名称。</p>
<p><code>dbm.ndbm.open</code>(<em>filename</em>[, <em>flag</em>[, <em>mode</em>]])</p>
<p>打开一个 dbm 数据库并返回 <code>ndbm</code> 对象。 <em>filename</em> 参数为数据库文件名称（不带 <code>.dir</code> 或 <code>.pag</code> 扩展名）。</p>
<p>可选的 <em>flag</em> 参数必须是下列值之一：</p>
<table>
<thead>
<tr>
<th align="left">值</th>
<th align="left">含意</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>‘r’</code></td>
<td align="left">以只读方式打开现有数据库（默认）</td>
</tr>
<tr>
<td align="left"><code>‘w’</code></td>
<td align="left">以读写方式打开现有数据库</td>
</tr>
<tr>
<td align="left"><code>‘c’</code></td>
<td align="left">以读写方式打开数据库，如果不存在则创建它</td>
</tr>
<tr>
<td align="left"><code>‘n’</code></td>
<td align="left">始终创建一个新的空数据库，以读写方式打开</td>
</tr>
</tbody></table>
<p>可选的 <em>mode</em> 参数是文件的 Unix 模式，仅在要创建数据库时才会被使用。 其默认值为八进制数 <code>0o666</code> (并将被当前的 umask 所修改)。</p>
<p>除了与字典类似的方法，<code>ndbm</code> 对象还有以下方法：</p>
<ul>
<li><p><code>ndbm.close</code>()</p>
<p>关闭 <code>ndbm</code> 数据库。</p>
</li>
</ul>
<h3 id="dbm-dumb-—-便携式-DBM-实现"><a href="#dbm-dumb-—-便携式-DBM-实现" class="headerlink" title="dbm.dumb —- 便携式 DBM 实现"></a><code>dbm.dumb</code> —- 便携式 DBM 实现</h3><p><strong>源代码:</strong> <a href="https://github.com/python/cpython/tree/3.10/Lib/dbm/dumb.py" target="_blank" rel="noopener">Lib/dbm/dumb.py</a></p>
<p>注解</p>
<p><code>dbm.dumb</code> 模块的目的是在更健壮的模块不可用时作为 <code>dbm</code> 模块的最终回退项。 <code>dbm.dumb</code> 不是为高速运行而编写的，也不像其他数据库模块一样被经常使用。</p>
<hr>
<p><code>dbm.dumb</code> 模块提供了一个完全以 Python 编写的持久化字典类接口。 不同于 <code>dbm.gnu</code> 等其他模块，它不需要外部库。 与其他持久化映射一样，它的键和值也总是被存储为字节串。</p>
<p>该模块定义以下内容：</p>
<p><em>exception</em> <code>dbm.dumb.error</code></p>
<p>针对 <code>dbm.dumb</code> 专属错误例如 I/O 错误引发。 <code>KeyError</code> 的引发则针对一般映射例如指定了不正确的键。</p>
<p><code>dbm.dumb.open</code>(<em>filename</em>[, <em>flag</em>[, <em>mode</em>]])</p>
<p>打开一个 <code>dumbdbm</code> 数据库并返回 dumbdbm 对象。 <em>filename</em> 参数为数据库文件的主名称（不带任何特定扩展名）。 创建一个 dumbdbm 数据库时将创建多个带有 <code>.dat</code> 和 <code>.dir</code> 扩展名的文件。</p>
<p>可选的 <em>flag</em> 参数可以是：</p>
<table>
<thead>
<tr>
<th align="left">值</th>
<th align="left">含意</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>‘r’</code></td>
<td align="left">以只读方式打开现有数据库（默认）</td>
</tr>
<tr>
<td align="left"><code>‘w’</code></td>
<td align="left">以读写方式打开现有数据库</td>
</tr>
<tr>
<td align="left"><code>‘c’</code></td>
<td align="left">以读写方式打开数据库，如果不存在则创建它</td>
</tr>
<tr>
<td align="left"><code>‘n’</code></td>
<td align="left">始终创建一个新的空数据库，以读写方式打开</td>
</tr>
</tbody></table>
<p>可选的 <em>mode</em> 参数是文件的 Unix 模式，仅在要创建数据库时才会被使用。 其默认值为八进制数 <code>0o666</code> (并将被当前的 umask 所修改)。</p>
<p>警告</p>
<p>当载入包含足够巨大/复杂条目的数据库时有可能导致 Python 解释器的崩溃，这是由于 Python AST 编译器有栈深度限制。</p>
<p>在 3.5 版更改: <code>open()</code> 在 flag 值为 <code>'n'</code> 时将总是创建一个新的数据库。</p>
<p>在 3.8 版更改: 附带 <code>'r'</code> 旗标打开的数据库现在将是只读的。 附带 <code>'r'</code> 和 <code>'w'</code> 旗标的打开操作不会再创建数据库。</p>
<p>除了 <code>collections.abc.MutableMapping</code> 类所提供的方法，<code>dumbdbm</code> 对象还提供了以下方法：</p>
<ul>
<li><p><code>dumbdbm.sync</code>()</p>
<p>同步磁盘上的目录和数据文件。 此方法会由 <code>Shelve.sync()</code> 方法来调用。</p>
</li>
<li><p><code>dumbdbm.close</code>()</p>
<p>关闭 <code>dumbdbm</code> 数据库。</p>
</li>
</ul>
<h2 id="sqlite3-—-SQLite-数据库-DB-API-2-0-接口模块"><a href="#sqlite3-—-SQLite-数据库-DB-API-2-0-接口模块" class="headerlink" title="sqlite3 —- SQLite 数据库 DB-API 2.0 接口模块"></a><code>sqlite3</code> —- SQLite 数据库 DB-API 2.0 接口模块</h2><p><strong>源代码：</strong> <a href="https://github.com/python/cpython/tree/3.10/Lib/sqlite3/" target="_blank" rel="noopener">Lib/sqlite3/</a></p>
<hr>
<p>SQLite 是一个C语言库，它可以提供一种轻量级的基于磁盘的数据库，这种数据库不需要独立的服务器进程，也允许需要使用一种非标准的 SQL 查询语言来访问它。一些应用程序可以使用 SQLite 作为内部数据存储。可以用它来创建一个应用程序原型，然后再迁移到更大的数据库，比如 PostgreSQL 或 Oracle。</p>
<p>sqlite3 模块由 Gerhard Häring 编写。 它提供了 <a href="https://www.python.org/dev/peps/pep-0249" target="_blank" rel="noopener"><strong>PEP 249</strong></a> 所描述的符合 DB-API 2.0 规范的 SQL 接口，并要求 SQLite 3.7.15 或更新的版本。</p>
<p>参见</p>
<p><a href="https://www.sqlite.org/" target="_blank" rel="noopener">https://www.sqlite.org</a></p>
<p>SQLite的主页；它的文档详细描述了它所支持的 SQL 方言的语法和可用的数据类型。</p>
<p><a href="https://www.w3schools.com/sql/" target="_blank" rel="noopener">https://www.w3schools.com/sql/</a></p>
<p>学习 SQL 语法的教程、参考和例子。</p>
<p><a href="https://www.python.org/dev/peps/pep-0249" target="_blank" rel="noopener"><strong>PEP 249</strong></a> - DB-API 2.0 规范</p>
<p>PEP 由 Marc-André Lemburg 撰写。</p>
<p><a href="https://blog.creativecc.cn/posts/Database-Sqlite.html#toc-heading-121" target="_blank" rel="noopener">SQLite 常规使用</a></p>
<h3 id="模块函数和常量"><a href="#模块函数和常量" class="headerlink" title="模块函数和常量"></a>模块函数和常量</h3><pre><code>sqlite3.version</code></pre><p>这个模块的版本号，是一个字符串。不是 SQLite 库的版本号。</p>
<pre><code>sqlite3.version_info</code></pre><p>这个模块的版本号，是一个由整数组成的元组。不是 SQLite 库的版本号。</p>
<pre><code>sqlite3.sqlite_version</code></pre><p>使用中的 SQLite 库的版本号，是一个字符串。</p>
<pre><code>sqlite3.sqlite_version_info</code></pre><p>使用中的 SQLite 库的版本号，是一个整数组成的元组。</p>
<pre><code>sqlite3.PARSE_DECLTYPES</code></pre><p>这个常量可以作为 <code>connect()</code> 函数的 <em>detect_types</em> 参数。</p>
<p>设置这个参数后，<code>sqlite3</code> 模块将解析它返回的每一列申明的类型。它会申明的类型的第一个单词，比如“integer primary key”，它会解析出“integer”，再比如“number(10)”，它会解析出“number”。然后，它会在转换器字典里查找那个类型注册的转换器函数，并调用它。</p>
<pre><code>sqlite3.PARSE_COLNAMES</code></pre><p>这个常量可以作为 <code>connect()</code> 函数的 <em>detect_types</em> 参数。</p>
<p>设置此参数可使得 SQLite 接口解析它所返回的每一列的列名。 它将在其中查找形式为 [mytype] 的字符串，然后将 ‘mytype’ 确定为列的类型。 它将尝试在转换器字典中查找 ‘mytype’ 条目，然后用找到的转换器函数来返回值。 在 <code>Cursor.description</code> 中找到的列名并不包括类型，举例来说，如果你在你的 SQL 中使用了像 <code>'as "Expiration date [datetime]"'</code> 这样的写法，那么我们将解析出在第一个 <code>'['</code> 之前的所有内容并去除前导空格作为列名：即列名将为 “Expiration date”。</p>
<p><code>sqlite3.connect</code>(<em>database</em>[, <em>timeout</em>, <em>detect_types</em>, <em>isolation_level</em>, <em>check_same_thread</em>, <em>factory</em>, <em>cached_statements</em>, <em>uri</em>])</p>
<p>连接 SQLite 数据库 <em>database*。默认返回 <code>Connection</code> 对象，除非使用了自定义的 *factory</em> 参数。</p>
<p><em>database</em> 是准备打开的数据库文件的路径（绝对路径或相对于当前目录的相对路径），它是 path-like object。你也可以用 <code>":memory:"</code> 在内存中打开一个数据库。</p>
<p>当一个数据库被多个连接访问的时候，如果其中一个进程修改这个数据库，在这个事务提交之前，这个 SQLite 数据库将会被一直锁定。<em>timeout</em> 参数指定了这个连接等待锁释放的超时时间，超时之后会引发一个异常。这个超时时间默认是 5.0（5秒）。</p>
<p><em>isolation_level</em> 参数，请查看 <code>Connection</code> 对象的 <code>isolation_level</code> 属性。</p>
<p>SQLite 原生只支持5种类型：TEXT，INTEGER，REAL，BLOB 和 NULL。如果你想用其它类型，你必须自己添加相应的支持。使用 <em>detect_types</em> 参数和模块级别的 <code>register_converter()</code> 函数注册<strong>转换器</strong> 可以简单的实现。</p>
<p><em>detect_types</em> 默认为 0 (即关闭，不进行类型检测)，你可以将其设为任意的 <code>PARSE_DECLTYPES</code> 和 <code>PARSE_COLNAMES</code> 组合来启用类型检测。 由于 SQLite 的行为，生成的字段类型 (例如 <code>max(data)</code>) 不能被检测，即使在设置了 <em>detect_types</em> 形参时也是如此。 在此情况下，返回的类型为 <code>str</code>。</p>
<p>默认情况下，<em>check_same_thread</em> 为 <code>True</code>，只有当前的线程可以使用该连接。 如果设置为 <code>False</code>，则多个线程可以共享返回的连接。 当多个线程使用同一个连接的时候，用户应该把写操作进行序列化，以避免数据损坏。</p>
<p>默认情况下，当调用 connect 方法的时候，<code>sqlite3</code> 模块使用了它的 <code>Connection</code> 类。当然，你也可以创建 <code>Connection</code> 类的子类，然后创建提供了 <em>factory</em> 参数的 <code>connect()</code> 方法。</p>
<p><code>sqlite3</code> 模块在内部使用语句缓存来避免 SQL 解析开销。 如果要显式设置当前连接可以缓存的语句数，可以设置 <em>cached_statements</em> 参数。 当前实现的默认值是缓存100条语句。</p>
<p>如果 <em>uri</em> 为真，则 <em>database</em> 被解释为 URI。 它允许您指定选项。 例如，以只读模式打开数据库：</p>
<pre class="line-numbers language-python"><code class="language-python">db <span class="token operator">=</span> sqlite3<span class="token punctuation">.</span>connect<span class="token punctuation">(</span><span class="token string">'file:path/to/database?mode=ro'</span><span class="token punctuation">,</span> uri<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>有关此功能的更多信息，包括已知选项的列表，可以在 <code>SQLite URI 文档 &lt;https://www.sqlite.org/uri.html&gt;</code>_ 中找到。</p>
<p>引发一个 审计事件 <code>sqlite3.connect</code>，附带参数 <code>database</code>。</p>
<p>引发一个 审计事件 <code>sqlite3.connect/handle</code>，附带参数 <code>connection_handle</code>。</p>
<p>在 3.4 版更改: 增加了 <em>uri</em> 参数。</p>
<p>在 3.7 版更改: <em>database</em> 现在可以是一个 path-like object 对象了，不仅仅是字符串。</p>
<p>在 3.10 版更改: 增加了 <code>sqlite3.connect/handle</code> 审计事件。</p>
<p><code>sqlite3.register_converter</code>(<em>typename</em>, <em>callable</em>)</p>
<p>注册一个回调对象 <em>callable</em>, 用来转换数据库中的字节串为自定的 Python 类型。所有类型为 <em>typename</em> 的数据库的值在转换时，都会调用这个回调对象。通过指定 <code>connect()</code> 函数的 <em>detect-types</em> 参数来设置类型检测的方式。注意，<em>typename</em> 与查询语句中的类型名进行匹配时不区分大小写。</p>
<p><code>sqlite3.register_adapter</code>(<em>type</em>, <em>callable</em>)</p>
<p>注册一个回调对象 <em>callable*，用来转换自定义Python类型为一个 SQLite 支持的类型。 这个回调对象 *callable</em> 仅接受一个 Python 值作为参数，而且必须返回以下某个类型的值：int，float，str 或 bytes。</p>
<p><code>sqlite3.complete_statement</code>(<em>sql</em>)</p>
<p>如果字符串 <em>sql</em> 包含一个或多个完整的 SQL 语句（以分号结束）则返回 <code>True</code>。它不会验证 SQL 语法是否正确，仅会验证字符串字面上是否完整，以及是否以分号结束。</p>
<p>它可以用来构建一个 SQLite shell，下面是一个例子：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># A minimal SQLite shell for experiments</span>
<span class="token keyword">import</span> sqlite3
con <span class="token operator">=</span> sqlite3<span class="token punctuation">.</span>connect<span class="token punctuation">(</span><span class="token string">":memory:"</span><span class="token punctuation">)</span>
con<span class="token punctuation">.</span>isolation_level <span class="token operator">=</span> None
cur <span class="token operator">=</span> con<span class="token punctuation">.</span>cursor<span class="token punctuation">(</span><span class="token punctuation">)</span>
buffer <span class="token operator">=</span> <span class="token string">""</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Enter your SQL commands to execute in sqlite3."</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Enter a blank line to exit."</span><span class="token punctuation">)</span>
<span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>
    line <span class="token operator">=</span> input<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> line <span class="token operator">==</span> <span class="token string">""</span><span class="token punctuation">:</span>
        <span class="token keyword">break</span>
    buffer <span class="token operator">+=</span> line
    <span class="token keyword">if</span> sqlite3<span class="token punctuation">.</span>complete_statement<span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">try</span><span class="token punctuation">:</span>
            buffer <span class="token operator">=</span> buffer<span class="token punctuation">.</span>strip<span class="token punctuation">(</span><span class="token punctuation">)</span>
            cur<span class="token punctuation">.</span>execute<span class="token punctuation">(</span>buffer<span class="token punctuation">)</span>
            <span class="token keyword">if</span> buffer<span class="token punctuation">.</span>lstrip<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>upper<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>startswith<span class="token punctuation">(</span><span class="token string">"SELECT"</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                <span class="token keyword">print</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>fetchall<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">except</span> sqlite3<span class="token punctuation">.</span>Error <span class="token keyword">as</span> e<span class="token punctuation">:</span>
            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"An error occurred:"</span><span class="token punctuation">,</span> e<span class="token punctuation">.</span>args<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
        buffer <span class="token operator">=</span> <span class="token string">""</span>
con<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>sqlite3.enable_callback_tracebacks</code>(<em>flag</em>)</p>
<p>默认情况下，您不会获得任何用户定义函数中的回溯消息，比如聚合，转换器，授权器回调等。如果要调试它们，可以设置 <em>flag</em> 参数为 <code>True</code> 并调用此函数。 之后，回调中的回溯信息将会输出到 <code>sys.stderr</code>。 再次使用 <code>False</code> 来禁用该功能。</p>
<h3 id="连接对象（Connection）"><a href="#连接对象（Connection）" class="headerlink" title="连接对象（Connection）"></a>连接对象（Connection）</h3><p><em>class</em> <code>sqlite3.Connection</code></p>
<p>SQLite 数据库连接对象有如下的属性和方法：</p>
<ul>
<li><p><code>isolation_level</code></p>
<p>获取或设置当前默认的隔离级别。 表示自动提交模式的 <code>None</code> 以及 “DEFERRED”, “IMMEDIATE” 或 “EXCLUSIVE” 其中之一。 </p>
</li>
<li><p><code>in_transaction</code></p>
<p>如果是在活动事务中（还没有提交改变），返回 <code>True</code>，否则，返回 <code>False</code>。它是一个只读属性。</p>
<p>3.2 新版功能.</p>
</li>
<li><p><code>cursor</code>(<em>factory=Cursor</em>)</p>
<p>这个方法接受一个可选参数 <em>factory</em>，如果要指定这个参数，它必须是一个可调用对象，而且必须返回 <code>Cursor</code> 类的一个实例或者子类。</p>
</li>
<li><p><code>commit</code>()</p>
<p>这个方法提交当前事务。如果没有调用这个方法，那么从上一次提交 <code>commit()</code> 以来所有的变化在其他数据库连接上都是不可见的。如果你往数据库里写了数据，但是又查询不到，请检查是否忘记了调用这个方法。</p>
</li>
<li><p><code>rollback</code>()</p>
<p>这个方法回滚从上一次调用 <code>commit()</code> 以来所有数据库的改变。</p>
</li>
<li><p><code>close</code>()</p>
<p>关闭数据库连接。注意，它不会自动调用 <code>commit()</code> 方法。如果在关闭数据库连接之前没有调用 <code>commit()</code>，那么你的修改将会丢失！</p>
</li>
<li><p><code>execute</code>(<em>sql</em>[, <em>parameters</em>])</p>
<p>这是一个非标准的快捷方法，它会调用 <code>cursor()</code> 方法来创建一个游标对象，并使用给定的 <em>parameters</em> 参数来调用游标对象的 <code>execute()</code> 方法，最后返回这个游标对象。</p>
</li>
<li><p><code>executemany</code>(<em>sql</em>[, <em>parameters</em>])</p>
<p>这是一个非标准的快捷方法，它会调用 <code>cursor()</code> 方法来创建一个游标对象，并使用给定的 <em>parameters</em> 参数来调用游标对象的 <code>executemany()</code> 方法，最后返回这个游标对象。</p>
</li>
<li><p><code>executescript</code>(<em>sql_script</em>)</p>
<p>这是一个非标准的快捷方法，它会调用 <code>cursor()</code> 方法来创建一个游标对象，并使用给定的 <em>sql_script</em> 参数来调用游标对象的 <code>executescript()</code> 方法，最后返回这个游标对象。</p>
</li>
<li><p><code>create_function</code>(<em>name</em>, <em>num_params</em>, <em>func</em>, <em>**,</em> deterministic=False*)</p>
<p>创建一个可以在 SQL 语句中使用的用户自定义函数，函数名为 <em>name*。 *num_params</em> 为该函数所接受的形参个数（如果 <em>num_params</em> 为 -1，则该函数可接受任意数量的参数）， <em>func</em> 是一个 Python 可调用对象，它将作为 SQL 函数被调用。 如果 <em>deterministic</em> 为真值，则所创建的函数将被标记为 deterministic，这允许 SQLite 执行额外的优化。 此旗标在 SQLite 3.8.3 或更高版本中受到支持，如果在旧版本中使用将引发 <code>NotSupportedError</code>。</p>
<p>此函数可返回任何 SQLite 所支持的类型: bytes, str, int, float 和 <code>None</code>。</p>
<p>在 3.8 版更改: 增加了 <em>deterministic</em> 形参。</p>
<p>示例:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> sqlite3
<span class="token keyword">import</span> hashlib
<span class="token keyword">def</span> <span class="token function">md5sum</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">return</span> hashlib<span class="token punctuation">.</span>md5<span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">.</span>hexdigest<span class="token punctuation">(</span><span class="token punctuation">)</span>
con <span class="token operator">=</span> sqlite3<span class="token punctuation">.</span>connect<span class="token punctuation">(</span><span class="token string">":memory:"</span><span class="token punctuation">)</span>
con<span class="token punctuation">.</span>create_function<span class="token punctuation">(</span><span class="token string">"md5"</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> md5sum<span class="token punctuation">)</span>
cur <span class="token operator">=</span> con<span class="token punctuation">.</span>cursor<span class="token punctuation">(</span><span class="token punctuation">)</span>
cur<span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token string">"select md5(?)"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>b<span class="token string">"foo"</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>fetchone<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
con<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><code>create_aggregate</code>(<em>name</em>, <em>num_params</em>, <em>aggregate_class</em>)</p>
<p>创建一个自定义的聚合函数。</p>
<p>参数中 <em>aggregate_class</em> 类必须实现两个方法：<code>step</code> 和 <code>finalize</code>。<code>step</code> 方法接受 <em>num_params</em> 个参数（如果 <em>num_params</em> 为 -1，那么这个函数可以接受任意数量的参数）；<code>finalize</code> 方法返回最终的聚合结果。</p>
<p><code>finalize</code> 方法可以返回任何 SQLite 支持的类型：bytes，str，int，float 和 <code>None</code>。</p>
<p>示例:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> sqlite3
<span class="token keyword">class</span> <span class="token class-name">MySum</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>count <span class="token operator">=</span> <span class="token number">0</span>
    <span class="token keyword">def</span> <span class="token function">step</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>count <span class="token operator">+=</span> value
    <span class="token keyword">def</span> <span class="token function">finalize</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> self<span class="token punctuation">.</span>count
con <span class="token operator">=</span> sqlite3<span class="token punctuation">.</span>connect<span class="token punctuation">(</span><span class="token string">":memory:"</span><span class="token punctuation">)</span>
con<span class="token punctuation">.</span>create_aggregate<span class="token punctuation">(</span><span class="token string">"mysum"</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> MySum<span class="token punctuation">)</span>
cur <span class="token operator">=</span> con<span class="token punctuation">.</span>cursor<span class="token punctuation">(</span><span class="token punctuation">)</span>
cur<span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token string">"create table test(i)"</span><span class="token punctuation">)</span>
cur<span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token string">"insert into test(i) values (1)"</span><span class="token punctuation">)</span>
cur<span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token string">"insert into test(i) values (2)"</span><span class="token punctuation">)</span>
cur<span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token string">"select mysum(i) from test"</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>fetchone<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
con<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><code>create_collation</code>(<em>name</em>, <em>callable</em>)</p>
<p>使用 <em>name</em> 和 <em>callable</em> 创建排序规则。这个 <em>callable</em> 接受两个字符串对象，如果第一个小于第二个则返回 -1， 如果两个相等则返回 0，如果第一个大于第二个则返回 1。注意，这是用来控制排序的（SQL 中的 ORDER BY），所以它不会影响其它的 SQL 操作。</p>
<p>注意，这个 <em>callable</em> 可调用对象会把它的参数作为 Python 字节串，通常会以 UTF-8 编码格式对它进行编码。</p>
<p>以下示例显示了使用“错误方式”进行排序的自定义排序规则：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> sqlite3
<span class="token keyword">def</span> <span class="token function">collate_reverse</span><span class="token punctuation">(</span>string1<span class="token punctuation">,</span> string2<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> string1 <span class="token operator">==</span> string2<span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token number">0</span>
    <span class="token keyword">elif</span> string1 <span class="token operator">&lt;</span> string2<span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token number">1</span>
    <span class="token keyword">else</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>
con <span class="token operator">=</span> sqlite3<span class="token punctuation">.</span>connect<span class="token punctuation">(</span><span class="token string">":memory:"</span><span class="token punctuation">)</span>
con<span class="token punctuation">.</span>create_collation<span class="token punctuation">(</span><span class="token string">"reverse"</span><span class="token punctuation">,</span> collate_reverse<span class="token punctuation">)</span>
cur <span class="token operator">=</span> con<span class="token punctuation">.</span>cursor<span class="token punctuation">(</span><span class="token punctuation">)</span>
cur<span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token string">"create table test(x)"</span><span class="token punctuation">)</span>
cur<span class="token punctuation">.</span>executemany<span class="token punctuation">(</span><span class="token string">"insert into test(x) values (?)"</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">"b"</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
cur<span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token string">"select x from test order by x collate reverse"</span><span class="token punctuation">)</span>
<span class="token keyword">for</span> row <span class="token keyword">in</span> cur<span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>row<span class="token punctuation">)</span>
con<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>要移除一个排序规则，需要调用 <code>create_collation</code> 并设置 callable 参数为 <code>None</code>。</p>
<pre class="line-numbers language-python"><code class="language-python">con<span class="token punctuation">.</span>create_collation<span class="token punctuation">(</span><span class="token string">"reverse"</span><span class="token punctuation">,</span> None<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p><code>interrupt</code>()</p>
<p>可以从不同的线程调用这个方法来终止所有查询操作，这些查询操作可能正在连接上执行。此方法调用之后， 查询将会终止，而且查询的调用者会获得一个异常。</p>
</li>
<li><p><code>set_authorizer</code>(<em>authorizer_callback</em>)</p>
<p>此方法注册一个授权回调对象。每次在访问数据库中某个表的某一列的时候，这个回调对象将会被调用。如果要允许访问，则返回 <code>SQLITE_OK</code>，如果要终止整个 SQL 语句，则返回 <code>SQLITE_DENY</code>，如果这一列需要当做 NULL 值处理，则返回 <code>SQLITE_IGNORE</code>。这些常量可以在 <code>sqlite3</code> 模块中找到。</p>
<p>回调的第一个参数表示要授权的操作类型。 第二个和第三个参数将是参数或 <code>None</code>，具体取决于第一个参数的值。 第 4 个参数是数据库的名称（“main”，“temp”等），如果需要的话。 第 5 个参数是负责访问尝试的最内层触发器或视图的名称，或者如果此访问尝试直接来自输入 SQL 代码，则为 <code>None</code>。</p>
<p>请参阅 SQLite 文档，了解第一个参数的可能值以及第二个和第三个参数的含义，具体取决于第一个参数。 </p>
</li>
<li><p><code>set_progress_handler</code>(<em>handler</em>, <em>n</em>)</p>
<p>此例程注册回调。 对SQLite虚拟机的每个多指令调用回调。 如果要在长时间运行的操作期间从SQLite调用（例如更新用户界面），这非常有用。</p>
<p>如果要清除以前安装的任何进度处理程序，调用该方法时请将 <em>handler</em> 参数设置为 <code>None</code>。</p>
<p>从处理函数返回非零值将终止当前正在执行的查询并导致它引发 <code>OperationalError</code> 异常。</p>
</li>
<li><p><code>set_trace_callback</code>(<em>trace_callback</em>)</p>
<p>为每个 SQLite 后端实际执行的 SQL 语句注册要调用的 <em>trace_callback</em>。</p>
<p>The only argument passed to the callback is the statement (as <code>str</code>) that is being executed. The return value of the callback is ignored. Note that the backend does not only run statements passed to the <code>Cursor.execute()</code> methods. Other sources include the transaction management of the sqlite3 module and the execution of triggers defined in the current database.</p>
<p>将传入的 <em>trace_callback</em> 设为 <code>None</code> 将禁用跟踪回调。</p>
<p>注解</p>
<p>Exceptions raised in the trace callback are not propagated. As a development and debugging aid, use <code>enable_callback_tracebacks()</code> to enable printing tracebacks from exceptions raised in the trace callback.</p>
<p>3.3 新版功能.</p>
</li>
<li><p><code>enable_load_extension</code>(<em>enabled</em>)</p>
<p>此例程允许/禁止SQLite引擎从共享库加载SQLite扩展。 SQLite扩展可以定义新功能，聚合或全新的虚拟表实现。 一个众所周知的扩展是与SQLite一起分发的全文搜索扩展。</p>
<p>默认情况下禁用可加载扩展。 </p>
<p>引发一个 审计事件 <code>sqlite3.enable_load_extension</code>，附带参数 <code>connection</code>, <code>enabled</code>。</p>
<p>3.2 新版功能.</p>
<p>在 3.10 版更改: 增加了 <code>sqlite3.enable_load_extension</code> 审计事件。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> sqlite3
con <span class="token operator">=</span> sqlite3<span class="token punctuation">.</span>connect<span class="token punctuation">(</span><span class="token string">":memory:"</span><span class="token punctuation">)</span>
<span class="token comment" spellcheck="true"># enable extension loading</span>
con<span class="token punctuation">.</span>enable_load_extension<span class="token punctuation">(</span><span class="token boolean">True</span><span class="token punctuation">)</span>
<span class="token comment" spellcheck="true"># Load the fulltext search extension</span>
con<span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token string">"select load_extension('./fts3.so')"</span><span class="token punctuation">)</span>
<span class="token comment" spellcheck="true"># alternatively you can load the extension using an API call:</span>
<span class="token comment" spellcheck="true"># con.load_extension("./fts3.so")</span>
<span class="token comment" spellcheck="true"># disable extension loading again</span>
con<span class="token punctuation">.</span>enable_load_extension<span class="token punctuation">(</span><span class="token boolean">False</span><span class="token punctuation">)</span>
<span class="token comment" spellcheck="true"># example from SQLite wiki</span>
con<span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token string">"create virtual table recipe using fts3(name, ingredients)"</span><span class="token punctuation">)</span>
con<span class="token punctuation">.</span>executescript<span class="token punctuation">(</span><span class="token triple-quoted-string string">"""
    insert into recipe (name, ingredients) values ('broccoli stew', 'broccoli peppers cheese tomatoes');
    insert into recipe (name, ingredients) values ('pumpkin stew', 'pumpkin onions garlic celery');
    insert into recipe (name, ingredients) values ('broccoli pie', 'broccoli cheese onions flour');
    insert into recipe (name, ingredients) values ('pumpkin pie', 'pumpkin sugar flour butter');
    """</span><span class="token punctuation">)</span>
<span class="token keyword">for</span> row <span class="token keyword">in</span> con<span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token string">"select rowid, name, ingredients from recipe where name match 'pie'"</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>row<span class="token punctuation">)</span>
con<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><code>load_extension</code>(<em>path</em>)</p>
<p>此例程从共享库加载SQLite扩展。 在使用此例程之前，必须使用 <code>enable_load_extension()</code> 启用扩展加载。</p>
<p>默认情况下禁用可加载扩展。</p>
<p>引发一个 审计事件 <code>sqlite3.load_extension</code>，附带参数 <code>connection</code>, <code>path</code>。</p>
<p>3.2 新版功能.</p>
<p>在 3.10 版更改: 增加了 <code>sqlite3.load_extension</code> 审计事件。</p>
</li>
<li><p><code>row_factory</code></p>
<p>您可以将此属性更改为可接受游标和原始行作为元组的可调用对象，并将返回实际结果行。 这样，您可以实现更高级的返回结果的方法，例如返回一个可以按名称访问列的对象。</p>
<p>示例:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> sqlite3
<span class="token keyword">def</span> <span class="token function">dict_factory</span><span class="token punctuation">(</span>cursor<span class="token punctuation">,</span> row<span class="token punctuation">)</span><span class="token punctuation">:</span>
    d <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token keyword">for</span> idx<span class="token punctuation">,</span> col <span class="token keyword">in</span> enumerate<span class="token punctuation">(</span>cursor<span class="token punctuation">.</span>description<span class="token punctuation">)</span><span class="token punctuation">:</span>
        d<span class="token punctuation">[</span>col<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> row<span class="token punctuation">[</span>idx<span class="token punctuation">]</span>
    <span class="token keyword">return</span> d
con <span class="token operator">=</span> sqlite3<span class="token punctuation">.</span>connect<span class="token punctuation">(</span><span class="token string">":memory:"</span><span class="token punctuation">)</span>
con<span class="token punctuation">.</span>row_factory <span class="token operator">=</span> dict_factory
cur <span class="token operator">=</span> con<span class="token punctuation">.</span>cursor<span class="token punctuation">(</span><span class="token punctuation">)</span>
cur<span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token string">"select 1 as a"</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>fetchone<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token string">"a"</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
con<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果返回一个元组是不够的，并且你想要对列进行基于名称的访问，你应该考虑将 <code>row_factory</code> 设置为高度优化的 <code>sqlite3.Row</code> 类型。 <code>Row</code> 提供基于索引和不区分大小写的基于名称的访问，几乎没有内存开销。 它可能比您自己的基于字典的自定义方法甚至基于 db_row 的解决方案更好。</p>
</li>
<li><p><code>text_factory</code></p>
<p>Using this attribute you can control what objects are returned for the <code>TEXT</code> data type. By default, this attribute is set to <code>str</code> and the <code>sqlite3</code> module will return <code>str</code> objects for <code>TEXT</code>. If you want to return <code>bytes</code> instead, you can set it to <code>bytes</code>.</p>
<p>您还可以将其设置为接受单个 bytestring 参数的任何其他可调用对象，并返回结果对象。</p>
<p>请参阅以下示例代码以进行说明：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> sqlite3
con <span class="token operator">=</span> sqlite3<span class="token punctuation">.</span>connect<span class="token punctuation">(</span><span class="token string">":memory:"</span><span class="token punctuation">)</span>
cur <span class="token operator">=</span> con<span class="token punctuation">.</span>cursor<span class="token punctuation">(</span><span class="token punctuation">)</span>
AUSTRIA <span class="token operator">=</span> <span class="token string">"Österreich"</span>
<span class="token comment" spellcheck="true"># by default, rows are returned as str</span>
cur<span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token string">"select ?"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>AUSTRIA<span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
row <span class="token operator">=</span> cur<span class="token punctuation">.</span>fetchone<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">assert</span> row<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> AUSTRIA
<span class="token comment" spellcheck="true"># but we can make sqlite3 always return bytestrings ...</span>
con<span class="token punctuation">.</span>text_factory <span class="token operator">=</span> bytes
cur<span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token string">"select ?"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>AUSTRIA<span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
row <span class="token operator">=</span> cur<span class="token punctuation">.</span>fetchone<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">assert</span> type<span class="token punctuation">(</span>row<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">is</span> bytes
<span class="token comment" spellcheck="true"># the bytestrings will be encoded in UTF-8, unless you stored garbage in the</span>
<span class="token comment" spellcheck="true"># database ...</span>
<span class="token keyword">assert</span> row<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> AUSTRIA<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token string">"utf-8"</span><span class="token punctuation">)</span>
<span class="token comment" spellcheck="true"># we can also implement a custom text_factory ...</span>
<span class="token comment" spellcheck="true"># here we implement one that appends "foo" to all strings</span>
con<span class="token punctuation">.</span>text_factory <span class="token operator">=</span> <span class="token keyword">lambda</span> x<span class="token punctuation">:</span> x<span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token string">"utf-8"</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"foo"</span>
cur<span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token string">"select ?"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">"bar"</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
row <span class="token operator">=</span> cur<span class="token punctuation">.</span>fetchone<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">assert</span> row<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">"barfoo"</span>
con<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><code>total_changes</code></p>
<p>返回自打开数据库连接以来已修改，插入或删除的数据库行的总数。</p>
</li>
<li><p><code>iterdump</code>()</p>
<p>返回以SQL文本格式转储数据库的迭代器。 保存内存数据库以便以后恢复时很有用。 此函数提供与 <strong>sqlite3</strong> shell 中的 .dump 命令相同的功能。</p>
<p>示例:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Convert file existing_db.db to SQL dump file dump.sql</span>
<span class="token keyword">import</span> sqlite3
con <span class="token operator">=</span> sqlite3<span class="token punctuation">.</span>connect<span class="token punctuation">(</span><span class="token string">'existing_db.db'</span><span class="token punctuation">)</span>
<span class="token keyword">with</span> open<span class="token punctuation">(</span><span class="token string">'dump.sql'</span><span class="token punctuation">,</span> <span class="token string">'w'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span>
    <span class="token keyword">for</span> line <span class="token keyword">in</span> con<span class="token punctuation">.</span>iterdump<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        f<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">'%s\n'</span> <span class="token operator">%</span> line<span class="token punctuation">)</span>
con<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><code>backup</code>(<em>target</em>, <em>**,</em> pages=- 1<em>,</em> progress=None<em>,</em> name=’main’<em>,</em> sleep=0.25*)</p>
<p>即使在 SQLite 数据库被其他客户端访问时，或者同时由同一连接访问，该方法也会对其进行备份。 该副本将写入强制参数 <em>target</em>，该参数必须是另一个 <code>Connection</code> 实例。</p>
<p>默认情况下，或者当 <em>pages</em> 为 <code>0</code> 或负整数时，整个数据库将在一个步骤中复制；否则该方法一次循环复制 <em>pages</em> 规定数量的页面。</p>
<p>如果指定了 <em>progress<em>，则它必须为 <code>None</code> 或一个将在每次迭代时附带三个整数参数执行的可调用对象，这三个参数分别是前一次迭代的状态 *status</em>，将要拷贝的剩余页数 *remaining</em> 以及总页数 <em>total</em>。</p>
<p><em>name</em> 参数指定将被拷贝的数据库名称：它必须是一个字符串，其内容为表示主数据库的默认值 <code>"main"</code>，表示临时数据库的 <code>"temp"</code> 或是在 <code>ATTACH DATABASE</code> 语句的 <code>AS</code> 关键字之后指定表示附加数据库的名称。</p>
<p><em>sleep</em> 参数指定在备份剩余页的连续尝试之间要休眠的秒数，可以指定为一个整数或一个浮点数值。</p>
<p>示例一，将现有数据库复制到另一个数据库中：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> sqlite3
<span class="token keyword">def</span> <span class="token function">progress</span><span class="token punctuation">(</span>status<span class="token punctuation">,</span> remaining<span class="token punctuation">,</span> total<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">'Copied {total-remaining} of {total} pages...'</span><span class="token punctuation">)</span>
con <span class="token operator">=</span> sqlite3<span class="token punctuation">.</span>connect<span class="token punctuation">(</span><span class="token string">'existing_db.db'</span><span class="token punctuation">)</span>
bck <span class="token operator">=</span> sqlite3<span class="token punctuation">.</span>connect<span class="token punctuation">(</span><span class="token string">'backup.db'</span><span class="token punctuation">)</span>
<span class="token keyword">with</span> bck<span class="token punctuation">:</span>
    con<span class="token punctuation">.</span>backup<span class="token punctuation">(</span>bck<span class="token punctuation">,</span> pages<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> progress<span class="token operator">=</span>progress<span class="token punctuation">)</span>
bck<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>
con<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>示例二，将现有数据库复制到临时副本中：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> sqlite3
source <span class="token operator">=</span> sqlite3<span class="token punctuation">.</span>connect<span class="token punctuation">(</span><span class="token string">'existing_db.db'</span><span class="token punctuation">)</span>
dest <span class="token operator">=</span> sqlite3<span class="token punctuation">.</span>connect<span class="token punctuation">(</span><span class="token string">':memory:'</span><span class="token punctuation">)</span>
source<span class="token punctuation">.</span>backup<span class="token punctuation">(</span>dest<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>3.7 新版功能.</p>
</li>
</ul>
<h3 id="Cursor-对象"><a href="#Cursor-对象" class="headerlink" title="Cursor 对象"></a>Cursor 对象</h3><p><em>class</em> <code>sqlite3.Cursor</code></p>
<p><code>Cursor</code> 游标实例具有以下属性和方法。</p>
<ul>
<li><p><code>execute</code>(<em>sql</em>[, <em>parameters</em>])</p>
<p>执行一条 SQL 语句。 可以使用 占位符 将值绑定到语句中。</p>
<p><code>execute()</code> 将只执行一条单独的 SQL 语句。 如果你尝试用它执行超过一条语句，将会引发 <code>Warning</code>。 如果你想要用一次调用执行多条 SQL 语句请使用 <code>executescript()</code>。</p>
</li>
<li><p><code>executemany</code>(<em>sql</em>, <em>seq_of_parameters</em>)</p>
<p>执行一条 带形参的 SQL 命令，使用所有形参序列或在序列 <em>seq_of_parameters</em> 中找到的映射。 <code>sqlite3</code> 模块还允许使用 iterator 代替序列来产生形参。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> sqlite3
<span class="token keyword">class</span> <span class="token class-name">IterChars</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>count <span class="token operator">=</span> ord<span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">)</span>
    <span class="token keyword">def</span> <span class="token function">__iter__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> self
    <span class="token keyword">def</span> <span class="token function">__next__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> self<span class="token punctuation">.</span>count <span class="token operator">></span> ord<span class="token punctuation">(</span><span class="token string">'z'</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">raise</span> StopIteration
        self<span class="token punctuation">.</span>count <span class="token operator">+=</span> <span class="token number">1</span>
        <span class="token keyword">return</span> <span class="token punctuation">(</span>chr<span class="token punctuation">(</span>self<span class="token punctuation">.</span>count <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># this is a 1-tuple</span>
con <span class="token operator">=</span> sqlite3<span class="token punctuation">.</span>connect<span class="token punctuation">(</span><span class="token string">":memory:"</span><span class="token punctuation">)</span>
cur <span class="token operator">=</span> con<span class="token punctuation">.</span>cursor<span class="token punctuation">(</span><span class="token punctuation">)</span>
cur<span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token string">"create table characters(c)"</span><span class="token punctuation">)</span>
theIter <span class="token operator">=</span> IterChars<span class="token punctuation">(</span><span class="token punctuation">)</span>
cur<span class="token punctuation">.</span>executemany<span class="token punctuation">(</span><span class="token string">"insert into characters(c) values (?)"</span><span class="token punctuation">,</span> theIter<span class="token punctuation">)</span>
cur<span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token string">"select c from characters"</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>fetchall<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
con<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这是一个使用生成器 generator 的简短示例：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> sqlite3
<span class="token keyword">import</span> string
<span class="token keyword">def</span> <span class="token function">char_generator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">for</span> c <span class="token keyword">in</span> string<span class="token punctuation">.</span>ascii_lowercase<span class="token punctuation">:</span>
        <span class="token keyword">yield</span> <span class="token punctuation">(</span>c<span class="token punctuation">,</span><span class="token punctuation">)</span>
con <span class="token operator">=</span> sqlite3<span class="token punctuation">.</span>connect<span class="token punctuation">(</span><span class="token string">":memory:"</span><span class="token punctuation">)</span>
cur <span class="token operator">=</span> con<span class="token punctuation">.</span>cursor<span class="token punctuation">(</span><span class="token punctuation">)</span>
cur<span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token string">"create table characters(c)"</span><span class="token punctuation">)</span>
cur<span class="token punctuation">.</span>executemany<span class="token punctuation">(</span><span class="token string">"insert into characters(c) values (?)"</span><span class="token punctuation">,</span> char_generator<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
cur<span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token string">"select c from characters"</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>fetchall<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
con<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><code>executescript</code>(<em>sql_script</em>)</p>
<p>这是用于一次性执行多条 SQL 语句的非标准便捷方法。 它会首先发出一条 <code>COMMIT</code> 语句，然后执行通过参数获得的 SQL 脚本。 此方法会忽略 <code>isolation_level</code>；任何事件控制都必须被添加到 <em>sql_script</em>。</p>
<p><em>sql_script</em> 可以是一个 <a href="https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#str" target="_blank" rel="noopener"><code>str</code></a> 类的实例。</p>
<p>示例:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> sqlite3
con <span class="token operator">=</span> sqlite3<span class="token punctuation">.</span>connect<span class="token punctuation">(</span><span class="token string">":memory:"</span><span class="token punctuation">)</span>
cur <span class="token operator">=</span> con<span class="token punctuation">.</span>cursor<span class="token punctuation">(</span><span class="token punctuation">)</span>
cur<span class="token punctuation">.</span>executescript<span class="token punctuation">(</span><span class="token triple-quoted-string string">"""
    create table person(
        firstname,
        lastname,
        age
    );
    create table book(
        title,
        author,
        published
    );
    insert into book(title, author, published)
    values (
        'Dirk Gently''s Holistic Detective Agency',
        'Douglas Adams',
        1987
    );
    """</span><span class="token punctuation">)</span>
con<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><code>fetchone</code>()</p>
<p>获取一个查询结果集的下一行，返回一个单独序列，或是在没有更多可用数据时返回 <code>None</code>。</p>
</li>
<li><p><code>fetchmany</code>(<em>size=cursor.arraysize</em>)</p>
<p>获取下一个多行查询结果集，返回一个列表。 当没有更多可用行时将返回一个空列表。</p>
<p>每次调用获取的行数由 <em>size</em> 形参指定。 如果没有给出该形参，则由 cursor 的 arraysize 决定要获取的行数。 此方法将基于 size 形参值尝试获取指定数量的行。 如果获取不到指定的行数，则可能返回较少的行。</p>
<p>请注意 <em>size</em> 形参会涉及到性能方面的考虑。为了获得优化的性能，通常最好是使用 arraysize 属性。 如果使用 <em>size</em> 形参，则最好在从一个 <code>fetchmany()</code> 调用到下一个调用之间保持相同的值。</p>
</li>
<li><p><code>fetchall</code>()</p>
<p>获取一个查询结果的所有（剩余）行，返回一个列表。 请注意 cursor 的 arraysize 属性会影响此操作的执行效率。 当没有可用行时将返回一个空列表。</p>
</li>
<li><p><code>close</code>()</p>
<p>立即关闭 cursor（而不是在当 <code>__del__</code> 被调用的时候）。</p>
<p>从这一时刻起该 cursor 将不再可用，如果再尝试用该 cursor 执行任何操作将引发 <code>ProgrammingError</code> 异常。</p>
</li>
<li><p><code>rowcount</code></p>
<p>虽然 <code>sqlite3</code> 模块的 <code>Cursor</code> 类实现了此属性，但数据库引擎本身对于确定 “受影响行”/“已选择行” 的支持并不完善。</p>
<p>对于 <code>executemany()</code> 语句，修改行数会被汇总至 <code>rowcount</code>。</p>
<p>根据 Python DB API 规格描述的要求，<code>rowcount</code> 属性 “当未在 cursor 上执行 <code>executeXX()</code> 或者上一次操作的 rowcount 不是由接口确定时为 -1”。 这包括 <code>SELECT</code> 语句，因为我们无法确定一次查询将产生的行计数，而要等获取了所有行时才会知道。</p>
</li>
<li><p><code>lastrowid</code></p>
<p>这个只读属性会提供最近修改行的 rowid。 它只在你使用 <code>execute()</code> 方法执行 <code>INSERT</code> 或 <code>REPLACE</code> 语句时会被设置。 对于 <code>INSERT</code> 或 <code>REPLACE</code> 以外的操作或者当 <code>executemany()</code> 被调用时，<code>lastrowid</code> 会被设为 <code>None</code>。</p>
<p>如果 <code>INSERT</code> 或 <code>REPLACE</code> 语句操作失败则将返回上一次成功操作的 rowid。</p>
<p>在 3.6 版更改: 增加了 <code>REPLACE</code> 语句的支持。</p>
</li>
<li><p><code>arraysize</code></p>
<p>用于控制 <code>fetchmany()</code> 返回行数的可读取/写入属性。 该属性的默认值为 1，表示每次调用将获取单独一行。</p>
</li>
<li><p><code>description</code></p>
<p>这个只读属性将提供上一次查询的列名称。 为了与 Python DB API 保持兼容，它会为每个列返回一个 7 元组，每个元组的最后六个条目均为 <code>None</code>。</p>
<p>对于没有任何匹配行的 <code>SELECT</code> 语句同样会设置该属性。</p>
</li>
<li><p><code>connection</code></p>
<p>这个只读属性将提供 <code>Cursor</code> 对象所使用的 SQLite 数据库 <code>Connection</code>。 通过调用 <code>con.cursor()</code> 创建的 <code>Cursor</code> 对象所包含的 <code>connection</code> 属性将指向 <em>con</em>:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> con <span class="token operator">=</span> sqlite3<span class="token punctuation">.</span>connect<span class="token punctuation">(</span><span class="token string">":memory:"</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> cur <span class="token operator">=</span> con<span class="token punctuation">.</span>cursor<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> cur<span class="token punctuation">.</span>connection <span class="token operator">==</span> con
<span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
<h3 id="行对象"><a href="#行对象" class="headerlink" title="行对象"></a>行对象</h3><p><em>class</em> <code>sqlite3.Row</code></p>
<p>一个 <code>Row</code> 实例，该实例将作为用于 <code>Connection</code> 对象的高度优化的 <code>row_factory</code>。 它的大部分行为都会模仿元组的特性。</p>
<p>它支持使用列名称的映射访问以及索引、迭代、文本表示、相等检测和 <code>len()</code> 等操作。</p>
<p>如果两个 <code>Row</code> 对象具有完全相同的列并且其成员均相等，则它们的比较结果为相等。</p>
<ul>
<li><p><code>keys</code>()</p>
<p>此方法会在一次查询之后立即返回一个列名称的列表，它是 <code>Cursor.description</code> 中每个元组的第一个成员。</p>
</li>
</ul>
<p>在 3.5 版更改: 添加了对切片操作的支持。</p>
<p>让我们假设我们如上面的例子所示初始化一个表:</p>
<pre class="line-numbers language-python"><code class="language-python">con <span class="token operator">=</span> sqlite3<span class="token punctuation">.</span>connect<span class="token punctuation">(</span><span class="token string">":memory:"</span><span class="token punctuation">)</span>
cur <span class="token operator">=</span> con<span class="token punctuation">.</span>cursor<span class="token punctuation">(</span><span class="token punctuation">)</span>
cur<span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token triple-quoted-string string">'''create table stocks
(date text, trans text, symbol text,
 qty real, price real)'''</span><span class="token punctuation">)</span>
cur<span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token triple-quoted-string string">"""insert into stocks
            values ('2006-01-05','BUY','RHAT',100,35.14)"""</span><span class="token punctuation">)</span>
con<span class="token punctuation">.</span>commit<span class="token punctuation">(</span><span class="token punctuation">)</span>
cur<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>现在我们将 <code>Row</code> 插入:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> con<span class="token punctuation">.</span>row_factory <span class="token operator">=</span> sqlite3<span class="token punctuation">.</span>Row
<span class="token operator">>></span><span class="token operator">></span> cur <span class="token operator">=</span> con<span class="token punctuation">.</span>cursor<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> cur<span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token string">'select * from stocks'</span><span class="token punctuation">)</span>
<span class="token operator">&lt;</span>sqlite3<span class="token punctuation">.</span>Cursor object at <span class="token number">0x7f4e7dd8fa80</span><span class="token operator">></span>
<span class="token operator">>></span><span class="token operator">></span> r <span class="token operator">=</span> cur<span class="token punctuation">.</span>fetchone<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> type<span class="token punctuation">(</span>r<span class="token punctuation">)</span>
<span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token string">'sqlite3.Row'</span><span class="token operator">></span>
<span class="token operator">>></span><span class="token operator">></span> tuple<span class="token punctuation">(</span>r<span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token string">'2006-01-05'</span><span class="token punctuation">,</span> <span class="token string">'BUY'</span><span class="token punctuation">,</span> <span class="token string">'RHAT'</span><span class="token punctuation">,</span> <span class="token number">100.0</span><span class="token punctuation">,</span> <span class="token number">35.14</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> len<span class="token punctuation">(</span>r<span class="token punctuation">)</span>
<span class="token number">5</span>
<span class="token operator">>></span><span class="token operator">></span> r<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span>
<span class="token string">'RHAT'</span>
<span class="token operator">>></span><span class="token operator">></span> r<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token string">'date'</span><span class="token punctuation">,</span> <span class="token string">'trans'</span><span class="token punctuation">,</span> <span class="token string">'symbol'</span><span class="token punctuation">,</span> <span class="token string">'qty'</span><span class="token punctuation">,</span> <span class="token string">'price'</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> r<span class="token punctuation">[</span><span class="token string">'qty'</span><span class="token punctuation">]</span>
<span class="token number">100.0</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">for</span> member <span class="token keyword">in</span> r<span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">print</span><span class="token punctuation">(</span>member<span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token number">2006</span><span class="token operator">-</span><span class="token number">01</span><span class="token operator">-</span><span class="token number">05</span>
BUY
RHAT
<span class="token number">100.0</span>
<span class="token number">35.14</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p><em>exception</em> <code>sqlite3.Warning</code></p>
<p><code>Exception</code> 的一个子类。</p>
<p><em>exception</em> <code>sqlite3.Error</code></p>
<p>此模块中其他异常的基类。 它是 <code>Exception</code> 的一个子类。</p>
<p><em>exception</em> <code>sqlite3.DatabaseError</code></p>
<p>针对数据库相关错误引发的异常。</p>
<p><em>exception</em> <code>sqlite3.IntegrityError</code></p>
<p>当数据库的关系一致性受到影响时引发的异常。 例如外键检查失败等。 它是 <code>DatabaseError</code> 的子类。</p>
<p><em>exception</em> <code>sqlite3.ProgrammingError</code></p>
<p>编程错误引发的异常，例如表未找到或已存在，SQL 语句存在语法错误，指定的形参数量错误等。 它是 <code>DatabaseError</code> 的子类。</p>
<p><em>exception</em> <code>sqlite3.OperationalError</code></p>
<p>与数据库操作相关而不一定能受程序员掌控的错误引发的异常，例如发生非预期的连接中断，数据源名称未找到，事务无法被执行等。 它是 <code>DatabaseError</code> 的子类。</p>
<p><em>exception</em> <code>sqlite3.NotSupportedError</code></p>
<p>在使用了某个数据库不支持的方法或数据库 API 时引发的异常，例如在一个不支持事务或禁用了事务的连接上调用 <code>rollback()</code> 方法等。 它是 <code>DatabaseError</code> 的子类。</p>
<h3 id="SQLite-与-Python-类型"><a href="#SQLite-与-Python-类型" class="headerlink" title="SQLite 与 Python 类型"></a>SQLite 与 Python 类型</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>SQLite 原生支持如下的类型： <code>NULL</code>，<code>INTEGER</code>，<code>REAL</code>，<code>TEXT</code>，<code>BLOB</code>。</p>
<p>因此可以将以下Python类型发送到SQLite而不会出现任何问题：</p>
<table>
<thead>
<tr>
<th align="left">Python 类型</th>
<th align="left">SQLite 类型</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>None</code></td>
<td align="left"><code>NULL</code></td>
</tr>
<tr>
<td align="left"><code>int</code></td>
<td align="left"><code>INTEGER</code></td>
</tr>
<tr>
<td align="left"><code>float</code></td>
<td align="left"><code>REAL</code></td>
</tr>
<tr>
<td align="left"><code>str</code></td>
<td align="left"><code>TEXT</code></td>
</tr>
<tr>
<td align="left"><code>bytes</code></td>
<td align="left"><code>BLOB</code></td>
</tr>
</tbody></table>
<p>这是SQLite类型默认转换为Python类型的方式：</p>
<table>
<thead>
<tr>
<th align="left">SQLite 类型</th>
<th align="left">Python 类型</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>NULL</code></td>
<td align="left"><code>None</code></td>
</tr>
<tr>
<td align="left"><code>INTEGER</code></td>
<td align="left"><code>int</code></td>
</tr>
<tr>
<td align="left"><code>REAL</code></td>
<td align="left"><code>float</code></td>
</tr>
<tr>
<td align="left"><code>TEXT</code></td>
<td align="left">取决于 <code>text_factory</code> , 默认为 <code>str</code></td>
</tr>
<tr>
<td align="left"><code>BLOB</code></td>
<td align="left"><code>bytes</code></td>
</tr>
</tbody></table>
<p><code>sqlite3</code> 模块的类型系统可通过两种方式来扩展：你可以通过对象适配将额外的 Python 类型保存在 SQLite 数据库中，你也可以让 <code>sqlite3</code> 模块通过转换器将 SQLite 类型转换为不同的 Python 类型。</p>
<h4 id="使用适配器将额外的-Python-类型保存在-SQLite-数据库中。"><a href="#使用适配器将额外的-Python-类型保存在-SQLite-数据库中。" class="headerlink" title="使用适配器将额外的 Python 类型保存在 SQLite 数据库中。"></a>使用适配器将额外的 Python 类型保存在 SQLite 数据库中。</h4><p>如上文所述，SQLite 只包含对有限类型集的原生支持。 要让 SQLite 能使用其他 Python 类型，你必须将它们 <strong>适配</strong> 至 sqlite3 模块所支持的 SQLite 类型中的一种：NoneType, int, float, str, bytes。</p>
<p>有两种方式能让 <code>sqlite3</code> 模块将某个定制的 Python 类型适配为受支持的类型。</p>
<h5 id="让对象自行适配"><a href="#让对象自行适配" class="headerlink" title="让对象自行适配"></a>让对象自行适配</h5><p>如果类是你自己编写的，这将是一个很好的方式。 假设你有这样一个类:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Point</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>x<span class="token punctuation">,</span> self<span class="token punctuation">.</span>y <span class="token operator">=</span> x<span class="token punctuation">,</span> y<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>现在你可将这种点对象保存在一个 SQLite 列中。 首先你必须选择一种受支持的类型用来表示点对象。 让我们就用 str 并使用一个分号来分隔坐标值。 然后你需要给你的类加一个方法 <code>__conform__(self, protocol)</code>，它必须返回转换后的值。 形参 <em>protocol</em> 将为 <code>PrepareProtocol</code>。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> sqlite3
<span class="token keyword">class</span> <span class="token class-name">Point</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>x<span class="token punctuation">,</span> self<span class="token punctuation">.</span>y <span class="token operator">=</span> x<span class="token punctuation">,</span> y
    <span class="token keyword">def</span> <span class="token function">__conform__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> protocol<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> protocol <span class="token keyword">is</span> sqlite3<span class="token punctuation">.</span>PrepareProtocol<span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token string">"%f;%f"</span> <span class="token operator">%</span> <span class="token punctuation">(</span>self<span class="token punctuation">.</span>x<span class="token punctuation">,</span> self<span class="token punctuation">.</span>y<span class="token punctuation">)</span>
con <span class="token operator">=</span> sqlite3<span class="token punctuation">.</span>connect<span class="token punctuation">(</span><span class="token string">":memory:"</span><span class="token punctuation">)</span>
cur <span class="token operator">=</span> con<span class="token punctuation">.</span>cursor<span class="token punctuation">(</span><span class="token punctuation">)</span>
p <span class="token operator">=</span> Point<span class="token punctuation">(</span><span class="token number">4.0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">3.2</span><span class="token punctuation">)</span>
cur<span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token string">"select ?"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>p<span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>fetchone<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
con<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h5 id="注册可调用的适配器"><a href="#注册可调用的适配器" class="headerlink" title="注册可调用的适配器"></a>注册可调用的适配器</h5><p>另一种可能的做法是创建一个将该类型转换为字符串表示的函数并使用 <code>register_adapter()</code> 注册该函数。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> sqlite3
<span class="token keyword">class</span> <span class="token class-name">Point</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>x<span class="token punctuation">,</span> self<span class="token punctuation">.</span>y <span class="token operator">=</span> x<span class="token punctuation">,</span> y
<span class="token keyword">def</span> <span class="token function">adapt_point</span><span class="token punctuation">(</span>point<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">return</span> <span class="token string">"%f;%f"</span> <span class="token operator">%</span> <span class="token punctuation">(</span>point<span class="token punctuation">.</span>x<span class="token punctuation">,</span> point<span class="token punctuation">.</span>y<span class="token punctuation">)</span>
sqlite3<span class="token punctuation">.</span>register_adapter<span class="token punctuation">(</span>Point<span class="token punctuation">,</span> adapt_point<span class="token punctuation">)</span>
con <span class="token operator">=</span> sqlite3<span class="token punctuation">.</span>connect<span class="token punctuation">(</span><span class="token string">":memory:"</span><span class="token punctuation">)</span>
cur <span class="token operator">=</span> con<span class="token punctuation">.</span>cursor<span class="token punctuation">(</span><span class="token punctuation">)</span>
p <span class="token operator">=</span> Point<span class="token punctuation">(</span><span class="token number">4.0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">3.2</span><span class="token punctuation">)</span>
cur<span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token string">"select ?"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>p<span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>fetchone<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
con<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>sqlite3</code> 模块有两个适配器可用于 Python 的内置 <code>datetime.date</code> 和 <code>datetime.datetime</code> 类型。 现在假设我们想要存储 <code>datetime.datetime</code> 对象，但不是表示为 ISO 格式，而是表示为 Unix 时间戳。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> sqlite3
<span class="token keyword">import</span> datetime
<span class="token keyword">import</span> time
<span class="token keyword">def</span> <span class="token function">adapt_datetime</span><span class="token punctuation">(</span>ts<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">return</span> time<span class="token punctuation">.</span>mktime<span class="token punctuation">(</span>ts<span class="token punctuation">.</span>timetuple<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
sqlite3<span class="token punctuation">.</span>register_adapter<span class="token punctuation">(</span>datetime<span class="token punctuation">.</span>datetime<span class="token punctuation">,</span> adapt_datetime<span class="token punctuation">)</span>
con <span class="token operator">=</span> sqlite3<span class="token punctuation">.</span>connect<span class="token punctuation">(</span><span class="token string">":memory:"</span><span class="token punctuation">)</span>
cur <span class="token operator">=</span> con<span class="token punctuation">.</span>cursor<span class="token punctuation">(</span><span class="token punctuation">)</span>
now <span class="token operator">=</span> datetime<span class="token punctuation">.</span>datetime<span class="token punctuation">.</span>now<span class="token punctuation">(</span><span class="token punctuation">)</span>
cur<span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token string">"select ?"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>now<span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>fetchone<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
con<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="将SQLite-值转换为自定义Python-类型"><a href="#将SQLite-值转换为自定义Python-类型" class="headerlink" title="将SQLite 值转换为自定义Python 类型"></a>将SQLite 值转换为自定义Python 类型</h4><p>编写适配器让你可以将定制的 Python 类型发送给 SQLite。 但要令它真正有用，我们需要实现从 Python 到 SQLite 再回到 Python 的双向转换。</p>
<p>输入转换器。</p>
<p>让我们回到 <code>Point</code> 类。 我们以字符串形式在 SQLite 中存储了 x 和 y 坐标值。</p>
<p>首先，我们将定义一个转换器函数，它接受这样的字符串作为形参并根据该参数构造一个 <code>Point</code> 对象。</p>
<p>注解</p>
<p>转换器函数在调用时 <strong>总是</strong> 会附带一个 <code>bytes</code> 对象，无论你将何种数据类型的值发给 SQLite。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">convert_point</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">:</span>
    x<span class="token punctuation">,</span> y <span class="token operator">=</span> map<span class="token punctuation">(</span>float<span class="token punctuation">,</span> s<span class="token punctuation">.</span>split<span class="token punctuation">(</span>b<span class="token string">";"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> Point<span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>现在你需要让 <code>sqlite3</code> 模块知道你从数据库中选取的其实是一个点对象。 有两种方式都可以做到这件事：</p>
<ul>
<li>隐式的声明类型</li>
<li>显式的通过列名</li>
</ul>
<p>下面的示例说明了这两种方法。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> sqlite3
<span class="token keyword">class</span> <span class="token class-name">Point</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>x<span class="token punctuation">,</span> self<span class="token punctuation">.</span>y <span class="token operator">=</span> x<span class="token punctuation">,</span> y
    <span class="token keyword">def</span> <span class="token function">__repr__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token string">"(%f;%f)"</span> <span class="token operator">%</span> <span class="token punctuation">(</span>self<span class="token punctuation">.</span>x<span class="token punctuation">,</span> self<span class="token punctuation">.</span>y<span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">adapt_point</span><span class="token punctuation">(</span>point<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token string">"%f;%f"</span> <span class="token operator">%</span> <span class="token punctuation">(</span>point<span class="token punctuation">.</span>x<span class="token punctuation">,</span> point<span class="token punctuation">.</span>y<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token string">'ascii'</span><span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">convert_point</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">:</span>
    x<span class="token punctuation">,</span> y <span class="token operator">=</span> list<span class="token punctuation">(</span>map<span class="token punctuation">(</span>float<span class="token punctuation">,</span> s<span class="token punctuation">.</span>split<span class="token punctuation">(</span>b<span class="token string">";"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> Point<span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span>
<span class="token comment" spellcheck="true"># Register the adapter</span>
sqlite3<span class="token punctuation">.</span>register_adapter<span class="token punctuation">(</span>Point<span class="token punctuation">,</span> adapt_point<span class="token punctuation">)</span>
<span class="token comment" spellcheck="true"># Register the converter</span>
sqlite3<span class="token punctuation">.</span>register_converter<span class="token punctuation">(</span><span class="token string">"point"</span><span class="token punctuation">,</span> convert_point<span class="token punctuation">)</span>
p <span class="token operator">=</span> Point<span class="token punctuation">(</span><span class="token number">4.0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">3.2</span><span class="token punctuation">)</span>
<span class="token comment" spellcheck="true">#########################</span>
<span class="token comment" spellcheck="true"># 1) Using declared types</span>
con <span class="token operator">=</span> sqlite3<span class="token punctuation">.</span>connect<span class="token punctuation">(</span><span class="token string">":memory:"</span><span class="token punctuation">,</span> detect_types<span class="token operator">=</span>sqlite3<span class="token punctuation">.</span>PARSE_DECLTYPES<span class="token punctuation">)</span>
cur <span class="token operator">=</span> con<span class="token punctuation">.</span>cursor<span class="token punctuation">(</span><span class="token punctuation">)</span>
cur<span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token string">"create table test(p point)"</span><span class="token punctuation">)</span>
cur<span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token string">"insert into test(p) values (?)"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>p<span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
cur<span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token string">"select p from test"</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"with declared types:"</span><span class="token punctuation">,</span> cur<span class="token punctuation">.</span>fetchone<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
cur<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>
con<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment" spellcheck="true">#######################</span>
<span class="token comment" spellcheck="true"># 1) Using column names</span>
con <span class="token operator">=</span> sqlite3<span class="token punctuation">.</span>connect<span class="token punctuation">(</span><span class="token string">":memory:"</span><span class="token punctuation">,</span> detect_types<span class="token operator">=</span>sqlite3<span class="token punctuation">.</span>PARSE_COLNAMES<span class="token punctuation">)</span>
cur <span class="token operator">=</span> con<span class="token punctuation">.</span>cursor<span class="token punctuation">(</span><span class="token punctuation">)</span>
cur<span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token string">"create table test(p)"</span><span class="token punctuation">)</span>
cur<span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token string">"insert into test(p) values (?)"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>p<span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
cur<span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token string">'select p as "p [point]" from test'</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"with column names:"</span><span class="token punctuation">,</span> cur<span class="token punctuation">.</span>fetchone<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
cur<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>
con<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="默认适配器和转换器"><a href="#默认适配器和转换器" class="headerlink" title="默认适配器和转换器"></a>默认适配器和转换器</h4><p>对于 datetime 模块中的 date 和 datetime 类型已提供了默认的适配器。 它们将会以 ISO 日期/ISO 时间戳的形式发给 SQLite。</p>
<p>默认转换器使用的注册名称是针对 <code>datetime.date</code> 的 “date” 和针对 <code>datetime.datetime</code> 的 “timestamp”。</p>
<p>通过这种方式，你可以在大多数情况下使用 Python 的 date/timestamp 对象而无须任何额外处理。 适配器的格式还与实验性的 SQLite date/time 函数兼容。</p>
<p>下面的示例演示了这一点。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> sqlite3
<span class="token keyword">import</span> datetime
con <span class="token operator">=</span> sqlite3<span class="token punctuation">.</span>connect<span class="token punctuation">(</span><span class="token string">":memory:"</span><span class="token punctuation">,</span> detect_types<span class="token operator">=</span>sqlite3<span class="token punctuation">.</span>PARSE_DECLTYPES<span class="token operator">|</span>sqlite3<span class="token punctuation">.</span>PARSE_COLNAMES<span class="token punctuation">)</span>
cur <span class="token operator">=</span> con<span class="token punctuation">.</span>cursor<span class="token punctuation">(</span><span class="token punctuation">)</span>
cur<span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token string">"create table test(d date, ts timestamp)"</span><span class="token punctuation">)</span>
today <span class="token operator">=</span> datetime<span class="token punctuation">.</span>date<span class="token punctuation">.</span>today<span class="token punctuation">(</span><span class="token punctuation">)</span>
now <span class="token operator">=</span> datetime<span class="token punctuation">.</span>datetime<span class="token punctuation">.</span>now<span class="token punctuation">(</span><span class="token punctuation">)</span>
cur<span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token string">"insert into test(d, ts) values (?, ?)"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>today<span class="token punctuation">,</span> now<span class="token punctuation">)</span><span class="token punctuation">)</span>
cur<span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token string">"select d, ts from test"</span><span class="token punctuation">)</span>
row <span class="token operator">=</span> cur<span class="token punctuation">.</span>fetchone<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>today<span class="token punctuation">,</span> <span class="token string">"=>"</span><span class="token punctuation">,</span> row<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> type<span class="token punctuation">(</span>row<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>now<span class="token punctuation">,</span> <span class="token string">"=>"</span><span class="token punctuation">,</span> row<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> type<span class="token punctuation">(</span>row<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
cur<span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token string">'select current_date as "d [date]", current_timestamp as "ts [timestamp]"'</span><span class="token punctuation">)</span>
row <span class="token operator">=</span> cur<span class="token punctuation">.</span>fetchone<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"current_date"</span><span class="token punctuation">,</span> row<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> type<span class="token punctuation">(</span>row<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"current_timestamp"</span><span class="token punctuation">,</span> row<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> type<span class="token punctuation">(</span>row<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
con<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果存储在 SQLite 中的时间戳的小数位多于 6 个数字，则时间戳转换器会将该值截断至微秒精度。</p>
<h3 id="控制事务"><a href="#控制事务" class="headerlink" title="控制事务"></a>控制事务</h3><p>底层的 <code>sqlite3</code> 库默认会以 <code>autocommit</code> 模式运行，但 Python 的 <code>sqlite3</code> 模块默认则不使用此模式。</p>
<p><code>autocommit</code> 模式意味着修改数据库的操作会立即生效。 <code>BEGIN</code> 或 <code>SAVEPOINT</code> 语句会禁用 <code>autocommit</code> 模式，而用于结束外层事务的 <code>COMMIT</code>, <code>ROLLBACK</code> 或 <code>RELEASE</code> 则会恢复 <code>autocommit</code> 模式。</p>
<p>Python 的 <code>sqlite3</code> 模块默认会在数据修改语言 (DML) 类语句 (即 <code>INSERT</code>/<code>UPDATE</code>/<code>DELETE</code>/<code>REPLACE</code>) 之前隐式地执行一条 <code>BEGIN</code> 语句。</p>
<p>你可以控制 <code>sqlite3</code> 隐式执行的 <code>BEGIN</code> 语句的种类，具体做法是通过将 <em>isolation_level</em> 形参传给 <code>connect()</code> 调用，或者通过指定连接的 <code>isolation_level</code> 属性。 如果你没有指定 <em>isolation_level</em>，将使用基本的 <code>BEGIN</code>，它等价于指定 <code>DEFERRED</code>。 其他可能的值为 <code>IMMEDIATE</code> 和 <code>EXCLUSIVE</code>。</p>
<p>你可以禁用 <code>sqlite3</code> 模块的隐式事务管理，具体做法是将 <code>isolation_level</code> 设为 <code>None</code>。 这将使得下层的 <code>sqlite3</code> 库采用 <code>autocommit</code> 模式。 随后你可以通过在代码中显式地使用 <code>BEGIN</code>, <code>ROLLBACK</code>, <code>SAVEPOINT</code> 和 <code>RELEASE</code> 语句来完全控制事务状态。</p>
<p>请注意 <code>executescript()</code> 会忽略 <code>isolation_level</code>；任何事务控制必要要显式地添加。</p>
<p>在 3.6 版更改: 以前 <code>sqlite3</code> 会在 DDL 语句之前隐式地提交未完成事务。 现在则不会再这样做。</p>
<h3 id="有效使用-sqlite3"><a href="#有效使用-sqlite3" class="headerlink" title="有效使用 sqlite3"></a>有效使用 <code>sqlite3</code></h3><h4 id="使用快捷方式"><a href="#使用快捷方式" class="headerlink" title="使用快捷方式"></a>使用快捷方式</h4><p>使用 <code>Connection</code> 对象的非标准 <code>execute()</code>, <code>executemany()</code> 和 <code>executescript()</code> 方法，可以更简洁地编写代码，因为不必显式创建（通常是多余的） <code>Cursor</code> 对象。相反， <code>Cursor</code> 对象是隐式创建的，这些快捷方法返回游标对象。这样，只需对 <code>Connection</code> 对象调用一次，就能直接执行 <code>SELECT</code> 语句并遍历对象。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> sqlite3
langs <span class="token operator">=</span> <span class="token punctuation">[</span>
    <span class="token punctuation">(</span><span class="token string">"C++"</span><span class="token punctuation">,</span> <span class="token number">1985</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">(</span><span class="token string">"Objective-C"</span><span class="token punctuation">,</span> <span class="token number">1984</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">]</span>
con <span class="token operator">=</span> sqlite3<span class="token punctuation">.</span>connect<span class="token punctuation">(</span><span class="token string">":memory:"</span><span class="token punctuation">)</span>
<span class="token comment" spellcheck="true"># Create the table</span>
con<span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token string">"create table lang(name, first_appeared)"</span><span class="token punctuation">)</span>
<span class="token comment" spellcheck="true"># Fill the table</span>
con<span class="token punctuation">.</span>executemany<span class="token punctuation">(</span><span class="token string">"insert into lang(name, first_appeared) values (?, ?)"</span><span class="token punctuation">,</span> langs<span class="token punctuation">)</span>
<span class="token comment" spellcheck="true"># Print the table contents</span>
<span class="token keyword">for</span> row <span class="token keyword">in</span> con<span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token string">"select name, first_appeared from lang"</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>row<span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"I just deleted"</span><span class="token punctuation">,</span> con<span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token string">"delete from lang"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>rowcount<span class="token punctuation">,</span> <span class="token string">"rows"</span><span class="token punctuation">)</span>
<span class="token comment" spellcheck="true"># close is not a shortcut method and it's not called automatically,</span>
<span class="token comment" spellcheck="true"># so the connection object should be closed manually</span>
con<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="通过名称而不是索引访问索引"><a href="#通过名称而不是索引访问索引" class="headerlink" title="通过名称而不是索引访问索引"></a>通过名称而不是索引访问索引</h4><p><code>sqlite3</code> 模块的一个有用功能是内置的 <code>sqlite3.Row</code> 类，它被设计用作行对象的工厂。</p>
<p>该类的行装饰器可以用索引（如元组）和不区分大小写的名称访问：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> sqlite3
con <span class="token operator">=</span> sqlite3<span class="token punctuation">.</span>connect<span class="token punctuation">(</span><span class="token string">":memory:"</span><span class="token punctuation">)</span>
con<span class="token punctuation">.</span>row_factory <span class="token operator">=</span> sqlite3<span class="token punctuation">.</span>Row
cur <span class="token operator">=</span> con<span class="token punctuation">.</span>cursor<span class="token punctuation">(</span><span class="token punctuation">)</span>
cur<span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token string">"select 'John' as name, 42 as age"</span><span class="token punctuation">)</span>
<span class="token keyword">for</span> row <span class="token keyword">in</span> cur<span class="token punctuation">:</span>
    <span class="token keyword">assert</span> row<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> row<span class="token punctuation">[</span><span class="token string">"name"</span><span class="token punctuation">]</span>
    <span class="token keyword">assert</span> row<span class="token punctuation">[</span><span class="token string">"name"</span><span class="token punctuation">]</span> <span class="token operator">==</span> row<span class="token punctuation">[</span><span class="token string">"nAmE"</span><span class="token punctuation">]</span>
    <span class="token keyword">assert</span> row<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> row<span class="token punctuation">[</span><span class="token string">"age"</span><span class="token punctuation">]</span>
    <span class="token keyword">assert</span> row<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> row<span class="token punctuation">[</span><span class="token string">"AgE"</span><span class="token punctuation">]</span>
con<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="使用连接作为上下文管理器"><a href="#使用连接作为上下文管理器" class="headerlink" title="使用连接作为上下文管理器"></a>使用连接作为上下文管理器</h4><p>连接对象可以用来作为上下文管理器，它可以自动提交或者回滚事务。如果出现异常，事务会被回滚；否则，事务会被提交。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> sqlite3
con <span class="token operator">=</span> sqlite3<span class="token punctuation">.</span>connect<span class="token punctuation">(</span><span class="token string">":memory:"</span><span class="token punctuation">)</span>
con<span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token string">"create table lang (id integer primary key, name varchar unique)"</span><span class="token punctuation">)</span>
<span class="token comment" spellcheck="true"># Successful, con.commit() is called automatically afterwards</span>
<span class="token keyword">with</span> con<span class="token punctuation">:</span>
    con<span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token string">"insert into lang(name) values (?)"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">"Python"</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment" spellcheck="true"># con.rollback() is called after the with block finishes with an exception, the</span>
<span class="token comment" spellcheck="true"># exception is still raised and must be caught</span>
<span class="token keyword">try</span><span class="token punctuation">:</span>
    <span class="token keyword">with</span> con<span class="token punctuation">:</span>
        con<span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token string">"insert into lang(name) values (?)"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">"Python"</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">except</span> sqlite3<span class="token punctuation">.</span>IntegrityError<span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"couldn't add Python twice"</span><span class="token punctuation">)</span>
<span class="token comment" spellcheck="true"># Connection object used as context manager only commits or rollbacks transactions,</span>
<span class="token comment" spellcheck="true"># so the connection object should be closed manually</span>
con<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="数据压缩和存档"><a href="#数据压缩和存档" class="headerlink" title="数据压缩和存档"></a>数据压缩和存档</h1><ul>
<li><code>zlib</code> —- 与 <strong>gzip</strong> 兼容的压缩</li>
<li><code>gzip</code> —- 对 <strong>gzip</strong> 格式的支持<ul>
<li>用法示例</li>
<li>命令行界面<ul>
<li>命令行选项</li>
</ul>
</li>
</ul>
</li>
<li><code>bz2</code> —- 对 <strong>bzip2</strong> 压缩算法的支持<ul>
<li>文件压缩和解压</li>
<li>增量压缩和解压</li>
<li>一次性压缩或解压缩</li>
<li>用法示例</li>
</ul>
</li>
<li><code>lzma</code> —- 用 LZMA 算法压缩<ul>
<li>读写压缩文件</li>
<li>在内存中压缩和解压缩数据</li>
<li>杂项</li>
<li>指定自定义的过滤器链</li>
<li>例子</li>
</ul>
</li>
<li><code>zipfile</code> —- 使用ZIP存档<ul>
<li>ZipFile 对象</li>
<li>Path 对象</li>
<li>PyZipFile 对象</li>
<li>ZipInfo 对象</li>
<li>命令行接口<ul>
<li>命令行选项</li>
</ul>
</li>
<li>解压缩的障碍<ul>
<li>由于文件本身</li>
<li>文件系统限制</li>
<li>资源限制</li>
<li>中断</li>
<li>提取的默认行为</li>
</ul>
</li>
</ul>
</li>
<li><code>tarfile</code> —- 读写tar归档文件<ul>
<li>TarFile 对象</li>
<li>TarInfo 对象</li>
<li>命令行接口<ul>
<li>命令行选项</li>
</ul>
</li>
<li>例子</li>
<li>受支持的 tar 格式</li>
<li>Unicode 问题</li>
</ul>
</li>
</ul>
<h2 id="zlib-—-与-gzip-兼容的压缩"><a href="#zlib-—-与-gzip-兼容的压缩" class="headerlink" title="zlib —- 与 gzip 兼容的压缩"></a><code>zlib</code> —- 与 <strong>gzip</strong> 兼容的压缩</h2><p>对于需要数据压缩的应用，此模块中的函数允许使用 zlib 库进行压缩和解压缩。 zlib 库的项目主页是 <a href="https://www.zlib.net/" target="_blank" rel="noopener">https://www.zlib.net</a>。 已知此 Python 模块与 1.1.3 之前版本的 zlib 库存在不兼容；1.1.3 版则存在一个 <a href="https://zlib.net/zlib_faq.html#faq33" target="_blank" rel="noopener">安全缺陷</a>，因此我们推荐使用 1.1.4 或更新的版本。</p>
<p>zlib 的函数有很多选项，一般需要按特定顺序使用。本文档没有覆盖全部的用法。更多详细信息请于 <a href="http://www.zlib.net/manual.html" target="_blank" rel="noopener">http://www.zlib.net/manual.html</a> 参阅官方手册。</p>
<p>此模块中可用的异常和函数如下：</p>
<p><em>exception</em> <code>zlib.error</code></p>
<p>在压缩或解压缩过程中发生错误时的异常。</p>
<p><code>zlib.adler32</code>(<em>data</em>[, <em>value</em>])</p>
<p>计算 <em>data</em> 的 Adler-32 校验值。(Adler-32 校验的可靠性与 CRC32 基本相当，但比计算 CRC32 更高效。) 计算的结果是一个 32 位的整数。参数 <em>value</em> 是校验时的起始值，其默认值为 1。借助参数 <em>value</em> 可为分段的输入计算校验值。此算法没有加密强度，不应用于身份验证和数字签名。此算法的目的仅为验证数据的正确性，不适合作为通用散列算法。</p>
<p>在 3.0 版更改: 返回值永远是无符号数。要在所有的 Python 版本和平台上获得相同的值，请使用 <code>adler32(data) &amp; 0xffffffff</code>。</p>
<p><code>zlib.compress</code>(<em>data</em>, <em>/</em>, <em>level=-1</em>)</p>
<p>压缩 <em>data</em> 中的字节，返回含有已压缩内容的 bytes 对象。参数 <em>level</em> 为整数，可取值为 <code>0</code> 到 <code>9</code> 或 <code>-1</code>，用于指定压缩等级。<code>1</code> (Z_BEST_SPEED) 表示最快速度和最低压缩率，<code>9</code> (Z_BEST_COMPRESSION) 表示最慢速度和最高压缩率。<code>0</code> (Z_NO_COMPRESSION) 表示不压缩。参数默认值为 <code>-1</code> (Z_DEFAULT_COMPRESSION)。Z_DEFAULT_COMPRESSION 是速度和压缩率之间的平衡 (一般相当于设压缩等级为 6)。函数发生错误时抛出 <code>error</code> 异常。</p>
<p>在 3.6 版更改: 现在，<em>level</em> 可作为关键字参数。</p>
<p><code>zlib.compressobj</code>(<em>level=-1</em>, <em>method=DEFLATED</em>, <em>wbits=MAX_WBITS</em>, <em>memLevel=DEF_MEM_LEVEL</em>, <em>strategy=Z_DEFAULT_STRATEGY</em>[, <em>zdict</em>])</p>
<p>返回一个 压缩对象，用来压缩内存中难以容下的数据流。</p>
<p>参数 <em>level</em> 为压缩等级，是整数，可取值为 <code>0</code> 到 <code>9</code> 或 <code>-1</code>。<code>1</code> (Z_BEST_SPEED) 表示最快速度和最低压缩率，<code>9</code> (Z_BEST_COMPRESSION) 表示最慢速度和最高压缩率。<code>0</code> (Z_NO_COMPRESSION) 表示不压缩。参数默认值为 <code>-1</code> (Z_DEFAULT_COMPRESSION)。Z_DEFAULT_COMPRESSION 是速度和压缩率之间的平衡 (一般相当于设压缩等级为 6)。</p>
<p><em>method</em> 表示压缩算法。现在只支持 <code>DEFLATED</code> 这个算法。</p>
<p>参数 <em>wbits</em> 指定压缩数据时所使用的历史缓冲区的大小 (窗口大小)，并指定压缩输出是否包含头部或尾部。参数的默认值是 <code>15</code> (MAX_WBITS)。参数的值分为几个范围：</p>
<ul>
<li>+9 至 +15：窗口大小以二为底的对数。 即这些值对应着 512 至 32768 的窗口大小。 更大的值会提供更好的压缩，同时内存开销也会更大。 压缩输出会包含 zlib 特定格式的头部和尾部。</li>
<li>−9 至 −15：绝对值为窗口大小以二为底的对数。 压缩输出仅包含压缩数据，没有头部和尾部。</li>
<li>+25 至 +31 = 16 + (9 至 15)：后 4 个比特位为窗口大小以二为底的对数。 压缩输出包含一个基本的 <strong>gzip</strong> 头部，并以校验和为尾部。</li>
</ul>
<p>参数 <em>memLevel</em> 指定内部压缩操作时所占用内存大小。参数取 <code>1</code> 到 <code>9</code>。更大的值占用更多的内存，同时速度也更快输出也更小。</p>
<p>参数 <em>strategy</em> 用于调节压缩算法。可取值为 <code>Z_DEFAULT_STRATEGY</code>、<code>Z_FILTERED</code>、<code>Z_HUFFMAN_ONLY</code>、<code>Z_RLE</code> (zlib 1.2.0.1) 或 <code>Z_FIXED</code> (zlib 1.2.2.2)。</p>
<p>参数 <em>zdict</em> 指定预定义的压缩字典。它是一个字节序列 (如 <code>bytes</code> 对象)，其中包含用户认为要压缩的数据中可能频繁出现的子序列。频率高的子序列应当放在字典的尾部。</p>
<p>在 3.3 版更改: 添加关键字参数 <em>zdict</em>。</p>
<p><code>zlib.crc32</code>(<em>data</em>[, <em>value</em>])</p>
<p>计算 <em>data</em> 的 CRC (循环冗余校验) 值。计算的结果是一个 32 位的整数。参数 <em>value</em> 是校验时的起始值，其默认值为 0。借助参数 <em>value</em> 可为分段的输入计算校验值。此算法没有加密强度，不应用于身份验证和数字签名。此算法的目的仅为验证数据的正确性，不适合作为通用散列算法。</p>
<p>在 3.0 版更改: 返回值永远是无符号数。要在所有的 Python 版本和平台上获得相同的值，请使用 <code>crc32(data) &amp; 0xffffffff</code>。</p>
<p><code>zlib.decompress</code>(<em>data</em>, <em>/</em>, <em>wbits=MAX_WBITS</em>, <em>bufsize=DEF_BUF_SIZE</em>)</p>
<p>解压 <em>data</em> 中的字节，返回含有已解压内容的 bytes 对象。参数 <em>wbits</em> 取决于 <em>data</em> 的格式，具体参见下边的说明。<em>bufsize</em> 为输出缓冲区的起始大小。函数发生错误时抛出 <code>error</code> 异常。</p>
<p><em>wbits</em> 形参控制历史缓冲区的大小（或称“窗口大小”）以及所期望的头部和尾部格式。 它类似于 <code>compressobj()</code> 的形参，但可接受更大范围的值：</p>
<ul>
<li>+8 至 +15：窗口尺寸以二为底的对数。 输入必须包含 zlib 头部和尾部。</li>
<li>0：根据 zlib 头部自动确定窗口大小。 只从 zlib 1.2.3.5 版起受支持。</li>
<li>−8 至 −15：使用 <em>wbits</em> 的绝对值作为窗口大小以二为底的对数。 输入必须为原始数据流，没有头部和尾部。</li>
<li>+24 至 +31 = 16 + (8 至 15)：使用后 4 个比特位作为窗口大小以二为底的对数。 输入必须包括 gzip 头部和尾部。</li>
<li>+40 至 +47 = 32 + (8 至 15)：使用后 4 个比特位作为窗口大小以二为底的对数，并且自动接受 zlib 或 gzip 格式。</li>
</ul>
<p>当解压缩一个数据流时，窗口大小必须不小于用于压缩数据流的原始窗口大小；使用太小的值可能导致 <code>error</code> 异常。 默认 <em>wbits</em> 值对应于最大的窗口大小并且要求包括 zlib 头部和尾部。</p>
<p><em>bufsize</em> 是用于存放解压数据的缓冲区初始大小。 如果需要更大空间，缓冲区大小将按需增加，因此你不需要让这个值完全精确；对其进行调整仅会节省一点对 <code>malloc()</code> 的调用次数。</p>
<p>在 3.6 版更改: <em>wbits</em> 和 <em>bufsize</em> 可用作关键字参数。</p>
<p><code>zlib.decompressobj</code>(<em>wbits=MAX_WBITS</em>[, <em>zdict</em>])</p>
<p>返回一个解压对象，用来解压无法被一次性放入内存的数据流。</p>
<p><em>wbits</em> 形参控制历史缓冲区的大小（或称“窗口大小”）以及所期望的头部和尾部格式。 它的含义与 对 decompress() 的描述 相同。</p>
<p><em>zdict</em> 形参指定指定一个预定义的压缩字典。 如果提供了此形参，它必须与产生将解压数据的压缩器所使用的字典相同。</p>
<p>注解</p>
<p>如果 <em>zdict</em> 是一个可变对象 (例如 <code>bytearray</code>)，则你不可在对 <code>decompressobj()</code> 的调用和对解压器的 <code>decompress()</code> 方法的调用之间修改其内容。</p>
<p>在 3.3 版更改: 增加了 <em>zdict</em> 形参。</p>
<p>压缩对象支持以下方法：</p>
<p><code>Compress.compress</code>(<em>data</em>)</p>
<p>压缩 <em>data</em> 并返回 bytes 对象，这个对象含有 <em>data</em> 的部分或全部内容的已压缩数据。所得的对象必须拼接在上一次调用 <code>compress()</code> 方法所得数据的后面。缓冲区中可能留存部分输入以供下一次调用。</p>
<p><code>Compress.flush</code>([<em>mode</em>])</p>
<p>压缩所有缓冲区的数据并返回已压缩的数据。参数 <em>mode</em> 可以传入的常量为：<code>Z_NO_FLUSH</code>、<code>Z_PARTIAL_FLUSH</code>、<code>Z_SYNC_FLUSH</code>、<code>Z_FULL_FLUSH</code>、<code>Z_BLOCK</code> (zlib 1.2.3.4) 或 <code>Z_FINISH</code>。默认值为 <code>Z_FINISH</code>。<code>Z_FINISH</code> 关闭已压缩数据流并不允许再压缩其他数据，<code>Z_FINISH</code> 以外的值皆允许这个对象继续压缩数据。调用 <code>flush()</code> 方法并将 <em>mode</em> 设为 <code>Z_FINISH</code> 后会无法再次调用 <code>compress()</code>，此时只能删除这个对象。</p>
<p><code>Compress.copy</code>()</p>
<p>返回此压缩对象的一个拷贝。它可以用来高效压缩一系列拥有相同前缀的数据。</p>
<p>在 3.8 版更改: 添加了对压缩对象执行 <code>copy.copy()</code> 和 <code>copy.deepcopy()</code> 的支持。</p>
<p>解压缩对象支持以下方法：</p>
<pre><code>Decompress.unused_data</code></pre><p>一个 bytes 对象，其中包含压缩数据结束之后的任何字节数据。 也就是说，它将为 <code>b""</code> 直到包含压缩数据的末尾字节可用。 如果整个结果字节串都包含压缩数据，它将为一个空的 bytes 对象 <code>b""</code>。</p>
<pre><code>Decompress.unconsumed_tail</code></pre><p>一个 bytes 对象，其中包含未被上一次 <code>decompress()</code> 调用所消耗的任何数据。 此数据不能被 zlib 机制看到，因此你必须将其送回（可能要附带额外的数据拼接）到后续的 <code>decompress()</code> 方法调用以获得正确的输出。</p>
<pre><code>Decompress.eof</code></pre><p>一个布尔值，指明是否已到达压缩数据流的末尾。</p>
<p>这使得区分正确构造的压缩数据流和不完整或被截断的压缩数据流成为可能。</p>
<p>3.3 新版功能.</p>
<p><code>Decompress.decompress</code>(<em>data</em>, <em>max_length=0</em>)</p>
<p>解压缩 <em>data</em> 并返回 bytes 对象，其中包含对应于 <em>string</em> 中至少一部分数据的解压缩数据。 此数据应当被拼接到之前任何对 <code>decompress()</code> 方法的调用所产生的输出。 部分输入数据可能会被保留在内部缓冲区以供后续处理。</p>
<p>如果可选的形参 <em>max_length</em> 非零则返回值将不会长于 <em>max_length*。 这可能意味着不是所有已压缩输入都能被处理；并且未被消耗的数据将被保存在 <code>unconsumed_tail</code> 属性中。 如果要继续解压缩则这个字节串必须被传给对 <code>decompress()</code> 的后续调用。 如果 *max_length</em> 为零则整个输入都会被解压缩，并且 <code>unconsumed_tail</code> 将为空。</p>
<p>在 3.6 版更改: <em>max_length</em> 可用作关键字参数。</p>
<p><code>Decompress.flush</code>([<em>length</em>])</p>
<p>所有挂起的输入会被处理，并且返回包含剩余未压缩输出的 bytes 对象。 在调用 <code>flush()</code> 之后，<code>decompress()</code> 方法将无法被再次调用；唯一可行的操作是删除该对象。</p>
<p>可选的形参 <em>length</em> 设置输出缓冲区的初始大小。</p>
<p><code>Decompress.copy</code>()</p>
<p>返回解压缩对象的一个拷贝。 它可以用来在数据流的中途保存解压缩器的状态以便加快随机查找数据流后续位置的速度。</p>
<p>在 3.8 版更改: 添加了对解压缩对象执行 <code>copy.copy()</code> 和 <code>copy.deepcopy()</code> 的支持。</p>
<p>通过下列常量可获取模块所使用的 zlib 库的版本信息：</p>
<pre><code>zlib.ZLIB_VERSION</code></pre><p>构建此模块时所用的 zlib 库的版本字符串。它的值可能与运行时所加载的 zlib 不同。运行时加载的 zlib 库的版本字符串为 <code>ZLIB_RUNTIME_VERSION</code>。</p>
<pre><code>zlib.ZLIB_RUNTIME_VERSION</code></pre><p>解释器所加载的 zlib 库的版本字符串。</p>
<p>3.3 新版功能.</p>
<p>参见</p>
<p><a href="http://www.zlib.net/" target="_blank" rel="noopener">http://www.zlib.net</a></p>
<p>zlib 库项目主页。</p>
<p><a href="http://www.zlib.net/manual.html" target="_blank" rel="noopener">http://www.zlib.net/manual.html</a></p>
<p>zlib 库用户手册。提供了库的许多功能的解释和用法。</p>
<h2 id="gzip-—-对-gzip-格式的支持"><a href="#gzip-—-对-gzip-格式的支持" class="headerlink" title="gzip —- 对 gzip 格式的支持"></a><code>gzip</code> —- 对 <strong>gzip</strong> 格式的支持</h2><p><strong>源代码：</strong> <a href="https://github.com/python/cpython/tree/3.10/Lib/gzip.py" target="_blank" rel="noopener">Lib/gzip.py</a></p>
<hr>
<p>此模块提供的简单接口帮助用户压缩和解压缩文件，功能类似于 GNU 应用程序 <strong>gzip</strong> 和 <strong>gunzip</strong>。</p>
<p>数据压缩由 <code>zlib</code> 模块提供。</p>
<p><code>gzip</code> 模块提供 <code>GzipFile</code> 类和 <code>open()</code>、<code>compress()</code>、<code>decompress()</code> 几个便利的函数。<code>GzipFile</code> 类可以读写 <strong>gzip</strong> 格式的文件，还能自动压缩和解压缩数据，这让操作压缩文件如同操作普通的 file object 一样方便。</p>
<p>注意，此模块不支持部分可以被 <strong>gzip</strong> 和 <strong>gunzip</strong> 解压的格式，如利用 <strong>compress</strong> 或 <strong>pack</strong> 压缩所得的文件。</p>
<p>这个模块定义了以下内容：</p>
<p><code>gzip.open</code>(<em>filename</em>, <em>mode=’rb’</em>, <em>compresslevel=9</em>, <em>encoding=None</em>, <em>errors=None</em>, <em>newline=None</em>)</p>
<p>以二进制方式或者文本方式打开一个 gzip 格式的压缩文件，返回一个 file object。</p>
<p><em>filename</em> 参数可以是一个实际的文件名(一个a <code>str</code> 对象或者 <code>bytes</code> 对象), 或者是一个用来读写的已存在的文件对象。</p>
<p><em>mode</em> 参数可以是二进制模式： <code>'r'</code>, <code>'rb'</code>, <code>'a'</code>, <code>'ab'</code>, <code>'w'</code>, <code>'wb'</code>, <code>'x'</code> or <code>'xb'</code> , 或者是文本模式 <code>'rt'</code>, <code>'at'</code>, <code>'wt'</code>, or <code>'xt'</code>。默认值是 <code>'rb'</code>。</p>
<p>The <em>compresslevel</em> argument is an integer from 0 to 9, as for the <code>GzipFile</code> constructor.</p>
<p>对于二进制模式，这个函数等价于 <code>GzipFile</code> 构造器：<code>GzipFile(filename, mode, compresslevel)</code>。在这个例子中，<em>encoding</em>, <em>errors</em> 和 <em>newline</em> 三个参数一定不要设置。</p>
<p>对于文本模式，将会创建一个 <code>GzipFile</code> 对象，并将它封装到一个 <code>io.TextIOWrapper</code> 实例中， 这个实例默认了指定编码，错误抓获行为和行。</p>
<p>在 3.3 版更改: 支持 <em>filename</em> 为一个文件对象，支持文本模式和 <em>encoding</em>, <em>errors</em> 和 <em>newline</em> 参数。</p>
<p>在 3.4 版更改: 支持 <code>'x'</code>, <code>'xb'</code> 和<code>‘xt’</code> 三种模式。</p>
<p>在 3.6 版更改: 接受一个 path-like object。</p>
<p><em>exception</em> <code>gzip.BadGzipFile</code></p>
<p>针对无效 gzip 文件引发的异常。 它继承自 <code>OSError</code>。 针对无效 gzip 文件也可能引发 <code>EOFError</code> 和 <code>zlib.error</code>。</p>
<p>3.8 新版功能.</p>
<p><em>class</em> <code>gzip.GzipFile</code>(<em>filename=None</em>, <em>mode=None</em>, <em>compresslevel=9</em>, <em>fileobj=None</em>, <em>mtime=None</em>)</p>
<p><code>GzipFile</code> 类的构造器支持 <code>truncate()</code> 的异常，与 file object 的大多数方法非常相似。<em>fileobj</em> 和 <em>filename</em> 至少有一个不为空。</p>
<p>新的实例基于 <em>fileobj*，它可以是一个普通文件，一个 <code>io.BytesIO</code> 对象，或者任何一个与文件相似的对象。当 *filename</em> 是一个文件对象时，它的默认值是 <code>None</code>。</p>
<p>当 <em>fileobj</em> 为 <code>None</code> 时， <em>filename</em> 参数只用于 <strong>gzip</strong> 文件头中，这个文件有可能包含未压缩文件的源文件名。如果文件可以被识别，默认 <em>fileobj</em> 的文件名；否则默认为空字符串，在这种情况下文件头将不包含源文件名。</p>
<p><em>mode</em> 参数可以是 <code>'r'</code>, <code>'rb'</code>, <code>'a'</code>, <code>'ab'</code>, <code>'w'</code>, <code>'wb'</code>, <code>'x'</code> 或 <code>'xb'</code> 中的一个，具体取决于文件将被读取还是被写入。 如果可识别则默认为 <em>fileobj</em> 的模式；否则默认为 <code>'rb'</code>。 在未来的 Python 发布版中将不再使用 <em>fileobj</em> 的模式。 最好总是指定 <em>mode</em> 为写入模式。</p>
<p>需要注意的是，文件默认使用二进制模式打开。如果要以文本模式打开文件一个压缩文件，请使用 <code>open()</code> 方法(或者使用 <code>io.TextIOWrapper</code> 包装 <code>GzipFile</code> )。</p>
<p><em>compresslevel</em> 参数是一个从 <code>0</code> 到 <code>9</code> 的整数，用于控制压缩等级；<code>1</code> 最快但压缩比例最小，<code>9</code> 最慢但压缩比例最大。 <code>0</code> 不压缩。默认为 <code>9</code>。</p>
<p><em>mtime</em> 参数是一个可选的数字时间戳用于写入流的最后修改字段，。<em>mtime</em> 只在压缩模式中使用。如果省略或者值为 <code>None</code>，则使用当前时间。</p>
<p>调用 <code>GzipFile</code> 的 <code>close()</code> 方法不会关闭 <em>fileobj</em>，因为你可以希望增加其它内容到已经压缩的数中。你可以将一个 <code>io.BytesIO</code> 对象作为 <em>fileobj</em>，也可以使用 <code>io.BytesIO</code> 的 <code>getvalue()</code> 方法从内存缓存中恢复数据。</p>
<p><code>GzipFile</code> 支持 <code>io.BufferedIOBase</code> 类的接口, 包括迭代和 <code>with</code> 语句。只有 <code>truncate()</code> 方法没有实现。</p>
<p><code>GzipFile</code> 还提供了以下的方法和属性:</p>
<ul>
<li><p><code>peek</code>(<em>n</em>)</p>
<p>在不移动文件指针的情况下读取 <em>n</em> 个未压缩字节。最多只有一个单独的读取流来服务这个方法调用。返回的字节数不一定刚好等于要求的数量。</p>
<p>注解</p>
<p>调用 <code>peek()</code> 并没有改变 <code>GzipFile</code> 的文件指针，它可能改变潜在文件对象(例如： <code>GzipFile</code> 使用 <em>fileobj</em> 参数进行初始化)。</p>
<p>3.2 新版功能.</p>
</li>
<li><p><code>mtime</code></p>
<p>在解压的过程中，最后修改时间字段的值可能来自于这个属性，以整数的形式出现。在读取任何文件头信息前，初始值为 <code>None</code>。</p>
<p>所有 <strong>gzip</strong> 东方压缩流中必须包含时间戳这个字段。以便于像 <strong>gunzip</strong>这样的程序可以使用时间戳。格式与 <code>time.time()</code> 的返回值和 <code>os.stat()</code> 对象的 <code>st_mtime</code> 属性值一样。</p>
</li>
</ul>
<p>在 3.1 版更改: 支持 <code>with</code> 语句，构造器参数 <em>mtime</em> 和 <code>mtime</code> 属性。</p>
<p>在 3.2 版更改: 添加了对零填充和不可搜索文件的支持。</p>
<p>在 3.3 版更改: 实现 <code>io.BufferedIOBase.read1()</code> 方法。</p>
<p>在 3.4 版更改: 支持 <code>'x'</code> and <code>'xb'</code> 两种模式。</p>
<p>在 3.5 版更改: 支持写入任意 bytes-like objects。<code>read()</code> 方法可以接受<code>None</code>为参数。</p>
<p>在 3.6 版更改: 接受一个 path-like object。</p>
<p>3.9 版后已移除: 打开 <code>GzipFile</code> 用于写入而不指定 <em>mode</em> 参数的做法已被弃用。</p>
<p><code>gzip.compress</code>(<em>data</em>, <em>compresslevel=9</em>, <em>**,</em> mtime=None*)</p>
<p>压缩 <em>data*，返回一个包含压缩数据的 <code>bytes</code> 对象。 *compresslevel</em> 和 <em>mtime</em> 的含义与上文中 <code>GzipFile</code> 构造器的相同。</p>
<p>3.2 新版功能.</p>
<p>在 3.8 版更改: 添加了 <em>mtime</em> 形参用于可重复的输出。</p>
<p><code>gzip.decompress</code>(<em>data</em>)</p>
<p>解压缩 <em>data</em>，返回一个包含未压缩数据的 <code>bytes</code> 对象。</p>
<p>3.2 新版功能.</p>
<h3 id="用法示例"><a href="#用法示例" class="headerlink" title="用法示例"></a>用法示例</h3><p>读取压缩文件示例：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> gzip
<span class="token keyword">with</span> gzip<span class="token punctuation">.</span>open<span class="token punctuation">(</span><span class="token string">'/home/joe/file.txt.gz'</span><span class="token punctuation">,</span> <span class="token string">'rb'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span>
    file_content <span class="token operator">=</span> f<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>创建GZIP 文件示例：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> gzip
content <span class="token operator">=</span> b<span class="token string">"Lots of content here"</span>
<span class="token keyword">with</span> gzip<span class="token punctuation">.</span>open<span class="token punctuation">(</span><span class="token string">'/home/joe/file.txt.gz'</span><span class="token punctuation">,</span> <span class="token string">'wb'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span>
    f<span class="token punctuation">.</span>write<span class="token punctuation">(</span>content<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>使用 GZIP 压缩已有的文件示例：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> gzip
<span class="token keyword">import</span> shutil
<span class="token keyword">with</span> open<span class="token punctuation">(</span><span class="token string">'/home/joe/file.txt'</span><span class="token punctuation">,</span> <span class="token string">'rb'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f_in<span class="token punctuation">:</span>
    <span class="token keyword">with</span> gzip<span class="token punctuation">.</span>open<span class="token punctuation">(</span><span class="token string">'/home/joe/file.txt.gz'</span><span class="token punctuation">,</span> <span class="token string">'wb'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f_out<span class="token punctuation">:</span>
        shutil<span class="token punctuation">.</span>copyfileobj<span class="token punctuation">(</span>f_in<span class="token punctuation">,</span> f_out<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>使用 GZIP 压缩二进制字符串示例：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> gzip
s_in <span class="token operator">=</span> b<span class="token string">"Lots of content here"</span>
s_out <span class="token operator">=</span> gzip<span class="token punctuation">.</span>compress<span class="token punctuation">(</span>s_in<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h3 id="命令行界面"><a href="#命令行界面" class="headerlink" title="命令行界面"></a>命令行界面</h3><p><code>gzip</code> 模块提供了简单的命令行界面用于压缩和解压缩文件。</p>
<p>在执行后 <code>gzip</code> 模块会保留输入文件。</p>
<p>在 3.8 版更改: 添加一个带有用法说明的新命令行界面命令。 默认情况下，当你要执行 CLI 时，默认压缩等级为 6。</p>
<h4 id="命令行选项"><a href="#命令行选项" class="headerlink" title="命令行选项"></a>命令行选项</h4><pre><code>file</code></pre><p>如果 <em>file</em> 未指定，则从 <code>sys.stdin</code> 读取。</p>
<pre><code>--fast</code></pre><p>指明最快速的压缩方法（较低压缩率）。</p>
<pre><code>--best</code></pre><p>指明最慢速的压缩方法（最高压缩率）。</p>
<pre><code>-d``,` `--decompress</code></pre><p>解压缩给定的文件。</p>
<pre><code>-h``,` `--help</code></pre><p>显示帮助消息。</p>
<h2 id="bz2-—-对-bzip2-压缩算法的支持"><a href="#bz2-—-对-bzip2-压缩算法的支持" class="headerlink" title="bz2 —- 对 bzip2 压缩算法的支持"></a><code>bz2</code> —- 对 <strong>bzip2</strong> 压缩算法的支持</h2><p><strong>源代码：</strong> <a href="https://github.com/python/cpython/tree/3.10/Lib/bz2.py" target="_blank" rel="noopener">Lib/bz2.py</a></p>
<hr>
<p>此模块提供了使用 bzip2 压缩算法压缩和解压数据的一套完整的接口。</p>
<p><code>bz2</code> 模块包含：</p>
<ul>
<li>用于读写压缩文件的 <code>open()</code> 函数和 <code>BZ2File</code> 类。</li>
<li>用于增量压缩和解压的 <code>BZ2Compressor</code> 和 <code>BZ2Decompressor</code> 类。</li>
<li>用于一次性压缩和解压的 <code>compress()</code> 和 <code>decompress()</code> 函数。</li>
</ul>
<h3 id="文件压缩和解压"><a href="#文件压缩和解压" class="headerlink" title="文件压缩和解压"></a>文件压缩和解压</h3><p><code>bz2.open</code>(<em>filename</em>, <em>mode=’rb’</em>, <em>compresslevel=9</em>, <em>encoding=None</em>, <em>errors=None</em>, <em>newline=None</em>)</p>
<p>以二进制或文本模式打开 bzip2 压缩文件，返回一个 file object。</p>
<p>和 <code>BZ2File</code> 的构造函数类似，<em>filename</em> 参数可以是一个实际的文件名（<code>str</code> 或 <code>bytes</code> 对象），或是已有的可供读取或写入的文件对象。</p>
<p><em>mode</em> 参数可设为二进制模式的 <code>'r'</code>、<code>'rb'</code>、<code>'w'</code>、<code>'wb'</code>、<code>'x'</code>、<code>'xb'</code>、<code>'a'</code> 或 <code>'ab'</code>，或者文本模式的 <code>'rt'</code>、<code>'wt'</code>、<code>'xt'</code> 或 <code>'at'</code>。默认是 <code>'rb'</code>。</p>
<p><em>compresslevel</em> 参数是 1 到 9 的整数，和 <code>BZ2File</code> 的构造函数一样。</p>
<p>对于二进制模式，这个函数等价于 <code>BZ2File</code> 构造器: <code>BZ2File(filename, mode, compresslevel=compresslevel)</code>。 在这种情况下，不可提供 <em>encoding</em>, <em>errors</em> 和 <em>newline</em> 参数。</p>
<p>对于文本模式，将会创建一个 <code>BZ2File</code> 对象，并将它包装到一个 <code>io.TextIOWrapper</code> 实例中，此实例带有指定的编码格式、错误处理行为和行结束符。</p>
<p>3.3 新版功能.</p>
<p>在 3.4 版更改: 添加了 <code>'x'</code> (单独创建) 模式。</p>
<p>在 3.6 版更改: 接受一个 path-like object。</p>
<p><em>class</em> <code>bz2.BZ2File</code>(<em>filename</em>, <em>mode=’r’</em>, <em>**,</em> compresslevel=9*)</p>
<p>用二进制模式打开 bzip2 压缩文件。</p>
<p>如果 <em>filename</em> 是一个 <code>str</code> 或 <code>bytes</code> 对象，则打开名称对应的文件目录。 否则的话，<em>filename</em> 应当是一个 file object，它将被用来读取或写入压缩数据。</p>
<p><em>mode</em> 参数可以是表示读取的 <code>'r'</code> (默认值)，表示覆写的 <code>'w'</code>，表示单独创建的 <code>'x'</code>，或表示添加的 <code>'a'</code>。 这些模式还可分别以 <code>'rb'</code>, <code>'wb'</code>, <code>'xb'</code> 和 <code>'ab'</code> 的等价形式给出。</p>
<p>如果 <em>filename</em> 是一个文件对象（而不是实际的文件名），则 <code>'w'</code> 模式并不会截断文件，而是会等价于 <code>'a'</code>。</p>
<p>如果 <em>mode</em> 为 <code>'w'</code> 或 <code>'a'</code>，则 <em>compresslevel</em> 可以是 <code>1</code> 到 <code>9</code> 之间的整数，用于指定压缩等级: <code>1</code> 产生最低压缩率，而 <code>9</code> (默认值) 产生最高压缩率。</p>
<p>如果 <em>mode</em> 为 <code>'r'</code>，则输入文件可以为多个压缩流的拼接。</p>
<p><code>BZ2File</code> 提供了 <code>io.BufferedIOBase</code> 所指定的所有成员，但 <code>detach()</code> 和 <code>truncate()</code> 除外。 并支持迭代和 <code>with</code> 语句。</p>
<p><code>BZ2File</code> 还提供了以下方法：</p>
<ul>
<li><p><code>peek</code>([<em>n</em>])</p>
<p>返回缓冲的数据而不前移文件位置。 至少将返回一个字节的数据（除非为 EOF）。 实际返回的字节数不确定。</p>
<p>注解</p>
<p>虽然调用 <code>peek()</code> 不会改变 <code>BZ2File</code> 的文件位置，但它可能改变下层文件对象的位置（举例来说如果 <code>BZ2File</code> 是通过传入一个文件对象作为 <em>filename</em> 的话）。</p>
<p>3.3 新版功能.</p>
</li>
</ul>
<p>在 3.1 版更改: 添加了对 <code>with</code> 语句的支持。</p>
<p>在 3.3 版更改: 添加了 <code>fileno()</code>, <code>readable()</code>, <code>seekable()</code>, <code>writable()</code>, <code>read1()</code> 和 <code>readinto()</code> 方法。</p>
<p>在 3.3 版更改: 添加了对 <em>filename</em> 使用 file object 而非实际文件名的支持。</p>
<p>在 3.3 版更改: 添加了 <code>'a'</code> (append) 模式，以及对读取多数据流文件的支持。</p>
<p>在 3.4 版更改: 添加了 <code>'x'</code> (单独创建) 模式。</p>
<p>在 3.5 版更改: <code>read()</code> 方法现在接受 <code>None</code> 作为参数。</p>
<p>在 3.6 版更改: 接受一个 path-like object。</p>
<p>在 3.9 版更改: <em>buffering</em> 形参已被移除。 它自 Python 3.0 起即被忽略并弃用。 请传入一个打开文件对象来控制文件的打开方式。</p>
<p><em>compresslevel</em> 形参成为仅限关键字参数。</p>
<p>在 3.10 版更改: 这个类在面对多个同时读取器和写入器时是线程安全的，就如它在 <code>gzip</code> 和 <code>lzma</code> 中的等价类所具有的特性一样。</p>
<h3 id="增量压缩和解压"><a href="#增量压缩和解压" class="headerlink" title="增量压缩和解压"></a>增量压缩和解压</h3><p><em>class</em> <code>bz2.BZ2Compressor</code>(<em>compresslevel=9</em>)</p>
<p>创建一个新的压缩器对象。 此对象可被用来执行增量数据压缩。 对于一次性压缩，请改用 <code>compress()</code> 函数。</p>
<p>如果给定 <em>compresslevel</em>，它必须为 <code>1</code> 至 <code>9</code> 之间的整数。 默认值为 <code>9</code>。</p>
<ul>
<li><p><code>compress</code>(<em>data</em>)</p>
<p>向压缩器对象提供数据。 在可能的情况下返回一段已压缩数据，否则返回空字节串。</p>
<p>当你已结束向压缩器提供数据时，请调用 <code>flush()</code> 方法来完成压缩进程。</p>
</li>
<li><p><code>flush</code>()</p>
<p>结束压缩进程，返回内部缓冲中剩余的压缩完成的数据。</p>
<p>调用此方法之后压缩器对象将不可再被使用。</p>
</li>
</ul>
<p><em>class</em> <code>bz2.BZ2Decompressor</code></p>
<p>创建一个新的解压缩器对象。 此对象可被用来执行增量数据解压缩。 对于一次性解压缩，请改用 <code>decompress()</code> 函数。</p>
<p>注解</p>
<p>这个类不会透明地处理包含多个已压缩数据流的输入，这不同于 <code>decompress()</code> 和 <code>BZ2File</code>。 如果你需要通过 <code>BZ2Decompressor</code> 来解压缩多个数据流输入，你必须为每个数据流都使用新的解压缩器。</p>
<ul>
<li><p><code>decompress</code>(<em>data</em>, <em>max_length=- 1</em>)</p>
<p>解压缩 <em>data</em> (一个 bytes-like object)，返回字节串形式的解压缩数据。 某些 <em>data</em> 可以在内部被缓冲，以便用于后续的 <code>decompress()</code> 调用。 返回的数据应当与之前任何 <code>decompress()</code> 调用的输出进行拼接。</p>
<p>如果 <em>max_length</em> 为非负数，将返回至多 <em>max_length</em> 个字节的解压缩数据。 如果达到此限制并且可以产生后续输出，则 <code>needs_input</code> 属性将被设为 <code>False</code>。 在这种情况下，下一次 <code>decompress()</code> 调用提供的 <em>data</em> 可以为 <code>b''</code> 以获取更多的输出。</p>
<p>如果所有输入数据都已被解压缩并返回（或是因为它少于 <em>max_length</em> 个字节，或是因为 <em>max_length</em> 为负数），则 <code>needs_input</code> 属性将被设为 <code>True</code>。</p>
<p>在到达数据流末尾之后再尝试解压缩数据会引发 EOFError。 在数据流末尾之后获取的任何数据都会被忽略并存储至 <code>unused_data</code> 属性。</p>
<p>在 3.5 版更改: 添加了 <em>max_length</em> 形参。</p>
</li>
<li><p><code>eof</code></p>
<p>若达到了数据流的末尾标记则为 <code>True</code>。</p>
<p>3.3 新版功能.</p>
</li>
<li><p><code>unused_data</code></p>
<p>在压缩数据流的末尾之后获取的数据。</p>
<p>如果在达到数据流末尾之前访问此属性，其值将为 <code>b''</code>。</p>
</li>
<li><p><code>needs_input</code></p>
<p>如果在要求新的未解压缩输入之前 <code>decompress()</code> 方法可以提供更多的解压缩数据则为 <code>False</code>。</p>
<p>3.5 新版功能.</p>
</li>
</ul>
<h3 id="一次性压缩或解压缩"><a href="#一次性压缩或解压缩" class="headerlink" title="一次性压缩或解压缩"></a>一次性压缩或解压缩</h3><p><code>bz2.compress</code>(<em>data</em>, <em>compresslevel=9</em>)</p>
<p>压缩 <em>data</em>，此参数为一个 字节类对象。</p>
<p>如果给定 <em>compresslevel</em>，它必须为 <code>1</code> 至 <code>9</code> 之间的整数。 默认值为 <code>9</code>。</p>
<p>对于增量压缩，请改用 <code>BZ2Compressor</code>。</p>
<p><code>bz2.decompress</code>(<em>data</em>)</p>
<p>解压缩 <em>data</em>，此参数为一个 字节类对象。</p>
<p>如果 <em>data</em> 是多个压缩数据流的拼接，则解压缩所有数据流。</p>
<p>对于增量解压缩，请改用 <code>BZ2Decompressor</code>。</p>
<p>在 3.3 版更改: 支持了多数据流的输入。</p>
<h3 id="用法示例-1"><a href="#用法示例-1" class="headerlink" title="用法示例"></a>用法示例</h3><p>以下是 <code>bz2</code> 模块典型用法的一些示例。</p>
<p>使用 <code>compress()</code> 和 <code>decompress()</code> 来显示往复式的压缩：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> bz2
<span class="token operator">>></span><span class="token operator">></span> data <span class="token operator">=</span> b<span class="token triple-quoted-string string">"""\
... Donec rhoncus quis sapien sit amet molestie. Fusce scelerisque vel augue
... nec ullamcorper. Nam rutrum pretium placerat. Aliquam vel tristique lorem,
... sit amet cursus ante. In interdum laoreet mi, sit amet ultrices purus
... pulvinar a. Nam gravida euismod magna, non varius justo tincidunt feugiat.
... Aliquam pharetra lacus non risus vehicula rutrum. Maecenas aliquam leo
... felis. Pellentesque semper nunc sit amet nibh ullamcorper, ac elementum
... dolor luctus. Curabitur lacinia mi ornare consectetur vestibulum."""</span>
<span class="token operator">>></span><span class="token operator">></span> c <span class="token operator">=</span> bz2<span class="token punctuation">.</span>compress<span class="token punctuation">(</span>data<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> len<span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token operator">/</span> len<span class="token punctuation">(</span>c<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># Data compression ratio</span>
<span class="token number">1.513595166163142</span>
<span class="token operator">>></span><span class="token operator">></span> d <span class="token operator">=</span> bz2<span class="token punctuation">.</span>decompress<span class="token punctuation">(</span>c<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> data <span class="token operator">==</span> d  <span class="token comment" spellcheck="true"># Check equality to original object after round-trip</span>
<span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>使用 <code>BZ2Compressor</code> 进行增量压缩：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> bz2
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">def</span> <span class="token function">gen_data</span><span class="token punctuation">(</span>chunks<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">,</span> chunksize<span class="token operator">=</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token triple-quoted-string string">"""Yield incremental blocks of chunksize bytes."""</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>chunks<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         <span class="token keyword">yield</span> b<span class="token string">"z"</span> <span class="token operator">*</span> chunksize
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> comp <span class="token operator">=</span> bz2<span class="token punctuation">.</span>BZ2Compressor<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> out <span class="token operator">=</span> b<span class="token string">""</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">for</span> chunk <span class="token keyword">in</span> gen_data<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token comment" spellcheck="true"># Provide data to the compressor object</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     out <span class="token operator">=</span> out <span class="token operator">+</span> comp<span class="token punctuation">.</span>compress<span class="token punctuation">(</span>chunk<span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token comment" spellcheck="true"># Finish the compression process.  Call this once you have</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token comment" spellcheck="true"># finished providing data to the compressor.</span>
<span class="token operator">>></span><span class="token operator">></span> out <span class="token operator">=</span> out <span class="token operator">+</span> comp<span class="token punctuation">.</span>flush<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>上面的示例使用了十分“非随机”的数据流（即 b”z” 块数据流）。 随机数据的压缩率通常很差，而有序、重复的数据通常会产生很高的压缩率。</p>
<p>用二进制模式写入和读取 bzip2 压缩文件：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> bz2
<span class="token operator">>></span><span class="token operator">></span> data <span class="token operator">=</span> b<span class="token triple-quoted-string string">"""\
... Donec rhoncus quis sapien sit amet molestie. Fusce scelerisque vel augue
... nec ullamcorper. Nam rutrum pretium placerat. Aliquam vel tristique lorem,
... sit amet cursus ante. In interdum laoreet mi, sit amet ultrices purus
... pulvinar a. Nam gravida euismod magna, non varius justo tincidunt feugiat.
... Aliquam pharetra lacus non risus vehicula rutrum. Maecenas aliquam leo
... felis. Pellentesque semper nunc sit amet nibh ullamcorper, ac elementum
... dolor luctus. Curabitur lacinia mi ornare consectetur vestibulum."""</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">with</span> bz2<span class="token punctuation">.</span>open<span class="token punctuation">(</span><span class="token string">"myfile.bz2"</span><span class="token punctuation">,</span> <span class="token string">"wb"</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token comment" spellcheck="true"># Write compressed data to file</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     unused <span class="token operator">=</span> f<span class="token punctuation">.</span>write<span class="token punctuation">(</span>data<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">with</span> bz2<span class="token punctuation">.</span>open<span class="token punctuation">(</span><span class="token string">"myfile.bz2"</span><span class="token punctuation">,</span> <span class="token string">"rb"</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token comment" spellcheck="true"># Decompress data from file</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     content <span class="token operator">=</span> f<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> content <span class="token operator">==</span> data  <span class="token comment" spellcheck="true"># Check equality to original object after round-trip</span>
<span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="lzma-—-用-LZMA-算法压缩"><a href="#lzma-—-用-LZMA-算法压缩" class="headerlink" title="lzma —- 用 LZMA 算法压缩"></a><code>lzma</code> —- 用 LZMA 算法压缩</h2><p>3.3 新版功能.</p>
<p><strong>源代码：</strong> <a href="https://github.com/python/cpython/tree/3.10/Lib/lzma.py" target="_blank" rel="noopener">Lib/lzma.py</a></p>
<hr>
<p>此模块提供了可以压缩和解压缩使用 LZMA 压缩算法的数据的类和便携函数。 其中还包含支持 <strong>xz</strong> 工具所使用的 <code>.xz</code> 和旧式 <code>.lzma</code> 文件格式的文件接口，以及相应的原始压缩数据流。</p>
<p>此模块所提供了接口与 <code>bz2</code> 模块的非常类似。 请注意 <code>LZMAFile</code> 和 <code>bz2.BZ2File</code> 都 <em>不是</em> 线程安全的。，因此如果你需要在多个线程中使用单个 <code>LZMAFile</code> 实例，则需要通过锁来保护它。</p>
<p><em>exception</em> <code>lzma.LZMAError</code></p>
<p>当在压缩或解压缩期间或是在初始化压缩器/解压缩器的状态期间发生错误时此异常会被引发。</p>
<h3 id="读写压缩文件"><a href="#读写压缩文件" class="headerlink" title="读写压缩文件"></a>读写压缩文件</h3><p><code>lzma.open</code>(<em>filename</em>, <em>mode=’rb’</em>, <em>**,</em> format=None<em>,</em> check=- 1<em>,</em> preset=None<em>,</em> filters=None<em>,</em> encoding=None<em>,</em> errors=None<em>,</em> newline=None*)</p>
<p>以二进制或文本模式打开 LZMA 压缩文件，返回一个 file object。</p>
<p><em>filename</em> 参数可以是一个实际的文件名（以 <code>str</code>, <code>bytes</code> 或 路径类 对象的形式给出），在此情况下会打开指定名称的文件，或者可以是一个用于读写的现有文件对象。</p>
<p><em>mode</em> 参数可以是二进制模式的 <code>"r"</code>, <code>"rb"</code>, <code>"w"</code>, <code>"wb"</code>, <code>"x"</code>, <code>"xb"</code>, <code>"a"</code> 或 <code>"ab"</code>，或者文本模式的 <code>"rt"</code>, <code>"wt"</code>, <code>"xt"</code> 或 <code>"at"</code>。 默认值为 <code>"rb"</code>。</p>
<p>当打开一个文件用于读取时，<em>format</em> 和 <em>filters</em> 参数具有与 <code>LZMADecompressor</code> 的参数相同的含义。 在此情况下，<em>check</em> 和 <em>preset</em> 参数不应被使用。</p>
<p>当打开一个文件用于写入的，<em>format</em>, <em>check</em>, <em>preset</em> 和 <em>filters</em> 参数具有与 <code>LZMACompressor</code> 的参数相同的含义。</p>
<p>对于二进制模式，这个函数等价于 <code>LZMAFile</code> 构造器: <code>LZMAFile(filename, mode, ...)</code>。 在这种情况下，不可提供 <em>encoding</em>, <em>errors</em> 和 <em>newline</em> 参数。</p>
<p>对于文本模式，将会创建一个 <code>LZMAFile</code> 对象，并将它包装到一个 <code>io.TextIOWrapper</code> 实例中，此实例带有指定的编码格式、错误处理行为和行结束符。</p>
<p>在 3.4 版更改: 增加了对 <code>"x"</code>, <code>"xb"</code> 和 <code>"xt"</code> 模式的支持。</p>
<p>在 3.6 版更改: 接受一个 path-like object。</p>
<p><em>class</em> <code>lzma.LZMAFile</code>(<em>filename=None</em>, <em>mode=’r’</em>, <em>**,</em> format=None<em>,</em> check=- 1<em>,</em> preset=None<em>,</em> filters=None*)</p>
<p>以二进制模式打开一个 LZMA 压缩文件。</p>
<p><code>LZMAFile</code> 可以包装在一个已打开的 file object 中，或者是在给定名称的文件上直接操作。 <em>filename</em> 参数指定所包装的文件对象，或是要打开的文件名称（类型为 <code>str</code>, <code>bytes</code> 或 路径类 对象）。 如果是包装现有的文件对象，被包装的文件在 <code>LZMAFile</code> 被关闭时将不会被关闭。</p>
<p><em>mode</em> 参数可以是表示读取的 <code>"r"</code> (默认值)，表示覆写的 <code>"w"</code>，表示单独创建的 <code>"x"</code>，或表示添加的 <code>"a"</code>。 这些模式还可以分别以 <code>"rb"</code>, <code>"wb"</code>, <code>"xb"</code> 和 <code>"ab"</code> 的等价形式给出。</p>
<p>如果 <em>filename</em> 是一个文件对象（而不是实际的文件名），则 <code>"w"</code> 模式并不会截断文件，而会等价于 <code>"a"</code>。</p>
<p>当打开一个文件用于读取时，输入文件可以为多个独立压缩流的拼接。 它们会被作为单个逻辑流被透明地解码。</p>
<p>当打开一个文件用于读取时，<em>format</em> 和 <em>filters</em> 参数具有与 <code>LZMADecompressor</code> 的参数相同的含义。 在此情况下，<em>check</em> 和 <em>preset</em> 参数不应被使用。</p>
<p>当打开一个文件用于写入的，<em>format</em>, <em>check</em>, <em>preset</em> 和 <em>filters</em> 参数具有与 <code>LZMACompressor</code> 的参数相同的含义。</p>
<p><code>LZMAFile</code> 支持 <code>io.BufferedIOBase</code> 所指定的所有成员，但 <code>detach()</code> 和 <code>truncate()</code> 除外。 并支持迭代和 <code>with</code> 语句。</p>
<p>也提供以下方法：</p>
<ul>
<li><p><code>peek</code>(<em>size=- 1</em>)</p>
<p>返回缓冲的数据而不前移文件位置。 至少将返回一个字节的数据，除非已经到达 EOF。 实际返回的字节数不确定（会忽略 <em>size</em> 参数）。</p>
<p>注解</p>
<p>虽然调用 <code>peek()</code> 不会改变 <code>LZMAFile</code> 的文件位置，但它可能改变下层文件对象的位置（举例来说如果 <code>LZMAFile</code> 是通过传入一个文件对象作为 <em>filename</em> 的话）。</p>
</li>
</ul>
<p>在 3.4 版更改: 增加了对 <code>"x"</code> 和 <code>"xb"</code> 模式的支持。</p>
<p>在 3.5 版更改: <code>read()</code> 方法现在接受 <code>None</code> 作为参数。</p>
<p>在 3.6 版更改: 接受一个 path-like object。</p>
<h3 id="在内存中压缩和解压缩数据"><a href="#在内存中压缩和解压缩数据" class="headerlink" title="在内存中压缩和解压缩数据"></a>在内存中压缩和解压缩数据</h3><p><em>class</em> <code>lzma.LZMACompressor</code>(<em>format=FORMAT_XZ</em>, <em>check=- 1</em>, <em>preset=None</em>, <em>filters=None</em>)</p>
<p>创建一个压缩器对象，此对象可被用来执行增量压缩。</p>
<p>压缩单个数据块的更便捷方式请参阅 <code>compress()</code>。</p>
<p><em>format</em> 参数指定应当使用哪种容器格式。 可能的值有：</p>
<ul>
<li><p><code>FORMAT_XZ</code>: <code>.xz</code> 容器格式。</p>
<p>这是默认格式。</p>
</li>
<li><p><code>FORMAT_ALONE</code>: 传统的 <code>.lzma</code> 容器格式。</p>
<p>这种格式相比 <code>.xz</code> 更为受限 — 它不支持一致性检查或多重过滤器。</p>
</li>
<li><p><code>FORMAT_RAW</code>: 原始数据流，不使用任何容器格式。</p>
<p>这个格式描述器不支持一致性检查，并且要求你必须指定一个自定义的过滤器链（用于压缩和解压缩）。 此外，以这种方式压缩的数据不可使用 <code>FORMAT_AUTO</code> 来解压缩 。</p>
</li>
</ul>
<p><em>check</em> 参数指定要包含在压缩数据中的一致性检查类型。 这种检查在解压缩时使用，以确保数据没有被破坏。 可能的值是：</p>
<ul>
<li><code>CHECK_NONE</code>: 没有一致性检查。 这是 <code>FORMAT_ALONE</code> 和 <code>FORMAT_RAW</code> 的默认值（也是唯一可接受的值）。</li>
<li><code>CHECK_CRC32</code>: 32 位循环冗余检查。</li>
<li><code>CHECK_CRC64</code>: 64 位循环冗余检查。 这是 <code>FORMAT_XZ</code> 的默认值。</li>
<li><code>CHECK_SHA256</code>: 256 位安全哈希算法。</li>
</ul>
<p>如果指定的检查不受支持，则会引发 <code>LZMAError</code>。</p>
<p>压缩设置可被指定为一个预设的压缩等级（通过 <em>preset</em> 参数）或以自定义过滤器链来详细设置（通过 <em>filters</em> 参数）。</p>
<p><em>preset</em> 参数（如果提供）应当为一个 <code>0</code> 到 <code>9</code> (包括边界) 之间的整数，可以选择与常数 <code>PRESET_EXTREME</code> 进行 OR 运算。 如果 <em>preset</em> 和 <em>filters</em> 均未给出，则默认行为是使用 <code>PRESET_DEFAULT</code> (预设等级 <code>6</code>)。 更高的预设等级会产生更小的输出，但会使得压缩过程更缓慢。</p>
<p>注解</p>
<p>除了更加 CPU 密集，使用更高的预设等级来压缩还需要更多的内存（并产生需要更多内存来解压缩的输出）。 例如使用预设等级 <code>9</code> 时，一个 <code>LZMACompressor</code> 对象的开销可以高达 800 MiB。 出于这样的原因，通常最好是保持使用默认预设等级。</p>
<p><em>filters</em> 参数（如果提供）应当指定一个过滤器链。</p>
<ul>
<li><p><code>compress</code>(<em>data</em>)</p>
<p>压缩 <em>data</em> (一个 <code>bytes</code> object)，返回包含针对输入的至少一部分已压缩数据的 <code>bytes</code> 对象。 一部 <em>data</em> 可能会被放入内部缓冲区，以便用于后续的 <code>compress()</code> 和 <code>flush()</code> 调用。 返回的数据应当与之前任何 <code>compress()</code> 调用的输出进行拼接。</p>
</li>
<li><p><code>flush</code>()</p>
<p>结束压缩进程，返回包含保存在压缩器的内部缓冲区中的任意数据的 <code>bytes</code> 对象。</p>
<p>调用此方法之后压缩器将不可再被使用。</p>
</li>
</ul>
<p><em>class</em> <code>lzma.LZMADecompressor</code>(<em>format=FORMAT_AUTO</em>, <em>memlimit=None</em>, <em>filters=None</em>)</p>
<p>创建一个压缩器对象，此对象可被用来执行增量解压缩。</p>
<p><em>format</em> 参数指定应当被使用的容器格式。 默认值为 <code>FORMAT_AUTO</code>，它可以解压缩 <code>.xz</code> 和 <code>.lzma</code> 文件。 其他可能的值为 <code>FORMAT_XZ</code>, <code>FORMAT_ALONE</code> 和 <code>FORMAT_RAW</code>。</p>
<p><em>memlimit</em> 参数指定解压缩器可以使用的内存上限（字节数）。 当使用此参数时，如果不可能在给定内存上限之内解压缩输入数据则解压缩将失败并引发 <code>LZMAError</code>。</p>
<p><em>filters</em> 参数指定用于创建被解压缩数据流的过滤器链。 此参数在 <em>format</em> 为 <code>FORMAT_RAW</code> 时要求提供，但对于其他格式不应使用。 </p>
<p>注解</p>
<p>这个类不会透明地处理包含多个已压缩数据流的输入，这不同于 <code>decompress()</code> 和 <code>LZMAFile</code>。 要通过 <code>LZMADecompressor</code> 来解压缩多个数据流输入，你必须为每个数据流都创建一个新的解压缩器。</p>
<ul>
<li><p><code>decompress</code>(<em>data</em>, <em>max_length=- 1</em>)</p>
<p>解压缩 <em>data</em> (一个 bytes-like object)，返回字节串形式的解压缩数据。 某些 <em>data</em> 可以在内部被缓冲，以便用于后续的 <code>decompress()</code> 调用。 返回的数据应当与之前任何 <code>decompress()</code> 调用的输出进行拼接。</p>
<p>如果 <em>max_length</em> 为非负数，将返回至多 <em>max_length</em> 个字节的解压缩数据。 如果达到此限制并且可以产生后续输出，则 <code>needs_input</code> 属性将被设为 <code>False</code>。 在这种情况下，下一次 <code>decompress()</code> 调用提供的 <em>data</em> 可以为 <code>b''</code> 以获取更多的输出。</p>
<p>如果所有输入数据都已被解压缩并返回（或是因为它少于 <em>max_length</em> 个字节，或是因为 <em>max_length</em> 为负数），则 <code>needs_input</code> 属性将被设为 <code>True</code>。</p>
<p>在到达数据流末尾之后再尝试解压缩数据会引发 EOFError。 在数据流末尾之后获取的任何数据都会被忽略并存储至 <code>unused_data</code> 属性。</p>
<p>在 3.5 版更改: 添加了 <em>max_length</em> 形参。</p>
</li>
<li><p><code>check</code></p>
<p>输入流使用的一致性检查的 ID。 这可能为 <code>CHECK_UNKNOWN</code> 直到已解压了足够的输入数据来确定它所使用的一致性检查。</p>
</li>
<li><p><code>eof</code></p>
<p>若达到了数据流的末尾标记则为 <code>True</code>。</p>
</li>
<li><p><code>unused_data</code></p>
<p>在压缩数据流的末尾之后获取的数据。</p>
<p>在达到数据流末尾之前，这个值将为 <code>b""</code>。</p>
</li>
<li><p><code>needs_input</code></p>
<p>如果在要求新的未解压缩输入之前 <code>decompress()</code> 方法可以提供更多的解压缩数据则为 <code>False</code>。</p>
<p>3.5 新版功能.</p>
</li>
</ul>
<p><code>lzma.compress</code>(<em>data</em>, <em>format=FORMAT_XZ</em>, <em>check=- 1</em>, <em>preset=None</em>, <em>filters=None</em>)</p>
<p>压缩 <em>data</em> (一个 <code>bytes</code> 对象)，返回包含压缩数据的 <code>bytes</code> 对象。</p>
<p>参见上文的 <code>LZMACompressor</code> 了解有关 <em>format</em>, <em>check</em>, <em>preset</em> 和 <em>filters</em> 参数的说明。</p>
<p><code>lzma.decompress</code>(<em>data</em>, <em>format=FORMAT_AUTO</em>, <em>memlimit=None</em>, <em>filters=None</em>)</p>
<p>解压缩 <em>data</em> (一个 <code>bytes</code> 对象)，返回包含解压缩数据的 <code>bytes</code> 对象。</p>
<p>如果 <em>data</em> 是多个单独压缩数据流的拼接，则解压缩所有相应数据流，并返回结果的拼接。</p>
<p>参见上文的 <code>LZMADecompressor</code> 了解有关 <em>format</em>, <em>memlimit</em> 和 <em>filters</em> 参数的说明。</p>
<h3 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h3><p><code>lzma.is_check_supported</code>(<em>check</em>)</p>
<p>如果本系统支持给定的一致性检查则返回 <code>True</code>。</p>
<p><code>CHECK_NONE</code> 和 <code>CHECK_CRC32</code> 总是受支持。 <code>CHECK_CRC64</code> 和 <code>CHECK_SHA256</code> 或许不可用，如果你正在使用基于受限制特性集编译的 <strong>liblzma</strong> 版本的话。</p>
<h3 id="指定自定义的过滤器链"><a href="#指定自定义的过滤器链" class="headerlink" title="指定自定义的过滤器链"></a>指定自定义的过滤器链</h3><p>过滤器链描述符是由字典组成的序列，其中每个字典包含单个过滤器的 ID 和选项。 每个字典必须包含键 <code>"id"</code>，并可能包含额外的键用来指定基于过滤器的选项。 有效的过滤器 ID 如下：</p>
<ul>
<li>压缩过滤器：<ul>
<li><code>FILTER_LZMA1</code> (配合 <code>FORMAT_ALONE</code> 使用)</li>
<li><code>FILTER_LZMA2</code> (配合 <code>FORMAT_XZ</code> 和 <code>FORMAT_RAW</code> 使用)</li>
</ul>
</li>
<li>Delta 过滤器：<ul>
<li><code>FILTER_DELTA</code></li>
</ul>
</li>
<li>Branch-Call-Jump (BCJ) 过滤器：<ul>
<li><code>FILTER_X86</code></li>
<li><code>FILTER_IA64</code></li>
<li><code>FILTER_ARM</code></li>
<li><code>FILTER_ARMTHUMB</code></li>
<li><code>FILTER_POWERPC</code></li>
<li><code>FILTER_SPARC</code></li>
</ul>
</li>
</ul>
<p>一个过滤器链最多可由 4 个过滤器组成，并且不能为空。 过滤器链中的最后一个过滤器必须为压缩过滤器，其他过滤器必须为 Delta 或 BCJ 过滤器。</p>
<p>压缩过滤器支持下列选项（指定为表示过滤器的字典中的附加条目）：</p>
<blockquote>
<ul>
<li><code>preset</code>: 压缩预设选项，用于作为未显式指定的选项的默认值的来源。</li>
<li><code>dict_size</code>: 以字节表示的字典大小。 这应当在 4 KiB 和 1.5 GiB 之间（包含边界）。</li>
<li><code>lc</code>: 字面值上下文的比特数。</li>
<li><code>lp</code>: 字面值位置的比特数。 总计值 <code>lc + lp</code> 必须不大于 4。</li>
<li><code>pb</code>: 位置的比特数；必须不大于 4。</li>
<li><code>mode</code>: <code>MODE_FAST</code> 或 <code>MODE_NORMAL</code>。</li>
<li><code>nice_len</code>: 对于一个匹配应当被视为“适宜长度”的值。 这应当小于或等于 273。</li>
<li><code>mf</code>: 要使用的匹配查找器 — <code>MF_HC3</code>, <code>MF_HC4</code>, <code>MF_BT2</code>, <code>MF_BT3</code> 或 <code>MF_BT4</code>。</li>
<li><code>depth</code>: 匹配查找器使用的最大查找深度。 0 (默认值) 表示基于其他过滤器选项自动选择。</li>
</ul>
</blockquote>
<p>Delta 过滤器保存字节数据之间的差值，在特定环境下可产生更具重复性的输入。 它支持一个 <code>dist</code> 选项，指明要减去的字节之间的差值大小。 默认值为 1，即相邻字节之间的差值。</p>
<p>BCJ 过滤器主要作用于机器码。 它们会转换机器码内的相对分支、调用和跳转以使用绝对寻址，其目标是提升冗余度以供压缩器利用。 这些过滤器支持一个 <code>start_offset</code> 选项，指明应当被映射到输入数据开头的地址。 默认值为 0。</p>
<h3 id="例子-2"><a href="#例子-2" class="headerlink" title="例子"></a>例子</h3><p>在已压缩的数据中读取:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> lzma
<span class="token keyword">with</span> lzma<span class="token punctuation">.</span>open<span class="token punctuation">(</span><span class="token string">"file.xz"</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span>
    file_content <span class="token operator">=</span> f<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>创建一个压缩文件:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> lzma
data <span class="token operator">=</span> b<span class="token string">"Insert Data Here"</span>
<span class="token keyword">with</span> lzma<span class="token punctuation">.</span>open<span class="token punctuation">(</span><span class="token string">"file.xz"</span><span class="token punctuation">,</span> <span class="token string">"w"</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span>
    f<span class="token punctuation">.</span>write<span class="token punctuation">(</span>data<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>在内存中压缩文件:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> lzma
data_in <span class="token operator">=</span> b<span class="token string">"Insert Data Here"</span>
data_out <span class="token operator">=</span> lzma<span class="token punctuation">.</span>compress<span class="token punctuation">(</span>data_in<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>增量压缩:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> lzma
lzc <span class="token operator">=</span> lzma<span class="token punctuation">.</span>LZMACompressor<span class="token punctuation">(</span><span class="token punctuation">)</span>
out1 <span class="token operator">=</span> lzc<span class="token punctuation">.</span>compress<span class="token punctuation">(</span>b<span class="token string">"Some data\n"</span><span class="token punctuation">)</span>
out2 <span class="token operator">=</span> lzc<span class="token punctuation">.</span>compress<span class="token punctuation">(</span>b<span class="token string">"Another piece of data\n"</span><span class="token punctuation">)</span>
out3 <span class="token operator">=</span> lzc<span class="token punctuation">.</span>compress<span class="token punctuation">(</span>b<span class="token string">"Even more data\n"</span><span class="token punctuation">)</span>
out4 <span class="token operator">=</span> lzc<span class="token punctuation">.</span>flush<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment" spellcheck="true"># Concatenate all the partial results:</span>
result <span class="token operator">=</span> b<span class="token string">""</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token punctuation">[</span>out1<span class="token punctuation">,</span> out2<span class="token punctuation">,</span> out3<span class="token punctuation">,</span> out4<span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>写入已压缩数据到已打开的文件:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> lzma
<span class="token keyword">with</span> open<span class="token punctuation">(</span><span class="token string">"file.xz"</span><span class="token punctuation">,</span> <span class="token string">"wb"</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span>
    f<span class="token punctuation">.</span>write<span class="token punctuation">(</span>b<span class="token string">"This data will not be compressed\n"</span><span class="token punctuation">)</span>
    <span class="token keyword">with</span> lzma<span class="token punctuation">.</span>open<span class="token punctuation">(</span>f<span class="token punctuation">,</span> <span class="token string">"w"</span><span class="token punctuation">)</span> <span class="token keyword">as</span> lzf<span class="token punctuation">:</span>
        lzf<span class="token punctuation">.</span>write<span class="token punctuation">(</span>b<span class="token string">"This *will* be compressed\n"</span><span class="token punctuation">)</span>
    f<span class="token punctuation">.</span>write<span class="token punctuation">(</span>b<span class="token string">"Not compressed\n"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>使用自定义过滤器链创建一个已压缩文件:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> lzma
my_filters <span class="token operator">=</span> <span class="token punctuation">[</span>
    <span class="token punctuation">{</span><span class="token string">"id"</span><span class="token punctuation">:</span> lzma<span class="token punctuation">.</span>FILTER_DELTA<span class="token punctuation">,</span> <span class="token string">"dist"</span><span class="token punctuation">:</span> <span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">{</span><span class="token string">"id"</span><span class="token punctuation">:</span> lzma<span class="token punctuation">.</span>FILTER_LZMA2<span class="token punctuation">,</span> <span class="token string">"preset"</span><span class="token punctuation">:</span> <span class="token number">7</span> <span class="token operator">|</span> lzma<span class="token punctuation">.</span>PRESET_EXTREME<span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">]</span>
<span class="token keyword">with</span> lzma<span class="token punctuation">.</span>open<span class="token punctuation">(</span><span class="token string">"file.xz"</span><span class="token punctuation">,</span> <span class="token string">"w"</span><span class="token punctuation">,</span> filters<span class="token operator">=</span>my_filters<span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span>
    f<span class="token punctuation">.</span>write<span class="token punctuation">(</span>b<span class="token string">"blah blah blah"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="zipfile-—-使用ZIP存档"><a href="#zipfile-—-使用ZIP存档" class="headerlink" title="zipfile —- 使用ZIP存档"></a><code>zipfile</code> —- 使用ZIP存档</h2><p><strong>源代码：</strong> <a href="https://github.com/python/cpython/tree/3.10/Lib/zipfile.py" target="_blank" rel="noopener">Lib/zipfile.py</a></p>
<hr>
<p>ZIP 文件格式是一个常用的归档与压缩标准。 这个模块提供了创建、读取、写入、添加及列出 ZIP 文件的工具。 任何对此模块的进阶使用都将需要理解此格式，其定义参见 <a href="https://pkware.cachefly.net/webdocs/casestudies/APPNOTE.TXT" target="_blank" rel="noopener">PKZIP 应用程序笔记</a>。</p>
<p>此模块目前不能处理分卷 ZIP 文件。它可以处理使用 ZIP64 扩展（超过 4 GB 的 ZIP 文件）的 ZIP 文件。它支持解密 ZIP 归档中的加密文件，但是目前不能创建一个加密的文件。解密非常慢，因为它是使用原生 Python 而不是 C 实现的。</p>
<p>这个模块定义了以下内容：</p>
<p><em>exception</em> <code>zipfile.BadZipFile</code></p>
<p>为损坏的 ZIP 文件抛出的错误。</p>
<p>3.2 新版功能.</p>
<p><em>exception</em> <code>zipfile.BadZipfile</code></p>
<p><code>BadZipFile</code> 的别名，与旧版本 Python 保持兼容性。</p>
<p>3.2 版后已移除.</p>
<p><em>exception</em> <code>zipfile.LargeZipFile</code></p>
<p>当 ZIP 文件需要 ZIP64 功能但是未启用时会抛出此错误。</p>
<p><em>class</em> <code>zipfile.ZipFile</code></p>
<p>用于读写 ZIP 文件的类。</p>
<p><em>class</em> <code>zipfile.Path</code></p>
<p>用于 zip 文件的兼容 pathlib 的包装器。</p>
<p>3.8 新版功能.</p>
<p><em>class</em> <code>zipfile.PyZipFile</code></p>
<p>用于创建包含 Python 库的 ZIP 归档的类。</p>
<p><em>class</em> <code>zipfile.ZipInfo</code>(<em>filename=’NoName’</em>, <em>date_time=1980, 1, 1, 0, 0, 0</em>)</p>
<p>用于表示档案内一个成员信息的类。 此类的实例会由 <code>ZipFile</code> 对象的 <code>getinfo()</code> 和 <code>infolist()</code> 方法返回。 大多数 <code>zipfile</code> 模块的用户都不必创建它们，只需使用此模块所创建的实例。 <em>filename</em> 应当是档案成员的全名，<em>date_time</em> 应当是包含六个字段的描述最近修改时间的元组。</p>
<p><code>zipfile.is_zipfile</code>(<em>filename</em>)</p>
<p>根据文件的 Magic Number，如果 <em>filename</em> 是一个有效的 ZIP 文件则返回 <code>True</code>，否则返回 <code>False</code>。 <em>filename</em> 也可能是一个文件或类文件对象。</p>
<p>在 3.1 版更改: 支持文件或类文件对象。</p>
<pre><code>zipfile.ZIP_STORED</code></pre><p>未被压缩的归档成员的数字常数。</p>
<pre><code>zipfile.ZIP_DEFLATED</code></pre><p>常用的 ZIP 压缩方法的数字常数。需要 <code>zlib</code> 模块。</p>
<pre><code>zipfile.ZIP_BZIP2</code></pre><p>BZIP2 压缩方法的数字常数。需要 <code>bz2</code> 模块。</p>
<p>3.3 新版功能.</p>
<pre><code>zipfile.ZIP_LZMA</code></pre><p>LZMA 压缩方法的数字常数。需要 <code>lzma</code> 模块。</p>
<p>3.3 新版功能.</p>
<p>注解</p>
<p>ZIP 文件格式规范包括自 2001 年以来对 bzip2 压缩的支持，以及自 2006 年以来对 LZMA 压缩的支持。但是，一些工具（包括较旧的 Python 版本）不支持这些压缩方法，并且可能拒绝完全处理 ZIP 文件，或者无法提取单个文件。</p>
<p>参见</p>
<p><a href="https://pkware.cachefly.net/webdocs/casestudies/APPNOTE.TXT" target="_blank" rel="noopener">PKZIP 应用程序笔记</a></p>
<p>Phil Katz 编写的 ZIP 文件格式文档，此格式和使用的算法的创建者。</p>
<p><a href="http://www.info-zip.org/" target="_blank" rel="noopener">Info-ZIP 主页</a></p>
<p>有关 Info-ZIP 项目的 ZIP 存档程序和开发库的信息。</p>
<h3 id="ZipFile-对象"><a href="#ZipFile-对象" class="headerlink" title="ZipFile 对象"></a>ZipFile 对象</h3><p><em>class</em> <code>zipfile.ZipFile</code>(<em>file</em>, <em>mode=’r’</em>, <em>compression=ZIP_STORED</em>, <em>allowZip64=True</em>, <em>compresslevel=None</em>, <em>**,</em> strict_timestamps=True*)</p>
<p>打开一个 ZIP 文件，<em>file</em> 为一个指向文件的路径（字符串），一个类文件对象或者一个 path-like object。</p>
<p>形参 <em>mode</em> 应当为 <code>'r'</code> 来读取一个存在的文件，<code>'w'</code> 来截断并写入新的文件， <code>'a'</code> 来添加到一个存在的文件，或者 <code>'x'</code> 来仅新建并写入新的文件。如果 <em>mode</em> 为 <code>'x'</code> 并且 <em>file</em> 指向已经存在的文件，则抛出 <code>FileExistsError</code>。如果 <em>mode</em> 为 <code>'a'</code> 且 <em>file</em> 为已存在的文件，则格外的文件将被加入。如果 <em>file</em> 不指向 ZIP 文件，之后一个新的 ZIP 归档将被追加为此文件。这是为了将 ZIP 归档添加到另一个文件（例如 <code>python.exe</code>）。如果 <em>mode</em> 为 <code>'a'</code> 并且文件不存在， 则会新建。如果 <em>mode</em> 为 <code>'r'</code> 或 <code>'a'</code>， 则文件应当可定位。</p>
<p><em>compression</em> 是在写入归档时要使用的 ZIP 压缩方法，应为 <code>ZIP_STORED</code>, <code>ZIP_DEFLATED</code>, <code>ZIP_BZIP2</code> 或 <code>ZIP_LZMA</code>；不可识别的值将导致引发 <code>NotImplementedError</code>。 如果指定了 <code>ZIP_DEFLATED</code>, <code>ZIP_BZIP2</code> 或 <code>ZIP_LZMA</code> 但相应的模块 (<code>zlib</code>, <code>bz2</code> 或 <code>lzma</code>) 不可用，则会引发 <code>RuntimeError</code>。 默认值为 <code>ZIP_STORED</code>。</p>
<p>如果 <em>allowZip64</em> 为 <code>True</code> (默认值) 则当 zipfile 大于 4 GiB 时 zipfile 将创建使用 ZIP64 扩展的 ZIP 文件。 如果该参数为 <code>false</code> 则当 ZIP 文件需要 ZIP64 扩展时 <code>zipfile</code> 将引发异常。</p>
<p><em>compresslevel</em> 形参控制在将文件写入归档时要使用的压缩等级。 当使用 <code>ZIP_STORED</code> 或 <code>ZIP_LZMA</code> 时无压缩效果。 当使用 <code>ZIP_DEFLATED</code> 时接受整数 <code>0</code> 至 <code>9</code>。 当使用 <code>ZIP_BZIP2</code> 时接受整数 <code>1</code> 至 <code>9</code>。</p>
<p><em>strict_timestamps</em> 参数在设为 <code>False</code> 时允许压缩早于 1980-01-01 的文件，代价时会将时间戳设为 1980-01-01。 类似的行为也会对晚于 2107-12-31 的文件发生，时间戳也会被设为该上限值。</p>
<p>如果创建文件时使用 <code>'w'</code>, <code>'x'</code> 或 <code>'a'</code> 模式并且未向归档添加任何文件就执行了 <code>closed</code>，则会将适当的空归档 ZIP 结构写入文件。</p>
<p>ZipFile 也是一个上下文管理器，因此支持 <code>with</code> 语句。 在这个示例中，<em>myzip</em> 将在 <code>with</code> 语句块执行完成之后被关闭 —- 即使是发生了异常:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">with</span> ZipFile<span class="token punctuation">(</span><span class="token string">'spam.zip'</span><span class="token punctuation">,</span> <span class="token string">'w'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> myzip<span class="token punctuation">:</span>
    myzip<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">'eggs.txt'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>3.2 新版功能: 添加了将 <code>ZipFile</code> 用作上下文管理员的功能。</p>
<p>在 3.3 版更改: 添加了对 <code>bzip2</code> 和 <code>lzma</code> 压缩的支持。</p>
<p>在 3.4 版更改: 默认启用 ZIP64 扩展。</p>
<p>在 3.5 版更改: 添加了对不可查找数据流的支持。 并添加了对 <code>'x'</code> 模式的支持。</p>
<p>在 3.6 版更改: 在此之前，对于不可识别的压缩值将引发普通的 <code>RuntimeError</code>。</p>
<p>在 3.6.2 版更改: <em>file</em> 形参接受一个 path-like object。</p>
<p>在 3.7 版更改: 添加了 <em>compresslevel</em> 形参。</p>
<p>3.8 新版功能: <em>strict_timestamps</em> 仅限关键字参数</p>
<p><code>ZipFile.close</code>()</p>
<p>关闭归档文件。 你必须在退出程序之前调用 <code>close()</code> 否则将不会写入关键记录数据。</p>
<p><code>ZipFile.getinfo</code>(<em>name</em>)</p>
<p>返回一个 <code>ZipInfo</code> 对象，其中包含有关归档成员 <em>name</em> 的信息。 针对一个目前并不包含于归档中的名称调用 <code>getinfo()</code> 将会引发 <code>KeyError</code>。</p>
<p><code>ZipFile.infolist</code>()</p>
<p>返回一个列表，其中包含每个归档成员的 <code>ZipInfo</code> 对象。 如果是打开一个现有归档则这些对象的排列顺序与它们对应条目在磁盘上的实际 ZIP 文件中的顺序一致。</p>
<p><code>ZipFile.namelist</code>()</p>
<p>返回按名称排序的归档成员列表。</p>
<p><code>ZipFile.open</code>(<em>name</em>, <em>mode=’r’</em>, <em>pwd=None</em>, <em>**,</em> force_zip64=False*)</p>
<p>以二进制文件类对象的形式访问一个归档成员。 <em>name</em> 可以是归档内某个文件的名称也可以是某个 <code>ZipInfo</code> 对象。 如果包含了 <em>mode</em> 形参，则它必须为 <code>'r'</code> (默认值) 或 <code>'w'</code>。 <em>pwd</em> 为用于解密已加密 ZIP 文件的密码。</p>
<p><code>open()</code> 也是一个上下文管理器，因此支持 <code>with</code> 语句:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">with</span> ZipFile<span class="token punctuation">(</span><span class="token string">'spam.zip'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> myzip<span class="token punctuation">:</span>
    <span class="token keyword">with</span> myzip<span class="token punctuation">.</span>open<span class="token punctuation">(</span><span class="token string">'eggs.txt'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> myfile<span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span>myfile<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>如果 <em>mode</em> 为 <code>'r'</code> 则文件类对象 (<code>ZipExtFile</code>) 将为只读并且提供下列方法: <code>read()</code>, <code>readline()</code>, <code>readlines()</code>, <code>seek()</code>, <code>tell()</code>, <code>__iter__()</code>, <code>__next__()</code>。 这些对象可独立于 ZipFile 进行操作。</p>
<p>如果 <code>mode='w'</code> 则返回一个可写入的文件句柄，它将支持 <code>write()</code> 方法。 当一个可写入的文件句柄被打开时，尝试读写 ZIP 文件中的其他文件将会引发 <code>ValueError</code>。</p>
<p>当写入一个文件时，如果文件大小不能预先确定但是可能超过 2 GiB，可传入 <code>force_zip64=True</code> 以确保标头格式能够支持超大文件。 如果文件大小可以预先确定，则在构造 <code>ZipInfo</code> 对象时应设置 <code>file_size</code>，并将其用作 <em>name</em> 形参。</p>
<p>注解</p>
<p><code>open()</code>, <code>read()</code> 和 <code>extract()</code> 方法可接受文件名或 <code>ZipInfo</code> 对象。 当尝试读取一个包含重复名称成员的 ZIP 文件时你将发现此功能很有好处。</p>
<p>在 3.6 版更改: 移除了对 <code>mode='U'</code> 的支持。 请使用 <code>io.TextIOWrapper</code> 以在 universal newlines 模式中读取已压缩的文本文件。</p>
<p>在 3.6 版更改: <code>open()</code> 现在可以被用来配合 <code>mode='w'</code> 选项来将文件写入归档。</p>
<p>在 3.6 版更改: 在已关闭的 ZipFile 上调用 <code>open()</code> 将引发 <code>ValueError</code>。 在之前的版本中则会引发 <code>RuntimeError</code>。</p>
<p><code>ZipFile.extract</code>(<em>member</em>, <em>path=None</em>, <em>pwd=None</em>)</p>
<p>从归档中提取出一个成员放入当前工作目录；<em>member</em> 必须为成员的完整名称或 <code>ZipInfo</code> 对象。 成员的文件信息会尽可能精确地被提取。 <em>path</em> 指定一个要提取到的不同目录。 <em>member</em> 可以是一个文件名或 <code>ZipInfo</code> 对象。 <em>pwd</em> 是用于解密文件的密码。</p>
<p>返回所创建的经正规化的路径（对应于目录或新文件）。</p>
<p>注解</p>
<p>如果一个成员文件名为绝对路径，则将去掉驱动器/UNC共享点和前导的（反）斜杠，例如: <code>///foo/bar</code> 在 Unix 上将变为 <code>foo/bar</code>，而 <code>C:\foo\bar</code> 在 Windows 上将变为 <code>foo\bar</code>。 并且一个成员文件名中的所有 <code>".."</code> 都将被移除，例如: <code>../../foo../../ba..r</code> 将变为 <code>foo../ba..r</code>。 在 Windows 上非法字符 (<code>:</code>, <code>&lt;</code>, <code>&gt;</code>, <code>|</code>, <code>"</code>, <code>?</code>, and <code>*</code>) 会被替换为下划线 (<code>_</code>)。</p>
<p>在 3.6 版更改: 在已关闭的 ZipFile 上调用 <code>extract()</code> 将引发 <code>ValueError</code>。 在之前的版本中则将引发 <code>RuntimeError</code>。</p>
<p>在 3.6.2 版更改: <em>path</em> 形参接受一个 path-like object。</p>
<p><code>ZipFile.extractall</code>(<em>path=None</em>, <em>members=None</em>, <em>pwd=None</em>)</p>
<p>从归档中提取出所有成员放入当前工作目录。 <em>path</em> 指定一个要提取到的不同目录。 <em>members</em> 为可选项且必须为 <code>namelist()</code> 所返回列表的一个子集。 <em>pwd</em> 是用于解密文件的密码。</p>
<p>警告</p>
<p>绝不要未经预先检验就从不可靠的源中提取归档文件。 这样有可能在 <em>path</em> 之外创建文件，例如某些成员具有以 <code>"/"</code> 开始的文件名或带有两个点号 <code>".."</code> 的文件名。 此模块会尝试防止这种情况。 </p>
<p>在 3.6 版更改: 在已关闭的 ZipFile 上调用 <code>extractall()</code> 将引发 <code>ValueError</code>。 在之前的版本中则将引发 <code>RuntimeError</code>。</p>
<p>在 3.6.2 版更改: <em>path</em> 形参接受一个 path-like object。</p>
<p><code>ZipFile.printdir</code>()</p>
<p>将归档的目录表打印到 <code>sys.stdout</code>。</p>
<p><code>ZipFile.setpassword</code>(<em>pwd</em>)</p>
<p>设置 <em>pwd</em> 为用于提取已加密文件的默认密码。</p>
<p><code>ZipFile.read</code>(<em>name</em>, <em>pwd=None</em>)</p>
<p>返回归档中文件 <em>name</em> 的字节数据。 <em>name</em> 是归档中文件的名称，或是一个 <code>ZipInfo</code> 对象。 归档必须以读取或追加方式打开。 <em>pwd</em> 为用于已加密文件的密码，并且如果指定该参数则它将覆盖通过 <code>setpassword()</code> 设置的默认密码。 on a ZipFile that uses a compression method 在使用 <code>ZIP_STORED</code> , <code>ZIP_DEFLATED</code>, <code>ZIP_BZIP2</code> 或 <code>ZIP_LZMA</code> 以外的压缩方法的 ZipFile 上调用 <code>read()</code> 将引发 <code>NotImplementedError</code>。 如果相应的压缩模块不可用也会引发错误。</p>
<p>在 3.6 版更改: 在已关闭的 ZipFile 上调用 <code>read()</code> 将引发 <code>ValueError</code>。 在之前的版本中则会引发 <code>RuntimeError</code>。</p>
<p><code>ZipFile.testzip</code>()</p>
<p>读取归档中的所有文件并检查它们的 CRC 和文件头。 返回第一个已损坏文件的名称，在其他情况下则返回 <code>None</code>。</p>
<p>在 3.6 版更改: 在已关闭的 ZipFile 上调用 <code>testzip()</code> 将引发 <code>ValueError</code>。 在之前的版本中则将引发 <code>RuntimeError</code>。</p>
<p><code>ZipFile.write</code>(<em>filename</em>, <em>arcname=None</em>, <em>compress_type=None</em>, <em>compresslevel=None</em>)</p>
<p>将名为 <em>filename</em> 的文件写入归档，给予的归档名为 <em>arcname</em> (默认情况下将与 <em>filename</em> 一致，但是不带驱动器盘符并会移除开头的路径分隔符)。 <em>compress_type</em> 如果给出，它将覆盖作为构造器 <em>compression</em> 形参对于新条目所给出的值。 类似地，<em>compresslevel</em> 如果给出也将覆盖构造器。 归档必须使用 <code>'w'</code>, <code>'x'</code> 或 <code>'a'</code> 模式打开。</p>
<p>注解</p>
<p>归档名称应当是基于归档根目录的相对路径，也就是说，它们不应以路径分隔符开头。</p>
<p>注解</p>
<p>如果 <code>arcname</code> (或 <code>filename</code>，如果 <code>arcname</code> 未给出) 包含一个空字节，则归档中该文件的名称将在空字节位置被截断。</p>
<p>注解</p>
<p>文件名开头有一个斜杠可能导致存档文件无法在 Windows 系统上的某些 zip 程序中打开。</p>
<p>在 3.6 版更改: 在使用 <code>'r'</code> 模式创建的 ZipFile 或已关闭的 ZipFile 上调用 <code>write()</code> 将引发 <code>ValueError</code>。 在之前的版本中则会引发 <code>RuntimeError</code>。</p>
<p><code>ZipFile.writestr</code>(<em>zinfo_or_arcname</em>, <em>data</em>, <em>compress_type=None</em>, <em>compresslevel=None</em>)</p>
<p>将一个文件写入归档。 内容为 <em>data*，它可以是一个 <code>str</code> 或 <code>bytes</code> 的实例；如果是 <code>str</code>，则会先使用 UTF-8 进行编码。 *zinfo_or_arcname</em> 可以是它在归档中将被给予的名称，或者是 <code>ZipInfo</code> 的实例。 如果它是一个实例，则至少必须给定文件名、日期和时间。 如果它是一个名称，则日期和时间会被设为当前日期和时间。 归档必须以 <code>'w'</code>, <code>'x'</code> 或 <code>'a'</code> 模式打开。</p>
<p>如果给定了 <em>compress_type*，它将会覆盖作为新条目构造器的 *compression</em> 形参或在 <em>zinfo_or_arcname</em> (如果是一个 <code>ZipInfo</code> 实例) 中所给出的值。 类似地，如果给定了 <em>compresslevel</em>，它将会覆盖构造器。</p>
<p>注解</p>
<p>当传入一个 <code>ZipInfo</code> 实例作为 <em>zinfo_or_arcname</em> 形参时，所使用的压缩方法将为在给定的 <code>ZipInfo</code> 实例的 <em>compress_type</em> 成员中指定的方法。 默认情况下，<code>ZipInfo</code> 构造器将将此成员设为 <code>ZIP_STORED</code>。</p>
<p>在 3.2 版更改: <em>compress_type</em> 参数。</p>
<p>在 3.6 版更改: 在使用 <code>'r'</code> 模式创建的 ZipFile 或已关闭的 ZipFile 上调用 <code>writestr()</code> 将引发 <code>ValueError</code>。 在之前的版本中则会引发 <code>RuntimeError</code>。</p>
<p>以下数据属性也是可用的:</p>
<pre><code>ZipFile.filename</code></pre><p>ZIP 文件的名称。</p>
<pre><code>ZipFile.debug</code></pre><p>要使用的调试输出等级。 这可以设为从 <code>0</code> (默认无输出) 到 <code>3</code> (最多输出) 的值。 调试信息会被写入 <code>sys.stdout</code>。</p>
<pre><code>ZipFile.comment</code></pre><p>关联到 ZIP 文件的 <code>bytes</code> 对象形式的说明。 如果将说明赋给以 <code>'w'</code>, <code>'x'</code> 或 <code>'a'</code> 模式创建的 <code>ZipFile</code> 实例，它的长度不应超过 65535 字节。 超过此长度的说明将被截断。</p>
<h3 id="Path-对象"><a href="#Path-对象" class="headerlink" title="Path 对象"></a>Path 对象</h3><p><em>class</em> <code>zipfile.Path</code>(<em>root</em>, <em>at=’’</em>)</p>
<p>根据 <code>root</code> zipfile (它可以是一个 <code>ZipFile</code> 实例或适合传给 <code>ZipFile</code> 构造器的 <code>file</code>) 构造一个 Path 对象。</p>
<p><code>at</code> 指定此 Path 在 zipfile 中的位置，例如 ‘dir/file.txt’, ‘dir/‘ 或 ‘’。 默认为空字符串，即指定跟目录。</p>
<p>Path 对象会公开 <code>pathlib.Path</code> 对象的下列特性:</p>
<p>Path 对象可以使用 <code>/</code> 运算符或 <code>joinpath</code> 来进行遍历。</p>
<pre><code>Path.name</code></pre><p>最终的路径组成部分。</p>
<p><code>Path.open</code>(<em>mode=’r’</em>, <strong><em>,</em> pwd<em>,</em> *</strong>)</p>
<p>在当前路径上发起调用 <code>ZipFile.open()</code>。 允许通过支持的模式打开用于读取或写入文本或二进制数据: ‘r’, ‘w’, ‘rb’, ‘wb’。 当以文本模式打开时位置和关键字参数会被传给 <code>io.TextIOWrapper</code>，在其他情况下则会被忽略。 <code>pwd</code> 是要传给 <code>ZipFile.open()</code> 的 <code>pwd</code> 形参。</p>
<p>在 3.9 版更改: 增加了对以文本和二进制模式打开的支持。 现在默认为文本模式。</p>
<p><code>Path.iterdir</code>()</p>
<p>枚举当前目录的子目录。</p>
<p><code>Path.is_dir</code>()</p>
<p>如果当前上下文引用了一个目录则返回 <code>True</code>。</p>
<p><code>Path.is_file</code>()</p>
<p>如果当前上下文引用了一个文件则返回 <code>True</code>。</p>
<p><code>Path.exists</code>()</p>
<p>如果当前上下文引用了 zip 文件内的一个文件或目录则返回 <code>True</code>。</p>
<p><code>Path.read_text</code>(<strong><em>,</em> *</strong>)</p>
<p>读取当前文件为 unicode 文本。 位置和关键字参数会被传递给 <code>io.TextIOWrapper</code> (<code>buffer</code> 除外，它将由上下文确定)。</p>
<p><code>Path.read_bytes</code>()</p>
<p>读取当前文件为字节串。</p>
<p><code>Path.joinpath</code>(<em>\</em>other*)</p>
<p>返回一个新的 Path 对象，其中合并了每个 <em>other</em> 参数。 以下代码是等价的:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> Path<span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">.</span>joinpath<span class="token punctuation">(</span><span class="token string">'child'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>joinpath<span class="token punctuation">(</span><span class="token string">'grandchild'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> Path<span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">.</span>joinpath<span class="token punctuation">(</span><span class="token string">'child'</span><span class="token punctuation">,</span> <span class="token string">'grandchild'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> Path<span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token string">'child'</span> <span class="token operator">/</span> <span class="token string">'grandchild'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>在 3.10 版更改: 在 3.10 之前，<code>joinpath</code> 未被写入文档并且只接受一个形参。</p>
<h3 id="PyZipFile-对象"><a href="#PyZipFile-对象" class="headerlink" title="PyZipFile 对象"></a>PyZipFile 对象</h3><p><code>PyZipFile</code> 构造器接受与 <code>ZipFile</code> 构造器相同的形参，以及一个额外的形参 <em>optimize</em>。</p>
<p><em>class</em> <code>zipfile.PyZipFile</code>(<em>file</em>, <em>mode=’r’</em>, <em>compression=ZIP_STORED</em>, <em>allowZip64=True</em>, <em>optimize=- 1</em>)</p>
<p>3.2 新版功能: <em>optimize</em> 形参。</p>
<p>在 3.4 版更改: 默认启用 ZIP64 扩展。</p>
<p>实例在 <code>ZipFile</code> 对象所具有的方法以外还附加了一个方法:</p>
<ul>
<li><p><code>writepy</code>(<em>pathname</em>, <em>basename=’’</em>, <em>filterfunc=None</em>)</p>
<p>查找 <code>*.py</code> 文件并将相应的文件添加到归档。</p>
<p>如果 <code>PyZipFile</code> 的 <em>optimize</em> 形参未给定或为 <code>-1</code>，则相应的文件为 <code>*.pyc</code> 文件，并在必要时进行编译。</p>
<p>如果 <code>PyZipFile</code> 的 <em>optimize</em> 形参为 <code>0</code>, <code>1</code> 或 <code>2</code>，则限具有相应优化级别的文件会被添加到归档，并在必要时进行编译。</p>
<p>如果 <em>pathname</em> 是文件，则文件名必须以 <code>.py</code> 为后缀，并且只有 (相应的 <code>*.pyc</code>) 文件会被添加到最高层级（不带路径信息）。 如果 <em>pathname</em> 不是以 <code>.py</code> 为后缀的文件，则将引发 <code>RuntimeError</code>。 如果它是目录，并且该目录不是一个包目录，则所有的 <code>*.pyc</code> 文件会被添加到最高层级。 如果目录是一个包目录，则所有的 <code>*.pyc</code> 会被添加到包名所表示的文件路径下，并且如果有任何子目录为包目录，则会以排好的顺序递归地添加这些目录。</p>
<p><em>basename</em> 仅限在内部使用。</p>
<p>如果给定 <em>filterfunc*，则它必须是一个接受单个字符串参数的函数。 在将其添加到归档之前它将被传入每个路径（包括每个单独的完整路径）。 如果 *filterfunc</em> 返回假值，则路径将不会被添加，而如果它是一个目录则其内容将被忽略。 例如，如果我们的测试文件全都位于 <code>test</code> 目录或以字符串 <code>test_</code> 打头，则我们可以使用一个 <em>filterfunc</em> 来排除它们:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> zf <span class="token operator">=</span> PyZipFile<span class="token punctuation">(</span><span class="token string">'myprog.zip'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">def</span> <span class="token function">notests</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     fn <span class="token operator">=</span> os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>basename<span class="token punctuation">(</span>s<span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token operator">not</span> <span class="token punctuation">(</span>fn <span class="token operator">==</span> <span class="token string">'test'</span> <span class="token operator">or</span> fn<span class="token punctuation">.</span>startswith<span class="token punctuation">(</span><span class="token string">'test_'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> zf<span class="token punctuation">.</span>writepy<span class="token punctuation">(</span><span class="token string">'myprog'</span><span class="token punctuation">,</span> filterfunc<span class="token operator">=</span>notests<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>writepy()</code> 方法会产生带有这样一些文件名的归档:</p>
<pre class="line-numbers language-python"><code class="language-python">string<span class="token punctuation">.</span>pyc                   <span class="token comment" spellcheck="true"># Top level name</span>
test<span class="token operator">/</span>__init__<span class="token punctuation">.</span>pyc            <span class="token comment" spellcheck="true"># Package directory</span>
test<span class="token operator">/</span>testall<span class="token punctuation">.</span>pyc             <span class="token comment" spellcheck="true"># Module test.testall</span>
test<span class="token operator">/</span>bogus<span class="token operator">/</span>__init__<span class="token punctuation">.</span>pyc      <span class="token comment" spellcheck="true"># Subpackage directory</span>
test<span class="token operator">/</span>bogus<span class="token operator">/</span>myfile<span class="token punctuation">.</span>pyc        <span class="token comment" spellcheck="true"># Submodule test.bogus.myfile</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>3.4 新版功能: <em>filterfunc</em> 形参。</p>
<p>在 3.6.2 版更改: <em>pathname</em> 形参接受一个 path-like object。</p>
<p>在 3.7 版更改: 递归排序目录条目。</p>
</li>
</ul>
<h3 id="ZipInfo-对象"><a href="#ZipInfo-对象" class="headerlink" title="ZipInfo 对象"></a>ZipInfo 对象</h3><p><code>ZipInfo</code> 类的实例会通过 <code>getinfo()</code> 和 <code>ZipFile</code> 对象的 <code>infolist()</code> 方法返回。 每个对象将存储关于 ZIP 归档的一个成员的信息。</p>
<p>有一个类方法可以为文件系统文件创建 <code>ZipInfo</code> 实例:</p>
<p><em>classmethod</em> <code>ZipInfo.from_file</code>(<em>filename</em>, <em>arcname=None</em>, <em>**,</em> strict_timestamps=True*)</p>
<p>为文件系统中的文件构造一个 <code>ZipInfo</code> 实例，并准备将其添加到一个 zip 文件。</p>
<p><em>filename</em> 应为文件系统中某个文件或目录的路径。</p>
<p>如果指定了 <em>arcname<em>，它会被用作归档中的名称。 如果未指定 *arcname</em>，则所用名称与 *filename</em> 相同，但将去除任何驱动器盘符和打头的路径分隔符。</p>
<p><em>strict_timestamps</em> 参数在设为 <code>False</code> 时允许压缩早于 1980-01-01 的文件，代价时会将时间戳设为 1980-01-01。 类似的行为也会对晚于 2107-12-31 的文件发生，时间戳也会被设为该上限值。</p>
<p>3.6 新版功能.</p>
<p>在 3.6.2 版更改: <em>filename</em> 形参接受一个 path-like object。</p>
<p>3.8 新版功能: <em>strict_timestamps</em> 仅限关键字参数</p>
<p>实例具有下列方法和属性:</p>
<p><code>ZipInfo.is_dir</code>()</p>
<p>如果此归档成员是一个目录则返回 <code>True</code>。</p>
<p>这会使用条目的名称：目录应当总是以 <code>/</code> 结尾。</p>
<p>3.6 新版功能.</p>
<pre><code>ZipInfo.filename</code></pre><p>归档中的文件名称。</p>
<pre><code>ZipInfo.date_time</code></pre><p>上次修改存档成员的时间和日期。这是六个值的元组：</p>
<table>
<thead>
<tr>
<th align="left">索引</th>
<th align="left">值</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>0</code></td>
<td align="left">Year (&gt;= 1980)</td>
</tr>
<tr>
<td align="left"><code>1</code></td>
<td align="left">月（1为基数）</td>
</tr>
<tr>
<td align="left"><code>2</code></td>
<td align="left">月份中的日期（1为基数）</td>
</tr>
<tr>
<td align="left"><code>3</code></td>
<td align="left">小时（0为基数）</td>
</tr>
<tr>
<td align="left"><code>4</code></td>
<td align="left">分钟（0为基数）</td>
</tr>
<tr>
<td align="left"><code>5</code></td>
<td align="left">秒（0为基数）</td>
</tr>
</tbody></table>
<p>注解</p>
<p>ZIP文件格式不支持1980年以前的时间戳。</p>
<pre><code>ZipInfo.compress_type</code></pre><p>归档成员的压缩类型。</p>
<pre><code>ZipInfo.comment</code></pre><p><code>bytes</code> 对象形式的单个归档成员的注释。</p>
<pre><code>ZipInfo.extra</code></pre><p>扩展字段数据。 PKZIP Application Note 包含一些保存于该 <code>bytes</code> 对象中的内部结构的注释。</p>
<pre><code>ZipInfo.create_system</code></pre><p>创建 ZIP 归档所用的系统。</p>
<pre><code>ZipInfo.create_version</code></pre><p>创建 ZIP 归档所用的 PKZIP 版本。</p>
<pre><code>ZipInfo.extract_version</code></pre><p>需要用来提取归档的 PKZIP 版本。</p>
<pre><code>ZipInfo.reserved</code></pre><p>必须为零。</p>
<pre><code>ZipInfo.flag_bits</code></pre><p>ZIP 标志位。</p>
<pre><code>ZipInfo.volume</code></pre><p>文件头的分卷号。</p>
<pre><code>ZipInfo.internal_attr</code></pre><p>内部属性。</p>
<pre><code>ZipInfo.external_attr</code></pre><p>外部文件属性。</p>
<pre><code>ZipInfo.header_offset</code></pre><p>文件头的字节偏移量。</p>
<pre><code>ZipInfo.CRC</code></pre><p>未压缩文件的 CRC-32。</p>
<pre><code>ZipInfo.compress_size</code></pre><p>已压缩数据的大小。</p>
<pre><code>ZipInfo.file_size</code></pre><p>未压缩文件的大小。</p>
<h3 id="命令行接口"><a href="#命令行接口" class="headerlink" title="命令行接口"></a>命令行接口</h3><p><code>zipfile</code> 模块提供了简单的命令行接口用于与 ZIP 归档的交互。</p>
<p>如果你想要创建一个新的 ZIP 归档，请在 <code>-c</code> 选项后指定其名称然后列出应当被包含的文件名:</p>
<pre><code>$ python -m zipfile -c monty.zip spam.txt eggs.txt</code></pre><p>传入一个字典也是可接受的:</p>
<pre><code>$ python -m zipfile -c monty.zip life-of-brian_1979/</code></pre><p>如果你想要将一个 ZIP 归档提取到指定的目录，请使用 <code>-e</code> 选项:</p>
<pre><code>$ python -m zipfile -e monty.zip target-dir/</code></pre><p>要获取一个 ZIP 归档中的文件列表，请使用 <code>-l</code> 选项:</p>
<pre><code>$ python -m zipfile -l monty.zip</code></pre><h4 id="命令行选项-1"><a href="#命令行选项-1" class="headerlink" title="命令行选项"></a>命令行选项</h4><pre><code>-l` `&lt;zipfile&gt;
--list` `&lt;zipfile&gt;</code></pre><p>列出一个 zipfile 中的文件名。</p>
<pre><code>-c` `&lt;zipfile&gt; &lt;source1&gt; ... &lt;sourceN&gt;
--create` `&lt;zipfile&gt; &lt;source1&gt; ... &lt;sourceN&gt;</code></pre><p>基于源文件创建 zipfile。</p>
<pre><code>-e` `&lt;zipfile&gt; &lt;output_dir&gt;
--extract` `&lt;zipfile&gt; &lt;output_dir&gt;</code></pre><p>将 zipfile 提取到目标目录中。</p>
<pre><code>-t` `&lt;zipfile&gt;
--test` `&lt;zipfile&gt;</code></pre><p>检测 zipfile 是否有效。</p>
<h3 id="解压缩的障碍"><a href="#解压缩的障碍" class="headerlink" title="解压缩的障碍"></a>解压缩的障碍</h3><p>zipfile 模块的提取操作可能会由于下面列出的障碍而失败。</p>
<h4 id="由于文件本身"><a href="#由于文件本身" class="headerlink" title="由于文件本身"></a>由于文件本身</h4><p>解压缩可能由于不正确的密码 / CRC 校验和 / ZIP 格式或不受支持的压缩 / 解密方法而失败。</p>
<h4 id="文件系统限制"><a href="#文件系统限制" class="headerlink" title="文件系统限制"></a>文件系统限制</h4><p>超出特定文件系统上的限制可能会导致解压缩失败。 例如目录条目所允许的字符、文件名的长度、路径名的长度、单个文件的大小以及文件的数量等等。</p>
<h4 id="资源限制"><a href="#资源限制" class="headerlink" title="资源限制"></a>资源限制</h4><p>缺乏内存或磁盘空间将会导致解压缩失败。 例如，作用于 zipfile 库的解压缩炸弹 (即 <a href="https://en.wikipedia.org/wiki/Zip_bomb" target="_blank" rel="noopener">ZIP bomb</a>) 就可能造成磁盘空间耗尽。</p>
<h4 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h4><p>在解压缩期间中断执行，例如按下 ctrl-C 或杀死解压缩进程可能会导致归档文件的解压缩不完整。</p>
<h4 id="提取的默认行为"><a href="#提取的默认行为" class="headerlink" title="提取的默认行为"></a>提取的默认行为</h4><p>不了解提取的默认行为可能导致不符合期望的解压缩结果。 例如，当提取相同归档两次时，它会不经询问地覆盖文件。</p>
<h2 id="tarfile-—-读写tar归档文件"><a href="#tarfile-—-读写tar归档文件" class="headerlink" title="tarfile —- 读写tar归档文件"></a><code>tarfile</code> —- 读写tar归档文件</h2><p><strong>源代码:</strong> <a href="https://github.com/python/cpython/tree/3.10/Lib/tarfile.py" target="_blank" rel="noopener">Lib/tarfile.py</a></p>
<hr>
<p><code>tarfile</code> 模块可以用来读写 tar 归档，包括使用 gzip, bz2 和 lzma 压缩的归档。 请使用 <code>zipfile</code> 模块来读写 <code>.zip</code> 文件，或者使用 shutil 的高层级函数。</p>
<p>一些事实和数字:</p>
<ul>
<li>读写 <code>gzip</code>, <code>bz2</code> 和 <code>lzma</code> 解压的归档要求相应的模块可用。</li>
<li>支持读取 / 写入 POSIX.1-1988 (ustar) 格式。</li>
<li>对 GNU tar 格式的读/写支持，包括 <em>longname</em> 和 <em>longlink</em> 扩展，对所有种类 <em>sparse</em> 扩展的只读支持，包括 sparse 文件的恢复。</li>
<li>对 POSIX.1-2001 (pax) 格式的读/写支持。</li>
<li>处理目录、正常文件、硬链接、符号链接、fifo 管道、字符设备和块设备，并且能够获取和恢复文件信息例如时间戳、访问权限和所有者等。</li>
</ul>
<p>在 3.3 版更改: 添加了对 <code>lzma</code> 压缩的支持。</p>
<p><code>tarfile.open</code>(<em>name=None</em>, <em>mode=’r’</em>, <em>fileobj=None</em>, <em>bufsize=10240</em>, <em>**kwargs</em>)</p>
<p>针对路径名 <em>name</em> 返回 <code>TarFile</code> 对象。 </p>
<p><em>mode</em> 必须是 <code>'filemode[:compression]'</code> 形式的字符串，其默认值为 <code>'r'</code>。 以下是模式组合的完整列表:</p>
<table>
<thead>
<tr>
<th align="left">模式</th>
<th align="left">action</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>‘r’ or ‘r:*’</code></td>
<td align="left">打开和读取使用透明压缩（推荐）。</td>
</tr>
<tr>
<td align="left"><code>‘r:’</code></td>
<td align="left">打开和读取不使用压缩。</td>
</tr>
<tr>
<td align="left"><code>‘r:gz’</code></td>
<td align="left">打开和读取使用gzip 压缩。</td>
</tr>
<tr>
<td align="left"><code>‘r:bz2’</code></td>
<td align="left">打开和读取使用bzip2 压缩。</td>
</tr>
<tr>
<td align="left"><code>‘r:xz’</code></td>
<td align="left">打开和读取使用lzma 压缩。</td>
</tr>
<tr>
<td align="left"><code>‘x’</code> 或 <code>‘x:’</code></td>
<td align="left">创建tarfile不进行压缩。如果文件已经存在，则抛出 <code>FileExistsError</code> 异常。</td>
</tr>
<tr>
<td align="left"><code>‘x:gz’</code></td>
<td align="left">使用gzip压缩创建tarfile。如果文件已经存在，则抛出 <code>FileExistsError</code> 异常。</td>
</tr>
<tr>
<td align="left"><code>‘x:bz2’</code></td>
<td align="left">使用bzip2 压缩创建tarfile。如果文件已经存在，则抛出 <code>FileExistsError</code> 异常。</td>
</tr>
<tr>
<td align="left"><code>‘x:xz’</code></td>
<td align="left">使用lzma 压缩创建tarfile。如果文件已经存在，则抛出 <code>FileExistsError</code> 异常。</td>
</tr>
<tr>
<td align="left"><code>‘a’ or ‘a:’</code></td>
<td align="left">打开以便在没有压缩的情况下追加。如果文件不存在，则创建该文件。</td>
</tr>
<tr>
<td align="left"><code>‘w’ or ‘w:’</code></td>
<td align="left">打开用于未压缩的写入。</td>
</tr>
<tr>
<td align="left"><code>‘w:gz’</code></td>
<td align="left">打开用于 gzip 压缩的写入。</td>
</tr>
<tr>
<td align="left"><code>‘w:bz2’</code></td>
<td align="left">打开用于 bzip2 压缩的写入。</td>
</tr>
<tr>
<td align="left"><code>‘w:xz’</code></td>
<td align="left">打开用于 lzma 压缩的写入。</td>
</tr>
</tbody></table>
<p>请注意 <code>'a:gz'</code>, <code>'a:bz2'</code> 或 <code>'a:xz'</code> 是不可能的组合。 如果 <em>mode</em> 不适用于打开特定（压缩的）文件用于读取，则会引发 <code>ReadError</code>。 请使用 <em>mode</em> <code>'r'</code> 来避免这种情况。 如果某种压缩方法不受支持，则会引发 <code>CompressionError</code>。</p>
<p>如果指定了 <em>fileobj*，它会被用作对应于 *name</em> 的以二进制模式打开的 file object 的替代。 它会被设定为处在位置 0。</p>
<p>对于 <code>'w:gz'</code>, <code>'r:gz'</code>, <code>'w:bz2'</code>, <code>'r:bz2'</code>, <code>'x:gz'</code>, <code>'x:bz2'</code> 等模式，<code>tarfile.open()</code> 接受关键字参数 <em>compresslevel</em> (默认值为 <code>9</code>) 来指定文件的压缩等级。</p>
<p>对于 <code>'w:xz'</code> 和 <code>'x:xz'</code> 模式，<code>tarfile.open()</code> 接受关键字参数 <em>preset</em> 来指定文件的压缩等级。</p>
<p>针对特殊的目的，还存在第二种 <em>mode</em> 格式: <code>'filemode|[compression]'</code>。 <code>tarfile.open()</code> 将返回一个将其数据作为数据块流来处理的 <code>TarFile</code> 对象。 对此文件将不能执行随机查找。 如果给定了 <em>fileobj*，它可以是任何具有 <code>read()</code> 或 <code>write()</code> 方法 (由 *mode</em> 确定) 的对象。 <em>bufsize</em> 指定块大小，默认值为 <code>20 * 512</code> 字节。 可与此格式组合使用的有 <code>sys.stdin</code>, 套接字 file object 或磁带设备等。 但是，对于这样的 <code>TarFile</code> 对象存在不允许随机访问的限制。 目前可用的模式如下:</p>
<table>
<thead>
<tr>
<th align="left">模式</th>
<th align="left">动作</th>
</tr>
</thead>
<tbody><tr>
<td align="left">`‘r</td>
<td align="left">*’`</td>
</tr>
<tr>
<td align="left">`‘r</td>
<td align="left">’`</td>
</tr>
<tr>
<td align="left">`‘r</td>
<td align="left">gz’`</td>
</tr>
<tr>
<td align="left">`‘r</td>
<td align="left">bz2’`</td>
</tr>
<tr>
<td align="left">`‘r</td>
<td align="left">xz’`</td>
</tr>
<tr>
<td align="left">`‘w</td>
<td align="left">’`</td>
</tr>
<tr>
<td align="left">`‘w</td>
<td align="left">gz’`</td>
</tr>
<tr>
<td align="left">`‘w</td>
<td align="left">bz2’`</td>
</tr>
<tr>
<td align="left">`‘w</td>
<td align="left">xz’`</td>
</tr>
</tbody></table>
<p>在 3.5 版更改: 添加了 <code>'x'</code> (单独创建) 模式。</p>
<p>在 3.6 版更改: <em>name</em> 形参接受一个 path-like object。</p>
<p><em>class</em> <code>tarfile.TarFile</code></p>
<p>用于读取和写入 tar 归档的类。 请不要直接使用这个类：而要使用 <code>tarfile.open()</code>。 </p>
<p><code>tarfile.is_tarfile</code>(<em>name</em>)</p>
<p>如果 <em>name</em> 是一个 <code>tarfile</code> 能读取的 tar 归档文件则返回 <code>True</code>。 <em>name</em> 可以为 <code>str</code>，文件或文件类对象。</p>
<p>在 3.9 版更改: 支持文件或类文件对象。</p>
<p><code>tarfile</code> 模块定义了以下异常:</p>
<p><em>exception</em> <code>tarfile.TarError</code></p>
<p>所有 <code>tarfile</code> 异常的基类。</p>
<p><em>exception</em> <code>tarfile.ReadError</code></p>
<p>当一个不能被 <code>tarfile</code> 模块处理或者因某种原因而无效的 tar 归档被打开时将被引发。</p>
<p><em>exception</em> <code>tarfile.CompressionError</code></p>
<p>当一个压缩方法不受支持或者当数据无法被正确解码时将被引发。</p>
<p><em>exception</em> <code>tarfile.StreamError</code></p>
<p>当达到流式 <code>TarFile</code> 对象的典型限制时将被引发。</p>
<p><em>exception</em> <code>tarfile.ExtractError</code></p>
<p>当使用 <code>TarFile.extract()</code> 时针对 <em>non-fatal</em> 所引发的异常，但是仅限 <code>TarFile.errorlevel``== 2</code>。</p>
<p><em>exception</em> <code>tarfile.HeaderError</code></p>
<p>如果获取的缓冲区无效则会由 <code>TarInfo.frombuf()</code> 引发的异常。</p>
<p>以下常量在模块层级上可用:</p>
<pre><code>tarfile.ENCODING</code></pre><p>默认的字符编码格式：在 Windows 上为 <code>'utf-8'</code>，其他系统上则为 <code>sys.getfilesystemencoding()</code> 所返回的值。</p>
<p>以下常量各自定义了一个 <code>tarfile</code> 模块能够创建的 tar 归档格式。 </p>
<pre><code>tarfile.USTAR_FORMAT</code></pre><p>POSIX.1-1988 (ustar) 格式。</p>
<pre><code>tarfile.GNU_FORMAT</code></pre><p>GNU tar 格式。</p>
<pre><code>tarfile.PAX_FORMAT</code></pre><p>POSIX.1-2001 (pax) 格式。</p>
<pre><code>tarfile.DEFAULT_FORMAT</code></pre><p>用于创建归档的默认格式。 目前为 <code>PAX_FORMAT</code>。</p>
<p>在 3.8 版更改: 新归档的默认格式已更改为 <code>PAX_FORMAT</code> 而不再是 <code>GNU_FORMAT</code>。</p>
<p>参见</p>
<p>归档操作</p>
<p>标准 <code>shutil</code> 模块所提供的高层级归档工具的文档。</p>
<p><a href="https://www.gnu.org/software/tar/manual/html_node/Standard.html" target="_blank" rel="noopener">GNU tar manual, Basic Tar Format</a></p>
<p>针对 tar 归档文件的文档，包含 GNU tar 扩展。</p>
<h3 id="TarFile-对象"><a href="#TarFile-对象" class="headerlink" title="TarFile 对象"></a>TarFile 对象</h3><p><code>TarFile</code> 对象提供了一个 tar 归档的接口。 一个 tar 归档就是数据块的序列。 一个归档成员（被保存文件）是由一个标头块加多个数据块组成的。 一个文件可以在一个 tar 归档中多次被保存。 每个归档成员都由一个 <code>TarInfo</code> 对象来代表。</p>
<p><code>TarFile</code> 对象可在 <code>with</code> 语句中作为上下文管理器使用。 当语句块结束时它将自动被关闭。 请注意在发生异常事件时被打开用于写入的归档将不会被终结；只有内部使用的文件对象将被关闭。 </p>
<p>3.2 新版功能: 添加了对上下文管理器协议的支持。</p>
<p><em>class</em> <code>tarfile.TarFile</code>(<em>name=None</em>, <em>mode=’r’</em>, <em>fileobj=None</em>, <em>format=DEFAULT_FORMAT</em>, <em>tarinfo=TarInfo</em>, <em>dereference=False</em>, <em>ignore_zeros=False</em>, <em>encoding=ENCODING</em>, <em>errors=’surrogateescape’</em>, <em>pax_headers=None</em>, <em>debug=0</em>, <em>errorlevel=0</em>)</p>
<p>下列所有参数都是可选项并且也可作为实例属性来访问。</p>
<p><em>name</em> 是归档的路径名称。 <em>name</em> 可以是一个 path-like object。 如果给定了 <em>fileobj</em> 则它可以被省略。 在此情况下，如果对象的 <code>name</code> 属性存在则它会被使用。</p>
<p><em>mode</em> 可以为 <code>'r'</code> 表示从现有归档读取，<code>'a'</code> 表示将数据追加到现有文件，<code>'w'</code> 表示创建新文件覆盖现有文件，或者 <code>'x'</code> 表示仅在文件不存在时创建新文件。</p>
<p>如果给定了 <em>fileobj*，它会被用于读取或写入数据。 如果可以被确定，则 *mode</em> 会被 <em>fileobj</em> 的模式所覆盖。 <em>fileobj</em> 的使用将从位置 0 开始。</p>
<p>注解</p>
<p>当 <code>TarFile</code> 被关闭时，<em>fileobj</em> 不会被关闭。</p>
<p><em>format</em> 控制用于写入的归档格式。 它必须为在模块层级定义的常量 <code>USTAR_FORMAT</code>, <code>GNU_FORMAT</code> 或 <code>PAX_FORMAT</code> 中的一个。 当读取时，格式将被自动检测，即使单个归档中存在不同的格式。</p>
<p><em>tarinfo</em> 参数可以被用来将默认的 <code>TarInfo</code> 类替换为另一个。</p>
<p>如果 <em>dereference</em> 为 <code>False</code>，则会将符号链接和硬链接添加到归档中。 如果为 <code>True</code>，则会将目标文件的内容添加到归档中。 在不支持符号链接的系统上参数将不起作用。</p>
<p>如果 <em>ignore_zeros</em> 为 <code>False</code>，则会将空的数据块当作归档的末尾来处理。 如果为 <code>True</code>，则会跳过空的（和无效的）数据块并尝试获取尽可能多的成员。 此参数仅适用于读取拼接的或损坏的归档。</p>
<p><em>debug</em> 可设为从 <code>0</code> (无调试消息) 到 <code>3</code> (全部调试消息)。 消息会被写入到 <code>sys.stderr</code>。</p>
<p>如果 <em>errorlevel</em> 为 <code>0</code>，则当使用 <code>TarFile.extract()</code> 时会忽略所有错误。 无论何种情况，当启用调试时它们都将被显示为调试输出的错误消息。 如果为 <code>1</code>，则所有 <em>fatal</em> 错误会被作为 <code>OSError</code> 异常被引发。 如果为 <code>2</code>，则所有 <em>non-fatal</em> 错误也会被作为 <code>TarError</code> 异常被引发。</p>
<p><em>encoding</em> 和 <em>errors</em> 参数定义了读取或写入归档所使用的字符编码格式以及要如何处理转换错误。 默认设置将适用于大多数用户。 </p>
<p>可选的 <em>pax_headers</em> 参数是字符串的字典，如果 <em>format</em> 为 <code>PAX_FORMAT</code> 它将被作为 pax 全局标头被添加。</p>
<p>在 3.2 版更改: 使用 <code>'surrogateescape'</code> 作为 <em>errors</em> 参数的默认值。</p>
<p>在 3.5 版更改: 添加了 <code>'x'</code> (单独创建) 模式。</p>
<p>在 3.6 版更改: <em>name</em> 形参接受一个 path-like object。</p>
<p><em>classmethod</em> <code>TarFile.open</code>(<em>…</em>)</p>
<p>作为替代的构造器。 <code>tarfile.open()</code> 函数实际上是这个类方法的快捷方式。</p>
<p><code>TarFile.getmember</code>(<em>name</em>)</p>
<p>返回成员 <em>name</em> 的 <code>TarInfo</code> 对象。 如果 <em>name</em> 在归档中找不到，则会引发 <code>KeyError</code>。</p>
<p>注解</p>
<p>如果一个成员在归档中出现超过一次，它的最后一次出现会被视为是最新的版本。</p>
<p><code>TarFile.getmembers</code>()</p>
<p>以 <code>TarInfo</code> 对象列表的形式返回归档的成员。 列表的顺序与归档中成员的顺序一致。</p>
<p><code>TarFile.getnames</code>()</p>
<p>以名称列表的形式返回成员。 它的顺序与 <code>getmembers()</code> 所返回列表的顺序一致。</p>
<p><code>TarFile.list</code>(<em>verbose=True</em>, <em>**,</em> members=None*)</p>
<p>将内容清单打印到 <code>sys.stdout</code>。 如果 <em>verbose</em> 为 <code>False</code>，则将只打印成员名称。 如果为 <code>True</code>，则输出将类似于 <strong>ls -l</strong> 的输出效果。 如果给定了可选的 <em>members</em>，它必须为 <code>getmembers()</code> 所返回的列表的一个子集。</p>
<p>在 3.5 版更改: 添加了 <em>members</em> 形参。</p>
<p><code>TarFile.next</code>()</p>
<p>当 <code>TarFile</code> 被打开用于读取时，以 <code>TarInfo</code> 对象的形式返回归档的下一个成员。 如果不再有可用对象则返回 <code>None</code>。</p>
<p><code>TarFile.extractall</code>(<em>path=’.’</em>, <em>members=None</em>, <em>**,</em> numeric_owner=False*)</p>
<p>将归档中的所有成员提取到当前工作目录或 <em>path</em> 目录。 如果给定了可选的 <em>members</em>，则它必须为 <code>getmembers()</code> 所返回的列表的一个子集。 字典信息例如所有者、修改时间和权限会在所有成员提取完毕后被设置。 这样做是为了避免两个问题：目录的修改时间会在每当在其中创建文件时被重置。 并且如果目录的权限不允许写入，提取文件到目录的操作将失败。</p>
<p>如果 <em>numeric_owner</em> 为 <code>True</code>，则将使用来自 tarfile 的 uid 和 gid 数值来设置被提取文件的所有者/用户组。 在其他情况下，则会使用来自 tarfile 的名称值。</p>
<p>警告</p>
<p>绝不要未经预先检验就从不可靠的源中提取归档文件。 这样有可能在 <em>path</em> 之外创建文件，例如某些成员具有以 <code>"/"</code> 开始的绝对路径文件名或带有两个点号 <code>".."</code> 的文件名。</p>
<p>在 3.5 版更改: 添加了 <em>numeric_owner</em> 形参。</p>
<p>在 3.6 版更改: <em>path</em> 形参接受一个 path-like object。</p>
<p><code>TarFile.extract</code>(<em>member</em>, <em>path=’’</em>, <em>set_attrs=True</em>, <em>**,</em> numeric_owner=False*)</p>
<p>从归档中提取出一个成员放入当前工作目录，将使用其完整名称。 成员的文件信息会尽可能精确地被提取。 <em>member</em> 可以是一个文件名或 <code>TarInfo</code> 对象。 你可以使用 <em>path</em> 指定一个不同的目录。 <em>path</em> 可以是一个 path-like object。 将会设置文件属性 (owner, mtime, mode) 除非 <em>set_attrs</em> 为假值。</p>
<p>如果 <em>numeric_owner</em> 为 <code>True</code>，则将使用来自 tarfile 的 uid 和 gid 数值来设置被提取文件的所有者/用户组。 在其他情况下，则会使用来自 tarfile 的名称值。</p>
<p>注解</p>
<p><code>extract()</code> 方法不会处理某些提取问题。 在大多数情况下你应当考虑使用 <code>extractall()</code> 方法。</p>
<p>警告</p>
<p>查看 <code>extractall()</code> 的警告信息。</p>
<p>在 3.2 版更改: 添加了 <em>set_attrs</em> 形参。</p>
<p>在 3.5 版更改: 添加了 <em>numeric_owner</em> 形参。</p>
<p>在 3.6 版更改: <em>path</em> 形参接受一个 path-like object。</p>
<p><code>TarFile.extractfile</code>(<em>member</em>)</p>
<p>将归档中的一个成员提取为文件对象。 <em>member</em> 可以是一个文件名或 <code>TarInfo</code> 对象。 如果 <em>member</em> 是一个常规文件或链接，则会返回一个 <code>io.BufferedReader</code> 对象。 对于所有其他现有成员，则都将返回 <code>None</code>。 如果 <em>member</em> 未在归档中出现，则会引发 <code>KeyError</code>。</p>
<p>在 3.3 版更改: 返回一个 <code>io.BufferedReader</code> 对象。</p>
<p><code>TarFile.add</code>(<em>name</em>, <em>arcname=None</em>, <em>recursive=True</em>, <em>**,</em> filter=None*)</p>
<p>将文件 <em>name</em> 添加到归档。 <em>name</em> 可以为任意类型的文件（目录、fifo、符号链接等等）。 如果给出 <em>arcname</em> 则它将为归档中的文件指定一个替代名称。 默认情况下会递归地添加目录。 这可以通过将 <em>recursive</em> 设为 <code>False</code> 来避免。 递归操作会按排序顺序添加条目。 如果给定了 <em>filter</em>，它应当为一个接受 <code>TarInfo</code> 对象并返回已修改 <code>TarInfo</code> 对象的函数。 如果它返回 <code>None</code> 则 <code>TarInfo</code> 对象将从归档中被排除。 </p>
<p>在 3.2 版更改: 添加了 <em>filter</em> 形参。</p>
<p>在 3.7 版更改: 递归操作按排序顺序添加条目。</p>
<p><code>TarFile.addfile</code>(<em>tarinfo</em>, <em>fileobj=None</em>)</p>
<p>将 <code>TarInfo</code> 对象 <em>tarinfo</em> 添加到归档。 如果给定了 <em>fileobj</em>，它应当是一个 binary file，并会从中读取 <code>tarinfo.size</code> 个字节添加到归档。 你可以直接创建 <code>TarInfo</code> 对象，或是使用 <code>gettarinfo()</code> 来创建。</p>
<p><code>TarFile.gettarinfo</code>(<em>name=None</em>, <em>arcname=None</em>, <em>fileobj=None</em>)</p>
<p>基于 <code>os.stat()</code> 的结果或者现有文件的相同数据创建一个 <code>TarInfo</code>。 文件或者是命名为 <em>name<em>，或者是使用文件描述符指定为一个 file object *fileobj</em>。 *name</em> 可以是一个 path-like object。 如果给定了 <em>arcname*，则它将为归档中的文件指定一个替代名称，在其他情况下，名称将从 *fileobj</em> 的 <code>name</code> 属性或 <em>name</em> 参数获取。 名称应当是一个文本字符串。</p>
<p>你可以在使用 <code>addfile()</code> 添加 <code>TarInfo</code> 的某些属性之前修改它们。 如果文件对象不是从文件开头进行定位的普通文件对象，<code>size</code> 之类的属性就可能需要修改。 例如 <code>GzipFile</code> 之类的文件就属于这种情况。 <code>name</code> 也可以被修改，在这种情况下 <em>arcname</em> 可以是一个占位字符串。</p>
<p>在 3.6 版更改: <em>name</em> 形参接受一个 path-like object。</p>
<p><code>TarFile.close</code>()</p>
<p>关闭 <code>TarFile</code>。 在写入模式下，会向归档添加两个表示结束的零数据块。</p>
<pre><code>TarFile.pax_headers</code></pre><p>一个包含 pax 全局标头的键值对的字典。</p>
<h3 id="TarInfo-对象"><a href="#TarInfo-对象" class="headerlink" title="TarInfo 对象"></a>TarInfo 对象</h3><p><code>TarInfo</code> 对象代表 <code>TarFile</code> 中的一个文件。 除了会存储所有必要的文件属性（例如文件类型、大小、时间、权限、所有者等），它还提供了一些确定文件类型的有用方法。 此对象 <em>并不</em> 包含文件数据本身。</p>
<p><code>TarInfo</code> 对象可通过 <code>TarFile</code> 的方法 <code>getmember()</code>, <code>getmembers()</code> 和 <code>gettarinfo()</code> 返回。</p>
<p><em>class</em> <code>tarfile.TarInfo</code>(<em>name=’’</em>)</p>
<p>创建一个 <code>TarInfo</code> 对象。</p>
<p><em>classmethod</em> <code>TarInfo.frombuf</code>(<em>buf</em>, <em>encoding</em>, <em>errors</em>)</p>
<p>基于字符串缓冲区 <em>buf</em> 创建并返回一个 <code>TarInfo</code> 对象。</p>
<p>如果缓冲区无效则会引发 <code>HeaderError</code>。</p>
<p><em>classmethod</em> <code>TarInfo.fromtarfile</code>(<em>tarfile</em>)</p>
<p>从 <code>TarFile</code> 对象 <em>tarfile</em> 读取下一个成员并将其作为 <code>TarInfo</code> 对象返回。</p>
<p><code>TarInfo.tobuf</code>(<em>format=DEFAULT_FORMAT</em>, <em>encoding=ENCODING</em>, <em>errors=’surrogateescape’</em>)</p>
<p>基于 <code>TarInfo</code> 对象创建一个字符串缓冲区。 </p>
<p>在 3.2 版更改: 使用 <code>'surrogateescape'</code> 作为 <em>errors</em> 参数的默认值。</p>
<p><code>TarInfo</code> 对象具有以下公有数据属性:</p>
<pre><code>TarInfo.name</code></pre><p>归档成员的名称。</p>
<pre><code>TarInfo.size</code></pre><p>以字节表示的大小。</p>
<pre><code>TarInfo.mtime</code></pre><p>上次修改的时间。</p>
<pre><code>TarInfo.mode</code></pre><p>权限位。</p>
<pre><code>TarInfo.type</code></pre><p>文件类型。 <em>type</em> 通常为以下常量之一: <code>REGTYPE</code>, <code>AREGTYPE</code>, <code>LNKTYPE</code>, <code>SYMTYPE</code>, <code>DIRTYPE</code>, <code>FIFOTYPE</code>, <code>CONTTYPE</code>, <code>CHRTYPE</code>, <code>BLKTYPE</code>, <code>GNUTYPE_SPARSE</code>。 要更方便地确定一个 <code>TarInfo</code> 对象的类型，请使用下述的 <code>is*()</code> 方法。</p>
<pre><code>TarInfo.linkname</code></pre><p>目标文件名的名称，该属性仅在类型为 <code>LNKTYPE</code> 和 <code>SYMTYPE</code> 的 <code>TarInfo</code> 对象中存在。</p>
<pre><code>TarInfo.uid</code></pre><p>最初保存该成员的用户的用户 ID。</p>
<pre><code>TarInfo.gid</code></pre><p>最初保存该成员的用户的分组 ID。</p>
<pre><code>TarInfo.uname</code></pre><p>用户名。</p>
<pre><code>TarInfo.gname</code></pre><p>分组名。</p>
<pre><code>TarInfo.pax_headers</code></pre><p>一个包含所关联的 pax 扩展标头的键值对的字典。</p>
<p><code>TarInfo</code> 对象还提供了一些便捷查询方法:</p>
<p><code>TarInfo.isfile</code>()</p>
<p>如果 <code>Tarinfo</code> 对象为普通文件则返回 <code>True</code>。</p>
<p><code>TarInfo.isreg</code>()</p>
<p>与 <code>isfile()</code> 相同。</p>
<p><code>TarInfo.isdir</code>()</p>
<p>如果为目录则返回 <code>True</code>。</p>
<p><code>TarInfo.issym</code>()</p>
<p>如果为符号链接则返回 <code>True</code>。</p>
<p><code>TarInfo.islnk</code>()</p>
<p>如果为硬链接则返回 <code>True</code>。</p>
<p><code>TarInfo.ischr</code>()</p>
<p>如果为字符设备则返回 <code>True</code>。</p>
<p><code>TarInfo.isblk</code>()</p>
<p>如果为块设备则返回 <code>True</code>。</p>
<p><code>TarInfo.isfifo</code>()</p>
<p>如果为 FIFO 则返回 <code>True</code>。.</p>
<p><code>TarInfo.isdev</code>()</p>
<p>如果为字符设备、块设备或 FIFO 之一则返回 <code>True</code>。</p>
<h3 id="命令行接口-1"><a href="#命令行接口-1" class="headerlink" title="命令行接口"></a>命令行接口</h3><p>3.4 新版功能.</p>
<p><code>tarfile</code> 模块提供了简单的命令行接口以便与 tar 归档进行交互。</p>
<p>如果你想要创建一个新的 tar 归档，请在 <code>-c</code> 选项后指定其名称然后列出应当被包含的文件名:</p>
<pre><code>$ python -m tarfile -c monty.tar  spam.txt eggs.txt</code></pre><p>传入一个字典也是可接受的:</p>
<pre><code>$ python -m tarfile -c monty.tar life-of-brian_1979/</code></pre><p>如果你想要将一个 tar 归档提取到指定的目录，请使用 <code>-e</code> 选项:</p>
<pre><code>$ python -m tarfile -e monty.tar</code></pre><p>你也可以通过传入目录名称将一个 tar 归档提取到不同的目录:</p>
<pre><code>$ python -m tarfile -e monty.tar  other-dir/</code></pre><p>要获取一个 tar 归档中文件的列表，请使用 <code>-l</code> 选项:</p>
<pre><code>$ python -m tarfile -l monty.tar</code></pre><h4 id="命令行选项-2"><a href="#命令行选项-2" class="headerlink" title="命令行选项"></a>命令行选项</h4><pre><code>-l` `&lt;tarfile&gt;
--list` `&lt;tarfile&gt;</code></pre><p>列出一个 tarfile 中的文件名。</p>
<pre><code>-c` `&lt;tarfile&gt; &lt;source1&gt; ... &lt;sourceN&gt;
--create` `&lt;tarfile&gt; &lt;source1&gt; ... &lt;sourceN&gt;</code></pre><p>基于源文件创建 tarfile。</p>
<pre><code>-e` `&lt;tarfile&gt; [&lt;output_dir&gt;]
--extract` `&lt;tarfile&gt; [&lt;output_dir&gt;]</code></pre><p>如果未指定 <em>output_dir</em> 则会将 tarfile 提取到当前目录。</p>
<pre><code>-t` `&lt;tarfile&gt;
--test` `&lt;tarfile&gt;</code></pre><p>检测 tarfile 是否有效。</p>
<pre><code>-v``,` `--verbose</code></pre><p>更详细地输出结果。</p>
<h3 id="例子-3"><a href="#例子-3" class="headerlink" title="例子"></a>例子</h3><p>如何将整个 tar 归档提取到当前工作目录:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> tarfile
tar <span class="token operator">=</span> tarfile<span class="token punctuation">.</span>open<span class="token punctuation">(</span><span class="token string">"sample.tar.gz"</span><span class="token punctuation">)</span>
tar<span class="token punctuation">.</span>extractall<span class="token punctuation">(</span><span class="token punctuation">)</span>
tar<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>如何通过 <code>TarFile.extractall()</code> 使用生成器函数而非列表来提取一个 tar 归档的子集:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> os
<span class="token keyword">import</span> tarfile
<span class="token keyword">def</span> <span class="token function">py_files</span><span class="token punctuation">(</span>members<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">for</span> tarinfo <span class="token keyword">in</span> members<span class="token punctuation">:</span>
        <span class="token keyword">if</span> os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>splitext<span class="token punctuation">(</span>tarinfo<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">".py"</span><span class="token punctuation">:</span>
            <span class="token keyword">yield</span> tarinfo
tar <span class="token operator">=</span> tarfile<span class="token punctuation">.</span>open<span class="token punctuation">(</span><span class="token string">"sample.tar.gz"</span><span class="token punctuation">)</span>
tar<span class="token punctuation">.</span>extractall<span class="token punctuation">(</span>members<span class="token operator">=</span>py_files<span class="token punctuation">(</span>tar<span class="token punctuation">)</span><span class="token punctuation">)</span>
tar<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如何基于一个文件名列表创建未压缩的 tar 归档:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> tarfile
tar <span class="token operator">=</span> tarfile<span class="token punctuation">.</span>open<span class="token punctuation">(</span><span class="token string">"sample.tar"</span><span class="token punctuation">,</span> <span class="token string">"w"</span><span class="token punctuation">)</span>
<span class="token keyword">for</span> name <span class="token keyword">in</span> <span class="token punctuation">[</span><span class="token string">"foo"</span><span class="token punctuation">,</span> <span class="token string">"bar"</span><span class="token punctuation">,</span> <span class="token string">"quux"</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
    tar<span class="token punctuation">.</span>add<span class="token punctuation">(</span>name<span class="token punctuation">)</span>
tar<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>使用 <code>with</code> 语句的同一个示例:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> tarfile
<span class="token keyword">with</span> tarfile<span class="token punctuation">.</span>open<span class="token punctuation">(</span><span class="token string">"sample.tar"</span><span class="token punctuation">,</span> <span class="token string">"w"</span><span class="token punctuation">)</span> <span class="token keyword">as</span> tar<span class="token punctuation">:</span>
    <span class="token keyword">for</span> name <span class="token keyword">in</span> <span class="token punctuation">[</span><span class="token string">"foo"</span><span class="token punctuation">,</span> <span class="token string">"bar"</span><span class="token punctuation">,</span> <span class="token string">"quux"</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
        tar<span class="token punctuation">.</span>add<span class="token punctuation">(</span>name<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>如何读取一个 gzip 压缩的 tar 归档并显示一些成员信息:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> tarfile
tar <span class="token operator">=</span> tarfile<span class="token punctuation">.</span>open<span class="token punctuation">(</span><span class="token string">"sample.tar.gz"</span><span class="token punctuation">,</span> <span class="token string">"r:gz"</span><span class="token punctuation">)</span>
<span class="token keyword">for</span> tarinfo <span class="token keyword">in</span> tar<span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>tarinfo<span class="token punctuation">.</span>name<span class="token punctuation">,</span> <span class="token string">"is"</span><span class="token punctuation">,</span> tarinfo<span class="token punctuation">.</span>size<span class="token punctuation">,</span> <span class="token string">"bytes in size and is "</span><span class="token punctuation">,</span> end<span class="token operator">=</span><span class="token string">""</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> tarinfo<span class="token punctuation">.</span>isreg<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"a regular file."</span><span class="token punctuation">)</span>
    <span class="token keyword">elif</span> tarinfo<span class="token punctuation">.</span>isdir<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"a directory."</span><span class="token punctuation">)</span>
    <span class="token keyword">else</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"something else."</span><span class="token punctuation">)</span>
tar<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如何创建一个归档并使用 <code>TarFile.add()</code> 中的 <em>filter</em> 形参来重置用户信息:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> tarfile
<span class="token keyword">def</span> <span class="token function">reset</span><span class="token punctuation">(</span>tarinfo<span class="token punctuation">)</span><span class="token punctuation">:</span>
    tarinfo<span class="token punctuation">.</span>uid <span class="token operator">=</span> tarinfo<span class="token punctuation">.</span>gid <span class="token operator">=</span> <span class="token number">0</span>
    tarinfo<span class="token punctuation">.</span>uname <span class="token operator">=</span> tarinfo<span class="token punctuation">.</span>gname <span class="token operator">=</span> <span class="token string">"root"</span>
    <span class="token keyword">return</span> tarinfo
tar <span class="token operator">=</span> tarfile<span class="token punctuation">.</span>open<span class="token punctuation">(</span><span class="token string">"sample.tar.gz"</span><span class="token punctuation">,</span> <span class="token string">"w:gz"</span><span class="token punctuation">)</span>
tar<span class="token punctuation">.</span>add<span class="token punctuation">(</span><span class="token string">"foo"</span><span class="token punctuation">,</span> filter<span class="token operator">=</span>reset<span class="token punctuation">)</span>
tar<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="受支持的-tar-格式"><a href="#受支持的-tar-格式" class="headerlink" title="受支持的 tar 格式"></a>受支持的 tar 格式</h3><p>通过 <code>tarfile</code> 模块可以创建三种 tar 格式:</p>
<ul>
<li><p>The POSIX.1-1988 ustar 格式 (<code>USTAR_FORMAT</code>)。 它支持最多 256 个字符的文件名长度和最多 100 个字符的链接名长度。 文件大小上限为 8 GiB。 这是一种老旧但广受支持的格式。</p>
</li>
<li><p>GNU tar 格式 (<code>GNU_FORMAT</code>)。 它支持长文件名和链接名、大于 8 GiB 的文件以及稀疏文件。 它是 GNU/Linux 系统上的事实标准。 <code>tarfile</code> 完全支持针对长名称的 GNU tar 扩展，稀疏文件支持则限制为只读。</p>
</li>
<li><p>POSIX.1-2001 pax 格式 (<code>PAX_FORMAT</code>)。 它是几乎无限制的最灵活格式。 它支持长文件名和链接名，大文件以及使用便捷方式存储路径名。 现代的 tar 实现，包括 GNU tar, bsdtar/libarchive 和 star，完全支持扩展 <em>pax</em> 特性；某些老旧或不维护的库可能不受支持，但应当会将 <em>pax</em> 归档视为广受支持的 <em>ustar</em> 格式。 这是目前新建归档的默认格式。</p>
<p>它扩展了现有的 <em>ustar</em> 格式，包括用于无法以其他方式存储的附加标头。 存在两种形式的 pax 标头：扩展标头只影响后续的文件标头，全局标头则适用于完整归档并会影响所有后续的文件。 为了便于移植，在 pax 标头中的所有数据均以 <em>UTF-8</em> 编码。</p>
</li>
</ul>
<p>还有一些 tar 格式的其他变种，它们可以被读取但不能被创建:</p>
<ul>
<li>古老的 V7 格式。 这是来自 Unix 第七版的第一个 tar 格式，它只存储常规文件和目录。 名称长度不能超过 100 个字符，并且没有用户/分组名信息。 某些归档在带有非 ASCII 字符字段的情况下会产生计算错误的标头校验和。</li>
<li>SunOS tar 扩展格式。 此格式是 POSIX.1-2001 pax 格式的一个变种，但并不保持兼容。</li>
</ul>
<h3 id="Unicode-问题"><a href="#Unicode-问题" class="headerlink" title="Unicode 问题"></a>Unicode 问题</h3><p>最初 tar 格式被设计用来在磁带机上生成备份，主要关注于保存文件系统信息。 现在 tar 归档通常用于文件分发和在网络上交换归档。 最初格式（它是所有其他格式的基础）的一个问题是它没有支持不同字符编码格式的概念。 例如，一个在 <em>UTF-8</em> 系统上创建的普通 tar 归档如果包含非 <em>ASCII</em> 字符则将无法在 <em>Latin-1</em> 系统上被正确读取。 文本元数据（例如文件名，链接名，用户/分组名）将变为损坏状态。 不幸的是，没有什么办法能够自动检测一个归档的编码格式。 pax 格式被设计用来解决这个问题。 它使用通用字符编码格式 <em>UTF-8</em> 来存储非 ASCII 元数据。</p>
<p>在 <code>tarfile</code> 中字符转换的细节由 <code>TarFile</code> 类的 <em>encoding</em> 和 <em>errors</em> 关键字参数控制。</p>
<p><em>encoding</em> 定义了用于归档中元数据的字符编码格式。 默认值为 <code>sys.getfilesystemencoding()</code> 或是回退选项 <code>'ascii'</code>。 根据归档是被读取还是被写入，元数据必须被解码或编码。 如果没有正确设置 <em>encoding</em>，转换可能会失败。</p>
<p><em>errors</em> 参数定义了不能被转换的字符将如何处理。 可能的取值在 错误处理方案 小节列出。 默认方案为 <code>'surrogateescape'</code>，它也被 Python 用于文件系统调用。</p>
<p>对于 <code>PAX_FORMAT</code> 归档（默认格式），<em>encoding</em> 通常是不必要的，因为所有元数据都使用 <em>UTF-8</em> 来存储。 <em>encoding</em> 仅在解码二进制 pax 标头或存储带有替代字符的字符串等少数场景下会被使用。</p>
<h1 id="文件格式"><a href="#文件格式" class="headerlink" title="文件格式"></a>文件格式</h1><ul>
<li><code>csv</code> —- CSV 文件读写<ul>
<li>模块内容</li>
<li>变种与格式参数</li>
<li>Reader 对象</li>
<li>Writer 对象</li>
<li>例子</li>
</ul>
</li>
<li><code>configparser</code> —- 配置文件解析器<ul>
<li>快速起步</li>
<li>支持的数据类型</li>
<li>回退值</li>
<li>受支持的 INI 文件结构</li>
<li>值的插值</li>
<li>映射协议访问</li>
<li>定制解析器行为</li>
<li>旧式 API 示例</li>
<li>ConfigParser 对象</li>
<li>RawConfigParser 对象</li>
<li>异常</li>
</ul>
</li>
<li><code>netrc</code> —- netrc 文件处理<ul>
<li>netrc 对象</li>
</ul>
</li>
<li><code>xdrlib</code> —- 编码与解码 XDR 数据<ul>
<li>Packer 对象</li>
<li>Unpacker 对象</li>
<li>异常</li>
</ul>
</li>
<li><code>plistlib</code> —- 生成与解析 Apple <code>.plist</code> 文件<ul>
<li>例子</li>
</ul>
</li>
</ul>
<h2 id="csv-—-CSV-文件读写"><a href="#csv-—-CSV-文件读写" class="headerlink" title="csv —- CSV 文件读写"></a><code>csv</code> —- CSV 文件读写</h2><p><strong>源代码：</strong><a href="https://github.com/python/cpython/tree/3.10/Lib/csv.py" target="_blank" rel="noopener">Lib/csv.py</a></p>
<hr>
<p>CSV (Comma Separated Values) 格式是电子表格和数据库中最常见的输入、输出文件格式。在 <a href="https://tools.ietf.org/html/rfc4180.html" target="_blank" rel="noopener"><strong>RFC 4180</strong></a> 规范推出的很多年前，CSV 格式就已经被开始使用了，由于当时并没有合理的标准，不同应用程序读写的数据会存在细微的差别。这种差别让处理多个来源的 CSV 文件变得困难。但尽管分隔符会变化，此类文件的大致格式是相似的，所以编写一个单独的模块以高效处理此类数据，将程序员从读写数据的繁琐细节中解放出来是有可能的。</p>
<p><code>csv</code> 模块实现了 CSV 格式表单数据的读写。其提供了诸如“以兼容 Excel 的方式输出数据文件”或“读取 Excel 程序输出的数据文件”的功能，程序员无需知道 Excel 所采用 CSV 格式的细节。此模块同样可以用于定义其他应用程序可用的 CSV 格式或定义特定需求的 CSV 格式。</p>
<p><code>csv</code> 模块中的 <code>reader</code> 类和 <code>writer</code> 类可用于读写序列化的数据。也可使用 <code>DictReader</code> 类和 <code>DictWriter</code> 类以字典的形式读写数据。</p>
<h3 id="模块内容"><a href="#模块内容" class="headerlink" title="模块内容"></a>模块内容</h3><p><code>csv</code> 模块定义了以下函数：</p>
<p><code>csv.reader</code>(<em>csvfile</em>, <em>dialect=’excel’</em>, <em>**fmtparams</em>)</p>
<p>返回一个 reader 对象，该对象将逐行遍历 <em>csvfile<em>。</em>csvfile</em> 可以是任何对象，只要这个对象支持 iterator 协议并在每次调用 <code>__next__()</code> 方法时都返回字符串，文件对象 和列表对象均适用。如果 <em>csvfile</em> 是文件对象，则打开它时应使用 <code>newline=''</code>。可选参数 <em>dialect</em> 是用于不同的 CSV 变种的特定参数组。它可以是 <code>Dialect</code> 类的子类的实例，也可以是 <code>list_dialects()</code> 函数返回的字符串之一。另一个可选关键字参数 <em>fmtparams</em> 可以覆写当前变种格式中的单个格式设置。</p>
<p>csv 文件的每一行都读取为一个由字符串组成的列表。除非指定了 <code>QUOTE_NONNUMERIC</code> 格式选项（在这种情况下，未加引号的字段会转换为浮点数），否则不会执行自动数据类型转换。</p>
<p>一个简短的用法示例:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span><span class="token keyword">import</span> csv
<span class="token operator">>></span><span class="token operator">></span><span class="token keyword">with</span> open<span class="token punctuation">(</span><span class="token string">'eggs.csv'</span><span class="token punctuation">,</span> newline<span class="token operator">=</span><span class="token string">''</span><span class="token punctuation">)</span><span class="token keyword">as</span> csvfile<span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     spamreader <span class="token operator">=</span> csv<span class="token punctuation">.</span>reader<span class="token punctuation">(</span>csvfile<span class="token punctuation">,</span> delimiter<span class="token operator">=</span><span class="token string">' '</span><span class="token punctuation">,</span> quotechar<span class="token operator">=</span><span class="token string">'|'</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">for</span> row <span class="token keyword">in</span> spamreader<span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">', '</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>row<span class="token punctuation">)</span><span class="token punctuation">)</span>
Spam<span class="token punctuation">,</span>Spam<span class="token punctuation">,</span>Spam<span class="token punctuation">,</span>Spam<span class="token punctuation">,</span>Spam<span class="token punctuation">,</span>BakedBeans
Spam<span class="token punctuation">,</span>LovelySpam<span class="token punctuation">,</span>WonderfulSpam<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>csv.writer</code>(<em>csvfile</em>, <em>dialect=’excel’</em>, <em>**fmtparams</em>)</p>
<p>返回一个 writer 对象，该对象负责将用户的数据在给定的文件类对象上转换为带分隔符的字符串。 <em>csvfile</em> 可以是任何具有 <code>write()</code> 方法的对象。 如果 <em>csvfile</em> 是一个文件对象，则打开它时应使用 <code>newline=''</code>。 可以给出可选的 <em>dialect</em> 形参用来定义一组特定 CSV 变种专属的形参。 它可以是 <code>Dialect</code> 类的某个子类的实例或是 <code>list_dialects()</code> 函数所返回的字符串之一。 还可以给出另一个可选的 <em>fmtparams</em> 关键字参数来覆盖当前变种中的单个格式化形参。  为了尽量简化与实现 DB API 的模块之间的接口，<code>None</code> 值会被当作空字符串写入。 虽然这个转换是不可逆的，但它可以简化 SQL NULL 数据值到 CSV 文件的转储而无需预处理从 <code>cursor.fetch*</code> 调用返回的数据。 在被写入之前所有其他非字符串数据都会先用 <code>str()</code> 来转转为字符串。</p>
<p>一个简短的用法示例:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> csv
<span class="token keyword">with</span> open<span class="token punctuation">(</span><span class="token string">'eggs.csv'</span><span class="token punctuation">,</span><span class="token string">'w'</span><span class="token punctuation">,</span> newline<span class="token operator">=</span><span class="token string">''</span><span class="token punctuation">)</span><span class="token keyword">as</span> csvfile<span class="token punctuation">:</span>
    spamwriter <span class="token operator">=</span> csv<span class="token punctuation">.</span>writer<span class="token punctuation">(</span>csvfile<span class="token punctuation">,</span> delimiter<span class="token operator">=</span><span class="token string">' '</span><span class="token punctuation">,</span>
                            quotechar<span class="token operator">=</span><span class="token string">'|'</span><span class="token punctuation">,</span> quoting<span class="token operator">=</span>csv<span class="token punctuation">.</span>QUOTE_MINIMAL<span class="token punctuation">)</span>
    spamwriter<span class="token punctuation">.</span>writerow<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'Spam'</span><span class="token punctuation">]</span><span class="token operator">*</span><span class="token number">5</span><span class="token operator">+</span><span class="token punctuation">[</span><span class="token string">'Baked Beans'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
    spamwriter<span class="token punctuation">.</span>writerow<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'Spam'</span><span class="token punctuation">,</span><span class="token string">'Lovely Spam'</span><span class="token punctuation">,</span><span class="token string">'Wonderful Spam'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>csv.register_dialect</code>(<em>name</em>[, <em>dialect</em>[, <em>*</em>fmtparams*]])</p>
<p>将 <em>dialect</em> 与 <em>name</em> 关联起来。 <em>name</em> 必须是字符串。 变种的指定可以通过传入一个 <code>Dialect</code> 的子类，或通过 <em>fmtparams</em> 关键字参数，或是两者同时传入，此时关键字参数会覆盖 dialect 形参。 </p>
<p><code>csv.unregister_dialect</code>(<em>name</em>)</p>
<p>从变种注册表中删除 <em>name</em> 对应的变种。如果 <em>name</em> 不是已注册的变种名称，则抛出 <code>Error</code> 异常。</p>
<p><code>csv.get_dialect</code>(<em>name</em>)</p>
<p>返回 <em>name</em> 对应的变种。如果 <em>name</em> 不是已注册的变种名称，则抛出 <code>Error</code> 异常。该函数返回的是不可变的 <code>Dialect</code> 对象。</p>
<p><code>csv.list_dialects</code>()</p>
<p>返回所有已注册变种的名称。</p>
<p><code>csv.field_size_limit</code>([<em>new_limit</em>])</p>
<p>返回解析器当前允许的最大字段大小。如果指定了 <em>new_limit</em>，则它将成为新的最大字段大小。</p>
<p><code>csv</code> 模块定义了以下类：</p>
<p><em>class<em><code>csv.DictReader</code>(</em>f</em>, <em>fieldnames=None</em>, <em>restkey=None</em>, <em>restval=None</em>, <em>dialect=’excel’</em>, <em>\</em>args<em>,</em> <em>*kwds</em>)</p>
<p>创建一个对象，该对象在操作上类似于常规 reader，但是将每行中的信息映射到一个 <code>dict</code>，该 dict 的键由 <em>fieldnames</em> 可选参数给出。</p>
<p><em>fieldnames</em> 参数是一个 sequence。如果省略 <em>fieldnames*，则文件 *f</em> 第一行中的值将用作字段名。无论字段名是如何确定的，字典都将保留其原始顺序。</p>
<p>如果某一行中的字段多于字段名，则剩余数据会被放入一个列表，并与 <em>restkey</em> 所指定的字段名 (默认为 <code>None</code>) 一起保存。 如果某个非空白行的字段少于字段名，则缺失的值会使用 <em>restval</em> 的值来填充 (默认为 <code>None</code>)。</p>
<p>所有其他可选或关键字参数都传递给底层的 <code>reader</code> 实例。</p>
<p>在 3.6 版更改: 返回的行现在的类型是 <code>OrderedDict</code>。</p>
<p>在 3.8 版更改: 现在，返回的行是 <code>dict</code> 类型。</p>
<p>一个简短的用法示例:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span><span class="token keyword">import</span> csv
<span class="token operator">>></span><span class="token operator">></span><span class="token keyword">with</span> open<span class="token punctuation">(</span><span class="token string">'names.csv'</span><span class="token punctuation">,</span> newline<span class="token operator">=</span><span class="token string">''</span><span class="token punctuation">)</span><span class="token keyword">as</span> csvfile<span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     reader <span class="token operator">=</span> csv<span class="token punctuation">.</span>DictReader<span class="token punctuation">(</span>csvfile<span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">for</span> row <span class="token keyword">in</span> reader<span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">print</span><span class="token punctuation">(</span>row<span class="token punctuation">[</span><span class="token string">'first_name'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> row<span class="token punctuation">[</span><span class="token string">'last_name'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
EricIdle
JohnCleese
<span class="token operator">>></span><span class="token operator">></span><span class="token keyword">print</span><span class="token punctuation">(</span>row<span class="token punctuation">)</span>
<span class="token punctuation">{</span><span class="token string">'first_name'</span><span class="token punctuation">:</span><span class="token string">'John'</span><span class="token punctuation">,</span><span class="token string">'last_name'</span><span class="token punctuation">:</span><span class="token string">'Cleese'</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><em>class<em><code>csv.DictWriter</code>(</em>f</em>, <em>fieldnames</em>, <em>restval=’’</em>, <em>extrasaction=’raise’</em>, <em>dialect=’excel’</em>, <em>\</em>args<em>,</em> <em>*kwds</em>)</p>
<p>创建一个对象，该对象在操作上类似常规 writer，但会将字典映射到输出行。 <em>fieldnames</em> 参数是由键组成的 <code>序列</code>，它指定字典中值的顺序，这些值会按指定顺序传递给 <code>writerow()</code> 方法并写入文件 <em>f</em>。 如果字典缺少 <em>fieldnames</em> 中的键，则可选参数 <em>restval</em> 用于指定要写入的值。 如果传递给 <code>writerow()</code> 方法的字典的某些键在 <em>fieldnames</em> 中找不到，则可选参数 <em>extrasaction</em> 用于指定要执行的操作。 如果将其设置为默认值 <code>'raise'</code>，则会引发 <code>ValueError</code>。 如果将其设置为 <code>'ignore'</code>，则字典中的其他键值将被忽略。 所有其他可选或关键字参数都传递给底层的 <code>writer</code> 实例。</p>
<p>注意，与 <code>DictReader</code> 类不同，<code>DictWriter</code> 类的 <em>fieldnames</em> 参数不是可选参数。</p>
<p>一个简短的用法示例:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> csv
<span class="token keyword">with</span> open<span class="token punctuation">(</span><span class="token string">'names.csv'</span><span class="token punctuation">,</span><span class="token string">'w'</span><span class="token punctuation">,</span> newline<span class="token operator">=</span><span class="token string">''</span><span class="token punctuation">)</span><span class="token keyword">as</span> csvfile<span class="token punctuation">:</span>
    fieldnames <span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">'first_name'</span><span class="token punctuation">,</span><span class="token string">'last_name'</span><span class="token punctuation">]</span>
    writer <span class="token operator">=</span> csv<span class="token punctuation">.</span>DictWriter<span class="token punctuation">(</span>csvfile<span class="token punctuation">,</span> fieldnames<span class="token operator">=</span>fieldnames<span class="token punctuation">)</span>
    writer<span class="token punctuation">.</span>writeheader<span class="token punctuation">(</span><span class="token punctuation">)</span>
    writer<span class="token punctuation">.</span>writerow<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">'first_name'</span><span class="token punctuation">:</span><span class="token string">'Baked'</span><span class="token punctuation">,</span><span class="token string">'last_name'</span><span class="token punctuation">:</span><span class="token string">'Beans'</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
    writer<span class="token punctuation">.</span>writerow<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">'first_name'</span><span class="token punctuation">:</span><span class="token string">'Lovely'</span><span class="token punctuation">,</span><span class="token string">'last_name'</span><span class="token punctuation">:</span><span class="token string">'Spam'</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
    writer<span class="token punctuation">.</span>writerow<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">'first_name'</span><span class="token punctuation">:</span><span class="token string">'Wonderful'</span><span class="token punctuation">,</span><span class="token string">'last_name'</span><span class="token punctuation">:</span><span class="token string">'Spam'</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><em>class</em><code>csv.Dialect</code></p>
<p><code>Dialect</code> 类是一个容器类，其属性包含有如何处理双引号、空白符、分隔符等的信息。 由于缺少严格的 CSV 规格描述，不同的应用程序会产生略有差别的 CSV 数据。 <code>Dialect</code> 实例定义了 <code>reader</code> 和 <code>writer</code> 实例将具有怎样的行为。</p>
<p>所有可用的 <code>Dialect</code> 名称会由 <code>list_dialects()</code> 返回，并且它们可由特定的 <code>reader</code> 和 <code>writer</code> 类通过它们的初始化函数 (<code>__init__</code>) 来注册，例如:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> csv
<span class="token keyword">with</span> open<span class="token punctuation">(</span><span class="token string">'students.csv'</span><span class="token punctuation">,</span><span class="token string">'w'</span><span class="token punctuation">,</span> newline<span class="token operator">=</span><span class="token string">''</span><span class="token punctuation">)</span><span class="token keyword">as</span> csvfile<span class="token punctuation">:</span>
    writer <span class="token operator">=</span> csv<span class="token punctuation">.</span>writer<span class="token punctuation">(</span>csvfile<span class="token punctuation">,</span> dialect<span class="token operator">=</span><span class="token string">'unix'</span><span class="token punctuation">)</span>
<span class="token operator">^</span><span class="token operator">^</span><span class="token operator">^</span><span class="token operator">^</span><span class="token operator">^</span><span class="token operator">^</span><span class="token operator">^</span><span class="token operator">^</span><span class="token operator">^</span><span class="token operator">^</span><span class="token operator">^</span><span class="token operator">^</span><span class="token operator">^</span><span class="token operator">^</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p><em>class</em><code>csv.excel</code></p>
<p><code>excel</code> 类定义了 Excel 生成的 CSV 文件的常规属性。它在变种注册表中的名称是 <code>'excel'</code>。</p>
<p><em>class</em><code>csv.excel_tab</code></p>
<p><code>excel_tab</code> 类定义了 Excel 生成的、制表符分隔的 CSV 文件的常规属性。它在变种注册表中的名称是 <code>'excel-tab'</code>。</p>
<p><em>class</em><code>csv.unix_dialect</code></p>
<p><code>unix_dialect</code> 类定义了在 UNIX 系统上生成的 CSV 文件的常规属性，即使用 <code>'\n'</code> 作为换行符，且所有字段都有引号包围。它在变种注册表中的名称是 <code>'unix'</code>。</p>
<p>3.2 新版功能.</p>
<p><em>class</em><code>csv.Sniffer</code></p>
<p><code>Sniffer</code> 类用于推断 CSV 文件的格式。</p>
<p><code>Sniffer</code> 类提供了两个方法：</p>
<ul>
<li><p><code>sniff</code>(<em>sample</em>, <em>delimiters=None</em>)</p>
<p>分析给定的 <em>sample</em> 并返回一个 <code>Dialect</code> 子类，该子类中包含了分析出的格式参数。如果给出可选的 <em>delimiters</em> 参数，则该参数会被解释为字符串，该字符串包含了可能的有效定界符。</p>
</li>
<li><p><code>has_header</code>(<em>sample</em>)</p>
<p>分析 sample 文本（假定为 CSV 格式），如果发现其首行为一组列标题则返回 <code>True</code>。 在检查每一列时，将考虑是否满足两个关键标准之一来估计 sample 是否包含标题:</p>
<blockquote>
<ul>
<li>第二至第 n 行包含数字值</li>
<li>第二至第 n 行包含字符串值，其中至少有一个值的长度与该列预期标题的长度不同。</li>
</ul>
</blockquote>
<p>会对第一行之后的二十行进行采样；如果有超过一半的列 + 行符合标准，则返回 <code>True</code>。</p>
</li>
</ul>
<p>注解</p>
<p>此方法是一个粗略的启发式方式，有可能产生错误的真值和假值。</p>
<p>使用 <code>Sniffer</code> 的示例：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">with</span> open<span class="token punctuation">(</span><span class="token string">'example.csv'</span><span class="token punctuation">,</span> newline<span class="token operator">=</span><span class="token string">''</span><span class="token punctuation">)</span><span class="token keyword">as</span> csvfile<span class="token punctuation">:</span>
    dialect <span class="token operator">=</span> csv<span class="token punctuation">.</span>Sniffer<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>sniff<span class="token punctuation">(</span>csvfile<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    csvfile<span class="token punctuation">.</span>seek<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
    reader <span class="token operator">=</span> csv<span class="token punctuation">.</span>reader<span class="token punctuation">(</span>csvfile<span class="token punctuation">,</span> dialect<span class="token punctuation">)</span>
<span class="token comment" spellcheck="true"># ... process CSV file contents here ...</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>csv</code> 模块定义了以下常量：</p>
<pre><code>csv.QUOTE_ALL</code></pre><p>指示 <code>writer</code> 对象给所有字段加上引号。</p>
<pre><code>csv.QUOTE_MINIMAL</code></pre><p>指示 <code>writer</code> 对象仅为包含特殊字符（例如 <em>定界符<em>、</em>引号字符</em> 或 <em>行结束符</em> 中的任何字符）的字段加上引号。</p>
<pre><code>csv.QUOTE_NONNUMERIC</code></pre><p>指示 <code>writer</code> 对象为所有非数字字段加上引号。</p>
<p>指示 reader 将所有未用引号引出的字段转换为 <em>float</em> 类型。</p>
<pre><code>csv.QUOTE_NONE</code></pre><p>指示 <code>writer</code> 对象不使用引号引出字段。当 <em>定界符</em> 出现在输出数据中时，其前面应该有 <em>转义符</em>。如果未设置 <em>转义符</em>，则遇到任何需要转义的字符时，writer 都会抛出 <code>Error</code> 异常。</p>
<p>指示 <code>reader</code> 不对引号字符进行特殊处理。</p>
<p><code>csv</code> 模块定义了以下异常：</p>
<p><em>exception</em><code>csv.Error</code></p>
<p>该异常可能由任何发生错误的函数抛出。</p>
<h3 id="变种与格式参数"><a href="#变种与格式参数" class="headerlink" title="变种与格式参数"></a>变种与格式参数</h3><p>为了更容易指定输入和输出记录的格式，特定的一组格式参数组合为一个 dialect（变种）。一个 dialect 是一个 <code>Dialect</code> 类的子类，它具有一组特定的方法和一个 <code>validate()</code> 方法。创建 <code>reader</code> 或 <code>writer</code> 对象时，程序员可以将某个字符串或 <code>Dialect</code> 类的子类指定为 dialect 参数。要想补充或覆盖 <em>dialect</em> 参数，程序员还可以单独指定某些格式参数，这些参数的名称与下面 <code>Dialect</code> 类定义的属性相同。</p>
<p>Dialect 类支持以下属性：</p>
<pre><code>Dialect.delimiter</code></pre><p>一个用于分隔字段的单字符，默认为 <code>','</code>。</p>
<pre><code>Dialect.doublequote</code></pre><p>控制出现在字段中的 <em>引号字符</em> 本身应如何被引出。当该属性为 <code>True</code> 时，双写引号字符。如果该属性为 <code>False</code>，则在 <em>引号字符</em> 的前面放置 <em>转义符</em>。默认值为 <code>True</code>。</p>
<p>在输出时，如果 <em>doublequote</em> 是 <code>False</code>，且 <em>转义符</em> 未指定，且在字段中发现 <em>引号字符</em> 时，会抛出 <code>Error</code> 异常。</p>
<pre><code>Dialect.escapechar</code></pre><p>一个用于 writer 的单字符，用来在 <em>quoting</em> 设置为 <code>QUOTE_NONE</code> 的情况下转义 <em>定界符*，在 *doublequote</em> 设置为 <code>False</code> 的情况下转义 <em>引号字符<em>。在读取时，</em>escapechar</em> 去除了其后所跟字符的任何特殊含义。该属性默认为 <code>None</code>，表示禁用转义。</p>
<pre><code>Dialect.lineterminator</code></pre><p>放在 <code>writer</code> 产生的行的结尾，默认为 <code>'\r\n'</code>。</p>
<p>注解</p>
<p><code>reader</code> 经过硬编码，会识别 <code>'\r'</code> 或 <code>'\n'</code> 作为行尾，并忽略 <em>lineterminator</em>。未来可能会更改这一行为。</p>
<pre><code>Dialect.quotechar</code></pre><p>一个单字符，用于包住含有特殊字符的字段，特殊字符如 <em>定界符</em> 或 <em>引号字符</em> 或换行符。默认为 <code>'"'</code>。</p>
<pre><code>Dialect.quoting</code></pre><p>控制 writer 何时生成引号，以及 reader 何时识别引号。该属性可以等于任何 <code>QUOTE_*</code> 常量，默认为 <code>QUOTE_MINIMAL</code>。</p>
<pre><code>Dialect.skipinitialspace</code></pre><p>如果为 <code>True</code>，则忽略 <em>定界符</em> 之后的空格。默认值为 <code>False</code>。</p>
<pre><code>Dialect.strict</code></pre><p>如果为 <code>True</code>，则在输入错误的 CSV 时抛出 <code>Error</code> 异常。默认值为 <code>False</code>。</p>
<h3 id="Reader-对象"><a href="#Reader-对象" class="headerlink" title="Reader 对象"></a>Reader 对象</h3><p>Reader 对象（<code>DictReader</code> 实例和 <code>reader()</code> 函数返回的对象）具有以下公开方法：</p>
<p><code>csvreader.__next__</code>()</p>
<p>返回 reader 的可迭代对象的下一行，它可以是一个列表（如果对象是由 <code>reader()</code> 返回）或字典（如果是一个 <code>DictReader</code> 实例），根据当前 <code>Dialect</code> 来解析。 通常你应当以 <code>next(reader)</code> 的形式来调用它。</p>
<p>Reader 对象具有以下公开属性：</p>
<pre><code>csvreader.dialect</code></pre><p>变种描述，只读，供解析器使用。</p>
<pre><code>csvreader.line_num</code></pre><p>源迭代器已经读取了的行数。它与返回的记录数不同，因为记录可能跨越多行。</p>
<p>DictReader 对象具有以下公开属性：</p>
<pre><code>csvreader.fieldnames</code></pre><p>字段名称。如果在创建对象时未传入字段名称，则首次访问时或从文件中读取第一条记录时会初始化此属性。</p>
<h3 id="Writer-对象"><a href="#Writer-对象" class="headerlink" title="Writer 对象"></a>Writer 对象</h3><p><code>Writer</code> 对象（<code>DictWriter</code> 实例和 <code>writer()</code> 函数返回的对象）具有下面的公开方法。对于 <code>Writer</code> 对象，<em>行</em> 必须是（一组可迭代的）字符串或数字。对于 <code>DictWriter</code> 对象，<em>行</em> 必须是一个字典，这个字典将字段名映射为字符串或数字（数字要先经过 <code>str()</code> 转换类型）。请注意，输出的复数会有括号包围。这样其他程序读取 CSV 文件时可能会有一些问题（假设它们完全支持复数）。</p>
<p><code>csvwriter.writerow</code>(<em>row</em>)</p>
<p>将 <em>row</em> 形参写入到 writer 的文件对象，根据当前 <code>Dialect</code> 进行格式化。 返回对下层文件对象的 <em>write</em> 方法的调用的返回值。</p>
<p>在 3.5 版更改: 开始支持任意类型的迭代器。</p>
<p><code>csvwriter.writerows</code>(<em>rows</em>)</p>
<p>将 <em>rows*（即能迭代出多个上述 *row</em> 对象的迭代器）中的所有元素写入 writer 的文件对象，并根据当前设置的变种进行格式化。</p>
<p>Writer 对象具有以下公开属性：</p>
<pre><code>csvwriter.dialect</code></pre><p>变种描述，只读，供 writer 使用。</p>
<p>DictWriter 对象具有以下公开方法：</p>
<p><code>DictWriter.writeheader</code>()</p>
<p>在 writer 的文件对象中，写入一行字段名称（字段名称在构造函数中指定），并根据当前设置的变种进行格式化。本方法的返回值就是内部使用的 <code>csvwriter.writerow()</code> 方法的返回值。</p>
<p>3.2 新版功能.</p>
<p>在 3.8 版更改: 现在 <code>writeheader()</code> 也返回其内部使用的 <code>csvwriter.writerow()</code> 方法的返回值。</p>
<h3 id="例子-4"><a href="#例子-4" class="headerlink" title="例子"></a>例子</h3><p>读取 CSV 文件最简单的一个例子:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> csv
<span class="token keyword">with</span> open<span class="token punctuation">(</span><span class="token string">'some.csv'</span><span class="token punctuation">,</span> newline<span class="token operator">=</span><span class="token string">''</span><span class="token punctuation">)</span><span class="token keyword">as</span> f<span class="token punctuation">:</span>
    reader <span class="token operator">=</span> csv<span class="token punctuation">.</span>reader<span class="token punctuation">(</span>f<span class="token punctuation">)</span>
<span class="token keyword">for</span> row <span class="token keyword">in</span> reader<span class="token punctuation">:</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>row<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>读取其他格式的文件:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> csv
<span class="token keyword">with</span> open<span class="token punctuation">(</span><span class="token string">'passwd'</span><span class="token punctuation">,</span> newline<span class="token operator">=</span><span class="token string">''</span><span class="token punctuation">)</span><span class="token keyword">as</span> f<span class="token punctuation">:</span>
    reader <span class="token operator">=</span> csv<span class="token punctuation">.</span>reader<span class="token punctuation">(</span>f<span class="token punctuation">,</span> delimiter<span class="token operator">=</span><span class="token string">':'</span><span class="token punctuation">,</span> quoting<span class="token operator">=</span>csv<span class="token punctuation">.</span>QUOTE_NONE<span class="token punctuation">)</span>
<span class="token keyword">for</span> row <span class="token keyword">in</span> reader<span class="token punctuation">:</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>row<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>相应最简单的写入示例是:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> csv
<span class="token keyword">with</span> open<span class="token punctuation">(</span><span class="token string">'some.csv'</span><span class="token punctuation">,</span><span class="token string">'w'</span><span class="token punctuation">,</span> newline<span class="token operator">=</span><span class="token string">''</span><span class="token punctuation">)</span><span class="token keyword">as</span> f<span class="token punctuation">:</span>
    writer <span class="token operator">=</span> csv<span class="token punctuation">.</span>writer<span class="token punctuation">(</span>f<span class="token punctuation">)</span>
    writer<span class="token punctuation">.</span>writerows<span class="token punctuation">(</span>someiterable<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>由于使用 <code>open()</code> 来读取 CSV 文件，因此默认情况下，将使用系统默认编码来解码文件并转换为 unicode（请参阅 <code>locale.getpreferredencoding()</code>）。要使用其他编码来解码文件，请使用 open 的 <code>encoding</code> 参数:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> csv
<span class="token keyword">with</span> open<span class="token punctuation">(</span><span class="token string">'some.csv'</span><span class="token punctuation">,</span> newline<span class="token operator">=</span><span class="token string">''</span><span class="token punctuation">,</span> encoding<span class="token operator">=</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span><span class="token keyword">as</span> f<span class="token punctuation">:</span>
    reader <span class="token operator">=</span> csv<span class="token punctuation">.</span>reader<span class="token punctuation">(</span>f<span class="token punctuation">)</span>
<span class="token keyword">for</span> row <span class="token keyword">in</span> reader<span class="token punctuation">:</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>row<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这同样适用于写入非系统默认编码的内容：打开输出文件时，指定 encoding 参数。</p>
<p>注册一个新的变种:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> csv
csv<span class="token punctuation">.</span>register_dialect<span class="token punctuation">(</span><span class="token string">'unixpwd'</span><span class="token punctuation">,</span> delimiter<span class="token operator">=</span><span class="token string">':'</span><span class="token punctuation">,</span> quoting<span class="token operator">=</span>csv<span class="token punctuation">.</span>QUOTE_NONE<span class="token punctuation">)</span>
<span class="token keyword">with</span> open<span class="token punctuation">(</span><span class="token string">'passwd'</span><span class="token punctuation">,</span> newline<span class="token operator">=</span><span class="token string">''</span><span class="token punctuation">)</span><span class="token keyword">as</span> f<span class="token punctuation">:</span>
    reader <span class="token operator">=</span> csv<span class="token punctuation">.</span>reader<span class="token punctuation">(</span>f<span class="token punctuation">,</span><span class="token string">'unixpwd'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>Reader 的更高级用法——捕获并报告错误:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> csv<span class="token punctuation">,</span> sys
filename <span class="token operator">=</span><span class="token string">'some.csv'</span>
<span class="token keyword">with</span> open<span class="token punctuation">(</span>filename<span class="token punctuation">,</span> newline<span class="token operator">=</span><span class="token string">''</span><span class="token punctuation">)</span><span class="token keyword">as</span> f<span class="token punctuation">:</span>
    reader <span class="token operator">=</span> csv<span class="token punctuation">.</span>reader<span class="token punctuation">(</span>f<span class="token punctuation">)</span>
<span class="token keyword">try</span><span class="token punctuation">:</span>
<span class="token keyword">for</span> row <span class="token keyword">in</span> reader<span class="token punctuation">:</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>row<span class="token punctuation">)</span>
<span class="token keyword">except</span> csv<span class="token punctuation">.</span>Erroras e<span class="token punctuation">:</span>
        sys<span class="token punctuation">.</span>exit<span class="token punctuation">(</span><span class="token string">'file {}, line {}: {}'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>filename<span class="token punctuation">,</span> reader<span class="token punctuation">.</span>line_num<span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>尽管该模块不直接支持解析字符串，但仍可如下轻松完成:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> csv
<span class="token keyword">for</span> row <span class="token keyword">in</span> csv<span class="token punctuation">.</span>reader<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'one,two,three'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>row<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h2 id="configparser-—-配置文件解析器"><a href="#configparser-—-配置文件解析器" class="headerlink" title="configparser —- 配置文件解析器"></a><code>configparser</code> —- 配置文件解析器</h2><p><strong>源代码:</strong> <a href="https://github.com/python/cpython/tree/3.10/Lib/configparser.py" target="_blank" rel="noopener">Lib/configparser.py</a></p>
<hr>
<p>此模块提供了它实现一种基本配置语言 <code>ConfigParser</code> 类，这种语言所提供的结构与 Microsoft Windows INI 文件的类似。 你可以使用这种语言来编写能够由最终用户来自定义的 Python 程序。</p>
<p>注解</p>
<p>这个库 <em>并不</em> 能够解析或写入在 Windows Registry 扩展版本 INI 语法中所使用的值-类型前缀。</p>
<h3 id="快速起步"><a href="#快速起步" class="headerlink" title="快速起步"></a>快速起步</h3><p>让我们准备一个非常基本的配置文件，它看起来是这样的:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token punctuation">[</span>DEFAULT<span class="token punctuation">]</span>
ServerAliveInterval <span class="token operator">=</span> <span class="token number">45</span>
Compression <span class="token operator">=</span> yes
CompressionLevel <span class="token operator">=</span> <span class="token number">9</span>
ForwardX11 <span class="token operator">=</span> yes
<span class="token punctuation">[</span>bitbucket<span class="token punctuation">.</span>org<span class="token punctuation">]</span>
User <span class="token operator">=</span> hg
<span class="token punctuation">[</span>topsecret<span class="token punctuation">.</span>server<span class="token punctuation">.</span>com<span class="token punctuation">]</span>
Port <span class="token operator">=</span> <span class="token number">50022</span>
ForwardX11 <span class="token operator">=</span> no<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>总的来说，这种文件由多个节组成，每个节包含多个带有值的键。 <code>configparser</code> 类可以读取和写入这种文件。 让我们先通过程序方式来创建上述的配置文件。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> configparser
<span class="token operator">>></span><span class="token operator">></span> config <span class="token operator">=</span> configparser<span class="token punctuation">.</span>ConfigParser<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> config<span class="token punctuation">[</span><span class="token string">'DEFAULT'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'ServerAliveInterval'</span><span class="token punctuation">:</span> <span class="token string">'45'</span><span class="token punctuation">,</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                      <span class="token string">'Compression'</span><span class="token punctuation">:</span> <span class="token string">'yes'</span><span class="token punctuation">,</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                      <span class="token string">'CompressionLevel'</span><span class="token punctuation">:</span> <span class="token string">'9'</span><span class="token punctuation">}</span>
<span class="token operator">>></span><span class="token operator">></span> config<span class="token punctuation">[</span><span class="token string">'bitbucket.org'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token operator">>></span><span class="token operator">></span> config<span class="token punctuation">[</span><span class="token string">'bitbucket.org'</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">'User'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'hg'</span>
<span class="token operator">>></span><span class="token operator">></span> config<span class="token punctuation">[</span><span class="token string">'topsecret.server.com'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token operator">>></span><span class="token operator">></span> topsecret <span class="token operator">=</span> config<span class="token punctuation">[</span><span class="token string">'topsecret.server.com'</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> topsecret<span class="token punctuation">[</span><span class="token string">'Port'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'50022'</span>     <span class="token comment" spellcheck="true"># mutates the parser</span>
<span class="token operator">>></span><span class="token operator">></span> topsecret<span class="token punctuation">[</span><span class="token string">'ForwardX11'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'no'</span>  <span class="token comment" spellcheck="true"># same here</span>
<span class="token operator">>></span><span class="token operator">></span> config<span class="token punctuation">[</span><span class="token string">'DEFAULT'</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">'ForwardX11'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'yes'</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">with</span> open<span class="token punctuation">(</span><span class="token string">'example.ini'</span><span class="token punctuation">,</span> <span class="token string">'w'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> configfile<span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>   config<span class="token punctuation">.</span>write<span class="token punctuation">(</span>configfile<span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如你所见，我们可以把配置解析器当作一个字典来处理。 </p>
<p>现在我们已经创建并保存了一个配置文件，让我们再将它读取出来并探究其中包含的数据。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> config <span class="token operator">=</span> configparser<span class="token punctuation">.</span>ConfigParser<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> config<span class="token punctuation">.</span>sections<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> config<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token string">'example.ini'</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token string">'example.ini'</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> config<span class="token punctuation">.</span>sections<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token string">'bitbucket.org'</span><span class="token punctuation">,</span> <span class="token string">'topsecret.server.com'</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token string">'bitbucket.org'</span> <span class="token keyword">in</span> config
<span class="token boolean">True</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token string">'bytebong.com'</span> <span class="token keyword">in</span> config
<span class="token boolean">False</span>
<span class="token operator">>></span><span class="token operator">></span> config<span class="token punctuation">[</span><span class="token string">'bitbucket.org'</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">'User'</span><span class="token punctuation">]</span>
<span class="token string">'hg'</span>
<span class="token operator">>></span><span class="token operator">></span> config<span class="token punctuation">[</span><span class="token string">'DEFAULT'</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">'Compression'</span><span class="token punctuation">]</span>
<span class="token string">'yes'</span>
<span class="token operator">>></span><span class="token operator">></span> topsecret <span class="token operator">=</span> config<span class="token punctuation">[</span><span class="token string">'topsecret.server.com'</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> topsecret<span class="token punctuation">[</span><span class="token string">'ForwardX11'</span><span class="token punctuation">]</span>
<span class="token string">'no'</span>
<span class="token operator">>></span><span class="token operator">></span> topsecret<span class="token punctuation">[</span><span class="token string">'Port'</span><span class="token punctuation">]</span>
<span class="token string">'50022'</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">for</span> key <span class="token keyword">in</span> config<span class="token punctuation">[</span><span class="token string">'bitbucket.org'</span><span class="token punctuation">]</span><span class="token punctuation">:</span>  
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">print</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span>
user
compressionlevel
serveraliveinterval
compression
forwardx11
<span class="token operator">>></span><span class="token operator">></span> config<span class="token punctuation">[</span><span class="token string">'bitbucket.org'</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">'ForwardX11'</span><span class="token punctuation">]</span>
<span class="token string">'yes'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>正如我们在上面所看到的，相关的 API 相当直观。 唯一有些神奇的地方是 <code>DEFAULT</code> 小节，它为所有其他小节提供了默认值 <a href="https://www.bookstack.cn/read/python-3.10.0-zh/f3a0822623b651da.md#id15" target="_blank" rel="noopener">1</a>。 还要注意小节中的键大小写不敏感并且会存储为小写形式。</p>
<p>将多个配置读入单个 <code>ConfigParser</code> 是可能的，其中最近添加的配置具有最高优先级。 任何冲突的键都会从更近的配置获取并且先前存在的键会被保留。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> another_config <span class="token operator">=</span> configparser<span class="token punctuation">.</span>ConfigParser<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> another_config<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token string">'example.ini'</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token string">'example.ini'</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> another_config<span class="token punctuation">[</span><span class="token string">'topsecret.server.com'</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">'Port'</span><span class="token punctuation">]</span>
<span class="token string">'50022'</span>
<span class="token operator">>></span><span class="token operator">></span> another_config<span class="token punctuation">.</span>read_string<span class="token punctuation">(</span><span class="token string">"[topsecret.server.com]\nPort=48484"</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> another_config<span class="token punctuation">[</span><span class="token string">'topsecret.server.com'</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">'Port'</span><span class="token punctuation">]</span>
<span class="token string">'48484'</span>
<span class="token operator">>></span><span class="token operator">></span> another_config<span class="token punctuation">.</span>read_dict<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">"topsecret.server.com"</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token string">"Port"</span><span class="token punctuation">:</span> <span class="token number">21212</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> another_config<span class="token punctuation">[</span><span class="token string">'topsecret.server.com'</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">'Port'</span><span class="token punctuation">]</span>
<span class="token string">'21212'</span>
<span class="token operator">>></span><span class="token operator">></span> another_config<span class="token punctuation">[</span><span class="token string">'topsecret.server.com'</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">'ForwardX11'</span><span class="token punctuation">]</span>
<span class="token string">'no'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>此行为等价于一次 <code>ConfigParser.read()</code> 调用并向 <em>filenames</em> 形参传入多个文件。</p>
<h3 id="支持的数据类型"><a href="#支持的数据类型" class="headerlink" title="支持的数据类型"></a>支持的数据类型</h3><p>配置解析器并不会猜测配置文件中值的类型，而总是将它们在内部存储为字符串。 这意味着如果你需要其他数据类型，你应当自己来转换:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> int<span class="token punctuation">(</span>topsecret<span class="token punctuation">[</span><span class="token string">'Port'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token number">50022</span>
<span class="token operator">>></span><span class="token operator">></span> float<span class="token punctuation">(</span>topsecret<span class="token punctuation">[</span><span class="token string">'CompressionLevel'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token number">9.0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>由于这种任务十分常用，配置解析器提供了一系列便捷的获取方法来处理整数、浮点数和布尔值。 最后一个类型的处理最为有趣，因为简单地将值传给 <code>bool()</code> 是没有用的，<code>bool('False')</code> 仍然会是 <code>True</code>。 为解决这个问题配置解析器还提供了 <code>getboolean()</code>。 这个方法对大小写不敏感并可识别 <code>'yes'</code>/<code>'no'</code>, <code>'on'</code>/<code>'off'</code>, <code>'true'</code>/<code>'false'</code> 和 <code>'1'</code>/<code>'0'</code> 等布尔值。 例如:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> topsecret<span class="token punctuation">.</span>getboolean<span class="token punctuation">(</span><span class="token string">'ForwardX11'</span><span class="token punctuation">)</span>
<span class="token boolean">False</span>
<span class="token operator">>></span><span class="token operator">></span> config<span class="token punctuation">[</span><span class="token string">'bitbucket.org'</span><span class="token punctuation">]</span><span class="token punctuation">.</span>getboolean<span class="token punctuation">(</span><span class="token string">'ForwardX11'</span><span class="token punctuation">)</span>
<span class="token boolean">True</span>
<span class="token operator">>></span><span class="token operator">></span> config<span class="token punctuation">.</span>getboolean<span class="token punctuation">(</span><span class="token string">'bitbucket.org'</span><span class="token punctuation">,</span> <span class="token string">'Compression'</span><span class="token punctuation">)</span>
<span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>除了 <code>getboolean()</code>，配置解析器还提供了同类的 <code>getint()</code> 和 <code>getfloat()</code> 方法。 你可以注册你自己的转换器并或是定制已提供的转换器。</p>
<h3 id="回退值"><a href="#回退值" class="headerlink" title="回退值"></a>回退值</h3><p>与字典类似，你可以使用某个小节的 <code>get()</code> 方法来提供回退值:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> topsecret<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">'Port'</span><span class="token punctuation">)</span>
<span class="token string">'50022'</span>
<span class="token operator">>></span><span class="token operator">></span> topsecret<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">'CompressionLevel'</span><span class="token punctuation">)</span>
<span class="token string">'9'</span>
<span class="token operator">>></span><span class="token operator">></span> topsecret<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">'Cipher'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> topsecret<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">'Cipher'</span><span class="token punctuation">,</span> <span class="token string">'3des-cbc'</span><span class="token punctuation">)</span>
<span class="token string">'3des-cbc'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>请注意默认值会优先于回退值。 例如，在我们的示例中 <code>'CompressionLevel'</code> 键仅在 <code>'DEFAULT'</code> 小节被指定。 如果你尝试在 <code>'topsecret.server.com'</code> 小节获取它，我们将总是获取到默认值，即使我们指定了一个回退值:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> topsecret<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">'CompressionLevel'</span><span class="token punctuation">,</span> <span class="token string">'3'</span><span class="token punctuation">)</span>
<span class="token string">'9'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>还需要注意的一点是解析器层级的 <code>get()</code> 方法提供了自定义的更复杂接口，它被维护用于向下兼容。 当使用此方法时，回退值可以通过 <code>fallback</code> 仅限关键字参数来提供:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> config<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">'bitbucket.org'</span><span class="token punctuation">,</span> <span class="token string">'monster'</span><span class="token punctuation">,</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>            fallback<span class="token operator">=</span><span class="token string">'No such things as monsters'</span><span class="token punctuation">)</span>
<span class="token string">'No such things as monsters'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>同样的 <code>fallback</code> 参数也可在 <code>getint()</code>, <code>getfloat()</code> 和 <code>getboolean()</code> 方法中使用，例如:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token string">'BatchMode'</span> <span class="token keyword">in</span> topsecret
<span class="token boolean">False</span>
<span class="token operator">>></span><span class="token operator">></span> topsecret<span class="token punctuation">.</span>getboolean<span class="token punctuation">(</span><span class="token string">'BatchMode'</span><span class="token punctuation">,</span> fallback<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>
<span class="token boolean">True</span>
<span class="token operator">>></span><span class="token operator">></span> config<span class="token punctuation">[</span><span class="token string">'DEFAULT'</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">'BatchMode'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'no'</span>
<span class="token operator">>></span><span class="token operator">></span> topsecret<span class="token punctuation">.</span>getboolean<span class="token punctuation">(</span><span class="token string">'BatchMode'</span><span class="token punctuation">,</span> fallback<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>
<span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="受支持的-INI-文件结构"><a href="#受支持的-INI-文件结构" class="headerlink" title="受支持的 INI 文件结构"></a>受支持的 INI 文件结构</h3><p>A configuration file consists of sections, each led by a <code>[section]</code> header, followed by key/value entries separated by a specific string (<code>=</code> or <code>:</code> by default ). By default, section names are case sensitive but keys are not. Leading and trailing whitespace is removed from keys and values. Values can be omitted if the parser is configured to allow it , in which case the key/value delimiter may also be left out. Values can also span multiple lines, as long as they are indented deeper than the first line of the value. Depending on the parser’s mode, blank lines may be treated as parts of multiline values or ignored.</p>
<p>配置文件可以包含注释，要带有指定字符前缀 (默认为 <code>#</code> 和 <code>;</code> )。 注释可以单独出现于原本的空白行，并可使用缩进。</p>
<p>例如:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token punctuation">[</span>Simple Values<span class="token punctuation">]</span>
key<span class="token operator">=</span>value
spaces <span class="token keyword">in</span> keys<span class="token operator">=</span>allowed
spaces <span class="token keyword">in</span> values<span class="token operator">=</span>allowed <span class="token keyword">as</span> well
spaces around the delimiter <span class="token operator">=</span> obviously
you can also use <span class="token punctuation">:</span> to delimit keys <span class="token keyword">from</span> values
<span class="token punctuation">[</span>All Values Are Strings<span class="token punctuation">]</span>
values like this<span class="token punctuation">:</span> <span class="token number">1000000</span>
<span class="token operator">or</span> this<span class="token punctuation">:</span> <span class="token number">3.14159265359</span>
are they treated <span class="token keyword">as</span> numbers? <span class="token punctuation">:</span> no
integers<span class="token punctuation">,</span> floats <span class="token operator">and</span> booleans are held <span class="token keyword">as</span><span class="token punctuation">:</span> strings
can use the API to get converted values directly<span class="token punctuation">:</span> true
<span class="token punctuation">[</span>Multiline Values<span class="token punctuation">]</span>
chorus<span class="token punctuation">:</span> I<span class="token string">'m a lumberjack, and I'</span>m okay
    I sleep all night <span class="token operator">and</span> I work all day
<span class="token punctuation">[</span>No Values<span class="token punctuation">]</span>
key_without_value
empty string value here <span class="token operator">=</span>
<span class="token punctuation">[</span>You can use comments<span class="token punctuation">]</span>
<span class="token comment" spellcheck="true"># like this</span>
<span class="token punctuation">;</span> <span class="token operator">or</span> this
<span class="token comment" spellcheck="true"># By default only in an empty line.</span>
<span class="token comment" spellcheck="true"># Inline comments can be harmful because they prevent users</span>
<span class="token comment" spellcheck="true"># from using the delimiting characters as parts of values.</span>
<span class="token comment" spellcheck="true"># That being said, this can be customized.</span>
    <span class="token punctuation">[</span>Sections Can Be Indented<span class="token punctuation">]</span>
        can_values_be_as_well <span class="token operator">=</span> <span class="token boolean">True</span>
        does_that_mean_anything_special <span class="token operator">=</span> <span class="token boolean">False</span>
        purpose <span class="token operator">=</span> formatting <span class="token keyword">for</span> readability
        multiline_values <span class="token operator">=</span> are
            handled just fine <span class="token keyword">as</span>
            long <span class="token keyword">as</span> they are indented
            deeper than the first line
            of a value
        <span class="token comment" spellcheck="true"># Did I mention we can indent comments, too?</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="值的插值"><a href="#值的插值" class="headerlink" title="值的插值"></a>值的插值</h3><p>在核心功能之上，<code>ConfigParser</code> 还支持插值。 这意味着值可以在被 <code>get()</code> 调用返回之前进行预处理。</p>
<p><em>class</em> <code>configparser.BasicInterpolation</code></p>
<p>默认实现由 <code>ConfigParser</code> 来使用。 它允许值包含引用了相同小节中其他值或者特殊的默认小节中的值的格式字符串。 额外的默认值可以在初始化时提供。</p>
<p>例如:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token punctuation">[</span>Paths<span class="token punctuation">]</span>
home_dir<span class="token punctuation">:</span> <span class="token operator">/</span>Users
my_dir<span class="token punctuation">:</span> <span class="token operator">%</span><span class="token punctuation">(</span>home_dir<span class="token punctuation">)</span>s<span class="token operator">/</span>lumberjack
my_pictures<span class="token punctuation">:</span> <span class="token operator">%</span><span class="token punctuation">(</span>my_dir<span class="token punctuation">)</span>s<span class="token operator">/</span>Pictures
<span class="token punctuation">[</span>Escape<span class="token punctuation">]</span>
gain<span class="token punctuation">:</span> <span class="token number">80</span><span class="token operator">%</span><span class="token operator">%</span>  <span class="token comment" spellcheck="true"># use a %% to escape the % sign (% is the only character that needs to be escaped)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在上面的例子里，<code>ConfigParser</code> 的 <em>interpolation</em> 设为 <code>BasicInterpolation()</code>，这会将 <code>%(home_dir)s</code> 求解为 <code>home_dir</code> 的值 (在这里是 <code>/Users</code>)。 <code>%(my_dir)s</code> 的将被实际求解为 <code>/Users/lumberjack</code>。 所有插值都是按需进行的，这样引用链中使用的键不必以任何特定顺序在配置文件中指明。</p>
<p>当 <code>interpolation</code> 设为 <code>None</code> 时，解析器会简单地返回 <code>%(my_dir)s/Pictures</code> 作为 <code>my_pictures</code> 的值，并返回 <code>%(home_dir)s/lumberjack</code> 作为 <code>my_dir</code> 的值。</p>
<p><em>class</em> <code>configparser.ExtendedInterpolation</code></p>
<p>一个用于插值的替代处理程序实现了更高级的语法，它被用于 <code>zc.buildout</code> 中的实例。 扩展插值使用 <code>${section:option}</code> 来表示来自外部小节的值。 插值可以跨越多个层级。 为了方便使用，<code>section:</code> 部分可被省略，插值会默认作用于当前小节（可能会从特殊小节获取默认值）。</p>
<p>例如，上面使用基本插值描述的配置，使用扩展插值将是这个样子:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token punctuation">[</span>Paths<span class="token punctuation">]</span>
home_dir<span class="token punctuation">:</span> <span class="token operator">/</span>Users
my_dir<span class="token punctuation">:</span> $<span class="token punctuation">{</span>home_dir<span class="token punctuation">}</span><span class="token operator">/</span>lumberjack
my_pictures<span class="token punctuation">:</span> $<span class="token punctuation">{</span>my_dir<span class="token punctuation">}</span><span class="token operator">/</span>Pictures
<span class="token punctuation">[</span>Escape<span class="token punctuation">]</span>
cost<span class="token punctuation">:</span> $$<span class="token number">80</span>  <span class="token comment" spellcheck="true"># use a $$ to escape the $ sign ($ is the only character that needs to be escaped)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>来自其他小节的值也可以被获取:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token punctuation">[</span>Common<span class="token punctuation">]</span>
home_dir<span class="token punctuation">:</span> <span class="token operator">/</span>Users
library_dir<span class="token punctuation">:</span> <span class="token operator">/</span>Library
system_dir<span class="token punctuation">:</span> <span class="token operator">/</span>System
macports_dir<span class="token punctuation">:</span> <span class="token operator">/</span>opt<span class="token operator">/</span>local
<span class="token punctuation">[</span>Frameworks<span class="token punctuation">]</span>
Python<span class="token punctuation">:</span> <span class="token number">3.2</span>
path<span class="token punctuation">:</span> $<span class="token punctuation">{</span>Common<span class="token punctuation">:</span>system_dir<span class="token punctuation">}</span><span class="token operator">/</span>Library<span class="token operator">/</span>Frameworks<span class="token operator">/</span>
<span class="token punctuation">[</span>Arthur<span class="token punctuation">]</span>
nickname<span class="token punctuation">:</span> Two Sheds
last_name<span class="token punctuation">:</span> Jackson
my_dir<span class="token punctuation">:</span> $<span class="token punctuation">{</span>Common<span class="token punctuation">:</span>home_dir<span class="token punctuation">}</span><span class="token operator">/</span>twosheds
my_pictures<span class="token punctuation">:</span> $<span class="token punctuation">{</span>my_dir<span class="token punctuation">}</span><span class="token operator">/</span>Pictures
python_dir<span class="token punctuation">:</span> $<span class="token punctuation">{</span>Frameworks<span class="token punctuation">:</span>path<span class="token punctuation">}</span><span class="token operator">/</span>Python<span class="token operator">/</span>Versions<span class="token operator">/</span>$<span class="token punctuation">{</span>Frameworks<span class="token punctuation">:</span>Python<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="映射协议访问"><a href="#映射协议访问" class="headerlink" title="映射协议访问"></a>映射协议访问</h3><p>3.2 新版功能.</p>
<p>映射协议访问这个通用名称是指允许以字典的方式来使用自定义对象的功能。 在 <code>configparser</code> 中，映射接口的实现使用了 <code>parser['section']['option']</code> 标记法。</p>
<p><code>parser['section']</code> 专门为解析器中的小节数据返回一个代理。 这意味着其中的值不会被拷贝，而是在需要时从原始解析器中获取。 更为重要的是，当值在小节代理上被修改时，它们其实是在原始解析器中发生了改变。</p>
<p><code>configparser</code> 对象的行为会尽可能地接近真正的字典。 映射接口是完整而且遵循 <code>MutableMapping</code> ABC 规范的。 但是，还是有一些差异应当被纳入考虑:</p>
<ul>
<li><p>默认情况下，小节中的所有键是以大小写不敏感的方式来访问的。 例如 <code>for option in parser["section"]</code> 只会产生 <code>optionxform</code> 形式的选项键名称。 也就是说默认使用小写字母键名。 与此同时，对于一个包含键 <code>'a'</code> 的小节，以下两个表达式均将返回 <code>True</code>:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token string">"a"</span> <span class="token keyword">in</span> parser<span class="token punctuation">[</span><span class="token string">"section"</span><span class="token punctuation">]</span>
<span class="token string">"A"</span> <span class="token keyword">in</span> parser<span class="token punctuation">[</span><span class="token string">"section"</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li><p>所有小节也包括 <code>DEFAULTSECT</code>，这意味着对一个小节执行 <code>.clear()</code> 可能无法使得该小节显示为空。 这是因为默认值是无法从小节中被删除的（因为从技术上说它们并不在那里）。 如果它们在小节中被覆盖，删除将导致默认值重新变为可见。 尝试删除默认值将会引发 <code>KeyError</code>。</p>
</li>
<li><p><code>DEFAULTSECT</code> 无法从解析器中被移除:</p>
<ul>
<li>尝试删除将引发 <code>ValueError</code>，</li>
<li><code>parser.clear()</code> 会保留其原状，</li>
<li><code>parser.popitem()</code> 绝不会将其返回。</li>
</ul>
</li>
<li><p><code>parser.get(section, option, **kwargs)</code> - 第二个参数 <strong>并非</strong> 回退值。 但是请注意小节层级的 <code>get()</code> 方法可同时兼容映射协议和经典配置解析器 API。</p>
</li>
<li><p><code>parser.items()</code> 兼容映射协议（返回 <em>section_name</em>, <em>section_proxy</em> 对的列表，包括 DEFAULTSECT）。 但是，此方法也可以带参数发起调用: <code>parser.items(section, raw, vars)</code>。 这种调用形式返回指定 <code>section</code> 的 <em>option</em>, <em>value</em> 对的列表，将展开所有插值（除非提供了 <code>raw=True</code> 选项）。</p>
</li>
</ul>
<p>映射协议是在现有的传统 API 之上实现的，以便重载原始接口的子类仍然具有符合预期的有效映射。</p>
<h3 id="定制解析器行为"><a href="#定制解析器行为" class="headerlink" title="定制解析器行为"></a>定制解析器行为</h3><p>INI 格式的变种数量几乎和使用此格式的应用一样多。 <code>configparser</code> 花费了很大力气来为尽量大范围的可用 INI 样式提供支持。 默认的可用功能主要由历史状况来确定，你很可能会想要定制某些特性。</p>
<p>改变特定配置解析器行为的最常见方式是使用 <code>__init__()</code> 选项:</p>
<ul>
<li><p><em>defaults</em>，默认值: <code>None</code></p>
<p>此选项接受一个键值对的字典，它将被首先放入 <code>DEFAULT</code> 小节。 这实现了一种优雅的方式来支持简洁的配置文件，它不必指定与已记录的默认值相同的值。</p>
<p>提示：如果你想要为特定的小节指定默认的值，请在读取实际文件之前使用 <code>read_dict()</code>。</p>
</li>
<li><p><em>dict_type</em>，默认值: <code>dict</code></p>
<p>此选项主要影响映射协议的行为和写入配置文件的外观。 使用标准字典时，每个小节是按照它们被加入解析器的顺序保存的。 在小节内的选项也是如此。</p>
<p>还有其他替换的字典类型可以使用，例如在写回数据时对小节和选项进行排序。</p>
<p>请注意：存在其他方式只用一次操作来添加键值对的集合。 当你在这些操作中使用一个常规字典时，键将按顺序进行排列。 例如:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> parser <span class="token operator">=</span> configparser<span class="token punctuation">.</span>ConfigParser<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> parser<span class="token punctuation">.</span>read_dict<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">'section1'</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token string">'key1'</span><span class="token punctuation">:</span> <span class="token string">'value1'</span><span class="token punctuation">,</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                                <span class="token string">'key2'</span><span class="token punctuation">:</span> <span class="token string">'value2'</span><span class="token punctuation">,</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                                <span class="token string">'key3'</span><span class="token punctuation">:</span> <span class="token string">'value3'</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                   <span class="token string">'section2'</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token string">'keyA'</span><span class="token punctuation">:</span> <span class="token string">'valueA'</span><span class="token punctuation">,</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                                <span class="token string">'keyB'</span><span class="token punctuation">:</span> <span class="token string">'valueB'</span><span class="token punctuation">,</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                                <span class="token string">'keyC'</span><span class="token punctuation">:</span> <span class="token string">'valueC'</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                   <span class="token string">'section3'</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token string">'foo'</span><span class="token punctuation">:</span> <span class="token string">'x'</span><span class="token punctuation">,</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                                <span class="token string">'bar'</span><span class="token punctuation">:</span> <span class="token string">'y'</span><span class="token punctuation">,</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                                <span class="token string">'baz'</span><span class="token punctuation">:</span> <span class="token string">'z'</span><span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> parser<span class="token punctuation">.</span>sections<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token string">'section1'</span><span class="token punctuation">,</span> <span class="token string">'section2'</span><span class="token punctuation">,</span> <span class="token string">'section3'</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token punctuation">[</span>option <span class="token keyword">for</span> option <span class="token keyword">in</span> parser<span class="token punctuation">[</span><span class="token string">'section3'</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token string">'foo'</span><span class="token punctuation">,</span> <span class="token string">'bar'</span><span class="token punctuation">,</span> <span class="token string">'baz'</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><em>allow_no_value</em>，默认值: <code>False</code></p>
<p>已知某些配置文件会包括不带值的设置，但其在其他方面均符合 <code>configparser</code> 所支持的语法。 构造器的 <em>allow_no_value</em> 形参可用于指明应当接受这样的值:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> configparser
<span class="token operator">>></span><span class="token operator">></span> sample_config <span class="token operator">=</span> <span class="token triple-quoted-string string">"""
... [mysqld]
...   user = mysql
...   pid-file = /var/run/mysqld/mysqld.pid
...   skip-external-locking
...   old_passwords = 1
...   skip-bdb
...   # we don't need ACID today
...   skip-innodb
... """</span>
<span class="token operator">>></span><span class="token operator">></span> config <span class="token operator">=</span> configparser<span class="token punctuation">.</span>ConfigParser<span class="token punctuation">(</span>allow_no_value<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> config<span class="token punctuation">.</span>read_string<span class="token punctuation">(</span>sample_config<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token comment" spellcheck="true"># Settings with values are treated as before:</span>
<span class="token operator">>></span><span class="token operator">></span> config<span class="token punctuation">[</span><span class="token string">"mysqld"</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">"user"</span><span class="token punctuation">]</span>
<span class="token string">'mysql'</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token comment" spellcheck="true"># Settings without values provide None:</span>
<span class="token operator">>></span><span class="token operator">></span> config<span class="token punctuation">[</span><span class="token string">"mysqld"</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">"skip-bdb"</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token comment" spellcheck="true"># Settings which aren't specified still raise an error:</span>
<span class="token operator">>></span><span class="token operator">></span> config<span class="token punctuation">[</span><span class="token string">"mysqld"</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">"does-not-exist"</span><span class="token punctuation">]</span>
Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
KeyError<span class="token punctuation">:</span> <span class="token string">'does-not-exist'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><em>delimiters</em>，默认值: <code>('=', ':')</code></p>
<p>分隔符是用于在小节内分隔键和值的子字符串。 在一行中首次出现的分隔子字符串会被视为一个分隔符。 这意味着值可以包含分隔符（但键不可以）。</p>
</li>
<li><p><em>comment_prefixes</em>，默认值: <code>('#', ';')</code></p>
</li>
<li><p><em>inline_comment_prefixes</em>，默认值: <code>None</code></p>
<p>注释前缀是配置文件中用于标示一条有效注释的开头的字符串。 <em>comment_prefixes</em> 仅用在被视为空白的行（可以缩进）之前而 <em>inline_comment_prefixes</em> 可用在每个有效值之后（例如小节名称、选项以及空白的行）。 默认情况下禁用行内注释，并且 <code>'#'</code> 和 <code>';'</code> 都被用作完整行注释的前缀。</p>
<p>在 3.2 版更改: 在之前的 <code>configparser</code> 版本中行为匹配 <code>comment_prefixes=('#',';')</code> 和 <code>inline_comment_prefixes=(';',)</code>。</p>
<p>请注意配置解析器不支持对注释前缀的转义，因此使用 <em>inline_comment_prefixes</em> 可能妨碍用户将被用作注释前缀的字符指定为可选值。 当有疑问时，请避免设置 <em>inline_comment_prefixes</em>。 在许多情况下，在多行值的一行开头存储注释前缀字符的唯一方式是进行前缀插值，例如:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> configparser <span class="token keyword">import</span> ConfigParser<span class="token punctuation">,</span> ExtendedInterpolation
<span class="token operator">>></span><span class="token operator">></span> parser <span class="token operator">=</span> ConfigParser<span class="token punctuation">(</span>interpolation<span class="token operator">=</span>ExtendedInterpolation<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token comment" spellcheck="true"># the default BasicInterpolation could be used as well</span>
<span class="token operator">>></span><span class="token operator">></span> parser<span class="token punctuation">.</span>read_string<span class="token punctuation">(</span><span class="token triple-quoted-string string">"""
... [DEFAULT]
... hash = #
...
... [hashes]
... shebang =
...   ${hash}!/usr/bin/env python
...   ${hash} -*- coding: utf-8 -*-
...
... extensions =
...   enabled_extension
...   another_extension
...   #disabled_by_comment
...   yet_another_extension
...
... interpolation not necessary = if # is not at line start
... even in multiline values = line #1
...   line #2
...   line #3
... """</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>parser<span class="token punctuation">[</span><span class="token string">'hashes'</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">'shebang'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token comment" spellcheck="true">#!/usr/bin/env python</span>
<span class="token comment" spellcheck="true"># -*- coding: utf-8 -*-</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>parser<span class="token punctuation">[</span><span class="token string">'hashes'</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">'extensions'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
enabled_extension
another_extension
yet_another_extension
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>parser<span class="token punctuation">[</span><span class="token string">'hashes'</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">'interpolation not necessary'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token keyword">if</span> <span class="token comment" spellcheck="true"># is not at line start</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>parser<span class="token punctuation">[</span><span class="token string">'hashes'</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">'even in multiline values'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
line <span class="token comment" spellcheck="true">#1</span>
line <span class="token comment" spellcheck="true">#2</span>
line <span class="token comment" spellcheck="true">#3</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><em>strict</em>，默认值: <code>True</code></p>
<p>当设为 <code>True</code> 时，解析器在从单一源读取 (使用 <code>read_file()</code>, <code>read_string()</code> 或 <code>read_dict()</code>) 期间将不允许任何小节或选项出现重复。 推荐在新的应用中使用严格解析器。</p>
<p>在 3.2 版更改: 在之前的 <code>configparser</code> 版本中行为匹配 <code>strict=False</code>。</p>
</li>
<li><p><em>empty_lines_in_values</em>，默认值: <code>True</code></p>
<p>在配置解析器中，值可以包含多行，只要它们的缩进级别低于它们所对应的键。 默认情况下解析器还会将空行视为值的一部分。 于此同时，键本身也可以任意缩进以提升可读性。 因此，当配置文件变得非常庞大而复杂时，用户很容易失去对文件结构的掌控。 例如:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token punctuation">[</span>Section<span class="token punctuation">]</span>
key <span class="token operator">=</span> multiline
  value <span class="token keyword">with</span> a gotcha
 this <span class="token operator">=</span> <span class="token keyword">is</span> still a part of the multiline value of <span class="token string">'key'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>在用户查看时这可能会特别有问题，如果她是使用比例字体来编辑文件的话。 这就是为什么当你的应用不需要带有空行的值时，你应该考虑禁用它们。 这将使得空行每次都会作为键之间的分隔。 在上面的示例中，空行产生了两个键，<code>key</code> 和 <code>this</code>。</p>
</li>
<li><p><em>default_section</em>，默认值: <code>configparser.DEFAULTSECT</code> (即: <code>"DEFAULT"</code>)</p>
<p>允许设置一个保存默认值的特殊节在其他节或插值等目的中使用的惯例是这个库所拥有的一个强大概念，使得用户能够创建复杂的声明性配置。 这种特殊节通常称为 <code>"DEFAULT"</code> 但也可以被定制为指向任何其他有效的节名称。 一些典型的值包括: <code>"general"</code> 或 <code>"common"</code>。 所提供的名称在从任意节读取的时候被用于识别默认的节，而且也会在将配置写回文件时被使用。 它的当前值可以使用 <code>parser_instance.default_section</code> 属性来获取，并且可以在运行时被修改（即将文件从一种格式转换为另一种格式）。</p>
</li>
<li><p><em>interpolation</em>，默认值: <code>configparser.BasicInterpolation</code></p>
<p>插值行为可以用通过提供 <em>interpolation</em> 参数提供自定义处理程序的方式来定制。 <code>None</code> 可用来完全禁用插值，<code>ExtendedInterpolation()</code> 提供了一种更高级的变体形式，它的设计受到了 <code>zc.buildout</code> 的启发。 <code>RawConfigParser</code> 具有默认的值 <code>None</code>。</p>
</li>
<li><p><em>converters</em>，默认值: 不设置</p>
<p>配置解析器提供了可选的值获取方法用来执行类型转换。 默认实现包括 <code>getint()</code>, <code>getfloat()</code> 以及 <code>getboolean()</code>。 如果还需要其他获取方法，用户可以在子类中定义它们，或者传入一个字典，其中每个键都是一个转换器的名称而每个值都是一个实现了特定转换的可调用对象。 例如，传入 <code>{'decimal': decimal.Decimal}</code> 将对解释器对象和所有节代理添加 <code>getdecimal()</code>。 换句话说，可以同时编写 <code>parser_instance.getdecimal('section', 'key', fallback=0)</code> 和 <code>parser_instance['section'].getdecimal('key', 0)</code>。</p>
<p>如果转换器需要访问解析器的状态，可以在配置解析器子类上作为一个方法来实现。 如果该方法的名称是以 <code>get</code> 打头的，它将在所有节代理上以兼容字典的形式提供（参见上面的 <code>getdecimal()</code> 示例）。</p>
</li>
</ul>
<p>更多高级定制选项可通过重载这些解析器属性的默认值来达成。 默认值是在类中定义的，因此它们可以通过子类或属性赋值来重载。</p>
<pre><code>ConfigParser.BOOLEAN_STATES</code></pre><p>默认情况下当使用 <code>getboolean()</code> 时，配置解析器会将下列值视为 <code>True</code>: <code>'1'</code>, <code>'yes'</code>, <code>'true'</code>, <code>'on'</code> 而将下列值视为 <code>False</code>: <code>'0'</code>, <code>'no'</code>, <code>'false'</code>, <code>'off'</code>。 你可以通过指定一个自定义的字符串键及其对应的布尔值字典来重载此行为。 例如:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> custom <span class="token operator">=</span> configparser<span class="token punctuation">.</span>ConfigParser<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> custom<span class="token punctuation">[</span><span class="token string">'section1'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'funky'</span><span class="token punctuation">:</span> <span class="token string">'nope'</span><span class="token punctuation">}</span>
<span class="token operator">>></span><span class="token operator">></span> custom<span class="token punctuation">[</span><span class="token string">'section1'</span><span class="token punctuation">]</span><span class="token punctuation">.</span>getboolean<span class="token punctuation">(</span><span class="token string">'funky'</span><span class="token punctuation">)</span>
Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
ValueError<span class="token punctuation">:</span> Not a boolean<span class="token punctuation">:</span> nope
<span class="token operator">>></span><span class="token operator">></span> custom<span class="token punctuation">.</span>BOOLEAN_STATES <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'sure'</span><span class="token punctuation">:</span> <span class="token boolean">True</span><span class="token punctuation">,</span> <span class="token string">'nope'</span><span class="token punctuation">:</span> <span class="token boolean">False</span><span class="token punctuation">}</span>
<span class="token operator">>></span><span class="token operator">></span> custom<span class="token punctuation">[</span><span class="token string">'section1'</span><span class="token punctuation">]</span><span class="token punctuation">.</span>getboolean<span class="token punctuation">(</span><span class="token string">'funky'</span><span class="token punctuation">)</span>
<span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其他典型的布尔值对包括 <code>accept</code>/<code>reject</code> 或 <code>enabled</code>/<code>disabled</code>。</p>
<p><code>ConfigParser.optionxform</code>(<em>option</em>)</p>
<p>这个方法会转换每次 read, get, 或 set 操作的选项名称。 默认会将名称转换为小写形式。 这也意味着当一个配置文件被写入时，所有键都将为小写形式。 如果此行为不合适则要重载此方法。 例如:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> config <span class="token operator">=</span> <span class="token triple-quoted-string string">"""
... [Section1]
... Key = Value
...
... [Section2]
... AnotherKey = Value
... """</span>
<span class="token operator">>></span><span class="token operator">></span> typical <span class="token operator">=</span> configparser<span class="token punctuation">.</span>ConfigParser<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> typical<span class="token punctuation">.</span>read_string<span class="token punctuation">(</span>config<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> list<span class="token punctuation">(</span>typical<span class="token punctuation">[</span><span class="token string">'Section1'</span><span class="token punctuation">]</span><span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token string">'key'</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> list<span class="token punctuation">(</span>typical<span class="token punctuation">[</span><span class="token string">'Section2'</span><span class="token punctuation">]</span><span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token string">'anotherkey'</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> custom <span class="token operator">=</span> configparser<span class="token punctuation">.</span>RawConfigParser<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> custom<span class="token punctuation">.</span>optionxform <span class="token operator">=</span> <span class="token keyword">lambda</span> option<span class="token punctuation">:</span> option
<span class="token operator">>></span><span class="token operator">></span> custom<span class="token punctuation">.</span>read_string<span class="token punctuation">(</span>config<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> list<span class="token punctuation">(</span>custom<span class="token punctuation">[</span><span class="token string">'Section1'</span><span class="token punctuation">]</span><span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token string">'Key'</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> list<span class="token punctuation">(</span>custom<span class="token punctuation">[</span><span class="token string">'Section2'</span><span class="token punctuation">]</span><span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token string">'AnotherKey'</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>注解</p>
<p>optionxform 函数会将选项名称转换为规范形式。 这应该是一个幂等函数：如果名称已经为规范形式，则应不加修改地将其返回。</p>
<pre><code>ConfigParser.SECTCRE</code></pre><p>一个已编译正则表达式会被用来解析节标头。 默认将 <code>[section]</code> 匹配到名称 <code>"section"</code>。 空格会被视为节名称的一部分，因此 <code>[ larch ]</code> 将被读取为一个名称为 <code>" larch "</code> 的节。 如果此行为不合适则要重载此属性。 例如:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> re
<span class="token operator">>></span><span class="token operator">></span> config <span class="token operator">=</span> <span class="token triple-quoted-string string">"""
... [Section 1]
... option = value
...
... [  Section 2  ]
... another = val
... """</span>
<span class="token operator">>></span><span class="token operator">></span> typical <span class="token operator">=</span> configparser<span class="token punctuation">.</span>ConfigParser<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> typical<span class="token punctuation">.</span>read_string<span class="token punctuation">(</span>config<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> typical<span class="token punctuation">.</span>sections<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token string">'Section 1'</span><span class="token punctuation">,</span> <span class="token string">'  Section 2  '</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> custom <span class="token operator">=</span> configparser<span class="token punctuation">.</span>ConfigParser<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> custom<span class="token punctuation">.</span>SECTCRE <span class="token operator">=</span> re<span class="token punctuation">.</span>compile<span class="token punctuation">(</span>r<span class="token string">"\[ *(?P&lt;header>[^]]+?) *\]"</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> custom<span class="token punctuation">.</span>read_string<span class="token punctuation">(</span>config<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> custom<span class="token punctuation">.</span>sections<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token string">'Section 1'</span><span class="token punctuation">,</span> <span class="token string">'Section 2'</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>注解</p>
<p>虽然 ConfigParser 对象也使用 <code>OPTCRE</code> 属性来识别选项行，但并不推荐重载它，因为这会与构造器选项 <em>allow_no_value</em> 和 <em>delimiters</em> 产生冲突。</p>
<h3 id="旧式-API-示例"><a href="#旧式-API-示例" class="headerlink" title="旧式 API 示例"></a>旧式 API 示例</h3><p>主要出于向下兼容性的考虑，<code>configparser</code> 还提供了一种采用显式 <code>get</code>/<code>set</code> 方法的旧式 API。 虽然以下介绍的方法存在有效的用例，但对于新项目仍建议采用映射协议访问。 旧式 API 在多数时候都更复杂、更底层并且完全违反直觉。</p>
<p>一个写入配置文件的示例:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> configparser
config <span class="token operator">=</span> configparser<span class="token punctuation">.</span>RawConfigParser<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment" spellcheck="true"># Please note that using RawConfigParser's set functions, you can assign</span>
<span class="token comment" spellcheck="true"># non-string values to keys internally, but will receive an error when</span>
<span class="token comment" spellcheck="true"># attempting to write to a file or when you get it in non-raw mode. Setting</span>
<span class="token comment" spellcheck="true"># values using the mapping protocol or ConfigParser's set() does not allow</span>
<span class="token comment" spellcheck="true"># such assignments to take place.</span>
config<span class="token punctuation">.</span>add_section<span class="token punctuation">(</span><span class="token string">'Section1'</span><span class="token punctuation">)</span>
config<span class="token punctuation">.</span>set<span class="token punctuation">(</span><span class="token string">'Section1'</span><span class="token punctuation">,</span> <span class="token string">'an_int'</span><span class="token punctuation">,</span> <span class="token string">'15'</span><span class="token punctuation">)</span>
config<span class="token punctuation">.</span>set<span class="token punctuation">(</span><span class="token string">'Section1'</span><span class="token punctuation">,</span> <span class="token string">'a_bool'</span><span class="token punctuation">,</span> <span class="token string">'true'</span><span class="token punctuation">)</span>
config<span class="token punctuation">.</span>set<span class="token punctuation">(</span><span class="token string">'Section1'</span><span class="token punctuation">,</span> <span class="token string">'a_float'</span><span class="token punctuation">,</span> <span class="token string">'3.1415'</span><span class="token punctuation">)</span>
config<span class="token punctuation">.</span>set<span class="token punctuation">(</span><span class="token string">'Section1'</span><span class="token punctuation">,</span> <span class="token string">'baz'</span><span class="token punctuation">,</span> <span class="token string">'fun'</span><span class="token punctuation">)</span>
config<span class="token punctuation">.</span>set<span class="token punctuation">(</span><span class="token string">'Section1'</span><span class="token punctuation">,</span> <span class="token string">'bar'</span><span class="token punctuation">,</span> <span class="token string">'Python'</span><span class="token punctuation">)</span>
config<span class="token punctuation">.</span>set<span class="token punctuation">(</span><span class="token string">'Section1'</span><span class="token punctuation">,</span> <span class="token string">'foo'</span><span class="token punctuation">,</span> <span class="token string">'%(bar)s is %(baz)s!'</span><span class="token punctuation">)</span>
<span class="token comment" spellcheck="true"># Writing our configuration file to 'example.cfg'</span>
<span class="token keyword">with</span> open<span class="token punctuation">(</span><span class="token string">'example.cfg'</span><span class="token punctuation">,</span> <span class="token string">'w'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> configfile<span class="token punctuation">:</span>
    config<span class="token punctuation">.</span>write<span class="token punctuation">(</span>configfile<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>一个再次读取配置文件的示例:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> configparser
config <span class="token operator">=</span> configparser<span class="token punctuation">.</span>RawConfigParser<span class="token punctuation">(</span><span class="token punctuation">)</span>
config<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token string">'example.cfg'</span><span class="token punctuation">)</span>
<span class="token comment" spellcheck="true"># getfloat() raises an exception if the value is not a float</span>
<span class="token comment" spellcheck="true"># getint() and getboolean() also do this for their respective types</span>
a_float <span class="token operator">=</span> config<span class="token punctuation">.</span>getfloat<span class="token punctuation">(</span><span class="token string">'Section1'</span><span class="token punctuation">,</span> <span class="token string">'a_float'</span><span class="token punctuation">)</span>
an_int <span class="token operator">=</span> config<span class="token punctuation">.</span>getint<span class="token punctuation">(</span><span class="token string">'Section1'</span><span class="token punctuation">,</span> <span class="token string">'an_int'</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>a_float <span class="token operator">+</span> an_int<span class="token punctuation">)</span>
<span class="token comment" spellcheck="true"># Notice that the next output does not interpolate '%(bar)s' or '%(baz)s'.</span>
<span class="token comment" spellcheck="true"># This is because we are using a RawConfigParser().</span>
<span class="token keyword">if</span> config<span class="token punctuation">.</span>getboolean<span class="token punctuation">(</span><span class="token string">'Section1'</span><span class="token punctuation">,</span> <span class="token string">'a_bool'</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>config<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">'Section1'</span><span class="token punctuation">,</span> <span class="token string">'foo'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>要获取插值，请使用 <code>ConfigParser</code>:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> configparser
cfg <span class="token operator">=</span> configparser<span class="token punctuation">.</span>ConfigParser<span class="token punctuation">(</span><span class="token punctuation">)</span>
cfg<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token string">'example.cfg'</span><span class="token punctuation">)</span>
<span class="token comment" spellcheck="true"># Set the optional *raw* argument of get() to True if you wish to disable</span>
<span class="token comment" spellcheck="true"># interpolation in a single get operation.</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>cfg<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">'Section1'</span><span class="token punctuation">,</span> <span class="token string">'foo'</span><span class="token punctuation">,</span> raw<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># -> "Python is fun!"</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>cfg<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">'Section1'</span><span class="token punctuation">,</span> <span class="token string">'foo'</span><span class="token punctuation">,</span> raw<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true"># -> "%(bar)s is %(baz)s!"</span>
<span class="token comment" spellcheck="true"># The optional *vars* argument is a dict with members that will take</span>
<span class="token comment" spellcheck="true"># precedence in interpolation.</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>cfg<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">'Section1'</span><span class="token punctuation">,</span> <span class="token string">'foo'</span><span class="token punctuation">,</span> vars<span class="token operator">=</span><span class="token punctuation">{</span><span class="token string">'bar'</span><span class="token punctuation">:</span> <span class="token string">'Documentation'</span><span class="token punctuation">,</span>
                                       <span class="token string">'baz'</span><span class="token punctuation">:</span> <span class="token string">'evil'</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment" spellcheck="true"># The optional *fallback* argument can be used to provide a fallback value</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>cfg<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">'Section1'</span><span class="token punctuation">,</span> <span class="token string">'foo'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
      <span class="token comment" spellcheck="true"># -> "Python is fun!"</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>cfg<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">'Section1'</span><span class="token punctuation">,</span> <span class="token string">'foo'</span><span class="token punctuation">,</span> fallback<span class="token operator">=</span><span class="token string">'Monty is not.'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
      <span class="token comment" spellcheck="true"># -> "Python is fun!"</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>cfg<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">'Section1'</span><span class="token punctuation">,</span> <span class="token string">'monster'</span><span class="token punctuation">,</span> fallback<span class="token operator">=</span><span class="token string">'No such things as monsters.'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
      <span class="token comment" spellcheck="true"># -> "No such things as monsters."</span>
<span class="token comment" spellcheck="true"># A bare print(cfg.get('Section1', 'monster')) would raise NoOptionError</span>
<span class="token comment" spellcheck="true"># but we can also use:</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>cfg<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">'Section1'</span><span class="token punctuation">,</span> <span class="token string">'monster'</span><span class="token punctuation">,</span> fallback<span class="token operator">=</span>None<span class="token punctuation">)</span><span class="token punctuation">)</span>
      <span class="token comment" spellcheck="true"># -> None</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>默认值在两种类型的 ConfigParser 中均可用。 它们将在当某个选项未在别处定义时被用于插值。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> configparser
<span class="token comment" spellcheck="true"># New instance with 'bar' and 'baz' defaulting to 'Life' and 'hard' each</span>
config <span class="token operator">=</span> configparser<span class="token punctuation">.</span>ConfigParser<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">'bar'</span><span class="token punctuation">:</span> <span class="token string">'Life'</span><span class="token punctuation">,</span> <span class="token string">'baz'</span><span class="token punctuation">:</span> <span class="token string">'hard'</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
config<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token string">'example.cfg'</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>config<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">'Section1'</span><span class="token punctuation">,</span> <span class="token string">'foo'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>     <span class="token comment" spellcheck="true"># -> "Python is fun!"</span>
config<span class="token punctuation">.</span>remove_option<span class="token punctuation">(</span><span class="token string">'Section1'</span><span class="token punctuation">,</span> <span class="token string">'bar'</span><span class="token punctuation">)</span>
config<span class="token punctuation">.</span>remove_option<span class="token punctuation">(</span><span class="token string">'Section1'</span><span class="token punctuation">,</span> <span class="token string">'baz'</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>config<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">'Section1'</span><span class="token punctuation">,</span> <span class="token string">'foo'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>     <span class="token comment" spellcheck="true"># -> "Life is hard!"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="ConfigParser-对象"><a href="#ConfigParser-对象" class="headerlink" title="ConfigParser 对象"></a>ConfigParser 对象</h3><p><em>class</em> <code>configparser.ConfigParser</code>(<em>defaults=None</em>, <em>dict_type=dict</em>, <em>allow_no_value=False</em>, <em>delimiters=’=’, ‘:’</em>, <em>comment_prefixes=’#’, ‘;’</em>, <em>inline_comment_prefixes=None</em>, <em>strict=True</em>, <em>empty_lines_in_values=True</em>, <em>default_section=configparser.DEFAULTSECT</em>, <em>interpolation=BasicInterpolation()</em>, <em>converters={}</em>)</p>
<p>主配置解析器。 当给定 <em>defaults</em> 时，它会被初始化为包含固有默认值的字典。 当给定 <em>dict_type</em> 时，它将被用来创建包含节、节中的选项以及默认值的字典。</p>
<p>当给定 <em>delimiters</em> 时，它会被用作分隔键与值的子字符串的集合。 当给定 <em>comment_prefixes</em> 时，它将被用作在否则为空行的注释的前缀子字符串的集合。 注释可以被缩进。 当给定 <em>inline_comment_prefixes</em> 时，它将被用作非空行的注释的前缀子字符串的集合。</p>
<p>当 <em>strict</em> 为 <code>True</code> (默认值) 时，解析器在从单个源（文件、字符串或字典）读取时将不允许任何节或选项出现重复，否则会引发 <code>DuplicateSectionError</code> 或 <code>DuplicateOptionError</code>。 当 <em>empty_lines_in_values</em> 为 <code>False</code> (默认值: <code>True</code>) 时，每个空行均表示一个选项的结束。 在其他情况下，一个多行选项内部的空行会被保留为值的一部分。 当 <em>allow_no_value</em> 为 <code>True</code> (默认值: <code>False</code>) 时，将接受没有值的选项；此种选项的值将为 <code>None</code> 并且它们会以不带末尾分隔符的形式被序列化。</p>
<p>当给定 <em>default_section</em> 时，它将指定存放其他节的默认值和用于插值的特殊节的名称 (通常命名为 <code>"DEFAULT"</code>)。 该值可通过使用 <code>default_section</code> 实例属性在运行时被读取或修改。</p>
<p>插值行为可通过给出 <em>interpolation</em> 参数提供自定义处理程序的方式来定制。 <code>None</code> 可用来完全禁用插值，<code>ExtendedInterpolation()</code> 提供了一种更高级的变体形式，它的设计受到了 <code>zc.buildout</code> 的启发。 </p>
<p>插值中使用的所有选项名称将像任何其他选项名称引用一样通过 <code>optionxform()</code> 方法来传递。 例如，使用 <code>optionxform()</code> 的默认实现（它会将选项名称转换为小写形式）时，值 <code>foo %(bar)s</code> 和 <code>foo %(BAR)s</code> 是等价的。</p>
<p>当给定 <em>converters</em> 时，它应当为一个字典，其中每个键代表一个类型转换器的名称而每个值则为实现从字符串到目标数据类型的转换的可调用对象。 每个转换器会获得其在解析器对象和节代理上对应的 <code>get*()</code> 方法。</p>
<p>在 3.1 版更改: 默认的 <em>dict_type</em> 为 <code>collections.OrderedDict</code>。</p>
<p>在 3.2 版更改: 添加了 <em>allow_no_value</em>, <em>delimiters</em>, <em>comment_prefixes</em>, <em>strict</em>, <em>empty_lines_in_values</em>, <em>default_section</em> 以及 <em>interpolation</em>。</p>
<p>在 3.5 版更改: 添加了 <em>converters</em> 参数。</p>
<p>在 3.7 版更改: <em>defaults</em> 参数会通过 <code>read_dict()</code> 来读取，提供全解析器范围内一致的行为：非字符串类型的键和值会被隐式地转换为字符串。</p>
<p>在 3.8 版更改: 默认的 <em>dict_type</em> 为 <code>dict</code>，因为它现在会保留插入顺序。</p>
<ul>
<li><p><code>defaults</code>()</p>
<p>返回包含实例范围内默认值的字典。</p>
</li>
<li><p><code>sections</code>()</p>
<p>返回可用节的列表；<em>default section</em> 不包括在该列表中。</p>
</li>
<li><p><code>add_section</code>(<em>section</em>)</p>
<p>向实例添加一个名为 <em>section</em> 的节。 如果给定名称的节已存在，将会引发 <code>DuplicateSectionError</code>。 如果传入了 <em>default section</em> 名称，则会引发 <code>ValueError</code>。 节名称必须为字符串；如果不是则会引发 <code>TypeError</code>。</p>
<p>在 3.2 版更改: 非字符串的节名称将引发 <code>TypeError</code>。</p>
</li>
<li><p><code>has_section</code>(<em>section</em>)</p>
<p>指明相应名称的 <em>section</em> 是否存在于配置中。 <em>default section</em> 不包含在内。</p>
</li>
<li><p><code>options</code>(<em>section</em>)</p>
<p>返回指定 <em>section</em> 中可用选项的列表。</p>
</li>
<li><p><code>has_option</code>(<em>section</em>, <em>option</em>)</p>
<p>如果给定的 <em>section</em> 存在并且包含给定的 <em>option</em> 则返回 <code>True</code>；否则返回 <code>False</code>。 如果指定的 <em>section</em> 为 <code>None</code> 或空字符串，则会使用 DEFAULT。</p>
</li>
<li><p><code>read</code>(<em>filenames</em>, <em>encoding=None</em>)</p>
<p>尝试读取并解析一个包含文件名的可迭代对象，返回一个被成功解析的文件名列表。</p>
<p>如果 <em>filenames</em> 为字符串、<code>bytes</code> 对象或 path-like object，它会被当作单个文件来处理。 如果 <em>filenames</em> 中名称对应的某个文件无法被打开，该文件将被忽略。 这样的设计使得你可以指定包含多个潜在配置文件位置的可迭代对象（例如当前目录、用户家目录以及某个系统级目录），存在于该可迭代对象中的所有配置文件都将被读取。</p>
<p>如果名称对应的文件全都不存在，则 <code>ConfigParser</code> 实例将包含一个空数据集。 一个要求从文件加载初始值的应用应当在调用 <code>read()</code> 来获取任何可选文件之前使用 <code>read_file()</code> 来加载所要求的一个或多个文件:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> configparser<span class="token punctuation">,</span> os
config <span class="token operator">=</span> configparser<span class="token punctuation">.</span>ConfigParser<span class="token punctuation">(</span><span class="token punctuation">)</span>
config<span class="token punctuation">.</span>read_file<span class="token punctuation">(</span>open<span class="token punctuation">(</span><span class="token string">'defaults.cfg'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
config<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'site.cfg'</span><span class="token punctuation">,</span> os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>expanduser<span class="token punctuation">(</span><span class="token string">'~/.myapp.cfg'</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
            encoding<span class="token operator">=</span><span class="token string">'cp1250'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>3.2 新版功能: <em>encoding</em> 形参。 在之前的版本中，所有文件都将使用 <code>open()</code> 的默认编码格式来读取。</p>
<p>3.6.1 新版功能: <em>filenames</em> 形参接受一个 path-like object。</p>
<p>3.7 新版功能: <em>filenames</em> 形参接受一个 <code>bytes</code> 对象。</p>
</li>
<li><p><code>read_file</code>(<em>f</em>, <em>source=None</em>)</p>
<p>从 <em>f</em> 读取并解析配置数据，它必须是一个产生 Unicode 字符串的可迭代对象（例如以文本模式打开的文件）。</p>
<p>可选参数 <em>source</em> 指定要读取的文件名称。 如果未给出并且 <em>f</em> 具有 <code>name</code> 属性，则该属性会被用作 <em>source</em>；默认值为 <code>'&lt;???&gt;'</code>。</p>
<p>3.2 新版功能: 替代 <code>readfp()</code>。</p>
</li>
<li><p><code>read_string</code>(<em>string</em>, <em>source=’<string>’</string></em>)</p>
<p>从字符串中解析配置数据。</p>
<p>可选参数 <em>source</em> 指定一个所传入字符串的上下文专属名称。 如果未给出，则会使用 <code>'&lt;string&gt;'</code>。 这通常应为一个文件系统路径或 URL。</p>
<p>3.2 新版功能.</p>
</li>
<li><p><code>read_dict</code>(<em>dictionary</em>, <em>source=’<dict>’</dict></em>)</p>
<p>从任意一个提供了类似于字典的 <code>items()</code> 方法的对象加载配置。 键为节名称，值为包含节中所出现的键和值的字典。 如果所用的字典类型会保留顺序，则节和其中的键将按顺序加入。 值会被自动转换为字符串。</p>
<p>可选参数 <em>source</em> 指定一个所传入字曲的上下文专属名称。 如果未给出，则会使用 <code>&lt;dict&gt;</code>。</p>
<p>此方法可被用于在解析器之间拷贝状态。</p>
<p>3.2 新版功能.</p>
</li>
<li><p><code>get</code>(<em>section</em>, <em>option</em>, <em>**,</em> raw=False<em>,</em> vars=None<em>[,</em> fallback*])</p>
<p>获取指定名称的 <em>section</em> 的一个 <em>option</em> 的值。 如果提供了 <em>vars*，则它必须为一个字典。 *option</em> 的查找顺序为 <em>vars*（如果有提供）、*section *以及</em> DEFAULTSECT<em>。 如果未找到该键并且提供了</em> fallback<em>，则它会被用作回退值。 可以提供 <code>None</code> 作为</em> fallback* 值。</p>
<p>所有 <code>'%'</code> 插值会在返回值中被展开，除非 <em>raw</em> 参数为真值。 插值键所使用的值会按与选项相同的方式来查找。</p>
<p>在 3.2 版更改: <em>raw</em>, <em>vars</em> 和 <em>fallback</em> 都是仅限关键字参数，以防止用户试图使用第三个参数作业为 <em>fallback</em> 回退值（特别是在使用映射 协议的时候）。</p>
</li>
<li><p><code>getint</code>(<em>section</em>, <em>option</em>, <em>**,</em> raw=False<em>,</em> vars=None<em>[,</em> fallback*])</p>
<p>将在指定 <em>section</em> 中的 <em>option</em> 强制转换为整数的便捷方法。 </p>
</li>
<li><p><code>getfloat</code>(<em>section</em>, <em>option</em>, <em>**,</em> raw=False<em>,</em> vars=None<em>[,</em> fallback*])</p>
<p>将在指定 <em>section</em> 中的 <em>option</em> 强制转换为浮点数的便捷方法。 </p>
</li>
<li><p><code>getboolean</code>(<em>section</em>, <em>option</em>, <em>**,</em> raw=False<em>,</em> vars=None<em>[,</em> fallback*])</p>
<p>将在指定 <em>section</em> 中的 <em>option</em> 强制转换为布尔值的便捷方法。 请注意选项所接受的值为 <code>'1'</code>, <code>'yes'</code>, <code>'true'</code> 和 <code>'on'</code>，它们会使得此方法返回 <code>True</code>，以及 <code>'0'</code>, <code>'no'</code>, <code>'false'</code> 和 <code>'off'</code>，它们会使得此方法返回 <code>False</code>。 这些字符串值会以对大小写不敏感的方式被检测。 任何其他值都将导致引发 <code>ValueError</code>。 </p>
</li>
<li><p><code>items</code>(<em>raw=False</em>, <em>vars=None</em>)</p>
<p><code>items</code>(<em>section</em>, <em>raw=False</em>, <em>vars=None</em>)</p>
<p>当未给出 <em>section</em> 时，将返回由 <em>section_name</em>, <em>section_proxy</em> 对组成的列表，包括 DEFAULTSECT。</p>
<p>在其他情况下，将返回给定的 <em>section</em> 中的 option 的 <em>name</em>, <em>value</em> 对组成的列表。 可选参数具有与 <code>get()</code> 方法的参数相同的含义。</p>
<p>在 3.8 版更改: <em>vars</em> 中的条目将不在结果中出现。 之前的行为混淆了实际的解析器选项和为插值提供的变量。</p>
</li>
<li><p><code>set</code>(<em>section</em>, <em>option</em>, <em>value</em>)</p>
<p>如果给定的节存在，则将所给出的选项设为指定的值；在其他情况下将引发 <code>NoSectionError</code>。 <em>option</em> 和 <em>value</em> 必须为字符串；如果不是则将引发 <code>TypeError</code>。</p>
</li>
<li><p><code>write</code>(<em>fileobject</em>, <em>space_around_delimiters=True</em>)</p>
<p>将配置的表示形式写入指定的 file object，该对象必须以文本模式打开（接受字符串）。 此表示形式可由将来的 <code>read()</code> 调用进行解析。 如果 <em>space_around_delimiters</em> 为真值，键和值之前的分隔符两边将加上空格。</p>
</li>
</ul>
<p>注解</p>
<p>原始配置文件中的注释在写回配置时不会被保留。 具体哪些会被当作注释，取决于为 <em>comment_prefix</em> 和 <em>inline_comment_prefix</em> 所指定的值。</p>
<ul>
<li><p><code>remove_option</code>(<em>section</em>, <em>option</em>)</p>
<p>将指定的 <em>option</em> 从指定的 <em>section</em> 中移除。 如果指定的节不存在则会引发 <code>NoSectionError</code>。 如果要移除的选项存在则返回 <code>True</code>；在其他情况下将返回 <code>False</code>。</p>
</li>
<li><p><code>remove_section</code>(<em>section</em>)</p>
<p>从配置中移除指定的 <em>section</em>。 如果指定的节确实存在则返回 <code>True</code>。 在其他情况下将返回 <code>False</code>。</p>
</li>
<li><p><code>optionxform</code>(<em>option</em>)</p>
<p>将选项名 <em>option</em> 转换为输入文件中的形式或客户端代码所传入的应当在内部结构中使用的形式。 默认实现将返回 <em>option</em> 的小写形式版本；子类可以重载此行为，或者客户端代码也可以在实例上设置一个具有此名称的属性来影响此行为。</p>
<p>你不需要子类化解析器来使用此方法，你也可以在一个实例上设置它，或使用一个接受字符串参数并返回字符串的函数。 例如将它设为 <code>str</code> 将使得选项名称变得大小写敏感:</p>
<pre class="line-numbers language-python"><code class="language-python">cfgparser <span class="token operator">=</span> ConfigParser<span class="token punctuation">(</span><span class="token punctuation">)</span>
cfgparser<span class="token punctuation">.</span>optionxform <span class="token operator">=</span> str<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>请注意当读取配置文件时，选项名称两边的空格将在调用 <code>optionxform()</code> 之前被去除。</p>
</li>
<li><p><code>readfp</code>(<em>fp</em>, <em>filename=None</em>)</p>
<p>3.2 版后已移除: 使用 <code>read_file()</code> 来代替。</p>
<p>在 3.2 版更改: <code>readfp()</code> 现在将在 <em>fp</em> 上执行迭代而不是调用 <code>fp.readline()</code>。</p>
<p>对于调用 <code>readfp()</code> 时传入不支持迭代的参数的现有代码，可以在文件类对象外使用以下生成器作为包装器:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">readline_generator</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">:</span>
    line <span class="token operator">=</span> fp<span class="token punctuation">.</span>readline<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">while</span> line<span class="token punctuation">:</span>
        <span class="token keyword">yield</span> line
        line <span class="token operator">=</span> fp<span class="token punctuation">.</span>readline<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>不再使用 <code>parser.readfp(fp)</code> 而是改用 <code>parser.read_file(readline_generator(fp))</code>。</p>
</li>
</ul>
<pre><code>configparser.MAX_INTERPOLATION_DEPTH</code></pre><p>当 <em>raw</em> 形参为假值时 <code>get()</code> 所采用的递归插值的最大深度。 这只在使用默认的 <em>interpolation</em> 时会起作用。</p>
<h3 id="RawConfigParser-对象"><a href="#RawConfigParser-对象" class="headerlink" title="RawConfigParser 对象"></a>RawConfigParser 对象</h3><p><em>class</em> <code>configparser.RawConfigParser</code>(<em>defaults=None</em>, <em>dict_type=dict</em>, <em>allow_no_value=False</em>, <em>**,</em> delimiters=(‘=’<em>,</em> ‘:’)<em>,</em> comment_prefixes=(‘#’<em>,</em> ‘;’)<em>,</em> inline_comment_prefixes=None<em>,</em> strict=True<em>,</em> empty_lines_in_values=True<em>,</em> default_section=configparser.DEFAULTSECT<em>[,</em> interpolation*])</p>
<p>旧式 <code>ConfigParser</code>。 它默认禁用插值并且允许通过不安全的 <code>add_section</code> 和 <code>set</code> 方法以及旧式 <code>defaults=</code> 关键字参数处理来设置非字符串的节名、选项名和值。</p>
<p>在 3.8 版更改: 默认的 <em>dict_type</em> 为 <code>dict</code>，因为它现在会保留插入顺序。</p>
<p>注解</p>
<p>考虑改用 <code>ConfigParser</code>，它会检查内部保存的值的类型。 如果你不想要插值，你可以使用 <code>ConfigParser(interpolation=None)</code>。</p>
<ul>
<li><p><code>add_section</code>(<em>section</em>)</p>
<p>向实例添加一个名为 <em>section</em> 的节。 如果给定名称的节已存在，将会引发 <code>DuplicateSectionError</code>。 如果传入了 <em>default section</em> 名称，则会引发 <code>ValueError</code>。</p>
<p>不检查 <em>section</em> 以允许用户创建以非字符串命名的节。 此行为已不受支持并可能导致内部错误。</p>
</li>
<li><p><code>set</code>(<em>section</em>, <em>option</em>, <em>value</em>)</p>
<p>如果给定的节存在，则将给定的选项设为指定的值；在其他情况下将引发 <code>NoSectionError</code>。 虽然可能使用 <code>RawConfigParser</code> (或使用 <code>ConfigParser</code> 并将 <em>raw</em> 形参设为真值) 以便实现非字符串值的 <em>internal</em> 存储，但是完整功能（包括插值和输出到文件）只能使用字符串值来实现。</p>
<p>此方法允许用户在内部将非字符串值赋给键。 此行为已不受支持并会在尝试写入到文件或在非原始模式下获取数据时导致错误。 <strong>请使用映射协议 API</strong>，它不允许出现这样的赋值。</p>
</li>
</ul>
<h3 id="异常-1"><a href="#异常-1" class="headerlink" title="异常"></a>异常</h3><p><em>exception</em> <code>configparser.Error</code></p>
<p>所有其他 <code>configparser</code> 异常的基类。</p>
<p><em>exception</em> <code>configparser.NoSectionError</code></p>
<p>当找不到指定节时引发的异常。</p>
<p><em>exception</em> <code>configparser.DuplicateSectionError</code></p>
<p>当调用 <code>add_section()</code> 时传入已存在的节名称，或者在严格解析器中当单个输入文件、字符串或字典内出现重复的节时引发的异常。</p>
<p>3.2 新版功能: 将可选的 <code>source</code> 和 <code>lineno</code> 属性和参数添加到 <code>__init__()</code>。</p>
<p><em>exception</em> <code>configparser.DuplicateOptionError</code></p>
<p>当单个选项在从单个文件、字符串或字典读取时出现两次时引发的异常。 这会捕获拼写错误和大小写敏感相关的错误，例如一个字典可能包含两个键分别代表同一个大小写不敏感的配置键。</p>
<p><em>exception</em> <code>configparser.NoOptionError</code></p>
<p>当指定的选项未在指定的节中被找到时引发的异常。</p>
<p><em>exception</em> <code>configparser.InterpolationError</code></p>
<p>当执行字符串插值发生问题时所引发的异常的基类。</p>
<p><em>exception</em> <code>configparser.InterpolationDepthError</code></p>
<p>当字符串插值由于迭代次数超出 <code>MAX_INTERPOLATION_DEPTH</code> 而无法完成所引发的异常。 为 <code>InterpolationError</code> 的子类。</p>
<p><em>exception</em> <code>configparser.InterpolationMissingOptionError</code></p>
<p>当从某个值引用的选项并不存在时引发的异常。 为 <code>InterpolationError</code> 的子类。</p>
<p><em>exception</em> <code>configparser.InterpolationSyntaxError</code></p>
<p>当将要执行替换的源文本不符合要求的语法时引发的异常。 为 <code>InterpolationError</code> 的子类。</p>
<p><em>exception</em> <code>configparser.MissingSectionHeaderError</code></p>
<p>当尝试解析一个不带节标头的文件时引发的异常。</p>
<p><em>exception</em> <code>configparser.ParsingError</code></p>
<p>当尝试解析一个文件而发生错误时引发的异常。</p>
<p>在 3.2 版更改: <code>filename</code> 属性和 <code>__init__()</code> 参数被重命名为 <code>source</code> 以保持一致性。</p>
<h2 id="netrc-—-netrc-文件处理"><a href="#netrc-—-netrc-文件处理" class="headerlink" title="netrc —- netrc 文件处理"></a><code>netrc</code> —- netrc 文件处理</h2><p><strong>源代码:</strong> <a href="https://github.com/python/cpython/tree/3.10/Lib/netrc.py" target="_blank" rel="noopener">Lib/netrc.py</a></p>
<hr>
<p><code>netrc</code> 类解析并封装了 Unix 的 <strong>ftp</strong> 程序和其他 FTP 客户端所使用的 netrc 文件格式。</p>
<p><em>class</em> <code>netrc.netrc</code>([<em>file</em>])</p>
<p><code>netrc</code> 的实例或其子类的实例会被用来封装来自 netrc 文件的数据。 如果有初始化参数，它将指明要解析的文件。 如果未给出参数，则位于用户家目录的 <code>.netrc</code> 文件 — 即 <code>os.path.expanduser()</code> 所确定的文件 — 将会被读取。 在其他情况下，则将引发 <code>FileNotFoundError</code> 异常。 解析错误将引发 <code>NetrcParseError</code> 并附带诊断信息，包括文件名、行号以及终止令牌。 如果在 POSIX 系统上未指明参数，则当 <code>.netrc</code> 文件中有密码时，如果文件归属或权限不安全（归属的用户不是运行进程的用户，或者可供任何其他用户读取或写入）将引发 <code>NetrcParseError</code>。 这实现了与 ftp 和其他使用 <code>.netrc</code> 的程序同等的安全行为。</p>
<p>在 3.4 版更改: 添加了 POSIX 权限检查。</p>
<p>在 3.7 版更改: 当未将 <em>file</em> 作为参数传入时会使用 <code>os.path.expanduser()</code> 来查找 <code>.netrc</code> 文件的位置。</p>
<p>在 3.10 版更改: <code>netrc</code> 会在使用语言区域指定的编码格式之前先尝试 UTF-8 编码格式。</p>
<p><em>exception</em> <code>netrc.NetrcParseError</code></p>
<p>当在源文本中遇到语法错误时由 <code>netrc</code> 类引发的异常。 此异常的实例提供了三个有用属性: <code>msg</code> 为错误的文本说明，<code>filename</code> 为源文件的名称，而 <code>lineno</code> 给出了错误所在的行号。</p>
<h3 id="netrc-对象"><a href="#netrc-对象" class="headerlink" title="netrc 对象"></a>netrc 对象</h3><p><code>netrc</code> 实例具有下列方法:</p>
<p><code>netrc.authenticators</code>(<em>host</em>)</p>
<p>针对 <em>host</em> 的身份验证者返回一个 3 元组 <code>(login, account, password)</code>。 如果 netrc 文件不包含针对给定主机的条目，则返回关联到 ‘default’ 条目的元组。 如果匹配的主机或默认条目均不可用，则返回 <code>None</code>。</p>
<p><code>netrc.__repr__</code>()</p>
<p>将类数据以 netrc 文件的格式转储为一个字符串。 （这会丢弃注释并可能重排条目顺序。）</p>
<p><code>netrc</code> 的实例具有一些公共实例变量:</p>
<pre><code>netrc.hosts</code></pre><p>将主机名映射到 <code>(login, account, password)</code> 元组的字典。 如果存在 ‘default’ 条目，则会表示为使用该名称的伪主机。</p>
<pre><code>netrc.macros</code></pre><p>将宏名称映射到字符串列表的字典。</p>
<p>注解</p>
<p>密码会被限制为 ASCII 字符集的一个子集。 所有 ASCII 标点符号均可用作密码，但是要注意空白符和非打印字符不允许用作密码。 这是 .netrc 文件解析方式带来的限制，在未来可能会被解除。</p>
<h2 id="xdrlib-—-编码与解码-XDR-数据"><a href="#xdrlib-—-编码与解码-XDR-数据" class="headerlink" title="xdrlib —- 编码与解码 XDR 数据"></a><code>xdrlib</code> —- 编码与解码 XDR 数据</h2><p><strong>源代码:</strong> <a href="https://github.com/python/cpython/tree/3.10/Lib/xdrlib.py" target="_blank" rel="noopener">Lib/xdrlib.py</a></p>
<hr>
<p><code>xdrlib</code> 模块为外部数据表示标准提供支持，该标准的描述见 <a href="https://tools.ietf.org/html/rfc1014.html" target="_blank" rel="noopener"><strong>RFC 1014</strong></a>，由 Sun Microsystems, Inc. 在 1987 年 6 月撰写。 它支持该 RFC 中描述的大部分数据类型。</p>
<p><code>xdrlib</code> 模块定义了两个类，一个用于将变量打包为 XDR 表示形式，另一个用于从 XDR 表示形式解包。 此外还有两个异常类。</p>
<p><em>class</em> <code>xdrlib.Packer</code></p>
<p><code>Packer</code> 是用于将数据打包为 XDR 表示形式的类。 <code>Packer</code> 类的实例化不附带参数。</p>
<p><em>class</em> <code>xdrlib.Unpacker</code>(<em>data</em>)</p>
<p><code>Unpacker</code> 是用于相应地从字符串缓冲区解包 XDR 数据值的类。 输入缓冲区将作为 <em>data</em> 给出。</p>
<p>参见</p>
<p><a href="https://tools.ietf.org/html/rfc1014.html" target="_blank" rel="noopener"><strong>RFC 1014</strong></a> - XDR: 外部数据表示标准</p>
<p>这个 RFC 定义了最初编写此模块时 XDR 所用的数据编码格式。 显然它已被 <a href="https://tools.ietf.org/html/rfc1832.html" target="_blank" rel="noopener"><strong>RFC 1832</strong></a> 所淘汰。</p>
<p><a href="https://tools.ietf.org/html/rfc1832.html" target="_blank" rel="noopener"><strong>RFC 1832</strong></a> - XDR: 外部数据表示标准</p>
<p>更新的 RFC，它提供了经修订的 XDR 定义。</p>
<h3 id="Packer-对象"><a href="#Packer-对象" class="headerlink" title="Packer 对象"></a>Packer 对象</h3><p><code>Packer</code> 实例具有下列方法:</p>
<p><code>Packer.get_buffer</code>()</p>
<p>将当前打包缓冲区以字符串的形式返回。</p>
<p><code>Packer.reset</code>()</p>
<p>将打包缓冲区重置为空字符串。</p>
<p>总体来说，你可以通过调用适当的 <code>pack_type()</code> 方法来打包任何最常见的 XDR 数据类型。 每个方法都是接受单个参数，即要打包的值。 受支持的简单数据类型打包方法如下: <code>pack_uint()</code>, <code>pack_int()</code>, <code>pack_enum()</code>, <code>pack_bool()</code>, <code>pack_uhyper()</code> 以及 <code>pack_hyper()</code>。</p>
<p><code>Packer.pack_float</code>(<em>value</em>)</p>
<p>打包单精度浮点数 <em>value</em>。</p>
<p><code>Packer.pack_double</code>(<em>value</em>)</p>
<p>打包双精度浮点数 <em>value</em>。</p>
<p>以下方法支持打包字符串、字节串以及不透明数据。</p>
<p><code>Packer.pack_fstring</code>(<em>n</em>, <em>s</em>)</p>
<p>打包固定长度字符串 <em>s</em>。 <em>n</em> 为字符串的长度，但它 <em>不会</em> 被打包进数据缓冲区。 如有必要字符串会以空字节串填充以保证 4 字节对齐。</p>
<p><code>Packer.pack_fopaque</code>(<em>n</em>, <em>data</em>)</p>
<p>打包固定长度不透明数据流，类似于 <code>pack_fstring()</code>。</p>
<p><code>Packer.pack_string</code>(<em>s</em>)</p>
<p>打包可变长度字符串 <em>s</em>。 先将字符串的长度打包为无符号整数，再用 <code>pack_fstring()</code> 来打包字符串数据。</p>
<p><code>Packer.pack_opaque</code>(<em>data</em>)</p>
<p>打包可变长度不透明数据流，类似于 <code>pack_string()</code>。</p>
<p><code>Packer.pack_bytes</code>(<em>bytes</em>)</p>
<p>打包可变长度字节流，类似于 <code>pack_string()</code>。</p>
<p>下列方法支持打包数组和列表:</p>
<p><code>Packer.pack_list</code>(<em>list</em>, <em>pack_item</em>)</p>
<p>打包由同质条目构成的 <em>list*。 此方法适用于不确定长度的列表；即其长度无法在遍历整个列表之前获知。 对于列表中的每个条目，先打包一个无符号整数 <code>1</code>，再添加列表中数据的值。 *pack_item</em> 是在打包单个条目时要调用的函数。 在列表的末尾，会再打包一个无符号整数 <code>0</code>。</p>
<p>例如，要打包一个整数列表，代码看起来会是这样:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> xdrlib
p <span class="token operator">=</span> xdrlib<span class="token punctuation">.</span>Packer<span class="token punctuation">(</span><span class="token punctuation">)</span>
p<span class="token punctuation">.</span>pack_list<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> p<span class="token punctuation">.</span>pack_int<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p><code>Packer.pack_farray</code>(<em>n</em>, <em>array</em>, <em>pack_item</em>)</p>
<p>打包由同质条目构成的固定长度列表 (<em>array</em>)。 <em>n</em> 为列表长度；它 <em>不会</em> 被打包到缓冲区，但是如果 <code>len(array)</code> 不等于 <em>n</em> 则会引发 <code>ValueError</code>。 如上所述，<em>pack_item</em> 是在打包每个元素时要使用的函数。</p>
<p><code>Packer.pack_array</code>(<em>list</em>, <em>pack_item</em>)</p>
<p>打包由同质条目构成的可变长度 <em>list</em>。 先将列表的长度打包为无符号整数，再像上面的 <code>pack_farray()</code> 一样打包每个元素。</p>
<h3 id="Unpacker-对象"><a href="#Unpacker-对象" class="headerlink" title="Unpacker 对象"></a>Unpacker 对象</h3><p><code>Unpacker</code> 类提供以下方法:</p>
<p><code>Unpacker.reset</code>(<em>data</em>)</p>
<p>使用给定的 <em>data</em> 重置字符串缓冲区。</p>
<p><code>Unpacker.get_position</code>()</p>
<p>返回数据缓冲区中的当前解包位置。</p>
<p><code>Unpacker.set_position</code>(<em>position</em>)</p>
<p>将数据缓冲区的解包位置设为 <em>position</em>。 你应当小心使用 <code>get_position()</code> 和 <code>set_position()</code>。</p>
<p><code>Unpacker.get_buffer</code>()</p>
<p>将当前解包数据缓冲区以字符串的形式返回。</p>
<p><code>Unpacker.done</code>()</p>
<p>表明解包完成。 如果数据没有全部完成解包则会引发 <code>Error</code> 异常。</p>
<p>此外，每种可通过 <code>Packer</code> 打包的数据类型都可通过 <code>Unpacker</code> 来解包。 解包方法的形式为 <code>unpack_type()</code>，并且不接受任何参数。 该方法将返回解包后的对象。</p>
<p><code>Unpacker.unpack_float</code>()</p>
<p>解包单精度浮点数。</p>
<p><code>Unpacker.unpack_double</code>()</p>
<p>解包双精度浮点数，类似于 <code>unpack_float()</code>。</p>
<p>此外，以下方法可用来解包字符串、字节串以及不透明数据:</p>
<p><code>Unpacker.unpack_fstring</code>(<em>n</em>)</p>
<p>解包并返回固定长度字符串。 <em>n</em> 为期望的字符数量。 会预设以空字节串填充以保证 4 字节对齐。</p>
<p><code>Unpacker.unpack_fopaque</code>(<em>n</em>)</p>
<p>解包并返回固定长度数据流，类似于 <code>unpack_fstring()</code>。</p>
<p><code>Unpacker.unpack_string</code>()</p>
<p>解包并返回可变长度字符串。 先将字符串的长度解包为无符号整数，再用 <code>unpack_fstring()</code> 来解包字符串数据。</p>
<p><code>Unpacker.unpack_opaque</code>()</p>
<p>解包并返回可变长度不透明数据流，类似于 <code>unpack_string()</code>。</p>
<p><code>Unpacker.unpack_bytes</code>()</p>
<p>解包并返回可变长度字节流，类似于 <code>unpack_string()</code>。</p>
<p>下列方法支持解包数组和列表:</p>
<p><code>Unpacker.unpack_list</code>(<em>unpack_item</em>)</p>
<p>解包并返回同质条目的列表。 该列表每次解包一个元素，先解包一个无符号整数旗标。 如果旗标为 <code>1</code>，则解包条目并将其添加到列表。 旗标为 <code>0</code> 表明列表结束。 <em>unpack_item</em> 为在解包条目时调用的函数。</p>
<p><code>Unpacker.unpack_farray</code>(<em>n</em>, <em>unpack_item</em>)</p>
<p>解包并（以列表形式）返回由同质条目构成的固定长度数组。 <em>n</em> 为期望的缓冲区内列表元素数量。 如上所述，<em>unpack_item</em> 是解包每个元素时要使用的函数。</p>
<p><code>Unpacker.unpack_array</code>(<em>unpack_item</em>)</p>
<p>解包并返回由同质条目构成的可变长度 <em>list</em>。 先将列表的长度解包为无符号整数，再像上面的 <code>unpack_farray()</code> 一样解包每个元素。</p>
<h3 id="异常-2"><a href="#异常-2" class="headerlink" title="异常"></a>异常</h3><p>此模块中的异常会表示为类实例代码:</p>
<p><em>exception</em> <code>xdrlib.Error</code></p>
<p>基本异常类。 <code>Error</code> 具有一个公共属性 <code>msg</code>，其中包含对错误的描述。</p>
<p><em>exception</em> <code>xdrlib.ConversionError</code></p>
<p>从 <code>Error</code> 所派生的类。 不包含额外的实例变量。</p>
<p>以下是一个应该如何捕获这些异常的示例:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> xdrlib
p <span class="token operator">=</span> xdrlib<span class="token punctuation">.</span>Packer<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">try</span><span class="token punctuation">:</span>
    p<span class="token punctuation">.</span>pack_double<span class="token punctuation">(</span><span class="token number">8.01</span><span class="token punctuation">)</span>
<span class="token keyword">except</span> xdrlib<span class="token punctuation">.</span>ConversionError <span class="token keyword">as</span> instance<span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'packing the double failed:'</span><span class="token punctuation">,</span> instance<span class="token punctuation">.</span>msg<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="plistlib-—-生成与解析-Apple-plist-文件"><a href="#plistlib-—-生成与解析-Apple-plist-文件" class="headerlink" title="plistlib —- 生成与解析 Apple .plist 文件"></a><code>plistlib</code> —- 生成与解析 Apple <code>.plist</code> 文件</h2><p><strong>源代码:</strong> <a href="https://github.com/python/cpython/tree/3.10/Lib/plistlib.py" target="_blank" rel="noopener">Lib/plistlib.py</a></p>
<hr>
<p>此模块提供了可读写 Apple “property list” 文件的接口，它主要用于 macOS 和 iOS 系统。 此模块同时支持二进制和 XML plist 文件。</p>
<p>property list (<code>.plist</code>) 文件格式是一种简单的序列化格式，它支持一些基本对象类型，例如字典、列表、数字和字符串等。 通常使用一个字典作为最高层级对象。</p>
<p>要写入和解析 plist 文件，请使用 <code>dump()</code> 和 <code>load()</code> 函数。</p>
<p>要以字节串对象形式操作 plist 数据，请使用 <code>dumps()</code> 和 <code>loads()</code>。</p>
<p>值可以为字符串、整数、浮点数、布尔值、元组、列表、字典（但只允许用字符串作为键）、<code>bytes</code>、<code>bytearray</code> 或 <code>datetime.datetime</code> 对象。</p>
<p>在 3.4 版更改: 新版 API，旧版 API 已被弃用。 添加了对二进制 plist 格式的支持。</p>
<p>在 3.8 版更改: 添加了在二进制 plist 中读写 <code>UID</code> 令牌的支持，例如用于 NSKeyedArchiver 和 NSKeyedUnarchiver。</p>
<p>在 3.9 版更改: 旧 API 已被移除。</p>
<p>这个模块定义了以下函数：</p>
<p><code>plistlib.load</code>(<em>fp</em>, <em>**,</em> fmt=None<em>,</em> dict_type=dict*)</p>
<p>读取 plist 文件。 <em>fp</em> 应当可读并且为二进制文件对象。 返回已解包的根对象（通常是一个字典）。</p>
<p><em>fmt</em> 为文件的格式，有效的值如下:</p>
<ul>
<li><code>None</code>: 自动检测文件格式</li>
<li><code>FMT_XML</code>: XML 文件格式</li>
<li><code>FMT_BINARY</code>: 二进制 plist 格式</li>
</ul>
<p><em>dict_type</em> 为字典用来从 plist 文件读取的类型。</p>
<p><code>FMT_XML</code> 格式的 XML 数据 会使用来自 <code>xml.parsers.expat</code> 的 Expat 解析器 — 请参阅其文档了解错误格式 XML 可能引发的异常。 未知元素将被 plist 解析器直接略过。</p>
<p>当文件无法被解析时二进制格式的解析器将引发 <code>InvalidFileException</code>。</p>
<p>3.4 新版功能.</p>
<p><code>plistlib.loads</code>(<em>data</em>, <em>**,</em> fmt=None<em>,</em> dict_type=dict*)</p>
<p>3.4 新版功能.</p>
<p><code>plistlib.dump</code>(<em>value</em>, <em>fp</em>, <em>**,</em> fmt=FMT_XML<em>,</em> sort_keys=True<em>,</em> skipkeys=False*)</p>
<p>将 <em>value</em> 写入 plist 文件。 <em>Fp</em> 应当可写并且为二进制文件对象。</p>
<p><em>fmt</em> 参数指定 plist 文件的格式，可以是以下值之一:</p>
<ul>
<li><code>FMT_XML</code>: XML 格式的 plist 文件</li>
<li><code>FMT_BINARY</code>: 二进制格式的 plist 文件</li>
</ul>
<p>当 <em>sort_keys</em> 为真值（默认）时字典的键将经过排序再写入 plist，否则将按字典的迭代顺序写入。</p>
<p>当 <em>skipkeys</em> 为假值（默认）时该函数将在字典的键不为字符串时引发 <code>TypeError</code>，否则将跳过这样的键。</p>
<p>如果对象是不受支持的类型或者是包含不受支持类型的对象的容器则将引发 <code>TypeError</code>。</p>
<p>对于无法在（二进制）plist 文件中表示的整数值，将会引发 <code>OverflowError</code>。</p>
<p>3.4 新版功能.</p>
<p><code>plistlib.dumps</code>(<em>value</em>, <em>**,</em> fmt=FMT_XML<em>,</em> sort_keys=True<em>,</em> skipkeys=False*)</p>
<p>将 <em>value</em> 以 plist 格式字节串对象的形式返回。 </p>
<p>3.4 新版功能.</p>
<p>可以使用以下的类:</p>
<p><em>class</em> <code>plistlib.UID</code>(<em>data</em>)</p>
<p>包装一个 <code>int</code>。 该类将在读取或写入 NSKeyedArchiver 编码的数据时被使用，其中包含 UID（参见 PList 指南）。</p>
<p>It has one attribute, <code>data</code>, which can be used to retrieve the int value of the UID. <code>data</code> must be in the range <code>0 &lt;= data &lt; 2**64</code>.</p>
<p>3.8 新版功能.</p>
<p>可以使用以下的常量:</p>
<pre><code>plistlib.FMT_XML</code></pre><p>用于 plist 文件的 XML 格式。</p>
<p>3.4 新版功能.</p>
<pre><code>plistlib.FMT_BINARY</code></pre><p>用于 plist 文件的二进制格式。</p>
<p>3.4 新版功能.</p>
<h3 id="例子-5"><a href="#例子-5" class="headerlink" title="例子"></a>例子</h3><p>生成一个 plist:</p>
<pre class="line-numbers language-python"><code class="language-python">pl <span class="token operator">=</span> dict<span class="token punctuation">(</span>
    aString <span class="token operator">=</span> <span class="token string">"Doodah"</span><span class="token punctuation">,</span>
    aList <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"A"</span><span class="token punctuation">,</span> <span class="token string">"B"</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">32.1</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
    aFloat <span class="token operator">=</span> <span class="token number">0.1</span><span class="token punctuation">,</span>
    anInt <span class="token operator">=</span> <span class="token number">728</span><span class="token punctuation">,</span>
    aDict <span class="token operator">=</span> dict<span class="token punctuation">(</span>
        anotherString <span class="token operator">=</span> <span class="token string">"&lt;hello &amp; hi there!>"</span><span class="token punctuation">,</span>
        aThirdString <span class="token operator">=</span> <span class="token string">"M\xe4ssig, Ma\xdf"</span><span class="token punctuation">,</span>
        aTrueValue <span class="token operator">=</span> <span class="token boolean">True</span><span class="token punctuation">,</span>
        aFalseValue <span class="token operator">=</span> <span class="token boolean">False</span><span class="token punctuation">,</span>
    <span class="token punctuation">)</span><span class="token punctuation">,</span>
    someData <span class="token operator">=</span> b<span class="token string">"&lt;binary gunk>"</span><span class="token punctuation">,</span>
    someMoreData <span class="token operator">=</span> b<span class="token string">"&lt;lots of binary gunk>"</span> <span class="token operator">*</span> <span class="token number">10</span><span class="token punctuation">,</span>
    aDate <span class="token operator">=</span> datetime<span class="token punctuation">.</span>datetime<span class="token punctuation">.</span>fromtimestamp<span class="token punctuation">(</span>time<span class="token punctuation">.</span>mktime<span class="token punctuation">(</span>time<span class="token punctuation">.</span>gmtime<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">)</span>
<span class="token keyword">with</span> open<span class="token punctuation">(</span>fileName<span class="token punctuation">,</span> <span class="token string">'wb'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> fp<span class="token punctuation">:</span>
    dump<span class="token punctuation">(</span>pl<span class="token punctuation">,</span> fp<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>解析一个 plist:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">with</span> open<span class="token punctuation">(</span>fileName<span class="token punctuation">,</span> <span class="token string">'rb'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> fp<span class="token punctuation">:</span>
    pl <span class="token operator">=</span> load<span class="token punctuation">(</span>fp<span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>pl<span class="token punctuation">[</span><span class="token string">"aKey"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h1 id="加密服务"><a href="#加密服务" class="headerlink" title="加密服务"></a>加密服务</h1><ul>
<li><code>hashlib</code> —- 安全哈希与消息摘要<ul>
<li>哈希算法</li>
<li>SHAKE 可变长度摘要</li>
<li>密钥派生</li>
<li>BLAKE2<ul>
<li>创建哈希对象</li>
<li>常量</li>
<li>例子<ul>
<li>简单哈希</li>
<li>使用不同的摘要大小</li>
<li>密钥哈希</li>
<li>随机哈希</li>
<li>个性化</li>
<li>树形模式</li>
</ul>
</li>
<li>开发人员</li>
</ul>
</li>
</ul>
</li>
<li><code>hmac</code> —- 基于密钥的消息验证</li>
<li><code>secrets</code> —- 生成管理密码的安全随机数<ul>
<li>随机数</li>
<li>生成 Token<ul>
<li>Token 应当使用多少个字节？</li>
</ul>
</li>
<li>其他功能</li>
<li>应用技巧与最佳实践</li>
</ul>
</li>
</ul>
<h2 id="hashlib-—-安全哈希与消息摘要"><a href="#hashlib-—-安全哈希与消息摘要" class="headerlink" title="hashlib —- 安全哈希与消息摘要"></a><code>hashlib</code> —- 安全哈希与消息摘要</h2><p><strong>源码：</strong> <a href="https://github.com/python/cpython/tree/3.10/Lib/hashlib.py" target="_blank" rel="noopener">Lib/hashlib.py</a></p>
<hr>
<p>这个模块针对许多不同的安全哈希和消息摘要算法实现了一个通用接口。 包括 FIPS 安全哈希算法 SHA1, SHA224, SHA256, SHA384 和 SHA512 (定义于 FIPS 180-2) 以及 RSA 的 MD5 算法 (定义于互联网 <a href="https://tools.ietf.org/html/rfc1321.html" target="_blank" rel="noopener"><strong>RFC 1321</strong></a>)。 术语 “安全哈希” 和 “消息摘要” 是同义的。 较旧的算法被称为消息摘要。 现代的术语是安全哈希。</p>
<p>注解</p>
<p>如果你想找到 adler32 或 crc32 哈希函数，它们在 <code>zlib</code> 模块中。</p>
<p>警告</p>
<p>有些算法已知存在哈希碰撞弱点，请参考最后的“另请参阅”段。</p>
<h3 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h3><p>每种类型的 <em>hash</em> 都有一个构造器方法。 它们都返回一个具有相同的简单接口的 hash 对象。 例如，使用 use <code>sha256()</code> 创建一个 SHA-256 hash 对象。 你可以使用 <code>update()</code> 方法向这个对象输入 字节类对象 (通常是 <code>bytes</code>)。 在任何时候你都可以使用 <code>digest()</code> 或 <code>hexdigest()</code> 方法获得到目前为止输入这个对象的拼接数据的 <em>digest</em>。</p>
<p>注解</p>
<p>为了更好的多线程性能，在对象创建或者更新时，若数据大于2047字节则 Python 的 GIL 会被释放。</p>
<p>注解</p>
<p>向 <code>update()</code> 输入字符串对象是不被支持的，因为哈希基于字节而非字符。</p>
<p>此模块中总是可用的哈希算法构造器有 <code>sha1()</code>, <code>sha224()</code>, <code>sha256()</code>, <code>sha384()</code>, <code>sha512()</code>, <code>blake2b()</code> 和 <code>blake2s()</code>。 <code>md5()</code> 通常也是可用的，但如果你在使用少见的 “FIPS 兼容” 的 Python 编译版本则可能会找不到它。 此外还可能有一些附加的算法，具体取决于你的平台上的 Python 所使用的 OpenSSL 库。 在大部分平台上可用的还有 <code>sha3_224()</code>, <code>sha3_256()</code>, <code>sha3_384()</code>, <code>sha3_512()</code>, <code>shake_128()</code>, <code>shake_256()</code> 等等。·</p>
<p>3.6 新版功能: SHA3 (Keccak) 和 SHAKE 构造器 <code>sha3_224()</code>, <code>sha3_256()</code>, <code>sha3_384()</code>, <code>sha3_512()</code>, <code>shake_128()</code>, <code>shake_256()</code>.</p>
<p>3.6 新版功能: 添加了 <code>blake2b()</code> 和 <code>blake2s()</code> 。</p>
<p>在 3.9 版更改: 所有 hashlib 的构造器都接受仅限关键字参数 <em>usedforsecurity</em> 且其默认值为 <code>True</code>。 设为假值即允许在受限的环境中使用不安全且阻塞的哈希算法。 <code>False</code> 表示此哈希算法不可用于安全场景，例如用作非加密的单向压缩函数。</p>
<p>现在 hashlib 会使用 OpenSSL 1.1.1 或更新版本的 SHA3 和 SHAKE。</p>
<p>例如，如果想获取字节串 <code>b'Nobody inspects the spammish repetition'</code> 的摘要:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> hashlib
<span class="token operator">>></span><span class="token operator">></span> m <span class="token operator">=</span> hashlib<span class="token punctuation">.</span>sha256<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> m<span class="token punctuation">.</span>update<span class="token punctuation">(</span>b<span class="token string">"Nobody inspects"</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> m<span class="token punctuation">.</span>update<span class="token punctuation">(</span>b<span class="token string">" the spammish repetition"</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> m<span class="token punctuation">.</span>digest<span class="token punctuation">(</span><span class="token punctuation">)</span>
b<span class="token string">'\x03\x1e\xdd}Ae\x15\x93\xc5\xfe\\\x00o\xa5u+7\xfd\xdf\xf7\xbcN\x84:\xa6\xaf\x0c\x95\x0fK\x94\x06'</span>
<span class="token operator">>></span><span class="token operator">></span> m<span class="token punctuation">.</span>digest_size
<span class="token number">32</span>
<span class="token operator">>></span><span class="token operator">></span> m<span class="token punctuation">.</span>block_size
<span class="token number">64</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>更简要的写法：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> hashlib<span class="token punctuation">.</span>sha224<span class="token punctuation">(</span>b<span class="token string">"Nobody inspects the spammish repetition"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>hexdigest<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token string">'a4337bc45a8fc544c03f52dc550cd6e1e87021bc896588bd79e901e2'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><code>hashlib.new</code>(<em>name</em>, [<em>data</em>, ]<em>**,</em> usedforsecurity=True*)</p>
<p>一个接受所希望的算法对应的字符串 <em>name</em> 作为第一个形参的通用构造器。 它还允许访问上面列出的哈希算法以及你的 OpenSSL 库可能提供的任何其他算法。 同名的构造器要比 <code>new()</code> 更快所以应当优先使用。</p>
<p>使用 <code>new()</code> 并附带由 OpenSSL 所提供了算法:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> h <span class="token operator">=</span> hashlib<span class="token punctuation">.</span>new<span class="token punctuation">(</span><span class="token string">'sha512_256'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> h<span class="token punctuation">.</span>update<span class="token punctuation">(</span>b<span class="token string">"Nobody inspects the spammish repetition"</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> h<span class="token punctuation">.</span>hexdigest<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token string">'19197dc4d03829df858011c6c87600f994a858103bbc19005f20987aa19a97e2'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>Hashlib 提供下列常量属性：</p>
<pre><code>hashlib.algorithms_guaranteed</code></pre><p>一个集合，其中包含此模块在所有平台上都保证支持的哈希算法的名称。 请注意 ‘md5’ 也在此清单中，虽然某些上游厂商提供了一个怪异的排除了此算法的 “FIPS 兼容” Python 编译版本。</p>
<p>3.2 新版功能.</p>
<pre><code>hashlib.algorithms_available</code></pre><p>一个集合，其中包含在所运行的 Python 解释器上可用的哈希算法的名称。 将这些名称传给 <code>new()</code> 时将可被识别。 <code>algorithms_guaranteed</code> 将总是它的一个子集。 同样的算法在此集合中可能以不同的名称出现多次（这是 OpenSSL 的原因）。</p>
<p>3.2 新版功能.</p>
<p>下列值会以构造器所返回的哈希对象的常量属性的形式被提供:</p>
<pre><code>hash.digest_size</code></pre><p>以字节表示的结果哈希对象的大小。</p>
<pre><code>hash.block_size</code></pre><p>以字节表示的哈希算法的内部块大小。</p>
<p>hash 对象具有以下属性：</p>
<pre><code>hash.name</code></pre><p>此哈希对象的规范名称，总是为小写形式并且总是可以作为 <code>new()</code> 的形参用来创建另一个此类型的哈希对象。</p>
<p>在 3.4 版更改: 该属性名称自被引入起即存在于 CPython 中，但在 Python 3.4 之前并未正式指明，因此可能不存在于某些平台上。</p>
<p>哈希对象具有下列方法:</p>
<p><code>hash.update</code>(<em>data</em>)</p>
<p>用 bytes-like object 来更新哈希对象。 重复调用相当于单次调用并传入所有参数的拼接结果: <code>m.update(a); m.update(b)</code> 等价于 <code>m.update(a+b)</code>。</p>
<p>在 3.1 版更改: 当使用 OpenSSL 提供的哈希算法在大于 2047 字节的数据上执行哈希更新时 Python GIL 会被释放以允许其他线程运行。</p>
<p><code>hash.digest</code>()</p>
<p>返回当前已传给 <code>update()</code> 方法的数据摘要。 这是一个大小为 <code>digest_size</code> 的字节串对象，字节串中可包含 0 至 255 的完整取值范围。</p>
<p><code>hash.hexdigest</code>()</p>
<p>类似于 <code>digest()</code> 但摘要会以两倍长度字符串对象的形式返回，其中仅包含十六进制数码。 这可以被用于在电子邮件或其他非二进制环境中安全地交换数据值。</p>
<p><code>hash.copy</code>()</p>
<p>返回哈希对象的副本（“克隆”）。 这可被用来高效地计算共享相同初始子串的数据的摘要。</p>
<h3 id="SHAKE-可变长度摘要"><a href="#SHAKE-可变长度摘要" class="headerlink" title="SHAKE 可变长度摘要"></a>SHAKE 可变长度摘要</h3><p><code>shake_128()</code> 和 <code>shake_256()</code> 算法提供安全的 length_in_bits//2 至 128 或 256 位可变长度摘要。 为此，它们的摘要需指定一个长度。 SHAKE 算法不限制最大长度。</p>
<p><code>shake.digest</code>(<em>length</em>)</p>
<p>返回当前已传给 <code>update()</code> 方法的数据摘要。 这是一个大小为 <em>length</em> 的字节串对象，字节串中可包含 0 to 255 的完整取值范围。</p>
<p><code>shake.hexdigest</code>(<em>length</em>)</p>
<p>类似于 <code>digest()</code> 但摘要会以两倍长度字符串对象的形式返回，其中仅包含十六进制数码。 这可以被用于在电子邮件或其他非二进制环境中安全地交换数据值。</p>
<h3 id="密钥派生"><a href="#密钥派生" class="headerlink" title="密钥派生"></a>密钥派生</h3><p>密钥派生和密钥延展算法被设计用于安全密码哈希。 <code>sha1(password)</code> 这样的简单算法无法防御暴力攻击。 好的密码哈希函数必须可以微调、放慢步调，并且包含 <a href="https://en.wikipedia.org/wiki/Salt_(cryptography)" target="_blank" rel="noopener">加盐</a>。</p>
<p><code>hashlib.pbkdf2_hmac</code>(<em>hash_name</em>, <em>password</em>, <em>salt</em>, <em>iterations</em>, <em>dklen=None</em>)</p>
<p>此函数提供 PKCS#5 基于密码的密钥派生函数 2。 它使用 HMAC 作为伪随机函数。</p>
<p>字符串 <em>hash_name</em> 是要求用于 HMAC 的哈希摘要算法的名称，例如 ‘sha1’ 或 ‘sha256’。 <em>password</em> 和 <em>salt</em> 会以字节串缓冲区的形式被解析。 应用和库应当将 <em>password</em> 限制在合理长度 (例如 1024)。 <em>salt</em> 应当为适当来源例如 <code>os.urandom()</code> 的大约 16 个或更多的字节串数据。</p>
<p><em>iterations</em> 数值应当基于哈希算法和算力来选择。 在 2013 年时，建议至少为 100,000 次 SHA-256 迭代。</p>
<p><em>dklen</em> 为派生密钥的长度。 如果 <em>dklen</em> 为 <code>None</code> 则会使用哈希算法 <em>hash_name</em> 的摘要大小，例如 SHA-512 为 64。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> hashlib
<span class="token operator">>></span><span class="token operator">></span> dk <span class="token operator">=</span> hashlib<span class="token punctuation">.</span>pbkdf2_hmac<span class="token punctuation">(</span><span class="token string">'sha256'</span><span class="token punctuation">,</span> b<span class="token string">'password'</span><span class="token punctuation">,</span> b<span class="token string">'salt'</span><span class="token punctuation">,</span> <span class="token number">100000</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> dk<span class="token punctuation">.</span>hex<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token string">'0394a2ede332c9a13eb82e9b24631604c31df978b4e2f0fbd2c549944f9d79a5'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>3.4 新版功能.</p>
<p>注解</p>
<p>随同 OpenSSL 提供了一个快速的 <em>pbkdf2_hmac</em> 实现。 Python 实现是使用 <code>hmac</code> 的内联版本。 它的速度大约要慢上三倍并且不会释放 GIL。</p>
<p>3.10 版后已移除: 较慢的 <em>pbkdf2_hmac</em> Python 实现已被弃用。 未来该函数将仅在 Python 附带 OpenSSL 编译时可用。</p>
<p><code>hashlib.scrypt</code>(<em>password</em>, <em>**,</em> salt<em>,</em> n<em>,</em> r<em>,</em> p<em>,</em> maxmem=0<em>,</em> dklen=64*)</p>
<p>此函数提供基于密码加密的密钥派生函数，其定义参见 <a href="https://tools.ietf.org/html/rfc7914.html" target="_blank" rel="noopener"><strong>RFC 7914</strong></a>。</p>
<p><em>password</em> 和 <em>salt</em> 必须为 字节类对象。 应用和库应当将 <em>password</em> 限制在合理长度 (例如 1024)。 <em>salt</em> 应当为适当来源例如 <code>os.urandom()</code> 的大约 16 个或更多的字节串数据。</p>
<p><em>n</em> 为 CPU/内存开销因子，<em>r</em> 为块大小，<em>p</em> 为并行化因子，<em>maxmem</em> 为内存限制 (OpenSSL 1.1.0 默认为 32 MiB)。 <em>dklen</em> 为派生密钥的长度。</p>
<p>3.6 新版功能.</p>
<h3 id="BLAKE2"><a href="#BLAKE2" class="headerlink" title="BLAKE2"></a>BLAKE2</h3><p>BLAKE2 是在 <a href="https://tools.ietf.org/html/rfc7693.html" target="_blank" rel="noopener"><strong>RFC 7693</strong></a> 中定义的加密哈希函数，它有两种形式:</p>
<ul>
<li><strong>BLAKE2b</strong>，针对 64 位平台进行优化，并会生成长度介于 1 和 64 字节之间任意大小的摘要。</li>
<li><strong>BLAKE2s</strong>，针对 8 至 32 位平台进行优化，并会生成长度介于 1 和 32 字节之间任意大小的摘要。</li>
</ul>
<p>BLAKE2 支持 <strong>keyed mode</strong> (<a href="https://en.wikipedia.org/wiki/Hash-based_message_authentication_code" target="_blank" rel="noopener">HMAC</a> 的更快速更简单的替代), <strong>salted hashing</strong>, <strong>personalization</strong> 和 <strong>tree hashing</strong>.</p>
<p>此模块的哈希对象遵循标准库 <code>hashlib</code> 对象的 API。</p>
<h4 id="创建哈希对象"><a href="#创建哈希对象" class="headerlink" title="创建哈希对象"></a>创建哈希对象</h4><p>新哈希对象可通过调用构造器函数来创建:</p>
<p><code>hashlib.blake2b</code>(<em>data=b’’</em>, <em>**,</em> digest_size=64<em>,</em> key=b’’<em>,</em> salt=b’’<em>,</em> person=b’’<em>,</em> fanout=1<em>,</em> depth=1<em>,</em> leaf_size=0<em>,</em> node_offset=0<em>,</em> node_depth=0<em>,</em> inner_size=0<em>,</em> last_node=False<em>,</em> usedforsecurity=True*)</p>
<p><code>hashlib.blake2s</code>(<em>data=b’’</em>, <em>**,</em> digest_size=32<em>,</em> key=b’’<em>,</em> salt=b’’<em>,</em> person=b’’<em>,</em> fanout=1<em>,</em> depth=1<em>,</em> leaf_size=0<em>,</em> node_offset=0<em>,</em> node_depth=0<em>,</em> inner_size=0<em>,</em> last_node=False<em>,</em> usedforsecurity=True*)</p>
<p>这些函数返回用于计算 BLAKE2b 或 BLAKE2s 的相应的哈希对象。 它们接受下列可选通用形参:</p>
<ul>
<li><em>data</em>: 要哈希的初始数据块，它必须为 bytes-like object。 它只能作为位置参数传入。</li>
<li><em>digest_size</em>: 以字节数表示的输出摘要大小。</li>
<li><em>key</em>: 用于密钥哈希的密钥（对于 BLAKE2b 最长 64 字节，对于 BLAKE2s 最长 32 字节）。</li>
<li><em>salt</em>: 用于随机哈希的盐值（对于 BLAKE2b 最长 16 字节，对于 BLAKE2s 最长 8 字节）。</li>
<li><em>person</em>: 个性化字符串（对于 BLAKE2b 最长 16 字节，对于 BLAKE2s 最长 8 字节）。</li>
</ul>
<p>下表显示了常规参数的限制（以字节为单位）：</p>
<table>
<thead>
<tr>
<th align="left">Hash</th>
<th align="left">目标长度</th>
<th align="left">长度（键）</th>
<th align="left">长度（盐）</th>
<th align="left">长度（个人）</th>
</tr>
</thead>
<tbody><tr>
<td align="left">BLAKE2b</td>
<td align="left">64</td>
<td align="left">64</td>
<td align="left">16</td>
<td align="left">16</td>
</tr>
<tr>
<td align="left">BLAKE2s</td>
<td align="left">32</td>
<td align="left">32</td>
<td align="left">8</td>
<td align="left">8</td>
</tr>
</tbody></table>
<p>注解</p>
<p>BLAKE2 规格描述为盐值和个性化形参定义了固定的长度，但是为了方便起见，此实现接受指定在长度以内的任意大小的字节串。 如果形参长度小于指定值，它将以零值进行填充，因此举例来说，<code>b'salt'</code> 和 <code>b'salt\x00'</code> 为相同的值 (<em>key</em> 的情况则并非如此。)</p>
<p>如下面的模块 constants 所描述，这些是可用的大小取值。</p>
<p>构造器函数还接受下列树形哈希形参:</p>
<ul>
<li><em>fanout</em>: 扇出值 (0 至 255，如无限制即为 0，连续模式下为 1)。</li>
<li><em>depth</em>: 树的最大深度 (1 至 255，如无限制则为 255，连续模式下为 1)。</li>
<li><em>leaf_size</em>: maximal byte length of leaf (0 to <code>2**32-1</code>, 0 if unlimited or in sequential mode).</li>
<li><em>node_offset</em>: node offset (0 to <code>2**64-1</code> for BLAKE2b, 0 to <code>2**48-1</code> for BLAKE2s, 0 for the first, leftmost, leaf, or in sequential mode).</li>
<li><em>node_depth</em>: 节点深度 (0 至 255，对于叶子或在连续模式下则为 0)。</li>
<li><em>inner_size</em>: 内部摘要大小 (对于 BLAKE2b 为 0 至 64，对于 BLAKE2s 为 0 至 32，连续模式下则为 0)。</li>
<li><em>last_node</em>: 一个布尔值，指明所处理的节点是否为最后一个 (连续模式下则为 False)。</li>
</ul>
<p><img src="/images/loading.gif" data-original="../images/ML/096779d37726f7e90cce50b0681a9f48.png" alt=""></p>
<p>请参阅 <a href="https://blake2.net/blake2_20130129.pdf" target="_blank" rel="noopener">BLAKE2 规格描述</a> 第 2.10 节获取有关树形哈希的完整说明。</p>
<h4 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h4><pre><code>blake2b.SALT_SIZE
blake2s.SALT_SIZE</code></pre><p>盐值长度（构造器所接受的最大长度）。</p>
<pre><code>blake2b.PERSON_SIZE
blake2s.PERSON_SIZE</code></pre><p>个性化字符串长度（构造器所接受的最大长度）。</p>
<pre><code>blake2b.MAX_KEY_SIZE
blake2s.MAX_KEY_SIZE</code></pre><p>最大密钥长度。</p>
<pre><code>blake2b.MAX_DIGEST_SIZE
blake2s.MAX_DIGEST_SIZE</code></pre><p>哈希函数可输出的最大摘要长度。</p>
<h4 id="例子-6"><a href="#例子-6" class="headerlink" title="例子"></a>例子</h4><h5 id="简单哈希"><a href="#简单哈希" class="headerlink" title="简单哈希"></a>简单哈希</h5><p>要计算某个数据的哈希值，你应该首先通过调用适当的构造器函数 (<code>blake2b()</code> 或 <code>blake2s()</code>) 来构造一个哈希对象，然后通过在该对象上调用 <code>update()</code> 来更新目标数据，最后通过调用 <code>digest()</code> (或针对十六进制编码字符串的 <code>hexdigest()</code>) 来获取该对象的摘要。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> hashlib <span class="token keyword">import</span> blake2b
<span class="token operator">>></span><span class="token operator">></span> h <span class="token operator">=</span> blake2b<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> h<span class="token punctuation">.</span>update<span class="token punctuation">(</span>b<span class="token string">'Hello world'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> h<span class="token punctuation">.</span>hexdigest<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token string">'6ff843ba685842aa82031d3f53c48b66326df7639a63d128974c5c14f31a0f33343a8c65551134ed1ae0f2b0dd2bb495dc81039e3eeb0aa1bb0388bbeac29183'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>作为快捷方式，你可以直接以位置参数的形式向构造器传入第一个数据块来直接更新:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> hashlib <span class="token keyword">import</span> blake2b
<span class="token operator">>></span><span class="token operator">></span> blake2b<span class="token punctuation">(</span>b<span class="token string">'Hello world'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>hexdigest<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token string">'6ff843ba685842aa82031d3f53c48b66326df7639a63d128974c5c14f31a0f33343a8c65551134ed1ae0f2b0dd2bb495dc81039e3eeb0aa1bb0388bbeac29183'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>你可以多次调用 <code>hash.update()</code> 至你所想要的任意次数以迭代地更新哈希值:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> hashlib <span class="token keyword">import</span> blake2b
<span class="token operator">>></span><span class="token operator">></span> items <span class="token operator">=</span> <span class="token punctuation">[</span>b<span class="token string">'Hello'</span><span class="token punctuation">,</span> b<span class="token string">' '</span><span class="token punctuation">,</span> b<span class="token string">'world'</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> h <span class="token operator">=</span> blake2b<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">for</span> item <span class="token keyword">in</span> items<span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     h<span class="token punctuation">.</span>update<span class="token punctuation">(</span>item<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> h<span class="token punctuation">.</span>hexdigest<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token string">'6ff843ba685842aa82031d3f53c48b66326df7639a63d128974c5c14f31a0f33343a8c65551134ed1ae0f2b0dd2bb495dc81039e3eeb0aa1bb0388bbeac29183'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h5 id="使用不同的摘要大小"><a href="#使用不同的摘要大小" class="headerlink" title="使用不同的摘要大小"></a>使用不同的摘要大小</h5><p>BLAKE2 具有可配置的摘要大小，对于 BLAKE2b 最多 64 字节，对于 BLAKE2s 最多 32 字节。 例如，要使用 BLAKE2b 来替代 SHA-1 而不改变输出大小，我们可以让 BLAKE2b 产生 20 个字节的摘要:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> hashlib <span class="token keyword">import</span> blake2b
<span class="token operator">>></span><span class="token operator">></span> h <span class="token operator">=</span> blake2b<span class="token punctuation">(</span>digest_size<span class="token operator">=</span><span class="token number">20</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> h<span class="token punctuation">.</span>update<span class="token punctuation">(</span>b<span class="token string">'Replacing SHA1 with the more secure function'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> h<span class="token punctuation">.</span>hexdigest<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token string">'d24f26cf8de66472d58d4e1b1774b4c9158b1f4c'</span>
<span class="token operator">>></span><span class="token operator">></span> h<span class="token punctuation">.</span>digest_size
<span class="token number">20</span>
<span class="token operator">>></span><span class="token operator">></span> len<span class="token punctuation">(</span>h<span class="token punctuation">.</span>digest<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token number">20</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>不同摘要大小的哈希对象具有完全不同的输出（较短哈希值 <em>并非</em> 较长哈希值的前缀）；即使输出长度相同，BLAKE2b 和 BLAKE2s 也会产生不同的输出:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> hashlib <span class="token keyword">import</span> blake2b<span class="token punctuation">,</span> blake2s
<span class="token operator">>></span><span class="token operator">></span> blake2b<span class="token punctuation">(</span>digest_size<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">.</span>hexdigest<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token string">'6fa1d8fcfd719046d762'</span>
<span class="token operator">>></span><span class="token operator">></span> blake2b<span class="token punctuation">(</span>digest_size<span class="token operator">=</span><span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">.</span>hexdigest<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token string">'eb6ec15daf9546254f0809'</span>
<span class="token operator">>></span><span class="token operator">></span> blake2s<span class="token punctuation">(</span>digest_size<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">.</span>hexdigest<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token string">'1bf21a98c78a1c376ae9'</span>
<span class="token operator">>></span><span class="token operator">></span> blake2s<span class="token punctuation">(</span>digest_size<span class="token operator">=</span><span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">.</span>hexdigest<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token string">'567004bf96e4a25773ebf4'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h5 id="密钥哈希"><a href="#密钥哈希" class="headerlink" title="密钥哈希"></a>密钥哈希</h5><p>密钥哈希可被用于身份验证，作为 基于哈希的消息验证代码 (HMAC) 的一种更快速更简单的替代。 BLAKE2 可在前缀 MAC 模式下安全地使用，这是由于它从 BLAKE 所继承的不可区分特性。</p>
<p>这个例子演示了如何使用密钥 <code>b'pseudorandom key'</code> 来为 <code>b'message data'</code> 获取一个（十六进制编码的）128 位验证代码:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> hashlib <span class="token keyword">import</span> blake2b
<span class="token operator">>></span><span class="token operator">></span> h <span class="token operator">=</span> blake2b<span class="token punctuation">(</span>key<span class="token operator">=</span>b<span class="token string">'pseudorandom key'</span><span class="token punctuation">,</span> digest_size<span class="token operator">=</span><span class="token number">16</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> h<span class="token punctuation">.</span>update<span class="token punctuation">(</span>b<span class="token string">'message data'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> h<span class="token punctuation">.</span>hexdigest<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token string">'3d363ff7401e02026f4a4687d4863ced'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>作为实际的例子，一个 Web 应用可为发送给用户的 cookies 进行对称签名，并在之后对其进行验证以确保它们没有被篡改:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> hashlib <span class="token keyword">import</span> blake2b
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> hmac <span class="token keyword">import</span> compare_digest
<span class="token operator">>></span><span class="token operator">></span>
<span class="token operator">>></span><span class="token operator">></span> SECRET_KEY <span class="token operator">=</span> b<span class="token string">'pseudorandomly generated server secret key'</span>
<span class="token operator">>></span><span class="token operator">></span> AUTH_SIZE <span class="token operator">=</span> <span class="token number">16</span>
<span class="token operator">>></span><span class="token operator">></span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">def</span> <span class="token function">sign</span><span class="token punctuation">(</span>cookie<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     h <span class="token operator">=</span> blake2b<span class="token punctuation">(</span>digest_size<span class="token operator">=</span>AUTH_SIZE<span class="token punctuation">,</span> key<span class="token operator">=</span>SECRET_KEY<span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     h<span class="token punctuation">.</span>update<span class="token punctuation">(</span>cookie<span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">return</span> h<span class="token punctuation">.</span>hexdigest<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">def</span> <span class="token function">verify</span><span class="token punctuation">(</span>cookie<span class="token punctuation">,</span> sig<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     good_sig <span class="token operator">=</span> sign<span class="token punctuation">(</span>cookie<span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">return</span> compare_digest<span class="token punctuation">(</span>good_sig<span class="token punctuation">,</span> sig<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span>
<span class="token operator">>></span><span class="token operator">></span> cookie <span class="token operator">=</span> b<span class="token string">'user-alice'</span>
<span class="token operator">>></span><span class="token operator">></span> sig <span class="token operator">=</span> sign<span class="token punctuation">(</span>cookie<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"{0},{1}"</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>cookie<span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> sig<span class="token punctuation">)</span><span class="token punctuation">)</span>
user<span class="token operator">-</span>alice<span class="token punctuation">,</span>b<span class="token string">'43b3c982cf697e0c5ab22172d1ca7421'</span>
<span class="token operator">>></span><span class="token operator">></span> verify<span class="token punctuation">(</span>cookie<span class="token punctuation">,</span> sig<span class="token punctuation">)</span>
<span class="token boolean">True</span>
<span class="token operator">>></span><span class="token operator">></span> verify<span class="token punctuation">(</span>b<span class="token string">'user-bob'</span><span class="token punctuation">,</span> sig<span class="token punctuation">)</span>
<span class="token boolean">False</span>
<span class="token operator">>></span><span class="token operator">></span> verify<span class="token punctuation">(</span>cookie<span class="token punctuation">,</span> b<span class="token string">'0102030405060708090a0b0c0d0e0f00'</span><span class="token punctuation">)</span>
<span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>即使存在原生的密钥哈希模式，BLAKE2 也同样可在 <code>hmac</code> 模块的 HMAC 构造过程中使用:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> hmac<span class="token punctuation">,</span> hashlib
<span class="token operator">>></span><span class="token operator">></span> m <span class="token operator">=</span> hmac<span class="token punctuation">.</span>new<span class="token punctuation">(</span>b<span class="token string">'secret key'</span><span class="token punctuation">,</span> digestmod<span class="token operator">=</span>hashlib<span class="token punctuation">.</span>blake2s<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> m<span class="token punctuation">.</span>update<span class="token punctuation">(</span>b<span class="token string">'message'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> m<span class="token punctuation">.</span>hexdigest<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token string">'e3c8102868d28b5ff85fc35dda07329970d1a01e273c37481326fe0c861c8142'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h5 id="随机哈希"><a href="#随机哈希" class="headerlink" title="随机哈希"></a>随机哈希</h5><p>用户可通过设置 <em>salt</em> 形参来为哈希函数引入随机化。 随机哈希适用于防止对数字签名中使用的哈希函数进行碰撞攻击。</p>
<blockquote>
<p>随机哈希被设计用来处理当一方（消息准备者）要生成由另一方（消息签名者）进行签名的全部或部分消息的情况。 如果消息准备者能够找到加密哈希函数的碰撞现象（即两条消息产生相同的哈希值），则他们就可以准备将产生相同哈希值和数字签名但却具有不同结果的有意义的消息版本（例如向某个账户转入 $1,000,000 而不是 $10）。 加密哈希函数的设计都是以防碰撞性能为其主要目标之一的，但是当前针对加密哈希函数的集中攻击可能导致特定加密哈希函数所提供的防碰撞性能低于预期。 随机哈希为签名者提供了额外的保护，可以降低准备者在数字签名生成过程中使得两条或更多条消息最终产生相同哈希值的可能性 —- 即使为特定哈希函数找到碰撞现象是可行的。 但是，当消息的所有部分均由签名者准备时，使用随机哈希可能降低数字签名所提供的安全性。</p>
<p>(<a href="https://csrc.nist.gov/publications/detail/sp/800-106/final" target="_blank" rel="noopener">NIST SP-800-106 “数字签名的随机哈希”</a>)</p>
</blockquote>
<p>在 BLAKE2 中，盐值会在初始化期间作为对哈希函数的一次性输入而不是对每个压缩函数的输入来处理。</p>
<p>警告</p>
<p>使用 BLAKE2 或任何其他通用加密哈希函数例如 SHA-256 进行 <em>加盐哈希</em> (或纯哈希) 并不适用于哈希密码。 请参阅 <a href="https://blake2.net/#qa" target="_blank" rel="noopener">BLAKE2 FAQ</a> 了解更多信息。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> os
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> hashlib <span class="token keyword">import</span> blake2b
<span class="token operator">>></span><span class="token operator">></span> msg <span class="token operator">=</span> b<span class="token string">'some message'</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token comment" spellcheck="true"># Calculate the first hash with a random salt.</span>
<span class="token operator">>></span><span class="token operator">></span> salt1 <span class="token operator">=</span> os<span class="token punctuation">.</span>urandom<span class="token punctuation">(</span>blake2b<span class="token punctuation">.</span>SALT_SIZE<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> h1 <span class="token operator">=</span> blake2b<span class="token punctuation">(</span>salt<span class="token operator">=</span>salt1<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> h1<span class="token punctuation">.</span>update<span class="token punctuation">(</span>msg<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token comment" spellcheck="true"># Calculate the second hash with a different random salt.</span>
<span class="token operator">>></span><span class="token operator">></span> salt2 <span class="token operator">=</span> os<span class="token punctuation">.</span>urandom<span class="token punctuation">(</span>blake2b<span class="token punctuation">.</span>SALT_SIZE<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> h2 <span class="token operator">=</span> blake2b<span class="token punctuation">(</span>salt<span class="token operator">=</span>salt2<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> h2<span class="token punctuation">.</span>update<span class="token punctuation">(</span>msg<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token comment" spellcheck="true"># The digests are different.</span>
<span class="token operator">>></span><span class="token operator">></span> h1<span class="token punctuation">.</span>digest<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> h2<span class="token punctuation">.</span>digest<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h5 id="个性化"><a href="#个性化" class="headerlink" title="个性化"></a>个性化</h5><p>出于不同的目的强制让哈希函数为相同的输入生成不同的摘要有时也是有用的。 正如 Skein 哈希函数的作者所言:</p>
<blockquote>
<p>我们建议所有应用设计者慎重考虑这种做法；我们已看到有许多协议在协议的某一部分中计算出来的哈希值在另一个完全不同的部分中也可以被使用，因为两次哈希计算是针对类似或相关的数据进行的，这样攻击者可以强制应用为相同的输入生成哈希值。 个性化协议中所使用的每个哈希函数将有效地阻止这种类型的攻击。</p>
<p>(<a href="http://www.skein-hash.info/sites/default/files/skein1.3.pdf" target="_blank" rel="noopener">Skein 哈希函数族</a>, p. 21)</p>
</blockquote>
<p>BLAKE2 可通过向 <em>person</em> 参数传入字节串来进行个性化:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> hashlib <span class="token keyword">import</span> blake2b
<span class="token operator">>></span><span class="token operator">></span> FILES_HASH_PERSON <span class="token operator">=</span> b<span class="token string">'MyApp Files Hash'</span>
<span class="token operator">>></span><span class="token operator">></span> BLOCK_HASH_PERSON <span class="token operator">=</span> b<span class="token string">'MyApp Block Hash'</span>
<span class="token operator">>></span><span class="token operator">></span> h <span class="token operator">=</span> blake2b<span class="token punctuation">(</span>digest_size<span class="token operator">=</span><span class="token number">32</span><span class="token punctuation">,</span> person<span class="token operator">=</span>FILES_HASH_PERSON<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> h<span class="token punctuation">.</span>update<span class="token punctuation">(</span>b<span class="token string">'the same content'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> h<span class="token punctuation">.</span>hexdigest<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token string">'20d9cd024d4fb086aae819a1432dd2466de12947831b75c5a30cf2676095d3b4'</span>
<span class="token operator">>></span><span class="token operator">></span> h <span class="token operator">=</span> blake2b<span class="token punctuation">(</span>digest_size<span class="token operator">=</span><span class="token number">32</span><span class="token punctuation">,</span> person<span class="token operator">=</span>BLOCK_HASH_PERSON<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> h<span class="token punctuation">.</span>update<span class="token punctuation">(</span>b<span class="token string">'the same content'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> h<span class="token punctuation">.</span>hexdigest<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token string">'cf68fb5761b9c44e7878bfb2c4c9aea52264a80b75005e65619778de59f383a3'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>个性化配合密钥模式也可被用来从单个密钥派生出多个不同密钥。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> hashlib <span class="token keyword">import</span> blake2s
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> base64 <span class="token keyword">import</span> b64decode<span class="token punctuation">,</span> b64encode
<span class="token operator">>></span><span class="token operator">></span> orig_key <span class="token operator">=</span> b64decode<span class="token punctuation">(</span>b<span class="token string">'Rm5EPJai72qcK3RGBpW3vPNfZy5OZothY+kHY6h21KM='</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> enc_key <span class="token operator">=</span> blake2s<span class="token punctuation">(</span>key<span class="token operator">=</span>orig_key<span class="token punctuation">,</span> person<span class="token operator">=</span>b<span class="token string">'kEncrypt'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>digest<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> mac_key <span class="token operator">=</span> blake2s<span class="token punctuation">(</span>key<span class="token operator">=</span>orig_key<span class="token punctuation">,</span> person<span class="token operator">=</span>b<span class="token string">'kMAC'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>digest<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>b64encode<span class="token punctuation">(</span>enc_key<span class="token punctuation">)</span><span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
rbPb15S<span class="token operator">/</span>Z9t<span class="token operator">+</span>agffno5wuhB77VbRi6F9Iv2qIxU7WHw<span class="token operator">=</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>b64encode<span class="token punctuation">(</span>mac_key<span class="token punctuation">)</span><span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
G9GtHFE1YluXY1zWPlYk1e<span class="token operator">/</span>nWfu0WSEb0KRcjhDeP<span class="token operator">/</span>o<span class="token operator">=</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h5 id="树形模式"><a href="#树形模式" class="headerlink" title="树形模式"></a>树形模式</h5><p>以下是对包含两个叶子节点的最小树进行哈希的例子:</p>
<pre><code>  10 /  \00  01</code></pre><p>这个例子使用 64 字节内部摘要，返回 32 字节最终摘要:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> hashlib <span class="token keyword">import</span> blake2b
<span class="token operator">>></span><span class="token operator">></span>
<span class="token operator">>></span><span class="token operator">></span> FANOUT <span class="token operator">=</span> <span class="token number">2</span>
<span class="token operator">>></span><span class="token operator">></span> DEPTH <span class="token operator">=</span> <span class="token number">2</span>
<span class="token operator">>></span><span class="token operator">></span> LEAF_SIZE <span class="token operator">=</span> <span class="token number">4096</span>
<span class="token operator">>></span><span class="token operator">></span> INNER_SIZE <span class="token operator">=</span> <span class="token number">64</span>
<span class="token operator">>></span><span class="token operator">></span>
<span class="token operator">>></span><span class="token operator">></span> buf <span class="token operator">=</span> bytearray<span class="token punctuation">(</span><span class="token number">6000</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token comment" spellcheck="true"># Left leaf</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> h00 <span class="token operator">=</span> blake2b<span class="token punctuation">(</span>buf<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span>LEAF_SIZE<span class="token punctuation">]</span><span class="token punctuation">,</span> fanout<span class="token operator">=</span>FANOUT<span class="token punctuation">,</span> depth<span class="token operator">=</span>DEPTH<span class="token punctuation">,</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>               leaf_size<span class="token operator">=</span>LEAF_SIZE<span class="token punctuation">,</span> inner_size<span class="token operator">=</span>INNER_SIZE<span class="token punctuation">,</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>               node_offset<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> node_depth<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> last_node<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token comment" spellcheck="true"># Right leaf</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> h01 <span class="token operator">=</span> blake2b<span class="token punctuation">(</span>buf<span class="token punctuation">[</span>LEAF_SIZE<span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">,</span> fanout<span class="token operator">=</span>FANOUT<span class="token punctuation">,</span> depth<span class="token operator">=</span>DEPTH<span class="token punctuation">,</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>               leaf_size<span class="token operator">=</span>LEAF_SIZE<span class="token punctuation">,</span> inner_size<span class="token operator">=</span>INNER_SIZE<span class="token punctuation">,</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>               node_offset<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> node_depth<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> last_node<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token comment" spellcheck="true"># Root node</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> h10 <span class="token operator">=</span> blake2b<span class="token punctuation">(</span>digest_size<span class="token operator">=</span><span class="token number">32</span><span class="token punctuation">,</span> fanout<span class="token operator">=</span>FANOUT<span class="token punctuation">,</span> depth<span class="token operator">=</span>DEPTH<span class="token punctuation">,</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>               leaf_size<span class="token operator">=</span>LEAF_SIZE<span class="token punctuation">,</span> inner_size<span class="token operator">=</span>INNER_SIZE<span class="token punctuation">,</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>               node_offset<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> node_depth<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> last_node<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> h10<span class="token punctuation">.</span>update<span class="token punctuation">(</span>h00<span class="token punctuation">.</span>digest<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> h10<span class="token punctuation">.</span>update<span class="token punctuation">(</span>h01<span class="token punctuation">.</span>digest<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> h10<span class="token punctuation">.</span>hexdigest<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token string">'3ad2a9b37c6070e374c7a8c508fe20ca86b6ed54e286e93a0318e95e881db5aa'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="开发人员"><a href="#开发人员" class="headerlink" title="开发人员"></a>开发人员</h4><p><a href="https://blake2.net/" target="_blank" rel="noopener">BLAKE2</a> 是由 <em>Jean-Philippe Aumasson</em>, <em>Samuel Neves</em>, <em>Zooko Wilcox-O’Hearn</em> 和 <em>Christian Winnerlein</em> 基于 <em>Jean-Philippe Aumasson</em>, <em>Luca Henzen</em>, <em>Willi Meier</em> 和 <em>Raphael C.-W. Phan</em> 所创造的 <a href="https://en.wikipedia.org/wiki/NIST_hash_function_competition" target="_blank" rel="noopener">SHA-3</a> 入围方案 <a href="https://131002.net/blake/" target="_blank" rel="noopener">BLAKE</a> 进行设计的。</p>
<p>它使用的核心算法来自由 <em>Daniel J. Bernstein</em> 所设计的 <a href="https://cr.yp.to/chacha.html" target="_blank" rel="noopener">ChaCha</a> 加密。</p>
<p>stdlib 实现是基于 <a href="https://pythonhosted.org/pyblake2/" target="_blank" rel="noopener">pyblake2</a> 模块的。 它由 <em>Dmitry Chestnykh</em> 在 <em>Samuel Neves</em> 所编写的 C 实现的基础上编写。 此文档拷贝自 <a href="https://pythonhosted.org/pyblake2/" target="_blank" rel="noopener">pyblake2</a> 并由 <em>Dmitry Chestnykh</em> 撰写。</p>
<p>C 代码由 <em>Christian Heimes</em> 针对 Python 进行了部分的重写。</p>
<p>以下公共领域贡献同时适用于 C 哈希函数实现、扩展代码和本文档:</p>
<blockquote>
<p>在法律许可的范围内，作者已将此软件的全部版权以及关联和邻接权利贡献到全球公共领域。 此软件的发布不附带任何担保。</p>
<p>你应该已收到此软件附带的 CC0 公共领域专属证书的副本。 如果没有，请参阅 <a href="https://creativecommons.org/publicdomain/zero/1.0/。" target="_blank" rel="noopener">https://creativecommons.org/publicdomain/zero/1.0/。</a></p>
</blockquote>
<p>根据创意分享公共领域贡献 1.0 通用规范，下列人士为此项目的开发提供了帮助或对公共领域的修改作出了贡献:</p>
<ul>
<li><em>Alexandr Sokolovskiy</em></li>
</ul>
<h2 id="hmac-—-基于密钥的消息验证"><a href="#hmac-—-基于密钥的消息验证" class="headerlink" title="hmac —- 基于密钥的消息验证"></a><code>hmac</code> —- 基于密钥的消息验证</h2><p><strong>源代码:</strong> <a href="https://github.com/python/cpython/tree/3.10/Lib/hmac.py" target="_blank" rel="noopener">Lib/hmac.py</a></p>
<hr>
<p>此模块实现了 HMAC 算法，算法的描述参见 <a href="https://tools.ietf.org/html/rfc2104.html" target="_blank" rel="noopener"><strong>RFC 2104</strong></a>。</p>
<p><code>hmac.new</code>(<em>key</em>, <em>msg=None</em>, <em>digestmod=’’</em>)</p>
<p>返回一个新的 hmac 对象。 <em>key</em> 是一个指定密钥的 bytes 或 bytearray 对象。 如果提供了 <em>msg*，将会调用 <code>update(msg)</code> 方法。 *digestmod</em> 为 HMAC 对象所用的摘要名称、摘要构造器或模块。 它可以是适用于 <code>hashlib.new()</code> 的任何名称。 虽然该参数位置靠后，但它却是必须的。</p>
<p>在 3.4 版更改: 形参 <em>key</em> 可以为 bytes 或 bytearray 对象。 形参 <em>msg</em> 可以为 <code>hashlib</code> 所支持的任意类型。 形参 <em>digestmod</em> 可以为某种哈希算法的名称。</p>
<p>Deprecated since version 3.4, removed in version 3.8: MD5 作为 <em>digestmod</em> 的隐式默认摘要已被弃用。 digestmod 形参现在是必须的。 请将其作为关键字参数传入以避免当你没有初始 msg 时将导致的麻烦。</p>
<p><code>hmac.digest</code>(<em>key</em>, <em>msg</em>, <em>digest</em>)</p>
<p>基于给定密钥 <em>key</em> 和 <em>digest</em> 返回 <em>msg</em> 的摘要。 此函数等价于 <code>HMAC(key, msg, digest).digest()</code>，但使用了优化的 C 或内联实现，对放入内存的消息能处理得更快。 形参 <em>key</em>, <em>msg</em> 和 <em>digest</em> 具有与 <code>new()</code> 中相同的含义。</p>
<p>作为 CPython 的实现细节，优化的 C 实现仅当 <em>digest</em> 为字符串并且是一个 OpenSSL 所支持的摘要算法的名称时才会被使用。</p>
<p>3.7 新版功能.</p>
<p>HMAC 对象具有下列方法:</p>
<p><code>HMAC.update</code>(<em>msg</em>)</p>
<p>用 <em>msg</em> 来更新 hmac 对象。 重复调用相当于单次调用并传入所有参数的拼接结果: <code>m.update(a); m.update(b)</code> 等价于 <code>m.update(a + b)</code>。</p>
<p>在 3.4 版更改: 形参 <em>msg</em> 可以为 <code>hashlib</code> 所支持的任何类型。</p>
<p><code>HMAC.digest</code>()</p>
<p>返回当前已传给 <code>update()</code> 方法的字节串数据的摘要。 这个字节串数据的长度将与传给构造器的摘要的长度 <em>digest_size</em> 相同。 它可以包含非 ASCII 的字节，包括 NUL 字节。</p>
<p>警告</p>
<p>在验证例程运行期间将 <code>digest()</code> 的输出与外部提供的摘要进行比较时，建议使用 <code>compare_digest()</code> 函数而不是 <code>==</code> 运算符以减少定时攻击防御力的不足。</p>
<p><code>HMAC.hexdigest</code>()</p>
<p>类似于 <code>digest()</code> 但摘要会以两倍长度字符串的形式返回，其中仅包含十六进制数码。 这可以被用于在电子邮件或其他非二进制环境中安全地交换数据值。</p>
<p>警告</p>
<p>在验证例程运行期间将 <code>hexdigest()</code> 的输出与外部提供的摘要进行比较时，建议使用 <code>compare_digest()</code> 函数而不是 <code>==</code> 运算符以减少定时攻击防御力的不足。</p>
<p><code>HMAC.copy</code>()</p>
<p>返回 hmac 对象的副本（“克隆）。 这可被用来高效地计算共享相同初始子串的数据的摘要。</p>
<p>hash 对象具有以下属性：</p>
<pre><code>HMAC.digest_size</code></pre><p>以字节表示的结果 HMAC 摘要的大小。</p>
<pre><code>HMAC.block_size</code></pre><p>以字节表示的哈希算法的内部块大小。</p>
<p>3.4 新版功能.</p>
<pre><code>HMAC.name</code></pre><p>HMAC 的规范名称，总是为小写形式，例如 <code>hmac-md5</code>。</p>
<p>3.4 新版功能.</p>
<p>3.9 版后已移除: 未写入文档的属性 <code>HMAC.digest_cons</code>, <code>HMAC.inner</code> 和 <code>HMAC.outer</code> 属于内部实现细节，将在 Python 3.10 中被移除。</p>
<p>这个模块还提供了下列辅助函数:</p>
<p><code>hmac.compare_digest</code>(<em>a</em>, <em>b</em>)</p>
<p>返回 <code>a == b</code>。 此函数使用一种经专门设计的方式通过避免基于内容的短路行为来防止定时分析，使得它适合处理密码。 <em>a</em> 和 <em>b</em> 必须为相同的类型：或者是 <code>str</code> (仅限 ASCII 字符，如 <code>HMAC.hexdigest()</code> 的返回值)，或者是 bytes-like object。</p>
<p>注解</p>
<p>如果 <em>a</em> 和 <em>b</em> 具有不同的长度，或者如果发生了错误，定时攻击在理论上可以获取有关 <em>a</em> 和 <em>b</em> 的类型和长度信息 — 但不能获取它们的值。</p>
<p>3.3 新版功能.</p>
<p>在 3.10 版更改: 此函数在可能的情况下会在内部使用 OpenSSL 的 <code>CRYPTO_memcmp()</code>。</p>
<h2 id="secrets-—-生成管理密码的安全随机数"><a href="#secrets-—-生成管理密码的安全随机数" class="headerlink" title="secrets —- 生成管理密码的安全随机数"></a><code>secrets</code> —- 生成管理密码的安全随机数</h2><p>3.6 新版功能.</p>
<p><strong>源代码:</strong> <a href="https://github.com/python/cpython/tree/3.10/Lib/secrets.py" target="_blank" rel="noopener">Lib/secrets.py</a></p>
<hr>
<p><code>secrets</code> 模块用于生成高度加密的随机数，适于管理密码、账户验证、安全凭据及机密数据。</p>
<p>最好用 <code>secrets</code> 替代 <code>random</code> 模块的默认伪随机数生成器，该生成器适用于建模和模拟，不宜用于安全与加密。</p>
<p>参见</p>
<p><a href="https://www.python.org/dev/peps/pep-0506" target="_blank" rel="noopener"><strong>PEP 506</strong></a></p>
<h3 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h3><p><code>secrets</code> 模块是操作系统提供的最安全地随机性来源。</p>
<p><em>class</em> <code>secrets.SystemRandom</code></p>
<p>用操作系统提供的最高质量源生成随机数的类。</p>
<p><code>secrets.choice</code>(<em>sequence</em>)</p>
<p>返回从非空序列中随机选取的元素。</p>
<p><code>secrets.randbelow</code>(<em>n</em>)</p>
<p>返回 [0, <em>n</em>) 范围内的随机整数。</p>
<p><code>secrets.randbits</code>(<em>k</em>)</p>
<p>返回 <em>k</em> 个随机比特位的整数。</p>
<h3 id="生成-Token"><a href="#生成-Token" class="headerlink" title="生成 Token"></a>生成 Token</h3><p><code>secrets</code> 模块提供了生成安全 Token 的函数，适用于密码重置、密保 URL 等应用场景。</p>
<p><code>secrets.token_bytes</code>([<em>nbytes=None</em>])</p>
<p>返回含 <em>nbytes</em> 个字节的随机字节字符串。如果未提供 <em>nbytes<em>，或</em>nbytes</em> 为 <code>None</code>，则使用合理的默认值。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> token_bytes<span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span>  
b<span class="token string">'\xebr\x17D*t\xae\xd4\xe3S\xb6\xe2\xebP1\x8b'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><code>secrets.token_hex</code>([<em>nbytes=None</em>])</p>
<p>返回十六进制随机文本字符串。字符串有 <em>nbytes</em> 个随机字节，每个字节转换为两个十六进制数码。未提供 <em>nbytes</em> 或为 <code>None</code> 时，则使用合理的默认值。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> token_hex<span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span>  
<span class="token string">'f9bf78b9a18ce6d46a0cd2b0b86df9da'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><code>secrets.token_urlsafe</code>([<em>nbytes=None</em>])</p>
<p>返回安全的 URL 随机文本字符串，包含 <em>nbytes</em> 个随机字节。文本用 Base64 编码，平均来说，每个字节对应 1.3 个结果字符。未提供 <em>nbytes</em> 或为 <code>None</code> 时，则使用合理的默认值。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> token_urlsafe<span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span>  
<span class="token string">'Drmhze6EPcv0fN_81Bj-nA'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h4 id="Token-应当使用多少个字节？"><a href="#Token-应当使用多少个字节？" class="headerlink" title="Token 应当使用多少个字节？"></a>Token 应当使用多少个字节？</h4><p>为了在面对 <a href="https://en.wikipedia.org/wiki/Brute-force_attack" target="_blank" rel="noopener">暴力攻击</a> 时保证安全，Token 的随机性必须足够高。随着计算机推衍能力的不断提升，随机性的安全标准也要不断提高。比如 2015 年，32 字节（256 位）的随机性对于 <code>secrets</code> 模块的典型用例就已经足够了。</p>
<p>要自行管理 Token 长度的用户，可以通过为 <code>token_*</code> 函数指定 <code>int</code> 参数显式指定 Token 要使用多大的随机性。该参数以字节数表示随机性大小。</p>
<p>反之，如果未提供参数，或参数为 <code>None</code>，则 <code>token_*</code> 函数将使用合理的默认值。</p>
<p>注解</p>
<p>该默认值随时可能会改变，比如，版本更新的时候。</p>
<h3 id="其他功能"><a href="#其他功能" class="headerlink" title="其他功能"></a>其他功能</h3><p><code>secrets.compare_digest</code>(<em>a</em>, <em>b</em>)</p>
<p>字符串 <em>a</em> 与 <em>b</em> 相等则返回 <code>True</code>，否则返回 <code>False</code>，这种方式可降低 <a href="https://codahale.com/a-lesson-in-timing-attacks/" target="_blank" rel="noopener">定时攻击</a> 的风险。</p>
<h3 id="应用技巧与最佳实践"><a href="#应用技巧与最佳实践" class="headerlink" title="应用技巧与最佳实践"></a>应用技巧与最佳实践</h3><p>本节展示了一些使用 <code>secrets</code> 管理基本安全级别的应用技巧和最佳实践。</p>
<p>生成长度为八个字符的字母数字密码：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> string
<span class="token keyword">import</span> secrets
alphabet <span class="token operator">=</span> string<span class="token punctuation">.</span>ascii_letters <span class="token operator">+</span> string<span class="token punctuation">.</span>digits
password <span class="token operator">=</span> <span class="token string">''</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>secrets<span class="token punctuation">.</span>choice<span class="token punctuation">(</span>alphabet<span class="token punctuation">)</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>注解</p>
<p>应用程序不能 <a href="http://cwe.mitre.org/data/definitions/257.html" target="_blank" rel="noopener">以可恢复的格式存储密码</a>，无论是用纯文本还是加密。 它们应当使用高加密强度的单向（不可恢复）哈希函数来加盐并生成哈希值。</p>
<p>生成长度为十个字符的字母数字密码，包含至少一个小写字母，至少一个大写字母以及至少三个数字：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> string
<span class="token keyword">import</span> secrets
alphabet <span class="token operator">=</span> string<span class="token punctuation">.</span>ascii_letters <span class="token operator">+</span> string<span class="token punctuation">.</span>digits
<span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>
    password <span class="token operator">=</span> <span class="token string">''</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>secrets<span class="token punctuation">.</span>choice<span class="token punctuation">(</span>alphabet<span class="token punctuation">)</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>any<span class="token punctuation">(</span>c<span class="token punctuation">.</span>islower<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">for</span> c <span class="token keyword">in</span> password<span class="token punctuation">)</span>
            <span class="token operator">and</span> any<span class="token punctuation">(</span>c<span class="token punctuation">.</span>isupper<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">for</span> c <span class="token keyword">in</span> password<span class="token punctuation">)</span>
            <span class="token operator">and</span> sum<span class="token punctuation">(</span>c<span class="token punctuation">.</span>isdigit<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">for</span> c <span class="token keyword">in</span> password<span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">break</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>生成 <a href="https://xkcd.com/936/" target="_blank" rel="noopener">XKCD 风格的密码串</a>：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> secrets
<span class="token comment" spellcheck="true"># On standard Linux systems, use a convenient dictionary file.</span>
<span class="token comment" spellcheck="true"># Other platforms may need to provide their own word-list.</span>
<span class="token keyword">with</span> open<span class="token punctuation">(</span><span class="token string">'/usr/share/dict/words'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span>
    words <span class="token operator">=</span> <span class="token punctuation">[</span>word<span class="token punctuation">.</span>strip<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">for</span> word <span class="token keyword">in</span> f<span class="token punctuation">]</span>
    password <span class="token operator">=</span> <span class="token string">' '</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>secrets<span class="token punctuation">.</span>choice<span class="token punctuation">(</span>words<span class="token punctuation">)</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>生成临时密保 URL，包含密码恢复应用的安全 Token：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> secrets
url <span class="token operator">=</span> <span class="token string">'https://mydomain.com/reset='</span> <span class="token operator">+</span> secrets<span class="token punctuation">.</span>token_urlsafe<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h1 id="通用操作系统服务"><a href="#通用操作系统服务" class="headerlink" title="通用操作系统服务"></a>通用操作系统服务</h1><ul>
<li><code>os</code> —- 多种操作系统接口<ul>
<li>文件名，命令行参数，以及环境变量。</li>
<li>Python UTF-8 模式</li>
<li>进程参数</li>
<li>创建文件对象</li>
<li>文件描述符操作<ul>
<li>查询终端的尺寸</li>
<li>文件描述符的继承</li>
</ul>
</li>
<li>文件和目录<ul>
<li>Linux 扩展属性</li>
</ul>
</li>
<li>进程管理</li>
<li>调度器接口</li>
<li>其他系统信息</li>
<li>随机数</li>
</ul>
</li>
<li><code>io</code> —- 处理流的核心工具<ul>
<li>概述<ul>
<li>文本 I/O</li>
<li>二进制 I/O</li>
<li>原始 I/O</li>
</ul>
</li>
<li>文本编码格式<ul>
<li>选择性的 EncodingWarning</li>
</ul>
</li>
<li>高阶模块接口</li>
<li>类的层次结构<ul>
<li>I/O 基类</li>
<li>原始文件 I/O</li>
<li>缓冲流</li>
<li>文本 I/O</li>
</ul>
</li>
<li>性能<ul>
<li>二进制 I/O</li>
<li>文本 I/O</li>
<li>多线程</li>
<li>可重入性</li>
</ul>
</li>
</ul>
</li>
<li><code>time</code> —- 时间的访问和转换<ul>
<li>函数</li>
<li>Clock ID 常量</li>
<li>时区常量</li>
</ul>
</li>
<li><code>argparse</code> —- 命令行选项、参数和子命令解析器<ul>
<li>示例<ul>
<li>创建一个解析器</li>
<li>添加参数</li>
<li>解析参数</li>
</ul>
</li>
<li>ArgumentParser 对象<ul>
<li>prog</li>
<li>usage</li>
<li>description</li>
<li>epilog</li>
<li>parents</li>
<li>formatter_class</li>
<li>prefix_chars</li>
<li>fromfile_prefix_chars</li>
<li>argument_default</li>
<li>allow_abbrev</li>
<li>conflict_handler</li>
<li>add_help</li>
<li>exit_on_error</li>
</ul>
</li>
<li>add_argument() 方法<ul>
<li>name or flags</li>
<li>action</li>
<li>nargs</li>
<li>const</li>
<li>默认值</li>
<li>type — 类型</li>
<li>choices</li>
<li>required</li>
<li>help</li>
<li>metavar</li>
<li>dest</li>
<li>Action 类</li>
</ul>
</li>
<li>parse_args() 方法<ul>
<li>选项值语法</li>
<li>无效的参数</li>
<li>包含 <code>-</code> 的参数</li>
<li>参数缩写（前缀匹配）</li>
<li>在 <code>sys.argv</code> 以外</li>
<li>命名空间对象</li>
</ul>
</li>
<li>其它实用工具<ul>
<li>子命令</li>
<li>FileType 对象</li>
<li>参数组</li>
<li>互斥</li>
<li>解析器默认值</li>
<li>打印帮助</li>
<li>部分解析</li>
<li>自定义文件解析</li>
<li>退出方法</li>
<li>混合解析</li>
</ul>
</li>
<li>升级 optparse 代码</li>
</ul>
</li>
<li><code>getopt</code> —- C 风格的命令行选项解析器</li>
<li><code>logging</code> —- Python 的日志记录工具<ul>
<li>记录器对象</li>
<li>日志级别</li>
<li>处理器对象</li>
<li>格式器对象</li>
<li>过滤器对象</li>
<li>LogRecord 属性</li>
<li>LogRecord 属性</li>
<li>LoggerAdapter 对象</li>
<li>线程安全</li>
<li>模块级函数</li>
<li>模块级属性</li>
<li>与警告模块集成</li>
</ul>
</li>
<li><code>logging.config</code> —- 日志记录配置<ul>
<li>配置函数</li>
<li>配置字典架构<ul>
<li>字典架构细节</li>
<li>增量配置</li>
<li>对象连接</li>
<li>用户定义对象</li>
<li>访问外部对象</li>
<li>访问内部对象</li>
<li>导入解析与定制导入器</li>
</ul>
</li>
<li>配置文件格式</li>
</ul>
</li>
<li><code>logging.handlers</code> —- 日志处理程序<ul>
<li>StreamHandler</li>
<li>FileHandler</li>
<li>NullHandler</li>
<li>WatchedFileHandler</li>
<li>BaseRotatingHandler</li>
<li>RotatingFileHandler</li>
<li>TimedRotatingFileHandler</li>
<li>SocketHandler</li>
<li>DatagramHandler</li>
<li>SysLogHandler</li>
<li>NTEventLogHandler</li>
<li>SMTPHandler</li>
<li>MemoryHandler</li>
<li>HTTPHandler</li>
<li>QueueHandler</li>
<li>QueueListener</li>
</ul>
</li>
<li><code>getpass</code> —- 便携式密码输入工具</li>
<li><code>curses</code> —- 终端字符单元显示的处理<ul>
<li>函数</li>
<li>Window 对象</li>
<li>常量</li>
</ul>
</li>
<li><code>curses.textpad</code> —- 用于 curses 程序的文本输入控件<ul>
<li>文本框对象</li>
</ul>
</li>
<li><code>curses.ascii</code> —- 用于 ASCII 字符的工具</li>
<li><code>curses.panel</code> —- curses 的面板栈扩展<ul>
<li>函数</li>
<li>Panel 对象</li>
</ul>
</li>
<li><code>platform</code> —- 获取底层平台的标识数据<ul>
<li>跨平台</li>
<li>Java平台</li>
<li>Windows平台</li>
<li>macOS Platform</li>
<li>Unix 平台</li>
<li>Linux 平台</li>
</ul>
</li>
<li><code>errno</code> —- 标准 errno 系统符号</li>
<li><code>ctypes</code> —- Python 的外部函数库<ul>
<li>ctypes 教程<ul>
<li>载入动态连接库</li>
<li>操作导入的动态链接库中的函数</li>
<li>调用函数</li>
<li>基础数据类型</li>
<li>调用函数，继续</li>
<li>使用自定义的数据类型调用函数</li>
<li>指定必选参数的类型(函数原型)</li>
<li>返回类型</li>
<li>传递指针（或以引用方式传递形参）</li>
<li>结构体和联合</li>
<li>结构体/联合字段对齐及字节顺序</li>
<li>结构体和联合中的位域</li>
<li>数组</li>
<li>指针</li>
<li>类型转换</li>
<li>不完整类型</li>
<li>回调函数</li>
<li>访问 dll 的导出变量</li>
<li>意外</li>
<li>变长数据类型</li>
</ul>
</li>
<li>ctypes 参考手册<ul>
<li>寻找动态链接库</li>
<li>加载动态链接库</li>
<li>外部函数</li>
<li>函数原型</li>
<li>工具函数</li>
<li>数据类型</li>
<li>基础数据类型</li>
<li>结构化数据类型</li>
<li>数组与指针</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="os-—-多种操作系统接口"><a href="#os-—-多种操作系统接口" class="headerlink" title="os —- 多种操作系统接口"></a><code>os</code> —- 多种操作系统接口</h2><p><strong>源代码：</strong> <a href="https://github.com/python/cpython/tree/3.10/Lib/os.py" target="_blank" rel="noopener">Lib/os.py</a></p>
<hr>
<p>本模块提供了一种使用与操作系统相关的功能的便捷式途径。 </p>
<p>关于这些函数的适用性的说明：</p>
<ul>
<li>Python中所有依赖于操作系统的内置模块的设计都是这样，只要不同的操作系统某一相同的功能可用，它就使用相同的接口。例如，函数 <code>os.stat(path)</code> 以相同的格式返回关于 <em>path</em> 的状态信息（该格式源于 POSIX 接口）。</li>
<li>特定于某一操作系统的扩展通过操作 <code>os</code> 模块也是可用的，但是使用它们当然是对可移植性的一种威胁。</li>
<li>所有接受路径或文件名的函数都同时支持字节串和字符串对象，并在返回路径或文件名时使用相应类型的对象作为结果。</li>
<li>在 VxWorks 系统上，os.popen, os.fork, os.execv 和 os.spawn<em>p</em> 都未支持。</li>
</ul>
<p>注解</p>
<p>如果使用无效或无法访问的文件名与路径，或者其他类型正确但操作系统不接受的参数，此模块的所有函数都抛出 <code>OSError</code> （或者它的子类）。</p>
<p><em>exception</em> <code>os.error</code></p>
<p>内建的 <code>OSError</code> 异常的一个别名。</p>
<pre><code>os.name</code></pre><p>导入的依赖特定操作系统的模块的名称。以下名称目前已注册: <code>'posix'</code>, <code>'nt'</code>, <code>'java'</code>.</p>
<h3 id="文件名，命令行参数，以及环境变量。"><a href="#文件名，命令行参数，以及环境变量。" class="headerlink" title="文件名，命令行参数，以及环境变量。"></a>文件名，命令行参数，以及环境变量。</h3><p>在 Python 中，使用字符串类型表示文件名、命令行参数和环境变量。 在某些系统上，在将这些字符串传递给操作系统之前，必须将这些字符串解码为字节。 Python 使用 filesystem encoding and error handler 来执行此转换。</p>
<p>filesystem encoding and error handler 是在 Python 启动时通过 <code>PyConfig_Read()</code> 函数来配置的。</p>
<p>在 3.1 版更改: 在某些系统上，使用文件系统编码进行转换可能会失败。 在这种情况下，Python 会使用 代理转义编码错误处理器，这意味着在解码时，不可解码的字节被 Unicode 字符 U+DCxx 替换，并且这些字节在编码时再次转换为原始字节。</p>
<p>文件系统编码器 必须保证能成功解码所有 128 以内的字节。如果不能保证，API 函数可能触发 <code>UnicodeError</code> 。</p>
<h3 id="Python-UTF-8-模式"><a href="#Python-UTF-8-模式" class="headerlink" title="Python UTF-8 模式"></a>Python UTF-8 模式</h3><p>3.7 新版功能: 有关更多详细信息，请参阅 <a href="https://www.python.org/dev/peps/pep-0540" target="_blank" rel="noopener"><strong>PEP 540</strong></a> 。</p>
<p>Python UTF-8 模式会忽略 locale encoding 并强制使用 UTF-8 编码。</p>
<ul>
<li>用 UTF-8 作为 文件系统编码。</li>
<li><code>sys.getfilesystemencoding()</code> 返回 <code>'UTF-8'</code> 。</li>
<li><code>locale.getpreferredencoding()</code> 返回 <code>'UTF-8'</code> (<em>do_setlocale</em> 参数不起作用)。</li>
<li><code>sys.stdin</code>, <code>sys.stdout</code> 和 <code>sys.stderr</code> 都将 UTF-8 用作它们的文本编码，并且为 <code>sys.stdin</code> 和 <code>sys.stdout</code> 启用 <code>surrogateescape</code> 错误处理句柄 (<code>sys.stderr</code> 会继续使用 <code>backslashreplace</code> 如同在默认的局部感知模式下一样)</li>
<li>在 Unix 中，<code>os.device_encoding()</code> 返回 <code>'UTF-8'</code>。而不是设备的编码。</li>
</ul>
<p>请注意 UTF-8 模式下的标准流设置可以被 <code>PYTHONIOENCODING</code> 所覆盖（在默认的区域感知模式下也同样如此）。</p>
<p>作为低层级 API 发生改变的结果，其他高层级 API 也会表现出不同的默认行为：</p>
<ul>
<li>命令行参数，环境变量和文件名会使用 UTF-8 编码来解码为文本。</li>
<li><code>os.fsdecode()</code> 和 <code>os.fsencode()</code> 会使用 UTF-8 编码。</li>
<li><code>open()</code>, <code>io.open()</code> 和 <code>codecs.open()</code> 默认会使用 UTF-8 编码。 但是，它们默认仍将使用严格错误处理句柄，因此试图在文本模式下打开二进制文件将可能引发异常，而不是生成无意义的数据。</li>
</ul>
<p>如果在 Python 启动时 LC_CTYPE 区域设为 <code>C</code> 或 <code>POSIX</code> ，则启用 Python UTF-8 模式 (参见 <code>PyConfig_Read()</code> 函数)。</p>
<p>它可以通过命令行选项 <code>-X utf8</code> 和环境变量 <code>PYTHONUTF8</code>，来启用或禁用。</p>
<p>如果没有设置 <code>PYTHONUTF8</code> 环境变量，那么解释器默认使用当前的地区设置，<em>除非</em> 当前地区识别为基于 ASCII 的传统地区（如 <code>PYTHONCOERCECLOCALE</code> 所述），并且 locale coercion 被禁用或失败。在这种传统地区，除非显式指明不要如此，解释器将默认启用 UTF-8 模式。</p>
<p>Python UTF-8 模式只能在 Python 启动时启用。其值可以从 <code>sys.flags.utf8_mode</code> 读取。</p>
<h3 id="进程参数"><a href="#进程参数" class="headerlink" title="进程参数"></a>进程参数</h3><p>这些函数和数据项提供了操作当前进程和用户的信息。</p>
<p><code>os.ctermid</code>()</p>
<p>返回与进程控制终端对应的文件名。</p>
<p>可用性: Unix。</p>
<pre><code>os.environ</code></pre><p>一个表示字符串环境的 mapping 对象。 例如，<code>environ['HOME']</code> 是你的主目录（在某些平台上）的路径名，相当于 C 中的 <code>getenv("HOME")</code>。</p>
<p>这个映射是在第一次导入 <code>os</code> 模块时捕获的，通常作为 Python 启动时处理 <code>site.py</code> 的一部分。除了通过直接修改 <code>os.environ</code> 之外，在此之后对环境所做的更改不会反映在 <code>os.environ</code> 中。</p>
<p>该映射除了可以用于查询环境外，还能用于修改环境。当该映射被修改时，将自动调用 <code>putenv()</code>。</p>
<p>在Unix系统上，键和值会使用 <code>sys.getfilesystemencoding()</code> 和 <code>'surrogateescape'</code> 的错误处理。如果你想使用其他的编码，使用 <code>environb</code>。</p>
<p>注解</p>
<p>直接调用 <code>putenv()</code> 并不会影响 <code>os.environ</code>，所以推荐直接修改 <code>os.environ</code>。</p>
<p>注解</p>
<p>在某些平台上，包括 FreeBSD 和 macOS，设置 <code>environ</code> 可能导致内存泄漏。 请参阅 <code>putenv()</code> 的系统文档。</p>
<p>可以删除映射中的元素来删除对应的环境变量。当从 <code>os.environ</code> 删除元素时，以及调用 <code>pop()</code> 或 <code>clear()</code> 之一时，将自动调用 <code>unsetenv()</code>。</p>
<p>在 3.9 版更改: 已更新并支持了 <a href="https://www.python.org/dev/peps/pep-0584" target="_blank" rel="noopener"><strong>PEP 584</strong></a> 的合并 (<code>|</code>) 和更新 (<code>|=</code>) 运算符。</p>
<pre><code>os.environb</code></pre><p>字节版本的 <code>environ</code>: 一个以字节串表示环境的 mapping 对象。 <code>environ</code> 和 <code>environb</code> 是同步的（修改 <code>environb</code> 会更新 <code>environ</code>，反之亦然）。</p>
<p>只有在 <code>supports_bytes_environ</code> 为 <code>True</code> 的时候 <code>environb</code> 才是可用的。</p>
<p>3.2 新版功能.</p>
<p>在 3.9 版更改: 已更新并支持了 <a href="https://www.python.org/dev/peps/pep-0584" target="_blank" rel="noopener"><strong>PEP 584</strong></a> 的合并 (<code>|</code>) 和更新 (<code>|=</code>) 运算符。</p>
<p><code>os.chdir</code>(<em>path</em>)</p>
<p><code>os.fchdir</code>(<em>fd</em>)</p>
<p><code>os.getcwd</code>()</p>
<p><code>os.fsencode</code>(<em>filename</em>)</p>
<p>将 类似路径形式的 <em>filename</em> 编码为 filesystem encoding and error handler；原样返回 <code>bytes</code>。</p>
<p><code>fsdecode()</code> 是此函数的逆向函数。</p>
<p>3.2 新版功能.</p>
<p>在 3.6 版更改: 增加对实现了 <code>os.PathLike</code> 接口的对象的支持。</p>
<p><code>os.fsdecode</code>(<em>filename</em>)</p>
<p>根据 filesystem encoding and error handler 来解码 类似路径形式的 <em>filename</em>；原样返回 <code>str</code>。</p>
<p><code>fsencode()</code> 是此函数的逆向函数。</p>
<p>3.2 新版功能.</p>
<p>在 3.6 版更改: 增加对实现了 <code>os.PathLike</code> 接口的对象的支持。</p>
<p><code>os.fspath</code>(<em>path</em>)</p>
<p>返回路径的文件系统表示。</p>
<p>如果传入的是 <code>str</code> 或 <code>bytes</code> 类型的字符串，将原样返回。否则 <code>__fspath__()</code> 将被调用，如果得到的是一个 <code>str</code> 或 <code>bytes</code> 类型的对象，那就返回这个值。其他所有情况则会抛出 <code>TypeError</code> 异常。</p>
<p>3.6 新版功能.</p>
<p><em>class</em> <code>os.PathLike</code></p>
<p>某些对象用于表示文件系统中的路径（如 <code>pathlib.PurePath</code> 对象），本类是这些对象的 抽象基类。</p>
<p>3.6 新版功能.</p>
<ul>
<li><p><em>abstractmethod</em> <code>__fspath__</code>()</p>
<p>返回当前对象的文件系统表示。</p>
<p>这个方法只应该返回一个 <code>str</code> 字符串或 <code>bytes</code> 字节串，请优先选择 <code>str</code> 字符串。</p>
</li>
</ul>
<p><code>os.getenv</code>(<em>key</em>, <em>default=None</em>)</p>
<p>如果存在，返回环境变量 <em>key</em> 的值，否则返回 <em>default*。 *key</em> ， <em>default</em> 和返回值均为 str 字符串类型。</p>
<p>在Unix系统上，键和值会使用 <code>sys.getfilesystemencoding()</code> 和<code>‘surrogateescape’</code> 错误处理进行解码。如果你想使用其他的编码，使用 <code>os.getenvb()</code>。</p>
<p>可用性: 大部分的Unix系统，Windows。</p>
<p><code>os.getenvb</code>(<em>key</em>, <em>default=None</em>)</p>
<p>如果存在环境变量 <em>key</em> 那么返回其值，否则返回 <em>default*。 *key</em> ， <em>default</em> 和返回值均为bytes字节串类型。</p>
<p><code>getenvb()</code> 仅在 <code>supports_bytes_environ</code> 为 <code>True</code> 时可用。</p>
<p>可用性: 大部分的Unix系统。</p>
<p>3.2 新版功能.</p>
<p><code>os.get_exec_path</code>(<em>env=None</em>)</p>
<p>返回将用于搜索可执行文件的目录列表，与在外壳程序中启动一个进程时相似。指定的 <em>env</em> 应为用于搜索 PATH 的环境变量字典。默认情况下，当 <em>env</em> 为 <code>None</code> 时，将会使用 <code>environ</code> 。</p>
<p>3.2 新版功能.</p>
<p><code>os.getegid</code>()</p>
<p>返回当前进程的有效组ID。对应当前进程执行文件的 “set id” 位。</p>
<p>可用性: Unix。</p>
<p><code>os.geteuid</code>()</p>
<p>返回当前进程的有效用户ID。</p>
<p>可用性: Unix。</p>
<p><code>os.getgid</code>()</p>
<p>返回当前进程的实际组ID。</p>
<p>可用性: Unix。</p>
<p><code>os.getgrouplist</code>(<em>user</em>, <em>group</em>)</p>
<p>返回该用户所在的组 ID 列表。可能 <em>group</em> 参数没有在返回的列表中，实际上用户应该也是属于该 <em>group<em>。</em>group</em> 参数一般可以从储存账户信息的密码记录文件中找到。</p>
<p>可用性: Unix。</p>
<p>3.3 新版功能.</p>
<p><code>os.getgroups</code>()</p>
<p>返回当前进程关联的附加组ID列表</p>
<p>可用性: Unix。</p>
<p>注解</p>
<p>在 macOS 中，<code>getgroups()</code> 会和其他 Unix 平台有所不同。 如果 Python 解释器是在 <code>10.5</code> 或更早版本中部署的，则 <code>getgroups()</code> 会返回与当前用户进程相关联的有效组 ID 列表；该列表受限于系统预定义的条目数量，通常为 16，并且在适当的权限下还可通过调用 <code>setgroups()</code> 来修改。 如果是在高于 <code>10.5</code> 的版本中部署的，则 <code>getgroups()</code> 会返回与进程的有效用户 ID 相关联的当前组访问列表；组访问列表可能会在进程的生命周期之内发生改变，它不会受对 <code>setgroups()</code> 的调用影响，且其长度也不被限制为 16。 部署目标值 <code>MACOSX_DEPLOYMENT_TARGET</code> 可以通过 <code>sysconfig.get_config_var()</code> 来获取。</p>
<p><code>os.getlogin</code>()</p>
<p>返回通过控制终端进程进行登录的用户名。在多数情况下，使用 <code>getpass.getuser()</code> 会更有效，因为后者会通过检查环境变量 <code>LOGNAME</code> 或 <code>USERNAME</code> 来查找用户，再由 <code>pwd.getpwuid(os.getuid())[0]</code> 来获取当前用户 ID 的登录名。</p>
<p>可用性: Unix, Windows。</p>
<p><code>os.getpgid</code>(<em>pid</em>)</p>
<p>根据进程id <em>pid</em> 返回进程的组 ID 列表。如果 <em>pid</em> 为 0，则返回当前进程的进程组 ID 列表</p>
<p>可用性: Unix。</p>
<p><code>os.getpgrp</code>()</p>
<p>返回当时进程组的ID</p>
<p>可用性: Unix。</p>
<p><code>os.getpid</code>()</p>
<p>返回当前进程ID</p>
<p><code>os.getppid</code>()</p>
<p>返回父进程ID。当父进程已经结束，在Unix中返回的ID是初始进程(1)中的一个，在Windows中仍然是同一个进程ID，该进程ID有可能已经被进行进程所占用。</p>
<p>可用性: Unix, Windows。</p>
<p>在 3.2 版更改: 添加WIndows的支持。</p>
<p><code>os.getpriority</code>(<em>which</em>, <em>who</em>)</p>
<p>获取程序调度优先级。<em>which</em> 参数值可以是 <code>PRIO_PROCESS</code>，<code>PRIO_PGRP</code>，或 <code>PRIO_USER</code> 中的一个，<em>who</em> 是相对于 <em>which</em> (<code>PRIO_PROCESS</code> 的进程标识符，<code>PRIO_PGRP</code> 的进程组标识符和 <code>PRIO_USER</code> 的用户ID)。当 <em>who</em> 为 0 时（分别）表示调用的进程，调用进程的进程组或调用进程所属的真实用户 ID。</p>
<p>可用性: Unix。</p>
<p>3.3 新版功能.</p>
<pre><code>os.PRIO_PROCESS
os.PRIO_PGRP
os.PRIO_USER</code></pre><p>函数 <code>getpriority()</code> 和 <code>setpriority()</code> 的参数。</p>
<p>可用性: Unix。</p>
<p>3.3 新版功能.</p>
<p><code>os.getresuid</code>()</p>
<p>返回一个由 (ruid, euid, suid) 所组成的元组，分别表示当前进程的真实用户ID，有效用户ID和暂存用户ID。</p>
<p>可用性: Unix。</p>
<p>3.2 新版功能.</p>
<p><code>os.getresgid</code>()</p>
<p>返回一个由 (rgid, egid, sgid) 所组成的元组，分别表示当前进程的真实组ID，有效组ID和暂存组ID。</p>
<p>可用性: Unix。</p>
<p>3.2 新版功能.</p>
<p><code>os.getuid</code>()</p>
<p>返回当前进程的真实用户ID。</p>
<p>可用性: Unix。</p>
<p><code>os.initgroups</code>(<em>username</em>, <em>gid</em>)</p>
<p>调用系统 initgroups()，使用指定用户所在的所有值来初始化组访问列表，包括指定的组ID。</p>
<p>可用性: Unix。</p>
<p>3.2 新版功能.</p>
<p><code>os.putenv</code>(<em>key</em>, <em>value</em>)</p>
<p>将名为 <em>key</em> 的环境变量值设置为 <em>value</em>。该变量名修改会影响由 <code>os.system()</code>， <code>popen()</code> ，<code>fork()</code> 和 <code>execv()</code> 发起的子进程。</p>
<p><code>os.environ</code> 中的参数赋值会自动转换为对 <code>putenv()</code> 的调用。不过 <code>putenv()</code> 的调用不会更新 <code>os.environ</code>，因此最好使用 <code>os.environ</code> 对变量赋值。</p>
<p>注解</p>
<p>在某些平台上，包括 FreeBSD 和 macOS，设置 <code>environ</code> 可能导致内存泄漏。 请参阅 <code>putenv()</code> 的系统文档。</p>
<p>引发一个 审计事件 <code>os.putenv</code>，附带参数 <code>key</code>, <code>value</code>。</p>
<p>在 3.9 版更改: 该函数现在总是可用。</p>
<p><code>os.setegid</code>(<em>egid</em>)</p>
<p>设置当前进程的有效组ID。</p>
<p>可用性: Unix。</p>
<p><code>os.seteuid</code>(<em>euid</em>)</p>
<p>设置当前进程的有效用户ID。</p>
<p>可用性: Unix。</p>
<p><code>os.setgid</code>(<em>gid</em>)</p>
<p>设置当前进程的组ID。</p>
<p>可用性: Unix。</p>
<p><code>os.setgroups</code>(<em>groups</em>)</p>
<p>将 <em>group</em> 参数值设置为与当进程相关联的附加组ID列表。<em>group</em> 参数必须为一个序列，每个元素应为每个组的数字ID。该操作通常只适用于超级用户。</p>
<p>可用性: Unix。</p>
<p>注解</p>
<p>在 macOS 中，<em>groups</em> 的长度不能超过系统定义的最大有效组 ID 数量，通常为 16。 对于未返回与调用 setgroups() 产生的相同组列表的情况。</p>
<p><code>os.setpgrp</code>()</p>
<p>根据已实现的版本（如果有）来调用系统 <code>setpgrp()</code> 或 <code>setpgrp(0, 0)</code> 。相关说明，请参考 Unix 手册。</p>
<p>可用性: Unix。</p>
<p><code>os.setpgid</code>(<em>pid</em>, <em>pgrp</em>)</p>
<p>使用系统调用 <code>setpgid()</code>，将 <em>pid</em> 对应进程的组ID设置为 <em>pgrp</em>。相关说明，请参考 Unix 手册。</p>
<p>可用性: Unix。</p>
<p><code>os.setpriority</code>(<em>which</em>, <em>who</em>, <em>priority</em>)</p>
<p>设置程序调度优先级。 <em>which</em> 的值为 <code>PRIO_PROCESS</code>, <code>PRIO_PGRP</code> 或 <code>PRIO_USER</code> 之一，而 <em>who</em> 会相对于 <em>which</em> (<code>PRIO_PROCESS</code> 的进程标识符, <code>PRIO_PGRP</code> 的进程组标识符和 <code>PRIO_USER</code> 的用户 ID) 被解析。 <em>who</em> 值为零 (分别) 表示调用进程，调用进程的进程组或调用进程的真实用户 ID。 <em>priority</em> 是范围在 -20 至 19 的值。 默认优先级为 0；较小的优先级数值会更优先被调度。</p>
<p>可用性: Unix。</p>
<p>3.3 新版功能.</p>
<p><code>os.setregid</code>(<em>rgid</em>, <em>egid</em>)</p>
<p>设置当前进程的真实和有效组ID。</p>
<p>可用性: Unix。</p>
<p><code>os.setresgid</code>(<em>rgid</em>, <em>egid</em>, <em>sgid</em>)</p>
<p>设置当前进程的真实，有效和暂存组ID。</p>
<p>可用性: Unix。</p>
<p>3.2 新版功能.</p>
<p><code>os.setresuid</code>(<em>ruid</em>, <em>euid</em>, <em>suid</em>)</p>
<p>设置当前进程的真实，有效和暂存用户ID。</p>
<p>可用性: Unix。</p>
<p>3.2 新版功能.</p>
<p><code>os.setreuid</code>(<em>ruid</em>, <em>euid</em>)</p>
<p>设置当前进程的真实和有效用户ID。</p>
<p>可用性: Unix。</p>
<p><code>os.getsid</code>(<em>pid</em>)</p>
<p>调用系统调用 <code>getsid()</code>。相关说明，请参考 Unix 手册。</p>
<p>可用性: Unix。</p>
<p><code>os.setsid</code>()</p>
<p>使用系统调用 <code>getsid()</code>。相关说明，请参考 Unix 手册。</p>
<p>可用性: Unix。</p>
<p><code>os.setuid</code>(<em>uid</em>)</p>
<p>设置当前进程的用户ID。</p>
<p>可用性: Unix。</p>
<p><code>os.strerror</code>(<em>code</em>)</p>
<p>根据 <em>code</em> 中的错误码返回错误消息。 在某些平台上当给出未知错误码时 <code>strerror()</code> 将返回 <code>NULL</code> 并会引发 <code>ValueError</code>。</p>
<pre><code>os.supports_bytes_environ</code></pre><p>如果操作系统上原生环境类型是字节型则为 <code>True</code> (例如在 Windows 上为 <code>False</code>)。</p>
<p>3.2 新版功能.</p>
<p><code>os.umask</code>(<em>mask</em>)</p>
<p>设定当前数值掩码并返回之前的掩码。</p>
<p><code>os.uname</code>()</p>
<p>返回当前操作系统的识别信息。返回值是一个有5个属性的对象：</p>
<ul>
<li><code>sysname</code> - 操作系统名</li>
<li><code>nodename</code> - 机器在网络上的名称（需要先设定）</li>
<li><code>release</code> - 操作系统发行信息</li>
<li><code>version</code> - 操作系统版本信息</li>
<li><code>machine</code> - 硬件标识符</li>
</ul>
<p>为了向后兼容，该对象也是可迭代的，像是一个按照 <code>sysname</code>，<code>nodename</code>，<code>release</code>，<code>version</code>，和 <code>machine</code> 顺序组成的元组。</p>
<p>有些系统会将 <code>nodename</code> 截短为 8 个字符或截短至前缀部分；获取主机名的一个更好方式是 <code>socket.gethostname()</code> 或甚至可以用 <code>socket.gethostbyaddr(socket.gethostname())</code>。</p>
<p>可用性: 较新的 Unix 版本。</p>
<p>在 3.3 版更改: 返回结果的类型由元组变成一个类似元组的对象，同时具有命名的属性。</p>
<p><code>os.unsetenv</code>(<em>key</em>)</p>
<p>取消设置（删除）名为 <em>key</em> 的环境变量。变量名的改变会影响由 <code>os.system()</code>，<code>popen()</code>，<code>fork()</code> 和 <code>execv()</code> 触发的子进程。</p>
<p>删除在 <code>os.environ</code> 中的变量会自动转换为对 <code>unsetenv()</code> 的调用。但是 <code>unsetenv()</code> 不能更新 <code>os.environ</code>，因此最好直接删除 <code>os.environ</code> 中的变量。</p>
<p>引发一个 审计事件 <code>os.unsetenv</code>，附带参数 <code>key</code>。</p>
<p>在 3.9 版更改: 该函数现在总是可用，并且在 Windows 上也可用。</p>
<h3 id="创建文件对象"><a href="#创建文件对象" class="headerlink" title="创建文件对象"></a>创建文件对象</h3><p>这些函数创建新的 file objects 。</p>
<p><code>os.fdopen</code>(<em>fd</em>, <em>\</em>args<em>,</em> <em>*kwargs</em>)</p>
<p>返回打开文件描述符 <em>fd</em> 对应文件的对象。类似内建 <code>open()</code> 函数，二者接受同样的参数。不同之处在于 <code>fdopen()</code> 第一个参数应该为整数。</p>
<h3 id="文件描述符操作"><a href="#文件描述符操作" class="headerlink" title="文件描述符操作"></a>文件描述符操作</h3><p>这些函数对文件描述符所引用的 I/O 流进行操作。</p>
<p>文件描述符是一些小的整数，对应于当前进程所打开的文件。例如，标准输入的文件描述符通常是0，标准输出是1，标准错误是2。之后被进程打开的文件的文件描述符会被依次指定为3，4，5等。“文件描述符”这个词有点误导性，在 Unix 平台中套接字和管道也被文件描述符所引用。</p>
<p>当需要时，可以用 <code>fileno()</code> 可以获得 file object 所对应的文件描述符。需要注意的是，直接使用文件描述符会绕过文件对象的方法，会忽略如数据内部缓冲等情况。</p>
<p><code>os.close</code>(<em>fd</em>)</p>
<p>关闭文件描述符 <em>fd</em>。</p>
<p>注解</p>
<p>该功能适用于低级 I/O 操作，必须用于 <code>os.open()</code> 或 <code>pipe()</code> 返回的文件描述符。若要关闭由内建函数 <code>open()</code>、<code>popen()</code> 或 <code>fdopen()</code> 返回的 “文件对象”，则应使用其相应的 <code>close()</code> 方法。</p>
<p><code>os.closerange</code>(<em>fd_low</em>, <em>fd_high</em>)</p>
<p>关闭从 <em>fd_low</em> （包括）到 <em>fd_high</em> （排除）间的文件描述符，并忽略错误。类似（但快于）:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">for</span> fd <span class="token keyword">in</span> range<span class="token punctuation">(</span>fd_low<span class="token punctuation">,</span> fd_high<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">try</span><span class="token punctuation">:</span>
        os<span class="token punctuation">.</span>close<span class="token punctuation">(</span>fd<span class="token punctuation">)</span>
    <span class="token keyword">except</span> OSError<span class="token punctuation">:</span>
        <span class="token keyword">pass</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>os.copy_file_range</code>(<em>src</em>, <em>dst</em>, <em>count</em>, <em>offset_src=None</em>, <em>offset_dst=None</em>)</p>
<p>从文件描述符 <em>src</em> 复制 <em>count</em> 字节，从偏移量 <em>offset_src</em> 开始读取，到文件描述符 <em>dst*，从偏移量 *offset_dst</em> 开始写入。如果 <em>offset_src</em> 为 None，则 <em>src</em> 将从当前位置开始读取；<em>offset_dst</em> 同理。<em>src</em> 和 <em>dst</em> 指向的文件必须处于相同的文件系统，否则将会抛出一个 <a href="https://www.bookstack.cn/read/python-3.10.0-zh/177bd954d1cc6696.md#OSError.errno" target="_blank" rel="noopener"><code>errno</code></a> 被设为 <code>errno.EXDEV</code> 的 <code>OSError</code> 。</p>
<p>此复制的完成没有额外的从内核到用户空间再回到内核的数据转移花费。另外，一些文件系统可能实现额外的优化。完成复制就如同打开两个二进制文件一样。</p>
<p>返回值是复制的字节的数目。这可能低于需求的数目。</p>
<p>Availability: Linux kernel &gt;= 4.5 或 glibc &gt;= 2.27。</p>
<p>3.8 新版功能.</p>
<p><code>os.device_encoding</code>(<em>fd</em>)</p>
<p>如果连接到终端，则返回一个与 <em>fd</em> 关联的设备描述字符，否则返回 <code>None</code>。</p>
<p>在 Unix 上，如果启用了 Python UTF-8 模式，则返回 <code>'UTF-8'</code> 而不是设备的编码格式。</p>
<p>在 3.10 版更改: 在 Unix 上，该函数现在实现了 Python UTF-8 模式。</p>
<p><code>os.dup</code>(<em>fd</em>)</p>
<p>返回一个文件描述符 <em>fd</em> 的副本。该文件描述符的副本是 不可继承的。</p>
<p>在 Windows 中，当复制一个标准流（0: stdin, 1: stdout, 2: stderr）时，新的文件描述符是 可继承的。</p>
<p>在 3.4 版更改: 新的文件描述符现在是不可继承的。</p>
<p><code>os.dup2</code>(<em>fd</em>, <em>fd2</em>, <em>inheritable=True</em>)</p>
<p>把文件描述符 <em>fd</em> 复制为 <em>fd2<em>，必要时先关闭后者。返回 *fd2</em>。新的文件描述符默认是 可继承的，除非在 *inheritable</em> 为 <code>False</code> 时，是不可继承的。</p>
<p>在 3.4 版更改: 添加可选参数 <em>inheritable</em>。</p>
<p>在 3.7 版更改: 成功时返回 <em>fd2</em>，以过去的版本中，总是返回 <code>None</code>。</p>
<p><code>os.fchmod</code>(<em>fd</em>, <em>mode</em>)</p>
<p>将 <em>fd</em> 指定文件的权限状态修改为 <em>mode*。可以参考 <code>chmod()</code> 中列出 *mode</em> 的可用值。从Python 3.3开始，这相当于 <code>os.chmod(fd, mode)</code>。</p>
<p>引发一个 审计事件 <code>os.chmod</code>，附带参数 <code>path</code>、<code>mode</code>、<code>dir_fd</code>。</p>
<p>可用性: Unix。</p>
<p><code>os.fchown</code>(<em>fd</em>, <em>uid</em>, <em>gid</em>)</p>
<p>分别将 <em>fd</em> 指定文件的所有者和组 ID 修改为 <em>uid</em> 和 <em>gid</em> 的值。若不想变更其中的某个 ID，可将相应值设为 -1。从 Python 3.3 开始，这相当于 <code>os.chown(fd, uid, gid)</code>。</p>
<p>引发一个 审计事件 <code>os.chown</code>，附带参数 <code>path</code>、<code>uid</code>、<code>gid</code>、<code>dir_fd</code>。</p>
<p>可用性: Unix。</p>
<p><code>os.fdatasync</code>(<em>fd</em>)</p>
<p>强制将文件描述符 <em>fd</em> 指定文件写入磁盘。不强制更新元数据。</p>
<p>可用性: Unix。</p>
<p>注解</p>
<p>该功能在 MacOS 中不可用。</p>
<p><code>os.fpathconf</code>(<em>fd</em>, <em>name</em>)</p>
<p>返回与打开的文件有关的系统配置信息。<em>name</em> 指定要查找的配置名称，它可以是字符串，是一个系统已定义的名称，这些名称定义在不同标准（POSIX.1，Unix 95，Unix 98 等）中。一些平台还定义了额外的其他名称。当前操作系统已定义的名称在 <code>pathconf_names</code> 字典中给出。对于未包含在该映射中的配置名称，也可以传递一个整数作为 <em>name</em>。</p>
<p>如果 <em>name</em> 是一个字符串且不是已定义的名称，将抛出 <code>ValueError</code> 异常。如果当前系统不支持 <em>name</em> 指定的配置名称，即使该名称存在于 <code>pathconf_names</code>，也会抛出 <code>OSError</code> 异常，错误码为 <code>errno.EINVAL</code>。</p>
<p>从 Python 3.3 起，此功能等价于 <code>os.pathconf(fd, name)</code>。</p>
<p>可用性: Unix。</p>
<p><code>os.fstat</code>(<em>fd</em>)</p>
<p>获取文件描述符 <em>fd</em> 的状态. 返回一个 <code>stat_result</code> 对象。</p>
<p>从 Python 3.3 起，此功能等价于 <code>os.stat(fd)</code>。</p>
<p>参见</p>
<p><code>stat()</code> 函数。</p>
<p><code>os.fstatvfs</code>(<em>fd</em>)</p>
<p>返回文件系统的信息，该文件系统是文件描述符 <em>fd</em> 指向的文件所在的文件系统，与 <code>statvfs()</code> 一样。从 Python 3.3 开始，它等效于 <code>os.statvfs(fd)</code>。</p>
<p>可用性: Unix。</p>
<p><code>os.fsync</code>(<em>fd</em>)</p>
<p>强制将文件描述符 <em>fd</em> 指向的文件写入磁盘。在 Unix，这将调用原生 <code>fsync()</code> 函数；在 Windows，则是 MS <code>_commit()</code> 函数。</p>
<p>如果要写入的是缓冲区内的 Python 文件对象 <em>f</em>，请先执行 <code>f.flush()</code>，然后执行 <code>os.fsync(f.fileno())</code>，以确保与 <em>f</em> 关联的所有内部缓冲区都写入磁盘。</p>
<p>可用性: Unix, Windows。</p>
<p><code>os.ftruncate</code>(<em>fd</em>, <em>length</em>)</p>
<p>截断文件描述符 <em>fd</em> 指向的文件，以使其最大为 <em>length</em> 字节。从 Python 3.3 开始，它等效于 <code>os.truncate(fd, length)</code>。</p>
<p>引发一个 审计事件 <code>os.truncate</code>，附带参数 <code>fd</code>, <code>length</code>。</p>
<p>可用性: Unix, Windows。</p>
<p>在 3.5 版更改: 添加了 Windows 支持</p>
<p><code>os.get_blocking</code>(<em>fd</em>)</p>
<p>获取文件描述符的阻塞模式：如果设置了 <code>O_NONBLOCK</code> 标志位，返回 <code>False</code>，如果该标志位被清除，返回 <code>True</code>。</p>
<p>参见 <code>set_blocking()</code> 和 <code>socket.socket.setblocking()</code>。</p>
<p>可用性: Unix。</p>
<p>3.5 新版功能.</p>
<p><code>os.isatty</code>(<em>fd</em>)</p>
<p>如果文件描述符 <em>fd</em> 打开且已连接至 tty 设备（或类 tty 设备），返回 <code>True</code>，否则返回 <code>False</code>。</p>
<p><code>os.lockf</code>(<em>fd</em>, <em>cmd</em>, <em>len</em>)</p>
<p>在打开的文件描述符上，使用、测试或删除 POSIX 锁。<em>fd</em> 是一个打开的文件描述符。<em>cmd</em> 指定要进行的操作，它们是 <code>F_LOCK</code>、<code>F_TLOCK</code>、<code>F_ULOCK</code> 或 <code>F_TEST</code> 中的一个。<em>len</em> 指定哪部分文件需要锁定。</p>
<p>引发一个 审计事件 <code>os.lockf</code>，附带参数 <code>fd</code>、<code>cmd</code>、<code>len</code>。</p>
<p>可用性: Unix。</p>
<p>3.3 新版功能.</p>
<pre><code>os.F_LOCK
os.F_TLOCK
os.F_ULOCK
os.F_TEST</code></pre><p>标志位，用于指定 <code>lockf()</code> 进行哪一种操作。</p>
<p>可用性: Unix。</p>
<p>3.3 新版功能.</p>
<p><code>os.lseek</code>(<em>fd</em>, <em>pos</em>, <em>how</em>)</p>
<p>将文件描述符 <em>fd</em> 的当前位置设置为 <em>pos*，位置的计算方式 *how</em> 如下：设置为 <code>SEEK_SET</code> 或 <code>0</code> 表示从文件开头计算，设置为 <code>SEEK_CUR</code> 或 <code>1</code> 表示从文件当前位置计算，设置为 <code>SEEK_END</code> 或 <code>2</code> 表示文件末尾计算。返回新指针位置，这个位置是从文件开头计算的，单位是字节。</p>
<pre><code>os.SEEK_SET
os.SEEK_CUR
os.SEEK_END</code></pre><p><code>lseek()</code> 函数的参数，它们的值分别为 0、1 和 2。</p>
<p>3.3 新版功能: 某些操作系统可能支持其他值，例如 <code>os.SEEK_HOLE</code> 或 <code>os.SEEK_DATA</code>。</p>
<p><code>os.open</code>(<em>path</em>, <em>flags</em>, <em>mode=511</em>, <em>**,</em> dir_fd=None*)</p>
<p>打开文件 <em>path*，根据 *flags</em> 设置各种标志位，并根据 <em>mode</em> 设置其权限状态。当计算 <em>mode</em> 时，会首先根据当前 umask 值将部分权限去除。本方法返回新文件的描述符。新的文件描述符是 不可继承 的。</p>
<p>有关 flag 和 mode 取值的说明，请参见 C 运行时文档。标志位常量（如 <code>O_RDONLY</code> 和 <code>O_WRONLY</code>）在 <code>os</code> 模块中定义。特别地，在 Windows 上需要添加 <code>O_BINARY</code> 才能以二进制模式打开文件。</p>
<p>本函数带有 <em>dir_fd</em> 参数，支持 基于目录描述符的相对路径。</p>
<p><code>open</code> 附带参数 <code>path</code>、<code>mode</code>、<code>flags</code> 会引发 审计事件。</p>
<p>在 3.4 版更改: 新的文件描述符现在是不可继承的。</p>
<p>注解</p>
<p>本函数适用于底层的 I/O。常规用途请使用内置函数 <code>open()</code>，该函数的 <code>read()</code> 和 <code>write()</code> 方法（及其他方法）会返回 文件对象。要将文件描述符包装在文件对象中，请使用 <code>fdopen()</code>。</p>
<p>3.3 新版功能: <em>dir_fd</em> 参数。</p>
<p>在 3.5 版更改: 如果系统调用被中断，但信号处理程序没有触发异常，此函数现在会重试系统调用，而不是触发 <code>InterruptedError</code> 异常 (原因详见 <a href="https://www.python.org/dev/peps/pep-0475" target="_blank" rel="noopener"><strong>PEP 475</strong></a>)。</p>
<p>在 3.6 版更改: 接受一个 path-like object。</p>
<p>以下常量是 <code>open()</code> 函数 <em>flags</em> 参数的选项。可以用按位或运算符 <code>|</code> 将它们组合使用。部分常量并非在所有平台上都可用。有关其可用性和用法的说明或 MSDN （Windows 上）。</p>
<pre><code>os.O_RDONLY
os.O_WRONLY
os.O_RDWR
os.O_APPEND
os.O_CREAT
os.O_EXCL
os.O_TRUNC</code></pre><p>上述常量在 Unix 和 Windows 上均可用。</p>
<pre><code>os.O_DSYNC
os.O_RSYNC
os.O_SYNC
os.O_NDELAY
os.O_NONBLOCK
os.O_NOCTTY
os.O_CLOEXEC</code></pre><p>这个常数仅在 Unix 系统中可用。</p>
<p>在 3.3 版更改: 增加 <code>O_CLOEXEC</code> 常量。</p>
<pre><code>os.O_BINARY
os.O_NOINHERIT
os.O_SHORT_LIVED
os.O_TEMPORARY
os.O_RANDOM
os.O_SEQUENTIAL
os.O_TEXT</code></pre><p>这个常数仅在 Windows 系统中可用。</p>
<pre><code>os.O_EVTONLY
os.O_FSYNC
os.O_SYMLINK
os.O_NOFOLLOW_ANY</code></pre><p>以上常量仅适用于 macOS。</p>
<p>在 3.10 版更改: 加入 <code>O_EVTONLY</code> 、 <code>O_FSYNC</code> 、 <code>O_SYMLINK</code> 和 <code>O_NOFOLLOW_ANY</code> 常量。</p>
<pre><code>os.O_ASYNC
os.O_DIRECT
os.O_DIRECTORY
os.O_NOFOLLOW
os.O_NOATIME
os.O_PATH
os.O_TMPFILE
os.O_SHLOCK
os.O_EXLOCK</code></pre><p>上述常量是扩展常量，如果 C 库未定义它们，则不存在。</p>
<p>在 3.4 版更改: 在支持的系统上增加 <code>O_PATH</code>。增加 <code>O_TMPFILE</code>，仅在 Linux Kernel 3.11 或更高版本可用。</p>
<p><code>os.openpty</code>()</p>
<p>打开一对新的伪终端，返回一对文件描述符 <code>（主，从）</code>，分别为 pty 和 tty。新的文件描述符是 不可继承 的。对于（稍微）轻量一些的方法，请使用 <code>pty</code> 模块。</p>
<p>可用性: 某些 Unix。</p>
<p>在 3.4 版更改: 新的文件描述符不再可继承。</p>
<p><code>os.pipe</code>()</p>
<p>创建一个管道，返回一对分别用于读取和写入的文件描述符 <code>(r, w)</code>。新的文件描述符是 不可继承 的。</p>
<p>可用性: Unix, Windows。</p>
<p>在 3.4 版更改: 新的文件描述符不再可继承。</p>
<p><code>os.pipe2</code>(<em>flags</em>)</p>
<p>创建带有 <em>flags</em> 标志位的管道。可通过对以下一个或多个值进行“或”运算来构造这些 <em>flags</em>：<code>O_NONBLOCK</code>、<code>O_CLOEXEC</code>。返回一对分别用于读取和写入的文件描述符 <code>(r, w)</code>。</p>
<p>可用性: 某些 Unix。</p>
<p>3.3 新版功能.</p>
<p><code>os.posix_fallocate</code>(<em>fd</em>, <em>offset</em>, <em>len</em>)</p>
<p>确保为 <em>fd</em> 指向的文件分配了足够的磁盘空间，该空间从偏移量 <em>offset</em> 开始，到 <em>len</em> 字节为止。</p>
<p>可用性: Unix。</p>
<p>3.3 新版功能.</p>
<p><code>os.posix_fadvise</code>(<em>fd</em>, <em>offset</em>, <em>len</em>, <em>advice</em>)</p>
<p>声明即将以特定模式访问数据，使内核可以提前进行优化。数据范围是从 <em>fd</em> 所指向文件的 <em>offset</em> 开始，持续 <em>len</em> 个字节。<em>advice</em> 的取值是如下之一：<code>POSIX_FADV_NORMAL</code>, <code>POSIX_FADV_SEQUENTIAL</code>, <code>POSIX_FADV_RANDOM</code>, <code>POSIX_FADV_NOREUSE</code>, <code>POSIX_FADV_WILLNEED</code> 或 <code>POSIX_FADV_DONTNEED</code>。</p>
<p>可用性: Unix。</p>
<p>3.3 新版功能.</p>
<pre><code>os.POSIX_FADV_NORMAL
os.POSIX_FADV_SEQUENTIAL
os.POSIX_FADV_RANDOM
os.POSIX_FADV_NOREUSE
os.POSIX_FADV_WILLNEED
os.POSIX_FADV_DONTNEED</code></pre><p>用于 <code>posix_fadvise()</code> 的 <em>advice</em> 参数的标志位，指定可能使用的访问模式。</p>
<p>可用性: Unix。</p>
<p>3.3 新版功能.</p>
<p><code>os.pread</code>(<em>fd</em>, <em>n</em>, <em>offset</em>)</p>
<p>从文件描述符 <em>fd</em> 所指向文件的偏移位置 <em>offset</em> 开始，读取至多 <em>n</em> 个字节，而保持文件偏移量不变。</p>
<p>返回所读取字节的字节串 (bytestring)。如果到达了 <em>fd</em> 指向的文件末尾，则返回空字节对象。</p>
<p>可用性: Unix。</p>
<p>3.3 新版功能.</p>
<p><code>os.preadv</code>(<em>fd</em>, <em>buffers</em>, <em>offset</em>, <em>flags=0</em>)</p>
<p>从文件描述符 <em>fd</em> 所指向文件的偏移位置 <em>offset</em> 开始，将数据读取至可变 字节类对象 缓冲区 <em>buffers</em> 中，保持文件偏移量不变。将数据依次存放到每个缓冲区中，填满一个后继续存放到序列中的下一个缓冲区，来保存其余数据。</p>
<p>flags 参数可以由零个或多个标志位进行按位或运算来得到：</p>
<ul>
<li><code>RWF_HIPRI</code></li>
<li><code>RWF_NOWAIT</code></li>
</ul>
<p>返回实际读取的字节总数，该总数可以小于所有对象的总容量。</p>
<p>操作系统可能对允许使用的缓冲区数量有限制（使用 <code>sysconf()</code> 获取 <code>'SC_IOV_MAX'</code> 值）。</p>
<p>本方法结合了 <code>os.readv()</code> 和 <code>os.pread()</code> 的功能。</p>
<p>可用性：Linux 2.6.30 或更高版本，FreeBSD 6.0 或更高版本，OpenBSD 2.7 或更高版本，AIX 7.1 或更高版本。使用标志位需要 Linux 4.6 或更高版本。</p>
<p>3.7 新版功能.</p>
<pre><code>os.RWF_NOWAIT</code></pre><p>不要等待无法立即获得的数据。如果指定了此标志，那么当需要从后备存储器中读取数据，或等待文件锁时，系统调用将立即返回。</p>
<p>如果成功读取数据，则返回读取的字节数。如果未读取到数据，则返回 <code>-1</code>，并将错误码 errno 置为 <code>errno.EAGAIN</code>。</p>
<p>可用性：Linux 4.14 或更高版本。</p>
<p>3.7 新版功能.</p>
<pre><code>os.RWF_HIPRI</code></pre><p>高优先级读/写。允许基于块的文件系统对设备进行轮询，这样可以降低延迟，但可能会占用更多资源。</p>
<p>目前在 Linux 上，此功能仅在使用 <code>O_DIRECT</code> 标志打开的文件描述符上可用。</p>
<p>可用性：Linux 4.6 或更高版本。</p>
<p>3.7 新版功能.</p>
<p><code>os.pwrite</code>(<em>fd</em>, <em>str</em>, <em>offset</em>)</p>
<p>将 <em>str</em> 中的字节串 (bytestring) 写入文件描述符 <em>fd</em> 的偏移位置 <em>offset</em> 处，保持文件偏移量不变。</p>
<p>返回实际写入的字节数。</p>
<p>可用性: Unix。</p>
<p>3.3 新版功能.</p>
<p><code>os.pwritev</code>(<em>fd</em>, <em>buffers</em>, <em>offset</em>, <em>flags=0</em>)</p>
<p>将缓冲区 <em>buffers</em> 的内容写入文件描述符 <em>fd</em> 的偏移位置 <em>offset</em> 处，保持文件偏移量不变。缓冲区 <em>buffers</em> 必须是由 字节类对象 组成的序列。缓冲区以数组顺序处理。先写入第一个缓冲区的全部内容，再写入第二个缓冲区，照此继续。</p>
<p>flags 参数可以由零个或多个标志位进行按位或运算来得到：</p>
<ul>
<li><code>RWF_DSYNC</code></li>
<li><code>RWF_SYNC</code></li>
<li><code>RWF_APPEND</code></li>
</ul>
<p>返回实际写入的字节总数。</p>
<p>操作系统可能对允许使用的缓冲区数量有限制（使用 <code>sysconf()</code> 获取 <code>'SC_IOV_MAX'</code> 值）。</p>
<p>本方法结合了 <code>os.writev()</code> 和 <code>os.pwrite()</code> 的功能。</p>
<p>可用性：Linux 2.6.30 或更高版本，FreeBSD 6.0 或更高版本，OpenBSD 2.7 或更高版本，AIX 7.1 或更高版本。使用标志位需要 Linux 4.7 或更高版本。</p>
<p>3.7 新版功能.</p>
<pre><code>os.RWF_DSYNC</code></pre><p>提供预写功能，等效于带 <code>O_DSYNC</code> 标志的 <code>os.open()</code> 。本标志只作用于通过系统调用写入的数据。</p>
<p>可用性：Linux 4.7 或更高版本。</p>
<p>3.7 新版功能.</p>
<pre><code>os.RWF_SYNC</code></pre><p>提供预写功能，等效于带 <code>O_SYNC</code> 标志的 <code>os.open()</code> 。本标志只作用于通过系统调用写入的数据。</p>
<p>可用性：Linux 4.7 或更高版本。</p>
<p>3.7 新版功能.</p>
<pre><code>os.RWF_APPEND</code></pre><p>提供预写功能，等效于带 <code>O_APPEND</code> 标志的 <code>os.open()</code> 。本标志只对 <code>os.pwritev()</code> 有意义，只作用于通过系统调用写入的数据。参数 <em>offset</em> 对写入操作无效；数据总是会添加到文件的末尾。但如果 <em>offset</em> 参数为 <code>-1</code>，则会刷新当前文件的 <em>offset</em> 。</p>
<p>可用性：Linux 4.16 以上版本。</p>
<p>3.10 新版功能.</p>
<p><code>os.read</code>(<em>fd</em>, <em>n</em>)</p>
<p>从文件描述符 <em>fd</em> 中读取至多 <em>n</em> 个字节。</p>
<p>返回所读取字节的字节串 (bytestring)。如果到达了 <em>fd</em> 指向的文件末尾，则返回空字节对象。</p>
<p>注解</p>
<p>该功能适用于低级 I/O 操作，必须用于 <code>os.open()</code> 或 <code>pipe()</code> 返回的文件描述符。若要读取由内建函数 <code>open()</code>、<code>popen()</code>、<code>fdopen()</code> 或 <code>sys.stdin</code> 返回的 “文件对象”，则应使用其相应的 <code>read()</code> 或 <code>readline()</code> 方法。</p>
<p>在 3.5 版更改: 如果系统调用被中断，但信号处理程序没有触发异常，此函数现在会重试系统调用，而不是触发 <code>InterruptedError</code> 异常 (原因详见 <a href="https://www.python.org/dev/peps/pep-0475" target="_blank" rel="noopener"><strong>PEP 475</strong></a>)。</p>
<p><code>os.sendfile</code>(<em>out_fd</em>, <em>in_fd</em>, <em>offset</em>, <em>count</em>)</p>
<p><code>os.sendfile</code>(<em>out_fd</em>, <em>in_fd</em>, <em>offset</em>, <em>count</em>, <em>headers=()</em>, <em>trailers=()</em>, <em>flags=0</em>)</p>
<p>将文件描述符 <em>in_fd</em> 中的 <em>count</em> 字节复制到文件描述符 <em>out_fd</em> 的偏移位置 <em>offset</em> 处。返回复制的字节数，如果到达 EOF，返回 <code>0</code>。</p>
<p>定义了 <code>sendfile()</code> 的所有平台均支持第一种函数用法。</p>
<p>在 Linux 上，将 <em>offset</em> 设置为 <code>None</code>，则从 <em>in_fd</em> 的当前位置开始读取，并更新 <em>in_fd</em> 的位置。</p>
<p>第二种情况可以被用于 macOS 和 FreeBSD，其中 <em>headers</em> 和 <em>trailers</em> 是任意的缓冲区序列，它们会在写入来自 <em>in_fd</em> 的数据之前被写入。 它的返回内容与第一种情况相同。</p>
<p>在 macOS 和 FreeBSD 上，传入 <code>0</code> 值作为 <em>count</em> 将指定持续发送直至到达 <em>in_fd</em> 的末尾。</p>
<p>所有平台都支持将套接字作为 <em>out_fd</em> 文件描述符，有些平台也支持其他类型（如常规文件或管道）。</p>
<p>跨平台应用程序不应使用 <em>headers<em>、</em>trailers</em> 和 <em>flags</em> 参数。</p>
<p>可用性: Unix。</p>
<p>注解</p>
<p>有关 <code>sendfile()</code> 的高级封装。</p>
<p>3.3 新版功能.</p>
<p>在 3.9 版更改: <em>out</em> 和 <em>in</em> 参数被重命名为 <em>out_fd</em> 和 <em>in_fd</em>。</p>
<p><code>os.set_blocking</code>(<em>fd</em>, <em>blocking</em>)</p>
<p>设置指定文件描述符的阻塞模式：如果 blocking 为 <code>False</code>，则为该描述符设置 <code>O_NONBLOCK</code> 标志位，反之则清除该标志位。</p>
<p>参见 <code>get_blocking()</code> 和 <code>socket.socket.setblocking()</code>。</p>
<p>可用性: Unix。</p>
<p>3.5 新版功能.</p>
<pre><code>os.SF_NODISKIO
os.SF_MNOWAIT
os.SF_SYNC</code></pre><p><code>sendfile()</code> 函数的参数（假设当前实现支持这些参数）。</p>
<p>可用性: Unix。</p>
<p>3.3 新版功能.</p>
<p><code>os.splice</code>(<em>src</em>, <em>dst</em>, <em>count</em>, <em>offset_src=None</em>, <em>offset_dst=None</em>)</p>
<p>由文件描述符 <em>src</em> 传输 <em>count</em> 字节，从偏移量 <em>offset_src</em> 开始读取，到文件描述符 <em>dst*，从偏移量 *offset_dst</em> 开始写入。至少得有一个文件描述符必须指向管道。如果 <em>offset_src</em> 为 None，则 <em>src</em> 将从当前位置开始读取；<em>offset_dst</em> 同理。指向管道的文件描述符，其偏移量必须为 <code>None</code>。 <em>src</em> 和 <em>dst</em> 指向的文件必须处于同一文件系统中，否则将会触发 <code>OSError</code> ，其 <code>errno</code> 将被设为 <code>errno.EXDEV</code> 。</p>
<p>此复制的完成没有额外的从内核到用户空间再回到内核的数据转移花费。另外，一些文件系统可能实现额外的优化。完成复制就如同打开两个二进制文件一样。</p>
<p>调用成功后，返回拼接到管道的字节数或从管道拼接出来的字节数。返回值为 0 意味着输入结束。如果 <em>src</em> 指向一个管道，则意味着没有数据需要传输，而且由于没有写入程序连到管道的写入端，所以将不会阻塞。</p>
<p>可用性： Linux &gt;= 2.6.27 且 glibc &gt;= 2.5。</p>
<p>3.10 新版功能.</p>
<pre><code>os.SPLICE_F_MOVE
os.SPLICE_F_NONBLOCK
os.SPLICE_F_MORE</code></pre><p>3.10 新版功能.</p>
<p><code>os.readv</code>(<em>fd</em>, <em>buffers</em>)</p>
<p>从文件描述符 <em>fd</em> 将数据读取至多个可变的 字节类对象 缓冲区 <em>buffers</em> 中。将数据依次存放到每个缓冲区中，填满一个后继续存放到序列中的下一个缓冲区，来保存其余数据。</p>
<p>返回实际读取的字节总数，该总数可以小于所有对象的总容量。</p>
<p>操作系统可能对允许使用的缓冲区数量有限制（使用 <code>sysconf()</code> 获取 <code>'SC_IOV_MAX'</code> 值）。</p>
<p>可用性: Unix。</p>
<p>3.3 新版功能.</p>
<p><code>os.tcgetpgrp</code>(<em>fd</em>)</p>
<p>返回与 <em>fd</em> 指定的终端相关联的进程组（<em>fd</em> 是由 <code>os.open()</code> 返回的已打开的文件描述符）。</p>
<p>可用性: Unix。</p>
<p><code>os.tcsetpgrp</code>(<em>fd</em>, <em>pg</em>)</p>
<p>设置与 <em>fd</em> 指定的终端相关联的进程组为 <em>pg*（*fd</em> 是由 <code>os.open()</code> 返回的已打开的文件描述符）。</p>
<p>可用性: Unix。</p>
<p><code>os.ttyname</code>(<em>fd</em>)</p>
<p>返回一个字符串，该字符串表示与文件描述符 <em>fd</em> 关联的终端。如果 <em>fd</em> 没有与终端关联，则抛出异常。</p>
<p>可用性: Unix。</p>
<p><code>os.write</code>(<em>fd</em>, <em>str</em>)</p>
<p>将 <em>str</em> 中的字节串 (bytestring) 写入文件描述符 <em>fd</em>。</p>
<p>返回实际写入的字节数。</p>
<p>注解</p>
<p>该功能适用于低级 I/O 操作，必须用于 <code>os.open()</code> 或 <code>pipe()</code> 返回的文件描述符。若要写入由内建函数 <code>open()</code>、<code>popen()</code>、<code>fdopen()</code>、<code>sys.stdout</code> 或 <code>sys.stderr</code> 返回的 “文件对象”，则应使用其相应的 <code>write()</code> 方法。</p>
<p>在 3.5 版更改: 如果系统调用被中断，但信号处理程序没有触发异常，此函数现在会重试系统调用，而不是触发 <code>InterruptedError</code> 异常 (原因详见 <a href="https://www.python.org/dev/peps/pep-0475" target="_blank" rel="noopener"><strong>PEP 475</strong></a>)。</p>
<p><code>os.writev</code>(<em>fd</em>, <em>buffers</em>)</p>
<p>将缓冲区 <em>buffers</em> 的内容写入文件描述符 <em>fd*。缓冲区 *buffers</em> 必须是由 字节类对象 组成的序列。缓冲区以数组顺序处理。先写入第一个缓冲区的全部内容，再写入第二个缓冲区，照此继续。</p>
<p>返回实际写入的字节总数。</p>
<p>操作系统可能对允许使用的缓冲区数量有限制（使用 <code>sysconf()</code> 获取 <code>'SC_IOV_MAX'</code> 值）。</p>
<p>可用性: Unix。</p>
<p>3.3 新版功能.</p>
<h4 id="查询终端的尺寸"><a href="#查询终端的尺寸" class="headerlink" title="查询终端的尺寸"></a>查询终端的尺寸</h4><p>3.3 新版功能.</p>
<p><code>os.get_terminal_size</code>(<em>fd=STDOUT_FILENO</em>)</p>
<p>返回终端窗口的尺寸，格式为 <code>(columns, lines)</code>，它是类型为 <code>terminal_size</code> 的元组。</p>
<p>可选参数 <code>fd</code> （默认为 <code>STDOUT_FILENO</code> 或标准输出）指定应查询的文件描述符。</p>
<p>如果文件描述符未连接到终端，则抛出 <code>OSError</code> 异常。</p>
<p><code>shutil.get_terminal_size()</code> 是供常规使用的高阶函数，<code>os.get_terminal_size</code> 是其底层的实现。</p>
<p>可用性: Unix, Windows。</p>
<p><em>class</em> <code>os.terminal_size</code></p>
<p>元组的子类，存储终端窗口尺寸 <code>(columns, lines)</code>。</p>
<ul>
<li><p><code>columns</code></p>
<p>终端窗口的宽度，单位为字符。</p>
</li>
<li><p><code>lines</code></p>
<p>终端窗口的高度，单位为字符。</p>
</li>
</ul>
<h4 id="文件描述符的继承"><a href="#文件描述符的继承" class="headerlink" title="文件描述符的继承"></a>文件描述符的继承</h4><p>3.4 新版功能.</p>
<p>每个文件描述符都有一个 “inheritable”（可继承）标志位，该标志位控制了文件描述符是否可以由子进程继承。从 Python 3.4 开始，由 Python 创建的文件描述符默认是不可继承的。</p>
<p>在 UNIX 上，执行新程序时，不可继承的文件描述符在子进程中是关闭的，其他文件描述符将被继承。</p>
<p>在 Windows 上，不可继承的句柄和文件描述符在子进程中是关闭的，但标准流（文件描述符 0、1 和 2 即标准输入、标准输出和标准错误）是始终继承的。如果使用 <code>spawn*</code> 函数，所有可继承的句柄和文件描述符都将被继承。如果使用 <code>subprocess</code> 模块，将关闭除标准流以外的所有文件描述符，并且仅当 <em>close_fds</em> 参数为 <code>False</code> 时才继承可继承的句柄。</p>
<p><code>os.get_inheritable</code>(<em>fd</em>)</p>
<p>获取指定文件描述符的“可继承”标志位（为布尔值）。</p>
<p><code>os.set_inheritable</code>(<em>fd</em>, <em>inheritable</em>)</p>
<p>设置指定文件描述符的“可继承”标志位。</p>
<p><code>os.get_handle_inheritable</code>(<em>handle</em>)</p>
<p>获取指定句柄的“可继承”标志位（为布尔值）。</p>
<p>可用性: Windows。</p>
<p><code>os.set_handle_inheritable</code>(<em>handle</em>, <em>inheritable</em>)</p>
<p>设置指定句柄的“可继承”标志位。</p>
<p>可用性: Windows。</p>
<h3 id="文件和目录"><a href="#文件和目录" class="headerlink" title="文件和目录"></a>文件和目录</h3><p>在某些 Unix 平台上，许多函数支持以下一项或多项功能：</p>
<ul>
<li><p><strong>指定文件描述符为参数：</strong> 通常在 <code>os</code> 模块中提供给函数的 <em>path</em> 参数必须是表示文件路径的字符串，但是，某些函数现在可以接受其 <em>path</em> 参数为打开文件描述符，该函数将对描述符指向的文件进行操作。（对于 POSIX 系统，Python 将调用以 <code>f</code> 开头的函数变体（如调用 <code>fchdir</code> 而不是 <code>chdir</code>）。）</p>
<p>可以用 <code>os.supports_fd</code> 检查某个函数在你的平台上是否支持将 <em>path</em> 参数指定为文件描述符。如果不支持，使用该功能将抛出 <code>NotImplementedError</code> 异常。</p>
<p>如果该函数还支持 <em>dir_fd</em> 或 <em>follow_symlinks</em> 参数，那么用文件描述符作为 <em>path</em> 后就不能再指定上述参数了。</p>
</li>
<li><p><strong>基于目录描述符的相对路径：</strong> 如果 <em>dir_fd</em> 不是 <code>None</code>，它就应该是一个指向目录的文件描述符，这时待操作的 path 应该是相对路径，相对路径是相对于前述目录的。如果 path 是绝对路径，则 <em>dir_fd</em> 将被忽略。（对于 POSIX 系统，Python 将调用该函数的变体，变体以 <code>at</code> 结尾，可能以 <code>f</code> 开头（如调用 <code>faccessat</code> 而不是 <code>access</code>）。</p>
<p>可以用 <code>os.supports_dir_fd</code> 检查某个函数在你的平台上是否支持 <em>dir_fd</em>。如果不支持，使用该功能将抛出 <code>NotImplementedError</code> 异常。</p>
</li>
<li><p><strong>不跟踪符号链接：</strong> 如果 <em>follow_symlinks</em> 为 <code>False</code>，并且待操作路径的最后一个元素是符号链接，则该函数将在符号链接本身而不是链接所指向的文件上操作。（对于 POSIX 系统，Python 将调用该函数的 <code>l...</code> 变体。）</p>
<p>可以用 <code>os.supports_follow_symlinks</code> 检查某个函数在你的平台上是否支持 <em>follow_symlinks</em>。如果不支持，使用该功能将抛出 <code>NotImplementedError</code> 异常。</p>
</li>
</ul>
<p><code>os.access</code>(<em>path</em>, <em>mode</em>, <em>**,</em> dir_fd=None<em>,</em> effective_ids=False<em>,</em> follow_symlinks=True*)</p>
<p>使用 实际用户ID/用户组ID 测试对 <em>path</em> 的访问。请注意，大多数测试操作将使用 有效用户ID/用户组ID，因此可以在 suid/sgid 环境中运用此例程，来测试调用用户是否具有对 <em>path</em> 的指定访问权限。<em>mode</em> 为 <code>F_OK</code> 时用于测试 <em>path</em> 是否存在，也可以对 <code>R_OK</code>、<code>W_OK</code> 和 <code>X_OK</code> 中的一个或多个进行“或”运算来测试指定权限。允许访问则返回 <code>True</code>，否则返回 <code>False</code>。</p>
<p>本函数支持指定 基于目录描述符的相对路径 和 不跟踪符号链接。</p>
<p>如果 <em>effective_ids</em> 为 <code>True</code>，<code>access()</code> 将使用 有效用户ID/用户组ID 而非 实际用户ID/用户组ID 进行访问检查。您的平台可能不支持 <em>effective_ids</em>，您可以使用 <code>os.supports_effective_ids</code> 检查它是否可用。如果不可用，使用它时会抛出 <code>NotImplementedError</code> 异常。</p>
<p>注解</p>
<p>使用 <code>access()</code> 来检查用户是否具有某项权限（如打开文件的权限），然后再使用 <code>open()</code> 打开文件，这样做存在一个安全漏洞，因为用户可能会在检查和打开文件之间的时间里做其他操作。推荐使用 EAFP 技术。如:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">if</span> os<span class="token punctuation">.</span>access<span class="token punctuation">(</span><span class="token string">"myfile"</span><span class="token punctuation">,</span> os<span class="token punctuation">.</span>R_OK<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">with</span> open<span class="token punctuation">(</span><span class="token string">"myfile"</span><span class="token punctuation">)</span> <span class="token keyword">as</span> fp<span class="token punctuation">:</span>
        <span class="token keyword">return</span> fp<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">return</span> <span class="token string">"some default data"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>最好写成:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">try</span><span class="token punctuation">:</span>
    fp <span class="token operator">=</span> open<span class="token punctuation">(</span><span class="token string">"myfile"</span><span class="token punctuation">)</span>
<span class="token keyword">except</span> PermissionError<span class="token punctuation">:</span>
    <span class="token keyword">return</span> <span class="token string">"some default data"</span>
<span class="token keyword">else</span><span class="token punctuation">:</span>
    <span class="token keyword">with</span> fp<span class="token punctuation">:</span>
        <span class="token keyword">return</span> fp<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>注解</p>
<p>即使 <code>access()</code> 指示 I/O 操作会成功，但实际操作仍可能失败，尤其是对网络文件系统的操作，其权限语义可能超出常规的 POSIX 权限位模型。</p>
<p>在 3.3 版更改: 添加 <em>dir_fd<em>、</em>effective_ids</em> 和 <em>follow_symlinks</em> 参数。</p>
<p>在 3.6 版更改: 接受一个 path-like object。</p>
<pre><code>os.F_OK
os.R_OK
os.W_OK
os.X_OK</code></pre><p>作为 <code>access()</code> 的 <em>mode</em> 参数的可选值，分别测试 <em>path</em> 的存在性、可读性、可写性和可执行性。</p>
<p><code>os.chdir</code>(<em>path</em>)</p>
<p>将当前工作目录更改为 <em>path</em>。</p>
<p>本函数支持 指定文件描述符为参数。其中，描述符必须指向打开的目录，不能是打开的文件。</p>
<p>本函数可以抛出 <code>OSError</code> 及其子类的异常，如 <code>FileNotFoundError</code>、<code>PermissionError</code> 和 <code>NotADirectoryError</code> 异常。</p>
<p>引发一个 审计事件 <code>os.chdir</code>，附带参数 <code>path</code>。</p>
<p>3.3 新版功能: 在某些平台上新增支持将 <em>path</em> 参数指定为文件描述符。</p>
<p>在 3.6 版更改: 接受一个 path-like object。</p>
<p><code>os.chflags</code>(<em>path</em>, <em>flags</em>, <em>**,</em> follow_symlinks=True*)</p>
<p>将 <em>path</em> 的 flags 设置为其他由数字表示的 <em>flags<em>。</em>flags</em> 可以用以下值按位或组合起来（以下值在 <code>stat</code> 模块中定义）：</p>
<ul>
<li><code>stat.UF_NODUMP</code></li>
<li><code>stat.UF_IMMUTABLE</code></li>
<li><code>stat.UF_APPEND</code></li>
<li><code>stat.UF_OPAQUE</code></li>
<li><code>stat.UF_NOUNLINK</code></li>
<li><code>stat.UF_COMPRESSED</code></li>
<li><code>stat.UF_HIDDEN</code></li>
<li><code>stat.SF_ARCHIVED</code></li>
<li><code>stat.SF_IMMUTABLE</code></li>
<li><code>stat.SF_APPEND</code></li>
<li><code>stat.SF_NOUNLINK</code></li>
<li><code>stat.SF_SNAPSHOT</code></li>
</ul>
<p>本函数支持 不跟踪符号链接。</p>
<p>引发一个 审计事件 <code>os.chflags</code>，附带参数 <code>path</code>、<code>flags</code>。</p>
<p>可用性: Unix。</p>
<p>3.3 新版功能: <em>follow_symlinks</em> 参数。</p>
<p>在 3.6 版更改: 接受一个 path-like object。</p>
<p><code>os.chmod</code>(<em>path</em>, <em>mode</em>, <em>**,</em> dir_fd=None<em>,</em> follow_symlinks=True*)</p>
<p>将 <em>path</em> 的 mode 更改为其他由数字表示的 <em>mode<em>。</em>mode</em> 可以用以下值之一，也可以将它们按位或组合起来（以下值在 <code>stat</code> 模块中定义）：</p>
<ul>
<li><code>stat.S_ISUID</code></li>
<li><code>stat.S_ISGID</code></li>
<li><code>stat.S_ENFMT</code></li>
<li><code>stat.S_ISVTX</code></li>
<li><code>stat.S_IREAD</code></li>
<li><code>stat.S_IWRITE</code></li>
<li><code>stat.S_IEXEC</code></li>
<li><code>stat.S_IRWXU</code></li>
<li><code>stat.S_IRUSR</code></li>
<li><code>stat.S_IWUSR</code></li>
<li><code>stat.S_IXUSR</code></li>
<li><code>stat.S_IRWXG</code></li>
<li><code>stat.S_IRGRP</code></li>
<li><code>stat.S_IWGRP</code></li>
<li><code>stat.S_IXGRP</code></li>
<li><code>stat.S_IRWXO</code></li>
<li><code>stat.S_IROTH</code></li>
<li><code>stat.S_IWOTH</code></li>
<li><code>stat.S_IXOTH</code></li>
</ul>
<p>本函数支持 指定文件描述符、指定基于目录描述符的相对路径 和 不跟踪符号链接。</p>
<p>注解</p>
<p>尽管 Windows 支持 <code>chmod()</code>，但只能用它设置文件的只读标志（<code>stat.S_IWRITE</code> 和 <code>stat.S_IREAD</code> 常量或对应的整数值）。所有其他标志位都会被忽略。</p>
<p>引发一个 审计事件 <code>os.chmod</code>，附带参数 <code>path</code>、<code>mode</code>、<code>dir_fd</code>。</p>
<p>3.3 新版功能: 添加了指定 <em>path</em> 为文件描述符的支持，以及 <em>dir_fd</em> 和 <em>follow_symlinks</em> 参数。</p>
<p>在 3.6 版更改: 接受一个 path-like object。</p>
<p><code>os.chown</code>(<em>path</em>, <em>uid</em>, <em>gid</em>, <em>**,</em> dir_fd=None<em>,</em> follow_symlinks=True*)</p>
<p>将 <em>path</em> 的用户和组 ID 分别修改为数字形式的 <em>uid</em> 和 <em>gid</em>。若要使其中某个 ID 保持不变，请将其置为 -1。</p>
<p>本函数支持 指定文件描述符、指定基于目录描述符的相对路径 和 不跟踪符号链接。</p>
<p>参见更高阶的函数 <code>shutil.chown()</code>，除了数字 ID 之外，它也接受名称。</p>
<p>引发一个 审计事件 <code>os.chown</code>，附带参数 <code>path</code>、<code>uid</code>、<code>gid</code>、<code>dir_fd</code>。</p>
<p>可用性: Unix。</p>
<p>3.3 新版功能: 添加了指定 <em>path</em> 为文件描述符的支持，以及 <em>dir_fd</em> 和 <em>follow_symlinks</em> 参数。</p>
<p>在 3.6 版更改: 支持 类路径对象。</p>
<p><code>os.chroot</code>(<em>path</em>)</p>
<p>将当前进程的根目录更改为 <em>path</em>。</p>
<p>可用性: Unix。</p>
<p>在 3.6 版更改: 接受一个 path-like object。</p>
<p><code>os.fchdir</code>(<em>fd</em>)</p>
<p>将当前工作目录更改为文件描述符 <em>fd</em> 指向的目录。fd 必须指向打开的目录而非文件。从 Python 3.3 开始，它等效于 <code>os.chdir(fd)</code>。</p>
<p>引发一个 审计事件 <code>os.chdir</code>，附带参数 <code>path</code>。</p>
<p>可用性: Unix。</p>
<p><code>os.getcwd</code>()</p>
<p>返回表示当前工作目录的字符串。</p>
<p><code>os.getcwdb</code>()</p>
<p>返回表示当前工作目录的字节串 (bytestring)。</p>
<p>在 3.8 版更改: 在 Windows 上，本函数现在会使用 UTF-8 编码格式而不是 ANSI 代码页：请参看 <a href="https://www.python.org/dev/peps/pep-0529" target="_blank" rel="noopener"><strong>PEP 529</strong></a> 了解具体原因。 该函数在 Windows 上不再被弃用。</p>
<p><code>os.lchflags</code>(<em>path</em>, <em>flags</em>)</p>
<p>将 <em>path</em> 的 flags 设置为其他由数字表示的 <em>flags</em>，与 <code>chflags()</code> 类似，但不跟踪符号链接。从 Python 3.3 开始，它等效于 <code>os.chflags(path, flags, follow_symlinks=False)</code>。</p>
<p>引发一个 审计事件 <code>os.chflags</code>，附带参数 <code>path</code>、<code>flags</code>。</p>
<p>可用性: Unix。</p>
<p>在 3.6 版更改: 接受一个 path-like object。</p>
<p><code>os.lchmod</code>(<em>path</em>, <em>mode</em>)</p>
<p>将 <em>path</em> 的权限状态修改为 <em>mode*。如果 path 是符号链接，则影响符号链接本身而非链接目标。可以参考 <code>chmod()</code> 中列出 *mode</em> 的可用值。从 Python 3.3 开始，它等效于 <code>os.chmod(path, mode, follow_symlinks=False)</code>。</p>
<p>引发一个 审计事件 <code>os.chmod</code>，附带参数 <code>path</code>、<code>mode</code>、<code>dir_fd</code>。</p>
<p>可用性: Unix。</p>
<p>在 3.6 版更改: 接受一个 path-like object。</p>
<p><code>os.lchown</code>(<em>path</em>, <em>uid</em>, <em>gid</em>)</p>
<p>将 <em>path</em> 的用户和组 ID 分别修改为数字形式的 <em>uid</em> 和 <em>gid</em>，本函数不跟踪符号链接。从 Python 3.3 开始，它等效于 <code>os.chown(path, uid, gid, follow_symlinks=False)</code>。</p>
<p>引发一个 审计事件 <code>os.chown</code>，附带参数 <code>path</code>、<code>uid</code>、<code>gid</code>、<code>dir_fd</code>。</p>
<p>可用性: Unix。</p>
<p>在 3.6 版更改: 接受一个 path-like object。</p>
<p><code>os.link</code>(<em>src</em>, <em>dst</em>, <em>**,</em> src_dir_fd=None<em>,</em> dst_dir_fd=None<em>,</em> follow_symlinks=True*)</p>
<p>创建一个指向 <em>src</em> 的硬链接，名为 <em>dst</em>。</p>
<p>本函数支持将 <em>src_dir_fd</em> 和 <em>dst_dir_fd</em> 中的一个或两个指定为 基于目录描述符的相对路径，支持 不跟踪符号链接。</p>
<p>引发一个 审计事件 <code>os.link</code> 附带参数 <code>src</code>、<code>dst</code>、<code>src_dir_fd</code>、<code>dst_dir_fd</code>。</p>
<p>可用性: Unix, Windows。</p>
<p>在 3.2 版更改: 添加了对 Windows 的支持。</p>
<p>3.3 新版功能: 添加 <em>src_dir_fd<em>、</em>dst_dir_fd</em> 和 <em>follow_symlinks</em> 参数。</p>
<p>在 3.6 版更改: 接受一个 类路径对象 作为 <em>src</em> 和 <em>dst</em>。</p>
<p><code>os.listdir</code>(<em>path=’.’</em>)</p>
<p>返回一个包含由 <em>path</em> 指定目录中条目名称组成的列表。 该列表按任意顺序排列，并且不包括特殊条目 <code>'.'</code> 和 <code>'..'</code>，即使它们存在于目录中。 如果有文件在调用此函数期间在被移除或添加到目录中，是否要包括该文件的名称并没有规定。</p>
<p><em>path</em> 可以是 类路径对象。如果 <em>path</em> 是（直接传入或通过 <code>PathLike</code> 接口间接传入） <code>bytes</code> 类型，则返回的文件名也将是 <code>bytes</code> 类型，其他情况下是 <code>str</code> 类型。</p>
<p>本函数也支持 指定文件描述符为参数，其中描述符必须指向目录。</p>
<p>引发一个 审计事件 <code>os.listdir</code>，附带参数 <code>path</code>。</p>
<p>注解</p>
<p>要将 <code>str</code> 类型的文件名编码为 <code>bytes</code>，请使用 <code>fsencode()</code>。</p>
<p>参见</p>
<p><code>scandir()</code> 函数返回目录内文件名的同时，也返回文件属性信息，它在某些具体情况下能提供更好的性能。</p>
<p>在 3.2 版更改: <em>path</em> 变为可选参数。</p>
<p>3.3 新版功能: 新增支持将 <em>path</em> 参数指定为打开的文件描述符。</p>
<p>在 3.6 版更改: 接受一个 path-like object。</p>
<p><code>os.lstat</code>(<em>path</em>, <em>**,</em> dir_fd=None*)</p>
<p>在给定路径上执行本函数，其操作相当于 <code>lstat()</code> 系统调用，类似于 <code>stat()</code> 但不跟踪符号链接。返回值是 <code>stat_result</code> 对象。</p>
<p>在不支持符号链接的平台上，本函数是 <code>stat()</code> 的别名。</p>
<p>从 Python 3.3 起，此功能等价于 <code>os.stat(path, dir_fd=dir_fd, follow_symlinks=False)</code>。</p>
<p>本函数支持 基于目录描述符的相对路径。</p>
<p>参见</p>
<p><code>stat()</code> 函数。</p>
<p>在 3.2 版更改: 添加对 Windows 6.0 (Vista) 符号链接的支持。</p>
<p>在 3.3 版更改: 添加了 <em>dir_fd</em> 参数。</p>
<p>在 3.6 版更改: 接受一个 path-like object。</p>
<p>在 3.8 版更改: 目前在 Windows 上，遇到表示另一个路径的重解析点（即名称代理，包括符号链接和目录结点），本函数将打开它。其他种类的重解析点由 <code>stat()</code> 交由操作系统解析。</p>
<p><code>os.mkdir</code>(<em>path</em>, <em>mode=511</em>, <em>**,</em> dir_fd=None*)</p>
<p>创建一个名为 <em>path</em> 的目录，应用以数字表示的权限模式 <em>mode</em>。</p>
<p>如果目录已存在，则抛出 <code>FileExistsError</code> 异常。</p>
<p>某些系统会忽略 <em>mode*。如果没有忽略它，那么将首先从它中减去当前的 umask 值。如果除最后 9 位（即 *mode</em> 八进制的最后 3 位）之外，还设置了其他位，则其他位的含义取决于各个平台。在某些平台上，它们会被忽略，应显式调用 <code>chmod()</code> 进行设置。</p>
<p>本函数支持 基于目录描述符的相对路径。</p>
<p>引发一个 审计事件 <code>os.mkdir</code>，附带参数 <code>path</code>、<code>mode</code>、<code>dir_fd</code>。</p>
<p>3.3 新版功能: <em>dir_fd</em> 参数。</p>
<p>在 3.6 版更改: 接受一个 path-like object。</p>
<p><code>os.makedirs</code>(<em>name</em>, <em>mode=511</em>, <em>exist_ok=False</em>)</p>
<p>递归目录创建函数。与 <code>mkdir()</code> 类似，但会自动创建到达最后一级目录所需要的中间目录。</p>
<p><em>mode</em> 参数会传递给 <code>mkdir()</code>，用来创建最后一级目录，对于该参数的解释。要设置某些新建的父目录的权限，可以在调用 <code>makedirs()</code> 之前设置 umask。现有父目录的权限不会更改。</p>
<p>如果 <em>exist_ok</em> 为 <code>False</code> (默认值)，则如果目标目录已存在将引发 <code>FileExistsError</code>。</p>
<p>注解</p>
<p>如果要创建的路径元素包含 <code>pardir</code> (如 UNIX 系统中的 “..”) <code>makedirs()</code> 将无法明确目标。</p>
<p>本函数能正确处理 UNC 路径。</p>
<p>引发一个 审计事件 <code>os.mkdir</code>，附带参数 <code>path</code>、<code>mode</code>、<code>dir_fd</code>。</p>
<p>3.2 新版功能: <em>exist_ok</em> 参数。</p>
<p>在 3.4.1 版更改: 在 Python 3.4.1 以前，如果 <em>exist_ok</em> 为 <code>True</code>，且目录已存在，且 <em>mode</em> 与现有目录的权限不匹配，<code>makedirs()</code> 仍会抛出错误。由于无法安全地实现此行为，因此在 Python 3.4.1 中将该行为删除。</p>
<p>在 3.6 版更改: 接受一个 path-like object。</p>
<p>在 3.7 版更改: <em>mode</em> 参数不再影响新创建的中间目录的权限。</p>
<p><code>os.mkfifo</code>(<em>path</em>, <em>mode=438</em>, <em>**,</em> dir_fd=None*)</p>
<p>创建一个名为 <em>path</em> 的 FIFO（命名管道，一种先进先出队列），具有以数字表示的权限状态 <em>mode</em>。将从 mode 中首先减去当前的 umask 值。</p>
<p>本函数支持 基于目录描述符的相对路径。</p>
<p>FIFO 是可以像常规文件一样访问的管道。FIFO 如果没有被删除（如使用 <code>os.unlink()</code>），会一直存在。通常，FIFO 用作“客户端”和“服务器”进程之间的汇合点：服务器打开 FIFO 进行读取，而客户端打开 FIFO 进行写入。请注意，<code>mkfifo()</code> 不会打开 FIFO —- 它只是创建汇合点。</p>
<p>可用性: Unix。</p>
<p>3.3 新版功能: <em>dir_fd</em> 参数。</p>
<p>在 3.6 版更改: 接受一个 path-like object。</p>
<p><code>os.mknod</code>(<em>path</em>, <em>mode=384</em>, <em>device=0</em>, <em>**,</em> dir_fd=None*)</p>
<p>创建一个名为 <em>path</em> 的文件系统节点（文件，设备专用文件或命名管道）。<em>mode</em> 指定权限和节点类型，方法是将权限与下列节点类型 <code>stat.S_IFREG</code>、<code>stat.S_IFCHR</code>、<code>stat.S_IFBLK</code> 和 <code>stat.S_IFIFO</code> 之一（按位或）组合（这些常量可以在 <code>stat</code> 模块中找到）。对于 <code>stat.S_IFCHR</code> 和 <code>stat.S_IFBLK</code>，<em>device</em> 参数指定了新创建的设备专用文件（可能会用到 <code>os.makedev()</code>），否则该参数将被忽略。</p>
<p>本函数支持 基于目录描述符的相对路径。</p>
<p>可用性: Unix。</p>
<p>3.3 新版功能: <em>dir_fd</em> 参数。</p>
<p>在 3.6 版更改: 接受一个 path-like object。</p>
<p><code>os.major</code>(<em>device</em>)</p>
<p>提取主设备号，提取自原始设备号（通常是 <code>stat</code> 中的 <code>st_dev</code> 或 <code>st_rdev</code> 字段）。</p>
<p><code>os.minor</code>(<em>device</em>)</p>
<p>提取次设备号，提取自原始设备号（通常是 <code>stat</code> 中的 <code>st_dev</code> 或 <code>st_rdev</code> 字段）。</p>
<p><code>os.makedev</code>(<em>major</em>, <em>minor</em>)</p>
<p>将主设备号和次设备号组合成原始设备号。</p>
<p><code>os.pathconf</code>(<em>path</em>, <em>name</em>)</p>
<p>返回所给名称的文件有关的系统配置信息。<em>name</em> 指定要查找的配置名称，它可以是字符串，是一个系统已定义的名称，这些名称定义在不同标准（POSIX.1，Unix 95，Unix 98 等）中。一些平台还定义了额外的其他名称。当前操作系统已定义的名称在 <code>pathconf_names</code> 字典中给出。对于未包含在该映射中的配置名称，也可以传递一个整数作为 <em>name</em>。</p>
<p>如果 <em>name</em> 是一个字符串且不是已定义的名称，将抛出 <code>ValueError</code> 异常。如果当前系统不支持 <em>name</em> 指定的配置名称，即使该名称存在于 <code>pathconf_names</code>，也会抛出 <code>OSError</code> 异常，错误码为 <code>errno.EINVAL</code>。</p>
<p>本函数支持 指定文件描述符为参数。</p>
<p>可用性: Unix。</p>
<p>在 3.6 版更改: 接受一个 path-like object。</p>
<pre><code>os.pathconf_names</code></pre><p>字典，表示映射关系，为 <code>pathconf()</code> 和 <code>fpathconf()</code> 可接受名称与操作系统为这些名称定义的整数值之间的映射。这可用于判断系统已定义了哪些名称。</p>
<p>可用性: Unix。</p>
<p><code>os.readlink</code>(<em>path</em>, <em>**,</em> dir_fd=None*)</p>
<p>返回一个字符串，为符号链接指向的实际路径。其结果可以是绝对或相对路径。如果是相对路径，则可用 <code>os.path.join(os.path.dirname(path), result)</code> 转换为绝对路径。</p>
<p>如果 <em>path</em> 是字符串对象（直接传入或通过 <code>PathLike</code> 接口间接传入），则结果也将是字符串对象，且此类调用可能会引发 UnicodeDecodeError。如果 <em>path</em> 是字节对象（直接传入或间接传入），则结果将会是字节对象。</p>
<p>本函数支持 基于目录描述符的相对路径。</p>
<p>当尝试解析的路径可能含有链接时，请改用 <code>realpath()</code> 以正确处理递归和平台差异。</p>
<p>可用性: Unix, Windows。</p>
<p>在 3.2 版更改: 添加对 Windows 6.0 (Vista) 符号链接的支持。</p>
<p>3.3 新版功能: <em>dir_fd</em> 参数。</p>
<p>在 3.6 版更改: 在 Unix 上可以接受一个 类路径对象。</p>
<p>在 3.8 版更改: 在 Windows 上接受 类路径对象 和字节对象。</p>
<p>在 3.8 版更改: 增加了对目录链接的支持，且返回值改为了“替换路径”的形式（通常带有 <code>\\?\</code> 前缀），而不是先前那样返回可选的 “print name” 字段。</p>
<p><code>os.remove</code>(<em>path</em>, <em>**,</em> dir_fd=None*)</p>
<p>移除（删除）文件 <em>path*。 如果 *path</em> 是目录，则会引发 <code>IsADirectoryError</code>。 请使用 <code>rmdir()</code> 来删除目录。 如果文件不存在，则会引发 <code>FileNotFoundError</code>。</p>
<p>本函数支持 基于目录描述符的相对路径。</p>
<p>在 Windows 上，尝试删除正在使用的文件会抛出异常。而在 Unix 上，虽然该文件的条目会被删除，但分配给文件的存储空间仍然不可用，直到原始文件不再使用为止。</p>
<p>本函数在语义上与 <code>unlink()</code> 相同。</p>
<p>引发一个 审计事件 <code>os.remove</code>，附带参数 <code>path</code>、<code>dir_fd</code>。</p>
<p>3.3 新版功能: <em>dir_fd</em> 参数。</p>
<p>在 3.6 版更改: 接受一个 path-like object。</p>
<p><code>os.removedirs</code>(<em>name</em>)</p>
<p>递归删除目录。工作方式类似于 <code>rmdir()</code>，不同之处在于，如果成功删除了末尾一级目录，<code>removedirs()</code> 会尝试依次删除 <em>path</em> 中提到的每个父目录，直到抛出错误为止（但该错误会被忽略，因为这通常表示父目录不是空目录）。例如，<code>os.removedirs('foo/bar/baz')</code> 将首先删除目录 <code>'foo/bar/baz'</code>，然后如果 <code>'foo/bar'</code> 和 <code>'foo'</code> 为空，则继续删除它们。如果无法成功删除末尾一级目录，则抛出 <code>OSError</code> 异常。</p>
<p>引发一个 审计事件 <code>os.remove</code>，附带参数 <code>path</code>、<code>dir_fd</code>。</p>
<p>在 3.6 版更改: 接受一个 path-like object。</p>
<p><code>os.rename</code>(<em>src</em>, <em>dst</em>, <em>**,</em> src_dir_fd=None<em>,</em> dst_dir_fd=None*)</p>
<p>将文件或目录 <em>src</em> 重命名为 <em>dst*。如果 *dst</em> 已存在，则下列情况下将会操作失败，并抛出 <code>OSError</code> 的子类：</p>
<p>在 Windows 上，如果 <em>dst</em> 已存在，则抛出 <code>FileExistsError</code> 异常。</p>
<p>在 Unix 上，如果 <em>src</em> 是文件而 <em>dst</em> 是目录，将抛出 <code>IsADirectoryError</code> 异常，反之则抛出 <code>NotADirectoryError</code> 异常。如果两者都是目录且 <em>dst</em> 为空，则 <em>dst</em> 将被静默替换。如果 <em>dst</em> 是非空目录，则抛出 <code>OSError</code> 异常。如果两者都是文件，则在用户具有权限的情况下，将对 <em>dst</em> 进行静默替换。如果 <em>src</em> 和 <em>dst</em> 在不同的文件系统上，则本操作在某些 Unix 分支上可能会失败。如果成功，重命名操作将是一个原子操作（这是 POSIX 的要求）。</p>
<p>本函数支持将 <em>src_dir_fd</em> 和 <em>dst_dir_fd</em> 中的一个或两个指定为 基于目录描述符的相对路径。</p>
<p>如果需要在不同平台上都能替换目标，请使用 <code>replace()</code>。</p>
<p>引发一个 审计事件 <code>os.rename</code> 附带参数 <code>src</code>、<code>dst</code>、<code>src_dir_fd</code>、<code>dst_dir_fd</code>。</p>
<p>3.3 新版功能: <em>src_dir_fd</em> 和 <em>dst_dir_fd</em> 参数。</p>
<p>在 3.6 版更改: 接受一个 类路径对象 作为 <em>src</em> 和 <em>dst</em>。</p>
<p><code>os.renames</code>(<em>old</em>, <em>new</em>)</p>
<p>递归重命名目录或文件。工作方式类似 <code>rename()</code>，除了会首先创建新路径所需的中间目录。重命名后，将调用 <code>removedirs()</code> 删除旧路径中不需要的目录。</p>
<p>注解</p>
<p>如果用户没有权限删除末级的目录或文件，则本函数可能会无法建立新的目录结构。</p>
<p>引发一个 审计事件 <code>os.rename</code> 附带参数 <code>src</code>、<code>dst</code>、<code>src_dir_fd</code>、<code>dst_dir_fd</code>。</p>
<p>在 3.6 版更改: 接受一个 类路径对象 作为 <em>old</em> 和 <em>new</em>。</p>
<p><code>os.replace</code>(<em>src</em>, <em>dst</em>, <em>**,</em> src_dir_fd=None<em>,</em> dst_dir_fd=None*)</p>
<p>将文件或目录 <em>src</em> 重命名为 <em>dst*。如果 *dst</em> 是目录，将抛出 <code>OSError</code> 异常。如果 <em>dst</em> 已存在且为文件，则在用户具有权限的情况下，将对其进行静默替换。如果 <em>src</em> 和 <em>dst</em> 在不同的文件系统上，本操作可能会失败。如果成功，重命名操作将是一个原子操作（这是 POSIX 的要求）。</p>
<p>本函数支持将 <em>src_dir_fd</em> 和 <em>dst_dir_fd</em> 中的一个或两个指定为 基于目录描述符的相对路径。</p>
<p>引发一个 审计事件 <code>os.rename</code> 附带参数 <code>src</code>、<code>dst</code>、<code>src_dir_fd</code>、<code>dst_dir_fd</code>。</p>
<p>3.3 新版功能.</p>
<p>在 3.6 版更改: 接受一个 类路径对象 作为 <em>src</em> 和 <em>dst</em>。</p>
<p><code>os.rmdir</code>(<em>path</em>, <em>**,</em> dir_fd=None*)</p>
<p>移除（删除）目录 <em>path</em>。如果目录不存在或不为空，则会分别抛出 <code>FileNotFoundError</code> 或 <code>OSError</code> 异常。要删除整个目录树，可以使用 <code>shutil.rmtree()</code>。</p>
<p>本函数支持 基于目录描述符的相对路径。</p>
<p>引发一个 审计事件 <code>os.rmdir</code>，附带参数 <code>path</code>、<code>dir_fd</code>。</p>
<p>3.3 新版功能: <em>dir_fd</em> 参数。</p>
<p>在 3.6 版更改: 接受一个 path-like object。</p>
<p><code>os.scandir</code>(<em>path=’.’</em>)</p>
<p>返回一个 <code>os.DirEntry</code> 对象的迭代器，它们对应于由 <em>path</em> 指定目录中的条目。 这些条目会以任意顺序生成，并且不包括特殊条目 <code>'.'</code> 和 <code>'..'</code>。 如果有文件在迭代器创建之后在目录中被移除或添加，是否要包括该文件对应的条目并没有规定。</p>
<p>如果需要文件类型或文件属性信息，使用 <code>scandir()</code> 代替 <code>listdir()</code> 可以大大提高这部分代码的性能，因为如果操作系统在扫描目录时返回的是 <code>os.DirEntry</code> 对象，则该对象包含了这些信息。所有 <code>os.DirEntry</code> 的方法都可能执行一次系统调用，但是 <code>is_dir()</code> 和 <code>is_file()</code> 通常只在有符号链接时才执行一次系统调用。<code>os.DirEntry.stat()</code> 在 Unix 上始终需要一次系统调用，而在 Windows 上只在有符号链接时才需要。</p>
<p><em>path</em> 可以是 类路径对象。如果 <em>path</em> 是（直接传入或通过 <code>PathLike</code> 接口间接传入的） <code>bytes</code> 类型，那么每个 <code>os.DirEntry</code> 的 <code>name</code> 和 <code>path</code> 属性将是 <code>bytes</code> 类型，其他情况下是 <code>str</code> 类型。</p>
<p>本函数也支持 指定文件描述符为参数，其中描述符必须指向目录。</p>
<p>引发一个 审计事件 <code>os.scandir</code>，附带参数 <code>path</code>。</p>
<p><code>scandir()</code> 迭代器支持 上下文管理 协议，并具有以下方法：</p>
<ul>
<li><p><code>scandir.close</code>()</p>
<p>关闭迭代器并释放占用的资源。</p>
<p>当迭代器迭代完毕，或垃圾回收，或迭代过程出错时，将自动调用本方法。但仍建议显式调用它或使用 <code>with</code> 语句。</p>
<p>3.6 新版功能.</p>
</li>
</ul>
<p>下面的例子演示了 <code>scandir()</code> 的简单用法，用来显示给定 <em>path</em> 中所有不以 <code>'.'</code> 开头的文件（不包括目录）。<code>entry.is_file()</code> 通常不会增加一次额外的系统调用:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">with</span> os<span class="token punctuation">.</span>scandir<span class="token punctuation">(</span>path<span class="token punctuation">)</span> <span class="token keyword">as</span> it<span class="token punctuation">:</span>
    <span class="token keyword">for</span> entry <span class="token keyword">in</span> it<span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token operator">not</span> entry<span class="token punctuation">.</span>name<span class="token punctuation">.</span>startswith<span class="token punctuation">(</span><span class="token string">'.'</span><span class="token punctuation">)</span> <span class="token operator">and</span> entry<span class="token punctuation">.</span>is_file<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">print</span><span class="token punctuation">(</span>entry<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>注解</p>
<p>在基于 Unix 的系统上，<code>scandir()</code> 使用系统的 opendir() 和 readdir() 函数。在 Windows 上，它使用 Win32 FindFirstFileW 和 FindNextFileW 函数。</p>
<p>3.5 新版功能.</p>
<p>3.6 新版功能: 添加了对 上下文管理 协议和 <code>close()</code> 方法的支持。如果 <code>scandir()</code> 迭代器没有迭代完毕且没有显式关闭，其析构函数将发出 <code>ResourceWarning</code> 警告。</p>
<p>本函数接受一个 类路径对象。</p>
<p>在 3.7 版更改: 在 Unix 上新增支持 指定文件描述符为参数。</p>
<p><em>class</em> <code>os.DirEntry</code></p>
<p>由 <code>scandir()</code> 生成的对象，用于显示目录内某个条目的文件路径和其他文件属性。</p>
<p><code>scandir()</code> 将在不进行额外系统调用的情况下，提供尽可能多的此类信息。每次进行 <code>stat()</code> 或 <code>lstat()</code> 系统调用时，<code>os.DirEntry</code> 对象会将结果缓存下来。</p>
<p><code>os.DirEntry</code> 实例不适合存储在长期存在的数据结构中，如果你知道文件元数据已更改，或者自调用 <code>scandir()</code> 以来已经经过了很长时间，请调用 <code>os.stat(entry.path)</code> 来获取最新信息。</p>
<p>因为 <code>os.DirEntry</code> 方法可以进行系统调用，所以它也可能抛出 <code>OSError</code> 异常。如需精确定位错误，可以逐个调用 <code>os.DirEntry</code> 中的方法来捕获 <code>OSError</code>，并适当处理。</p>
<p>为了能直接用作 类路径对象，<code>os.DirEntry</code> 实现了 <code>PathLike</code> 接口。</p>
<p><code>os.DirEntry</code> 实例所包含的属性和方法如下：</p>
<ul>
<li><p><code>name</code></p>
<p>本条目的基本文件名，是根据 <code>scandir()</code> 的 <em>path</em> 参数得出的相对路径。</p>
<p>如果 <code>scandir()</code> 的 <em>path</em> 参数是 <code>bytes</code> 类型，则 <code>name</code> 属性也是 <code>bytes</code> 类型，否则为 <code>str</code>。使用 <code>fsdecode()</code> 解码 byte 类型的文件名。</p>
</li>
<li><p><code>path</code></p>
<p>本条目的完整路径：等效于 <code>os.path.join(scandir_path, entry.name)</code>，其中 <em>scandir_path</em> 就是 <code>scandir()</code> 的 <em>path</em> 参数。仅当 <code>scandir()</code> 的 <em>path</em> 参数为绝对路径时，本路径才是绝对路径。如果 <code>scandir()</code> 的 <em>path</em> 参数是 文件描述符，则 <code>path</code> 属性与上述 <code>name</code> 属性相同。</p>
<p>如果 <code>scandir()</code> 的 <em>path</em> 参数是 <code>bytes</code> 类型，则 <code>path</code> 属性也是 <code>bytes</code> 类型，否则为 <code>str</code>。使用 <code>fsdecode()</code> 解码 byte 类型的文件名。</p>
</li>
<li><p><code>inode</code>()</p>
<p>返回本条目的索引节点号 (inode number)。</p>
<p>这一结果是缓存在 <code>os.DirEntry</code> 对象中的，请调用 <code>os.stat(entry.path, follow_symlinks=False).st_ino</code> 来获取最新信息。</p>
<p>一开始没有缓存时，在 Windows 上需要一次系统调用，但在 Unix 上不需要。</p>
</li>
<li><p><code>is_dir</code>(<em>**,</em> follow_symlinks=True*)</p>
<p>如果本条目是目录，或是指向目录的符号链接，则返回 <code>True</code>。如果本条目是文件，或指向任何其他类型的文件，或该目录不再存在，则返回 <code>False</code>。</p>
<p>如果 <em>follow_symlinks</em> 是 <code>False</code>，那么仅当本条目为目录时返回 <code>True</code> （不跟踪符号链接），如果本条目是任何类型的文件，或该文件不再存在，则返回 <code>False</code>。</p>
<p>这一结果是缓存在 <code>os.DirEntry</code> 对象中的，且 <em>follow_symlinks</em> 为 <code>True</code> 和 <code>False</code> 时的缓存是分开的。请调用 <code>os.stat()</code> 和 <code>stat.S_ISDIR()</code> 来获取最新信息。</p>
<p>一开始没有缓存时，大多数情况下不需要系统调用。特别是对于非符号链接，Windows 和 Unix 都不需要系统调用，除非某些 Unix 文件系统（如网络文件系统）返回了 <code>dirent.d_type == DT_UNKNOWN</code>。如果本条目是符号链接，则需要一次系统调用来跟踪它（除非 <em>follow_symlinks</em> 为 <code>False</code>）。</p>
<p>本方法可能抛出 <code>OSError</code> 异常，如 <code>PermissionError</code> 异常，但 <code>FileNotFoundError</code> 异常会被内部捕获且不会抛出。</p>
</li>
<li><p><code>is_file</code>(<em>**,</em> follow_symlinks=True*)</p>
<p>如果本条目是文件，或是指向文件的符号链接，则返回 <code>True</code>。如果本条目是目录，或指向目录，或指向其他非文件条目，或该文件不再存在，则返回 <code>False</code>。</p>
<p>如果 <em>follow_symlinks</em> 是 <code>False</code>，那么仅当本条目为文件时返回 <code>True</code> （不跟踪符号链接），如果本条目是目录或其他非文件条目，或该文件不再存在，则返回 <code>False</code>。</p>
<p>这一结果是缓存在 <code>os.DirEntry</code> 对象中的。缓存、系统调用、异常抛出都与 <code>is_dir()</code> 一致。</p>
</li>
<li><p><code>is_symlink</code>()</p>
<p>如果本条目是符号链接（即使是断开的链接），返回 <code>True</code>。如果是目录或任何类型的文件，或本条目不再存在，返回 <code>False</code>。</p>
<p>这一结果是缓存在 <code>os.DirEntry</code> 对象中的，请调用 <code>os.path.islink()</code> 来获取最新信息。</p>
<p>一开始没有缓存时，大多数情况下不需要系统调用。其实 Windows 和 Unix 都不需要系统调用，除非某些 Unix 文件系统（如网络文件系统）返回了 <code>dirent.d_type == DT_UNKNOWN</code>。</p>
<p>本方法可能抛出 <code>OSError</code> 异常，如 <code>PermissionError</code> 异常，但 <code>FileNotFoundError</code> 异常会被内部捕获且不会抛出。</p>
</li>
<li><p><code>stat</code>(<em>**,</em> follow_symlinks=True*)</p>
<p>返回本条目对应的 <code>stat_result</code> 对象。本方法默认会跟踪符号链接，要获取符号链接本身的 stat，请添加 <code>follow_symlinks=False</code> 参数。</p>
<p>在 Unix 上，本方法需要一次系统调用。在 Windows 上，仅在 <em>follow_symlinks</em> 为 <code>True</code> 且该条目是一个重解析点（如符号链接或目录结点）时，才需要一次系统调用。</p>
<p>在 Windows 上，<code>stat_result</code> 的 <code>st_ino</code>、<code>st_dev</code> 和 <code>st_nlink</code> 属性总是为零。请调用 <code>os.stat()</code> 以获得这些属性。</p>
<p>这一结果是缓存在 <code>os.DirEntry</code> 对象中的，且 <em>follow_symlinks</em> 为 <code>True</code> 和 <code>False</code> 时的缓存是分开的。请调用 <code>os.stat()</code> 来获取最新信息。</p>
</li>
</ul>
<p>注意，<code>os.DirEntry</code> 和 <code>pathlib.Path</code> 的几个属性和方法之间存在很好的对应关系。具体来说是 <code>name</code> 属性，以及 <code>is_dir()</code>、<code>is_file()</code>、<code>is_symlink()</code> 和 <code>stat()</code> 方法，在两个类中具有相同的含义。</p>
<p>3.5 新版功能.</p>
<p>在 3.6 版更改: 添加了对 <code>PathLike</code> 接口的支持。在 Windows 上添加了对 <code>bytes</code> 类型路径的支持。</p>
<p><code>os.stat</code>(<em>path</em>, <em>**,</em> dir_fd=None<em>,</em> follow_symlinks=True*)</p>
<p>获取文件或文件描述符的状态。在所给路径上执行等效于 <code>stat()</code> 系统调用的操作。<em>path</em> 可以是字符串类型，或（直接传入或通过 <code>PathLike</code> 接口间接传入的） bytes 类型，或打开的文件描述符。返回一个 <code>stat_result</code> 对象。</p>
<p>本函数默认会跟踪符号链接，要获取符号链接本身的 stat，请添加 <code>follow_symlinks=False</code> 参数，或使用 <code>lstat()</code>。</p>
<p>本函数支持 指定文件描述符为参数 和 不跟踪符号链接。</p>
<p>在 Windows 上，传入 <code>follow_symlinks=False</code> 将禁用所有名称代理重解析点，其中包括符号链接和目录结点。其他类型的重解析点将直接打开，比如不像链接的或系统无法跟踪的重解析点。当多个链接形成一个链时，本方法可能会返回原始链接的 stat，无法完整遍历到非链接的对象。在这种情况下，要获取最终路径的 stat，请使用 <code>os.path.realpath()</code> 函数尽可能地解析路径，并在解析结果上调用 <code>lstat()</code>。这不适用于空链接或交接点，否则会抛出异常。</p>
<p>示例:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> os
<span class="token operator">>></span><span class="token operator">></span> statinfo <span class="token operator">=</span> os<span class="token punctuation">.</span>stat<span class="token punctuation">(</span><span class="token string">'somefile.txt'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> statinfo
os<span class="token punctuation">.</span>stat_result<span class="token punctuation">(</span>st_mode<span class="token operator">=</span><span class="token number">33188</span><span class="token punctuation">,</span> st_ino<span class="token operator">=</span><span class="token number">7876932</span><span class="token punctuation">,</span> st_dev<span class="token operator">=</span><span class="token number">234881026</span><span class="token punctuation">,</span>
st_nlink<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> st_uid<span class="token operator">=</span><span class="token number">501</span><span class="token punctuation">,</span> st_gid<span class="token operator">=</span><span class="token number">501</span><span class="token punctuation">,</span> st_size<span class="token operator">=</span><span class="token number">264</span><span class="token punctuation">,</span> st_atime<span class="token operator">=</span><span class="token number">1297230295</span><span class="token punctuation">,</span>
st_mtime<span class="token operator">=</span><span class="token number">1297230027</span><span class="token punctuation">,</span> st_ctime<span class="token operator">=</span><span class="token number">1297230027</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> statinfo<span class="token punctuation">.</span>st_size
<span class="token number">264</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>参见</p>
<p><code>fstat()</code> 和 <code>lstat()</code> 函数。</p>
<p>3.3 新版功能: 增加 <em>dir_fd</em> 和 <em>follow_symlinks</em> 参数，可指定文件描述符代替路径。</p>
<p>在 3.6 版更改: 接受一个 path-like object。</p>
<p>在 3.8 版更改: 在 Windows 上，本方法将跟踪系统能解析的所有重解析点，并且传入 <code>follow_symlinks=False</code> 会停止跟踪所有名称代理重解析点。现在，如果操作系统遇到无法跟踪的重解析点，<em>stat</em> 将返回原始路径的信息，就像已指定 <code>follow_symlinks=False</code> 一样，而不会抛出异常。</p>
<p><em>class</em> <code>os.stat_result</code></p>
<p>本对象的属性大致对应于 <code>stat</code> 结构体成员，主要作为 <code>os.stat()</code>、<code>os.fstat()</code> 和 <code>os.lstat()</code> 的返回值。</p>
<p>属性：</p>
<ul>
<li><p><code>st_mode</code></p>
<p>文件模式：包括文件类型和文件模式位（即权限位）。</p>
</li>
<li><p><code>st_ino</code></p>
<p>与平台有关，但如果不为零，则根据 <code>st_dev</code> 值唯一地标识文件。通常：</p>
<ul>
<li>在 Unix 上该值表示索引节点号 (inode number)。</li>
<li>在 Windows 上该值表示 文件索引号 。</li>
</ul>
</li>
<li><p><code>st_dev</code></p>
<p>该文件所在设备的标识符。</p>
</li>
<li><p><code>st_nlink</code></p>
<p>硬链接的数量。</p>
</li>
<li><p><code>st_uid</code></p>
<p>文件所有者的用户 ID。</p>
</li>
<li><p><code>st_gid</code></p>
<p>文件所有者的用户组 ID。</p>
</li>
<li><p><code>st_size</code></p>
<p>文件大小（以字节为单位），文件可以是常规文件或符号链接。符号链接的大小是它包含的路径的长度，不包括末尾的空字节。</p>
</li>
</ul>
<p>时间戳：</p>
<ul>
<li><p><code>st_atime</code></p>
<p>最近的访问时间，以秒为单位。</p>
</li>
<li><p><code>st_mtime</code></p>
<p>最近的修改时间，以秒为单位。</p>
</li>
<li><p><code>st_ctime</code></p>
<p>取决于平台：</p>
<ul>
<li>在 Unix 上表示最近的元数据更改时间，</li>
<li>在 Windows 上表示创建时间，以秒为单位。</li>
</ul>
</li>
<li><p><code>st_atime_ns</code></p>
<p>最近的访问时间，以纳秒表示，为整数。</p>
</li>
<li><p><code>st_mtime_ns</code></p>
<p>最近的修改时间，以纳秒表示，为整数。</p>
</li>
<li><p><code>st_ctime_ns</code></p>
<p>取决于平台：</p>
<ul>
<li>在 Unix 上表示最近的元数据更改时间，</li>
<li>在 Windows 上表示创建时间，以纳秒表示，为整数。</li>
</ul>
</li>
</ul>
<p>注解</p>
<p><code>st_atime</code>、<code>st_mtime</code> 和 <code>st_ctime</code> 属性的确切含义和分辨率取决于操作系统和文件系统。例如，在使用 FAT 或 FAT32 文件系统的 Windows 上，<code>st_mtime</code> 有 2 秒的分辨率，而 <code>st_atime</code> 仅有 1 天的分辨率。详细信息请参阅操作系统文档。</p>
<p>类似地，尽管 <code>st_atime_ns</code>、<code>st_mtime_ns</code> 和 <code>st_ctime_ns</code> 始终以纳秒表示，但许多系统并不提供纳秒精度。在确实提供纳秒精度的系统上，用于存储 <code>st_atime</code>、<code>st_mtime</code> 和 <code>st_ctime</code> 的浮点对象无法保留所有精度，因此不够精确。如果需要确切的时间戳，则应始终使用 <code>st_atime_ns</code>、<code>st_mtime_ns</code> 和 <code>st_ctime_ns</code>。</p>
<p>在某些 Unix 系统上（如 Linux 上），以下属性可能也可用：</p>
<ul>
<li><p><code>st_blocks</code></p>
<p>为文件分配的字节块数，每块 512 字节。文件是稀疏文件时，它可能小于 <code>st_size</code>/512。</p>
</li>
<li><p><code>st_blksize</code></p>
<p>“首选的” 块大小，用于提高文件系统 I/O 效率。写入文件时块大小太小可能会导致读取-修改-重写效率低下。</p>
</li>
<li><p><code>st_rdev</code></p>
<p>设备类型（如果是 inode 设备）。</p>
</li>
<li><p><code>st_flags</code></p>
<p>用户定义的文件标志位。</p>
</li>
</ul>
<p>在其他 Unix 系统上（如 FreeBSD 上），以下属性可能可用（但仅当 root 使用它们时才被填充）：</p>
<ul>
<li><p><code>st_gen</code></p>
<p>文件生成号。</p>
</li>
<li><p><code>st_birthtime</code></p>
<p>文件创建时间。</p>
</li>
</ul>
<p>在 Solaris 及其衍生版本上，以下属性可能也可用：</p>
<ul>
<li><p><code>st_fstype</code></p>
<p>文件所在文件系统的类型的唯一标识，为字符串。</p>
</li>
</ul>
<p>On macOS systems, the following attributes may also be available:</p>
<ul>
<li><p><code>st_rsize</code></p>
<p>文件的实际大小。</p>
</li>
<li><p><code>st_creator</code></p>
<p>文件的创建者。</p>
</li>
<li><p><code>st_type</code></p>
<p>文件类型。</p>
</li>
</ul>
<p>在 Windows 系统上，以下属性也可用：</p>
<ul>
<li><p><code>st_file_attributes</code></p>
<p>Windows 文件属性：<code>dwFileAttributes</code>，由 <code>GetFileInformationByHandle()</code> 返回的 <code>BY_HANDLE_FILE_INFORMATION</code> 结构体的成员之一。</p>
</li>
<li><p><code>st_reparse_tag</code></p>
<p>当 <code>st_file_attributes</code> 存在 <code>FILE_ATTRIBUTE_REPARSE_POINT</code> 集合时，本字段包含重解析点类型标记。</p>
</li>
</ul>
<p>标准模块 <code>stat</code> 中定义了函数和常量，这些函数和常量可用于从 <code>stat</code> 结构体中提取信息。（在 Windows 上，某些项填充的是虚值。）</p>
<p>为了向后兼容，一个 <code>stat_result</code> 实例还可以作为至少包含 10 个整数的元组访问，以提供 <code>stat</code> 结构中最重要（和可移植）的成员，整数顺序为 <code>st_mode</code>, <code>st_ino</code>, <code>st_dev</code>, <code>st_nlink</code>, <code>st_uid</code>, <code>st_gid</code>, <code>st_size</code>, <code>st_atime</code>, <code>st_mtime</code>, <code>st_ctime</code>。某些实现可能在末尾还有更多项。为了与旧版 Python 兼容，以元组形式访问 <code>stat_result</code> 始终返回整数。</p>
<p>3.3 新版功能: 添加了 <code>st_atime_ns</code>、<code>st_mtime_ns</code> 和 <code>st_ctime_ns</code> 成员。</p>
<p>3.5 新版功能: 在 Windows 上添加了 <code>st_file_attributes</code> 成员。</p>
<p>在 3.5 版更改: 在 Windows 上，如果可用，会返回文件索引作为 <code>st_ino</code> 的值。</p>
<p>3.7 新版功能: 在 Solaris 及其衍生版本上添加了 <code>st_fstype</code> 成员。</p>
<p>3.8 新版功能: 在 Windows 上添加了 <code>st_reparse_tag</code> 成员。</p>
<p>在 3.8 版更改: 在 Windows 上，<code>st_mode</code> 成员现在可以根据需要将特殊文件标识为 <code>S_IFCHR</code>、<code>S_IFIFO</code> 或 <code>S_IFBLK</code>。</p>
<p><code>os.statvfs</code>(<em>path</em>)</p>
<p>在所给的路径上执行 <code>statvfs()</code> 系统调用。返回值是一个对象，其属性描述了所给路径上的文件系统，并且与 <code>statvfs</code> 结构体的成员相对应，即：<code>f_bsize</code>, <code>f_frsize</code>, <code>f_blocks</code>, <code>f_bfree</code>, <code>f_bavail</code>, <code>f_files</code>, <code>f_ffree</code>, <code>f_favail</code>, <code>f_flag</code>, <code>f_namemax</code>, <code>f_fsid</code>。</p>
<p>为 <code>f_flag</code> 属性位定义了两个模块级常量：如果存在 <code>ST_RDONLY</code> 位，则文件系统以只读挂载；如果存在 <code>ST_NOSUID</code> 位，则文件系统禁用或不支持 setuid/setgid 位。</p>
<p>为基于 GNU/glibc 的系统还定义了额外的模块级常量。它们是 <code>ST_NODEV</code> （禁止访问设备专用文件），<code>ST_NOEXEC</code> （禁止执行程序），<code>ST_SYNCHRONOUS</code> （写入后立即同步），<code>ST_MANDLOCK</code> （允许文件系统上的强制锁定），<code>ST_WRITE</code> （写入文件/目录/符号链接），<code>ST_APPEND</code> （仅追加文件），<code>ST_IMMUTABLE</code> （不可变文件），<code>ST_NOATIME</code> （不更新访问时间），<code>ST_NODIRATIME</code> （不更新目录访问时间），<code>ST_RELATIME</code> （相对于 mtime/ctime 更新访问时间）。</p>
<p>本函数支持 指定文件描述符为参数。</p>
<p>可用性: Unix。</p>
<p>在 3.2 版更改: 添加了 <code>ST_RDONLY</code> 和 <code>ST_NOSUID</code> 常量。</p>
<p>3.3 新版功能: 新增支持将 <em>path</em> 参数指定为打开的文件描述符。</p>
<p>在 3.4 版更改: 添加了 <code>ST_NODEV</code>、<code>ST_NOEXEC</code>、<code>ST_SYNCHRONOUS</code>、<code>ST_MANDLOCK</code>、<code>ST_WRITE</code>、<code>ST_APPEND</code>、<code>ST_IMMUTABLE</code>、<code>ST_NOATIME</code>、<code>ST_NODIRATIME</code> 和 <code>ST_RELATIME</code> 常量。</p>
<p>在 3.6 版更改: 接受一个 path-like object。</p>
<p>3.7 新版功能: 添加了 <code>f_fsid</code>。</p>
<pre><code>os.supports_dir_fd</code></pre><p>一个 <code>set</code> 对象，指示 <code>os</code> 模块中的哪些函数接受一个打开的文件描述符作为 <em>dir_fd</em> 参数。不同平台提供的功能不同，且 Python 用于实现 <em>dir_fd</em> 参数的底层函数并非在 Python 支持的所有平台上都可用。考虑到一致性，支持 <em>dir_fd</em> 的函数始终允许指定描述符，但如果在底层不支持时调用了该函数，则会抛出异常。（在所有平台上始终支持将 <em>dir_fd</em> 指定为 <code>None</code>。）</p>
<p>要检查某个函数是否接受打开的文件描述符作为 <em>dir_fd</em> 参数，请在 <code>supports_dir_fd</code> 前使用 <code>in</code> 运算符。例如，如果 <code>os.stat()</code> 在当前平台上接受打开的文件描述符作为 <em>dir_fd</em> 参数，则此表达式的计算结果为 <code>True</code>:</p>
<pre><code>os.stat in os.supports_dir_fd</code></pre><p>目前 <em>dir_fd</em> 参数仅在 Unix 平台上有效，在 Windows 上均无效。</p>
<p>3.3 新版功能.</p>
<pre><code>os.supports_effective_ids</code></pre><p>一个 <code>set</code> 对象，指示 <code>os.access()</code> 是否允许在当前平台上将其 <em>effective_ids</em> 参数指定为 <code>True</code>。（所有平台都支持将 <em>effective_ids</em> 指定为 <code>False</code>。）如果当前平台支持，则集合将包含 <code>os.access()</code>，否则集合为空。</p>
<p>如果当前平台上的 <code>os.access()</code> 支持 <code>effective_ids=True</code>，则此表达式的计算结果为 <code>True</code>:</p>
<pre><code>os.access in os.supports_effective_ids</code></pre><p>目前仅 Unix 平台支持 <em>effective_ids</em>，Windows 不支持。</p>
<p>3.3 新版功能.</p>
<pre><code>os.supports_fd</code></pre><p>一个 <code>set</code> 对象，指示在当前平台上 <code>os</code> 模块中的哪些函数接受一个打开的文件描述符作为 <em>path</em> 参数。不同平台提供的功能不同，且 Python 所使用到的底层函数（用于实现接受描述符作为 <em>path</em>）并非在 Python 支持的所有平台上都可用。</p>
<p>要判断某个函数是否接受打开的文件描述符作为 <em>path</em> 参数，请在 <code>supports_fd</code> 前使用 <code>in</code> 运算符。例如，如果 <code>os.chdir()</code> 在当前平台上接受打开的文件描述符作为 <em>path</em> 参数，则此表达式的计算结果为 <code>True</code>:</p>
<pre><code>os.chdir in os.supports_fd</code></pre><p>3.3 新版功能.</p>
<pre><code>os.supports_follow_symlinks</code></pre><p>一个 <code>set</code> 对象，指示在当前平台上 <code>os</code> 模块中的哪些函数的 <em>follow_symlinks</em> 参数可指定为 <code>False</code>。不同平台提供的功能不同，且 Python 用于实现 <em>follow_symlinks</em> 的底层函数并非在 Python 支持的所有平台上都可用。考虑到一致性，支持 <em>follow_symlinks</em> 的函数始终允许将其指定为 <code>False</code>，但如果在底层不支持时调用了该函数，则会抛出异常。（在所有平台上始终支持将 <em>follow_symlinks</em> 指定为 <code>True</code>。）</p>
<p>要检查某个函数的 <em>follow_symlinks</em> 参数是否可以指定为 <code>False</code>，请在 <code>supports_follow_symlinks</code> 前使用 <code>in</code> 运算符。例如，如果在当前平台上调用 <code>os.stat()</code> 时可以指定 <code>follow_symlinks=False</code>，则此表达式的计算结果为 <code>True</code>:</p>
<pre><code>os.stat in os.supports_follow_symlinks</code></pre><p>3.3 新版功能.</p>
<p><code>os.symlink</code>(<em>src</em>, <em>dst</em>, <em>target_is_directory=False</em>, <em>**,</em> dir_fd=None*)</p>
<p>创建一个指向 <em>src</em> 的符号链接，名为 <em>dst</em>。</p>
<p>在 Windows 上，符号链接可以表示文件或目录两种类型，并且不会动态改变类型。如果目标存在，则新建链接的类型将与目标一致。否则，如果 <em>target_is_directory</em> 为 <code>True</code>，则符号链接将创建为目录链接，为 <code>False</code> （默认）将创建为文件链接。在非 Windows 平台上，<em>target_is_directory</em> 被忽略。</p>
<p>本函数支持 基于目录描述符的相对路径。</p>
<p>注解</p>
<p>在 Windows 10 或更高版本上，如果启用了开发人员模式，非特权帐户可以创建符号链接。如果开发人员模式不可用/未启用，则需要 <em>SeCreateSymbolicLinkPrivilege</em> 权限，或者该进程必须以管理员身份运行。</p>
<p>当本函数由非特权账户调用时，抛出 <code>OSError</code> 异常。</p>
<p>引发一个 审计事件 <code>os.symlink</code>，附带参数 <code>src</code>、<code>dst</code>、<code>dir_fd</code>。</p>
<p>可用性: Unix, Windows。</p>
<p>在 3.2 版更改: 添加对 Windows 6.0 (Vista) 符号链接的支持。</p>
<p>3.3 新版功能: 添加了 <em>dir_fd</em> 参数，现在在非 Windows 平台上允许 <em>target_is_directory</em> 参数。</p>
<p>在 3.6 版更改: 接受一个 类路径对象 作为 <em>src</em> 和 <em>dst</em>。</p>
<p>在 3.8 版更改: 针对启用了开发人员模式的 Windows，添加了非特权账户创建符号链接的支持。</p>
<p><code>os.sync</code>()</p>
<p>强制将所有内容写入磁盘。</p>
<p>可用性: Unix。</p>
<p>3.3 新版功能.</p>
<p><code>os.truncate</code>(<em>path</em>, <em>length</em>)</p>
<p>截断 <em>path</em> 对应的文件，以使其最大为 <em>length</em> 字节。</p>
<p>本函数支持 指定文件描述符为参数。</p>
<p>引发一个 审计事件 <code>os.truncate</code>，附带参数 <code>path</code>, <code>length</code>。</p>
<p>可用性: Unix, Windows。</p>
<p>3.3 新版功能.</p>
<p>在 3.5 版更改: 添加了 Windows 支持</p>
<p>在 3.6 版更改: 接受一个 path-like object。</p>
<p><code>os.unlink</code>(<em>path</em>, <em>**,</em> dir_fd=None*)</p>
<p>移除（删除）文件 <em>path</em>。该函数在语义上与 <code>remove()</code> 相同，<code>unlink</code> 是其传统的 Unix 名称。</p>
<p>引发一个 审计事件 <code>os.remove</code>，附带参数 <code>path</code>、<code>dir_fd</code>。</p>
<p>3.3 新版功能: <em>dir_fd</em> 参数。</p>
<p>在 3.6 版更改: 接受一个 path-like object。</p>
<p><code>os.utime</code>(<em>path</em>, <em>times=None</em>, <em>*<em>, [</em>ns</em>, ]<em>dir_fd=None</em>,* follow_symlinks=True*)</p>
<p>设置文件 <em>path</em> 的访问时间和修改时间。</p>
<p><code>utime()</code> 有 <em>times</em> 和 <em>ns</em> 两个可选参数，它们指定了设置给 <em>path</em> 的时间，用法如下：</p>
<ul>
<li>如果指定 <em>ns</em>，它必须是一个 <code>(atime_ns, mtime_ns)</code> 形式的二元组，其中每个成员都是一个表示纳秒的整数。</li>
<li>如果 <em>times</em> 不为 <code>None</code>，则它必须是 <code>(atime, mtime)</code> 形式的二元组，其中每个成员都是一个表示秒的 int 或 float。</li>
<li>如果 <em>times</em> 为 <code>None</code> 且未指定 <em>ns</em>，则相当于指定 <code>ns=(atime_ns, mtime_ns)</code>，其中两个时间均为当前时间。</li>
</ul>
<p>同时为 <em>times</em> 和 <em>ns</em> 指定元组会出错。</p>
<p>注意，根据操作系统记录访问时间和修改时间的分辨率，后续的 <code>stat()</code> 调用可能不会返回此处设置的确切时间。保留精确时间的最佳方法是使用 <code>os.stat()</code> 结果对象中的 <em>st_atime_ns</em> 和 <em>st_mtime_ns</em> 字段，并将 <em>ns</em> 参数设置为 utime。</p>
<p>本函数支持 指定文件描述符、指定基于目录描述符的相对路径 和 不跟踪符号链接。</p>
<p>引发一个 审计事件 <code>os.utime</code>，附带参数 <code>path</code>、<code>times</code>、<code>ns</code>、<code>dir_fd</code>。</p>
<p>3.3 新版功能: 新增支持将 <em>path</em> 参数指定为打开的文件描述符，以及支持 <em>dir_fd<em>、</em>follow_symlinks</em> 和 <em>ns</em> 参数。</p>
<p>在 3.6 版更改: 接受一个 path-like object。</p>
<p><code>os.walk</code>(<em>top</em>, <em>topdown=True</em>, <em>onerror=None</em>, <em>followlinks=False</em>)</p>
<p>生成目录树中的文件名，方式是按上-&gt;下或下-&gt;上顺序浏览目录树。对于以 <em>top</em> 为根的目录树中的每个目录（包括 <em>top</em> 本身），它都会生成一个三元组 <code>(dirpath, dirnames, filenames)</code>。</p>
<p><em>dirpath</em> 是表示目录路径的字符串。 <em>dirnames</em> 是 <em>dirpath</em> 中子目录名称组成的列表 (excluding <code>'.'</code> and <code>'..'</code>)。 <em>filenames</em> 是 <em>dirpath</em> 中非目录文件名称组成的列表。 请注意列表中的名称不带路径部分。 要获取 <em>dirpath</em> 中文件或目录的完整路径（以 <em>top</em> 打头），请执行 <code>os.path.join(dirpath, name)</code>。 列表是否排序取决于具体文件系统。 如果有文件或列表生成期间被移除或添加到 <em>dirpath</em> 目录中，是否要包括该文件的名称并没有规定。</p>
<p>如果可选参数 <em>topdown</em> 为 <code>True</code> 或未指定，则在所有子目录的三元组之前生成父目录的三元组（目录是自上而下生成的）。如果 <em>topdown</em> 为 <code>False</code>，则在所有子目录的三元组生成之后再生成父目录的三元组（目录是自下而上生成的）。无论 <em>topdown</em> 为何值，在生成目录及其子目录的元组之前，都将检索全部子目录列表。</p>
<p>当 <em>topdown</em> 为 <code>True</code> 时，调用者可以就地修改 <em>dirnames</em> 列表（也许用到了 <code>del</code> 或切片），而 <code>walk()</code> 将仅仅递归到仍保留在 <em>dirnames</em> 中的子目录内。这可用于减少搜索、加入特定的访问顺序，甚至可在继续 <code>walk()</code> 之前告知 <code>walk()</code> 由调用者新建或重命名的目录的信息。当 <em>topdown</em> 为 <code>False</code> 时，修改 <em>dirnames</em> 对 walk 的行为没有影响，因为在自下而上模式中，<em>dirnames</em> 中的目录是在 <em>dirpath</em> 本身之前生成的。</p>
<p>默认将忽略 <code>scandir()</code> 调用中的错误。如果指定了可选参数 <em>onerror</em>，它应该是一个函数。出错时它会被调用，参数是一个 <code>OSError</code> 实例。它可以报告错误然后继续遍历，或者抛出异常然后中止遍历。注意，可以从异常对象的 <code>filename</code> 属性中获取出错的文件名。</p>
<p><code>walk()</code> 默认不会递归进指向目录的符号链接。可以在支持符号链接的系统上将 <em>followlinks</em> 设置为 <code>True</code>，以访问符号链接指向的目录。</p>
<p>注解</p>
<p>注意，如果链接指向自身的父目录，则将 <em>followlinks</em> 设置为 <code>True</code> 可能导致无限递归。<code>walk()</code> 不会记录它已经访问过的目录。</p>
<p>注解</p>
<p>如果传入的是相对路径，请不要在恢复 <code>walk()</code> 之间更改当前工作目录。<code>walk()</code> 不会更改当前目录，并假定其调用者也不会更改当前目录。</p>
<p>下面的示例遍历起始目录内所有子目录，打印每个目录内的文件占用的字节数，CVS 子目录不会被遍历:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> os
<span class="token keyword">from</span> os<span class="token punctuation">.</span>path <span class="token keyword">import</span> join<span class="token punctuation">,</span> getsize
<span class="token keyword">for</span> root<span class="token punctuation">,</span> dirs<span class="token punctuation">,</span> files <span class="token keyword">in</span> os<span class="token punctuation">.</span>walk<span class="token punctuation">(</span><span class="token string">'python/Lib/email'</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> <span class="token string">"consumes"</span><span class="token punctuation">,</span> end<span class="token operator">=</span><span class="token string">" "</span><span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>sum<span class="token punctuation">(</span>getsize<span class="token punctuation">(</span>join<span class="token punctuation">(</span>root<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">for</span> name <span class="token keyword">in</span> files<span class="token punctuation">)</span><span class="token punctuation">,</span> end<span class="token operator">=</span><span class="token string">" "</span><span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"bytes in"</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>files<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"non-directory files"</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> <span class="token string">'CVS'</span> <span class="token keyword">in</span> dirs<span class="token punctuation">:</span>
        dirs<span class="token punctuation">.</span>remove<span class="token punctuation">(</span><span class="token string">'CVS'</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># don't visit CVS directories</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在下一个示例（<code>shutil.rmtree()</code> 的简单实现）中，必须使树自下而上遍历，因为 <code>rmdir()</code> 只允许在目录为空时删除目录:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Delete everything reachable from the directory named in "top",</span>
<span class="token comment" spellcheck="true"># assuming there are no symbolic links.</span>
<span class="token comment" spellcheck="true"># CAUTION:  This is dangerous!  For example, if top == '/', it</span>
<span class="token comment" spellcheck="true"># could delete all your disk files.</span>
<span class="token keyword">import</span> os
<span class="token keyword">for</span> root<span class="token punctuation">,</span> dirs<span class="token punctuation">,</span> files <span class="token keyword">in</span> os<span class="token punctuation">.</span>walk<span class="token punctuation">(</span>top<span class="token punctuation">,</span> topdown<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">for</span> name <span class="token keyword">in</span> files<span class="token punctuation">:</span>
        os<span class="token punctuation">.</span>remove<span class="token punctuation">(</span>os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>join<span class="token punctuation">(</span>root<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">for</span> name <span class="token keyword">in</span> dirs<span class="token punctuation">:</span>
        os<span class="token punctuation">.</span>rmdir<span class="token punctuation">(</span>os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>join<span class="token punctuation">(</span>root<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>引发一个 审计事件 <code>os.walk</code>，附带参数 <code>top</code>, <code>topdown</code>, <code>onerror</code>, <code>followlinks</code>。</p>
<p>在 3.5 版更改: 现在，本函数调用的是 <code>os.scandir()</code> 而不是 <code>os.listdir()</code>，从而减少了调用 <code>os.stat()</code> 的次数而变得更快。</p>
<p>在 3.6 版更改: 接受一个 path-like object。</p>
<p><code>os.fwalk</code>(<em>top=’.’</em>, <em>topdown=True</em>, <em>onerror=None</em>, <em>**,</em> follow_symlinks=False<em>,</em> dir_fd=None*)</p>
<p>本方法的行为与 <code>walk()</code> 完全一样，除了它产生的是 4 元组 <code>(dirpath, dirnames, filenames, dirfd)</code>，并且它支持 <code>dir_fd</code>。</p>
<p><em>dirpath<em>、</em>dirnames</em> 和 <em>filenames</em> 与 <code>walk()</code> 输出的相同，<em>dirfd</em> 是指向目录 <em>dirpath</em> 的文件描述符。</p>
<p>本函数始终支持 基于目录描述符的相对路径 和 不跟踪符号链接。但是请注意，与其他函数不同，<code>fwalk()</code> 的 <em>follow_symlinks</em> 的默认值为 <code>False</code>。</p>
<p>注解</p>
<p>由于 <code>fwalk()</code> 会生成文件描述符，而它们仅在下一个迭代步骤前有效，因此如果要将描述符保留更久，则应复制它们（比如使用 <code>dup()</code>）。</p>
<p>下面的示例遍历起始目录内所有子目录，打印每个目录内的文件占用的字节数，CVS 子目录不会被遍历:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> os
<span class="token keyword">for</span> root<span class="token punctuation">,</span> dirs<span class="token punctuation">,</span> files<span class="token punctuation">,</span> rootfd <span class="token keyword">in</span> os<span class="token punctuation">.</span>fwalk<span class="token punctuation">(</span><span class="token string">'python/Lib/email'</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> <span class="token string">"consumes"</span><span class="token punctuation">,</span> end<span class="token operator">=</span><span class="token string">""</span><span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>sum<span class="token punctuation">(</span><span class="token punctuation">[</span>os<span class="token punctuation">.</span>stat<span class="token punctuation">(</span>name<span class="token punctuation">,</span> dir_fd<span class="token operator">=</span>rootfd<span class="token punctuation">)</span><span class="token punctuation">.</span>st_size <span class="token keyword">for</span> name <span class="token keyword">in</span> files<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
          end<span class="token operator">=</span><span class="token string">""</span><span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"bytes in"</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>files<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"non-directory files"</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> <span class="token string">'CVS'</span> <span class="token keyword">in</span> dirs<span class="token punctuation">:</span>
        dirs<span class="token punctuation">.</span>remove<span class="token punctuation">(</span><span class="token string">'CVS'</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># don't visit CVS directories</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在下一个示例中，必须使树自下而上遍历，因为 <code>rmdir()</code> 只允许在目录为空时删除目录:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Delete everything reachable from the directory named in "top",</span>
<span class="token comment" spellcheck="true"># assuming there are no symbolic links.</span>
<span class="token comment" spellcheck="true"># CAUTION:  This is dangerous!  For example, if top == '/', it</span>
<span class="token comment" spellcheck="true"># could delete all your disk files.</span>
<span class="token keyword">import</span> os
<span class="token keyword">for</span> root<span class="token punctuation">,</span> dirs<span class="token punctuation">,</span> files<span class="token punctuation">,</span> rootfd <span class="token keyword">in</span> os<span class="token punctuation">.</span>fwalk<span class="token punctuation">(</span>top<span class="token punctuation">,</span> topdown<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">for</span> name <span class="token keyword">in</span> files<span class="token punctuation">:</span>
        os<span class="token punctuation">.</span>unlink<span class="token punctuation">(</span>name<span class="token punctuation">,</span> dir_fd<span class="token operator">=</span>rootfd<span class="token punctuation">)</span>
    <span class="token keyword">for</span> name <span class="token keyword">in</span> dirs<span class="token punctuation">:</span>
        os<span class="token punctuation">.</span>rmdir<span class="token punctuation">(</span>name<span class="token punctuation">,</span> dir_fd<span class="token operator">=</span>rootfd<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>引发一个 审计事件 <code>os.fwalk</code>，附带参数 <code>top</code>, <code>topdown</code>, <code>onerror</code>, <code>follow_symlinks</code>, <code>dir_fd</code>。</p>
<p>可用性: Unix。</p>
<p>3.3 新版功能.</p>
<p>在 3.6 版更改: 接受一个 path-like object。</p>
<p>在 3.7 版更改: 添加了对 <code>bytes</code> 类型路径的支持。</p>
<p><code>os.memfd_create</code>(<em>name</em>[, <em>flags=os.MFD_CLOEXEC</em>])</p>
<p>创建一个匿名文件，返回指向该文件的文件描述符。<em>flags</em> 必须是系统上可用的 <code>os.MFD_*</code> 常量之一（或将它们按位“或”组合起来）。新文件描述符默认是 不可继承的。</p>
<p><em>name</em> 提供的名称会被用作文件名，并且 <code>/proc/self/fd/</code> 目录中相应符号链接的目标将显示为该名称。显示的名称始终以 <code>memfd:</code> 为前缀，并且仅用于调试目的。名称不会影响文件描述符的行为，因此多个文件可以有相同的名称，不会有副作用。</p>
<p>可用性：Linux 3.17 或更高版本，且装有 glibc 2.27 或更高版本。</p>
<p>3.8 新版功能.</p>
<pre><code>os.MFD_CLOEXEC
os.MFD_ALLOW_SEALING
os.MFD_HUGETLB
os.MFD_HUGE_SHIFT
os.MFD_HUGE_MASK
os.MFD_HUGE_64KB
os.MFD_HUGE_512KB
os.MFD_HUGE_1MB
os.MFD_HUGE_2MB
os.MFD_HUGE_8MB
os.MFD_HUGE_16MB
os.MFD_HUGE_32MB
os.MFD_HUGE_256MB
os.MFD_HUGE_512MB
os.MFD_HUGE_1GB
os.MFD_HUGE_2GB
os.MFD_HUGE_16GB</code></pre><p>以上标志位可以传递给 <code>memfd_create()</code>。</p>
<p>可用性：Linux 3.17 或更高版本，且装有 glibc 2.27 或更高版本。<code>MFD_HUGE*</code> 标志仅在 Linux 4.14 及以上可用。</p>
<p>3.8 新版功能.</p>
<p><code>os.eventfd</code>(<em>initval</em>[, <em>flags=os.EFD_CLOEXEC</em>])</p>
<p>创建并返回一个事件文件描述符。此文件描述符支持缓冲区大小为 8 的原生 <code>read()</code> 和 <code>write()</code> 操作、<code>select()</code> 、<code>poll()</code> 等类似操作。默认情况下，新的文件描述符是 non-inheritable。</p>
<p><em>initval</em> 是事件计数器的初始值。初始值必须是一个 32 位无符号整数。请注意，虽然事件计数器是一个无符号的 64 位整数，其最大值为 2 64-2，但初始值仍被限制为 32 位无符号整数。</p>
<p><em>flags</em> 可由 <code>EFD_CLOEXEC</code> 、 <code>EFD_NONBLOCK</code> 和 <code>EFD_SEMAPHORE</code> 组合而成。</p>
<p>如果设置了 <code>EFD_SEMAPHORE</code>，并且事件计数器非零，那么 <code>eventfd_read()</code> 将返回 1 并将计数器递减 1。</p>
<p>如果未设置 <code>EFD_SEMAPHORE</code>，并且事件计数器非零，那么 <code>eventfd_read()</code> 返回当前的事件计数器值，并将计数器重置为零。</p>
<p>如果事件计数器为 0，并且未设置 <code>EFD_NONBLOCK</code>，那么 <code>eventfd_read()</code> 会阻塞。</p>
<p><code>eventfd_write()</code> 会递增事件计数器。如果写操作会让计数器的增量大于264-2，则写入会被阻止。</p>
<p>示例:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> os
<span class="token comment" spellcheck="true"># semaphore with start value '1'</span>
fd <span class="token operator">=</span> os<span class="token punctuation">.</span>eventfd<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> os<span class="token punctuation">.</span>EFD_SEMAPHORE <span class="token operator">|</span> os<span class="token punctuation">.</span>EFC_CLOEXEC<span class="token punctuation">)</span>
<span class="token keyword">try</span><span class="token punctuation">:</span>
    <span class="token comment" spellcheck="true"># acquire semaphore</span>
    v <span class="token operator">=</span> os<span class="token punctuation">.</span>eventfd_read<span class="token punctuation">(</span>fd<span class="token punctuation">)</span>
    <span class="token keyword">try</span><span class="token punctuation">:</span>
        do_work<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">finally</span><span class="token punctuation">:</span>
        <span class="token comment" spellcheck="true"># release semaphore</span>
        os<span class="token punctuation">.</span>eventfd_write<span class="token punctuation">(</span>fd<span class="token punctuation">,</span> v<span class="token punctuation">)</span>
<span class="token keyword">finally</span><span class="token punctuation">:</span>
    os<span class="token punctuation">.</span>close<span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可用性 ：Linux 2.6.27 以上版本，带有 glibc 2.8 以上版本。</p>
<p>3.10 新版功能.</p>
<p><code>os.eventfd_read</code>(<em>fd</em>)</p>
<p>从一个 <code>eventfd()</code> 文件描述符中读取数据，并返回一个 64 位无符号整数。该函数不会校验 <em>fd</em> 是否为 <code>eventfd()</code>。</p>
<p>可用性 ：参见 <code>eventfd()</code> 。</p>
<p>3.10 新版功能.</p>
<p><code>os.eventfd_write</code>(<em>fd</em>, <em>value</em>)</p>
<p>向一个 <code>eventfd()</code> 文件描述符加入数据。<em>value</em> 必须是一个 64 位无符号整数。本函数不会校验 <em>fd</em> 是否为 <code>eventfd()</code>。</p>
<p>可用性 ：参见 <code>eventfd()</code> 。</p>
<p>3.10 新版功能.</p>
<pre><code>os.EFD_CLOEXEC</code></pre><p>为新的 <code>eventfd()</code> 文件描述符设置 close-on-exec 标志。</p>
<p>可用性 ：参见 <code>eventfd()</code> 。</p>
<p>3.10 新版功能.</p>
<pre><code>os.EFD_NONBLOCK</code></pre><p>为新的 <code>eventfd()</code> 文件描述符设置 <code>O_NONBLOCK</code> 状态标志。</p>
<p>可用性 ：参见 <code>eventfd()</code> 。</p>
<p>3.10 新版功能.</p>
<pre><code>os.EFD_SEMAPHORE</code></pre><p>为读取 <code>eventfd()</code> 文件描述符的操作提供类似信号量的控制。在读取时，内部计数器递减 1。</p>
<p>可用性: Linux 2.6.30 以上版本，带有 glibc 2.8 以上版本。</p>
<p>3.10 新版功能.</p>
<h4 id="Linux-扩展属性"><a href="#Linux-扩展属性" class="headerlink" title="Linux 扩展属性"></a>Linux 扩展属性</h4><p>3.3 新版功能.</p>
<p>这些函数仅在 Linux 上可用。</p>
<p><code>os.getxattr</code>(<em>path</em>, <em>attribute</em>, <em>**,</em> follow_symlinks=True*)</p>
<p>返回 <em>path</em> 的扩展文件系统属性 <em>attribute</em> 的值。<em>attribute</em> 可以是 bytes 或 str （直接传入或通过 <code>PathLike</code> 接口间接传入）。如果是 str，则使用文件系统编码来编码字符串。</p>
<p>本函数支持 指定文件描述符为参数 和 不跟踪符号链接。</p>
<p>引发一个 审计事件 <code>os.getxattr</code>，附带参数 <code>path</code>、<code>attribute</code>。</p>
<p>在 3.6 版更改: 接受一个 类路径对象 作为 <em>path</em> 和 <em>attribute</em>。</p>
<p><code>os.listxattr</code>(<em>path=None</em>, <em>**,</em> follow_symlinks=True*)</p>
<p>返回一个列表，包含 <em>path</em> 的所有扩展文件系统属性。列表中的属性都表示为字符串，它们是根据文件系统编码解码出来的。如果 <em>path</em> 为 <code>None</code>，则 <code>listxattr()</code> 将检查当前目录。</p>
<p>本函数支持 指定文件描述符为参数 和 不跟踪符号链接。</p>
<p>引发一个 审计事件 <code>os.listxattr</code>，附带参数 <code>path</code>。</p>
<p>在 3.6 版更改: 接受一个 path-like object。</p>
<p><code>os.removexattr</code>(<em>path</em>, <em>attribute</em>, <em>**,</em> follow_symlinks=True*)</p>
<p>移除 <em>path</em> 中的扩展文件系统属性 <em>attribute*。 *attribute</em> 应为字节串或字符串类型（通过 <code>PathLike</code> 接口直接或间接得到）。 若为字符串类型，则用 filesystem encoding and error handler 进行编码。</p>
<p>本函数支持 指定文件描述符为参数 和 不跟踪符号链接。</p>
<p>引发一个 审计事件 <code>os.removexattr</code>，附带参数 <code>path</code>、<code>attribute</code>。</p>
<p>在 3.6 版更改: 接受一个 类路径对象 作为 <em>path</em> 和 <em>attribute</em>。</p>
<p><code>os.setxattr</code>(<em>path</em>, <em>attribute</em>, <em>value</em>, <em>flags=0</em>, <em>**,</em> follow_symlinks=True*)</p>
<p>将 <em>path</em> 的文件系统扩展属性 <em>attribute</em> 设为 <em>value*。 *attribute</em> 必须是一个字节串或字符串，不含 NUL（通过 <code>PathLike</code> 接口直接或间接得到）。 若为字符串，将用 filesystem encoding and error handler 进行编码。 <em>flags</em> 可以是 <code>XATTR_REPLACE</code> 或 <code>XATTR_CREATE</code>。 如果给出 <code>XATTR_REPLACE</code> 而属性不存在，则会触发 <code>ENODATA</code>。 如果给出了 <code>XATTR_CREATE</code> 而属性已存在，则不会创建属性并将触发 <code>EEXISTS</code>。</p>
<p>本函数支持 指定文件描述符为参数 和 不跟踪符号链接。</p>
<p>注解</p>
<p>Linux kernel 2.6.39 以下版本的一个 bug 导致在某些文件系统上，flags 参数会被忽略。</p>
<p>引发一个 审计事件 <code>os.setxattr</code>，附带参数 <code>path</code>、<code>attribute</code>、<code>value</code>、<code>flags</code>。</p>
<p>在 3.6 版更改: 接受一个 类路径对象 作为 <em>path</em> 和 <em>attribute</em>。</p>
<pre><code>os.XATTR_SIZE_MAX</code></pre><p>一条扩展属性的值的最大大小。在当前的 Linux 上是 64 KiB。</p>
<pre><code>os.XATTR_CREATE</code></pre><p>这是 <code>setxattr()</code> 的 flags 参数的可取值，它表示该操作必须创建一个属性。</p>
<pre><code>os.XATTR_REPLACE</code></pre><p>这是 <code>setxattr()</code> 的 flags 参数的可取值，它表示该操作必须替换现有属性。</p>
<h3 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h3><p>下列函数可用于创建和管理进程。</p>
<p>所有 <code>exec*</code> 函数都接受一个参数列表，用来给新程序加载到它的进程中。在所有情况下，传递给新程序的第一个参数是程序本身的名称，而不是用户在命令行上输入的参数。对于 C 程序员来说，这就是传递给 <code>main()</code> 函数的 <code>argv[0]</code>。例如，<code>os.execv('/bin/echo', ['foo', 'bar'])</code> 只会在标准输出上打印 <code>bar</code>，而 <code>foo</code> 会被忽略。</p>
<p><code>os.abort</code>()</p>
<p>发送 <code>SIGABRT</code> 信号到当前进程。在 Unix 上，默认行为是生成一个核心转储。在 Windows 上，该进程立即返回退出代码 <code>3</code>。请注意，使用 <code>signal.signal()</code> 可以为 <code>SIGABRT</code> 注册 Python 信号处理程序，而调用本函数将不会调用按前述方法注册的程序。</p>
<p><code>os.add_dll_directory</code>(<em>path</em>)</p>
<p>将路径添加到 DLL 搜索路径。</p>
<p>当需要解析扩展模块的依赖时（扩展模块本身通过 sys.path 解析），会使用该搜索路径，<code>ctypes</code> 也会使用该搜索路径。</p>
<p>要移除目录，可以在返回的对象上调用 <strong>close()</strong>，也可以在 <code>with</code> 语句内使用本方法。</p>
<p>参阅 <a href="https://msdn.microsoft.com/44228cf2-6306-466c-8f16-f513cd3ba8b5" target="_blank" rel="noopener">Microsoft 文档</a> 获取如何加载 DLL 的信息。</p>
<p>引发一个 审计事件 <code>os.add_dll_directory</code>，附带参数 <code>path</code>。</p>
<p>可用性: Windows。</p>
<p>3.8 新版功能: 早期版本的 CPython 解析 DLL 时用的是当前进程的默认行为。这会导致不一致，比如不是每次都会去搜索 <code>PATH</code> 和当前工作目录，且系统函数（如 <code>AddDllDirectory</code> ）失效。</p>
<p>在 3.8 中，DLL 的两种主要加载方式现在可以显式覆盖进程的行为，以确保一致性。</p>
<p><code>os.execl</code>(<em>path</em>, <em>arg0</em>, <em>arg1</em>, <em>…</em>)</p>
<p><code>os.execle</code>(<em>path</em>, <em>arg0</em>, <em>arg1</em>, <em>…</em>, <em>env</em>)</p>
<p><code>os.execlp</code>(<em>file</em>, <em>arg0</em>, <em>arg1</em>, <em>…</em>)</p>
<p><code>os.execlpe</code>(<em>file</em>, <em>arg0</em>, <em>arg1</em>, <em>…</em>, <em>env</em>)</p>
<p><code>os.execv</code>(<em>path</em>, <em>args</em>)</p>
<p><code>os.execve</code>(<em>path</em>, <em>args</em>, <em>env</em>)</p>
<p><code>os.execvp</code>(<em>file</em>, <em>args</em>)</p>
<p><code>os.execvpe</code>(<em>file</em>, <em>args</em>, <em>env</em>)</p>
<p>这些函数都将执行一个新程序，以替换当前进程。它们没有返回值。在 Unix 上，新程序会加载到当前进程中，且进程号与调用者相同。过程中的错误会被报告为 <code>OSError</code> 异常。</p>
<p>当前进程会被立即替换。打开的文件对象和描述符都不会刷新，因此如果这些文件上可能缓冲了数据，则应在调用 <code>exec*</code> 函数之前使用 <code>sys.stdout.flush()</code> 或 <code>os.fsync()</code> 刷新它们。</p>
<p><code>exec*</code> 函数的 “l” 和 “v” 变体不同在于命令行参数的传递方式。如果在编码时固定了参数数量，则 “l” 变体可能是最方便的，各参数作为 <code>execl*()</code> 函数的附加参数传入即可。当参数数量可变时，”v” 变体更方便，参数以列表或元组的形式作为 <em>args</em> 参数传递。在这两种情况下，子进程的第一个参数都应该是即将运行的命令名称，但这不是强制性的。</p>
<p>结尾包含 “p” 的变体（<code>execlp()</code>、<code>execlpe()</code>、<code>execvp()</code> 和 <code>execvpe()</code> ）将使用 <code>PATH</code> 环境变量来查找程序 <em>file<em>。当环境被替换时（使用下一段讨论的 `exec</em>e<code>变体之一），</code>PATH<code>变量将来自于新环境。其他变体</code>execl()<code>、</code>execle()<code>、</code>execv()<code>和</code>execve()<code>不使用</code>PATH` 变量来查找程序，因此 *path</em> 必须包含正确的绝对或相对路径。</p>
<p>对于 <code>execle()</code>、<code>execlpe()</code>、<code>execve()</code> 和 <code>execvpe()</code> （都以 “e” 结尾），<em>env</em> 参数是一个映射，用于定义新进程的环境变量（代替当前进程的环境变量）。而函数 <code>execl()</code>、<code>execlp()</code>、<code>execv()</code> 和 <code>execvp()</code> 会将当前进程的环境变量过继给新进程。</p>
<p>某些平台上的 <code>execve()</code> 可以将 <em>path</em> 指定为打开的文件描述符。当前平台可能不支持此功能，可以使用 <code>os.supports_fd</code> 检查它是否支持。如果不可用，则使用它会抛出 <code>NotImplementedError</code> 异常。</p>
<p>引发一个 审计事件 <code>os.exec</code>，附带参数 <code>path</code>、<code>args</code>、<code>env</code>。</p>
<p>可用性: Unix, Windows。</p>
<p>3.3 新版功能: 新增支持将 <code>execve()</code> 的 <em>path</em> 参数指定为打开的文件描述符。</p>
<p>在 3.6 版更改: 接受一个 path-like object。</p>
<p><code>os._exit</code>(<em>n</em>)</p>
<p>以状态码 <em>n</em> 退出进程，不会调用清理处理程序，不会刷新 stdio，等等。</p>
<p>注解</p>
<p>退出的标准方法是使用 <code>sys.exit(n)</code>。而 <code>_exit()</code> 通常只应在 <code>fork()</code> 出的子进程中使用。</p>
<p>以下是已定义的退出代码，可以用于 <code>_exit()</code>，尽管它们不是必需的。这些退出代码通常用于 Python 编写的系统程序，例如邮件服务器的外部命令传递程序。</p>
<p>注解</p>
<p>其中部分退出代码在部分 Unix 平台上可能不可用，因为平台间存在差异。如果底层平台定义了这些常量，那上层也会定义。</p>
<pre><code>os.EX_OK</code></pre><p>退出代码，表示未发生任何错误。</p>
<p>可用性: Unix。</p>
<pre><code>os.EX_USAGE</code></pre><p>退出代码，表示命令使用不正确，如给出的参数数量有误。</p>
<p>可用性: Unix。</p>
<pre><code>os.EX_DATAERR</code></pre><p>退出代码，表示输入数据不正确。</p>
<p>可用性: Unix。</p>
<pre><code>os.EX_NOINPUT</code></pre><p>退出代码，表示某个输入文件不存在或不可读。</p>
<p>可用性: Unix。</p>
<pre><code>os.EX_NOUSER</code></pre><p>退出代码，表示指定的用户不存在。</p>
<p>可用性: Unix。</p>
<pre><code>os.EX_NOHOST</code></pre><p>退出代码，表示指定的主机不存在。</p>
<p>可用性: Unix。</p>
<pre><code>os.EX_UNAVAILABLE</code></pre><p>退出代码，表示所需的服务不可用。</p>
<p>可用性: Unix。</p>
<pre><code>os.EX_SOFTWARE</code></pre><p>退出代码，表示检测到内部软件错误。</p>
<p>可用性: Unix。</p>
<pre><code>os.EX_OSERR</code></pre><p>退出代码，表示检测到操作系统错误，例如无法 fork 或创建管道。</p>
<p>可用性: Unix。</p>
<pre><code>os.EX_OSFILE</code></pre><p>退出代码，表示某些系统文件不存在、无法打开或发生其他错误。</p>
<p>可用性: Unix。</p>
<pre><code>os.EX_CANTCREAT</code></pre><p>退出代码，表示无法创建用户指定的输出文件。</p>
<p>可用性: Unix。</p>
<pre><code>os.EX_IOERR</code></pre><p>退出代码，表示对某些文件进行读写时发生错误。</p>
<p>可用性: Unix。</p>
<pre><code>os.EX_TEMPFAIL</code></pre><p>退出代码，表示发生了暂时性故障。它可能并非意味着真正的错误，例如在可重试的情况下无法建立网络连接。</p>
<p>可用性: Unix。</p>
<pre><code>os.EX_PROTOCOL</code></pre><p>退出代码，表示协议交换是非法的、无效的或无法解读的。</p>
<p>可用性: Unix。</p>
<pre><code>os.EX_NOPERM</code></pre><p>退出代码，表示没有足够的权限执行该操作（但不适用于文件系统问题）。</p>
<p>可用性: Unix。</p>
<pre><code>os.EX_CONFIG</code></pre><p>退出代码，表示发生某种配置错误。</p>
<p>可用性: Unix。</p>
<pre><code>os.EX_NOTFOUND</code></pre><p>退出代码，表示的内容类似于“找不到条目”。</p>
<p>可用性: Unix。</p>
<p><code>os.fork</code>()</p>
<p>Fork 出一个子进程。在子进程中返回 <code>0</code>，在父进程中返回子进程的进程号。如果发生错误，则抛出 <code>OSError</code> 异常。</p>
<p>注意，当从线程中使用 <code>fork()</code> 时，某些平台（包括 FreeBSD &lt;= 6.3 和 Cygwin）存在已知问题。</p>
<p>引发一个 审计事件 <code>os.fork</code>，没有附带参数。</p>
<p>在 3.8 版更改: 不再支持在子解释器中调用 <code>fork()</code> （将抛出 <code>RuntimeError</code> 异常）。</p>
<p>警告</p>
<p>有关 SSL 模块与 fork() 结合的应用。</p>
<p>可用性: Unix。</p>
<p><code>os.forkpty</code>()</p>
<p>Fork 出一个子进程，使用新的伪终端作为子进程的控制终端。返回一对 <code>(pid, fd)</code>，其中 <em>pid</em> 在子进程中为 <code>0</code>，这是父进程中新子进程的进程号，而 <em>fd</em> 是伪终端主设备的文件描述符。对于更便于移植的方法，请使用 <code>pty</code> 模块。如果发生错误，则抛出 <code>OSError</code> 异常。</p>
<p>引发一个 审计事件 <code>os.forkpty</code>，没有附带参数。</p>
<p>在 3.8 版更改: 不再支持在子解释器中调用 <code>forkpty()</code> （将抛出 <code>RuntimeError</code> 异常）。</p>
<p>可用性: 某些 Unix。</p>
<p><code>os.kill</code>(<em>pid</em>, <em>sig</em>)</p>
<p>将信号 <em>sig</em> 发送至进程 <em>pid</em>。特定平台上可用的信号常量定义在 <code>signal</code> 模块中。</p>
<p>Windows： <code>signal.CTRL_C_EVENT</code> 和 <code>signal.CTRL_BREAK_EVENT</code> 信号是特殊信号，只能发送给共享同一个控制台窗口的控制台进程，如某些子进程。<em>sig</em> 取任何其他值将导致该进程被 TerminateProcess API 无条件终止，且退出代码为 <em>sig</em>。Windows 版本的 <code>kill()</code> 还需要传入待结束进程的句柄。</p>
<p>另请参阅 <code>signal.pthread_kill()</code>。</p>
<p>引发一个 审计事件 <code>os.kill</code>，附带参数 <code>pid</code>、<code>sig</code>。</p>
<p>3.2 新版功能: Windows 支持。</p>
<p><code>os.killpg</code>(<em>pgid</em>, <em>sig</em>)</p>
<p>将信号 <em>sig</em> 发送给进程组 <em>pgid</em>。</p>
<p>引发一个 审计事件 <code>os.killpg</code>，附带参数 <code>pgid</code>、<code>sig</code>。</p>
<p>可用性: Unix。</p>
<p><code>os.nice</code>(<em>increment</em>)</p>
<p>将进程的优先级（nice 值）增加 <em>increment</em>，返回新的 nice 值。</p>
<p>可用性: Unix。</p>
<p><code>os.pidfd_open</code>(<em>pid</em>, <em>flags=0</em>)</p>
<p>返回一个文件描述符，它指向进程 <em>pid<em>。该描述符可用于管理进程，避免出现竞争和信号。</em>flags</em> 参数提供给将来扩展使用，当前没有定义标志值。</p>
<p>可用性: Linux 5.3+。</p>
<p>3.9 新版功能.</p>
<p><code>os.plock</code>(<em>op</em>)</p>
<p>将程序段锁定到内存中。<em>op</em> 的值（定义在 <code>&lt;sys/lock.h&gt;</code> 中）决定了哪些段被锁定。</p>
<p>可用性: Unix。</p>
<p><code>os.popen</code>(<em>cmd</em>, <em>mode=’r’</em>, <em>buffering=- 1</em>)</p>
<p>打开一个管道，它通往 / 接受自命令 <em>cmd*。返回值是连接到管道的文件对象，根据 *mode</em> 是 <code>'r'</code> （默认）还是 <code>'w'</code> 决定该对象可以读取还是写入。<em>buffering</em> 参数与内置函数 <code>open()</code> 相应的参数含义相同。返回的文件对象只能读写文本字符串，不能是字节类型。</p>
<p>如果子进程成功退出，则 <code>close</code> 方法返回 <code>None</code>。如果发生错误，则返回子进程的返回码。在 POSIX 系统上，如果返回码为正，则它就是进程返回值左移一个字节后的值。如果返回码为负，则进程是被信号终止的，返回码取反后就是该信号。（例如，如果子进程被终止，则返回值可能是 <code>- signal.SIGKILL</code>。）在 Windows 系统上，返回值包含子进程的返回码（有符号整数）。</p>
<p>在 Unix 上，<code>waitstatus_to_exitcode()</code> 可以将 <code>close</code> 方法的返回值（即退出状态，不能是 <code>None</code>）转换为退出码。在 Windows 上，<code>close</code> 方法的结果直接就是退出码（或 <code>None</code> ）。</p>
<p>本方法是使用 <code>subprocess.Popen</code> 实现的，如需更强大的方法来管理和沟通子进程，请参阅该类的文档。</p>
<p><code>os.posix_spawn</code>(<em>path</em>, <em>argv</em>, <em>env</em>, <em>**,</em> file_actions=None<em>,</em> setpgroup=None<em>,</em> resetids=False<em>,</em> setsid=False<em>,</em> setsigmask=()<em>,</em> setsigdef=()<em>,</em> scheduler=None*)</p>
<p>包装 <code>posix_spawn()</code> C 库 API，使其可以从 Python 调用。</p>
<p>大多数用户应使用 <code>subprocess.run()</code> 代替 <code>posix_spawn()</code>。</p>
<p>仅位置参数 (Positional-only arguments) <em>path<em>、</em>args</em> 和 <em>env</em> 与 <code>execve()</code> 中的类似。</p>
<p><em>path</em> 形参是可执行文件的路径，<em>path</em> 中应当包含目录。 使用 <code>posix_spawnp()</code> 可传入不带目录的可执行文件。</p>
<p><em>file_actions</em> 参数可以是由元组组成的序列，序列描述了对子进程中指定文件描述符采取的操作，这些操作会在 C 库实现的 <code>fork()</code> 和 <code>exec()</code> 步骤间完成。每个元组的第一个元素必须是下面列出的三个类型指示符之一，用于描述元组剩余的元素：</p>
<ul>
<li><p><code>os.POSIX_SPAWN_OPEN</code></p>
<p>(<code>os.POSIX_SPAWN_OPEN</code>, <em>fd</em>, <em>path</em>, <em>flags</em>, <em>mode</em>)</p>
<p>执行 <code>os.dup2(os.open(path, flags, mode), fd)</code>。</p>
</li>
<li><p><code>os.POSIX_SPAWN_CLOSE</code></p>
<p>(<code>os.POSIX_SPAWN_CLOSE</code>, <em>fd</em>)</p>
<p>执行 <code>os.close(fd)</code>。</p>
</li>
<li><p><code>os.POSIX_SPAWN_DUP2</code></p>
<p>(<code>os.POSIX_SPAWN_DUP2</code>, <em>fd</em>, <em>new_fd</em>)</p>
<p>执行 <code>os.dup2(fd, new_fd)</code>。</p>
</li>
</ul>
<p>这些元组对应于 C 库 <code>posix_spawn_file_actions_addopen()</code>， <code>posix_spawn_file_actions_addclose()</code> 和 <code>posix_spawn_file_actions_adddup2()</code> API 调用，它们为调用 <code>posix_spawn()</code> 自身做准备。</p>
<p><em>setpgroup</em> 参数将子进程的进程组设置为指定值。如果指定值为 0，则子进程的进程组 ID 将与其进程 ID 相同。如果未设置 <em>setpgroup</em> 值，则子进程将继承父进程的进程组 ID。本参数对应于 C 库 <code>POSIX_SPAWN_SETPGROUP</code> 标志。</p>
<p>如果 <em>resetids</em> 参数为 <code>True</code>，则会将子进程的有效用户 ID 和有效组 ID 重置为父进程的实际用户 ID 和实际组 ID。如果该参数为 <code>False</code>，则子进程保留父进程的有效用户 ID 和有效组 ID。无论哪种情况，若在可执行文件上启用了 “设置用户 ID” 和 “设置组 ID” 权限位，它们将覆盖有效用户 ID 和有效组 ID 的设置。本参数对应于 C 库 <code>POSIX_SPAWN_RESETIDS</code> 标志。</p>
<p>如果 <em>setsid</em> 参数为 <code>True</code>，它将为 posix_spawn 新建一个会话 ID。<em>setsid</em> 需要 <code>POSIX_SPAWN_SETSID</code> 或 <code>POSIX_SPAWN_SETSID_NP</code> 标志，否则会抛出 <code>NotImplementedError</code> 异常。</p>
<p><em>setsigmask</em> 参数将信号掩码设置为指定的信号集合。如果未使用该参数，则子进程将继承父进程的信号掩码。本参数对应于 C 库 <code>POSIX_SPAWN_SETSIGMASK</code> 标志。</p>
<p><em>sigdef</em> 参数将集合中所有信号的操作全部重置为默认。本参数对应于 C 库 <code>POSIX_SPAWN_SETSIGDEF</code> 标志。</p>
<p><em>scheduler</em> 参数必须是一个元组，其中包含调度器策略（可选）以及携带了调度器参数的 <code>sched_param</code> 实例。在调度器策略所在位置为 <code>None</code> 表示未提供该值。本参数是 C 库 <code>POSIX_SPAWN_SETSCHEDPARAM</code> 和 <code>POSIX_SPAWN_SETSCHEDULER</code> 标志的组合。</p>
<p>引发一个 审计事件 <code>os.posix_spawn</code>，附带参数 <code>path</code>、<code>argv</code>、<code>env</code>。</p>
<p>3.8 新版功能.</p>
<p>可用性: Unix。</p>
<p><code>os.posix_spawnp</code>(<em>path</em>, <em>argv</em>, <em>env</em>, <em>**,</em> file_actions=None<em>,</em> setpgroup=None<em>,</em> resetids=False<em>,</em> setsid=False<em>,</em> setsigmask=()<em>,</em> setsigdef=()<em>,</em> scheduler=None*)</p>
<p>包装 <code>posix_spawnp()</code> C 库 API，使其可以从 Python 调用。</p>
<p>与 <code>posix_spawn()</code> 相似，但是系统会在 <code>PATH</code> 环境变量指定的目录列表中搜索可执行文件 <em>executable</em> （与 <code>execvp(3)</code> 相同）。</p>
<p>引发一个 审计事件 <code>os.posix_spawn</code>，附带参数 <code>path</code>、<code>argv</code>、<code>env</code>。</p>
<p>3.8 新版功能.</p>
<p>可用性。</p>
<p><code>os.register_at_fork</code>(<em>**,</em> before=None<em>,</em> after_in_parent=None<em>,</em> after_in_child=None*)</p>
<p>注册可调用对象，在使用 <code>os.fork()</code> 或类似的进程克隆 API 派生新的子进程时，这些对象会运行。参数是可选的，且为仅关键字 (Keyword-only) 参数。每个参数指定一个不同的调用点。</p>
<ul>
<li><em>before</em> 是一个函数，在 fork 子进程前调用。</li>
<li><em>after_in_parent</em> 是一个函数，在 fork 子进程后从父进程调用。</li>
<li><em>after_in_child</em> 是一个函数，从子进程中调用。</li>
</ul>
<p>只有希望控制权回到 Python 解释器时，才进行这些调用。典型的 <code>子进程</code> 启动时不会触发它们，因为子进程不会重新进入解释器。</p>
<p>在注册的函数中，用于 fork 前运行的函数将按与注册相反的顺序调用。用于 fork 后（从父进程或子进程）运行的函数按注册顺序调用。</p>
<p>注意，第三方 C 代码的 <code>fork()</code> 调用可能不会调用这些函数，除非它显式调用了 <code>PyOS_BeforeFork()</code>、<code>PyOS_AfterFork_Parent()</code> 和 <code>PyOS_AfterFork_Child()</code>。</p>
<p>函数注册后无法注销。</p>
<p>可用性: Unix。</p>
<p>3.7 新版功能.</p>
<p><code>os.spawnl</code>(<em>mode</em>, <em>path</em>, <em>…</em>)</p>
<p><code>os.spawnle</code>(<em>mode</em>, <em>path</em>, <em>…</em>, <em>env</em>)</p>
<p><code>os.spawnlp</code>(<em>mode</em>, <em>file</em>, <em>…</em>)</p>
<p><code>os.spawnlpe</code>(<em>mode</em>, <em>file</em>, <em>…</em>, <em>env</em>)</p>
<p><code>os.spawnv</code>(<em>mode</em>, <em>path</em>, <em>args</em>)</p>
<p><code>os.spawnve</code>(<em>mode</em>, <em>path</em>, <em>args</em>, <em>env</em>)</p>
<p><code>os.spawnvp</code>(<em>mode</em>, <em>file</em>, <em>args</em>)</p>
<p><code>os.spawnvpe</code>(<em>mode</em>, <em>file</em>, <em>args</em>, <em>env</em>)</p>
<p>在新进程中执行程序 <em>path</em>。</p>
<p>（注意，<code>subprocess</code> 模块提供了更强大的工具来生成新进程并跟踪执行结果，使用该模块比使用这些函数更好。尤其应当检查 使用 subprocess 模块替换旧函数 部分。）</p>
<p><em>mode</em> 为 <code>P_NOWAIT</code> 时，本函数返回新进程的进程号。<em>mode</em> 为 <code>P_WAIT</code> 时，如果进程正常退出，返回退出代码，如果被终止，返回 <code>-signal</code>，其中 <em>signal</em> 是终止进程的信号。在 Windows 上，进程号实际上是进程句柄，因此可以与 <code>waitpid()</code> 函数一起使用。</p>
<p>注意在 VxWorks 上，新进程被终止时，本函数不会返回 <code>-signal</code>，而是会抛出 OSError 异常。</p>
<p><code>spawn*</code> 函数的 “l” 和 “v” 变体不同在于命令行参数的传递方式。如果在编码时固定了参数数量，则 “l” 变体可能是最方便的，各参数作为 <code>spawnl*()</code> 函数的附加参数传入即可。当参数数量可变时，”v” 变体更方便，参数以列表或元组的形式作为 <em>args</em> 参数传递。在这两种情况下，子进程的第一个参数都必须是即将运行的命令名称。</p>
<p>结尾包含第二个 “p” 的变体（<code>spawnlp()</code>、<code>spawnlpe()</code>、<code>spawnvp()</code> 和 <code>spawnvpe()</code>）将使用 <code>PATH</code> 环境变量来查找程序 <em>file<em>。当环境被替换时（使用下一段讨论的 `spawn</em>e<code>变体之一），</code>PATH<code>变量将来自于新环境。其他变体</code>spawnl()<code>、</code>spawnle()<code>、</code>spawnv()<code>和</code>spawnve()<code>不使用</code>PATH` 变量来查找程序，因此 *path</em> 必须包含正确的绝对或相对路径。</p>
<p>对于 <code>spawnle()</code>、<code>spawnlpe()</code>、<code>spawnve()</code> 和 <code>spawnvpe()</code> （都以 “e” 结尾），<em>env</em> 参数是一个映射，用于定义新进程的环境变量（代替当前进程的环境变量）。而函数 <code>spawnl()</code>、<code>spawnlp()</code>、<code>spawnv()</code> 和 <code>spawnvp()</code> 会将当前进程的环境变量过继给新进程。注意，<em>env</em> 字典中的键和值必须是字符串。无效的键或值将导致函数出错，返回值为 <code>127</code>。</p>
<p>例如，以下对 <code>spawnlp()</code> 和 <code>spawnvpe()</code> 的调用是等效的:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> os
os<span class="token punctuation">.</span>spawnlp<span class="token punctuation">(</span>os<span class="token punctuation">.</span>P_WAIT<span class="token punctuation">,</span> <span class="token string">'cp'</span><span class="token punctuation">,</span> <span class="token string">'cp'</span><span class="token punctuation">,</span> <span class="token string">'index.html'</span><span class="token punctuation">,</span> <span class="token string">'/dev/null'</span><span class="token punctuation">)</span>
L <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'cp'</span><span class="token punctuation">,</span> <span class="token string">'index.html'</span><span class="token punctuation">,</span> <span class="token string">'/dev/null'</span><span class="token punctuation">]</span>
os<span class="token punctuation">.</span>spawnvpe<span class="token punctuation">(</span>os<span class="token punctuation">.</span>P_WAIT<span class="token punctuation">,</span> <span class="token string">'cp'</span><span class="token punctuation">,</span> L<span class="token punctuation">,</span> os<span class="token punctuation">.</span>environ<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>引发一个 审计事件 <code>os.spawn</code>，附带参数 <code>mode</code>、<code>path</code>、<code>args</code>、<code>env</code>。</p>
<p>可用性: Unix, Windows。<code>spawnlp()</code>、<code>spawnlpe()</code>、<code>spawnvp()</code> 和 <code>spawnvpe()</code> 在 Windows 上不可用。<code>spawnle()</code> 和 <code>spawnve()</code> 在 Windows 上不是线程安全的，建议使用 <code>subprocess</code> 模块替代。</p>
<p>在 3.6 版更改: 接受一个 path-like object。</p>
<pre><code>os.P_NOWAIT
os.P_NOWAITO</code></pre><p><code>spawn*</code> 系列函数的 <em>mode</em> 参数的可取值。如果给出这些值中的任何一个，则 <code>spawn*()</code> 函数将在创建新进程后立即返回，且返回值为进程号。</p>
<p>可用性: Unix, Windows。</p>
<pre><code>os.P_WAIT</code></pre><p><code>spawn*</code> 系列函数的 <em>mode</em> 参数的可取值。如果将 <em>mode</em> 指定为该值，则 <code>spawn*()</code> 函数将在新进程运行完毕后返回，运行成功则返回进程的退出代码，被信号终止则返回 <code>-signal</code>。</p>
<p>可用性: Unix, Windows。</p>
<pre><code>os.P_DETACH
os.P_OVERLAY</code></pre><p><code>spawn*</code> 系列函数的 <em>mode</em> 参数的可取值。它们比上面列出的值可移植性差。<code>P_DETACH</code> 与 <code>P_NOWAIT</code> 相似，但是新进程会与父进程的控制台脱离。使用 <code>P_OVERLAY</code> 则会替换当前进程，<code>spawn*</code> 函数将不会返回。</p>
<p>可用性: Windows。</p>
<p><code>os.startfile</code>(<em>path</em>, <em>operation</em>, <em>cwd</em>)</p>
<p>使用已关联的应用程序打开文件。</p>
<p>当 <em>operation</em> 未指定或指定为 <code>'open'</code> 时，这类似于在 Windows 资源管理器中双击文件，或在交互式命令行中将文件名作为 <strong>start</strong> 命令的参数：通过扩展名相关联的应用程序（如果有）打开文件。</p>
<p>当指定另一个 <em>operation</em> 时，它必须是一个“命令动词” (“command verb”)，该词指定对文件执行的操作。Microsoft 文档中的常用动词有 <code>'print'</code> 和 <code>'edit'</code> （用于文件），以及 <code>'explore'</code> 和 <code>'find'</code> （用于目录）。</p>
<p>在启动某个应用程序时，<em>arguments</em> 将作为一个字符串传入。若是打开某个文档，此参数可能没什么效果。</p>
<p>默认工作目录是继承而来的，但可以通过 <em>cwd</em> 参数进行覆盖。且应为绝对路径。相对路径 <em>path</em> 将据此参数进行解析。</p>
<p><em>show_cmd</em> 可用于覆盖默认的窗口样式。是否生效则取决于被启动的应用程序。应为 Win32 函数 <code>ShellExecute()</code> 所支持的整数值。</p>
<p>在关联的应用程序启动后，<code>startfile()</code> 就会立即返回。 没有提供等待应用程序关闭的选项，也没有办法获得应用程序的退出状态。 <em>path</em> 形参是基于当前目录或 <em>cwd</em> 的相对路径。 如果要使用绝对路径，请确保第一个字符不为斜杠 (<code>'/'</code>) 。 请用 <code>pathlib</code> 或 <code>os.path.normpath()</code> 函数来保证路径已按照 Win32 的要求进行了正确的编码。</p>
<p>为了减少解释器的启动开销，直到第一次调用本函数后，才解析 Win32 <code>ShellExecute()</code> 函数。如果无法解析该函数，则抛出 <code>NotImplementedError</code> 异常。</p>
<p>引发一个 审计事件 <code>os.startfile</code>，附带参数 <code>path</code>、<code>operation</code>。</p>
<p>引发一条 审计事件 <code>os.startfile/2</code>，附带参数为 <code>path</code>、<code>operation</code>、<code>arguments</code>、<code>cwd</code>、<code>show_cmd</code>。</p>
<p>可用性: Windows。</p>
<p>在 3.10 版更改: 加入了 <em>arguments<em>、</em>cwd</em> 和 <em>show_cmd</em> 参数，以及 <code>os.startfile/2</code> 审计事件。</p>
<p><code>os.system</code>(<em>command</em>)</p>
<p>在子外壳程序中执行此命令（一个字符串）。 这是通过调用标准 C 函数 <code>system()</code> 来实现的，并受到同样的限制。 对 <code>sys.stdin</code> 的更改等不会反映在所执行命令的环境中。 如果 <em>command</em> 生成了任何输出，它将被发送到解释器的标准输出流。 C 标准没有指明这个 C 函数返回值的含义，因此这个 Python 函数的返回值取决于具体系统。</p>
<p>在 Unix 上，返回值为进程的退出状态，以针对 <code>wait()</code> 而指定的格式进行编码。</p>
<p>在 Windows 上，返回值是运行 <em>command</em> 后系统 Shell 返回的值。该 Shell 由 Windows 环境变量 <code>COMSPEC</code>: 给出：通常是 <strong>cmd.exe</strong>，它会返回命令的退出状态。在使用非原生 Shell 的系统上，请查阅 Shell 的文档。</p>
<p><code>subprocess</code> 模块提供了更强大的工具来生成新进程并跟踪执行结果，使用该模块比使用本函数更好。</p>
<p>在 Unix 上，<code>waitstatus_to_exitcode()</code> 可以将返回值（即退出状态）转换为退出码。在 Windows 上，返回值就是退出码。</p>
<p>引发一个 审计事件 <code>os.system</code>，附带参数 <code>command</code>。</p>
<p>可用性: Unix, Windows。</p>
<p><code>os.times</code>()</p>
<p>返回当前的全局进程时间。返回值是一个有 5 个属性的对象：</p>
<ul>
<li><code>user</code> - 用户时间</li>
<li><code>system</code> - 系统时间</li>
<li><code>children_user</code> - 所有子进程的用户时间</li>
<li><code>children_system</code> - 所有子进程的系统时间</li>
<li><code>elapsed</code> - 从过去的固定时间点起，经过的真实时间</li>
</ul>
<p>为了向后兼容，该对象的行为也类似于五元组，按照 <code>user</code>，<code>system</code>，<code>children_user</code>，<code>children_system</code> 和 <code>elapsed</code> 顺序组成。</p>
<p>在 Windows 上，只有 <code>user</code> 和 <code>system</code> 是已知的，其他属性均为零。</p>
<p>可用性: Unix, Windows。</p>
<p>在 3.3 版更改: 返回结果的类型由元组变成一个类似元组的对象，同时具有命名的属性。</p>
<p><code>os.wait</code>()</p>
<p>等待子进程执行完毕，返回一个元组，包含其 pid 和退出状态指示：一个 16 位数字，其低字节是终止该进程的信号编号，高字节是退出状态码（信号编号为零的情况下），如果生成了核心文件，则低字节的高位会置位。</p>
<p>可以使用 <code>waitstatus_to_exitcode()</code> 来将退出状态转换为退出码。</p>
<p>可用性: Unix。</p>
<p>参见</p>
<p><code>waitpid()</code> 可以等待特定的子进程执行完毕，且支持更多选项。</p>
<p><code>os.waitid</code>(<em>idtype</em>, <em>id</em>, <em>options</em>)</p>
<p>等待一个或多个子进程执行完毕。<em>idtype</em> 可以是 <code>P_PID</code>, <code>P_PGID</code>, <code>P_ALL</code>, 或 <code>P_PIDFD</code> （Linux 可用）。<em>id</em> 指定要等待的 pid。<em>options</em> 是由 <code>WEXITED</code>、<code>WSTOPPED</code> 或 <code>WCONTINUED</code> 中的一个或多个进行或运算构造的，且额外可以与 <code>WNOHANG</code> 或 <code>WNOWAIT</code> 进行或运算。返回值是一个对象，对应着 <code>siginfo_t</code> 结构体中的数据，即： <code>si_pid</code>, <code>si_uid</code>, <code>si_signo</code>, <code>si_status</code>, <code>si_code</code> 或 <code>None</code> （如果指定了 <code>WNOHANG</code> 且没有子进程处于等待状态）。</p>
<p>可用性: Unix。</p>
<p>3.3 新版功能.</p>
<pre><code>os.P_PID
os.P_PGID
os.P_ALL</code></pre><p><code>waitid()</code> 的 <em>idtype</em> 参数的可取值。它们影响 <em>id</em> 的解释方式。</p>
<p>可用性: Unix。</p>
<p>3.3 新版功能.</p>
<pre><code>os.P_PIDFD</code></pre><p>这是仅 Linux 上存在的一种 <em>idtype*，它表示 *id</em> 是指向一个进程的文件描述符。</p>
<p>可用性: Linux 5.4+</p>
<p>3.9 新版功能.</p>
<pre><code>os.WEXITED
os.WSTOPPED
os.WNOWAIT</code></pre><p>用于 <code>waitid()</code> 的 <em>options</em> 参数的标志位，指定要等待的子进程信号。</p>
<p>可用性: Unix。</p>
<p>3.3 新版功能.</p>
<pre><code>os.CLD_EXITED
os.CLD_KILLED
os.CLD_DUMPED
os.CLD_TRAPPED
os.CLD_STOPPED
os.CLD_CONTINUED</code></pre><p><code>waitid()</code> 返回的结果中，<code>si_code</code> 的可取值。</p>
<p>可用性: Unix。</p>
<p>3.3 新版功能.</p>
<p>在 3.9 版更改: 添加了 <code>CLD_KILLED</code> 和 <code>CLD_STOPPED</code> 值。</p>
<p><code>os.waitpid</code>(<em>pid</em>, <em>options</em>)</p>
<p>本函数的细节在 Unix 和 Windows 上有不同之处。</p>
<p>在 Unix 上：等待进程号为 <em>pid</em> 的子进程执行完毕，返回一个元组，内含其进程 ID 和退出状态指示（编码与 <code>wait()</code> 相同）。调用的语义受整数 <em>options</em> 的影响，常规操作下该值应为 <code>0</code>。</p>
<p>如果 <em>pid</em> 大于 <code>0</code>，则 <code>waitpid()</code> 会获取该指定进程的状态信息。如果 <em>pid</em> 为 <code>0</code>，则获取当前进程所在进程组中的所有子进程的状态。如果 <em>pid</em> 为 <code>-1</code>，则获取当前进程的子进程状态。如果 <em>pid</em> 小于 <code>-1</code>，则获取进程组 <code>-pid</code> （ <em>pid</em> 的绝对值）中所有进程的状态。</p>
<p>当系统调用返回 -1 时，将抛出带有错误码的 <code>OSError</code> 异常。</p>
<p>在 Windows 上：等待句柄为 <em>pid</em> 的进程执行完毕，返回一个元组，内含 <em>pid</em> 以及左移 8 位后的退出状态码（移位简化了跨平台使用本函数）。小于或等于 <code>0</code> 的 <em>pid</em> 在 Windows 上没有特殊含义，且会抛出异常。整数值 <em>options</em> 无效。<em>pid</em> 可以指向任何 ID 已知的进程，不一定是子进程。调用 <code>spawn*</code> 函数时传入 <code>P_NOWAIT</code> 将返回合适的进程句柄。</p>
<p>可以使用 <code>waitstatus_to_exitcode()</code> 来将退出状态转换为退出码。</p>
<p>在 3.5 版更改: 如果系统调用被中断，但信号处理程序没有触发异常，此函数现在会重试系统调用，而不是触发 <code>InterruptedError</code> 异常 (原因详见 <a href="https://www.python.org/dev/peps/pep-0475" target="_blank" rel="noopener"><strong>PEP 475</strong></a>)。</p>
<p><code>os.wait3</code>(<em>options</em>)</p>
<p>与 <code>waitpid()</code> 相似，差别在于没有进程 ID 参数，且返回一个 3 元组，其中包括子进程 ID，退出状态指示和资源使用信息。option 参数与传入 <code>waitpid()</code> 和 <code>wait4()</code> 的相同。</p>
<p>可以使用 <code>waitstatus_to_exitcode()</code> 来将退出状态转换为退出码。</p>
<p>可用性: Unix。</p>
<p><code>os.wait4</code>(<em>pid</em>, <em>options</em>)</p>
<p>与 <code>waitpid()</code> 相似，差别在本方法返回一个 3 元组，其中包括子进程 ID，退出状态指示和资源使用信息。<code>wait4()</code> 的参数与 <code>waitpid()</code> 的参数相同。</p>
<p>可以使用 <code>waitstatus_to_exitcode()</code> 来将退出状态转换为退出码。</p>
<p>可用性: Unix。</p>
<p><code>os.waitstatus_to_exitcode</code>(<em>status</em>)</p>
<p>将等待状态转换为退出码。</p>
<p>在 Unix 上：</p>
<ul>
<li>如果进程正常退出（当 <code>WIFEXITED(status)</code> 为真值），则返回进程退出状态 (返回 <code>WEXITSTATUS(status)</code>): 结果值大于等于 0。</li>
<li>如果进程被信号终止（当 <code>WIFSIGNALED(status)</code> 为真值），则返回 <code>-signum</code> 其中 <em>signum</em> 为导致进程终止的信号数值 (返回 <code>-WTERMSIG(status)</code>): 结果值小于 0。</li>
<li>否则将抛出 <code>ValueError</code> 异常。</li>
</ul>
<p>在 Windows 上，返回 <em>status</em> 右移 8 位的结果。</p>
<p>在 Unix 上，如果进程正被追踪或 <code>waitpid()</code> 附带 <code>WUNTRACED</code> 选项被调用，则调用者必须先检查 <code>WIFSTOPPED(status)</code> 是否为真值。 如果 <code>WIFSTOPPED(status)</code> 为真值则此函数不可被调用。</p>
<p>参见</p>
<p><code>WIFEXITED()</code>, <code>WEXITSTATUS()</code>, <code>WIFSIGNALED()</code>, <code>WTERMSIG()</code>, <code>WIFSTOPPED()</code>, <code>WSTOPSIG()</code> 函数。</p>
<p>3.9 新版功能.</p>
<pre><code>os.WNOHANG</code></pre><p>用于 <code>waitpid()</code> 的选项，如果没有立即可用的子进程状态，则立即返回。在这种情况下，函数返回 <code>(0, 0)</code>。</p>
<p>可用性: Unix。</p>
<pre><code>os.WCONTINUED</code></pre><p>被任务控制 (job control) 停止的子进程，如果上次报告状态后已恢复运行，则此选项将报告这些子进程。</p>
<p>可用性: 部分 Unix 系统。</p>
<pre><code>os.WUNTRACED</code></pre><p>已停止的子进程，如果自停止以来尚未报告其当前状态，则此选项将报告这些子进程。</p>
<p>可用性: Unix。</p>
<p>下列函数采用进程状态码作为参数，状态码由 <code>system()</code>、<code>wait()</code> 或 <code>waitpid()</code> 返回。它们可用于确定进程上发生的操作。</p>
<p><code>os.WCOREDUMP</code>(<em>status</em>)</p>
<p>如果为该进程生成了核心转储，返回 <code>True</code>，否则返回 <code>False</code>。</p>
<p>此函数应当仅在 <code>WIFSIGNALED()</code> 为真值时使用。</p>
<p>可用性: Unix。</p>
<p><code>os.WIFCONTINUED</code>(<em>status</em>)</p>
<p>如果一个已停止的子进程通过传送 <code>SIGCONT</code> 获得恢复（如果该进程是从任务控制停止后再继续的）则返回 <code>True</code>，否则返回 <code>False</code>。</p>
<p>参见 <code>WCONTINUED</code> 选项。</p>
<p>可用性: Unix。</p>
<p><code>os.WIFSTOPPED</code>(<em>status</em>)</p>
<p>如果进程是通过传送一个信号来停止的则返回 <code>True</code>，否则返回 <code>False</code>。</p>
<p><code>WIFSTOPPED()</code> 只有在当 <code>waitpid()</code> 调用是通过使用 <code>WUNTRACED</code> 选项来完成或者当该进程正被追踪时 才返回 <code>True</code>。</p>
<p>可用性: Unix。</p>
<p><code>os.WIFSIGNALED</code>(<em>status</em>)</p>
<p>如果进程是通过一个信号来终止的则返回 <code>True</code> ，否则返回 <code>False</code>。</p>
<p>可用性: Unix。</p>
<p><code>os.WIFEXITED</code>(<em>status</em>)</p>
<p>如果进程正常终止退出则返回 <code>True</code>，也就是说通过调用 <code>exit()</code> 或 <code>_exit()</code>，或者通过从 <code>main()</code> 返回；在其他情况下则返回 <code>False</code>。</p>
<p>可用性: Unix。</p>
<p><code>os.WEXITSTATUS</code>(<em>status</em>)</p>
<p>返回进程退出状态。</p>
<p>此函数应当仅在 <code>WIFEXITED()</code> 为真值时使用。</p>
<p>可用性: Unix。</p>
<p><code>os.WSTOPSIG</code>(<em>status</em>)</p>
<p>返回导致进程停止的信号。</p>
<p>此函数应当仅在 <code>WIFSTOPPED()</code> 为真值时使用。</p>
<p>可用性: Unix。</p>
<p><code>os.WTERMSIG</code>(<em>status</em>)</p>
<p>返回导致进程终止的信号的编号。</p>
<p>此函数应当仅在 <code>WIFSIGNALED()</code> 为真值时使用。</p>
<p>可用性: Unix。</p>
<h3 id="调度器接口"><a href="#调度器接口" class="headerlink" title="调度器接口"></a>调度器接口</h3><p>这些函数控制操作系统如何为进程分配 CPU 时间。 它们仅在某些 Unix 平台上可用。 更多细节信息请查阅你所用 Unix 的指南页面。</p>
<p>3.3 新版功能.</p>
<p>以下调度策略如果被操作系统支持就会对外公开。</p>
<pre><code>os.SCHED_OTHER</code></pre><p>默认调度策略。</p>
<pre><code>os.SCHED_BATCH</code></pre><p>用于 CPU 密集型进程的调度策略，它会尽量为计算机中的其余任务保留交互性。</p>
<pre><code>os.SCHED_IDLE</code></pre><p>用于极低优先级的后台任务的调度策略。</p>
<pre><code>os.SCHED_SPORADIC</code></pre><p>用于偶发型服务程序的调度策略。</p>
<pre><code>os.SCHED_FIFO</code></pre><p>先进先出的调度策略。</p>
<pre><code>os.SCHED_RR</code></pre><p>循环式的调度策略。</p>
<pre><code>os.SCHED_RESET_ON_FORK</code></pre><p>此旗标可与任何其他调度策略进行 OR 运算。 当带有此旗标的进程设置分叉时，其子进程的调度策略和优先级会被重置为默认值。</p>
<p><em>class</em> <code>os.sched_param</code>(<em>sched_priority</em>)</p>
<p>这个类表示在 <code>sched_setparam()</code>, <code>sched_setscheduler()</code> 和 <code>sched_getparam()</code> 中使用的可修改调度形参。 它属于不可变对象。</p>
<p>目前它只有一个可能的形参：</p>
<ul>
<li><p><code>sched_priority</code></p>
<p>一个调度策略的调度优先级。</p>
</li>
</ul>
<p><code>os.sched_get_priority_min</code>(<em>policy</em>)</p>
<p>获取 <em>policy</em> 的最低优先级数值。 <em>policy</em> 是以上调度策略常量之一。</p>
<p><code>os.sched_get_priority_max</code>(<em>policy</em>)</p>
<p>获取 <em>policy</em> 的最高优先级数值。 <em>policy</em> 是以上调度策略常量之一。</p>
<p><code>os.sched_setscheduler</code>(<em>pid</em>, <em>policy</em>, <em>param</em>)</p>
<p>设置 PID 为 <em>pid</em> 的进程的调度策略。<em>pid</em> 为 0 指的是调用本方法的进程。<em>policy</em> 是以上调度策略常量之一。<em>param</em> 是一个 <code>sched_param</code> 实例。</p>
<p><code>os.sched_getscheduler</code>(<em>pid</em>)</p>
<p>返回 PID 为 <em>pid</em> 的进程的调度策略。<em>pid</em> 为 0 指的是调用本方法的进程。返回的结果是以上调度策略常量之一。</p>
<p><code>os.sched_setparam</code>(<em>pid</em>, <em>param</em>)</p>
<p>设置 PID 为 <em>pid</em> 的进程的调度参数。 <em>pid</em> 为 0 表示调用方过程。 <em>param</em> 是一个 <code>sched_param</code> 实例。</p>
<p><code>os.sched_getparam</code>(<em>pid</em>)</p>
<p>返回 PID 为 <em>pid</em> 的进程的调度参数为一个 <code>sched_param</code> 实例。<em>pid</em> 为 0 指的是调用本方法的进程。</p>
<p><code>os.sched_rr_get_interval</code>(<em>pid</em>)</p>
<p>返回 PID 为 <em>pid</em> 的进程在时间片轮转调度下的时间片长度（单位为秒）。<em>pid</em> 为 0 指的是调用本方法的进程。</p>
<p><code>os.sched_yield</code>()</p>
<p>自愿放弃 CPU。</p>
<p><code>os.sched_setaffinity</code>(<em>pid</em>, <em>mask</em>)</p>
<p>将 PID 为 <em>pid</em> 的进程（为零则为当前进程）限制到一组 CPU 上。<em>mask</em> 是整数的可迭代对象，表示应将进程限制在其中的一组 CPU。</p>
<p><code>os.sched_getaffinity</code>(<em>pid</em>)</p>
<p>返回 PID 为 <em>pid</em> 的进程（为零则为当前进程）被限制到的那一组 CPU。</p>
<h3 id="其他系统信息"><a href="#其他系统信息" class="headerlink" title="其他系统信息"></a>其他系统信息</h3><p><code>os.confstr</code>(<em>name</em>)</p>
<p>返回字符串格式的系统配置信息。<em>name</em> 指定要查找的配置名称，它可以是字符串，是一个系统已定义的名称，这些名称定义在不同标准（POSIX，Unix 95，Unix 98 等）中。一些平台还定义了额外的其他名称。当前操作系统已定义的名称在 <code>confstr_names</code> 字典的键中给出。对于未包含在该映射中的配置名称，也可以传递一个整数作为 <em>name</em>。</p>
<p>如果 <em>name</em> 指定的配置值未定义，返回 <code>None</code>。</p>
<p>如果 <em>name</em> 是一个字符串且不是已定义的名称，将抛出 <code>ValueError</code> 异常。如果当前系统不支持 <em>name</em> 指定的配置名称，即使该名称存在于 <code>confstr_names</code>，也会抛出 <code>OSError</code> 异常，错误码为 <code>errno.EINVAL</code>。</p>
<p>可用性: Unix。</p>
<pre><code>os.confstr_names</code></pre><p>字典，表示映射关系，为 <code>confstr()</code> 可接受名称与操作系统为这些名称定义的整数值之间的映射。这可用于判断系统已定义了哪些名称。</p>
<p>可用性: Unix。</p>
<p><code>os.cpu_count</code>()</p>
<p>返回系统的 CPU 数量。不确定则返回 <code>None</code>。</p>
<p>该数量不同于当前进程可以使用的CPU数量。可用的CPU数量可以由 <code>len(os.sched_getaffinity(0))</code> 方法获得。</p>
<p>3.4 新版功能.</p>
<p><code>os.getloadavg</code>()</p>
<p>返回系统运行队列中最近 1、5 和 15 分钟内的平均进程数。无法获得平均负载则抛出 <code>OSError</code> 异常。</p>
<p>可用性: Unix。</p>
<p><code>os.sysconf</code>(<em>name</em>)</p>
<p>返回整数格式的系统配置信息。如果 <em>name</em> 指定的配置值未定义，返回 <code>-1</code>。对 <code>confstr()</code> 的 <em>name</em> 参数的注释在此处也适用。当前已知的配置名称在 <code>sysconf_names</code> 字典中提供。</p>
<p>可用性: Unix。</p>
<pre><code>os.sysconf_names</code></pre><p>字典，表示映射关系，为 <code>sysconf()</code> 可接受名称与操作系统为这些名称定义的整数值之间的映射。这可用于判断系统已定义了哪些名称。</p>
<p>可用性: Unix。</p>
<p>以下数据值用于支持对路径本身的操作。所有平台都有定义。</p>
<p>对路径的高级操作在 <code>os.path</code> 模块中定义。</p>
<pre><code>os.curdir</code></pre><p>操作系统用来表示当前目录的常量字符串。在 Windows 和 POSIX 上是 <code>'.'</code>。在 <code>os.path</code> 中也可用。</p>
<pre><code>os.pardir</code></pre><p>操作系统用来表示父目录的常量字符串。在 Windows 和 POSIX 上是 <code>'..'</code>。在 <code>os.path</code> 中也可用。</p>
<pre><code>os.sep</code></pre><p>操作系统用来分隔路径不同部分的字符。在 POSIX 上是 <code>'/'</code>，在 Windows 上是是 <code>'\\'</code>。注意，仅了解它不足以能解析或连接路径，请使用 <code>os.path.split()</code> 和 <code>os.path.join()</code>，但它有时是有用的。在 <code>os.path</code> 中也可用。</p>
<pre><code>os.altsep</code></pre><p>操作系统用来分隔路径不同部分的替代字符。如果仅存在一个分隔符，则为 <code>None</code>。在 <code>sep</code> 是反斜杠的 Windows 系统上，该值被设为 <code>'/'</code>。在 <code>os.path</code> 中也可用。</p>
<pre><code>os.extsep</code></pre><p>分隔基本文件名与扩展名的字符，如 <code>os.py</code> 中的 <code>'.'</code>。在 <code>os.path</code> 中也可用。</p>
<pre><code>os.pathsep</code></pre><p>操作系统通常用于分隔搜索路径（如 <code>PATH</code>）中不同部分的字符，如 POSIX 上是 <code>':'</code>，Windows 上是 <code>';'</code>。在 <code>os.path</code> 中也可用。</p>
<pre><code>os.defpath</code></pre><p>在环境变量没有 <code>'PATH'</code> 键的情况下，<code>exec*p*</code> and <code>spawn*p*</code> 使用的默认搜索路径。在 <code>os.path</code> 中也可用。</p>
<pre><code>os.linesep</code></pre><p>当前平台用于分隔（或终止）行的字符串。它可以是单个字符，如 POSIX 上是 <code>'\n'</code>，也可以是多个字符，如 Windows 上是 <code>'\r\n'</code>。在写入以文本模式（默认模式）打开的文件时，请不要使用 <em>os.linesep</em> 作为行终止符，请在所有平台上都使用一个 <code>'\n'</code> 代替。</p>
<pre><code>os.devnull</code></pre><p>空设备的文件路径。如 POSIX 上为 <code>'/dev/null'</code>，Windows 上为 <code>'nul'</code>。在 <code>os.path</code> 中也可用。</p>
<pre><code>os.RTLD_LAZY
os.RTLD_NOW
os.RTLD_GLOBAL
os.RTLD_LOCAL
os.RTLD_NODELETE
os.RTLD_NOLOAD
os.RTLD_DEEPBIND</code></pre><p><code>setdlopenflags()</code> 和 <code>getdlopenflags()</code> 函数所使用的标志。</p>
<p>3.3 新版功能.</p>
<h3 id="随机数-1"><a href="#随机数-1" class="headerlink" title="随机数"></a>随机数</h3><p><code>os.getrandom</code>(<em>size</em>, <em>flags=0</em>)</p>
<p>获得最多为 <em>size</em> 的随机字节。本函数返回的字节数可能少于请求的字节数。</p>
<p>这些字节可用于为用户空间的随机数生成器提供种子，或用于加密目的。</p>
<p><code>getrandom()</code> 依赖于从设备驱动程序和其他环境噪声源收集的熵。不必要地读取大量数据将对使用 <code>/dev/random</code> 和 <code>/dev/urandom</code> 设备的其他用户产生负面影响。</p>
<p>flags 参数是一个位掩码，可以是零个或多个下列值以或运算组合： <code>os.GRND_RANDOM</code> 和 <code>GRND_NONBLOCK</code>。</p>
<p>可用性：Linux 3.17 或更高版本。</p>
<p>3.6 新版功能.</p>
<p><code>os.urandom</code>(<em>size</em>)</p>
<p>返回大小为 <em>size</em> 的字符串，它是适合加密使用的随机字节。</p>
<p>本函数从系统指定的随机源获取随机字节。对于加密应用程序，返回的数据应有足够的不可预测性，尽管其确切的品质取决于操作系统的实现。</p>
<p>在 Linux 上，如果 <code>getrandom()</code> 系统调用可用，它将以阻塞模式使用：阻塞直到系统的 urandom 熵池初始化完毕（内核收集了 128 位熵）。原理请参阅 <a href="https://www.python.org/dev/peps/pep-0524" target="_blank" rel="noopener"><strong>PEP 524</strong></a>。在 Linux 上，<code>getrandom()</code> 可以以非阻塞模式（使用 <code>GRND_NONBLOCK</code> 标志）获取随机字节，或者轮询直到系统的 urandom 熵池初始化完毕。</p>
<p>在类 Unix 系统上，随机字节是从 <code>/dev/urandom</code> 设备读取的。如果 <code>/dev/urandom</code> 设备不可用或不可读，则抛出 <code>NotImplementedError</code> 异常。</p>
<p>在 Windows 上将使用 <code>CryptGenRandom()</code>。</p>
<p>参见</p>
<p><code>secrets</code> 模块提供了更高级的功能。所在平台会提供随机数生成器，有关其易于使用的接口。</p>
<p>在 3.6.0 版更改: 在 Linux 上，<code>getrandom()</code> 现在以阻塞模式使用，以提高安全性。</p>
<p>在 3.5.2 版更改: 在 Linux 上，如果 <code>getrandom()</code> 系统调用阻塞（urandom 熵池尚未初始化完毕），则退回一步读取 <code>/dev/urandom</code>。</p>
<p>在 3.5 版更改: 在 Linux 3.17 和更高版本上，现在使用 <code>getrandom()</code> 系统调用（如果可用）。在 OpenBSD 5.6 和更高版本上，现在使用 <code>getentropy()</code> C 函数。这些函数避免了使用内部文件描述符。</p>
<pre><code>os.GRND_NONBLOCK</code></pre><p>默认情况下，从 <code>/dev/random</code> 读取时，如果没有可用的随机字节，则 <code>getrandom()</code> 会阻塞；从 <code>/dev/urandom</code> 读取时，如果熵池尚未初始化，则会阻塞。</p>
<p>如果设置了 <code>GRND_NONBLOCK</code> 标志，则这些情况下 <code>getrandom()</code> 不会阻塞，而是立即抛出 <code>BlockingIOError</code> 异常。</p>
<p>3.6 新版功能.</p>
<pre><code>os.GRND_RANDOM</code></pre><p>如果设置了此标志位，那么将从 <code>/dev/random</code> 池而不是 <code>/dev/urandom</code> 池中提取随机字节。</p>
<p>3.6 新版功能.</p>
<h2 id="io-—-处理流的核心工具"><a href="#io-—-处理流的核心工具" class="headerlink" title="io —- 处理流的核心工具"></a><code>io</code> —- 处理流的核心工具</h2><p><strong>源代码:</strong> <a href="https://github.com/python/cpython/tree/3.10/Lib/io.py" target="_blank" rel="noopener">Lib/io.py</a></p>
<hr>
<h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p><code>io</code> 模块提供了 Python 用于处理各种 I/O 类型的主要工具。三种主要的 I/O类型分别为: <em>文本 I/O</em>, <em>二进制 I/O</em> 和 <em>原始 I/O*。这些是泛型类型，有很多种后端存储可以用在他们上面。一个隶属于任何这些类型的具体对象被称作 file object。 其他同类的术语还有 *流</em> 和 <em>类文件对象</em>。</p>
<p>独立于其类别，每个具体流对象也将具有各种功能：它可以是只读，只写或读写。它还可以允许任意随机访问（向前或向后寻找任何位置），或仅允许顺序访问（例如在套接字或管道的情况下）。</p>
<p>所有流对提供给它们的数据类型都很敏感。例如将 <code>str</code> 对象给二进制流的 <code>write()</code> 方法会引发 <code>TypeError</code>。将 <code>bytes</code> 对象提供给文本流的 <code>write()</code> 方法也是如此。</p>
<p>在 3.3 版更改: 由于 <code>IOError</code> 现在是 <code>OSError</code> 的别名，因此用于引发 <code>IOError</code> 的操作现在会引发 <code>OSError</code> 。</p>
<h4 id="文本-I-O"><a href="#文本-I-O" class="headerlink" title="文本 I/O"></a>文本 I/O</h4><p>文本I/O预期并生成 <code>str</code> 对象。这意味着，无论何时后台存储是由字节组成的（例如在文件的情况下），数据的编码和解码都是透明的，并且可以选择转换特定于平台的换行符。</p>
<p>创建文本流的最简单方法是使用 <code>open()</code>，可以选择指定编码：</p>
<pre class="line-numbers language-python"><code class="language-python">f <span class="token operator">=</span> open<span class="token punctuation">(</span><span class="token string">"myfile.txt"</span><span class="token punctuation">,</span> <span class="token string">"r"</span><span class="token punctuation">,</span> encoding<span class="token operator">=</span><span class="token string">"utf-8"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>内存中文本流也可以作为 <code>StringIO</code> 对象使用：</p>
<pre class="line-numbers language-python"><code class="language-python">f <span class="token operator">=</span> io<span class="token punctuation">.</span>StringIO<span class="token punctuation">(</span><span class="token string">"some initial text data"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><code>TextIOBase</code> 的文档中详细描述了文本流的API</p>
<h4 id="二进制-I-O"><a href="#二进制-I-O" class="headerlink" title="二进制 I/O"></a>二进制 I/O</h4><p>二进制I/O（也称为缓冲I/O）预期 bytes-like objects 并生成 <code>bytes</code> 对象。不执行编码、解码或换行转换。这种类型的流可以用于所有类型的非文本数据，并且还可以在需要手动控制文本数据的处理时使用。</p>
<p>创建二进制流的最简单方法是使用 <code>open()</code>，并在模式字符串中指定 <code>'b'</code> ：</p>
<pre class="line-numbers language-python"><code class="language-python">f <span class="token operator">=</span> open<span class="token punctuation">(</span><span class="token string">"myfile.jpg"</span><span class="token punctuation">,</span> <span class="token string">"rb"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>内存中二进制流也可以作为 <code>BytesIO</code> 对象使用：</p>
<pre class="line-numbers language-python"><code class="language-python">f <span class="token operator">=</span> io<span class="token punctuation">.</span>BytesIO<span class="token punctuation">(</span>b<span class="token string">"some initial binary data: \x00\x01"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><code>BufferedIOBase</code> 的文档中详细描述了二进制流 API。</p>
<p>其他库模块可以提供额外的方式来创建文本或二进制流。</p>
<h4 id="原始-I-O"><a href="#原始-I-O" class="headerlink" title="原始 I/O"></a>原始 I/O</h4><p>原始 I/O（也称为 <em>非缓冲 I/O</em>）通常用作二进制和文本流的低级构建块。用户代码直接操作原始流的用法非常罕见。不过，可以通过在禁用缓冲的情况下以二进制模式打开文件来创建原始流：</p>
<pre class="line-numbers language-python"><code class="language-python">f <span class="token operator">=</span> open<span class="token punctuation">(</span><span class="token string">"myfile.jpg"</span><span class="token punctuation">,</span> <span class="token string">"rb"</span><span class="token punctuation">,</span> buffering<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><code>RawIOBase</code> 的文档中详细描述了原始流的API</p>
<h3 id="文本编码格式"><a href="#文本编码格式" class="headerlink" title="文本编码格式"></a>文本编码格式</h3><p><code>TextIOWrapper</code> 和 <code>open()</code> 的默认编码格式取决于语言区域设置 (<code>locale.getpreferredencoding(False)</code>).</p>
<p>但是，很多开发者在打开以 UTF-8 编码的文本文件 (例如 JSON, TOML, Markdown 等等…) 时会忘记指定编码格式，因为大多数 Unix 平台默认使用 UTF-8 语言区域。 这会导致各种错误因为大多数 Windows 用户的语言区域编码格式并不是 UTF-8。 例如:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># May not work on Windows when non-ASCII characters in the file.</span>
<span class="token keyword">with</span> open<span class="token punctuation">(</span><span class="token string">"README.md"</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span>
    long_description <span class="token operator">=</span> f<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>此外，虽然暂时还没有确定的计划，但 Python 可能会在未来将默认的文本文件编码格式改为 UTF-8。</p>
<p>为此，强烈建议你在打开文本文件时显式地指定编码格式。 如果你想要使用 UTF-8，请传入 <code>encoding="utf-8"</code>。 要使用当前语言区域的编码格式，<code>encoding="locale"</code> 已在 Python 3.10 中被支持。</p>
<p>当你需要在 Windows 上运行尝试使用默认语言区域的编码格式打开使用 UTF-8 的文件的现有代码时，你可以启动 UTF-8 模式。 参见 Windows 上的 UTF-8 模式。</p>
<h4 id="选择性的-EncodingWarning"><a href="#选择性的-EncodingWarning" class="headerlink" title="选择性的 EncodingWarning"></a>选择性的 EncodingWarning</h4><p>3.10 新版功能: 请参阅 <a href="https://www.python.org/dev/peps/pep-0597" target="_blank" rel="noopener"><strong>PEP 597</strong></a> 了解详情。</p>
<p>要找出哪里使用了默认语言区域的编码格式，你可以启用 <code>-X warn_default_encoding</code> 命令行选项或设置 <code>PYTHONWARNDEFAULTENCODING</code> 环境变量，这将在使用默认编码格式时发出 <code>EncodingWarning</code>。</p>
<p>如果你提供了使用 <code>open()</code> 或 <code>TextIOWrapper</code> 的 API 并将 <code>encoding=None</code> 作为形参传入，你可以使用 <code>text_encoding()</code> 以便 API 的调用方在没有传入 <code>encoding</code> 的时候将发出 <code>EncodingWarning</code>。 但是，对于新的 API 请考虑默认就使用 UTF-8 (即 <code>encoding="utf-8"</code>)。</p>
<h3 id="高阶模块接口"><a href="#高阶模块接口" class="headerlink" title="高阶模块接口"></a>高阶模块接口</h3><pre><code>io.DEFAULT_BUFFER_SIZE</code></pre><p>包含模块缓冲 I/O 类使用的默认缓冲区大小的 int。 在可能的情况下 <code>open()</code> 将使用文件的 blksize（由 <code>os.stat()</code> 获得）。</p>
<p><code>io.open</code>(<em>file</em>, <em>mode=’r’</em>, <em>buffering=- 1</em>, <em>encoding=None</em>, <em>errors=None</em>, <em>newline=None</em>, <em>closefd=True</em>, <em>opener=None</em>)</p>
<p>这是内置的 <code>open()</code> 函数的别名。</p>
<p><code>open</code> 附带参数 <code>path</code>、<code>mode</code>、<code>flags</code> 会引发 审计事件。</p>
<p><code>io.open_code</code>(<em>path</em>)</p>
<p>以 <code>'rb'</code> 模式打开提供的文件。如果目的是将文件内容做为可执行代码，则应使用此函数。</p>
<p><code>path</code> 应当为 <code>str</code> 类型并且是一个绝对路径。</p>
<p>此函数的行为可以由对 <code>PyFile_SetOpenCodeHook()</code> 的先期调用所重载。 但是，如果 <code>path</code> 为 <code>str</code> 类型并且是一个绝对路径，<code>open_code(path)</code> 的行为应当总是与 <code>open(path, 'rb')</code> 一致。 重载此行为的目的是为了给文件附加额外的验证或预处理。</p>
<p>3.8 新版功能.</p>
<p><code>io.text_encoding</code>(<em>encoding</em>, <em>stacklevel=2</em>)</p>
<p>这是一个针对使用 <code>open()</code> 或 <code>TextIOWrapper</code> 的可调用对象的辅助函数并且具有 <code>encoding=None</code> 形参。</p>
<p>此函数会返回 <em>encoding*，如果它不为 <code>None</code> 的话，或是 <code>"locale"</code> ，如果 *encoding</em> 为 <code>None</code> 的话。</p>
<p>如果 <code>sys.flags.warn_default_encoding</code> 为真值并且 <em>encoding</em> 为 None 则此函数会发出 <code>EncodingWarning</code>。 <em>stacklevel</em> 指定在哪里发出警告。 例如:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">read_text</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span> encoding<span class="token operator">=</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>
    encoding <span class="token operator">=</span> io<span class="token punctuation">.</span>text_encoding<span class="token punctuation">(</span>encoding<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># stacklevel=2</span>
    <span class="token keyword">with</span> open<span class="token punctuation">(</span>path<span class="token punctuation">,</span> encoding<span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span>
        <span class="token keyword">return</span> f<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>在这个例子中，将为 <code>read_text()</code> 的调用方发出 <code>EncodingWarning</code>。</p>
<p>3.10 新版功能.</p>
<p><em>exception</em> <code>io.BlockingIOError</code></p>
<p>这是内置的 <code>BlockingIOError</code> 异常的兼容性别名。</p>
<p><em>exception</em> <code>io.UnsupportedOperation</code></p>
<p>在流上调用不支持的操作时引发的继承 <code>OSError</code> 和 <code>ValueError</code> 的异常。</p>
<p>包含标准IO流: <code>sys.stdin</code>, <code>sys.stdout</code> 和 <code>sys.stderr</code> 。</p>
<h3 id="类的层次结构"><a href="#类的层次结构" class="headerlink" title="类的层次结构"></a>类的层次结构</h3><p>I/O 流被安排为按类的层次结构实现。 首先是 抽象基类 (ABC)，用于指定流的各种类别，然后是提供标准流实现的具体类。</p>
<blockquote>
<p>注解</p>
<p>抽象基类还提供某些方法的默认实现，以帮助实现具体的流类。例如 <code>BufferedIOBase</code> 提供了 <code>readinto()</code> 和 <code>readline()</code> 的未优化实现。</p>
</blockquote>
<p>I/O层次结构的顶部是抽象基类 <code>IOBase</code> 。它定义了流的基本接口。但是请注意，对流的读取和写入之间没有分离。如果实现不支持指定的操作，则会引发 <code>UnsupportedOperation</code> 。</p>
<p>抽象基类 <code>RawIOBase</code> 是 <code>IOBase</code> 的子类。它负责将字节读取和写入流中。 <code>RawIOBase</code> 的子类 <code>FileIO</code> 提供计算机文件系统中文件的接口。</p>
<p>抽象基类 <code>BufferedIOBase</code> 继承了 <code>IOBase</code> ，处理原始二进制流（ <code>RawIOBase</code> ）上的缓冲。其子类 <code>BufferedWriter</code> 、 <code>BufferedReader</code> 和 <code>BufferedRWPair</code> 分别缓冲可读、可写以及可读写的原始二进制流。 <code>BufferedRandom</code> 提供了带缓冲的可随机访问流接口。 <code>BufferedIOBase</code> 的另一个子类 <code>BytesIO</code> 是内存中字节流。</p>
<p>抽象基类 <code>TextIOBase</code> 继承了 <code>IOBase</code> 。它处理可表示文本的流，并处理字符串的编码和解码。类 <code>TextIOWrapper</code> 继承了 <code>TextIOBase</code> ，是原始缓冲流（ <code>BufferedIOBase</code> ）的缓冲文本接口。最后， <code>StringIO</code> 是文本的内存流。</p>
<p>参数名不是规范的一部分，只有 <code>open()</code> 的参数才用作关键字参数。</p>
<p>下表总结了抽象基类提供的 <code>io</code> 模块：</p>
<table>
<thead>
<tr>
<th align="left">抽象基类</th>
<th align="left">继承</th>
<th align="left">抽象方法</th>
<th align="left">Mixin方法和属性</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>IOBase</code></td>
<td align="left"></td>
<td align="left"><code>fileno</code>, <code>seek</code>, 和 <code>truncate</code></td>
<td align="left"><code>close</code>, <code>closed</code>, <code>**enter**</code>, <code>**exit**</code>, <code>flush</code>, <code>isatty</code>, <code>**iter**</code>, <code>**next**</code>, <code>readable</code>, <code>readline</code>, <code>readlines</code>, <code>seekable</code>, <code>tell</code>, <code>writable</code> 和 <code>writelines</code></td>
</tr>
<tr>
<td align="left"><code>RawIOBase</code></td>
<td align="left"><code>IOBase</code></td>
<td align="left"><code>readinto</code> 和 <code>write</code></td>
<td align="left">继承 <code>IOBase</code> 方法, <code>read</code>, 和 <code>readall</code></td>
</tr>
<tr>
<td align="left"><code>BufferedIOBase</code></td>
<td align="left"><code>IOBase</code></td>
<td align="left"><code>detach</code>, <code>read</code>, <code>read1</code>, 和 <code>write</code></td>
<td align="left">继承 <code>IOBase</code> 方法, <code>readinto</code>, 和 <code>readinto1</code></td>
</tr>
<tr>
<td align="left"><code>TextIOBase</code></td>
<td align="left"><code>IOBase</code></td>
<td align="left"><code>detach</code>, <code>read</code>, <code>readline</code>, 和 <code>write</code></td>
<td align="left">继承 <code>IOBase</code> 方法, <code>encoding</code>, <code>errors</code>, 和 <code>newlines</code></td>
</tr>
</tbody></table>
<h4 id="I-O-基类"><a href="#I-O-基类" class="headerlink" title="I/O 基类"></a>I/O 基类</h4><p><em>class</em> <code>io.IOBase</code></p>
<p>所有 I/O 类的抽象基类，作用于字节流。没有公共构造函数。</p>
<p>此类为许多方法提供了空的抽象实现，派生类可以有选择地重写。默认实现代表一个无法读取、写入或查找的文件。</p>
<p>尽管 <code>IOBase</code> 没有声明 <code>read()</code> 或 <code>write()</code> ，因为它们的签名会有所不同，但是实现和客户端应该将这些方法视为接口的一部分。此外，当调用不支持的操作时可能会引发 <code>ValueError</code> （或 <code>UnsupportedOperation</code> ）。</p>
<p>从文件读取或写入文件的二进制数据的基本类型为 <code>bytes</code> 。其他 bytes-like objects 也可以作为方法参数。文本I/O类使用 <code>str</code> 数据。</p>
<p>请注意，在关闭的流上调用任何方法（甚至查询）都是未定义的（undefined）。在这种情况下，实现可能会引发 <code>ValueError</code> 。</p>
<p><code>IOBase</code> （及其子类）支持迭代器协议，这意味着可以迭代 <code>IOBase</code> 对象以产生流中的行。根据流是二进制流（产生字节）还是文本流（产生字符串），行的定义略有不同。请参见下面的 <code>readline()</code> 。</p>
<p><code>IOBase</code> 也是一个上下文管理器，因此支持 <code>with</code> 语句。 在这个示例中，<em>file</em> 将在 <code>with</code> 语句块执行完成之后被关闭 —- 即使是发生了异常:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">with</span> open<span class="token punctuation">(</span><span class="token string">'spam.txt'</span><span class="token punctuation">,</span> <span class="token string">'w'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> file<span class="token punctuation">:</span>
    file<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">'Spam and eggs!'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><code>IOBase</code> 提供以下数据属性和方法：</p>
<ul>
<li><p><code>close</code>()</p>
<p>刷新并关闭此流。如果文件已经关闭，则此方法无效。文件关闭后，对文件的任何操作（例如读取或写入）都会引发 <code>ValueError</code> 。</p>
<p>为方便起见，允许多次调用此方法。但是，只有第一个调用才会生效。</p>
</li>
<li><p><code>closed</code></p>
<p>如果流已关闭，则返回 True。</p>
</li>
<li><p><code>fileno</code>()</p>
<p>返回流的底层文件描述符（整数）—-如果存在。如果 IO 对象不使用文件描述符，则会引发 <code>OSError</code> 。</p>
</li>
<li><p><code>flush</code>()</p>
<p>刷新流的写入缓冲区（如果适用）。这对只读和非阻塞流不起作用。</p>
</li>
<li><p><code>isatty</code>()</p>
<p>如果流是交互式的（即连接到终端/tty设备），则返回 <code>True</code> 。</p>
</li>
<li><p><code>readable</code>()</p>
<p>如果可以读取流，则返回 <code>True</code> 。否则为 <code>False</code> ，且 <code>read()</code> 将引发 <code>OSError</code> 错误。</p>
</li>
<li><p><code>readline</code>(<em>size=- 1</em>)</p>
<p>从流中读取并返回一行。如果指定了 <em>size*，将至多读取 *size</em> 个字节。</p>
<p>对于二进制文件行结束符总是 <code>b'\n'</code>；对于文本文件，可以用将 <em>newline</em> 参数传给 <code>open()</code> 的方式来选择要识别的行结束符。</p>
</li>
<li><p><code>readlines</code>(<em>hint=- 1</em>)</p>
<p>从流中读取并返回包含多行的列表。可以指定 <em>hint</em> 来控制要读取的行数：如果（以字节/字符数表示的）所有行的总大小超出了 <em>hint</em> 则将不会读取更多的行。</p>
<p><code>0</code> 或更小的 <em>hint</em> 值以及 <code>None</code>，会被视为没有 hint。</p>
<p>请注意使用 <code>for line in file: ...</code> 就足够对文件对象进行迭代了，可以不必调用 <code>file.readlines()</code>。</p>
</li>
<li><p><code>seek</code>(<em>offset</em>, <em>whence=SEEK_SET</em>)</p>
<p>将流位置修改到给定的字节 <em>offset*。 *offset</em> 将相对于由 <em>whence</em> 指定的位置进行解析。 <em>whence</em> 的默认值为 <code>SEEK_SET</code>。 <em>whence</em> 的可用值有：</p>
<ul>
<li><code>SEEK_SET</code> 或 <code>0</code> — 流的开头（默认值）；<em>offset</em> 应为零或正值</li>
<li><code>SEEK_CUR</code> or <code>1</code> — 当前流位置；<em>offset</em> 可以为负值</li>
<li><code>SEEK_END</code> or <code>2</code> — 流的末尾；<em>offset</em> 通常为负值</li>
</ul>
<p>返回新的绝对位置。</p>
<p>3.1 新版功能: <code>SEEK_*</code> 常量.</p>
<p>3.3 新版功能: 某些操作系统还可支持其他的值，例如 <code>os.SEEK_HOLE</code> 或 <code>os.SEEK_DATA</code>。特定文件的可用值还会取决于它是以文本还是二进制模式打开。</p>
</li>
<li><p><code>seekable</code>()</p>
<p>如果流支持随机访问则返回 <code>True</code>。 如为 <code>False</code>，则 <code>seek()</code>, <code>tell()</code> 和 <code>truncate()</code> 将引发 <code>OSError</code>。</p>
</li>
<li><p><code>tell</code>()</p>
<p>返回当前流的位置。</p>
</li>
<li><p><code>truncate</code>(<em>size=None</em>)</p>
<p>将流的大小调整为给定的 <em>size</em> 个字节（如果未指定 <em>size</em> 则调整至当前位置）。 当前的流位置不变。 这个调整操作可扩展或减小当前文件大小。 在扩展的情况下，新文件区域的内容取决于具体平台（在大多数系统上，额外的字节会填充为零）。 返回新的文件大小。</p>
<p>在 3.5 版更改: 现在Windows在扩展时将文件填充为零。</p>
</li>
<li><p><code>writable</code>()</p>
<p>如果流支持写入则返回 <code>True</code>。 如为 <code>False</code>，则 <code>write()</code> 和 <code>truncate()</code> 将引发 <code>OSError</code>。</p>
</li>
<li><p><code>writelines</code>(<em>lines</em>)</p>
<p>将行列表写入到流。 不会添加行分隔符，因此通常所提供的每一行都带有末尾行分隔符。</p>
</li>
<li><p><code>__del__</code>()</p>
<p>为对象销毁进行准备。 <code>IOBase</code> 提供了此方法的默认实现，该实现会调用实例的 <code>close()</code> 方法。</p>
</li>
</ul>
<p><em>class</em> <code>io.RawIOBase</code></p>
<p>原始二进制流的基类。 它继承自 <code>IOBase</code> 类。 没有公共构造器。</p>
<p>原始二进制流通常会提供对下层 OS 设备或 API 的低层级访问，而不是尝试将其封装到高层级的基元中（此功能是在更高层级的缓冲二进制流和文本流中实现的，将在下文中描述）。</p>
<p><code>RawIOBase</code> 在 <code>IOBase</code> 的现有成员以外还提供了下列方法:</p>
<ul>
<li><p><code>read</code>(<em>size=- 1</em>)</p>
<p>从对象中读取 <em>size</em> 个字节并将其返回。 作为一个便捷选项，如果 <em>size</em> 未指定或为 -1，则返回所有字节直到 EOF。 在其他情况下，仅会执行一次系统调用。 如果操作系统调用返回字节数少于 <em>size</em> 则此方法也可能返回少于 <em>size</em> 个字节。</p>
<p>如果返回 0 个字节而 <em>size</em> 不为零 0，这表明到达文件末尾。 如果处于非阻塞模式并且没有更多字节可用，则返回 <code>None</code>。</p>
<p>默认实现会转至 <code>readall()</code> 和 <code>readinto()</code>。</p>
</li>
<li><p><code>readall</code>()</p>
<p>从流中读取并返回所有字节直到 EOF，如有必要将对流执行多次调用。</p>
</li>
<li><p><code>readinto</code>(<em>b</em>)</p>
<p>将字节数据读入预先分配的可写 bytes-like object <em>b</em>，并返回所读取的字节数。 例如，<em>b</em> 可以是一个 <code>bytearray</code>。 如果对象处理非阻塞模式并且没有更多字节可用，则返回 <code>None</code>。</p>
</li>
<li><p><code>write</code>(<em>b</em>)</p>
<p>将给定的 bytes-like object <em>b</em> 写入到下层的原始流，并返回所写入的字节数。 这可以少于 <em>b</em> 的总字节数，具体取决于下层原始流的设定，特别是如果它处于非阻塞模式的话。 如果原始流设为非阻塞并且不能真正向其写入单个字节时则返回 <code>None</code>。 调用者可以在此方法返回后释放或改变 <em>b</em>，因此该实现应该仅在方法调用期间访问 <em>b</em>。</p>
</li>
</ul>
<p><em>class</em> <code>io.BufferedIOBase</code></p>
<p>支持某种缓冲的二进制流的基类。 它继承自 <code>IOBase</code>。 没有公共构造器。</p>
<p>与 <code>RawIOBase</code> 的主要差别在于 <code>read()</code>, <code>readinto()</code> 和 <code>write()</code> 等方法将（分别）尝试按照要求读取尽可能多的输入或是耗尽所有给定的输出，其代价是可能会执行一次以上的系统调用。</p>
<p>除此之外，那些方法还可能引发 <code>BlockingIOError</code>，如果下层的原始数据流处于非阻塞模式并且无法接受或给出足够数据的话；不同于对应的 <code>RawIOBase</code> 方法，它们将永远不会返回 <code>None</code>。</p>
<p>并且，<code>read()</code> 方法也没有转向 <code>readinto()</code> 的默认实现。</p>
<p>典型的 <code>BufferedIOBase</code> 实现不应当继承自 <code>RawIOBase</code> 实现，而要包装一个该实现，正如 <code>BufferedWriter</code> 和 <code>BufferedReader</code> 所做的那样。</p>
<p><code>BufferedIOBase</code> 在 <code>IOBase</code> 的现有成员以外还提供或重载了下列数据属性和方法:</p>
<ul>
<li><p><code>raw</code></p>
<p>由 <code>BufferedIOBase</code> 处理的下层原始流 (<code>RawIOBase</code> 的实例)。 它不是 <code>BufferedIOBase</code> API 的组成部分并且不存在于某些实现中。</p>
</li>
<li><p><code>detach</code>()</p>
<p>从缓冲区分离出下层原始流并将其返回。</p>
<p>在原始流被分离之后，缓冲区将处于不可用的状态。</p>
<p>某些缓冲区例如 <code>BytesIO</code> 并无可从此方法返回的单独原始流的概念。 它们将会引发 <code>UnsupportedOperation</code>。</p>
<p>3.1 新版功能.</p>
</li>
<li><p><code>read</code>(<em>size=- 1</em>)</p>
<p>读取并返回最多 <em>size</em> 个字节。 如果此参数被省略、为 <code>None</code> 或为负值，则读取并返回所有数据直到 EOF。 如果流已经到达 EOF 则返回一个空的 <code>bytes</code> 对象。</p>
<p>如果此参数为正值，并且下层原始流不可交互，则可能发起多个原始读取以满足字节计数（直至先遇到 EOF）。 但对于可交互原始流，则将至多发起一个原始读取，并且简短的结果并不意味着已到达 EOF。</p>
<p><code>BlockingIOError</code> 会在下层原始流不处于阻塞模式，并且当前没有可用数据时被引发。</p>
</li>
<li><p><code>read1</code>([<em>size</em>])</p>
<p>通过至多一次对下层流的 <code>read()</code> (或 <code>readinto()</code>) 方法的调用读取并返回至多 <em>size</em> 个字节。 这适用于在 <code>BufferedIOBase</code> 对象之上实现你自己的缓冲区的情况。</p>
<p>如果 <em>size</em> 为 <code>-1</code> (默认值)，则返回任意数量的字节（多于零字节，除非已到达 EOF）。</p>
</li>
<li><p><code>readinto</code>(<em>b</em>)</p>
<p>将字节数据读入预先分配的可写 bytes-like object <em>b</em> 并返回所读取的字节数。 例如，<em>b</em> 可以是一个 <code>bytearray</code>。</p>
<p>类似于 <code>read()</code>，可能对下层原始流发起多次读取，除非后者为交互式。</p>
<p><code>BlockingIOError</code> 会在下层原始流不处于阻塞模式，并且当前没有可用数据时被引发。</p>
</li>
<li><p><code>readinto1</code>(<em>b</em>)</p>
<p>将字节数据读入预先分配的可写 bytes-like object <em>b</em>，其中至多使用一次对下层原始流 <code>read()</code> (或 <code>readinto()</code>) 方法的调用。 返回所读取的字节数。</p>
<p><code>BlockingIOError</code> 会在下层原始流不处于阻塞模式，并且当前没有可用数据时被引发。</p>
<p>3.5 新版功能.</p>
</li>
<li><p><code>write</code>(<em>b</em>)</p>
<p>写入给定的 bytes-like object <em>b</em>，并返回写入的字节数 (总是等于 <em>b</em> 的字节长度，因为如果写入失败则会引发 <code>OSError</code>)。 根据具体实现的不同，这些字节可能被实际写入下层流，或是出于运行效率和冗余等考虑而暂存于缓冲区。</p>
<p>当处于非阻塞模式时，如果需要将数据写入原始流但它无法在不阻塞的情况下接受所有数据则将引发 <code>BlockingIOError</code>。</p>
<p>调用者可能会在此方法返回后释放或改变 <em>b</em>，因此该实现应当仅在方法调用期间访问 <em>b</em>。</p>
</li>
</ul>
<h4 id="原始文件-I-O"><a href="#原始文件-I-O" class="headerlink" title="原始文件 I/O"></a>原始文件 I/O</h4><p><em>class</em> <code>io.FileIO</code>(<em>name</em>, <em>mode=’r’</em>, <em>closefd=True</em>, <em>opener=None</em>)</p>
<p>代表一个包含字节数据的 OS 层级文件的原始二进制流。 它继承自 <code>RawIOBase</code>。</p>
<p><em>name</em> 可以是以下两项之一：</p>
<ul>
<li>代表将被打开的文件路径的字符串或 <code>bytes</code> 对象。 在此情况下 closefd 必须为 <code>True</code> (默认值) 否则将会引发异常。</li>
<li>代表一个现有 OS 层级文件描述符的号码的整数，作为结果的 <code>FileIO</code> 对象将可访问该文件。 当 FileIO 对象被关闭时此 fd 也将被关闭，除非 <em>closefd</em> 设为 <code>False</code>。</li>
</ul>
<p><em>mode</em> 可以为 <code>'r'</code>, <code>'w'</code>, <code>'x'</code> 或 <code>'a'</code> 分别表示读取（默认模式）、写入、独占新建或添加。 如果以写入或添加模式打开的文件不存在将自动新建；当以写入模式打开时文件将先清空。 以新建模式打开时如果文件已存在则将引发 <code>FileExistsError</code>。 以新建模式打开文件也意味着要写入，因此该模式的行为与 <code>'w'</code> 类似。 在模式中附带 <code>'+'</code> 将允许同时读取和写入。</p>
<p>该类的 <code>read()</code> (当附带正值参数调用时), <code>readinto()</code> 和 <code>write()</code> 方法将只执行一次系统调用。</p>
<p>可以通过传入一个可调用对象作为 <em>opener</em> 来使用自定义文件打开器。 然后通过调用 <em>opener</em> 并传入 (<em>name</em>, <em>flags</em>) 来获取文件对象所对应的下层文件描述符。 <em>opener</em> 必须返回一个打开文件描述符（传入 <code>os.open</code> 作为 <em>opener</em> 的结果在功能上将与传入 <code>None</code> 类似）。</p>
<p>新创建的文件是 不可继承的。</p>
<p>有关 opener 参数的示例，请参见内置函数 <code>open()</code> 。</p>
<p>在 3.3 版更改: 增加了 <em>opener</em> 参数。增加了 <code>'x'</code> 模式。</p>
<p>在 3.4 版更改: 文件现在禁止继承。</p>
<p><code>FileIO</code> 在继承自 <code>RawIOBase</code> 和 <code>IOBase</code> 的现有成员以外还提供了以下数据属性和方法:</p>
<ul>
<li><p><code>mode</code></p>
<p>构造函数中给定的模式。</p>
</li>
<li><p><code>name</code></p>
<p>文件名。当构造函数中没有给定名称时，这是文件的文件描述符。</p>
</li>
</ul>
<h4 id="缓冲流"><a href="#缓冲流" class="headerlink" title="缓冲流"></a>缓冲流</h4><p>相比原始 I/O，缓冲 I/O 流提供了针对 I/O 设备的更高层级接口。</p>
<p><em>class</em> <code>io.BytesIO</code>([<em>initial_bytes</em>])</p>
<p>一个使用内在字节缓冲区的二进制流。 它继承自 <code>BufferedIOBase</code>。 在 <code>close()</code> 方法被调用时将会丢弃缓冲区。</p>
<p>可选参数 <em>initial_bytes</em> 是一个包含初始数据的 bytes-like object。</p>
<p><code>BytesIO</code> 在继承自 <code>BufferedIOBase</code> 和 <code>IOBase</code> 的成员以外还提供或重载了下列方法:</p>
<ul>
<li><p><code>getbuffer</code>()</p>
<p>返回一个对应于缓冲区内容的可读写视图而不必拷贝其数据。 此外，改变视图将透明地更新缓冲区内容:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> b <span class="token operator">=</span> io<span class="token punctuation">.</span>BytesIO<span class="token punctuation">(</span>b<span class="token string">"abcdef"</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> view <span class="token operator">=</span> b<span class="token punctuation">.</span>getbuffer<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> view<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> b<span class="token string">"56"</span>
<span class="token operator">>></span><span class="token operator">></span> b<span class="token punctuation">.</span>getvalue<span class="token punctuation">(</span><span class="token punctuation">)</span>
b<span class="token string">'ab56ef'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>注解</p>
<p>只要视图保持存在，<code>BytesIO</code> 对象就无法被改变大小或关闭。</p>
<p>3.2 新版功能.</p>
</li>
<li><p><code>getvalue</code>()</p>
<p>返回包含整个缓冲区内容的 <code>bytes</code>。</p>
</li>
<li><p><code>read1</code>([<em>size</em>])</p>
<p>在 <code>BytesIO</code> 中，这与 <code>read()</code> 相同。</p>
<p>在 3.7 版更改: <em>size</em> 参数现在是可选的。</p>
</li>
<li><p><code>readinto1</code>(<em>b</em>)</p>
<p>在 <code>BytesIO</code> 中，这与 <code>readinto()</code> 相同。</p>
<p>3.5 新版功能.</p>
</li>
</ul>
<p><em>class</em> <code>io.BufferedReader</code>(<em>raw</em>, <em>buffer_size=DEFAULT_BUFFER_SIZE</em>)</p>
<p>一个提供对可读、不可查找的 <code>RawIOBase</code> 原始二进制流的高层级访问的缓冲二进制流。 它继承自 <code>BufferedIOBase</code>。</p>
<p>当从此对象读取数据时，可能会从下层原始流请求更大量的数据，并存放到内部缓冲区中。 接下来可以在后续读取时直接返回缓冲数据。</p>
<p>根据给定的可读 <em>raw</em> 流和 <em>buffer_size</em> 创建 <code>BufferedReader</code> 的构造器。 如果省略 <em>buffer_size</em>，则会使用 <code>DEFAULT_BUFFER_SIZE</code>。</p>
<p><code>BufferedReader</code> 在继承自 <code>BufferedIOBase</code> 和 <code>IOBase</code> 的成员以外还提供或重载了下列方法:</p>
<ul>
<li><p><code>peek</code>([<em>size</em>])</p>
<p>从流返回字节数据而不前移位置。 完成此调用将至多读取一次原始流。 返回的字节数量可能少于或多于请求的数量。</p>
</li>
<li><p><code>read</code>([<em>size</em>])</p>
<p>读取并返回 <em>size</em> 个字节，如果 <em>size</em> 未给定或为负值，则读取至 EOF 或是在非阻塞模式下读取调用将会阻塞。</p>
</li>
<li><p><code>read1</code>([<em>size</em>])</p>
<p>在原始流上通过单次调用读取并返回至多 <em>size</em> 个字节。 如果至少缓冲了一个字节，则只返回缓冲的字节。 在其他情况下，将执行一次原始流读取。</p>
<p>在 3.7 版更改: <em>size</em> 参数现在是可选的。</p>
</li>
</ul>
<p><em>class</em> <code>io.BufferedWriter</code>(<em>raw</em>, <em>buffer_size=DEFAULT_BUFFER_SIZE</em>)</p>
<p>一个提供对可写、不可查找的 <code>RawIOBase</code> 原始二进制流的高层级访问的缓冲二进制流。 它继承自 <code>BufferedIOBase</code>。</p>
<p>当写入到此对象时，数据通常会被放入到内部缓冲区中。 缓冲区将在满足某些条件的情况下被写到下层的 <code>RawIOBase</code> 对象，包括:</p>
<ul>
<li>当缓冲区对于所有挂起数据而言太小时；</li>
<li>当 <code>flush()</code> 被调用时</li>
<li>当（为 <code>BufferedRandom</code> 对象）请求 <code>seek()</code> 时；</li>
<li>当 <code>BufferedWriter</code> 对象被关闭或销毁时。</li>
</ul>
<p>该构造器会为给定的可写 <em>raw</em> 流创建一个 <code>BufferedWriter</code>。 如果未给定 <em>buffer_size</em>，则使用默认的 <code>DEFAULT_BUFFER_SIZE</code>。</p>
<p><code>BufferedWriter</code> 在继承自 <code>BufferedIOBase</code> 和 <code>IOBase</code> 的成员以外还提供或重载了下列方法:</p>
<ul>
<li><p><code>flush</code>()</p>
<p>将缓冲区中保存的字节数据强制放入原始流。 如果原始流发生阻塞则应当引发 <code>BlockingIOError</code>。</p>
</li>
<li><p><code>write</code>(<em>b</em>)</p>
<p>写入 bytes-like object <em>b</em> 并返回写入的字节数。 当处于非阻塞模式时，如果缓冲区需要被写入但原始流发生阻塞则将引发 <code>BlockingIOError</code>。</p>
</li>
</ul>
<p><em>class</em> <code>io.BufferedRandom</code>(<em>raw</em>, <em>buffer_size=DEFAULT_BUFFER_SIZE</em>)</p>
<p>一个提供对不可查找的 <code>RawIOBase</code> 原始二进制流的高层级访问的缓冲二进制流。 它继承自 <code>BufferedReader</code> 和 <code>BufferedWriter</code>。</p>
<p>该构造器会为在第一个参数中给定的可查找原始流创建一个读取器和定稿器。 如果省略 <em>buffer_size</em> 则使用默认的 <code>DEFAULT_BUFFER_SIZE</code>。</p>
<p><code>BufferedRandom</code> 能做到 <code>BufferedReader</code> 或 <code>BufferedWriter</code> 所能做的任何事。 此外，还会确保实现 <code>seek()</code> 和 <code>tell()</code>。</p>
<p><em>class</em> <code>io.BufferedRWPair</code>(<em>reader</em>, <em>writer</em>, <em>buffer_size=DEFAULT_BUFFER_SIZE</em>)</p>
<p>一个提供对两个不可查找的 <code>RawIOBase</code> 原始二进制流的高层级访问的缓冲二进制流 —- 一个可读，另一个可写。 它继承自 <code>BufferedIOBase</code>。</p>
<p><em>reader</em> 和 <em>writer</em> 分别是可读和可写的 <code>RawIOBase</code> 对象。 如果省略 <em>buffer_size</em> 则使用默认的 <code>DEFAULT_BUFFER_SIZE</code>。</p>
<p><code>BufferedRWPair</code> 实现了 <code>BufferedIOBase</code> 的所有方法，但 <code>detach()</code> 除外，调用该方法将引发 <code>UnsupportedOperation</code>。</p>
<p>警告</p>
<p><code>BufferedRWPair</code> 不会尝试同步访问其下层的原始流。 你不应当将传给它与读取器和写入器相同的对象；而要改用 <code>BufferedRandom</code>。</p>
<h4 id="文本-I-O-1"><a href="#文本-I-O-1" class="headerlink" title="文本 I/O"></a>文本 I/O</h4><p><em>class</em> <code>io.TextIOBase</code></p>
<p>文本流的基类。 该类提供了基于字符和行的流 I/O 接口。 它继承自 <code>IOBase</code>。 该类无公有构造器。</p>
<p><code>TextIOBase</code> 在来自 <code>IOBase</code> 的成员以外还提供或重载了以下数据属性和方法:</p>
<ul>
<li><p><code>encoding</code></p>
<p>用于将流的字节串解码为字符串以及将字符串编码为字节串的编码格式名称。</p>
</li>
<li><p><code>errors</code></p>
<p>解码器或编码器的错误设置。</p>
</li>
<li><p><code>newlines</code></p>
<p>一个字符串、字符串元组或者 <code>None</code>，表示目前已经转写的新行。 根据具体实现和初始构造器旗标的不同，此属性或许会不可用。</p>
</li>
<li><p><code>buffer</code></p>
<p>由 <code>TextIOBase</code> 处理的下层二进制缓冲区（为一个 <code>BufferedIOBase</code> 的实例）。 它不是 <code>TextIOBase</code> API 的组成部分并且不存在于某些实现中。</p>
</li>
<li><p><code>detach</code>()</p>
<p>从 <code>TextIOBase</code> 分离出下层二进制缓冲区并将其返回。</p>
<p>在下层缓冲区被分离后，<code>TextIOBase</code> 将处于不可用的状态。</p>
<p>某些 <code>TextIOBase</code> 的实现，例如 <code>StringIO</code> 可能并无下层缓冲区的概念，因此调用此方法将引发 <code>UnsupportedOperation</code>。</p>
<p>3.1 新版功能.</p>
</li>
<li><p><code>read</code>(<em>size=- 1</em>)</p>
<p>从流中读取至多 <em>size</em> 个字符并以单个 <code>str</code> 的形式返回。 如果 <em>size</em> 为负值或 <code>None</code>，则读取至 EOF。</p>
</li>
<li><p><code>readline</code>(<em>size=- 1</em>)</p>
<p>读取至换行符或 EOF 并返回单个 <code>str</code>。 如果流已经到达 EOF，则将返回一个空字符串。</p>
<p>如果指定了 <em>size</em> ，最多将读取 <em>size</em> 个字符。</p>
</li>
<li><p><code>seek</code>(<em>offset</em>, <em>whence=SEEK_SET</em>)</p>
<p>将流位置改为给定的偏移位置 <em>offset*。 具体行为取决于 *whence</em> 形参。 <em>whence</em> 的默认值为 <code>SEEK_SET</code>。</p>
<ul>
<li><code>SEEK_SET</code> 或 <code>0</code>: 从流的开始位置起查找（默认值）；<em>offset</em> 必须为 <code>TextIOBase.tell()</code> 所返回的数值或为零。 任何其他 <em>offset</em> 值都将导致未定义的行为。</li>
<li><code>SEEK_CUR</code> 或 <code>1</code>: “查找” 到当前位置；<em>offset</em> 必须为零，表示无操作（所有其他值均不受支持）。</li>
<li><code>SEEK_END</code> 或 <code>2</code>: 查找到流的末尾；<em>offset</em> 必须为零（所有其他值均不受支持）。</li>
</ul>
<p>以不透明数字形式返回新的绝对位置。</p>
<p>3.1 新版功能: <code>SEEK_*</code> 常量.</p>
</li>
<li><p><code>tell</code>()</p>
<p>以不透明数字形式返回当前流的位置。 该数字通常并不代表下层二进制存储中对应的字节数。</p>
</li>
<li><p><code>write</code>(<em>s</em>)</p>
<p>将字符串 <em>s</em> 写入到流并返回写入的字符数。</p>
</li>
</ul>
<p><em>class</em> <code>io.TextIOWrapper</code>(<em>buffer</em>, <em>encoding=None</em>, <em>errors=None</em>, <em>newline=None</em>, <em>line_buffering=False</em>, <em>write_through=False</em>)</p>
<p>一个提供对 <code>BufferedIOBase</code> 缓冲二进制流的高层级访问的缓冲文本流。 它继承自 <code>TextIOBase</code>。</p>
<p><em>encoding</em> 给出流的解码和编码将会使用的编码格式的名称。 它默认为 <code>locale.getpreferredencoding(False)</code>。 <code>encoding="locale"</code> 可被用来地指定当前语言区域的编码格式。 </p>
<p><em>errors</em> 是一个可选的字符串，它指明编码格式和编码格式错误的处理方式。 传入 <code>'strict'</code> 将在出现编码格式错误时引发 <code>ValueError</code> (默认值 <code>None</code> 具有相同的效果)，传入 <code>'ignore'</code> 将忽略错误。 (请注意忽略编码格式错误会导致数据丢失。) <code>'replace'</code> 会在出现错误数据时插入一个替换标记 (例如 <code>'?'</code>)。 <code>'backslashreplace'</code> 将把错误数据替换为一个反斜杠转义序列。 在写入时，还可以使用 <code>'xmlcharrefreplace'</code> (替换为适当的 XML 字符引用) 或 <code>'namereplace'</code> (替换为 <code>\N{...}</code> 转义序列)。 任何其他通过 <code>codecs.register_error()</code> 注册的错误处理方式名称也可以被接受。</p>
<p><em>newline</em> 控制行结束符处理方式。 它可以为 <code>None</code>, <code>''</code>, <code>'\n'</code>, <code>'\r'</code> 和 <code>'\r\n'</code>。 其工作原理如下:</p>
<ul>
<li>当从流读取输入时，如果 <em>newline</em> 为 <code>None</code>，则将启用 universal newlines 模式。 输入中的行结束符可以为 <code>'\n'</code>, <code>'\r'</code> 或 <code>'\r\n'</code>，在返回给调用者之前它们会被统一转写为 <code>'\n'</code>。 如果 <em>newline</em> 为 <code>''</code>，也会启用通用换行模式，但行结束符会不加转写即返回给调用者。 如果 <em>newline</em> 具有任何其他合法的值，则输入行将仅由给定的字符串结束，并且行结束符会不加转写即返回给调用者。</li>
<li>将输出写入流时，如果 <em>newline</em> 为 <code>None</code>，则写入的任何 <code>'\n'</code> 字符都将转换为系统默认行分隔符 <code>os.linesep</code>。如果 <em>newline</em> 是 <code>''</code> 或 <code>'\n'</code>，则不进行翻译。如果 <em>newline</em> 是任何其他合法值，则写入的任何 <code>'\n'</code> 字符将被转换为给定的字符串。</li>
</ul>
<p>如果 <em>line_buffering</em> 为 <code>True</code>，则当一个写入调用包含换行符或回车时将会应用 <code>flush()</code>。</p>
<p>如果 <em>write_through</em> 为 <code>True</code>，对 <code>write()</code> 的调用会确保不被缓冲：在 <code>TextIOWrapper</code> 对象上写入的任何数据会立即交给其下层的 <em>buffer</em> 来处理。</p>
<p>在 3.3 版更改: 已添加 <em>write_through</em> 参数</p>
<p>在 3.3 版更改: 默认的 <em>encoding</em> 现在将为 <code>locale.getpreferredencoding(False)</code> 而非 <code>locale.getpreferredencoding()</code>。 不要使用 <code>locale.setlocale()</code> 来临时改变区域编码格式，要使用当前区域编码格式而不是用户的首选编码格式。</p>
<p>在 3.10 版更改: <em>encoding</em> 参数现在支持 <code>"locale"</code> 作为编码格式名称。</p>
<p><code>TextIOWrapper</code> 在继承自 <code>TextIOBase</code> 和 <code>IOBase</code> 的现有成员以外还提供了以下数据属性和方法:</p>
<ul>
<li><p><code>line_buffering</code></p>
<p>是否启用行缓冲。</p>
</li>
<li><p><code>write_through</code></p>
<p>写入是否要立即传给下层的二进制缓冲。</p>
<p>3.7 新版功能.</p>
</li>
<li><p><code>reconfigure</code>(<em>\</em>, encoding, newline[, write_through]*)</p>
<p>使用 <em>encoding</em>, <em>errors</em>, <em>newline</em>, <em>line_buffering</em> 和 <em>write_through</em> 的新设置来重新配置此文本流。</p>
<p>未指定的形参将保留当前设定，例外情况是当指定了 <em>encoding</em> 但未指定 <em>errors</em> 时将会使用 <code>errors='strict'</code>。</p>
<p>如果已经有数据从流中被读取则将无法再改变编码格式或行结束符。 另一方面，在写入数据之后再改变编码格式则是可以的。</p>
<p>此方法会在设置新的形参之前执行隐式的流刷新。</p>
<p>3.7 新版功能.</p>
</li>
</ul>
<p><em>class</em> <code>io.StringIO</code>(<em>initial_value=’’</em>, <em>newline=’\n’</em>)</p>
<p>一个使用内存文本缓冲的文本流。 它继承自 <code>TextIOBase</code>。</p>
<p>当 <code>close()</code> 方法被调用时将会丢弃文本缓冲区。</p>
<p>缓冲区的初始值可通过提供 <em>initial_value</em> 来设置。 如果启用了行结束符转写，换行将以 <code>write()</code> 所用的方式被编码。 数据流位置将被设为缓冲区的开头。</p>
<p><em>newline</em> 参数的规则与 <code>TextIOWrapper</code> 所用的一致，不同之处在于当将输出写入到流时，如果 <em>newline</em> 为 <code>None</code>，则在所有平台上换行符都会被写入为 <code>\n</code>。</p>
<p><code>StringIO</code> 在继承自 <code>TextIOBase</code> 和 <code>IOBase</code> 的现有成员以外还提供了以下方法:</p>
<ul>
<li><p><code>getvalue</code>()</p>
<p>返回一个包含缓冲区全部内容的 <code>str</code>。 换行符会以与 <code>read()</code> 相同的方式被编码，但是流的位置不会被改变。</p>
</li>
</ul>
<p>用法示例：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> io
output <span class="token operator">=</span> io<span class="token punctuation">.</span>StringIO<span class="token punctuation">(</span><span class="token punctuation">)</span>
output<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">'First line.\n'</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Second line.'</span><span class="token punctuation">,</span> file<span class="token operator">=</span>output<span class="token punctuation">)</span>
<span class="token comment" spellcheck="true"># Retrieve file contents -- this will be</span>
<span class="token comment" spellcheck="true"># 'First line.\nSecond line.\n'</span>
contents <span class="token operator">=</span> output<span class="token punctuation">.</span>getvalue<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment" spellcheck="true"># Close object and discard memory buffer --</span>
<span class="token comment" spellcheck="true"># .getvalue() will now raise an exception.</span>
output<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><em>class</em> <code>io.IncrementalNewlineDecoder</code></p>
<p>用于在 universal newlines 模式下解码换行符的辅助编解码器。 它继承自 <code>codecs.IncrementalDecoder</code>。</p>
<h3 id="性能-1"><a href="#性能-1" class="headerlink" title="性能"></a>性能</h3><p>本节讨论所提供的具体 I/O 实现的性能。</p>
<h4 id="二进制-I-O-1"><a href="#二进制-I-O-1" class="headerlink" title="二进制 I/O"></a>二进制 I/O</h4><p>即使在用户请求单个字节时，也只读取和写入大块数据。通过该方法，缓冲 I/O 隐藏了操作系统调用和执行无缓冲 I/O 例程时的任何低效性。增益取决于操作系统和执行的 I/O 类型。例如，在某些现代操作系统上（例如 Linux），无缓冲磁盘 I/O 可以与缓冲 I/O 一样快。但最重要的是，无论平台和支持设备如何，缓冲 I/O 都能提供可预测的性能。因此，对于二进制数据，应首选使用缓冲的 I/O 而不是未缓冲的 I/O 。</p>
<h4 id="文本-I-O-2"><a href="#文本-I-O-2" class="headerlink" title="文本 I/O"></a>文本 I/O</h4><p>二进制存储（如文件）上的文本 I/O 比同一存储上的二进制 I/O 慢得多，因为它需要使用字符编解码器在Unicode和二进制数据之间进行转换。这在处理大量文本数据（如大型日志文件）时会变得非常明显。此外，由于使用的重构算法 <code>TextIOWrapper.tell()</code> 和 <code>TextIOWrapper.seek()</code> 都相当慢。</p>
<p><code>StringIO</code> 是原生的内存 Unicode 容器，速度与 <code>BytesIO</code> 相似。</p>
<h4 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h4><p><code>FileIO</code> 对象是线程安全的，只要它们封装的操作系统调用（比如Unix下的 <code>read(2)</code> ）也是线程安全的。</p>
<p>二进制缓冲对象（例如 <code>BufferedReader</code>, <code>BufferedWriter</code>, <code>BufferedRandom</code> 和 <code>BufferedRWPair</code>）使用锁来保护其内部结构；因此，可以安全地一次从多个线程中调用它们。</p>
<p><code>TextIOWrapper</code> 对象不再是线程安全的。</p>
<h4 id="可重入性"><a href="#可重入性" class="headerlink" title="可重入性"></a>可重入性</h4><p>二进制缓冲对象（ <code>BufferedReader</code> ， <code>BufferedWriter</code> ， <code>BufferedRandom</code> 和 <code>BufferedRWPair</code> 的实例）不是可重入的。虽然在正常情况下不会发生可重入调用，但仍可能会在 <code>signal</code> 处理程序执行 I/O 时产生。如果线程尝试重入已经访问的缓冲对象，则会引发 <code>RuntimeError</code> 。注意，这并不禁止其他线程进入缓冲对象。</p>
<p>上面的内容隐式地扩展到文本文件中，因为 <code>open()</code> 函数将把缓冲对象封装在 <code>TextIOWrapper</code> 中。 这包括标准流，因而也会影响内置的 <code>print()</code> 函数。</p>
<h2 id="time-—-时间的访问和转换"><a href="#time-—-时间的访问和转换" class="headerlink" title="time —- 时间的访问和转换"></a><code>time</code> —- 时间的访问和转换</h2><p>该模块提供了各种与时间相关的函数。相关功能还可以参阅 <code>datetime</code> 和 <code>calendar</code> 模块。</p>
<p>尽管所有平台皆可使用此模块，但模块内的函数并非所有平台都可用。此模块中定义的大多数函数的实现都是调用其所在平台的C语言库的同名函数。因为这些函数的语义可能因平台而异，所以使用时最好查阅对应平台的相关文档。</p>
<p>下面是一些术语和惯例的解释.</p>
<ul>
<li><p><em>epoch</em> 是时间开始的点，其值取决于平台。对于Unix， epoch 是1970年1月1日00:00:00（UTC）。要找出给定平台上的 epoch ，请查看 <code>time.gmtime(0)</code> 。</p>
</li>
<li><p>术语 <em>纪元秒数</em> 是指自 epoch （纪元）时间点以来经过的总秒数，通常不包括 闰秒。 在所有符合 POSIX 标准的平台上，闰秒都不会记录在总秒数中。</p>
</li>
<li><p>此模块中的函数可能无法处理纪元之前或遥远未来的日期和时间。“遥远未来”的定义由对应的C语言库决定；对于32位系统，它通常是指2038年及以后。</p>
</li>
<li><p>函数 <code>strptime()</code> 在接收到 <code>%y</code> 格式代码时可以解析使用 2 位数表示的年份。当解析 2 位数年份时，函数会按照 POSIX 和 ISO C 标准进行年份转换：数值 69—99 被映射为 1969—1999；数值 0—68 被映射为 2000—2068。</p>
</li>
<li><p>UTC是协调世界时（Coordinated Universal Time）的缩写。它以前也被称为格林威治标准时间（GMT）。使用UTC而不是CUT作为缩写是英语与法语（Temps Universel Coordonné）之间妥协的结果，不是什么低级错误。</p>
</li>
<li><p>DST是夏令时（Daylight Saving Time）的缩写，在一年的某一段时间中将当地时间调整（通常）一小时。 DST的规则非常神奇（由当地法律确定），并且每年的起止时间都不同。C语言库中有一个表格，记录了各地的夏令时规则（实际上，为了灵活性，C语言库通常是从某个系统文件中读取这张表）。从这个角度而言，这张表是夏令时规则的唯一权威真理。</p>
</li>
<li><p>由于平台限制，各种实时函数的精度可能低于其值或参数所要求（或给定）的精度。例如，在大多数Unix系统上，时钟频率仅为每秒50或100次。</p>
</li>
<li><p>另一方面， <code>time()</code> 和 <code>sleep()</code> 的精度优于它们的Unix等价物：时间表示为浮点数，<code>time()</code> 返回最准确的时间 （使用Unix <code>gettimeofday()</code> 如果可用），并且 <code>sleep()</code> 将接受非零分数的时间（Unix <code>select()</code> 用于实现此功能，如果可用）。</p>
</li>
<li><p>时间值由 <code>gmtime()</code>，<code>localtime()</code> 和 <code>strptime()</code> 返回，并被 <code>asctime()</code>， <code>mktime()</code> 和 <code>strftime()</code> 接受，是一个 9 个整数的序列。 <code>gmtime()</code>， <code>localtime()</code> 和 <code>strptime()</code> 的返回值还提供各个字段的属性名称。</p>
<p>在 3.3 版更改: 在平台支持相应的 <code>struct tm</code> 成员时，<code>struct_time</code> 类型被扩展提供 <code>tm_gmtoff</code> 和 <code>tm_zone</code> 属性。</p>
<p>在 3.6 版更改: <code>struct_time</code> 的属性 <code>tm_gmtoff</code> 和 <code>tm_zone</code> 现在可在所有平台上使用。</p>
</li>
<li><p>使用以下函数在时间表示之间进行转换：</p>
<table>
<thead>
<tr>
<th align="left">从</th>
<th align="left">到</th>
<th align="left">使用</th>
</tr>
</thead>
<tbody><tr>
<td align="left">自纪元以来的秒数</td>
<td align="left">UTC 的 <code>struct_time</code></td>
<td align="left"><code>gmtime()</code></td>
</tr>
<tr>
<td align="left">自纪元以来的秒数</td>
<td align="left">本地时间的 <code>struct_time</code></td>
<td align="left"><code>localtime()</code></td>
</tr>
<tr>
<td align="left">UTC 的 <code>struct_time</code></td>
<td align="left">自纪元以来的秒数</td>
<td align="left"><code>calendar.timegm()</code></td>
</tr>
<tr>
<td align="left">本地时间的 <code>struct_time</code></td>
<td align="left">自纪元以来的秒数</td>
<td align="left"><code>mktime()</code></td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p><code>time.asctime</code>([<em>t</em>])</p>
<p>转换由 <code>gmtime()</code> 或 <code>localtime()</code> 所返回的表示时间的元组或 <code>struct_time</code> 为以下形式的字符串: <code>'Sun Jun 20 23:21:05 1993'</code>。 日期字段的长度为两个字符，如果日期只有一个数字则会以零填充，例如: <code>'Wed Jun 9 04:26:40 1993'</code>。</p>
<p>如果未提供 <em>t</em>，则会使用 <code>localtime()</code> 所返回的当前时间。 <code>asctime()</code> 不会使用区域设置信息。</p>
<p>注解</p>
<p>与同名的C函数不同， <code>asctime()</code> 不添加尾随换行符。</p>
<p><code>time.pthread_getcpuclockid</code>(<em>thread_id</em>)</p>
<p>返回指定的 <em>thread_id</em> 的特定于线程的CPU时间时钟的 <em>clk_id</em> 。</p>
<p>使用 <code>threading.Thread</code> 对象的 <code>threading.get_ident()</code> 或 <code>ident</code> 属性为 <em>thread_id</em> 获取合适的值。</p>
<p>警告</p>
<p>传递无效的或过期的 <em>thread_id</em> 可能会导致未定义的行为，例如段错误。</p>
<p>可用性 ： Unix。</p>
<p>3.7 新版功能.</p>
<p><code>time.clock_getres</code>(<em>clk_id</em>)</p>
<p>返回指定时钟 <em>clk_id</em> 的分辨率（精度）。</p>
<p>可用性: Unix。</p>
<p>3.3 新版功能.</p>
<p><code>time.clock_gettime</code>(<em>clk_id</em>) → float</p>
<p>返回指定 <em>clk_id</em> 时钟的时间。</p>
<p>使用 <code>clock_gettime_ns()</code> 以避免 <code>float</code> 类型导致的精度损失。</p>
<p>可用性: Unix。</p>
<p>3.3 新版功能.</p>
<p><code>time.clock_gettime_ns</code>(<em>clk_id</em>) → int</p>
<p>与 <code>clock_gettime()</code> 相似，但返回时间为纳秒。</p>
<p>可用性: Unix。</p>
<p>3.7 新版功能.</p>
<p><code>time.clock_settime</code>(<em>clk_id</em>, <em>time: float</em>)</p>
<p>设置指定 <em>clk_id</em> 时钟的时间。 目前， <code>CLOCK_REALTIME</code> 是 <em>clk_id</em> 唯一可接受的值。</p>
<p>使用 <code>clock_settime_ns()</code> 以避免 <code>float</code> 类型导致的精度损失。</p>
<p>可用性: Unix。</p>
<p>3.3 新版功能.</p>
<p><code>time.clock_settime_ns</code>(<em>clk_id</em>, <em>time: int</em>)</p>
<p>与 <code>clock_settime()</code> 相似，但设置时间为纳秒。</p>
<p>可用性: Unix。</p>
<p>3.7 新版功能.</p>
<p><code>time.ctime</code>([<em>secs</em>])</p>
<p>转换以距离初始纪元的秒数表示的时间为以下形式的字符串: <code>'Sun Jun 20 23:21:05 1993'</code> 代表本地时间。 日期字段的长度为两个字符，如果日期只有一个数字则会以零填充，例如: <code>'Wed Jun 9 04:26:40 1993'</code>。</p>
<p>如果 <em>secs</em> 未提供或为 <code>None</code>，则使用 <code>time()</code> 所返回的当前时间。 <code>ctime(secs)</code> 等价于 <code>asctime(localtime(secs))</code>。 <code>ctime()</code> 不会使用区域设置信息。</p>
<p><code>time.get_clock_info</code>(<em>name</em>)</p>
<p>获取有关指定时钟的信息作为命名空间对象。 支持的时钟名称和读取其值的相应函数是：</p>
<ul>
<li><code>'monotonic'</code>: <code>time.monotonic()</code></li>
<li><code>'perf_counter'</code>: <code>time.perf_counter()</code></li>
<li><code>'process_time'</code>: <code>time.process_time()</code></li>
<li><code>'thread_time'</code>: <code>time.thread_time()</code></li>
<li><code>'time'</code>: <code>time.time()</code></li>
</ul>
<p>结果具有以下属性：</p>
<ul>
<li><em>adjustable</em> ： 如果时钟可以自动更改（例如通过NTP守护程序）或由系统管理员手动更改，则为 <code>True</code> ，否则为 <code>False</code> 。</li>
<li><em>implementation</em> ： 用于获取时钟值的基础C函数的名称。</li>
<li><em>monotonic</em> ：如果时钟不能倒退，则为 <code>True</code> ，否则为 <code>False</code> 。</li>
<li><em>resolution</em> ： 以秒为单位的时钟分辨率（ <code>float</code> ）</li>
</ul>
<p>3.3 新版功能.</p>
<p><code>time.gmtime</code>([<em>secs</em>])</p>
<p>将以自 epoch 开始的秒数表示的时间转换为 UTC 的 <code>struct_time</code> ，其中 dst 标志始终为零。 如果未提供 <em>secs</em> 或为 <code>None</code> ，则使用 <code>time()</code> 所返回的当前时间。 一秒以内的小数将被忽略。 有关 <code>struct_time</code> 对象的说明请参见上文。 有关此函数的逆操作请参阅 <code>calendar.timegm()</code>。</p>
<p><code>time.localtime</code>([<em>secs</em>])</p>
<p>与 <code>gmtime()</code> 相似但转换为当地时间。如果未提供 <em>secs</em> 或为 <code>None</code> ，则使用由 <code>time()</code> 返回的当前时间。当 DST 适用于给定时间时，dst标志设置为 <code>1</code> 。</p>
<p><code>time.mktime</code>(<em>t</em>)</p>
<p>这是 <code>localtime()</code> 的反函数。它的参数是 <code>struct_time</code> 或者完整的 9 元组（因为需要 dst 标志；如果它是未知的则使用 <code>-1</code> 作为dst标志），它表示 <em>local</em> 的时间，而不是 UTC 。它返回一个浮点数，以便与 <code>time()</code> 兼容。如果输入值不能表示为有效时间，则 <code>OverflowError</code> 或 <code>ValueError</code> 将被引发（这取决于Python或底层C库是否捕获到无效值）。它可以生成时间的最早日期取决于平台。</p>
<p><code>time.monotonic</code>() → float</p>
<p>（以小数表示的秒为单位）返回一个单调时钟的值，即不能倒退的时钟。 该时钟不受系统时钟更新的影响。 返回值的参考点未被定义，因此只有两次调用之间的差值才是有效的。</p>
<p>使用 <code>monotonic_ns()</code> 以避免 <code>float</code> 类型导致的精度损失。</p>
<p>3.3 新版功能.</p>
<p>在 3.5 版更改: 该功能现在始终可用且始终在系统范围内。</p>
<p>在 3.10 版更改: 在 macOS 上，现在这个函数作用于全系统。</p>
<p><code>time.monotonic_ns</code>() → int</p>
<p>与 <code>monotonic()</code> 相似，但是返回时间为纳秒数。</p>
<p>3.7 新版功能.</p>
<p><code>time.perf_counter</code>() → float</p>
<p>（以小数表示的秒为单位）返回一个性能计数器的值，即用于测量较短持续时间的具有最高有效精度的时钟。 它会包括睡眠状态所消耗的时间并且作用于全系统范围。 返回值的参考点未被定义，因此只有两次调用之间的差值才是有效的。</p>
<p>使用 <code>perf_counter_ns()</code> 以避免 <code>float</code> 类型导致的精度损失。</p>
<p>3.3 新版功能.</p>
<p>在 3.10 版更改: 在 Windows 上，现在这个函数作用于全系统。</p>
<p><code>time.perf_counter_ns</code>() → int</p>
<p>与 <code>perf_counter()</code> 相似，但是返回时间为纳秒。</p>
<p>3.7 新版功能.</p>
<p><code>time.process_time</code>() → float</p>
<p>（以小数表示的秒为单位）返回当前进程的系统和用户 CPU 时间的总计值。 它不包括睡眠状态所消耗的时间。 根据定义它只作用于进程范围。 返回值的参考点未被定义，因此只有两次调用之间的差值才是有效的。</p>
<p>使用 <code>process_time_ns()</code> 以避免 <code>float</code> 类型导致的精度损失。</p>
<p>3.3 新版功能.</p>
<p><code>time.process_time_ns</code>() → int</p>
<p>与 <code>process_time()</code> 相似，但是返回时间为纳秒。</p>
<p>3.7 新版功能.</p>
<p><code>time.sleep</code>(<em>secs</em>)</p>
<p>调用该方法的线程将被暂停执行 secs 秒。参数可以是浮点数，以表示更为精确的睡眠时长。由于任何捕获到的信号都会终止 <code>sleep()</code> 引发的该睡眠过程并开始执行信号的处理例程，因此实际的暂停时长可能小于请求的时长；此外，由于系统需要调度其他活动，实际暂停时长也可能比请求的时间长。</p>
<p>在 3.5 版更改: 现在，即使该睡眠过程被信号中断，该函数也会保证调用它的线程至少会睡眠 <em>secs</em> 秒。信号处理例程抛出异常的情况除外。（欲了解我们做出这次改变的原因，请参见 <a href="https://www.python.org/dev/peps/pep-0475" target="_blank" rel="noopener"><strong>PEP 475</strong></a> ）</p>
<p><code>time.strftime</code>(<em>format</em>[, <em>t</em>])</p>
<p>转换一个元组或 <code>struct_time</code> 表示的由 <code>gmtime()</code> 或 <code>localtime()</code> 返回的时间到由 <em>format</em> 参数指定的字符串。如果未提供 <em>t</em> ，则使用由 <code>localtime()</code> 返回的当前时间。 <em>format</em> 必须是一个字符串。如果 <em>t</em> 中的任何字段超出允许范围，则引发 <code>ValueError</code> 。</p>
<p>0是时间元组中任何位置的合法参数；如果它通常是非法的，则该值被强制改为正确的值。</p>
<p>以下指令可以嵌入 <em>format</em> 字符串中。它们显示时没有可选的字段宽度和精度规范，并被 <code>strftime()</code> 结果中的指示字符替换：</p>
<table>
<thead>
<tr>
<th align="left">指令</th>
<th align="left">含意</th>
<th align="left">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>%a</code></td>
<td align="left">本地化的缩写星期中每日的名称。</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>%A</code></td>
<td align="left">本地化的星期中每日的完整名称。</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>%b</code></td>
<td align="left">本地化的月缩写名称。</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>%B</code></td>
<td align="left">本地化的月完整名称。</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>%c</code></td>
<td align="left">本地化的适当日期和时间表示。</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>%d</code></td>
<td align="left">十进制数 [01,31] 表示的月中日。</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>%H</code></td>
<td align="left">十进制数 [00,23] 表示的小时（24小时制）。</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>%I</code></td>
<td align="left">十进制数 [01,12] 表示的小时（12小时制）。</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>%j</code></td>
<td align="left">十进制数 [001,366] 表示的年中日。</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>%m</code></td>
<td align="left">十进制数 [01,12] 表示的月。</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>%M</code></td>
<td align="left">十进制数 [00,59] 表示的分钟。</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>%p</code></td>
<td align="left">本地化的 AM 或 PM 。</td>
<td align="left">(1)</td>
</tr>
<tr>
<td align="left"><code>%S</code></td>
<td align="left">十进制数 [00,61] 表示的秒。</td>
<td align="left">(2)</td>
</tr>
<tr>
<td align="left"><code>%U</code></td>
<td align="left">十进制数 [00,53] 表示的一年中的周数（星期日作为一周的第一天）。 在第一个星期日之前的新年中的所有日子都被认为是在第 0 周。</td>
<td align="left">(3)</td>
</tr>
<tr>
<td align="left"><code>%w</code></td>
<td align="left">十进制数 [0(星期日),6] 表示的周中日。</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>%W</code></td>
<td align="left">十进制数 [00,53] 表示的一年中的周数（星期一作为一周的第一天）。 在第一个星期一之前的新年中的所有日子被认为是在第 0 周。</td>
<td align="left">(3)</td>
</tr>
<tr>
<td align="left"><code>%x</code></td>
<td align="left">本地化的适当日期表示。</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>%X</code></td>
<td align="left">本地化的适当时间表示。</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>%y</code></td>
<td align="left">十进制数 [00,99] 表示的没有世纪的年份。</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>%Y</code></td>
<td align="left">十进制数表示的带世纪的年份。</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>%z</code></td>
<td align="left">时区偏移以格式 +HHMM 或 -HHMM 形式的 UTC/GMT 的正或负时差指示，其中H表示十进制小时数字，M表示小数分钟数字 [-23:59, +23:59] 。</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>%Z</code></td>
<td align="left">时区名称（如果不存在时区，则不包含字符）。</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>%%</code></td>
<td align="left">字面的 <code>‘%’</code> 字符。</td>
<td align="left"></td>
</tr>
</tbody></table>
<p>注释：</p>
<ol>
<li>当与 <code>strptime()</code> 函数一起使用时，如果使用 <code>%I</code> 指令来解析小时， <code>%p</code> 指令只影响输出小时字段。</li>
<li>范围真的是 <code>0</code> 到 <code>61</code> ；值 <code>60</code> 在表示 leap seconds 的时间戳中有效，并且由于历史原因支持值 <code>61</code> 。</li>
<li>当与 <code>strptime()</code> 函数一起使用时， <code>%U</code> 和 <code>%W</code> 仅用于指定星期几和年份的计算。</li>
</ol>
<p>下面是一个示例，一个与 <a href="https://tools.ietf.org/html/rfc2822.html" target="_blank" rel="noopener"><strong>RFC 2822</strong></a> Internet电子邮件标准以兼容的日期格式.</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> time <span class="token keyword">import</span> gmtime<span class="token punctuation">,</span> strftime
<span class="token operator">>></span><span class="token operator">></span> strftime<span class="token punctuation">(</span><span class="token string">"%a, %d %b %Y %H:%M:%S +0000"</span><span class="token punctuation">,</span> gmtime<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token string">'Thu, 28 Jun 2001 14:17:15 +0000'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>某些平台可能支持其他指令，但只有此处列出的指令具有 ANSI C 标准化的含义。</p>
<p>在某些平台上，可选的字段宽度和精度规范可以按照以下顺序紧跟在指令的初始 <code>'%'</code> 之后；这也不可移植。字段宽度通常为2，除了 <code>%j</code> ，它是3。</p>
<p><code>time.strptime</code>(<em>string</em>[, <em>format</em>])</p>
<p>根据格式解析表示时间的字符串。 返回值为一个被 <code>gmtime()</code> 或 <code>localtime()</code> 返回的 <code>struct_time</code> 。</p>
<p><em>format</em> 参数使用与 <code>strftime()</code> 相同的指令。 它默认为匹配 <code>ctime()</code> 所返回的格式 <code>"%a %b %d %H:%M:%S %Y"</code>  。 如果 <em>string</em> 不能根据 <em>format</em> 来解析，或者解析后它有多余的数据，则会引发 ValueError。 当无法推断出更准确的值时，用于填充任何缺失数据的默认值是 <code>(1900, 1, 1, 0, 0, 0, 0, 1, -1)</code> 。 <em>string</em> 和 <em>format</em> 都必须为字符串。</p>
<p>例如:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> time
<span class="token operator">>></span><span class="token operator">></span> time<span class="token punctuation">.</span>strptime<span class="token punctuation">(</span><span class="token string">"30 Nov 00"</span><span class="token punctuation">,</span> <span class="token string">"%d %b %y"</span><span class="token punctuation">)</span>   
time<span class="token punctuation">.</span>struct_time<span class="token punctuation">(</span>tm_year<span class="token operator">=</span><span class="token number">2000</span><span class="token punctuation">,</span> tm_mon<span class="token operator">=</span><span class="token number">11</span><span class="token punctuation">,</span> tm_mday<span class="token operator">=</span><span class="token number">30</span><span class="token punctuation">,</span> tm_hour<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> tm_min<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>
                 tm_sec<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> tm_wday<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">,</span> tm_yday<span class="token operator">=</span><span class="token number">335</span><span class="token punctuation">,</span> tm_isdst<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>支持 <code>%Z</code> 指令是基于 <code>tzname</code> 中包含的值以及 <code>daylight</code> 是否为真。因此，它是特定于平台的，除了识别始终已知的 UTC 和 GMT （并且被认为是非夏令时时区）。</p>
<p>仅支持文档中指定的指令。因为每个平台都实现了 <code>strftime()</code> ，它有时会提供比列出的指令更多的指令。但是 <code>strptime()</code> 独立于任何平台，因此不一定支持所有未记录为支持的可用指令。</p>
<p><em>class</em> <code>time.struct_time</code></p>
<p>返回的时间值序列的类型为 <code>gmtime()</code> 、 <code>localtime()</code> 和 <code>strptime()</code> 。它是一个带有 named tuple 接口的对象：可以通过索引和属性名访问值。 存在以下值：</p>
<table>
<thead>
<tr>
<th align="left">索引</th>
<th align="left">属性</th>
<th align="left">值</th>
</tr>
</thead>
<tbody><tr>
<td align="left">0</td>
<td align="left"><code>tm_year</code></td>
<td align="left">（例如，1993）</td>
</tr>
<tr>
<td align="left">1</td>
<td align="left"><code>tm_mon</code></td>
<td align="left">range [1, 12]</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><code>tm_mday</code></td>
<td align="left">range [1, 31]</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><code>tm_hour</code></td>
<td align="left">range [0, 23]</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><code>tm_min</code></td>
<td align="left">range [0, 59]</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><code>tm_sec</code></td>
<td align="left">range [0, 61]；</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left"><code>tm_wday</code></td>
<td align="left">range [0, 6] ，周一为 0</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left"><code>tm_yday</code></td>
<td align="left">range [1, 366]</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left"><code>tm_isdst</code></td>
<td align="left">0, 1 或 -1；如下所示</td>
</tr>
<tr>
<td align="left">N/A</td>
<td align="left"><code>tm_zone</code></td>
<td align="left">时区名称的缩写</td>
</tr>
<tr>
<td align="left">N/A</td>
<td align="left"><code>tm_gmtoff</code></td>
<td align="left">以秒为单位的UTC以东偏离</td>
</tr>
</tbody></table>
<p>请注意，与C结构不同，月份值是 [1,12] 的范围，而不是 [0,11] 。</p>
<p>在调用 <code>mktime()</code> 时， <code>tm_isdst</code> 可以在夏令时生效时设置为1，而在夏令时不生效时设置为0。 值-1表示这是未知的，并且通常会导致填写正确的状态。</p>
<p>当一个长度不正确的元组被传递给期望 <code>struct_time</code> 的函数，或者具有错误类型的元素时，会引发 <code>TypeError</code> 。</p>
<p><code>time.time</code>() → float</p>
<p>返回以浮点数表示的从 epoch 开始的秒数的时间值。 epoch 的具体日期和 leap seconds 的处理取决于平台。 在 Windows 和大多数 Unix 系统中， epoch 是 1970 年 1 月 1 日 00:00:00 (UTC)，并且闰秒将不计入从 epoch 开始的秒数。 这通常被称为 Unix 时间。 要了解给定平台上 epoch 的具体定义，请查看 <code>gmtime(0)</code>。</p>
<p>请注意，即使时间总是作为浮点数返回，但并非所有系统都提供高于1秒的精度。虽然此函数通常返回非递减值，但如果在两次调用之间设置了系统时钟，则它可以返回比先前调用更低的值。</p>
<p>返回的数字 <code>time()</code> 可以通过将其传递给 <code>gmtime()</code> 函数或转换为UTC中更常见的时间格式（即年、月、日、小时等）或通过将它传递给 <code>localtime()</code> 函数获得本地时间。在这两种情况下都返回一个 <code>struct_time</code> 对象，日历日期组件可以从中作为属性访问。</p>
<p>使用 <code>time_ns()</code> 以避免 <code>float</code> 类型导致的精度损失。</p>
<p><code>time.time_ns</code>() → int</p>
<p>与 <code>time()</code> 相似，但返回时间为用整数表示的自 epoch 以来所经过的纳秒数。</p>
<p>3.7 新版功能.</p>
<p><code>time.thread_time</code>() → float</p>
<p>（以小数表示的秒为单位）返回当前线程的系统和用户 CPU 时间的总计值。 它不包括睡眠状态所消耗的时间。 根据定义它只作用于线程范围。 返回值的参考点未被定义，因此只有两次调用之间的差值才是有效的。</p>
<p>使用 <code>thread_time_ns()</code> 以避免 <code>float</code> 类型导致的精度损失。</p>
<p>可用性 ： Windows、 Linux、 Unix 系统支持 <code>CLOCK_THREAD_CPUTIME_ID</code> 。</p>
<p>3.7 新版功能.</p>
<p><code>time.thread_time_ns</code>() → int</p>
<p>与 <code>thread_time()</code> 相似，但返回纳秒时间。</p>
<p>3.7 新版功能.</p>
<p><code>time.tzset</code>()</p>
<p>重置库例程使用的时间转换规则。环境变量 <code>TZ</code> 指定如何完成。它还将设置变量 <code>tzname</code> （来自 <code>TZ</code> 环境变量）， <code>timezone</code> （UTC的西部非DST秒）， <code>altzone</code> （UTC以西的DST秒）和 <code>daylight</code> （如果此时区没有任何夏令时规则则为0，如果有夏令时适用的时间，无论过去、现在或未来，则为非零）。</p>
<p>可用性: Unix。</p>
<p>注解</p>
<p>虽然在很多情况下，更改 <code>TZ</code> 环境变量而不调用 <code>tzset()</code> 可能会影响函数的输出，例如 <code>localtime()</code> ，不应该依赖此行为。</p>
<p><code>TZ</code> 不应该包含空格。</p>
<p><code>TZ</code> 环境变量的标准格式是（为了清晰起见，添加了空格）:</p>
<pre><code>std offset [dst [offset [,start[/time], end[/time]]]]</code></pre><p>组件的位置是：</p>
<ul>
<li><p><code>std</code> 和 <code>dst</code></p>
<p>三个或更多字母数字，给出时区缩写。这些将传到 time.tzname</p>
<p><code>offset</code></p>
<p>偏移量的形式为： <code>± hh[:mm[:ss]]</code> 。这表示添加到达UTC的本地时间的值。如果前面有 ‘-‘ ，则时区位于本初子午线的东边；否则，在它是西边。如果dst之后没有偏移，则假设夏令时比标准时间提前一小时。</p>
<p><code>start[/time], end[/time]</code></p>
<p>指示何时更改为DST和从DST返回。开始日期和结束日期的格式为以下之一：</p>
<ul>
<li><p><code>J*n*</code></p>
<p>Julian日 <em>n</em> （1 &lt;= <em>n</em> &lt;= 365）。闰日不计算在内，因此在所有年份中，2月28日是第59天，3月1日是第60天。</p>
<p><code>*n*</code></p>
<p>从零开始的Julian日（0 &lt;= <em>n</em> &lt;= 365）。 闰日计入，可以引用2月29日。</p>
<p><code>M*m*.*n*.*d*</code></p>
<p>一年中 <em>m</em> 月的第 <em>n</em> 周（1 &lt;= <em>n</em> &lt;= 5 ，1 &lt;= <em>m</em> &lt;= 12 ，第 5 周表示 “可能在 <em>m</em> 月第 4 周或第 5 周出现的最后第 <em>d</em> 日”）的第 <em>d</em> 天（0 &lt;= <em>d</em> &lt;= 6）。 第 1 周是第 <em>d</em> 天发生的第一周。 第 0 天是星期天。</p>
</li>
</ul>
<p><code>time</code> 的格式与 <code>offset</code> 的格式相同，但不允许使用前导符号（ ‘-‘ 或 ‘+’ ）。如果没有给出时间，则默认值为02:00:00。</p>
</li>
</ul>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> os<span class="token punctuation">.</span>environ<span class="token punctuation">[</span><span class="token string">'TZ'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'EST+05EDT,M4.1.0,M10.5.0'</span>
<span class="token operator">>></span><span class="token operator">></span> time<span class="token punctuation">.</span>tzset<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> time<span class="token punctuation">.</span>strftime<span class="token punctuation">(</span><span class="token string">'%X %x %Z'</span><span class="token punctuation">)</span>
<span class="token string">'02:07:36 05/08/03 EDT'</span>
<span class="token operator">>></span><span class="token operator">></span> os<span class="token punctuation">.</span>environ<span class="token punctuation">[</span><span class="token string">'TZ'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'AEST-10AEDT-11,M10.5.0,M3.5.0'</span>
<span class="token operator">>></span><span class="token operator">></span> time<span class="token punctuation">.</span>tzset<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> time<span class="token punctuation">.</span>strftime<span class="token punctuation">(</span><span class="token string">'%X %x %Z'</span><span class="token punctuation">)</span>
<span class="token string">'16:08:12 05/08/03 AEST'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在许多Unix系统（包括 *BSD ， Linux ， Solaris 和 Darwin 上），使用系统的区域信息数据库来指定时区规则会更方便。为此，将 <code>TZ</code> 环境变量设置为所需时区数据文件的路径，相对于系统 ‘zoneinfo’ 时区数据库的根目录，通常位于 <code>/usr/share/zoneinfo</code> 。 例如，<code>'US/Eastern'</code> 、 <code>'Australia/Melbourne'</code> 、 <code>'Egypt'</code> 或 <code>'Europe/Amsterdam'</code>。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> os<span class="token punctuation">.</span>environ<span class="token punctuation">[</span><span class="token string">'TZ'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'US/Eastern'</span>
<span class="token operator">>></span><span class="token operator">></span> time<span class="token punctuation">.</span>tzset<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> time<span class="token punctuation">.</span>tzname
<span class="token punctuation">(</span><span class="token string">'EST'</span><span class="token punctuation">,</span> <span class="token string">'EDT'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> os<span class="token punctuation">.</span>environ<span class="token punctuation">[</span><span class="token string">'TZ'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'Egypt'</span>
<span class="token operator">>></span><span class="token operator">></span> time<span class="token punctuation">.</span>tzset<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> time<span class="token punctuation">.</span>tzname
<span class="token punctuation">(</span><span class="token string">'EET'</span><span class="token punctuation">,</span> <span class="token string">'EEST'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="Clock-ID-常量"><a href="#Clock-ID-常量" class="headerlink" title="Clock ID 常量"></a>Clock ID 常量</h3><p>这些常量用作 <code>clock_getres()</code> 和 <code>clock_gettime()</code> 的参数。</p>
<pre><code>time.CLOCK_BOOTTIME</code></pre><p>与 <code>CLOCK_MONOTONIC</code> 相同，除了它还包括系统暂停的任何时间。</p>
<p>这允许应用程序获得一个暂停感知的单调时钟，而不必处理 <code>CLOCK_REALTIME</code> 的复杂性，如果使用 <code>settimeofday()</code> 或类似的时间更改时间可能会有不连续性。</p>
<p>可用性: Linux 2.6.39 或更新</p>
<p>3.7 新版功能.</p>
<pre><code>time.CLOCK_HIGHRES</code></pre><p>Solaris OS 有一个 <code>CLOCK_HIGHRES</code> 计时器，试图使用最佳硬件源，并可能提供接近纳秒的分辨率。 <code>CLOCK_HIGHRES</code> 是不可调节的高分辨率时钟。</p>
<p>可用性: Solaris.</p>
<p>3.3 新版功能.</p>
<pre><code>time.CLOCK_MONOTONIC</code></pre><p>无法设置的时钟，表示自某些未指定的起点以来的单调时间。</p>
<p>可用性: Unix。</p>
<p>3.3 新版功能.</p>
<pre><code>time.CLOCK_MONOTONIC_RAW</code></pre><p>类似于 <code>CLOCK_MONOTONIC</code> ，但可以访问不受NTP调整影响的原始硬件时间。</p>
<p>可用性: Linux 2.6.28 和更新版本， macOS 10.12 和更新版本。</p>
<p>3.3 新版功能.</p>
<pre><code>time.CLOCK_PROCESS_CPUTIME_ID</code></pre><p>来自CPU的高分辨率每进程计时器。</p>
<p>可用性: Unix。</p>
<p>3.3 新版功能.</p>
<pre><code>time.CLOCK_PROF</code></pre><p>来自CPU的高分辨率每进程计时器。</p>
<p>可用性: FreeBSD， NetBSD 7 或更新， OpenBSD.</p>
<p>3.7 新版功能.</p>
<pre><code>time.CLOCK_TAI</code></pre><p>国际原子时间</p>
<p>该系统必须有一个当前闰秒表以便能给出正确的回答。 PTP 或 NTP 软件可以用来维护闰秒表。</p>
<p>可用性: Linux。</p>
<p>3.9 新版功能.</p>
<pre><code>time.CLOCK_THREAD_CPUTIME_ID</code></pre><p>特定于线程的CPU时钟。</p>
<p>可用性: Unix。</p>
<p>3.3 新版功能.</p>
<pre><code>time.CLOCK_UPTIME</code></pre><p>该时间的绝对值是系统运行且未暂停的时间，提供准确的正常运行时间测量，包括绝对值和间隔值。</p>
<p>可用性: FreeBSD， OpenBSD 5.5 或更新。</p>
<p>3.7 新版功能.</p>
<pre><code>time.CLOCK_UPTIME_RAW</code></pre><p>单调递增的时钟，记录从一个任意起点开始的时间，不受频率或时间调整的影响，并且当系统休眠时将不会递增。</p>
<p>可用性: macOS 10.12 和更新版本。</p>
<p>3.8 新版功能.</p>
<p>以下常量是唯一可以发送到 <code>clock_settime()</code> 的参数。</p>
<pre><code>time.CLOCK_REALTIME</code></pre><p>系统范围的实时时钟。 设置此时钟需要适当的权限。</p>
<p>可用性: Unix。</p>
<p>3.3 新版功能.</p>
<h3 id="时区常量"><a href="#时区常量" class="headerlink" title="时区常量"></a>时区常量</h3><pre><code>time.altzone</code></pre><p>本地DST时区的偏移量，以UTC为单位的秒数，如果已定义。如果当地DST时区在UTC以东（如在西欧，包括英国），则是负数。 只有当 <code>daylight</code> 非零时才使用它。 见下面的注释。</p>
<pre><code>time.daylight</code></pre><p>如果定义了DST时区，则为非零。 见下面的注释。</p>
<pre><code>time.timezone</code></pre><p>本地（非DST）时区的偏移量，UTC以西的秒数（西欧大部分地区为负，美国为正，英国为零）。 见下面的注释。</p>
<pre><code>time.tzname</code></pre><p>两个字符串的元组：第一个是本地非DST时区的名称，第二个是本地DST时区的名称。 如果未定义DST时区，则不应使用第二个字符串。 见下面的注释。</p>
<p>注解</p>
<p>对于上述时区常量（ <code>altzone</code> 、 <code>daylight</code> 、 <code>timezone</code> 和 <code>tzname</code> ），该值由模块加载时有效的时区规则确定，或者最后一次 <code>tzset()</code> 被调用时，并且在过去的时间可能不正确。建议使用来自 <code>localtime()</code> 结果的 <code>tm_gmtoff</code> 和 <code>tm_zone</code> 来获取时区信息。</p>
<h2 id="getopt-—-C-风格的命令行选项解析器"><a href="#getopt-—-C-风格的命令行选项解析器" class="headerlink" title="getopt —- C 风格的命令行选项解析器"></a><code>getopt</code> —- C 风格的命令行选项解析器</h2><p><strong>源代码:</strong> <a href="https://github.com/python/cpython/tree/3.10/Lib/getopt.py" target="_blank" rel="noopener">Lib/getopt.py</a></p>
<p>注解</p>
<p><code>getopt</code> 模块是一个命令行选项解析器，其 API 设计会让 C <code>getopt()</code> 函数的用户感到熟悉。 不熟悉 C <code>getopt()</code> 函数或者希望写更少代码并获得更完善帮助和错误消息的用户应当考虑改用 <code>argparse</code> 模块。</p>
<hr>
<p>此模块可协助脚本解析 <code>sys.argv</code> 中的命令行参数。 它支持与 Unix <code>getopt()</code> 函数相同的惯例（包括形式如 ‘<code>-</code>‘ 与 ‘<code>--</code>‘ 的参数的特殊含义）。 也能通过可选的第三个参数来使用与 GNU 软件所支持形式相类似的长选项。</p>
<p>此模块提供了两个函数和一个异常:</p>
<p><code>getopt.getopt</code>(<em>args</em>, <em>shortopts</em>, <em>longopts=[]</em>)</p>
<p>解析命令行选项与形参列表。 <em>args</em> 为要解析的参数列表，不包含最开头的对正在运行的程序的引用。 通常这意味着 <code>sys.argv[1:]</code>。 <em>shortopts</em> 为脚本所要识别的字母选项，包含要求后缀一个冒号 (<code>':'</code>；即与 Unix <code>getopt()</code> 所用的格式相同) 的选项。</p>
<p>注解</p>
<p>与 GNU <code>getopt()</code> 不同，在非选项参数之后，所有后续参数都会被视为非选项。 这类似于非 GNU Unix 系统的运作方式。</p>
<p>如果指定了 <em>longopts*，则必须为一个由应当被支持的长选项名称组成的列表。 开头的 <code>'--'</code> 字符不应被包括在选项名称中。 要求参数的长选项后应当带一个等号 (<code>'='</code>)。 可选参数不被支持。 如果想仅接受长选项，则 *shortopts</em> 应为一个空字符串。 命令行中的长选项只要提供了恰好能匹配可接受选项之一的选项名称前缀即可被识别。 举例来说，如果 <em>longopts</em> 为 <code>['foo', 'frob']</code>，则选项 <code>--fo</code> 将匹配为 <code>--foo</code>，但 <code>--f</code> 将不能得到唯一匹配，因此将引发 <code>GetoptError</code>。</p>
<p>返回值由两个元素组成：第一个是 <code>(option, value)</code> 对的列表；第二个是在去除该选项列表后余下的程序参数列表（这也就是 <em>args</em> 的尾部切片）。每个被返回的选项与值对的第一个元素是选项，短选项前缀一个连字符 (例如 <code>'-x'</code>)，长选项则前缀两个连字符 (例如 <code>'--long-option'</code>)，第二个元素是选项参数，如果选项不带参数则为空字符串。 列表中选项的排列顺序与它们被解析的顺序相同，因此允许多次出现。 长选项与短选项可以混用。</p>
<p><code>getopt.gnu_getopt</code>(<em>args</em>, <em>shortopts</em>, <em>longopts=[]</em>)</p>
<p>此函数与 <code>getopt()</code> 类似，区别在于它默认使用 GNU 风格的扫描模式。 这意味着选项和非选项参数可能会混在一起。 <code>getopt()</code> 函数将在遇到非选项参数时立即停止处理选项。</p>
<p>如果选项字符串的第一个字符为 <code>'+'</code>，或者如果设置了环境变量 <code>POSIXLY_CORRECT</code>，则选项处理会在遇到非选项参数时立即停止。</p>
<p><em>exception</em> <code>getopt.GetoptError</code></p>
<p>This is raised当参数列表中出现不可识别的选项或者当一个需要参数的选项未带参数时将引发此异常。 此异常的参数是一个指明错误原因的字符串。 对于长选项，将一个参数传给不需要参数的选项也将导致引发此异常。 <code>msg</code> 和 <code>opt</code> 属性会给出错误消息和关联的选项；如果没有关联到异常的特定选项，则 <code>opt</code> 将为空字符串。</p>
<p><em>exception</em> <code>getopt.error</code></p>
<p><code>GetoptError</code> 的别名；用于向后兼容。</p>
<p>一个仅使用 Unix 风格选项的例子:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> getopt
<span class="token operator">>></span><span class="token operator">></span> args <span class="token operator">=</span> <span class="token string">'-a -b -cfoo -d bar a1 a2'</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> args
<span class="token punctuation">[</span><span class="token string">'-a'</span><span class="token punctuation">,</span> <span class="token string">'-b'</span><span class="token punctuation">,</span> <span class="token string">'-cfoo'</span><span class="token punctuation">,</span> <span class="token string">'-d'</span><span class="token punctuation">,</span> <span class="token string">'bar'</span><span class="token punctuation">,</span> <span class="token string">'a1'</span><span class="token punctuation">,</span> <span class="token string">'a2'</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> optlist<span class="token punctuation">,</span> args <span class="token operator">=</span> getopt<span class="token punctuation">.</span>getopt<span class="token punctuation">(</span>args<span class="token punctuation">,</span> <span class="token string">'abc:d:'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> optlist
<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token string">'-a'</span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'-b'</span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'-c'</span><span class="token punctuation">,</span> <span class="token string">'foo'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'-d'</span><span class="token punctuation">,</span> <span class="token string">'bar'</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> args
<span class="token punctuation">[</span><span class="token string">'a1'</span><span class="token punctuation">,</span> <span class="token string">'a2'</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>使用长选项名也同样容易:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> s <span class="token operator">=</span> <span class="token string">'--condition=foo --testing --output-file abc.def -x a1 a2'</span>
<span class="token operator">>></span><span class="token operator">></span> args <span class="token operator">=</span> s<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> args
<span class="token punctuation">[</span><span class="token string">'--condition=foo'</span><span class="token punctuation">,</span> <span class="token string">'--testing'</span><span class="token punctuation">,</span> <span class="token string">'--output-file'</span><span class="token punctuation">,</span> <span class="token string">'abc.def'</span><span class="token punctuation">,</span> <span class="token string">'-x'</span><span class="token punctuation">,</span> <span class="token string">'a1'</span><span class="token punctuation">,</span> <span class="token string">'a2'</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> optlist<span class="token punctuation">,</span> args <span class="token operator">=</span> getopt<span class="token punctuation">.</span>getopt<span class="token punctuation">(</span>args<span class="token punctuation">,</span> <span class="token string">'x'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token string">'condition='</span><span class="token punctuation">,</span> <span class="token string">'output-file='</span><span class="token punctuation">,</span> <span class="token string">'testing'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> optlist
<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token string">'--condition'</span><span class="token punctuation">,</span> <span class="token string">'foo'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'--testing'</span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'--output-file'</span><span class="token punctuation">,</span> <span class="token string">'abc.def'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'-x'</span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> args
<span class="token punctuation">[</span><span class="token string">'a1'</span><span class="token punctuation">,</span> <span class="token string">'a2'</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在脚本中，典型的用法类似这样:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> getopt<span class="token punctuation">,</span> sys
<span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">try</span><span class="token punctuation">:</span>
        opts<span class="token punctuation">,</span> args <span class="token operator">=</span> getopt<span class="token punctuation">.</span>getopt<span class="token punctuation">(</span>sys<span class="token punctuation">.</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">"ho:v"</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">"help"</span><span class="token punctuation">,</span> <span class="token string">"output="</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token keyword">except</span> getopt<span class="token punctuation">.</span>GetoptError <span class="token keyword">as</span> err<span class="token punctuation">:</span>
        <span class="token comment" spellcheck="true"># print help information and exit:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># will print something like "option -a not recognized"</span>
        usage<span class="token punctuation">(</span><span class="token punctuation">)</span>
        sys<span class="token punctuation">.</span>exit<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>
    output <span class="token operator">=</span> None
    verbose <span class="token operator">=</span> <span class="token boolean">False</span>
    <span class="token keyword">for</span> o<span class="token punctuation">,</span> a <span class="token keyword">in</span> opts<span class="token punctuation">:</span>
        <span class="token keyword">if</span> o <span class="token operator">==</span> <span class="token string">"-v"</span><span class="token punctuation">:</span>
            verbose <span class="token operator">=</span> <span class="token boolean">True</span>
        <span class="token keyword">elif</span> o <span class="token keyword">in</span> <span class="token punctuation">(</span><span class="token string">"-h"</span><span class="token punctuation">,</span> <span class="token string">"--help"</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            usage<span class="token punctuation">(</span><span class="token punctuation">)</span>
            sys<span class="token punctuation">.</span>exit<span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">elif</span> o <span class="token keyword">in</span> <span class="token punctuation">(</span><span class="token string">"-o"</span><span class="token punctuation">,</span> <span class="token string">"--output"</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            output <span class="token operator">=</span> a
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            <span class="token keyword">assert</span> <span class="token boolean">False</span><span class="token punctuation">,</span> <span class="token string">"unhandled option"</span>
    <span class="token comment" spellcheck="true"># ...</span>
<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">"__main__"</span><span class="token punctuation">:</span>
    main<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>请注意通过 <code>argparse</code> 模块可以使用更少的代码并附带更详细的帮助与错误消息生成等价的命令行接口:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> argparse
<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>
    parser <span class="token operator">=</span> argparse<span class="token punctuation">.</span>ArgumentParser<span class="token punctuation">(</span><span class="token punctuation">)</span>
    parser<span class="token punctuation">.</span>add_argument<span class="token punctuation">(</span><span class="token string">'-o'</span><span class="token punctuation">,</span> <span class="token string">'--output'</span><span class="token punctuation">)</span>
    parser<span class="token punctuation">.</span>add_argument<span class="token punctuation">(</span><span class="token string">'-v'</span><span class="token punctuation">,</span> dest<span class="token operator">=</span><span class="token string">'verbose'</span><span class="token punctuation">,</span> action<span class="token operator">=</span><span class="token string">'store_true'</span><span class="token punctuation">)</span>
    args <span class="token operator">=</span> parser<span class="token punctuation">.</span>parse_args<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment" spellcheck="true"># ... do something with args.output ...</span>
    <span class="token comment" spellcheck="true"># ... do something with args.verbose ..</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="argparse-—-命令行选项、参数和子命令解析器"><a href="#argparse-—-命令行选项、参数和子命令解析器" class="headerlink" title="argparse —- 命令行选项、参数和子命令解析器"></a><code>argparse</code> —- 命令行选项、参数和子命令解析器</h2><p>3.2 新版功能.</p>
<p><strong>源代码：</strong><a href="https://github.com/python/cpython/tree/3.10/Lib/argparse.py" target="_blank" rel="noopener">Lib/argparse.py</a></p>
<p>模块解析：<a href="https://blog.creativecc.cn/posts/blog-python18.html" target="_blank" rel="noopener">Python-Argparse</a></p>
<h2 id="logging-—-Python-的日志记录工具"><a href="#logging-—-Python-的日志记录工具" class="headerlink" title="logging —- Python 的日志记录工具"></a><code>logging</code> —- Python 的日志记录工具</h2><p><strong>源代码：</strong> <a href="https://github.com/python/cpython/tree/3.10/Lib/logging/__init__.py" target="_blank" rel="noopener">Lib/logging/<strong>init</strong>.py</a></p>
<p>Important</p>
<p>模块解析：<a href="https://blog.creativecc.cn/posts/blog-python21.html" target="_blank" rel="noopener">Python-Logging</a></p>
<p>这个模块为应用与库实现了灵活的事件日志系统的函数与类。</p>
<p>使用标准库提供的 logging API 最主要的好处是，所有的 Python 模块都可能参与日志输出，包括你自己的日志消息和第三方模块的日志消息。</p>
<p>这个模块提供许多强大而灵活的功能。如果你对 logging 不太熟悉的话， 掌握它最好的方式就是查看它对应的教程（详见右侧的链接）。</p>
<p>该模块定义的基础类和函数都列在下面。</p>
<ul>
<li>记录器暴露了应用程序代码直接使用的接口。</li>
<li>处理器将日志记录（由记录器创建）发送到适当的目标。</li>
<li>过滤器提供了更细粒度的功能，用于确定要输出的日志记录。</li>
<li>格式器指定最终输出中日志记录的样式。</li>
</ul>
<h3 id="记录器对象"><a href="#记录器对象" class="headerlink" title="记录器对象"></a>记录器对象</h3><p>记录器有以下的属性和方法。注意 <em>永远</em> 不要直接实例化记录器，应当通过模块级别的函数 <code>logging.getLogger(name)</code> 。多次使用相同的名字调用 <code>getLogger()</code> 会一直返回相同的 Logger 对象的引用。</p>
<p><code>name</code> 一般是句点分割的层级值, 像<code>foo.bar.baz</code> (尽管也可以只是普通的 <code>foo</code>)。层次结构列表中位于下方的记录器是列表中较高位置的记录器的子级。例如，有个名叫 <code>foo</code> 的记录器，而名字是 <code>foo.bar</code>，<code>foo.bar.baz</code>，和 <code>foo.bam</code> 的记录器都是 <code>foo</code> 的子级。记录器的名字分级类似 Python 包的层级，如果您使用建议的结构 <code>logging.getLogger(__name__)</code> 在每个模块的基础上组织记录器，则与之完全相同。这是因为在模块里，<code>__name__</code> 是该模块在 Python 包命名空间中的名字。</p>
<p><em>class</em> <code>logging.Logger</code></p>
<ul>
<li><p><code>propagate</code></p>
<p>如果这个属性为真，记录到这个记录器的事件除了会发送到此记录器的所有处理程序外，还会传递给更高级别（祖先）记录器的处理器，此外任何关联到这个记录器的处理器。消息会直接传递给祖先记录器的处理器 —— 不考虑祖先记录器的级别和过滤器。</p>
<p>如果为假，记录消息将不会传递给当前记录器的祖先记录器的处理器。</p>
<p>构造器将这个属性初始化为 <code>True</code>。</p>
<p>注解</p>
<p>如果你将一个处理器附加到一个记录器 <em>和</em> 其一个或多个祖先记录器，它可能发出多次相同的记录。通常，您不需要将一个处理器附加到一个以上的记录器上 —— 如果您将它附加到记录器层次结构中最高的适当记录器上，则它将看到所有后代记录器记录的所有事件，前提是它们的传播设置保留为 <code>True</code>。一种常见的方案是仅将处理器附加到根记录器，通过传播来处理其余部分。</p>
</li>
<li><p><code>setLevel</code>(<em>level</em>)</p>
<p>给记录器设置阈值为 <em>level</em> 。日志等级小于 <em>level</em> 会被忽略。严重性为 <em>level</em> 或更高的日志消息将由该记录器的任何一个或多个处理器发出，除非将处理器的级别设置为比 <em>level</em> 更高的级别。</p>
<p>创建记录器时，级别默认设置为 <code>NOTSET</code> （当记录器是根记录器时，将处理所有消息；如果记录器不是根记录器，则将委托给父级）。请注意，根记录器的默认级别为 <code>WARNING</code> 。</p>
<p>委派给父级的意思是如果一个记录器的级别设置为 NOTSET，将遍历其祖先记录器，直到找到级别不是 NOTSET 的记录器，或者到根记录器为止。</p>
<p>如果发现某个父级的级别不是 NOTSET ，那么该父级的级别将被视为发起搜索的记录器的有效级别，并用于确定如何处理日志事件。</p>
<p>如果搜索到达根记录器，并且其级别为 NOTSET，则将处理所有消息。否则，将使用根记录器的级别作为有效级别。</p>
<p>在 3.2 版更改: 现在 <em>level</em> 参数可以接受形如 ‘INFO’ 的级别字符串表示形式，以代替形如 <code>INFO</code> 的整数常量。 但是请注意，级别在内部存储为整数，并且 <code>getEffectiveLevel()</code> 和 <code>isEnabledFor()</code> 等方法的传入/返回值也为整数。</p>
</li>
<li><p><code>isEnabledFor</code>(<em>level</em>)</p>
<p>指示此记录器是否将处理级别为 <em>level</em> 的消息。此方法首先检查由 <code>logging.disable(level)</code> 设置的模块级的级别，然后检查由 <code>getEffectiveLevel()</code> 确定的记录器的有效级别。</p>
</li>
<li><p><code>getEffectiveLevel</code>()</p>
<p>指示此记录器的有效级别。如果通过 <code>setLevel()</code> 设置了除 <code>NOTSET</code> 以外的值，则返回该值。否则，将层次结构遍历到根，直到找到除 <code>NOTSET</code> 以外的其他值，然后返回该值。返回的值是一个整数，通常为 <code>logging.DEBUG</code>、 <code>logging.INFO</code> 等等。</p>
</li>
<li><p><code>getChild</code>(<em>suffix</em>)</p>
<p>返回由后缀确定的该记录器的后代记录器。 因此，<code>logging.getLogger('abc').getChild('def.ghi')</code> 与 <code>logging.getLogger('abc.def.ghi')</code> 将返回相同的记录器。 这是一个便捷方法，当使用如 <code>__name__</code> 而不是字符串字面值命名父记录器时很有用。</p>
<p>3.2 新版功能.</p>
</li>
<li><p><code>debug</code>(<em>msg</em>, <em>\</em>args<em>,</em> <em>*kwargs</em>)</p>
<p>在此记录器上记录 <code>DEBUG</code> 级别的消息。 <em>msg</em> 是消息格式字符串，而 <em>args</em> 是用于字符串格式化操作合并到 <em>msg</em> 的参数。（请注意，这意味着您可以在格式字符串中使用关键字以及单个字典参数。）当未提供 <em>args</em> 时，不会对 <em>msg</em> 执行 ％ 格式化操作。</p>
<p>在 <em>kwargs</em> 中会检查四个关键字参数： <em>exc_info</em> ，<em>stack_info</em> ，<em>stacklevel</em> 和 <em>extra</em> 。</p>
<p>如果 <em>exc_info</em> 的求值结果不为 false ，则它将异常信息添加到日志消息中。如果提供了一个异常元组（按照 <code>sys.exc_info()</code> 返回的格式）或一个异常实例，则它将被使用；否则，调用 <code>sys.exc_info()</code> 以获取异常信息。</p>
<p>第二个可选关键字参数是 <em>stack_info*，默认为 <code>False</code>。如果为 True，则将堆栈信息添加到日志消息中，包括实际的日志调用。请注意，这与通过指定 *exc_info</em> 显示的堆栈信息不同：前者是从堆栈底部到当前线程中的日志记录调用的堆栈帧，而后者是在搜索异常处理程序时，跟踪异常而打开的堆栈帧的信息。</p>
<p>您可以独立于 <em>exc_info</em> 来指定 <em>stack_info</em>，例如，即使在未引发任何异常的情况下，也可以显示如何到达代码中的特定点。堆栈帧在标题行之后打印：</p>
<pre><code>Stack (most recent call last):</code></pre><p>这模仿了显示异常帧时所使用的 <code>Traceback (most recent call last):</code> 。</p>
<p>第三个可选关键字参数是 <em>stacklevel</em> ，默认为 <code>1</code> 。如果大于 1 ，则在为日志记录事件创建的 <code>LogRecord</code> 中计算行号和函数名时，将跳过相应数量的堆栈帧。可以在记录帮助器时使用它，以便记录的函数名称，文件名和行号不是帮助器的函数/方法的信息，而是其调用方的信息。此参数是 <code>warnings</code> 模块中的同名等效参数。</p>
<p>第四个关键字参数是 <em>extra</em> ，传递一个字典，该字典用于填充为日志记录事件创建的、带有用户自定义属性的 <code>LogRecord</code> 中的 <strong>dict</strong> 。然后可以按照需求使用这些自定义属性。例如，可以将它们合并到已记录的消息中：</p>
<pre class="line-numbers language-python"><code class="language-python">FORMAT <span class="token operator">=</span> <span class="token string">'%(asctime)-15s %(clientip)s %(user)-8s %(message)s'</span>
logging<span class="token punctuation">.</span>basicConfig<span class="token punctuation">(</span>format<span class="token operator">=</span>FORMAT<span class="token punctuation">)</span>
d <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'clientip'</span><span class="token punctuation">:</span> <span class="token string">'192.168.0.1'</span><span class="token punctuation">,</span> <span class="token string">'user'</span><span class="token punctuation">:</span> <span class="token string">'fbloggs'</span><span class="token punctuation">}</span>
logger <span class="token operator">=</span> logging<span class="token punctuation">.</span>getLogger<span class="token punctuation">(</span><span class="token string">'tcpserver'</span><span class="token punctuation">)</span>
logger<span class="token punctuation">.</span>warning<span class="token punctuation">(</span><span class="token string">'Protocol problem: %s'</span><span class="token punctuation">,</span> <span class="token string">'connection reset'</span><span class="token punctuation">,</span> extra<span class="token operator">=</span>d<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>输出类似于</p>
<pre><code>2006-02-08 22:20:02,165 192.168.0.1 fbloggs  Protocol problem: connection reset</code></pre><p><em>extra</em> 中传入的字典的键不应与日志系统使用的键冲突。</p>
<p>如果在已记录的消息中使用这些属性，则需要格外小心。例如，在上面的示例中，<code>Formatter</code> 已设置了格式字符串，其在 <code>LogRecord</code> 的属性字典中键值为 “clientip” 和 “user”。如果缺少这些内容，则将不会记录该消息，因为会引发字符串格式化异常。因此，在这种情况下，您始终需要使用 <em>extra</em> 字典传递这些键。</p>
<p>尽管这可能很烦人，但此功能旨在用于特殊情况，例如在多个上下文中执行相同代码的多线程服务器，并且出现的有趣条件取决于此上下文（例如在上面的示例中就是远程客户端IP地址和已验证用户名）。在这种情况下，很可能将专门的 <code>Formatter</code> 与特定的 <code>Handler</code> 一起使用。</p>
<p>在 3.2 版更改: 增加了 <em>stack_info</em> 参数。</p>
<p>在 3.5 版更改: <em>exc_info</em> 参数现在可以接受异常实例。</p>
<p>在 3.8 版更改: 增加了 <em>stacklevel</em> 参数。</p>
</li>
<li><p><code>info</code>(<em>msg</em>, <em>\</em>args<em>,</em> <em>*kwargs</em>)</p>
<p>在此记录器上记录 <code>INFO</code> 级别的消息。</p>
</li>
<li><p><code>warning</code>(<em>msg</em>, <em>\</em>args<em>,</em> <em>*kwargs</em>)</p>
<p>在此记录器上记录 <code>WARNING</code> 级别的消息。</p>
<p>注解</p>
<p>有一个功能上与 <code>warning</code> 一致的方法 <code>warn</code>。由于 <code>warn</code> 已被弃用，请不要使用它 —— 改为使用 <code>warning</code>。</p>
</li>
<li><p><code>error</code>(<em>msg</em>, <em>\</em>args<em>,</em> <em>*kwargs</em>)</p>
<p>在此记录器上记录 <code>ERROR</code> 级别的消息。</p>
</li>
<li><p><code>critical</code>(<em>msg</em>, <em>\</em>args<em>,</em> <em>*kwargs</em>)</p>
<p>在此记录器上记录 <code>CRITICAL</code> 级别的消息。</p>
</li>
<li><p><code>log</code>(<em>level</em>, <em>msg</em>, <em>\</em>args<em>,</em> <em>*kwargs</em>)</p>
<p>在此记录器上记录 <em>level</em> 整数代表的级别的消息。</p>
</li>
<li><p><code>exception</code>(<em>msg</em>, <em>\</em>args<em>,</em> <em>*kwargs</em>)</p>
<p>在此记录器上记录 <code>ERROR</code> 级别的消息。异常信息将添加到日志消息中。仅应从异常处理程序中调用此方法。</p>
</li>
<li><p><code>addFilter</code>(<em>filter</em>)</p>
<p>将指定的过滤器 <em>filter</em> 添加到此记录器。</p>
</li>
<li><p><code>removeFilter</code>(<em>filter</em>)</p>
<p>从此记录器中删除指定的过滤器 <em>filter</em>。</p>
</li>
<li><p><code>filter</code>(<em>record</em>)</p>
<p>将此记录器的过滤器应用于记录，如果记录能被处理则返回 <code>True</code>。过滤器会被依次使用，直到其中一个返回假值为止。如果它们都不返回假值，则记录将被处理（传递给处理器）。如果返回任一为假值，则不会对该记录做进一步处理。</p>
</li>
<li><p><code>addHandler</code>(<em>hdlr</em>)</p>
<p>将指定的处理器 <em>hdlr</em> 添加到此记录器。</p>
</li>
<li><p><code>removeHandler</code>(<em>hdlr</em>)</p>
<p>从此记录器中删除指定的处理器 <em>hdlr</em>。</p>
</li>
<li><p><code>findCaller</code>(<em>stack_info=False</em>, <em>stacklevel=1</em>)</p>
<p>查找调用源的文件名和行号，以 文件名，行号，函数名称和堆栈信息 4元素元组的形式返回。堆栈信息将返回 <code>None</code>，除非 <em>stack_info</em> 为 <code>True</code>。</p>
<p><em>stacklevel</em> 参数用于调用 <code>debug()</code> 和其他 API。如果大于 1，则多余部分将用于跳过堆栈帧，然后再确定要返回的值。当从帮助器/包装器代码调用日志记录 API 时，这通常很有用，以便事件日志中的信息不是来自帮助器/包装器代码，而是来自调用它的代码。</p>
</li>
<li><p><code>handle</code>(<em>record</em>)</p>
<p>通过将记录传递给与此记录器及其祖先关联的所有处理器来处理（直到某个 <em>propagate</em> 值为 false）。此方法用于从套接字接收的未序列化的以及在本地创建的记录。使用 <code>filter()</code> 进行记录器级别过滤。</p>
</li>
<li><p><code>makeRecord</code>(<em>name</em>, <em>level</em>, <em>fn</em>, <em>lno</em>, <em>msg</em>, <em>args</em>, <em>exc_info</em>, <em>func=None</em>, <em>extra=None</em>, <em>sinfo=None</em>)</p>
<p>这是一种工厂方法，可以在子类中对其进行重写以创建专门的 <code>LogRecord</code> 实例。</p>
</li>
<li><p><code>hasHandlers</code>()</p>
<p>检查此记录器是否配置了任何处理器。通过在此记录器及其记录器层次结构中的父级中查找处理器完成此操作。如果找到处理器则返回 <code>True</code>，否则返回 <code>False</code>。只要找到 “propagate” 属性设置为假值的记录器，该方法就会停止搜索层次结构 —— 其将是最后一个检查处理器是否存在的记录器。</p>
<p>3.2 新版功能.</p>
</li>
</ul>
<p>在 3.7 版更改: 现在可以对处理器进行序列化和反序列化。</p>
<h3 id="日志级别"><a href="#日志级别" class="headerlink" title="日志级别"></a>日志级别</h3><p>日志记录级别的数值在下表中给出。如果你想要定义自己的级别，并且需要它们具有相对于预定义级别的特定值，那么这你可能对以下内容感兴趣。如果你定义具有相同数值的级别，它将覆盖预定义的值；预定义的名称将失效。</p>
<table>
<thead>
<tr>
<th align="left">级别</th>
<th align="left">数值</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>CRITICAL</code></td>
<td align="left">50</td>
</tr>
<tr>
<td align="left"><code>ERROR</code></td>
<td align="left">40</td>
</tr>
<tr>
<td align="left"><code>WARNING</code></td>
<td align="left">30</td>
</tr>
<tr>
<td align="left"><code>INFO</code></td>
<td align="left">20</td>
</tr>
<tr>
<td align="left"><code>DEBUG</code></td>
<td align="left">10</td>
</tr>
<tr>
<td align="left"><code>NOTSET</code></td>
<td align="left">0</td>
</tr>
</tbody></table>
<h3 id="处理器对象"><a href="#处理器对象" class="headerlink" title="处理器对象"></a>处理器对象</h3><p>Handler 有以下属性和方法。注意不要直接实例化 <code>Handler</code> ；这个类用来派生其他更有用的子类。但是，子类的 <code>__init__()</code> 方法需要调用 <code>Handler.__init__()</code> 。</p>
<p><em>class</em> <code>logging.Handler</code></p>
<ul>
<li><p><code>__init__</code>(<em>level=NOTSET</em>)</p>
<p>初始化 <code>Handler</code> 实例时，需要设置它的级别，将过滤列表置为空，并且创建锁（通过 <code>createLock()</code> ）来序列化对 I/O 的访问。</p>
</li>
<li><p><code>createLock</code>()</p>
<p>初始化一个线程锁，用来序列化对底层的 I/O 功能的访问，底层的 I/O 功能可能不是线程安全的。</p>
</li>
<li><p><code>acquire</code>()</p>
<p>获取由 <code>createLock()</code> 创建的线程锁。</p>
</li>
<li><p><code>release</code>()</p>
<p>释放由 <code>acquire()</code> 获取的线程锁。</p>
</li>
<li><p><code>setLevel</code>(<em>level</em>)</p>
<p>给处理器设置阈值为 <em>level</em> 。日志级别小于 <em>level</em> 将被忽略。创建处理器时，日志级别被设置为 <code>NOTSET</code> （所有的消息都会被处理）。</p>
<p>在 3.2 版更改: <em>level</em> 形参现在接受像 ‘INFO’ 这样的字符串形式的级别表达方式，也可以使用像 <code>INFO</code> 这样的整数常量。</p>
</li>
<li><p><code>setFormatter</code>(<em>fmt</em>)</p>
<p>将此处理器的 <code>Formatter</code> 设置为 <em>fmt</em>。</p>
</li>
<li><p><code>addFilter</code>(<em>filter</em>)</p>
<p>将指定的过滤器 <em>filter</em> 添加到此处理器。</p>
</li>
<li><p><code>removeFilter</code>(<em>filter</em>)</p>
<p>从此处理器中删除指定的过滤器 <em>filter</em> 。</p>
</li>
<li><p><code>filter</code>(<em>record</em>)</p>
<p>将此处理器的过滤器应用于记录，在要处理记录时返回 <code>True</code> 。依次查询过滤器，直到其中一个返回假值为止。如果它们都不返回假值，则将发出记录。如果返回一个假值，则处理器将不会发出记录。</p>
</li>
<li><p><code>flush</code>()</p>
<p>确保所有日志记录从缓存输出。此版本不执行任何操作，并且应由子类实现。</p>
</li>
<li><p><code>close</code>()</p>
<p>回收处理器使用的所有资源。此版本不输出，但从内部处理器列表中删除处理器，内部处理器在 <code>shutdown()</code> 被调用时关闭 。子类应确保从重写的 <code>close()</code> 方法中调用此方法。</p>
</li>
<li><p><code>handle</code>(<em>record</em>)</p>
<p>经已添加到处理器的过滤器过滤后，有条件地发出指定的日志记录。用获取/释放 I/O 线程锁包装了记录的实际发出行为。</p>
</li>
<li><p><code>handleError</code>(<em>record</em>)</p>
<p>调用 <code>emit()</code> 期间遇到异常时，应从处理器中调用此方法。如果模块级属性 <code>raiseExceptions</code> 是 <code>False</code>，则异常将被静默忽略。这是大多数情况下日志系统需要的 —— 大多数用户不会关心日志系统中的错误，他们对应用程序错误更感兴趣。但是，你可以根据需要将其替换为自定义处理器。指定的记录是发生异常时正在处理的记录。（<code>raiseExceptions</code> 的默认值是 <code>True</code>，因为这在开发过程中是比较有用的）。</p>
</li>
<li><p><code>format</code>(<em>record</em>)</p>
<p>如果设置了格式器则用其对记录进行格式化。否则，使用模块的默认格式器。</p>
</li>
<li><p><code>emit</code>(<em>record</em>)</p>
<p>执行实际记录给定日志记录所需的操作。这个版本应由子类实现，因此这里直接引发 <code>NotImplementedError</code> 异常。</p>
</li>
</ul>
<h3 id="格式器对象"><a href="#格式器对象" class="headerlink" title="格式器对象"></a>格式器对象</h3><p><code>Formatter</code> 对象拥有以下的属性和方法。一般情况下，它们负责将 <code>LogRecord</code> 转换为可由人或外部系统解释的字符串。基础的 <code>Formatter</code> 允许指定格式字符串。如果未提供任何值，则使用默认值 <code>'%(message)s'</code> ，它仅将消息包括在日志记录调用中。要在格式化输出中包含其他信息（如时间戳），请阅读下文。</p>
<p>格式器可以使用格式化字符串来初始化，该字符串利用 <code>LogRecord</code> 的属性 —— 例如上述默认值，用户的消息和参数预先格式化为 <code>LogRecord</code> 的 <em>message</em> 属性后被使用。此格式字符串包含标准的 Python %-s 样式映射键。</p>
<p><em>class</em> <code>logging.Formatter</code>(<em>fmt=None</em>, <em>datefmt=None</em>, <em>style=’%’</em>, <em>validate=True</em>, <em>**,</em> defaults=None*)</p>
<p>返回 <code>Formatter</code> 类的新实例。实例将使用整个消息的格式字符串以及消息的日期/时间部分的格式字符串进行初始化。如果未指定 <em>fmt</em> ，则使用 <code>'%(message)s'</code>。如果未指定 <em>datefmt</em>，则使用 <code>formatTime()</code> 文档中描述的格式。</p>
<p><em>style</em> 形参可以是 ‘%’, ‘{‘ 或 ‘$’ 之一，它决定格式字符串将如何与数据进行合并：使用 %-formatting, <a href="https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#str.format" target="_blank" rel="noopener"><code>str.format()</code></a> 或是 <a href="https://www.bookstack.cn/read/python-3.10.0-zh/1cb7b20c32bbf2f2.md#string.Template" target="_blank" rel="noopener"><code>string.Template</code></a>。 这仅适用于格式字符串 <em>fmt</em> (例如 <code>'%(message)s'</code> 或 <code>{message}</code>)，不适用于传递给 <code>Logger.debug</code> 的实际日志消息等；请参阅 <a href="https://www.bookstack.cn/read/python-3.10.0-zh/453d77a93b48320d.md#formatting-styles" target="_blank" rel="noopener">生效于整个应用程序的格式化样式</a> 了解有关在日志消息中使用 {- 和 $-formatting 的更多详情。</p>
<p><em>defaults</em> 形参可以是一个包含在自定义字段中使用的默认值的字典。 例如: <code>logging.Formatter('%(ip)s %(message)s', defaults={"ip": None})</code></p>
<p>在 3.2 版更改: 加入了 <em>style</em> 形参。</p>
<p>在 3.8 版更改: 加入<em>validate</em> 参数。不正确或不匹配的样式和格式将引发 <code>ValueError</code> 错误。例如: <code>logging.Formatter('%(asctime)s - %(message)s', style='{')</code>。</p>
<p>在 3.10 版更改: 增加了 <em>defaults</em> 形参。</p>
<ul>
<li><p><code>format</code>(<em>record</em>)</p>
<p>记录的属性字典被用作字符串格式化操作的操作数。 返回结果字符串。 在格式化该字典之前，会执行几个预备步骤。 记录的 <em>message</em> 属性是用 <em>msg</em> % <em>args</em> 来计算的。 如果格式化字符串包含 <code>'(asctime)'</code>，则会调用 <code>formatTime()</code> 来格式化事件时间。 如果有异常信息，则使用 <code>formatException()</code> 将其格式化并添加到消息中。 请注意已格式化的异常信息会缓存在 <em>exc_text</em> 属性中。 这很有用因为异常信息可以被 pickle 并通过网络发送，但是如果你有不止一个对异常信息进行定制的 <code>Formatter</code> 子类则应当小心。 在这种情况下，你必须在一个格式化器完成格式化后清空缓存的值 (通过将 <em>exc_text</em> 属性设为 <code>None</code>)，以便下一个处理事件的格式化器不会使用缓存的值，而是重新计算它。</p>
<p>如果栈信息可用，它将被添加在异常信息之后，如有必要请使用 <code>formatStack()</code> 来转换它。</p>
</li>
<li><p><code>formatTime</code>(<em>record</em>, <em>datefmt=None</em>)</p>
<p>此方法应由想要使用格式化时间的格式器中的 <code>format()</code> 调用。可以在格式器中重写此方法以提供任何特定要求，但是基本行为如下：如果指定了 <em>datefmt</em> （字符串），则将其用于 <code>time.strftime()</code> 来格式化记录的创建时间。否则，使用格式 ‘%Y-%m-%d %H:%M:%S,uuu’，其中 uuu 部分是毫秒值，其他字母根据 <code>time.strftime()</code> 文档。这种时间格式的示例为 <code>2003-01-23 00:29:50,411</code>。返回结果字符串。</p>
<p>此函数使用一个用户可配置函数将创建时间转换为元组。 默认情况下，使用 <code>time.localtime()</code>；要为特定格式化程序实例更改此项，请将实例的 <code>converter</code> 属性设为具有与 <code>time.localtime()</code> 或 <code>time.gmtime()</code> 相同签名的函数。 要为所有格式化程序更改此项，例如当你希望所有日志时间都显示为 GMT，请在 <code>Formatter</code> 类中设置 <code>converter</code> 属性。</p>
<p>在 3.3 版更改: 在之前版本中，默认格式是被硬编码的，例如这个例子: <code>2010-09-06 22:38:15,292</code> 其中逗号之前的部分由 strptime 格式字符串 (<code>'%Y-%m-%d %H:%M:%S'</code>) 处理，而逗号之后的部分为毫秒值。 因为 strptime 没有表示毫秒的占位符，毫秒值使用了另外的格式字符串来添加 <code>'%s,%03d'</code> —- 这两个格式字符串代码都是硬编码在该方法中的。 经过修改，这些字符串被定义为类层级的属性，当需要时可以在实例层级上被重载。 属性的名称为 <code>default_time_format</code> (用于 strptime 格式字符串) 和 <code>default_msec_format</code> (用于添加毫秒值)。</p>
<p>在 3.9 版更改: <code>default_msec_format</code> 可以为 <code>None</code>。</p>
</li>
<li><p><code>formatException</code>(<em>exc_info</em>)</p>
<p>将指定的异常信息（由 <code>sys.exc_info()</code> 返回的标准异常元组）格式化为字符串。默认实现只是使用了 <code>traceback.print_exception()</code>。 结果字符串将被返回。</p>
</li>
<li><p><code>formatStack</code>(<em>stack_info</em>)</p>
<p>将指定的堆栈信息（由 <code>traceback.print_stack()</code> 返回的字符串，但移除末尾的换行符）格式化为字符串。 默认实现只是返回输入值。</p>
</li>
</ul>
<h3 id="过滤器对象"><a href="#过滤器对象" class="headerlink" title="过滤器对象"></a>过滤器对象</h3><p><code>Filters</code> 可被 <code>Handlers</code> 和 <code>Loggers</code> 用来实现比按层级提供更复杂的过滤操作。 基本过滤器类只允许低于日志记录器层级结构中低于特定层级的事件。 例如，一个用 ‘A.B’ 初始化的过滤器将允许 ‘A.B’, ‘A.B.C’, ‘A.B.C.D’, ‘A.B.D’ 等日志记录器所记录的事件。 但 ‘A.BB’, ‘B.A.B’ 等则不允许。 如果用空字符串初始化，则所有事件都会通过。</p>
<p><em>class</em> <code>logging.Filter</code>(<em>name=’’</em>)</p>
<p>返回一个 <code>Filter</code> 类的实例。 如果指定了 <em>name*，则它将被用来为日志记录器命名，该类及其子类将通过该过滤器允许指定事件通过。 如果 *name</em> 为空字符串，则允许所有事件通过。</p>
<ul>
<li><p><code>filter</code>(<em>record</em>)</p>
<p>是否要记录指定的记录？返回零表示否，非零表示是。如果认为合适，则可以通过此方法就地修改记录。</p>
</li>
</ul>
<p>请注意关联到处理器的过滤器会在事件由处理器发出之前被查询，而关联到日志记录器的过滤器则会在有事件被记录的的任何时候（使用 <code>debug()</code>, <code>info()</code> 等等）在将事件发送给处理器之前被查询。 这意味着由后代日志记录器生成的事件将不会被父代日志记录器的过滤器设置所过滤，除非该过滤器也已被应用于后代日志记录器。</p>
<p>你实际上不需要子类化 <code>Filter</code> ：你可以传入任何一个包含有相同语义的 <code>filter</code> 方法的实例。</p>
<p>在 3.2 版更改: 你不需要创建专门的 <code>Filter</code> 类，或使用具有 <code>filter</code> 方法的其他类：你可以使用一个函数（或其他可调用对象）作为过滤器。 过滤逻辑将检查过滤器对象是否具有 <code>filter</code> 属性：如果有，就会将它当作是 <code>Filter</code> 并调用它的 <code>filter()</code> 方法。 在其他情况下，则会将它当作是可调用对象并将记录作为唯一的形参进行调用。 返回值应当与 <code>filter()</code> 的返回值相一致。</p>
<p>尽管过滤器主要被用来构造比层级更复杂的规则以过滤记录，但它们可以查看由它们关联的处理器或记录器所处理的每条记录：当你想要执行统计特定记录器或处理器共处理了多少条记录，或是在所处理的 <code>LogRecord</code> 中添加、修改或移除属性这样的任务时该特性将很有用处。 显然改变 LogRecord 时需要相当小心，但将上下文信息注入日志确实是被允许的。</p>
<h3 id="LogRecord"><a href="#LogRecord" class="headerlink" title="LogRecord"></a>LogRecord</h3><p><code>LogRecord</code> 实例是每当有日志被记录时由 <code>Logger</code> 自动创建的，并且可通过 <code>makeLogRecord()</code> 手动创建（例如根据从网络接收的已封存事件创建）。</p>
<p><em>class</em> <code>logging.LogRecord</code>(<em>name</em>, <em>level</em>, <em>pathname</em>, <em>lineno</em>, <em>msg</em>, <em>args</em>, <em>exc_info</em>, <em>func=None</em>, <em>sinfo=None</em>)</p>
<p>包含与被记录的事件相关的所有信息。</p>
<p>主要信息是在 <code>msg</code> 和 <code>args</code> 中传递的，它们使用 <code>msg % args</code> 组合到一起以创建记录的 <code>message</code> 字段。</p>
<ul>
<li><p>参数</p>
<ul>
<li><strong>name</strong> — 用于记录由此 LogRecord 所表示事件的记录器名称。 请注意此名称将始终为该值，即使它可能是由附加到不同（祖先）日志记录器的处理器所发出的。</li>
<li><strong>level</strong> — 以数字表示的日志记录事件层级（如 DEBUG, INFO 等）。 请注意这会转换为 LogRecord 的 <em>两个</em> 属性: <code>levelno</code> 为数字值而 <code>levelname</code> 为对应的层级名称。</li>
<li><strong>pathname</strong> — 进行日志记录调用的文件的完整路径名。</li>
<li><strong>lineno</strong> — 记录调用所在源文件中的行号。</li>
<li><strong>msg</strong> — 事件描述消息，可能为带有可变数据占位符的格式字符串。</li>
<li><strong>args</strong> — 要合并到 <em>msg</em> 参数以获得事件描述的可变数据。</li>
<li><strong>exc_info</strong> — 包含当前异常信息的异常元组，或者如果没有可用异常信息则为 <code>None</code>。</li>
<li><strong>func</strong> — 发起调用日志记录调用的函数或方法名称。</li>
<li><strong>sinfo</strong> — 一个文本字符串，表示当前线程中从堆栈底部直到日志记录调用的堆栈信息。</li>
</ul>
</li>
<li><p><code>getMessage</code>()</p>
<p>在将 <code>LogRecord</code> 实例与任何用户提供的参数合并之后，返回此实例的消息。 如果用户提供给日志记录调用的消息参数不是字符串，则会在其上调用 <code>str()</code> 以将它转换为字符串。 此方法允许将用户定义的类用作消息，类的 <code>__str__</code> 方法可以返回要使用的实际格式字符串。</p>
</li>
</ul>
<p>在 3.2 版更改: 通过提供用于创建记录的工厂方法已使得 <code>LogRecord</code> 的创建更易于配置。 该工厂方法可使用 <code>getLogRecordFactory()</code> 和 <code>setLogRecordFactory()</code> （在此可查看工厂方法的签名）来设置。</p>
<p>在创建时可使用此功能将你自己的值注入 <code>LogRecord</code>。 你可以使用以下模式:</p>
<pre class="line-numbers language-python"><code class="language-python">old_factory <span class="token operator">=</span> logging<span class="token punctuation">.</span>getLogRecordFactory<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">record_factory</span><span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>
    record <span class="token operator">=</span> old_factory<span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span>
    record<span class="token punctuation">.</span>custom_attribute <span class="token operator">=</span> <span class="token number">0xdecafbad</span>
    <span class="token keyword">return</span> record
logging<span class="token punctuation">.</span>setLogRecordFactory<span class="token punctuation">(</span>record_factory<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>通过此模式，多个工厂方法可以被链接起来，并且只要它们不重载彼此的属性或是在无意中覆盖了上面列出的标准属性，就不会发生意外。</p>
<h3 id="LogRecord-属性"><a href="#LogRecord-属性" class="headerlink" title="LogRecord 属性"></a>LogRecord 属性</h3><p>LogRecord 具有许多属性，它们大多数来自于传递给构造器的形参。 （请注意 LogRecord 构造器形参与 LogRecord 属性的名称并不总是完全彼此对应的。） 这些属性可被用于将来自记录的数据合并到格式字符串中。 下面的表格（按字母顺序）列出了属性名称、它们的含义以及相应的 %-style 格式字符串内占位符。</p>
<p>如果是使用 {}-格式化（<code>str.format()</code>），你可以将 <code>{attrname}</code> 用作格式字符串内的占位符。 如果是使用 $-格式化（<code>string.Template</code>），则会使用 <code>${attrname}</code> 的形式。 当然在这两种情况下，都应当将 <code>attrname</code> 替换为你想要使用的实际属性名称。</p>
<p>在 {}-格式化的情况下，你可以在属性名称之后放置指定的格式化旗标，并用冒号来分隔两者。 例如，占位符 <code>{msecs:03d}</code> 会将毫秒值 <code>4</code> 格式化为 <code>004</code>。 请参看 <code>str.format()</code> 文档了解你所能使用的选项的完整细节。</p>
<table>
<thead>
<tr>
<th align="left">属性名称</th>
<th align="left">格式</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">args</td>
<td align="left">此属性不需要用户进行格式化。</td>
<td align="left">合并到 <code>msg</code> 以产生 <code>message</code> 的包含参数的元组，或是其中的值将被用于合并的字典（当只有一个参数且其类型为字典时）。</td>
</tr>
<tr>
<td align="left">asctime</td>
<td align="left"><code>%(asctime)s</code></td>
<td align="left">表示 <code>LogRecord</code> 何时被创建的供人查看时间值。 默认形式为 ‘2003-07-08 16:49:45,896’ （逗号之后的数字为时间的毫秒部分）。</td>
</tr>
<tr>
<td align="left">created</td>
<td align="left"><code>%(created)f</code></td>
<td align="left"><code>LogRecord</code> 被创建的时间（即 <code>time.time()</code> 的返回值）。</td>
</tr>
<tr>
<td align="left">exc_info</td>
<td align="left">此属性不需要用户进行格式化。</td>
<td align="left">异常元组（例如 <code>sys.exc_info</code>）或者如未发生异常则为 <code>None</code>。</td>
</tr>
<tr>
<td align="left">文件名</td>
<td align="left"><code>%(filename)s</code></td>
<td align="left"><code>pathname</code> 的文件名部分。</td>
</tr>
<tr>
<td align="left">funcName</td>
<td align="left"><code>%(funcName)s</code></td>
<td align="left">函数名包括调用日志记录.</td>
</tr>
<tr>
<td align="left">levelname</td>
<td align="left"><code>%(levelname)s</code></td>
<td align="left">消息文本记录级别（<code>‘DEBUG’</code>，<code>‘INFO’</code>，<code>‘WARNING’</code>，<code>‘ERROR’</code>，<code>‘CRITICAL’</code>）。</td>
</tr>
<tr>
<td align="left">levelno</td>
<td align="left"><code>%(levelno)s</code></td>
<td align="left">消息数字的记录级别 (<code>DEBUG</code>, <code>INFO</code>, <code>WARNING</code>, <code>ERROR</code>, <code>CRITICAL</code>).</td>
</tr>
<tr>
<td align="left">lineno</td>
<td align="left"><code>%(lineno)d</code></td>
<td align="left">发出日志记录调用所在的源行号（如果可用）。</td>
</tr>
<tr>
<td align="left">message</td>
<td align="left"><code>%(message)s</code></td>
<td align="left">记入日志的消息，即 <code>msg % args</code> 的结果。 这是在发起调用 <code>Formatter.format()</code> 时设置的。</td>
</tr>
<tr>
<td align="left">module — 模块</td>
<td align="left"><code>%(module)s</code></td>
<td align="left">模块 (<code>filename</code> 的名称部分)。</td>
</tr>
<tr>
<td align="left">msecs</td>
<td align="left"><code>%(msecs)d</code></td>
<td align="left"><code>LogRecord</code> 被创建的时间的毫秒部分。</td>
</tr>
<tr>
<td align="left">msg</td>
<td align="left">此属性不需要用户进行格式化。</td>
<td align="left">在原始日志记录调用中传入的格式字符串。 与 <code>args</code> 合并以产生 <code>message</code>，或是一个任意对象。</td>
</tr>
<tr>
<td align="left">名称</td>
<td align="left"><code>%(name)s</code></td>
<td align="left">用于记录调用的日志记录器名称。</td>
</tr>
<tr>
<td align="left">pathname</td>
<td align="left"><code>%(pathname)s</code></td>
<td align="left">发出日志记录调用的源文件的完整路径名（如果可用）。</td>
</tr>
<tr>
<td align="left">process</td>
<td align="left"><code>%(process)d</code></td>
<td align="left">进程ID（如果可用）</td>
</tr>
<tr>
<td align="left">processName</td>
<td align="left"><code>%(processName)s</code></td>
<td align="left">进程名（如果可用）</td>
</tr>
<tr>
<td align="left">relativeCreated</td>
<td align="left"><code>%(relativeCreated)d</code></td>
<td align="left">以毫秒数表示的 LogRecord 被创建的时间，即相对于 logging 模块被加载时间的差值。</td>
</tr>
<tr>
<td align="left">stack_info</td>
<td align="left">此属性不需要用户进行格式化。</td>
<td align="left">当前线程中从堆栈底部起向上直到包括日志记录调用并引发创建当前记录堆栈帧创建的堆栈帧信息（如果可用）。</td>
</tr>
<tr>
<td align="left">thread</td>
<td align="left"><code>%(thread)d</code></td>
<td align="left">线程ID（如果可用）</td>
</tr>
<tr>
<td align="left">threadName</td>
<td align="left"><code>%(threadName)s</code></td>
<td align="left">线程名（如果可用）</td>
</tr>
</tbody></table>
<p>在 3.1 版更改: 添加了 <em>processName</em></p>
<h3 id="LoggerAdapter-对象"><a href="#LoggerAdapter-对象" class="headerlink" title="LoggerAdapter 对象"></a>LoggerAdapter 对象</h3><p><code>LoggerAdapter</code> 实例会被用来方便地将上下文信息传入日志记录调用。 </p>
<p><em>class</em> <code>logging.LoggerAdapter</code>(<em>logger</em>, <em>extra</em>)</p>
<p>返回一个 <code>LoggerAdapter</code> 的实例，该实例的初始化使用了下层的 <code>Logger</code> 实例和一个字典类对象。</p>
<ul>
<li><p><code>process</code>(<em>msg</em>, <em>kwargs</em>)</p>
<p>修改传递给日志记录调用的消息和/或关键字参数以便插入上下文信息。 此实现接受以 <em>extra</em> 形式传给构造器的对象并使用 ‘extra’ 键名将其加入 <em>kwargs<em>。 返回值为一个 (</em>msg</em>, <em>kwargs</em>) 元组，其包含（可能经过修改的）传入参数。</p>
</li>
</ul>
<p>在上述方法之外，<code>LoggerAdapter</code> 还支持 <code>Logger</code> 的下列方法: <code>debug()</code>, <code>info()</code>，<code>warning()</code>，<code>error()</code>, <code>exception()</code>, <code>critical()</code>，<code>log()</code>，<code>isEnabledFor()</code>，<code>getEffectiveLevel()</code>，<code>setLevel()</code> 以及 <code>hasHandlers()</code>。 这些方法具有与它们在 <code>Logger</code> 中的对应方法相同的签名，因此你可以互换使用这两种类型的实例。</p>
<p>在 3.2 版更改: <code>isEnabledFor()</code>, <code>getEffectiveLevel()</code>, <code>setLevel()</code> 和 <code>hasHandlers()</code> 方法已被添加到 <code>LoggerAdapter</code>。 这些方法会委托给下层的日志记录器。</p>
<p>在 3.6 版更改: 增加了 <code>manager</code> 属性和 <code>_log()</code> 方法，它们会委托给下层的日志记录器并允许适配器嵌套。</p>
<h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><p>logging 模块的目标是使客户端不必执行任何特殊操作即可确保线程安全。 它通过使用线程锁来达成这个目标；用一个锁来序列化对模块共享数据的访问，并且每个处理程序也会创建一个锁来序列化对其下层 I/O 的访问。</p>
<p>如果你要使用 <code>signal</code> 模块来实现异步信号处理程序，则可能无法在这些处理程序中使用 logging。 这是因为 <code>threading</code> 模块中的锁实现并非总是可重入的，所以无法从此类信号处理程序发起调用。</p>
<h3 id="模块级函数"><a href="#模块级函数" class="headerlink" title="模块级函数"></a>模块级函数</h3><p>在上述的类之外，还有一些模块级的函数。</p>
<p><code>logging.getLogger</code>(<em>name=None</em>)</p>
<p>返回具有指定 name 的日志记录器，或者当 name 为 <code>None</code> 时返回层级结构中的根日志记录器。 如果指定了 name，它通常是以点号分隔的带层级结构的名称，如 <em>‘a’<em>、</em>‘a.b’</em> 或 <em>‘a.b.c.d’</em>。 这些名称的选择完全取决于使用 logging 的开发者。</p>
<p>所有用给定的 name 对该函数的调用都将返回相同的日志记录器实例。 这意味着日志记录器实例不需要在应用的各部分间传递。</p>
<p><code>logging.getLoggerClass</code>()</p>
<p>返回标准的 <code>Logger</code> 类，或是最近传给 <code>setLoggerClass()</code> 的类。 此函数可以从一个新的类定义中调用，以确保安装自定义的 <code>Logger</code> 类不会撤销其他代码已经应用的自定义操作。 例如:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">MyLogger</span><span class="token punctuation">(</span>logging<span class="token punctuation">.</span>getLoggerClass<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token comment" spellcheck="true"># ... override behaviour here</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><code>logging.getLogRecordFactory</code>()</p>
<p>返回一个被用来创建 <code>LogRecord</code> 的可调用对象。</p>
<p>3.2 新版功能: 此函数与 <code>setLogRecordFactory()</code> 一起提供，以允许开发者对表示日志记录事件的 <code>LogRecord</code> 的构造有更好的控制。</p>
<p>请参阅 <code>setLogRecordFactory()</code> 了解有关如何调用该工厂方法的更多信息。</p>
<p><code>logging.debug</code>(<em>msg</em>, <em>\</em>args<em>,</em> <em>*kwargs</em>)</p>
<p>在根日志记录器上记录一条 <code>DEBUG</code> 级别的消息。 <em>msg</em> 是消息格式字符串，而 <em>args</em> 是要使用字符串格式化运算符合并到 <em>msg</em> 的参数。 （请注意这意味着你可以在格式字符串中使用关键字以及单个字典参数。）</p>
<p>在 <em>kwargs</em> 中有三个关键字参数会被检查: <em>exc_info</em> 参数如果不为假值则会将异常信息添加到日志记录消息。 如果提供了异常元组（为 <code>sys.exc_info()</code> 的返回值格式）或异常实例则它会被使用；在其他情况下，会调用 <code>sys.exc_info()</code> 以获取异常信息。</p>
<p>第二个可选关键字参数是 <em>stack_info*，默认为 <code>False</code>。如果为 True，则将堆栈信息添加到日志消息中，包括实际的日志调用。请注意，这与通过指定 *exc_info</em> 显示的堆栈信息不同：前者是从堆栈底部到当前线程中的日志记录调用的堆栈帧，而后者是在搜索异常处理程序时，跟踪异常而打开的堆栈帧的信息。</p>
<p>您可以独立于 <em>exc_info</em> 来指定 <em>stack_info</em>，例如，即使在未引发任何异常的情况下，也可以显示如何到达代码中的特定点。堆栈帧在标题行之后打印：</p>
<pre><code>Stack (most recent call last):</code></pre><p>这模仿了显示异常帧时所使用的 <code>Traceback (most recent call last):</code> 。</p>
<p>第三个可选关键字参数是 <em>extra</em>，它可被用来传递一个字典，该字典会被用来填充为日志记录事件创建并附带用户自定义属性的 LogRecord 的 <strong>dict</strong>。 之后将可按你的需要使用这些自定义属性。 例如，可以将它们合并到已记录的消息中。 举例来说:</p>
<pre class="line-numbers language-python"><code class="language-python">FORMAT <span class="token operator">=</span> <span class="token string">'%(asctime)-15s %(clientip)s %(user)-8s %(message)s'</span>
logging<span class="token punctuation">.</span>basicConfig<span class="token punctuation">(</span>format<span class="token operator">=</span>FORMAT<span class="token punctuation">)</span>
d <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'clientip'</span><span class="token punctuation">:</span> <span class="token string">'192.168.0.1'</span><span class="token punctuation">,</span> <span class="token string">'user'</span><span class="token punctuation">:</span> <span class="token string">'fbloggs'</span><span class="token punctuation">}</span>
logging<span class="token punctuation">.</span>warning<span class="token punctuation">(</span><span class="token string">'Protocol problem: %s'</span><span class="token punctuation">,</span> <span class="token string">'connection reset'</span><span class="token punctuation">,</span> extra<span class="token operator">=</span>d<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>应当会打印出这样的内容:</p>
<pre><code>2006-02-08 22:20:02,165 192.168.0.1 fbloggs  Protocol problem: connection reset</code></pre><p><em>extra</em> 中传入的字典的键不应与日志系统使用的键冲突。</p>
<p>如果你选择在已记录的消息中使用这些属性，则需要格外小心。 例如在上面的示例中，<code>Formatter</code> 已设置了格式字符串，其在 LogRecord 的属性字典中应有 ‘clientip’ 和 ‘user’。 如果缺少这些属性，消息将不被记录，因为会引发字符串格式化异常，你始终需要传入带有这些键的 <em>extra</em> 字典。</p>
<p>尽管这可能很烦人，但此功能旨在用于特殊情况，例如在多个上下文中执行相同代码的多线程服务器，并且出现的有趣条件取决于此上下文（例如在上面的示例中就是远程客户端IP地址和已验证用户名）。在这种情况下，很可能将专门的 <code>Formatter</code> 与特定的 <code>Handler</code> 一起使用。</p>
<p>在 3.2 版更改: 增加了 <em>stack_info</em> 参数。</p>
<p><code>logging.info</code>(<em>msg</em>, <em>\</em>args<em>,</em> <em>*kwargs</em>)</p>
<p>在根日志记录器上记录一条 <code>INFO</code> 级别的消息。</p>
<p><code>logging.warning</code>(<em>msg</em>, <em>\</em>args<em>,</em> <em>*kwargs</em>)</p>
<p>在根日志记录器上记录一条 <code>WARNING</code> 级别的消息。</p>
<p>注解</p>
<p>有一个已过时方法 <code>warn</code> 其功能与 <code>warning</code> 一致。 由于 <code>warn</code> 已被弃用，请不要使用它 —— 而是改用 <code>warning</code>。</p>
<p><code>logging.error</code>(<em>msg</em>, <em>\</em>args<em>,</em> <em>*kwargs</em>)</p>
<p>在根日志记录器上记录一条 <code>ERROR</code> 级别的消息。 </p>
<p><code>logging.critical</code>(<em>msg</em>, <em>\</em>args<em>,</em> <em>*kwargs</em>)</p>
<p>在根日志记录器上记录一条 <code>CRITICAL</code> 级别的消息。</p>
<p><code>logging.exception</code>(<em>msg</em>, <em>\</em>args<em>,</em> <em>*kwargs</em>)</p>
<p>在根日志记录器上记录一条 <code>ERROR</code> 级别的消息。 异常信息将被添加到日志消息中。 此函数应当仅从异常处理程序中调用。</p>
<p><code>logging.log</code>(<em>level</em>, <em>msg</em>, <em>\</em>args<em>,</em> <em>*kwargs</em>)</p>
<p>在根日志记录器上记录一条 <em>level</em> 级别的消息。 </p>
<p>注解</p>
<p>上述模块级的便捷函数均委托给根日志记录器，它们会调用 <code>basicConfig()</code> 以确保至少有一个处理器可用。 因此，在 Python 2.7.1 和 3.2 之前的版本中，除非线程启动 <em>之前</em> 已向根日志记录器添加了至少一个处理器，它们 <em>不应</em> 在线程中使用。 在较早的 Python 版本中，由于 <code>basicConfig()</code> 中存在线程安全性的不足，这（在少数情况下）可能导致处理器被多次加入根日志记录器，这会导致同一事件出现多条消息。</p>
<p><code>logging.disable</code>(<em>level=CRITICAL</em>)</p>
<p>为所有日志记录器提供重载的级别 <em>level*，其优先级高于日志记录器自己的级别。 当需要临时限制整个应用程序中的日志记录输出时，此功能会很有用。 它的效果是禁用所有重要程度为 *level</em> 及以下的日志记录调用，因此如果你附带 INFO 值调用它，则所有 INFO 和 DEBUG 事件就会被丢弃，而重要程度为 WARNING 以及上的事件将根据日志记录器的当前有效级别来处理。 如果 <code>logging.disable(logging.NOTSET)</code> 被调用，它将移除这个重载的级别，因此日志记录输出会再次取决于单个日志记录器的有效级别。</p>
<p>请注意如果你定义了任何高于 <code>CRITICAL</code> 的自定义日志级别（并不建议这样做），你就将无法沿用 <em>level</em> 形参的默认值，而必须显式地提供适当的值。</p>
<p>在 3.7 版更改: <em>level</em> 形参默认级别为 <code>CRITICAL</code>。 请参阅 <a href="https://bugs.python.org/issue28524" target="_blank" rel="noopener">bpo-28524</a> 了解此项改变的更多细节。</p>
<p><code>logging.addLevelName</code>(<em>level</em>, <em>levelName</em>)</p>
<p>在一个内部字典中关联级别 <em>level</em> 与文本 <em>levelName</em>，该字典会被用来将数字级别映射为文本表示形式，例如在 <code>Formatter</code> 格式化消息的时候。 此函数也可被用来定义你自己的级别。 唯一的限制是自定义的所有级别必须使用此函数来注册，级别值必须为正整数并且其应随严重程度而递增。</p>
<p><code>logging.getLevelName</code>(<em>level</em>)</p>
<p>返回日志记录级别 <em>level</em> 的字符串表示。</p>
<p>如果 <em>level</em> 为预定义的级别 <code>CRITICAL</code>, <code>ERROR</code>, <code>WARNING</code>, <code>INFO</code> 或 <code>DEBUG</code> 之一则你会得到相应的字符串。 如果你使用 <code>addLevelName()</code> 将级别关联到名称则返回你为 <em>level</em> 所关联的名称。 如果传入了与已定义级别相对应的数字值，则返回对应的字符串表示。</p>
<p><em>level</em> 形参也接受级别的字符串表示例如 ‘INFO’。 在这种情况下，此函数将返回级别所对应的数字值。</p>
<p>如果未传入可匹配的数字或字符串值，则返回字符串 ‘Level %s’ % level。</p>
<p>注解</p>
<p>级别在内部以整数表示（因为它们在日志记录逻辑中需要进行比较）。 此函数被用于在整数级别与通过 <code>%(levelname)s</code> 格式描述符方式在格式化日志输出中显示的级别名称之间进行相互的转换 。</p>
<p>在 3.4 版更改: 在早于 3.4 的 Python 版本中，此函数也可传入一个字符串形式的级别名称，并将返回对应的级别数字值。 此未记入文档的行为被视为是一个错误，并在 Python 3.4 中被移除，但又在 3.4.2 中被恢复以保持向下兼容性。</p>
<p><code>logging.makeLogRecord</code>(<em>attrdict</em>)</p>
<p>创建并返回一个新的 <code>LogRecord</code> 实例，实例属性由 <em>attrdict</em> 定义。 此函数适用于接受一个通过套接字传输的封存好的 <code>LogRecord</code> 属性字典，并在接收端将其重建为一个 <code>LogRecord</code> 实例。</p>
<p><code>logging.basicConfig</code>(<em>**kwargs</em>)</p>
<p>通过使用默认的 <code>Formatter</code> 创建一个 <code>StreamHandler</code> 并将其加入根日志记录器来为日志记录系统执行基本配置。 如果没有为根日志记录器定义处理器则 <code>debug()</code>, <code>info()</code>, <code>warning()</code>, <code>error()</code> 和 <code>critical()</code> 等函数将自动调用 <code>basicConfig()</code>。</p>
<p>如果根日志记录器已配置了处理器则此函数将不执行任何操作，除非关键字参数 <em>force</em> 被设为 <code>True</code>。</p>
<p>注解</p>
<p>此函数应当在其他线程启动之前从主线程被调用。 在 2.7.1 和 3.2 之前的 Python 版本中，如果此函数从多个线程被调用，一个处理器（在极少的情况下）有可能被多次加入根日志记录器，导致非预期的结果例如日志中的消息出现重复。</p>
<p>支持以下关键字参数。</p>
<table>
<thead>
<tr>
<th align="left">格式</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><em>filename</em></td>
<td align="left">使用指定的文件名创建一个 <code>FileHandler</code>，而不是 <code>StreamHandler</code>。</td>
</tr>
<tr>
<td align="left"><em>filemode</em></td>
<td align="left">如果指定了 <em>filename</em>，则用此 模式 打开该文件。 默认模式为 <code>‘a’</code>。</td>
</tr>
<tr>
<td align="left"><em>format</em></td>
<td align="left">使用指定的格式字符串作为处理器。 默认为属性以冒号分隔的 <code>levelname</code>, <code>name</code> 和 <code>message</code>。</td>
</tr>
<tr>
<td align="left"><em>datefmt</em></td>
<td align="left">使用指定的日期/时间格式，与 <code>time.strftime()</code> 所接受的格式相同。</td>
</tr>
<tr>
<td align="left"><em>style</em></td>
<td align="left">如果指定了 <em>format</em>，将为格式字符串使用此风格。 <code>‘%’</code>, <code>‘{‘</code> 或 <code>‘$’</code> 分别对应于 printf 风格, <code>str.format()</code> 或 <code>string.Template</code>。 默认为 <code>‘%’</code>。</td>
</tr>
<tr>
<td align="left"><em>level</em></td>
<td align="left">设置根记录器级别去指定 level.</td>
</tr>
<tr>
<td align="left"><em>stream</em></td>
<td align="left">使用指定的流初始化 <code>StreamHandler</code>。 请注意此参数与 <em>filename</em> 不兼容 —— 如果两者同时存在，则会引发 <code>ValueError</code>。</td>
</tr>
<tr>
<td align="left"><em>handlers</em></td>
<td align="left">如果指定，这应为一个包含要加入根日志记录器的已创建处理器的可迭代对象。 任何尚未设置格式描述符的处理器将被设置为在此函数中创建的默认格式描述符。 请注意此参数与 <em>filename</em> 或 <em>stream</em> 不兼容 —— 如果两者同时存在，则会引发 <code>ValueError</code>。</td>
</tr>
<tr>
<td align="left"><em>force</em></td>
<td align="left">如果将此关键字参数指定为 true，则在执行其他参数指定的配置之前，将移除并关闭附加到根记录器的所有现有处理器。</td>
</tr>
<tr>
<td align="left"><em>encoding</em></td>
<td align="left">如果此关键字参数与 <em>filename</em> 一同被指定，则其值会在创建 <code>FileHandler</code> 时被使用，因而也会在打开输出文件时被使用。</td>
</tr>
<tr>
<td align="left"><em>errors</em></td>
<td align="left">如果此关键字参数与 <em>filename</em> 一同被指定，则其值会在创建 <code>FileHandler</code> 时被使用，因而也会在打开输出文件时被使用。 如果未指定，则会使用值 ‘backslashreplace’。 请注意如果指定为 <code>None</code>，它将被原样传给 <code>open()</code>，这意味着它将会当作传入 ‘errors’ 一样处理。</td>
</tr>
</tbody></table>
<p>在 3.2 版更改: 增加了 <em>style</em> 参数。</p>
<p>在 3.3 版更改: 增加了 <em>handlers</em> 参数。 增加了额外的检查来捕获指定不兼容参数的情况 (例如同时指定 <em>handlers</em> 与 <em>stream</em> 或 <em>filename*，或者同时指定 *stream</em> 与 <em>filename</em>)。</p>
<p>在 3.8 版更改: 增加了 <em>force</em> 参数。</p>
<p>在 3.9 版更改: 增加了 <em>encoding</em> 和 <em>errors</em> 参数。</p>
<p><code>logging.shutdown</code>()</p>
<p>通过刷新和关闭所有处理程序来通知日志记录系统执行有序停止。 此函数应当在应用退出时被调用并且在此调用之后不应再使用日志记录系统。</p>
<p>当 logging 模块被导入时，它会将此函数注册为退出处理程序，因此通常不需要手动执行该操作。</p>
<p><code>logging.setLoggerClass</code>(<em>klass</em>)</p>
<p>通知日志记录系统在实例化日志记录器时使用 <em>klass</em> 类。 该类应当定义 <code>__init__()</code> 使其只要求一个 name 参数，并且 <code>__init__()</code> 应当调用 <code>Logger.__init__()</code>。 此函数通常会在需要使用自定义日志记录器行为的应用程序实例化任何日志记录器之前被调用。 在此调用之后，在任何其他时刻都不要使用该子类来直接实例化日志记录器：请继续使用 <code>logging.getLogger()</code> API 来获取你的日志记录器。</p>
<p><code>logging.setLogRecordFactory</code>(<em>factory</em>)</p>
<p>设置一个用来创建 <code>LogRecord</code> 的可调用对象。</p>
<ul>
<li><p>参数</p>
<p><strong>factory</strong> — 用来实例化日志记录的工厂可调用对象。</p>
</li>
</ul>
<p>3.2 新版功能: 此函数与 <code>getLogRecordFactory()</code> 一起提供，以便允许开发者对如何构造表示日志记录事件的 <code>LogRecord</code> 有更好的控制。</p>
<p>可调用对象 factory 具有如下签名:</p>
<pre><code>factory(name, level, fn, lno, msg, args, exc_info, func=None, sinfo=None, **kwargs)</code></pre><blockquote>
<ul>
<li><p>名称</p>
<p>日志记录器名称</p>
<p>level</p>
<p>日志记录级别（数字）。</p>
<p>fn</p>
<p>进行日志记录调用的文件的完整路径名。</p>
<p>lno</p>
<p>记录调用所在文件中的行号。</p>
<p>msg</p>
<p>日志消息。</p>
<p>args</p>
<p>日志记录消息的参数。</p>
<p>exc_info</p>
<p>异常元组，或 <code>None</code> 。</p>
<p>func</p>
<p>调用日志记录调用的函数或方法的名称。</p>
<p>sinfo</p>
<p>与 <code>traceback.print_stack()</code> 所提供的类似的栈回溯信息，显示调用的层级结构。</p>
<p>kwargs</p>
<p>其他关键字参数。</p>
</li>
</ul>
</blockquote>
<h3 id="模块级属性"><a href="#模块级属性" class="headerlink" title="模块级属性"></a>模块级属性</h3><pre><code>logging.lastResort</code></pre><p>通过此属性提供的“最后处理者”。 这是一个以 <code>WARNING</code> 级别写入到 <code>sys.stderr</code> 的 <code>StreamHandler</code>，用于在没有任何日志记录配置的情况下处理日志记录事件。 最终结果就是将消息打印到 <code>sys.stderr</code>，这会替代先前形式为 “no handlers could be found for logger XYZ” 的错误消息。 如果出于某种原因你需要先前的行为，可将 <code>lastResort</code> 设为 <code>None</code>。</p>
<p>3.2 新版功能.</p>
<h3 id="与警告模块集成"><a href="#与警告模块集成" class="headerlink" title="与警告模块集成"></a>与警告模块集成</h3><p><code>captureWarnings()</code> 函数可用来将 <code>logging</code> 和 <code>warnings</code> 模块集成。</p>
<p><code>logging.captureWarnings</code>(<em>capture</em>)</p>
<p>此函数用于打开和关闭日志系统对警告的捕获。</p>
<p>如果 <em>capture</em> 是 <code>True</code>，则 <code>warnings</code> 模块发出的警告将重定向到日志记录系统。具体来说，将使用 <code>warnings.formatwarning()</code> 格式化警告信息，并将结果字符串使用 <code>WARNING</code> 等级记录到名为 <code>'py.warnings'</code> 的记录器中。</p>
<p>如果 <em>capture</em> 是 <code>False</code>，则将停止将警告重定向到日志记录系统，并且将警告重定向到其原始目标（即在 <code>captureWarnings(True)</code> 调用之前的有效目标）。</p>
<h2 id="logging-config-—-日志记录配置"><a href="#logging-config-—-日志记录配置" class="headerlink" title="logging.config —- 日志记录配置"></a><code>logging.config</code> —- 日志记录配置</h2><p><strong>源代码：</strong> <a href="https://github.com/python/cpython/tree/3.10/Lib/logging/config.py" target="_blank" rel="noopener">Lib/logging/config.py</a></p>
<h3 id="配置函数"><a href="#配置函数" class="headerlink" title="配置函数"></a>配置函数</h3><p>下列函数可配置 logging 模块。 它们位于 <code>logging.config</code> 模块中。 它们的使用是可选的 —- 要配置 logging 模块你可以使用这些函数，也可以通过调用主 API (在 <code>logging</code> 本身定义) 并定义在 <code>logging</code> 或 <code>logging.handlers</code> 中声明的处理程序。</p>
<p><code>logging.config.dictConfig</code>(<em>config</em>)</p>
<p>从一个字典获取日志记录配置。 </p>
<p>如果在配置期间遇到错误，此函数将引发 <code>ValueError</code>, <code>TypeError</code>, <code>AttributeError</code> 或 <code>ImportError</code> 并附带适当的描述性消息。 下面是将会引发错误的（可能不完整的）条件列表:</p>
<ul>
<li><code>level</code> 不是字符串或者不是对应于实际日志记录级别的字符串。</li>
<li><code>propagate</code> 值不是布尔类型。</li>
<li>id 没有对应的目标。</li>
<li>在增量调用期间发现不存在的处理程序 id。</li>
<li>无效的日志记录器名称。</li>
<li>无法解析为内部或外部对象。</li>
</ul>
<p>解析由 <code>DictConfigurator</code> 类执行，该类的构造器可传入用于配置的字典，并且具有 <code>configure()</code> 方法。 <code>logging.config</code> 模块具有可调用属性 <code>dictConfigClass</code>，其初始值设为 <code>DictConfigurator</code>。 你可以使用你自己的适当实现来替换 <code>dictConfigClass</code> 的值。</p>
<p><code>dictConfig()</code> 会调用 <code>dictConfigClass</code> 并传入指定的字典，然后在所返回的对象上调用 <code>configure()</code> 方法以使配置生效:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">dictConfig</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span><span class="token punctuation">:</span>
    dictConfigClass<span class="token punctuation">(</span>config<span class="token punctuation">)</span><span class="token punctuation">.</span>configure<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>例如，<code>DictConfigurator</code> 的子类可以在它自己的 <code>__init__()</code> 中调用 <code>DictConfigurator.__init__()</code>，然后设置可以在后续 <code>configure()</code> 调用中使用的自定义前缀。 <code>dictConfigClass</code> 将被绑定到这个新的子类，然后就可以与在默认的未定制状态下完全相同的方式调用 <code>dictConfig()</code>。</p>
<p>3.2 新版功能.</p>
<p><code>logging.config.fileConfig</code>(<em>fname</em>, <em>defaults=None</em>, <em>disable_existing_loggers=True</em>, <em>encoding=None</em>)</p>
<p>从一个 <code>configparser</code> 格式文件中读取日志记录配置。 文件格式应当与 配置文件格式 中的描述一致。 此函数可在应用程序中被多次调用，以允许最终用户在多个预设配置中进行选择（如果开发者提供了展示选项并加载选定配置的机制）。</p>
<ul>
<li>参数<ul>
<li><strong>fname</strong> — 一个文件名，或一个文件类对象，或是一个派生自 <code>RawConfigParser</code> 的实例。 如果传入了一个派生自 <code>RawConfigParser</code> 的实例，它会被原样使用。 否则，将会实例化一个 <code>Configparser</code>，并且它会从作为 <code>fname</code> 传入的对象中读取配置。 如果存在 <code>readline()</code> 方法，则它会被当作一个文件类对象并使用 <code>read_file()</code> 来读取；在其它情况下，它会被当作一个文件名并传递给 <code>read()</code>。</li>
<li><strong>defaults</strong> — 要传递给 ConfigParser 的默认值可在此参数中指定。</li>
<li><strong>disable_existing_loggers</strong> — 如果指定为 <code>False</code>，则当执行此调用时已存在的日志记录器会被保持启用。 默认值为 <code>True</code> 因为这将以向下兼容的方式启用旧有行为。 此行为是禁用任何已存在的非根日志记录器除非它们或它们的上级在日志配置中被显式地指定。 :param encoding: 当 <em>fname</em> 为文件名时用于打开文件的编码格式。</li>
</ul>
</li>
</ul>
<p>在 3.4 版更改: 现在接受 <code>RawConfigParser</code> 子类的实例作为 <code>fname</code> 的值。 这有助于:</p>
<blockquote>
<ul>
<li>使用一个配置文件，其中日志记录配置只是全部应用程序配置的一部分。</li>
<li>使用从一个文件读取的配置，它随后会在被传给 <code>fileConfig</code> 之前由使用配置的应用程序来修改（例如基于命令行参数或运行时环境的其他部分）。</li>
</ul>
</blockquote>
<p>3.10 新版功能: 增加了 <em>encoding</em> 形参。</p>
<p><code>logging.config.listen</code>(<em>port=DEFAULT_LOGGING_CONFIG_PORT</em>, <em>verify=None</em>)</p>
<p>在指定的端口上启动套接字服务器，并监听新的配置。 如果未指定端口，则会使用模块默认的 <code>DEFAULT_LOGGING_CONFIG_PORT</code>。 日志记录配置将作为适合由 <code>dictConfig()</code> 或 <code>fileConfig()</code> 进行处理的文件来发送。 返回一个 <code>Thread</code> 实例，你可以在该实例上调用 <code>start()</code> 来启动服务器，对该服务器你可以在适当的时候执行 <code>join()</code>。 要停止该服务器，请调用 <code>stopListening()</code>。</p>
<p>如果指定 <code>verify</code> 参数，则它应当是一个可调用对象，该对象应当验证通过套接字接收的字节数据是否有效且应被处理。 这可以通过对通过套接字发送的内容进行加密和/或签名来完成，这样 <code>verify</code> 可调用对象就能执行签名验证和/或解密。 <code>verify</code> 可调用对象的调用会附带一个参数 —— 通过套接字接收的字节数据 —— 并应当返回要处理的字节数据，或者返回 <code>None</code> 来指明这些字节数据应当被丢弃。 返回的字节数据可以与传入的字节数据相同（例如在只执行验证的时候），或者也可以完全不同（例如在可能执行了解密的时候）。</p>
<p>要将配置发送到套接字，请读取配置文件并将其作为字节序列发送到套接字，字节序列要以使用 <code>struct.pack('&gt;L', n)</code> 打包为二进制格式的四字节长度的字符串打头。</p>
<p>注解</p>
<p>Because portions of the configuration are passed through <code>eval()</code>, use of this function may open its users to a security risk. While the function only binds to a socket on <code>localhost</code>, and so does not accept connections from remote machines, there are scenarios where untrusted code could be run under the account of the process which calls <code>listen()</code>. Specifically, if the process calling <code>listen()</code> runs on a multi-user machine where users cannot trust each other, then a malicious user could arrange to run essentially arbitrary code in a victim user’s process, simply by connecting to the victim’s <code>listen()</code> socket and sending a configuration which runs whatever code the attacker wants to have executed in the victim’s process. This is especially easy to do if the default port is used, but not hard even if a different port is used. To avoid the risk of this happening, use the <code>verify</code> argument to <code>listen()</code> to prevent unrecognised configurations from being applied.</p>
<p>在 3.4 版更改: 添加了 <code>verify</code> 参数。</p>
<p>注解</p>
<p>如果你希望将配置发送给未禁用现有日志记录器的监听器，你将需要使用 JSON 格式的配置，该格式将使用 <code>dictConfig()</code> 进行配置。 此方法允许你在你发送的配置中将 <code>disable_existing_loggers</code> 指定为 <code>False</code>。</p>
<p><code>logging.config.stopListening</code>()</p>
<p>停止通过对 <code>listen()</code> 的调用所创建的监听服务器。 此函数的调用通常会先于在 <code>listen()</code> 的返回值上调用 <code>join()</code>。</p>
<h3 id="配置字典架构"><a href="#配置字典架构" class="headerlink" title="配置字典架构"></a>配置字典架构</h3><p>描述日志记录配置需要列出要创建的不同对象及它们之间的连接；例如，你可以创建一个名为 ‘console’ 的处理程序，然后名为 ‘startup’ 的日志记录器将可以把它的消息发送给 ‘console’ 处理程序。 这些对象并不仅限于 <code>logging</code> 模块所提供的对象，因为你还可以编写你自己的格式化或处理程序类。 这些类的形参可能还需要包括 <code>sys.stderr</code> 这样的外部对象。 描述这些对象和连接的语法会在下面的 对象连接 中定义。</p>
<h4 id="字典架构细节"><a href="#字典架构细节" class="headerlink" title="字典架构细节"></a>字典架构细节</h4><p>传给 <code>dictConfig()</code> 的字典必须包含以下的键:</p>
<ul>
<li><em>version</em> - 应设为代表架构版本的整数值。 目前唯一有效的值是 1，使用此键可允许架构在继续演化的同时保持向下兼容性。</li>
</ul>
<p>所有其他键都是可选项，但如存在它们将根据下面的描述来解读。 在下面提到 ‘configuring dict’ 的所有情况下，都将检查它的特殊键 <code>'()'</code> 以确定是否需要自定义实例化。 如果需要，则会使用下面 用户定义对象 所描述的机制来创建一个实例；否则，会使用上下文来确定要实例化的对象。</p>
<ul>
<li><p><em>formatters</em> - 对应的值将是一个字典，其中每个键是一个格式器 ID 而每个值则是一个描述如何配置相应 <code>Formatter</code> 实例的字典。</p>
<p>在配置字典中搜索以下可选键，这些键对应于创建 <code>Formatter</code> 对象时传入的参数。:</p>
<blockquote>
<ul>
<li><code>format</code></li>
<li><code>datefmt</code></li>
<li><code>style</code></li>
<li><code>validate</code> (从版本 &gt;=3.8 起)</li>
</ul>
</blockquote>
<p>可选的 <code>class</code> 键指定格式化器类的名称（形式为带点号的模块名和类名）。 实例化的参数与 <code>Formatter</code> 的相同，因此这个键对于实例化自定义的 <code>Formatter</code> 子类最为有用。 如果，替代类可能 会以扩展和精简格式呈现异常回溯信息。 如果你的格式化器需要不同的或额外的配置键，你应当使用 用户定义对象。</p>
</li>
<li><p><em>filters</em> - 对应的值将是一个字典，其中每个键是一个过滤器 ID 而每个值则是一个描述如何配置相应 Filter 实例的字典。</p>
<p>将在配置字典中搜索键 <code>name</code> (默认值为空字符串) 并且该键会被用于构造 <code>logging.Filter</code> 实例。</p>
</li>
<li><p><em>handlers</em> - 对应的值将是一个字典，其中每个键是一个处理程序 ID 而每个值则是一个描述如何配置相应 Handler 实例的字典。</p>
<p>将在配置字典中搜索下列键:</p>
<ul>
<li><code>class</code> (强制)。 这是处理程序类的完整限定名称。</li>
<li><code>level</code> (可选)。 处理程序的级别。</li>
<li><code>formatter</code> (可选)。 处理程序所对应格式化器的 ID。</li>
<li><code>filters</code> (可选)。 由处理程序所对应过滤器的 ID 组成的列表。</li>
</ul>
<p>所有 <em>其他</em> 键会被作为关键字参数传递给处理程序类的构造器。 例如，给定如下配置:</p>
<pre class="line-numbers language-python"><code class="language-python">handlers<span class="token punctuation">:</span>
  console<span class="token punctuation">:</span>
    <span class="token keyword">class</span> <span class="token punctuation">:</span> logging<span class="token punctuation">.</span>StreamHandler
    formatter<span class="token punctuation">:</span> brief
    level   <span class="token punctuation">:</span> INFO
    filters<span class="token punctuation">:</span> <span class="token punctuation">[</span>allow_foo<span class="token punctuation">]</span>
    stream  <span class="token punctuation">:</span> ext<span class="token punctuation">:</span><span class="token operator">//</span>sys<span class="token punctuation">.</span>stdout
  file<span class="token punctuation">:</span>
    <span class="token keyword">class</span> <span class="token punctuation">:</span> logging<span class="token punctuation">.</span>handlers<span class="token punctuation">.</span>RotatingFileHandler
    formatter<span class="token punctuation">:</span> precise
    filename<span class="token punctuation">:</span> logconfig<span class="token punctuation">.</span>log
    maxBytes<span class="token punctuation">:</span> <span class="token number">1024</span>
    backupCount<span class="token punctuation">:</span> <span class="token number">3</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>ID 为 <code>console</code> 的处理程序会被实例化为 <code>logging.StreamHandler</code>，并使用 <code>sys.stdout</code> 作为下层流。 ID 为 <code>file</code> 的处理程序会被实例化为 <code>logging.handlers.RotatingFileHandler</code>，并附带关键字参数 <code>filename='logconfig.log', maxBytes=1024, backupCount=3</code>。</p>
</li>
<li><p><em>loggers</em> - 对应的值将是一个字典，其中每个键是一个日志记录器名称而每个值则是一个描述如何配置相应 Logger 实例的字典。</p>
<p>将在配置字典中搜索下列键:</p>
<ul>
<li><code>level</code> (可选)。 日志记录器的级别。</li>
<li><code>propagate</code> (可选)。 日志记录器的传播设置。</li>
<li><code>filters</code> (可选)。 由日志记录器对应过滤器的 ID 组成的列表。</li>
<li><code>handlers</code> (可选)。 由日志记录器对应处理程序的 ID 组成的列表。</li>
</ul>
<p>指定的日志记录器将根据指定的级别、传播、过滤器和处理程序来配置。</p>
</li>
<li><p><em>root</em> - 这将成为根日志记录器对应的配置。 配置的处理方式将与所有日志记录器一致，除了 <code>propagate</code> 设置将不可用之外。</p>
</li>
<li><p><em>incremental</em> - 配置是否要被解读为在现有配置上新增。 该值默认为 <code>False</code>，这意味着指定的配置将以与当前 <code>fileConfig()</code> API 所使用的相同语义来替代现有的配置。</p>
<p>如果指定的值为 <code>True</code>，配置会按照 增量配置 部分所描述的方式来处理。</p>
</li>
<li><p><em>disable_existing_loggers</em> - 是否要禁用任何现有的非根日志记录器。 该设置对应于 <code>fileConfig()</code> 中的同名形参。 如果省略，则此形参默认为 <code>True</code>。 如果 <em>incremental</em> 为 <code>True</code> 则该省会被忽略。</p>
</li>
</ul>
<h4 id="增量配置"><a href="#增量配置" class="headerlink" title="增量配置"></a>增量配置</h4><p>为增量配置提供完全的灵活性是很困难的。 例如，由于过滤器和格式化器这样的对象是匿名的，一旦完成配置，在增加配置时就不可能引用这些匿名对象。</p>
<p>此外，一旦完成了配置，在运行时任意改变日志记录器、处理程序、过滤器、格式化器的对象图就不是很有必要；日志记录器和处理程序的详细程度只需通过设置级别即可实现控制（对于日志记录器则可设置传播旗标）。 在多线程环境中以安全的方式任意改变对象图也许会导致问题；虽然并非不可能，但这样做的好处不足以抵销其所增加的实现复杂度。</p>
<p>这样，当配置字典的 <code>incremental</code> 键存在且为 <code>True</code> 时，系统将完全忽略任何 <code>formatters</code> 和 <code>filters</code> 条目，并仅会处理 <code>handlers</code> 条目中的 <code>level</code> 设置，以及 <code>loggers</code> 和 <code>root</code> 条目中的 <code>level</code> 和 <code>propagate</code> 设置。</p>
<p>使用配置字典中的值可让配置以封存字典对象的形式通过线路传送给套接字监听器。 这样，长时间运行的应用程序的日志记录的详细程度可随时间改变而无须停止并重新启动应用程序。</p>
<h4 id="对象连接"><a href="#对象连接" class="headerlink" title="对象连接"></a>对象连接</h4><p>该架构描述了一组日志记录对象 —— 日志记录器、处理程序、格式化器、过滤器 —— 它们在对象图中彼此连接。 因此，该架构需要能表示对象之间的连接。 例如，在配置完成后，一个特定的日志记录器关联到了一个特定的处理程序。 出于讨论的目的，我们可以说该日志记录器代表两者间连接的源头，而处理程序则代表对应的目标。 当然在已配置对象中这是由包含对处理程序的引用的日志记录器来代表的。 在配置字典中，这是通过给每个目标对象一个 ID 来无歧义地标识它，然后在源头对象中使用该 ID 来实现的。</p>
<p>因此，举例来说，考虑以下 YAML 代码段:</p>
<pre><code>formatters:
  brief:
    # configuration for formatter with id 'brief' goes here
  precise:
    # configuration for formatter with id 'precise' goes here
handlers:
  h1: #This is an id
   # configuration of handler with id 'h1' goes here
   formatter: brief
  h2: #This is another id
   # configuration of handler with id 'h2' goes here
   formatter: precise
loggers:
  foo.bar.baz:
    # other configuration for logger 'foo.bar.baz'
    handlers: [h1, h2]</code></pre><p>（注：这里使用 YAML 是因为它的可读性比表示字典的等价 Python 源码形式更好。）</p>
<p>日志记录器 ID 就是日志记录器的名称，它会在程序中被用来获取对日志记录器的引用，例如 <code>foo.bar.baz</code>。 格式化器和过滤器的 ID 可以是任意字符串值 (例如上面的 <code>brief</code>, <code>precise</code>) 并且它们是瞬态的，因为它们仅对处理配置字典有意义并会被用来确定对象之间的连接，而当配置调用完成时不会在任何地方保留。</p>
<p>上面的代码片段指明名为 <code>foo.bar.baz</code> 的日志记录器应当关联到两个处理程序，它们的 ID 是 <code>h1</code> 和 <code>h2</code>。 <code>h1</code> 的格式化器的 ID 是 <code>brief</code>，而 <code>h2</code> 的格式化器的 ID 是 <code>precise</code>。</p>
<h4 id="用户定义对象"><a href="#用户定义对象" class="headerlink" title="用户定义对象"></a>用户定义对象</h4><p>此架构支持用户定义对象作为处理程序、过滤器和格式化器。 （日志记录器的不同实例不需要具有不同类型，因此这个配置架构并不支持用户定义日志记录器类。）</p>
<p>要配置的对象是由字典描述的，其中包含它们的配置详情。 在某些地方，日志记录系统将能够从上下文中推断出如何实例化一个对象，但是当要实例化一个用户自定义对象时，系统将不知道要如何做。 为了提供用户自定义对象实例化的完全灵活性，用户需要提供一个‘工厂’函数 —— 即在调用时传入配置字典并返回实例化对象的可调用对象。 这是用一个通过特殊键 <code>'()'</code> 来访问的工厂函数的绝对导入路径来标示的。 下面是一个实际的例子:</p>
<pre><code>formatters:
  brief:
    format: '%(message)s'
  default:
    format: '%(asctime)s %(levelname)-8s %(name)-15s %(message)s'
    datefmt: '%Y-%m-%d %H:%M:%S'
  custom:
      (): my.package.customFormatterFactory
      bar: baz
      spam: 99.9
      answer: 42</code></pre><p>上面的 YAML 代码片段定义了三个格式化器。 第一个的 ID 为 <code>brief</code>，是带有特殊格式字符串的标准 <code>logging.Formatter</code> 实例。 第二个的 ID 为 <code>default</code>，具有更长的格式同时还显式地定义了时间格式，并将最终实例化一个带有这两个格式字符串的 <code>logging.Formatter</code>。 以 Python 源代码形式显示的 <code>brief</code> 和 <code>default</code> 格式化器分别具有下列配置子字典:</p>
<pre><code>{
  'format' : '%(message)s'
}</code></pre><p>和:</p>
<pre><code>{
  'format' : '%(asctime)s %(levelname)-8s %(name)-15s %(message)s',
  'datefmt' : '%Y-%m-%d %H:%M:%S'
}</code></pre><p>并且由于这些字典不包含特殊键 <code>'()'</code>，实例化方式是从上下文中推断出来的：结果会创建标准的 <code>logging.Formatter</code> 实例。 第三个格式器的 ID 为 <code>custom</code>，对应配置子字典为:</p>
<pre><code>{
  '()' : 'my.package.customFormatterFactory',
  'bar' : 'baz',
  'spam' : 99.9,
  'answer' : 42
}</code></pre><p>并且它包含特殊键 <code>'()'</code>，这意味着需要用户自定义实例化方式。 在此情况下，将使用指定的工厂可调用对象。 如果它本身就是一个可调用对象则将被直接使用 —— 否则如果你指定了一个字符串（如这个例子所示）则将使用正常的导入机制来定位实例的可调用对象。 调用该可调用对象将传入配置子字典中 <strong>剩余的</strong> 条目作为关键字参数。 在上面的例子中，调用将预期返回 ID 为 <code>custom</code> 的格式化器:</p>
<pre><code>my.package.customFormatterFactory(bar='baz', spam=99.9, answer=42)</code></pre><p>将 <code>'()'</code> 用作特殊键是因为它不是一个有效的关键字形参名称，这样就不会与调用中使用的关键字参数发生冲突。 <code>'()'</code> 还被用作表明对应值为可调用对象的助记符。</p>
<h4 id="访问外部对象"><a href="#访问外部对象" class="headerlink" title="访问外部对象"></a>访问外部对象</h4><p>有时一个配置需要引用配置以外的对象，例如 <code>sys.stderr</code>。 如果配置字典是使用 Python 代码构造的，这会很直观，但是当配置是通过文本文件（例如 JSON, YAML）提供的时候就会引发问题。 在一个文本文件中，没有将 <code>sys.stderr</code> 与字符串字面值 <code>'sys.stderr'</code> 区分开来的标准方式。 为了实现这种区分，配置系统会在字符串值中查找规定的特殊前缀并对其做特殊处理。 例如，如果在配置中将字符串字面值 <code>'ext://sys.stderr'</code> 作为一个值来提供，则 <code>ext://</code> 将被去除而该值的剩余部分将使用正常导入机制来处理。</p>
<p>此类前缀的处理方式类似于协议处理：存在一种通用机制来查找与正则表达式 <code>^(?P&lt;prefix&gt;[a-z]+)://(?P&lt;suffix&gt;.*)$</code> 相匹配的前缀，如果识别出了 <code>prefix</code>，则 <code>suffix</code> 会以与前缀相对应的方式来处理并且处理的结果将替代原字符串值。 如果未识别出前缀，则原字符串将保持不变。</p>
<h4 id="访问内部对象"><a href="#访问内部对象" class="headerlink" title="访问内部对象"></a>访问内部对象</h4><p>除了外部对象，有时还需要引用配置中的对象。 这将由配置系统针对它所了解的内容隐式地完成。 例如，在日志记录器或处理程序中表示 <code>level</code> 的字符串值 <code>'DEBUG'</code> 将被自动转换为值 <code>logging.DEBUG</code>，而 <code>handlers</code>, <code>filters</code> 和 <code>formatter</code> 条目将接受一个对象 ID 并解析为适当的目标对象。</p>
<p>但是，对于 <code>logging</code> 模块所不了解的用户自定义对象则需要一种更通用的机制。 例如，考虑 <code>logging.handlers.MemoryHandler</code>，它接受一个 <code>target</code> 参数即其所委托的另一个处理程序。 由于系统已经知道存在该类，因而在配置中，给定的 <code>target</code> 只需为相应目标处理程序的的对象 ID 即可，而系统将根据该 ID 解析出处理程序。 但是，如果用户定义了一个具有 <code>alternate</code> 处理程序的 <code>my.package.MyHandler</code>，则配置程序将不知道 <code>alternate</code> 指向的是一个处理程序。 为了应对这种情况，通用解析系统允许用户指定:</p>
<pre class="line-numbers language-python"><code class="language-python">handlers<span class="token punctuation">:</span>
  file<span class="token punctuation">:</span>
    <span class="token comment" spellcheck="true"># configuration of file handler goes here</span>
  custom<span class="token punctuation">:</span>
    <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> my<span class="token punctuation">.</span>package<span class="token punctuation">.</span>MyHandler
    alternate<span class="token punctuation">:</span> cfg<span class="token punctuation">:</span><span class="token operator">//</span>handlers<span class="token punctuation">.</span>file<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>字符串字面值 <code>'cfg://handlers.file'</code> 将按照与 <code>ext://</code> 前缀类似的方式被解析为结果字符串，但查找操作是在配置自身而不是在导入命名空间中进行。 该机制允许按点号或按索引来访问，与 <code>str.format</code> 所提供的方式类似。 这样，给定以下代码段:</p>
<pre class="line-numbers language-handlers:"><code class="language-handlers:">handlers:
  email:
    class: logging.handlers.SMTPHandler
    mailhost: localhost
    fromaddr: my_app@domain.tld
    toaddrs:
      - support_team@domain.tld
      - dev_team@domain.tld
    subject: Houston, we have a problem.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在该配置中，字符串 <code>'cfg://handlers'</code> 将解析为带有 <code>handlers</code> 键的字典，字符串 <code>'cfg://handlers.email</code> 将解析为具有 <code>email</code> 键的 <code>handlers</code> 字典中的字典，依此类推。 字符串 <code>'cfg://handlers.email.toaddrs[1]</code> 将解析为 <code>'dev_team@domain.tld'</code> 而字符串 <code>'cfg://handlers.email.toaddrs[0]'</code> 将解析为值 <code>'support_team@domain.tld'</code>。 <code>subject</code> 值 可以使用 <code>'cfg://handlers.email.subject'</code> 或者等价的 <code>'cfg://handlers.email[subject]'</code> 来访问。 后一种形式仅在键包含空格或非字母类数字类字符的情况下才需要使用。 如果一个索引仅由十进制数码构成，则将尝试使用相应的整数值来访问，如果有必要则将回退为字符串值。</p>
<p>给定字符串 <code>cfg://handlers.myhandler.mykey.123</code>，这将解析为 <code>config_dict['handlers']['myhandler']['mykey']['123']</code>。 如果字符串被指定为 <code>cfg://handlers.myhandler.mykey[123]</code>，系统将尝试从 <code>config_dict['handlers']['myhandler']['mykey'][123]</code> 中提取值，并在尝试失败时回退为 <code>config_dict['handlers']['myhandler']['mykey']['123']</code>。</p>
<h4 id="导入解析与定制导入器"><a href="#导入解析与定制导入器" class="headerlink" title="导入解析与定制导入器"></a>导入解析与定制导入器</h4><p>导入解析默认使用内置的 <code>__import__()</code> 函数来执行导入。 你可能想要将其替换为你自己的导入机制：如果是这样的话，你可以替换 <code>DictConfigurator</code> 或其超类 <code>BaseConfigurator</code> 类的 <code>importer</code> 属性。 但是你必须小心谨慎，因为函数是从类中通过描述器方式来访问的。 如果你使用 Python 可调用对象来执行导入，并且你希望在类层级而不是在实例层级上定义它，则你需要用 <code>staticmethod()</code> 来装饰它。 例如:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> importlib <span class="token keyword">import</span> import_module
<span class="token keyword">from</span> logging<span class="token punctuation">.</span>config <span class="token keyword">import</span> BaseConfigurator
BaseConfigurator<span class="token punctuation">.</span>importer <span class="token operator">=</span> staticmethod<span class="token punctuation">(</span>import_module<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>如果你是在一个配置器的 <em>实例</em> 上设置导入可调用对象则你不需要用 <code>staticmethod()</code> 来装饰。</p>
<h3 id="配置文件格式"><a href="#配置文件格式" class="headerlink" title="配置文件格式"></a>配置文件格式</h3><p><code>fileConfig()</code> 所能理解的配置文件格式是基于 <code>configparser</code> 功能的。 该文件必须包含 <code>[loggers]</code>, <code>[handlers]</code> 和 <code>[formatters]</code> 等小节，它们通过名称来标识文件中定义的每种类型的实体。 对于每个这样的实体，都有单独的小节来标识实体的配置方式。 因此，对于 <code>[loggers]</code> 小节中名为 <code>log01</code> 的日志记录器，相应的配置详情保存在 <code>[logger_log01]</code> 小节中。 类似地，对于 <code>[handlers]</code> 小节中名为 <code>hand01</code> 的处理程序，其配置将保存在名为 <code>[handler_hand01]</code> 的小节中，而对于 <code>[formatters]</code> 小节中名为 <code>form01</code> 的格式化器，其配置将在名为 <code>[formatter_form01]</code> 的小节中指定。 根日志记录器的配置必须在名为 <code>[logger_root]</code> 的小节中指定。</p>
<p>注解</p>
<p><code>fileConfig()</code> API 比 <code>dictConfig()</code> API 更旧因而没有提供涵盖日志记录特定方面的功能。 例如，你无法配置 <code>Filter</code> 对象，该对象使用 <code>fileConfig()</code> 提供超出简单整数级别的消息过滤功能。 如果你想要在你的日志记录配置中包含 <code>Filter</code> 的实例，你将必须使用 <code>dictConfig()</code>。 请注意未来还将向 <code>dictConfig()</code> 添加对配置功能的强化，因此值得考虑在方便的时候转换到这个新 API。</p>
<p>在文件中这些小节的例子如下所示。</p>
<pre><code>[loggers]
keys=root,log02,log03,log04,log05,log06,log07
[handlers]
keys=hand01,hand02,hand03,hand04,hand05,hand06,hand07,hand08,hand09
[formatters]
keys=form01,form02,form03,form04,form05,form06,form07,form08,form09</code></pre><p>根日志记录器必须指定一个级别和一个处理程序列表。 根日志小节的例子如下所示。</p>
<pre><code>[logger_root]
level=NOTSET
handlers=hand01</code></pre><p><code>level</code> 条目可以为 <code>DEBUG, INFO, WARNING, ERROR, CRITICAL</code> 或 <code>NOTSET</code> 之一。 其中 <code>NOTSET</code> 仅适用于根日志记录器，表示将会记录所有消息。 级别值会在 <code>logging</code> 包命名空间的上下文中通过 <code>eval()</code> 来得出。</p>
<p><code>handlers</code> 条目是以逗号分隔的处理程序名称列表，它必须出现于 <code>[handlers]</code> 小节并且在配置文件中有相应的小节。</p>
<p>对于根日志记录器以外的日志记录器，还需要某些附加信息。 下面的例子演示了这些信息。</p>
<pre><code>[logger_parser]
level=DEBUG
handlers=hand01
propagate=1
qualname=compiler.parser</code></pre><p><code>level</code> 和 <code>handlers</code> 条目的解释方式与根日志记录器的一致，不同之处在于如果一个非根日志记录器的级别被指定为 <code>NOTSET</code>，则系统会咨询更高层级的日志记录器来确定该日志记录器的有效级别。 <code>propagate</code> 条目设为 1 表示消息必须从此日志记录器传播到更高层级的处理程序，设为 0 表示消息 <strong>不会</strong> 传播到更高层级的处理程序。 <code>qualname</code> 条目是日志记录器的层级通道名称，也就是应用程序获取日志记录器所用的名称。</p>
<p>指定处理程序配置的小节说明如下。</p>
<pre><code>[handler_hand01]
class=StreamHandler
level=NOTSET
formatter=form01
args=(sys.stdout,)</code></pre><p><code>class</code> 条目指明处理程序的类（由 <code>logging</code> 包命名空间中的 <code>eval()</code> 来确定）。 <code>level</code> 会以与日志记录器相同的方式来解读，<code>NOTSET</code> 会被视为表示‘记录一切消息’。</p>
<p><code>formatter</code> 条目指明此处理程序的格式化器的键名称。 如为空白，则会使用默认的格式化器 (<code>logging._defaultFormatter</code>)。 如果指定了名称，则它必须出现于 <code>[formatters]</code> 小节并且在配置文件中有相应的小节。</p>
<p><code>args</code> 条目，当在 <code>logging</code> 包命名空间的上下文中执行 <code>eval()</code> 时将是传给处理程序类构造器的参数列表。 请参阅相应处理程序的构造器说明或者下面的示例，以了解典型的条目是如何构造的。 如果未提供，则默认为 <code>()</code>。</p>
<p>可选的 <code>kwargs</code> 条目，当在 <code>logging</code> 包命名空间的上下文中执行 <code>eval()</code> 时将是传给处理程序的构造器的关键字参数字典。 如果未提供，则默认为 <code>{}</code>。</p>
<pre><code>[handler_hand02]
class=FileHandler
level=DEBUG
formatter=form02
args=('python.log', 'w')
[handler_hand03]
class=handlers.SocketHandler
level=INFO
formatter=form03
args=('localhost', handlers.DEFAULT_TCP_LOGGING_PORT)
[handler_hand04]
class=handlers.DatagramHandler
level=WARN
formatter=form04
args=('localhost', handlers.DEFAULT_UDP_LOGGING_PORT)
[handler_hand05]
class=handlers.SysLogHandler
level=ERROR
formatter=form05
args=(('localhost', handlers.SYSLOG_UDP_PORT), handlers.SysLogHandler.LOG_USER)
[handler_hand06]
class=handlers.NTEventLogHandler
level=CRITICAL
formatter=form06
args=('Python Application', '', 'Application')
[handler_hand07]
class=handlers.SMTPHandler
level=WARN
formatter=form07
args=('localhost', 'from@abc', ['user1@abc', 'user2@xyz'], 'Logger Subject')
kwargs={'timeout': 10.0}
[handler_hand08]
class=handlers.MemoryHandler
level=NOTSET
formatter=form08
target=
args=(10, ERROR)
[handler_hand09]
class=handlers.HTTPHandler
level=NOTSET
formatter=form09
args=('localhost:9022', '/log', 'GET')
kwargs={'secure': True}</code></pre><p>指定格式化器配置的小节说明如下。</p>
<pre><code>[formatter_form01]
format=F1 %(asctime)s %(levelname)s %(message)s
datefmt=
style='%'
validate=True
class=logging.Formatter</code></pre><p>用于格式化器配置的参数与字典规范 格式化器部分 中的键相同。</p>
<p>注解</p>
<p>由于如上所述使用了 <code>eval()</code>，因此使用 <code>listen()</code> 通过套接字来发送和接收配置会导致潜在的安全风险。 此风险仅限于相互间没有信任的多个用户在同一台机器上运行代码的情况.</p>
<h2 id="logging-handlers-—-日志处理程序"><a href="#logging-handlers-—-日志处理程序" class="headerlink" title="logging.handlers —- 日志处理程序"></a><code>logging.handlers</code> —- 日志处理程序</h2><p><strong>源代码:</strong> <a href="https://github.com/python/cpython/tree/3.10/Lib/logging/handlers.py" target="_blank" rel="noopener">Lib/logging/handlers.py</a></p>
<p>这个包提供了以下有用的处理程序。 请注意有三个处理程序类 (<code>StreamHandler</code>, <code>FileHandler</code> 和 <code>NullHandler</code>) 实际上是在 <code>logging</code> 模块本身定义的，但其文档与其他处理程序一同记录在此。</p>
<h3 id="StreamHandler"><a href="#StreamHandler" class="headerlink" title="StreamHandler"></a>StreamHandler</h3><p><code>StreamHandler</code> 类位于核心 <code>logging</code> 包，它可将日志记录输出发送到数据流例如 <em>sys.stdout</em>, <em>sys.stderr</em> 或任何文件类对象（或者更精确地说，任何支持 <code>write()</code> 和 <code>flush()</code> 方法的对象）。</p>
<p><em>class</em> <code>logging.StreamHandler</code>(<em>stream=None</em>)</p>
<p>返回一个新的 <code>StreamHandler</code> 类。 如果指定了 <em>stream</em>，则实例将用它作为日志记录输出；在其他情况下将使用 <em>sys.stderr</em>。</p>
<ul>
<li><p><code>emit</code>(<em>record</em>)</p>
<p>如果指定了一个格式化器，它会被用来格式化记录。 随后记录会被写入到 <code>terminator</code> 之后的流中。 如果存在异常信息，则会使用 <code>traceback.print_exception()</code> 来格式化并添加到流中。</p>
</li>
<li><p><code>flush</code>()</p>
<p>通过调用流的 <code>flush()</code> 方法来刷新它。 请注意 <code>close()</code> 方法是继承自 <code>Handler</code> 的所以没有输出，因此有时可能需要显式地调用 <code>flush()</code>。</p>
</li>
<li><p><code>setStream</code>(<em>stream</em>)</p>
<p>将实例的流设为指定值，如果两者不一致的话。 旧的流会在设置新的流之前被刷新。</p>
<ul>
<li><p>参数</p>
<p><strong>stream</strong> — 处理程序应当使用的流。</p>
<p>返回</p>
<p>旧的流，如果流已被改变的话，如果未被改变则为 <em>None</em>。</p>
</li>
</ul>
<p>3.7 新版功能.</p>
</li>
<li><p><code>terminator</code></p>
<p>当将已格式化的记录写入到流时被用作终止符的字符串。 默认值为 <code>'\n'</code>。</p>
<p>如果你不希望以换行符终止，你可以将处理程序类实例的 <code>terminator</code> 属性设为空字符串。</p>
<p>在较早的版本中，终止符被硬编码为 <code>'\n'</code>。</p>
<p>3.2 新版功能.</p>
</li>
</ul>
<h3 id="FileHandler"><a href="#FileHandler" class="headerlink" title="FileHandler"></a>FileHandler</h3><p><code>FileHandler</code> 类位于核心 <code>logging</code> 包，它可将日志记录输出到磁盘文件中。 它从 <code>StreamHandler</code> 继承了输出功能。</p>
<p><em>class</em> <code>logging.FileHandler</code>(<em>filename</em>, <em>mode=’a’</em>, <em>encoding=None</em>, <em>delay=False</em>, <em>errors=None</em>)</p>
<p>返回一个 <code>FileHandler</code> 类的新实例。 将打开指定的文件并将其用作日志记录流。 如果未指定 <em>mode*，则会使用 <code>'a'</code>。 如果 *encoding</em> 不为 <code>None</code>，则会将其用作打开文件的编码格式。 如果 <em>delay</em> 为真值，则文件打开会被推迟至第一次调用 <code>emit()</code> 时。 默认情况下，文件会无限增长。 如果指定了 <em>errors</em>，它会被用于确定编码格式错误的处理方式。</p>
<p>在 3.6 版更改: 除了字符串值，也接受 <code>Path</code> 对象作为 <em>filename</em> 参数。</p>
<p>在 3.9 版更改: 增加了 <em>errors</em> 形参。</p>
<ul>
<li><p><code>close</code>()</p>
<p>关闭文件。</p>
</li>
<li><p><code>emit</code>(<em>record</em>)</p>
<p>将记录输出到文件。</p>
</li>
</ul>
<h3 id="NullHandler"><a href="#NullHandler" class="headerlink" title="NullHandler"></a>NullHandler</h3><p>3.1 新版功能.</p>
<p><code>NullHandler</code> 类位于核心 <code>logging</code> 包，它不执行任何格式化或输出。 它实际上是一个供库开发者使用的‘无操作’处理程序。</p>
<p><em>class</em> <code>logging.NullHandler</code></p>
<p>返回一个 <code>NullHandler</code> 类的新实例。</p>
<ul>
<li><p><code>emit</code>(<em>record</em>)</p>
<p>此方法不执行任何操作。</p>
</li>
<li><p><code>handle</code>(<em>record</em>)</p>
<p>此方法不执行任何操作。</p>
</li>
<li><p><code>createLock</code>()</p>
<p>此方法会对锁返回 <code>None</code>，因为没有下层 I/O 的访问需要被序列化。</p>
</li>
</ul>
<h3 id="WatchedFileHandler"><a href="#WatchedFileHandler" class="headerlink" title="WatchedFileHandler"></a>WatchedFileHandler</h3><p><code>WatchedFileHandler</code> 类位于 <code>logging.handlers</code> 模块，这个 <code>FileHandler</code> 用于监视它所写入日志记录的文件。 如果文件发生变化，它会被关闭并使用文件名重新打开。</p>
<p>发生文件更改可能是由于使用了执行文件轮换的程序例如 <em>newsyslog</em> 和 <em>logrotate</em>。 这个处理程序在 Unix/Linux 下使用，它会监视文件来查看自上次发出数据后是否有更改。 （如果文件的设备或 inode 发生变化就认为已被更改。） 如果文件被更改，则会关闭旧文件流，并再打开文件以获得新文件流。</p>
<p>这个处理程序不适合在 Windows 下使用，因为在 Windows 下打开的日志文件无法被移动或改名 —— 日志记录会使用排他的锁来打开文件 —— 因此这样的处理程序是没有必要的。 此外，<em>ST_INO</em> 在 Windows 下不受支持；<code>stat()</code> 将总是为该值返回零。</p>
<p><em>class</em> <code>logging.handlers.WatchedFileHandler</code>(<em>filename</em>, <em>mode=’a’</em>, <em>encoding=None</em>, <em>delay=False</em>, <em>errors=None</em>)</p>
<p>返回一个 <code>WatchedFileHandler</code> 类的新实例。 将打开指定的文件并将其用作日志记录流。 如果未指定 <em>mode*，则会使用 <code>'a'</code>。 如果 *encoding</em> 不为 <code>None</code>，则会将其用作打开文件的编码格式。 如果 <em>delay</em> 为真值，则文件打开会被推迟至第一次调用 <code>emit()</code> 时。 默认情况下，文件会无限增长。 如果提供了 <em>errors</em>，它会被用于确定编码格式错误的处理方式。</p>
<p>在 3.6 版更改: 除了字符串值，也接受 <code>Path</code> 对象作为 <em>filename</em> 参数。</p>
<p>在 3.9 版更改: 增加了 <em>errors</em> 形参。</p>
<ul>
<li><p><code>reopenIfNeeded</code>()</p>
<p>检查文件是否已更改。 如果已更改，则会刷新并关闭现有流然后重新打开文件，这通常是将记录输出到文件的先导操作。</p>
<p>3.6 新版功能.</p>
</li>
<li><p><code>emit</code>(<em>record</em>)</p>
<p>将记录输出到文件，但如果文件已更改则会先调用 <code>reopenIfNeeded()</code> 来重新打开它。</p>
</li>
</ul>
<h3 id="BaseRotatingHandler"><a href="#BaseRotatingHandler" class="headerlink" title="BaseRotatingHandler"></a>BaseRotatingHandler</h3><p><code>BaseRotatingHandler</code> 类位于 <code>logging.handlers</code> 模块中，它是轮换文件处理程序类 <code>RotatingFileHandler</code> 和 <code>TimedRotatingFileHandler</code> 的基类。 你不需要实例化此类，但它具有你可能需要重载的属性和方法。</p>
<p><em>class</em> <code>logging.handlers.BaseRotatingHandler</code>(<em>filename</em>, <em>mode</em>, <em>encoding=None</em>, <em>delay=False</em>, <em>errors=None</em>)</p>
<p>类的形参与 <code>FileHandler</code> 的相同。 其属性有:</p>
<ul>
<li><p><code>namer</code></p>
<p>如果此属性被设为一个可调用对象，则 <code>rotation_filename()</code> 方法会委托给该可调用对象。 传给该可调用对象的形参与传给 <code>rotation_filename()</code> 的相同。</p>
<p>注解</p>
<p>namer 函数会在轮换期间被多次调用，因此它应当尽可能的简单快速。 它还应当对给定的输入每次都返回相同的输出，否则轮换行为可能无法按预期工作。</p>
<p>3.3 新版功能.</p>
</li>
<li><p><code>rotator</code></p>
<p>如果此属性被设为一个可调用对象，则 <code>rotate()</code> 方法会委托给该可调用对象。 传给该可调用对象的形参与传给 <code>rotate()</code> 的相同。</p>
<p>3.3 新版功能.</p>
</li>
<li><p><code>rotation_filename</code>(<em>default_name</em>)</p>
<p>当轮换时修改日志文件的文件名。</p>
<p>提供该属性以便可以提供自定义文件名。</p>
<p>默认实现会调用处理程序的 ‘namer’ 属性，如果它是可调用对象的话，并传给它默认的名称。 如果该属性不是可调用对象 (默认值为 <code>None</code>)，则将名称原样返回。</p>
<ul>
<li><p>参数</p>
<p><strong>default_name</strong> — 日志文件的默认名称。</p>
</li>
</ul>
<p>3.3 新版功能.</p>
</li>
<li><p><code>rotate</code>(<em>source</em>, <em>dest</em>)</p>
<p>当执行轮换时，轮换当前日志。</p>
<p>默认实现会调用处理程序的 ‘rotator’ 属性，如果它是可调用对象的话，并传给它 source 和 dest 参数。 如果该属性不是可调用对象 (默认值为 <code>None</code>)，则将源简单地重命名为目标。</p>
<ul>
<li>参数<ul>
<li><strong>source</strong> — 源文件名。 这通常为基本文件名，例如 ‘test.log’。</li>
<li><strong>dest</strong> — 目标文件名。 这通常是源被轮换后的名称，例如 ‘test.log.1’。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>3.3 新版功能.</p>
<p>该属性存在的理由是让你不必进行子类化 —— 你可以使用与 <code>RotatingFileHandler</code> 和 <code>TimedRotatingFileHandler</code> 的实例相同的可调用对象。 如果 namer 或 rotator 可调用对象引发了异常，将会按照与 <code>emit()</code> 调用期间的任何其他异常相同的方式来处理，例如通过处理程序的 <code>handleError()</code> 方法。</p>
<p>如果你需要对轮换进程执行更多的修改，你可以重载这些方法。</p>
<h3 id="RotatingFileHandler"><a href="#RotatingFileHandler" class="headerlink" title="RotatingFileHandler"></a>RotatingFileHandler</h3><p><code>RotatingFileHandler</code> 类位于 <code>logging.handlers</code> 模块，它支持磁盘日志文件的轮换。</p>
<p><em>class</em> <code>logging.handlers.RotatingFileHandler</code>(<em>filename</em>, <em>mode=’a’</em>, <em>maxBytes=0</em>, <em>backupCount=0</em>, <em>encoding=None</em>, <em>delay=False</em>, <em>errors=None</em>)</p>
<p>返回一个 <code>RotatingFileHandler</code> 类的新实例。 将打开指定的文件并将其用作日志记录流。 如果未指定 <em>mode*，则会使用 <code>'a'</code>。 如果 *encoding</em> 不为 <code>None</code>，则会将其用作打开文件的编码格式。 如果 <em>delay</em> 为真值，则文件打开会被推迟至第一次调用 <code>emit()</code>。 默认情况下，文件会无限增长。 如果提供了 <em>errors</em>，它会被用于确定编码格式错误的处理方式。</p>
<p>你可以使用 <em>maxBytes</em> 和 <em>backupCount</em> 值来允许文件以预定的大小执行 <em>rollover*。 当即将超出预定大小时，将关闭旧文件并打开一个新文件用于输出。 只要当前日志文件长度接近 *maxBytes</em> 就会发生轮换；但是如果 <em>maxBytes</em> 或 <em>backupCount</em> 两者之一的值为零，就不会发生轮换，因此你通常要设置 <em>backupCount</em> 至少为 1，而 <em>maxBytes</em> 不能为零。 当 <em>backupCount</em> 为非零值时，系统将通过为原文件名添加扩展名 ‘.1’, ‘.2’ 等来保存旧日志文件。 例如，当 <em>backupCount</em> 为 5 而基本文件名为 <code>app.log</code> 时，你将得到 <code>app.log</code>, <code>app.log.1</code>, <code>app.log.2</code> 直至 <code>app.log.5</code>。 当前被写入的文件总是 <code>app.log</code>。 当此文件写满时，它会被关闭并重户名为 <code>app.log.1</code>，而如果文件 <code>app.log.1</code>, <code>app.log.2</code> 等存在，则它们会被分别重命名为 <code>app.log.2</code>, <code>app.log.3</code> 等等。</p>
<p>在 3.6 版更改: 除了字符串值，也接受 <code>Path</code> 对象作为 <em>filename</em> 参数。</p>
<p>在 3.9 版更改: 增加了 <em>errors</em> 形参。</p>
<ul>
<li><p><code>doRollover</code>()</p>
<p>执行上文所描述的轮换。</p>
</li>
<li><p><code>emit</code>(<em>record</em>)</p>
<p>将记录输出到文件，以适应上文所描述的轮换。</p>
</li>
</ul>
<h3 id="TimedRotatingFileHandler"><a href="#TimedRotatingFileHandler" class="headerlink" title="TimedRotatingFileHandler"></a>TimedRotatingFileHandler</h3><p><code>TimedRotatingFileHandler</code> 类位于 <code>logging.handlers</code> 模块，它支持基于特定时间间隔的磁盘日志文件轮换。</p>
<p><em>class</em> <code>logging.handlers.TimedRotatingFileHandler</code>(<em>filename</em>, <em>when=’h’</em>, <em>interval=1</em>, <em>backupCount=0</em>, <em>encoding=None</em>, <em>delay=False</em>, <em>utc=False</em>, <em>atTime=None</em>, <em>errors=None</em>)</p>
<p>返回一个新的 <code>TimedRotatingFileHandler</code> 类实例。 指定的文件会被打开并用作日志记录的流。 对于轮换操作它还会设置文件名前缀。 轮换的发生是基于 <em>when</em> 和 <em>interval</em> 的积。</p>
<p>你可以使用 <em>when</em> 来指定 <em>interval</em> 的类型。 可能的值列表如下。 请注意它们不是大小写敏感的。</p>
<table>
<thead>
<tr>
<th align="left">值</th>
<th align="left">间隔类型</th>
<th align="left">如果/如何使用 <em>atTime</em></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>‘S’</code></td>
<td align="left">秒</td>
<td align="left">忽略</td>
</tr>
<tr>
<td align="left"><code>‘M’</code></td>
<td align="left">分钟</td>
<td align="left">忽略</td>
</tr>
<tr>
<td align="left"><code>‘H’</code></td>
<td align="left">小时</td>
<td align="left">忽略</td>
</tr>
<tr>
<td align="left"><code>‘D’</code></td>
<td align="left">天</td>
<td align="left">忽略</td>
</tr>
<tr>
<td align="left"><code>‘W0’-‘W6’</code></td>
<td align="left">工作日(0=星期一)</td>
<td align="left">用于计算初始轮换时间</td>
</tr>
<tr>
<td align="left"><code>‘midnight’</code></td>
<td align="left">如果未指定 <em>atTime</em> 则在午夜执行轮换，否则将使用 <em>atTime</em>。</td>
<td align="left">用于计算初始轮换时间</td>
</tr>
</tbody></table>
<p>当使用基于星期的轮换时，星期一为 ‘W0’，星期二为 ‘W1’，以此类推直至星期日为 ‘W6’。 在这种情况下，传入的 <em>interval</em> 值不会被使用。</p>
<p>系统将通过为文件名添加扩展名来保存旧日志文件。 扩展名是基于日期和时间的，根据轮换间隔的长短使用 strftime 格式 <code>%Y-%m-%d_%H-%M-%S</code> 或是其中有变动的部分。</p>
<p>当首次计算下次轮换的时间时（即当处理程序被创建时），现有日志文件的上次被修改时间或者当前时间会被用来计算下次轮换的发生时间。</p>
<p>如果 <em>utc</em> 参数为真值，将使用 UTC 时间；否则会使用本地时间。</p>
<p>如果 <em>backupCount</em> 不为零，则最多将保留 <em>backupCount</em> 个文件，而如果当轮换发生时创建了更多的文件，则最旧的文件会被删除。 删除逻辑使用间隔时间来确定要删除的文件，因此改变间隔时间可能导致旧文件被继续保留。</p>
<p>如果 <em>delay</em> 为真值，则会将文件打开延迟到首次调用 <code>emit()</code> 的时候。</p>
<p>如果 <em>atTime</em> 不为 <code>None</code>，则它必须是一个 <code>datetime.time</code> 的实例，该实例指定轮换在一天内的发生时间，用于轮换被设为“在午夜”或“在每星期的某一天”之类的情况。 请注意在这些情况下，<em>atTime</em> 值实际上会被用于计算 <em>初始</em> 轮换，而后续轮换将会通过正常的间隔时间计算来得出。</p>
<p>如果指定了 <em>errors</em>，它会被用来确定编码错误的处理方式。</p>
<p>注解</p>
<p>初始轮换时间的计算是在处理程序被初始化时执行的。 后续轮换时间的计算则仅在轮换发生时执行，而只有当提交输出时轮换才会发生。 如果不记住这一点，你就可能会感到困惑。 例如，如果设置时间间隔为“每分钟”，那并不意味着你总会看到（文件名中）带有间隔一分钟时间的日志文件；如果在应用程序执行期间，日志记录输出的生成频率高于每分钟一次，<em>那么</em> 你可以预期看到间隔一分钟时间的日志文件。 另一方面，如果（假设）日志记录消息每五分钟才输出一次，那么文件时间将会存在对应于没有输出（因而没有轮换）的缺失。</p>
<p>在 3.4 版更改: 添加了 <em>atTime</em> 形参。</p>
<p>在 3.6 版更改: 除了字符串值，也接受 <code>Path</code> 对象作为 <em>filename</em> 参数。</p>
<p>在 3.9 版更改: 增加了 <em>errors</em> 形参。</p>
<ul>
<li><p><code>doRollover</code>()</p>
<p>执行上文所描述的轮换。</p>
</li>
<li><p><code>emit</code>(<em>record</em>)</p>
<p>将记录输出到文件，以适应上文所描述的轮换。</p>
</li>
</ul>
<h3 id="SocketHandler"><a href="#SocketHandler" class="headerlink" title="SocketHandler"></a>SocketHandler</h3><p><code>SocketHandler</code> 类位于 <code>logging.handlers</code> 模块，它会将日志记录输出发送到网络套接字。 基类所使用的是 TCP 套接字。</p>
<p><em>class</em> <code>logging.handlers.SocketHandler</code>(<em>host</em>, <em>port</em>)</p>
<p>返回一个 <code>SocketHandler</code> 类的新实例，该实例旨在与使用 <em>host</em> 与 <em>port</em> 给定地址的远程主机进行通信。</p>
<p>在 3.4 版更改: 如果 <code>port</code> 指定为 <code>None</code>，会使用 <code>host</code> 中的值来创建一个 Unix 域套接字 —— 在其他情况下，则会创建一个 TCP 套接字。</p>
<ul>
<li><p><code>close</code>()</p>
<p>关闭套接字。</p>
</li>
<li><p><code>emit</code>()</p>
<p>对记录的属性字典执行封存并以二进制格式将其写入套接字。 如果套接字存在错误，则静默地丢弃数据包。 如果连接在此之前丢失，则重新建立连接。 要在接收端将记录解封并输出到 <code>LogRecord</code>，请使用 <code>makeLogRecord()</code> 函数。</p>
</li>
<li><p><code>handleError</code>()</p>
<p>处理在 <code>emit()</code> 期间发生的错误。 最可能的原因是连接丢失。 关闭套接字以便我们能在下次事件时重新尝试。</p>
</li>
<li><p><code>makeSocket</code>()</p>
<p>这是一个工厂方法，它允许子类定义它们想要的套接字的准确类型。 默认实现会创建一个 TCP 套接字 (<code>socket.SOCK_STREAM</code>)。</p>
</li>
<li><p><code>makePickle</code>(<em>record</em>)</p>
<p>将记录的属性字典封存为带有长度前缀的二进制格式，并将其返回以准备通过套接字进行传输。 此操作在细节上相当于:</p>
<pre><code>data = pickle.dumps(record_attr_dict, 1)datalen = struct.pack('&gt;L', len(data))return datalen + data</code></pre><p>请注意封存操作不是绝对安全的。 如果你关心安全问题，你可能会想要重载此方法以实现更安全的机制。 例如，你可以使用 HMAC 对封存对象进行签名然后在接收端验证它们，或者你也可以在接收端禁用全局对象的解封操作。</p>
</li>
<li><p><code>send</code>(<em>packet</em>)</p>
<p>将封存后的字节串 <em>packet</em> 发送到套接字。 所发送字节串的格式与 <code>makePickle()</code> 文档中的描述一致。</p>
<p>此函数允许部分发送，这可能会在网络繁忙时发生。</p>
</li>
<li><p><code>createSocket</code>()</p>
<p>尝试创建一个套接字；失败时将使用指数化回退算法处理。 在失败初次发生时，处理程序将丢弃它正尝试发送的消息。 当后续消息交由同一实例处理时，它将不会尝试连接直到经过一段时间以后。 默认形参设置为初始延迟一秒，如果在延迟之后连接仍然无法建立，处理程序将每次把延迟翻倍直至达到 30 秒的最大值。</p>
<p>此行为由下列处理程序属性控制:</p>
<ul>
<li><code>retryStart</code> (初始延迟，默认为 1.0 秒)。</li>
<li><code>retryFactor</code> (倍数，默认为 2.0)。</li>
<li><code>retryMax</code> (最大延迟，默认为 30.0 秒)。</li>
</ul>
<p>这意味着如果远程监听器在处理程序被使用 <em>之后</em> 启动，你可能会丢失消息（因为处理程序在延迟结束之前甚至不会尝试连接，而在延迟期间静默地丢弃消息）。</p>
</li>
</ul>
<h3 id="DatagramHandler"><a href="#DatagramHandler" class="headerlink" title="DatagramHandler"></a>DatagramHandler</h3><p><code>DatagramHandler</code> 类位于 <code>logging.handlers</code> 模块，它继承自 <code>SocketHandler</code>，支持通过 UDP 套接字发送日志记录消息。</p>
<p><em>class</em> <code>logging.handlers.DatagramHandler</code>(<em>host</em>, <em>port</em>)</p>
<p>返回一个 <code>DatagramHandler</code> 类的新实例，该实例旨在与使用 <em>host</em> 与 <em>port</em> 给定地址的远程主机进行通信。</p>
<p>在 3.4 版更改: 如果 <code>port</code> 指定为 <code>None</code>，会使用 <code>host</code> 中的值来创建一个 Unix 域套接字 —— 在其他情况下，则会创建一个 UDP 套接字。</p>
<ul>
<li><p><code>emit</code>()</p>
<p>对记录的属性字典执行封存并以二进制格式将其写入套接字。 如果套接字存在错误，则静默地丢弃数据包。 要在接收端将记录解封并输出到 <code>LogRecord</code>，请使用 <code>makeLogRecord()</code> 函数。</p>
</li>
<li><p><code>makeSocket</code>()</p>
<p><code>SocketHandler</code> 的工厂方法会在此被重载以创建一个 UDP 套接字 (<code>socket.SOCK_DGRAM</code>)。</p>
</li>
<li><p><code>send</code>(<em>s</em>)</p>
<p>将封存后的字节串发送到套接字。 所发送字节串的格式与 <code>SocketHandler.makePickle()</code> 文档中的描述一致。</p>
</li>
</ul>
<h3 id="SysLogHandler"><a href="#SysLogHandler" class="headerlink" title="SysLogHandler"></a>SysLogHandler</h3><p><code>SysLogHandler</code> 类位于 <code>logging.handlers</code> 模块，它支持将日志记录消息发送到远程或本地 Unix syslog。</p>
<p><em>class</em> <code>logging.handlers.SysLogHandler</code>(<em>address=’localhost’, SYSLOG_UDP_PORT</em>, <em>facility=LOG_USER</em>, <em>socktype=socket.SOCK_DGRAM</em>)</p>
<p>返回一个 <code>SysLogHandler</code> 类的新实例用来与通过 <em>address</em> 以 <code>(host, port)</code> 元组形式给出地址的远程 Unix 机器进行通讯。 如果未指定 <em>address<em>，则使用 <code>('localhost', 514)</code>。 该地址会被用于打开套接字。 提供 <code>(host, port)</code> 元组的一种替代方式是提供字符串形式的地址，例如 ‘/dev/log’。 在这种情况下，会使用 Unix 域套接字将消息发送到 syslog。 如果未指定 *facility</em>，则使用 <code>LOG_USER</code>。 打开的套接字类型取决于 *socktype</em> 参数，该参数的默认值为 <code>socket.SOCK_DGRAM</code> 即打开一个 UDP 套接字。 要打开一个 TCP 套接字（用来配合较新的 syslog 守护程序例如 rsyslog 使用），请指定值为 <code>socket.SOCK_STREAM</code>。</p>
<p>请注意如果你的服务器不是在 UDP 端口 514 上进行侦听，则 <code>SysLogHandler</code> 可能无法正常工作。 在这种情况下，请检查你应当为域套接字所使用的地址 —— 它依赖于具体的系统。 例如，在 Linux 上通常为 ‘/dev/log’ 而在 OS/X 上则为 ‘/var/run/syslog’。 你需要检查你的系统平台并使用适当的地址（如果你的应用程序需要在多个平台上运行则可能需要在运行时进行这样的检查）。 在 Windows 上，你大概必须要使用 UDP 选项。</p>
<p>在 3.2 版更改: 添加了 <em>socktype</em>。</p>
<ul>
<li><p><code>close</code>()</p>
<p>关闭连接远程主机的套接字。</p>
</li>
<li><p><code>emit</code>(<em>record</em>)</p>
<p>记录会被格式化，然后发送到 syslog 服务器。 如果存在异常信息，则它 <em>不会</em> 被发送到服务器。</p>
<p>在 3.2.1 版更改: (参见: <a href="https://bugs.python.org/issue12168" target="_blank" rel="noopener">bpo-12168</a>。) 在较早的版本中，发送至 syslog 守护程序的消息总是以一个 NUL 字节结束，因为守护程序的早期版本期望接收一个以 NUL 结束的消息 —— 即使它不包含于对应的规范说明 (<a href="https://tools.ietf.org/html/rfc5424.html" target="_blank" rel="noopener"><strong>RFC 5424</strong></a>)。 这些守护程序的较新版本不再期望接收 NUL 字节，如果其存在则会将其去除，而最新的守护程序（更紧密地遵循 RFC 5424）会将 NUL 字节作为消息的一部分传递出去。</p>
<p>为了在面对所有这些不同守护程序行为时能够更方便地处理 syslog 消息，通过使用类层级属性 <code>append_nul</code>，添加 NUL 字节的操作已被作为可配置项。 该属性默认为 <code>True</code> (保留现有行为) 但可在 <code>SysLogHandler</code> 实例上设为 <code>False</code> 以便让实例 <em>不会</em> 添加 NUL 结束符。</p>
<p>在 3.3 版更改: (参见: <a href="https://bugs.python.org/issue12419" target="_blank" rel="noopener">bpo-12419</a>。) 在较早的版本中，没有 “ident” 或 “tag” 前缀工具可以用来标识消息的来源。 现在则可以使用一个类层级属性来设置它，该属性默认为 <code>""</code> 表示保留现有行为，但可在 <code>SysLogHandler</code> 实例上重载以便让实例不会为所处理的每条消息添加标识。 请注意所提供的标识必须为文本而非字节串，并且它会被原封不动地添加到消息中。</p>
</li>
<li><p><code>encodePriority</code>(<em>facility</em>, <em>priority</em>)</p>
<p>将功能和优先级编码为一个整数。 你可以传入字符串或者整数 —— 如果传入的是字符串，则会使用内部的映射字典将其转换为整数。</p>
<p>符号 <code>LOG_</code> 的值在 <code>SysLogHandler</code> 中定义并且是 <code>sys/syslog.h</code> 头文件中所定义值的镜像。</p>
<p><strong>优先级</strong></p>
<table>
<thead>
<tr>
<th align="left">名称（字符串）</th>
<th align="left">符号值</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>alert</code></td>
<td align="left">LOG_ALERT</td>
</tr>
<tr>
<td align="left"><code>crit</code> 或 <code>critical</code></td>
<td align="left">LOG_CRIT</td>
</tr>
<tr>
<td align="left"><code>debug</code></td>
<td align="left">LOG_DEBUG</td>
</tr>
<tr>
<td align="left"><code>emerg</code> 或 <code>panic</code></td>
<td align="left">LOG_EMERG</td>
</tr>
<tr>
<td align="left"><code>err</code> 或 <code>error</code></td>
<td align="left">LOG_ERR</td>
</tr>
<tr>
<td align="left"><code>info</code></td>
<td align="left">LOG_INFO</td>
</tr>
<tr>
<td align="left"><code>notice</code></td>
<td align="left">LOG_NOTICE</td>
</tr>
<tr>
<td align="left"><code>warn</code> 或 <code>warning</code></td>
<td align="left">LOG_WARNING</td>
</tr>
</tbody></table>
<p><strong>设备</strong></p>
<table>
<thead>
<tr>
<th align="left">名称（字符串）</th>
<th align="left">符号值</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>auth</code></td>
<td align="left">LOG_AUTH</td>
</tr>
<tr>
<td align="left"><code>authpriv</code></td>
<td align="left">LOG_AUTHPRIV</td>
</tr>
<tr>
<td align="left"><code>cron</code></td>
<td align="left">LOG_CRON</td>
</tr>
<tr>
<td align="left"><code>daemon</code></td>
<td align="left">LOG_DAEMON</td>
</tr>
<tr>
<td align="left"><code>ftp</code></td>
<td align="left">LOG_FTP</td>
</tr>
<tr>
<td align="left"><code>kern</code></td>
<td align="left">LOG_KERN</td>
</tr>
<tr>
<td align="left"><code>lpr</code></td>
<td align="left">LOG_LPR</td>
</tr>
<tr>
<td align="left"><code>mail</code></td>
<td align="left">LOG_MAIL</td>
</tr>
<tr>
<td align="left"><code>news</code></td>
<td align="left">LOG_NEWS</td>
</tr>
<tr>
<td align="left"><code>syslog</code></td>
<td align="left">LOG_SYSLOG</td>
</tr>
<tr>
<td align="left"><code>user</code></td>
<td align="left">LOG_USER</td>
</tr>
<tr>
<td align="left"><code>uucp</code></td>
<td align="left">LOG_UUCP</td>
</tr>
<tr>
<td align="left"><code>local0</code></td>
<td align="left">LOG_LOCAL0</td>
</tr>
<tr>
<td align="left"><code>local1</code></td>
<td align="left">LOG_LOCAL1</td>
</tr>
<tr>
<td align="left"><code>local2</code></td>
<td align="left">LOG_LOCAL2</td>
</tr>
<tr>
<td align="left"><code>local3</code></td>
<td align="left">LOG_LOCAL3</td>
</tr>
<tr>
<td align="left"><code>local4</code></td>
<td align="left">LOG_LOCAL4</td>
</tr>
<tr>
<td align="left"><code>local5</code></td>
<td align="left">LOG_LOCAL5</td>
</tr>
<tr>
<td align="left"><code>local6</code></td>
<td align="left">LOG_LOCAL6</td>
</tr>
<tr>
<td align="left"><code>local7</code></td>
<td align="left">LOG_LOCAL7</td>
</tr>
</tbody></table>
</li>
<li><p><code>mapPriority</code>(<em>levelname</em>)</p>
<p>将日志记录级别名称映射到 syslog 优先级名称。 如果你使用自定义级别，或者如果默认算法不适合你的需要，你可能需要重载此方法。 默认算法将 <code>DEBUG</code>, <code>INFO</code>, <code>WARNING</code>, <code>ERROR</code> 和 <code>CRITICAL</code> 映射到等价的 syslog 名称，并将所有其他级别名称映射到 ‘warning’。</p>
</li>
</ul>
<h3 id="NTEventLogHandler"><a href="#NTEventLogHandler" class="headerlink" title="NTEventLogHandler"></a>NTEventLogHandler</h3><p><code>NTEventLogHandler</code> 类位于 <code>logging.handlers</code> 模块，它支持将日志记录消息发送到本地 Windows NT, Windows 2000 或 Windows XP 事件日志。 在你使用它之前，你需要安装 Mark Hammond 的 Python Win32 扩展。</p>
<p><em>class</em> <code>logging.handlers.NTEventLogHandler</code>(<em>appname</em>, <em>dllname=None</em>, <em>logtype=’Application’</em>)</p>
<p>返回一个 <code>NTEventLogHandler</code> 类的新实例。 <em>appname</em> 用来定义出现在事件日志中的应用名称。 将使用此名称创建适当的注册表条目。 <em>dllname</em> 应当给出要包含在日志中的消息定义的 .dll 或 .exe 的完整限定路径名称（如未指定则会使用 <code>'win32service.pyd'</code> —— 此文件随 Win32 扩展安装且包含一些基本的消息定义占位符。 请注意使用这些占位符将使你的事件日志变得很大，因为整个消息源都会被放入日志。 如果你希望有较小的日志，你必须自行传入包含你想要在事件日志中使用的消息定义的 .dll 或 .exe 名称）。 <em>logtype</em> 为 <code>'Application'</code>, <code>'System'</code> 或 <code>'Security'</code> 之一，且默认值为 <code>'Application'</code>。</p>
<ul>
<li><p><code>close</code>()</p>
<p>这时，你就可以从注册表中移除作为事件日志条目来源的应用名称。 但是，如果你这样做，你将无法如你所预期的那样在事件日志查看器中看到这些事件 —— 它必须能访问注册表来获取 .dll 名称。 当前版本并不会这样做。</p>
</li>
<li><p><code>emit</code>(<em>record</em>)</p>
<p>确定消息 ID，事件类别和事件类型，然后将消息记录到 NT 事件日志中。</p>
</li>
<li><p><code>getEventCategory</code>(<em>record</em>)</p>
<p>返回记录的事件类别。 如果你希望指定你自己的类别就要重载此方法。 此版本将返回 0。</p>
</li>
<li><p><code>getEventType</code>(<em>record</em>)</p>
<p>返回记录的事件类型。 如果你希望指定你自己的类型就要重载此方法。 此版本将使用处理程序的 typemap 属性来执行映射，该属性在 <code>__init__()</code> 被设置为一个字典，其中包含 <code>DEBUG</code>, <code>INFO</code>, <code>WARNING</code>, <code>ERROR</code> 和 <code>CRITICAL</code> 的映射。 如果你使用你自己的级别，你将需要重载此方法或者在处理程序的 <em>typemap</em> 属性中放置一个合适的字典。</p>
</li>
<li><p><code>getMessageID</code>(<em>record</em>)</p>
<p>返回记录的消息 ID。 如果你使用你自己的消息，你可以通过将 <em>msg</em> 传给日志记录器作为 ID 而非格式字符串实现此功能。 然后，你可以在这里使用字典查找来获取消息 ID。 此版本将返回 1，是 <code>win32service.pyd</code> 中的基本消息 ID。</p>
</li>
</ul>
<h3 id="SMTPHandler"><a href="#SMTPHandler" class="headerlink" title="SMTPHandler"></a>SMTPHandler</h3><p><code>SMTPHandler</code> 类位于 <code>logging.handlers</code> 模块，它支持将日志记录消息通过 SMTP 发送到一个电子邮件地址。</p>
<p><em>class</em> <code>logging.handlers.SMTPHandler</code>(<em>mailhost</em>, <em>fromaddr</em>, <em>toaddrs</em>, <em>subject</em>, <em>credentials=None</em>, <em>secure=None</em>, <em>timeout=1.0</em>)</p>
<p>返回一个 <code>SMTPHandler</code> 类的新实例。 该实例使用电子邮件的发件人、收件人地址和主题行进行初始化。 <em>toaddrs</em> 应当为字符串列表。 要指定一个非标准 SMTP 端口，请使用 (host, port) 元组格式作为 <em>mailhost</em> 参数。 如果你使用一个字符串，则会使用标准 SMTP 端口。 如果你的 SMTP 服务器要求验证，你可以指定一个 (username, password) 元组作为 <em>credentials</em> 参数。</p>
<p>要指定使用安全协议 (TLS)，请传入一个元组作为 <em>secure</em> 参数。 这将仅在提供了验证凭据时才能被使用。 元组应当或是一个空元组，或是一个包含密钥文件名的单值元组，或是一个包含密钥文件和证书文件的 2 值元组。 （此元组会被传给 <code>smtplib.SMTP.starttls()</code> 方法。）</p>
<p>可以使用 <em>timeout</em> 参数为与 SMTP 服务器的通信指定超时限制。</p>
<p>3.3 新版功能: 增加了 <em>timeout</em> 参数。</p>
<ul>
<li><p><code>emit</code>(<em>record</em>)</p>
<p>对记录执行格式化并将其发送到指定的地址。</p>
</li>
<li><p><code>getSubject</code>(<em>record</em>)</p>
<p>如果你想要指定一个基于记录的主题行，请重载此方法。</p>
</li>
</ul>
<h3 id="MemoryHandler"><a href="#MemoryHandler" class="headerlink" title="MemoryHandler"></a>MemoryHandler</h3><p><code>MemoryHandler</code> 类位于 <code>logging.handlers</code> 模块，它支持在内存中缓冲日志记录，并定期将其刷新到 <em>target</em> 处理程序中。 刷新会在缓冲区满的时候，或是在遇到特定或更高严重程度事件的时候发生。</p>
<p><code>MemoryHandler</code> 是更通用的 <code>BufferingHandler</code> 的子类，后者属于抽象类。 它会在内存中缓冲日志记录。 当每条记录被添加到缓冲区时，会通过调用 <code>shouldFlush()</code> 来检查缓冲区是否应当刷新。 如果应当刷新，则要使用 <code>flush()</code> 来执行刷新。</p>
<p><em>class</em> <code>logging.handlers.BufferingHandler</code>(<em>capacity</em>)</p>
<p>使用指定容量的缓冲区初始化处理程序。 这里，<em>capacity</em> 是指缓冲的日志记录数量。</p>
<ul>
<li><p><code>emit</code>(<em>record</em>)</p>
<p>将记录添加到缓冲区。 如果 <code>shouldFlush()</code> 返回真值，则会调用 <code>flush()</code> 来处理缓冲区。</p>
</li>
<li><p><code>flush</code>()</p>
<p>你可以重载此方法来实现自定义的刷新行为。 此版本只是将缓冲区清空。</p>
</li>
<li><p><code>shouldFlush</code>(<em>record</em>)</p>
<p>如果缓冲区容量已满则返回 <code>True</code>。 可以重载此方法以实现自定义的刷新策略。</p>
</li>
</ul>
<p><em>class</em> <code>logging.handlers.MemoryHandler</code>(<em>capacity</em>, <em>flushLevel=ERROR</em>, <em>target=None</em>, <em>flushOnClose=True</em>)</p>
<p>返回一个 <code>MemoryHandler</code> 类的新实例。 该实例使用 <em>capacity</em> 指定的缓冲区大小（要缓冲的记录数量）来初始化。 如果 <em>flushLevel</em> 未指定，则使用 <code>ERROR</code>。 如果未指定 <em>target*，则需要在此处理程序执行任何实际操作之前使用 <code>setTarget()</code> 来设置目标。 如果 *flushOnClose</em> 指定为 <code>False</code>，则当处理程序被关闭时 <em>不会</em> 刷新缓冲区。 如果未指定或指定为 <code>True</code>，则当处理程序被关闭时将会发生之前的缓冲区刷新行为。</p>
<p>在 3.6 版更改: 增加了 <em>flushOnClose</em> 形参。</p>
<ul>
<li><p><code>close</code>()</p>
<p>调用 <code>flush()</code>，设置目标为 <code>None</code> 并清空缓冲区。</p>
</li>
<li><p><code>flush</code>()</p>
<p>对于 <code>MemoryHandler</code>，刷新是指将缓冲的记录发送到目标，如果存在目标的话。 当此行为发生时缓冲区也将被清空。 如果你想要不同的行为请重载此方法。</p>
</li>
<li><p><code>setTarget</code>(<em>target</em>)</p>
<p>设置此处理程序的目标处理程序。</p>
</li>
<li><p><code>shouldFlush</code>(<em>record</em>)</p>
<p>检测缓冲区是否已满或是有记录为 <em>flushLevel</em> 或更高级别。</p>
</li>
</ul>
<h3 id="HTTPHandler"><a href="#HTTPHandler" class="headerlink" title="HTTPHandler"></a>HTTPHandler</h3><p><code>HTTPHandler</code> 类位于 <code>logging.handlers</code> 模块，它支持使用 <code>GET</code> 或 <code>POST</code> 语义将日志记录消息发送到 Web 服务器。</p>
<p><em>class</em> <code>logging.handlers.HTTPHandler</code>(<em>host</em>, <em>url</em>, <em>method=’GET’</em>, <em>secure=False</em>, <em>credentials=None</em>, <em>context=None</em>)</p>
<p>返回一个 <code>HTTPHandler</code> 类的新实例。 <em>host</em> 可以为 <code>host:port</code> 的形式，如果你需要使用指定端口号的话。 如果没有指定 <em>method*，则会使用 <code>GET</code>。 如果 *secure</em> 为真值，则将使用 HTTPS 连接。 <em>context</em> 形参可以设为一个 <code>ssl.SSLContext</code> 实例以配置用于 HTTPS 连接的 SSL 设置。 如果指定了 <em>credentials</em>，它应当为包含 userid 和 password 的二元组，该元组将被放入使用 Basic 验证的 HTTP ‘Authorization’ 标头中。 如果你指定了 credentials，你还应当指定 secure=True 这样你的 userid 和 password 就不会以明文在线路上传输。</p>
<p>在 3.5 版更改: 增加了 <em>context</em> 形参。</p>
<ul>
<li><p><code>mapLogRecord</code>(<em>record</em>)</p>
<p>基于 <code>record</code> 提供一个字典，它将被执行 URL 编码并发送至 Web 服务器。 默认实现仅返回 <code>record.__dict__</code>。 在只需将 <code>LogRecord</code> 的某个子集发送至 Web 服务器，或者需要对发送至服务器的内容进行更多定制时可以重载此方法。</p>
</li>
<li><p><code>emit</code>(<em>record</em>)</p>
<p>将记录以 URL 编码字典的形式发送至 Web 服务器。 <code>mapLogRecord()</code> 方法会被用来将要发送的记录转换为字典。</p>
</li>
</ul>
<p>注解</p>
<p>由于记录发送至 Web 服务器所需的预处理与通用的格式化操作不同，使用 <code>setFormatter()</code> 来指定一个 <code>Formatter</code> 用于 <code>HTTPHandler</code> 是没有效果的。 此处理程序不会调用 <code>format()</code>，而是调用 <code>mapLogRecord()</code> 然后再调用 <code>urllib.parse.urlencode()</code> 来以适合发送至 Web 服务器的形式对字典进行编码。</p>
<h3 id="QueueHandler"><a href="#QueueHandler" class="headerlink" title="QueueHandler"></a>QueueHandler</h3><p>3.2 新版功能.</p>
<p><code>QueueHandler</code> 类位于 <code>logging.handlers</code> 模块，它支持将日志记录消息发送到一个队列，例如在 <code>queue</code> 或 <code>multiprocessing</code> 模块中实现的队列。</p>
<p>配合 <code>QueueListener</code> 类使用，<code>QueueHandler</code> 可被用来使处理程序在与执行日志记录的线程不同的线程上完成工作。 这对 Web 应用程序以及其他服务于客户端的线程需要尽可能快地响应的服务应用程序来说很重要，任何潜在的慢速操作（例如通过 <code>SMTPHandler</code> 发送邮件）都要在单独的线程上完成。</p>
<p><em>class</em> <code>logging.handlers.QueueHandler</code>(<em>queue</em>)</p>
<p>返回一个 <code>QueueHandler</code> 类的新实例。 该实例使用队列来初始化以向其发送消息。 <em>queue</em> 可以为任何队列类对象；它由 <code>enqueue()</code> 方法来使用，该方法需要知道如何向其发送消息。 队列 <em>不要求</em> 具有任务跟踪 API，这意味着你可以为 <em>queue</em> 使用 <code>SimpleQueue</code> 实例。</p>
<ul>
<li><p><code>emit</code>(<em>record</em>)</p>
<p>将准备 LogRecord 的结果排入队列。 如果发生了异常（例如由于有界队列已满），则会调用 <code>handleError()</code> 方法来处理错误。 这可能导致记录被静默地丢弃 (如果 <code>logging.raiseExceptions</code> 为 <code>False</code>) 或者消息被打印到 <code>sys.stderr</code> (如果 <code>logging.raiseExceptions</code> 为 <code>True</code>)。</p>
</li>
<li><p><code>prepare</code>(<em>record</em>)</p>
<p>准备用于队列的记录。 此方法返回的对象会被排入队列。</p>
<p>基本实现会格式化记录以合并消息、参数以及可能存在的异常信息。 它还会从记录中原地移除无法封存的条目。</p>
<p>如果你想要将记录转换为 dict 或 JSON 字符串，或者发送记录被修改后的副本而让初始记录保持原样，则你可能会想要重载此方法。</p>
</li>
<li><p><code>enqueue</code>(<em>record</em>)</p>
<p>使用 <code>put_nowait()</code> 将记录排入队列；如果你想要使用阻塞行为，或超时设置，或自定义的队列实现，则你可能会想要重载此方法。</p>
</li>
</ul>
<h3 id="QueueListener"><a href="#QueueListener" class="headerlink" title="QueueListener"></a>QueueListener</h3><p>3.2 新版功能.</p>
<p><code>QueueListener</code> 类位于 <code>logging.handlers</code> 模块，它支持从一个队列接收日志记录消息，例如在 <code>queue</code> 或 <code>multiprocessing</code> 模块中实现的队列。 消息是在内部线程中从队列接收并在同一线程上传递到一个或多个处理程序进行处理的。 尽管 <code>QueueListener</code> 本身并不是一个处理程序，但由于它要与 <code>QueueHandler</code> 配合工作，因此也在此处介绍。</p>
<p>配合 <code>QueueHandler</code> 类使用，<code>QueueListener</code> 可被用来使处理程序在与执行日志记录的线程不同的线程上完成工作。 这对 Web 应用程序以及其他服务于客户端的线程需要尽可能快地响应的服务应用程序来说很重要，任何潜在的慢速动作（例如通过 <code>SMTPHandler</code> 发送邮件）都要在单独的线程上完成。</p>
<p><em>class</em> <code>logging.handlers.QueueListener</code>(<em>queue</em>, <em>\</em>handlers<em>,</em> respect_handler_level=False*)</p>
<p>返回一个 <code>QueueListener</code> 类的新实例。 该实例初始化时要传入一个队列以向其发送消息，还要传入一个处理程序列表用来处理放置在队列中的条目。 队列可以是任何队列类对象；它会被原样传给 <code>dequeue()</code> 方法，该方法需要知道如何从其获取消息。 队列 <em>不要求</em> 具有任务跟踪 API（但如提供则会使用它），这意味着你可以为 <em>queue</em> 使用 <code>SimpleQueue</code> 实例。</p>
<p>如果 <code>respect_handler_level</code> 为 <code>True</code>，则在决定是否将消息传递给处理程序之前会遵循处理程序的级别（与消息的级别进行比较）；在其他情况下，其行为与之前的 Python 版本一致 —— 总是将每条消息传递给每个处理程序。</p>
<p>在 3.5 版更改: 增加了 <code>respect_handler_level</code> 参数。</p>
<ul>
<li><p><code>dequeue</code>(<em>block</em>)</p>
<p>从队列移出一条记录并将其返回，可以选择阻塞。</p>
<p>基本实现使用 <code>get()</code>。 如果你想要使用超时设置或自定义的队列实现，则你可能会想要重载此方法。</p>
</li>
<li><p><code>prepare</code>(<em>record</em>)</p>
<p>准备一条要处理的记录。</p>
<p>该实现只是返回传入的记录。 如果你想要对记录执行任何自定义的 marshal 操作或在将其传给处理程序之前进行调整，则你可能会想要重载此方法。</p>
</li>
<li><p><code>handle</code>(<em>record</em>)</p>
<p>处理一条记录。</p>
<p>此方法简单地循环遍历处理程序，向它们提供要处理的记录。 实际传给处理程序的对象就是从 <code>prepare()</code> 返回的对象。</p>
</li>
<li><p><code>start</code>()</p>
<p>启动监听器。</p>
<p>此方法启动一个后台线程来监视 LogRecords 队列以进行处理。</p>
</li>
<li><p><code>stop</code>()</p>
<p>停止监听器。</p>
<p>此方法要求线程终止，然后等待它完成终止操作。 请注意在你的应用程序退出之前如果你没有调用此方法，则可能会有一些记录在留在队列中，它们将不会被处理。</p>
</li>
<li><p><code>enqueue_sentinel</code>()</p>
<p>将一个标记写入队列以通知监听器退出。 此实现会使用 <code>put_nowait()</code>。 如果你想要使得超时设置或自定义的队列实现，则你可能会想要重载此方法。</p>
<p>3.3 新版功能.</p>
</li>
</ul>
<h2 id="getpass-—-便携式密码输入工具"><a href="#getpass-—-便携式密码输入工具" class="headerlink" title="getpass —- 便携式密码输入工具"></a><code>getpass</code> —- 便携式密码输入工具</h2><p><strong>源代码:</strong> <a href="https://github.com/python/cpython/tree/3.10/Lib/getpass.py" target="_blank" rel="noopener">Lib/getpass.py</a></p>
<hr>
<p><code>getpass</code> 模块提供了两个函数：</p>
<p><code>getpass.getpass</code>(<em>prompt=’Password: ‘</em>, <em>stream=None</em>)</p>
<p>提示用户输入一个密码且不会回显。 用户会看到字符串 <em>prompt</em> 作为提示，其默认值为 <code>'Password: '</code>。 在 Unix 上，如有必要提示会使用替换错误句柄写入到文件类对象 <em>stream*。 *stream</em> 默认指向控制终端 (<code>/dev/tty</code>)，如果不可用则指向 <code>sys.stderr</code> (此参数在 Windows 上会被忽略)。</p>
<p>如果回显自由输入不可用则 getpass() 将回退为打印一条警告消息到 <em>stream</em> 并且从 <code>sys.stdin</code> 读取同时发出 <code>GetPassWarning</code>。</p>
<p>注解</p>
<p>如果你从 IDLE 内部调用 getpass，输入可能是在你启动 IDLE 的终端中而非在 IDLE 窗口本身中完成。</p>
<p><em>exception</em> <code>getpass.GetPassWarning</code></p>
<p>一个当密码输入可能被回显时发出的 <code>UserWarning</code> 子类。</p>
<p><code>getpass.getuser</code>()</p>
<p>返回用户的“登录名称”。</p>
<p>此函数会按顺序检查环境变量 <code>LOGNAME</code>, <code>USER</code>, <code>LNAME</code> 和 <code>USERNAME</code>，并返回其中第一个被设置为非空字符串的值。 如果均未设置，则在支持 <code>pwd</code> 模块的系统上将返回来自密码数据库的登录名，否则将引发一个异常。</p>
<p>通常情况下，此函数应优先于 <code>os.getlogin()</code> 使用。</p>
<h2 id="curses-—-终端字符单元显示的处理"><a href="#curses-—-终端字符单元显示的处理" class="headerlink" title="curses —- 终端字符单元显示的处理"></a><code>curses</code> —- 终端字符单元显示的处理</h2><p><code>curses</code> 模块提供了 curses 库的接口，这是可移植高级终端处理的事实标准。</p>
<p>虽然 curses 在 Unix 环境中使用最为广泛，但也有适用于 Windows，DOS 以及其他可能的系统的版本。此扩展模块旨在匹配 ncurses 的 API，这是一个部署在 Linux 和 Unix 的 BSD 变体上的开源 curses 库。</p>
<p>注解</p>
<p>每当文档提到 <strong>字符</strong> 时，它可以被指定为一个整数，一个单字符 Unicode 字符串或者一个单字节的字节字符串。</p>
<p>每当此文档提到 <strong>字符串</strong> 时，它可以被指定为一个 Unicode 字符串或者一个字节字符串。</p>
<p>注解</p>
<p>从 5.4 版本开始，ncurses 库使用 <code>nl_langinfo</code> 函数来决定如何解释非 ASCII 数据。这意味着你需要在程序中调用 <code>locale.setlocale()</code> 函数，并使用一种系统中可用的编码方法来编码 Unicode 字符串。这个例子使用了系统默认的编码:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> locale
locale<span class="token punctuation">.</span>setlocale<span class="token punctuation">(</span>locale<span class="token punctuation">.</span>LC_ALL<span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">)</span>
code <span class="token operator">=</span> locale<span class="token punctuation">.</span>getpreferredencoding<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>然后使用 <em>code</em> 作为 <code>str.encode()</code> 调用的编码。</p>
<p>关于配合 Python 使用 curses 的教学材料，由 Andrew Kuchling 和 Eric Raymond 撰写。</p>
<p>Python 源码发布包的 <a href="https://github.com/python/cpython/tree/3.10/Tools/demo/" target="_blank" rel="noopener">Tools/demo/</a> 目录包含了一些使用此模块所提供的 curses 绑定的示例程序。</p>
<h3 id="函数-1"><a href="#函数-1" class="headerlink" title="函数"></a>函数</h3><p><code>curses</code> 模块定义了以下异常：</p>
<p><em>exception</em> <code>curses.error</code></p>
<p>当 curses 库中函数返回一个错误时引发的异常。</p>
<p>注解</p>
<p>只要一个函数或方法的 <em>x</em> 或 <em>y</em> 参数是可选项，它们会默认为当前光标位置。 而当 <em>attr</em> 是可选项时，它会默认为 <code>A_NORMAL</code>。</p>
<p><code>curses</code> 模块定义了以下函数：</p>
<p><code>curses.baudrate</code>()</p>
<p>以每秒比特数为单位返回终端输出速度。 在软件终端模拟器上它将具有一个固定的最高值。 此函数出于历史原因被包括；在以前，它被用于写输出循环以提供时间延迟，并偶尔根据线路速度来改变接口。</p>
<p><code>curses.beep</code>()</p>
<p>发出短促的提醒声音。</p>
<p><code>curses.can_change_color</code>()</p>
<p>根据程序员能否改变终端显示的颜色返回 <code>True</code> 或 <code>False</code>。</p>
<p><code>curses.cbreak</code>()</p>
<p>进入 cbreak 模式。 在 cbreak 模式（有时也称为“稀有”模式）通常的 tty 行缓冲会被关闭并且字符可以被一个一个地读取。 但是，与原始模式不同，特殊字符（中断、退出、挂起和流程控制）会在 tty 驱动和调用程序上保留其效果。 首先调用 <code>raw()</code> 然后调用 <code>cbreak()</code> 会将终端置于 cbreak 模式。</p>
<p><code>curses.color_content</code>(<em>color_number</em>)</p>
<p>返回颜色值 <em>color_number</em> 中红、绿和蓝（RGB）分量的强度，此强度值必须介于 <code>0</code> 和 <code>COLORS - 1</code> 之间。 返回一个 3 元组，其中包含给定颜色的 R,G,B 值，它们必须介于 <code>0</code> (无分量) 和 <code>1000</code> (最大分量) 之间。</p>
<p><code>curses.color_pair</code>(<em>pair_number</em>)</p>
<p>返回用于以指定颜色对显示文本的属性值。 仅支持前 256 个颜色对。 该属性值可与 <code>A_STANDOUT</code>, <code>A_REVERSE</code> 以及其他 <code>A_*</code> 属性组合使用。 <code>pair_number()</code> 是此函数的对应操作。</p>
<p><code>curses.curs_set</code>(<em>visibility</em>)</p>
<p>设置光标状态。 <em>visibility</em> 可设为 <code>0</code>, <code>1</code> 或 <code>2</code> 表示不可见、正常与高度可见。 如果终端支持所请求的可见性，则返回之前的光标状态；否则会引发异常。 在许多终端上，“正常可见”模式为下划线光标而“高度可见”模式为方块形光标。</p>
<p><code>curses.def_prog_mode</code>()</p>
<p>将当前终端模式保存为 “program” 模式，即正在运行的程序使用 curses 的模式。 （与其相对的是 “shell” 模式，即程序不使用 curses。） 对 <code>reset_prog_mode()</code> 的后续调用将恢复此模式。</p>
<p><code>curses.def_shell_mode</code>()</p>
<p>将当前终端模式保存为 “shell” 模式，即正在运行的程序不使用 curses 的模式。 （与其相对的是 “program” 模式，即程序使用 功能。） 对 <code>reset_shell_mode()</code> 的后续调用将恢复此模式。</p>
<p><code>curses.delay_output</code>(<em>ms</em>)</p>
<p>在输出中插入 <em>ms</em> 毫秒的暂停。</p>
<p><code>curses.doupdate</code>()</p>
<p>更新物理屏幕。 curses 库会保留两个数据结构，一个代表当前物理屏幕的内容以及一个虚拟屏幕代表需要的后续状态。 <code>doupdate()</code> 整体更新物理屏幕以匹配虚拟屏幕。</p>
<p>虚拟屏幕可以通过在写入操作例如在一个窗口上执行 <code>addstr()</code> 之后调用 <code>noutrefresh()</code> 来刷新。 普通的 <code>refresh()</code> 调用只是简单的 <code>noutrefresh()</code> 加 <code>doupdate()</code>；如果你需要更新多个窗口，你可以通过在所有窗口上发出 <code>noutrefresh()</code> 调用再加单次 <code>doupdate()</code> 来提升性能并可减少屏幕闪烁。</p>
<p><code>curses.echo</code>()</p>
<p>进入 echo 模式。 在 echo 模式下，输入的每个字符都会在输入后回显到屏幕上。</p>
<p><code>curses.endwin</code>()</p>
<p>撤销库的初始化，使终端返回正常状态。</p>
<p><code>curses.erasechar</code>()</p>
<p>将用户的当前擦除字符以单字节字节串对象的形式返回。 在 Unix 操作系统下这是 curses 程序用来控制 tty 的属性，而不是由 curses 库本身来设置的。</p>
<p><code>curses.filter</code>()</p>
<p>如果要使用 <code>filter()</code> 例程，它必须在调用 <code>initscr()</code> 之前被调用。 其效果是在这些调用期间，<code>LINES</code> 会被设为 <code>1</code>；<code>clear</code>, <code>cup</code>, <code>cud</code>, <code>cud1</code>, <code>cuu1</code>, <code>cuu</code>, <code>vpa</code> 等功能会被禁用；而 <code>home</code> 字符串会被设为 <code>cr</code> 的值。 其影响是光标会被限制在当前行内，屏幕刷新也是如此。 这可被用于启用单字符模式的行编辑而不触及屏幕的其余部分。</p>
<p><code>curses.flash</code>()</p>
<p>闪烁屏幕。 也就是将其改为反显并在很短的时间内将其改回原状。 有些人更喜欢这样的‘视觉响铃’而非 <code>beep()</code> 所产生的听觉提醒信号。</p>
<p><code>curses.flushinp</code>()</p>
<p>刷新所有输入缓冲区。 这会丢弃任何已被用户输入但尚未被程序处理的预输入内容。</p>
<p><code>curses.getmouse</code>()</p>
<p>在 <code>getch()</code> 返回 <code>KEY_MOUSE</code> 以发出鼠标事件信号之后，应当调用此方法来获取加入队列的鼠标事件，事件以一个 5 元组 <code>(id, x, y, z, bstate)</code> 来表示。 其中 <em>id</em> 为用于区分多个设备的 ID 值，而 <em>x</em>, <em>y</em>, <em>z</em> 为事件的坐标。 (<em>z</em> 目前未被使用。) <em>bstate</em> 为一个整数值，其各个比特位将被设置用来表示事件的类型，并将为下列常量中的一个或多个按位 OR 的结果，其中 <em>n</em> 是以 1 到 5 表示的键号: <code>BUTTONn_PRESSED</code>, <code>BUTTONn_RELEASED</code>, <code>BUTTONn_CLICKED</code>, <code>BUTTONn_DOUBLE_CLICKED</code>, <code>BUTTONn_TRIPLE_CLICKED</code>, <code>BUTTON_SHIFT</code>, <code>BUTTON_CTRL</code>, <code>BUTTON_ALT</code>。</p>
<p>在 3.10 版更改: 现在 <code>BUTTON5_*</code> 常量如果是由下层 curses 库提供的则会对外公开。</p>
<p><code>curses.getsyx</code>()</p>
<p>将当前虚拟屏幕光标的坐标作为元组 <code>(y, x)</code> 返回。 如果 <code>leaveok</code> 当前为 <code>True</code>，则返回 <code>(-1, -1)</code>。</p>
<p><code>curses.getwin</code>(<em>file</em>)</p>
<p>读取由之前的 <code>putwin()</code> 调用存放在文件中的窗口相关数据。 该例程随后将使用该数据创建并初始化一个新窗口，并返回该新窗口对象。</p>
<p><code>curses.has_colors</code>()</p>
<p>如果终端能显示彩色则返回 <code>True</code>；否则返回 <code>False</code>。</p>
<p><code>curses.has_extended_color_support</code>()</p>
<p>如果此模块支持扩展颜色则返回 <code>True</code>；否则返回 <code>False</code>。 扩展颜色支持允许支持超过 16 种颜色的终端（例如 xterm-256color）支持超过 256 种颜色对。</p>
<p>扩展颜色支持要求 ncurses 版本为 6.1 或更新。</p>
<p>3.10 新版功能.</p>
<p><code>curses.has_ic</code>()</p>
<p>如果终端具有插入和删除字符的功能则返回 <code>True</code>。 此函数仅是出于历史原因而被包括的，因为所有现代软件终端模拟器都具有这些功能。</p>
<p><code>curses.has_il</code>()</p>
<p>如果终端具有插入和删除字符功能，或者能够使用滚动区域来模拟这些功能则返回 <code>True</code>。 此函数仅是出于历史原因而被包括的，因为所有现代软件终端模拟器都具有这些功能。</p>
<p><code>curses.has_key</code>(<em>ch</em>)</p>
<p>接受一个键值 <em>ch</em>，并在当前终端类型能识别出具有该值的键时返回 <code>True</code>。</p>
<p><code>curses.halfdelay</code>(<em>tenths</em>)</p>
<p>用于半延迟模式，与 cbreak 模式的类似之处是用户所键入的字符会立即对程序可用。 但是，在阻塞 <em>tenths</em> 个十分之一秒之后，如果还未输入任何内容则将引发异常。 <em>tenths</em> 值必须为 <code>1</code> 和 <code>255</code> 之间的数字。 使用 <code>nocbreak()</code> 可退出半延迟模式。</p>
<p><code>curses.init_color</code>(<em>color_number</em>, <em>r</em>, <em>g</em>, <em>b</em>)</p>
<p>更改某个颜色的定义，接受要更改的颜色编号以及三个 RGB 值（表示红绿蓝三分量的强度）。 <em>color_number</em> 值必须为 <code>0</code> 和 COLORS - 1 之间的数字。 <em>r</em>, <em>g</em>, <em>b</em> 值必须为 <code>0</code> 和 <code>1000</code> 之间的数字。 当使用 <code>init_color()</code> 时，出现在屏幕上的对应颜色会立即按照新定义来更改。 此函数在大多数终端上都是无操作的；它仅会在 <code>can_change_color()</code> 返回 <code>True</code> 时生效。</p>
<p><code>curses.init_pair</code>(<em>pair_number</em>, <em>fg</em>, <em>bg</em>)</p>
<p>更改某个颜色对的定义。 它接受三个参数：要更改的颜色对编号，前景色编号和背景色编号。 <em>pair_number</em> 值必须为 <code>1</code> 和 <code>COLOR_PAIRS - 1</code> 之间的数字（并且 <code>0</code> 号颜色对固定为黑底白字而无法更改）。 <em>fg</em> 和 <em>bg</em> 参数必须为 <code>0</code> 和 <code>COLORS - 1</code> 之间的数字，或者在调用 <code>use_default_colors()</code> 之后则为 <code>-1</code>。 如果颜色对之前已被初始化，则屏幕会被刷新使得出现在屏幕上的该颜色会立即按照新定义来更改。</p>
<p><code>curses.initscr</code>()</p>
<p>初始化库。 返回代表整个屏幕的 窗口 对象。</p>
<p>注解</p>
<p>如果打开终端时发生错误，则下层的 curses 库可能会导致解释器退出。</p>
<p><code>curses.is_term_resized</code>(<em>nlines</em>, <em>ncols</em>)</p>
<p>如果 <code>resize_term()</code> 会修改窗口结构则返回 <code>True</code>，否则返回 <code>False</code>。</p>
<p><code>curses.isendwin</code>()</p>
<p>如果 <code>endwin()</code> 已经被调用（即 curses 库已经被撤销初始化则返回 <code>True</code>。</p>
<p><code>curses.keyname</code>(<em>k</em>)</p>
<p>将编号为 <em>k</em> 的键名称作为字节串对象返回。 生成可打印 ASCII 字符的键名称就是键所对应的字符。 Ctrl-键组合的键名称则是一个两字节的字节串对象，它由插入符 (<code>b'^'</code>) 加对应的可打印 ASCII 字符组成。 Alt-键组合 (128—255) 的键名称则是由前缀 <code>b'M-'</code> 加对应的可打印 ASCII 字符组成的字节串对象。</p>
<p><code>curses.killchar</code>()</p>
<p>将用户的当前行删除字符以单字节字节串对象的形式返回。 在 Unix 操作系统下这是 curses 程序用来控制 tty 的属性，而不是由 curses 库本身来设置的。</p>
<p><code>curses.longname</code>()</p>
<p>返回一个字节串对象，其中包含描述当前终端的 terminfo 长名称字段。 详细描述的最大长度为 128 个字符。 它仅在调用 <code>initscr()</code> 之后才会被定义。</p>
<p><code>curses.meta</code>(<em>flag</em>)</p>
<p>如果 <em>flag</em> 为 <code>True</code>，则允许输入 8 比特位的字符。 如果 <em>flag</em> 为 <code>False</code>，则只允许 7 比特位的字符。</p>
<p><code>curses.mouseinterval</code>(<em>interval</em>)</p>
<p>以毫秒为单位设置能够被识别为点击的按下和释放事件之间可以间隔的最长时间，并返回之前的间隔值。 默认值为 200 毫秒，即五分之一秒。</p>
<p><code>curses.mousemask</code>(<em>mousemask</em>)</p>
<p>设置要报告的鼠标事件，并返回一个元组 <code>(availmask, oldmask)</code>。 <em>availmask</em> 表明指定的鼠标事件中哪些可以被报告；当完全失败时将返回 <code>0</code>。 <em>oldmask</em> 是给定窗口的鼠标事件之前的掩码值。 如果从未调用此函数，则不会报告任何鼠标事件。</p>
<p><code>curses.napms</code>(<em>ms</em>)</p>
<p>休眠 <em>ms</em> 毫秒。</p>
<p><code>curses.newpad</code>(<em>nlines</em>, <em>ncols</em>)</p>
<p>创建并返回一个指向具有给定行数和列数新的面板数据结构的指针。 将面板作为窗口对象返回。</p>
<p>面板类似于窗口，区别在于它不受屏幕大小的限制，并且不必与屏幕的特定部分相关联。 面板可以在需要使用大窗口时使用，并且每次只需将窗口的一部分放在屏幕上。 面板不会发生自动刷新（例如由于滚动或输入回显）。 面板的 <code>refresh()</code> 和 <code>noutrefresh()</code> 方法需要 6 个参数来指定面板要显示的部分以及要用于显示的屏幕位置。 这些参数是 <em>pminrow</em>, <em>pmincol</em>, <em>sminrow</em>, <em>smincol</em>, <em>smaxrow</em>, <em>smaxcol<em>；</em>p</em> 参数表示要显示的面板区域的左上角而 <em>s</em> 参数定义了要显示的面板区域在屏幕上的剪切框。</p>
<p><code>curses.newwin</code>(<em>nlines</em>, <em>ncols</em>)</p>
<p><code>curses.newwin</code>(<em>nlines</em>, <em>ncols</em>, <em>begin_y</em>, <em>begin_x</em>)</p>
<p>返回一个新的 窗口，其左上角位于 <code>(begin_y, begin_x)</code>，并且其高度/宽度为 <em>nlines</em>/<em>ncols</em>。</p>
<p>默认情况下，窗口将从指定位置扩展到屏幕的右下角。</p>
<p><code>curses.nl</code>()</p>
<p>进入 newline 模式。 此模式会在输入时将回车转换为换行符，并在输出时将换行符转换为回车加换行。 newline 模式会在初始时启用。</p>
<p><code>curses.nocbreak</code>()</p>
<p>退出 cbreak 模式。 返回具有行缓冲的正常 “cooked” 模式。</p>
<p><code>curses.noecho</code>()</p>
<p>退出 echo 模式。 关闭输入字符的回显。</p>
<p><code>curses.nonl</code>()</p>
<p>退出 newline 模式。 停止在输入时将回车转换为换行，并停止在输出时从换行到换行/回车的底层转换（但这不会改变 <code>addch('\n')</code> 的行为，此行为总是在虚拟屏幕上执行相当于回车加换行的操作）。 当停止转换时，curses 有时能使纵向移动加快一些；并且，它将能够在输入时检测回车键。</p>
<p><code>curses.noqiflush</code>()</p>
<p>当使用 <code>noqiflush()</code> 例程时，与 <code>INTR</code>, <code>QUIT</code> 和 <code>SUSP</code> 字符相关联的输入和输出队列的正常刷新将不会被执行。 如果你希望在处理程序退出后还能继续输出，就像没有发生过中断一样，你可能会想要在信号处理程序中调用 <code>noqiflush()</code>。</p>
<p><code>curses.noraw</code>()</p>
<p>退出 raw 模式。 返回具有行缓冲的正常 “cooked” 模式。</p>
<p><code>curses.pair_content</code>(<em>pair_number</em>)</p>
<p>返回包含对应于所请求颜色对的元组 <code>(fg, bg)</code>。 <em>pair_number</em> 的值必须在 <code>0</code> 和 <code>COLOR_PAIRS - 1</code> 之间。</p>
<p><code>curses.pair_number</code>(<em>attr</em>)</p>
<p>返回通过属性值 <em>attr</em> 所设置的颜色对的编号。 <code>color_pair()</code> 是此函数的对应操作。</p>
<p><code>curses.putp</code>(<em>str</em>)</p>
<p>等价于 <code>tputs(str, 1, putchar)</code>；为当前终端发出指定 terminfo 功能的值。 请注意 <code>putp()</code> 的输出总是前往标准输出。</p>
<p><code>curses.qiflush</code>([<em>flag</em>])</p>
<p>如果 <em>flag</em> 为 <code>False</code>，则效果与调用 <code>noqiflush()</code> 相同。 如果 <em>flag</em> 为 <code>True</code> 或未提供参数，则在读取这些控制字符时队列将被刷新。</p>
<p><code>curses.raw</code>()</p>
<p>进入 raw 模式。 在 raw 模式下，正常的行缓冲和对中断、退出、挂起和流程控制键的处理会被关闭；字符会被逐个地提交给 curses 输入函数。</p>
<p><code>curses.reset_prog_mode</code>()</p>
<p>将终端恢复到 “program” 模式，如之前由 <code>def_prog_mode()</code> 所保存的一样。</p>
<p><code>curses.reset_shell_mode</code>()</p>
<p>将终端恢复到 “shell” 模式，如之前由 <code>def_shell_mode()</code> 所保存的一样。</p>
<p><code>curses.resetty</code>()</p>
<p>将终端模式恢复到最后一次调用 <code>savetty()</code> 时的状态。</p>
<p><code>curses.resize_term</code>(<em>nlines</em>, <em>ncols</em>)</p>
<p>由 <code>resizeterm()</code> 用来执行大部分工作的后端函数；当调整窗口大小时，<code>resize_term()</code> 会以空白填充扩展区域。 调用方应用程序应当以适当的数据填充这些区域。 <code>resize_term()</code> 函数会尝试调整所有窗口的大小。 但是，由于面板的调用约定，在不与应用程序进行额外交互的情况下是无法调整其大小的。</p>
<p><code>curses.resizeterm</code>(<em>nlines</em>, <em>ncols</em>)</p>
<p>将标准窗口和当前窗口的大小调整为指定的尺寸，并调整由 curses 库所使用的记录窗口尺寸的其他记录数据（特别是 SIGWINCH 处理程序）。</p>
<p><code>curses.savetty</code>()</p>
<p>将终端模式的当前状态保存在缓冲区中，可供 <code>resetty()</code> 使用。</p>
<p><code>curses.get_escdelay</code>()</p>
<p>提取通过 <code>set_escdelay()</code> 设置的值。</p>
<p>3.9 新版功能.</p>
<p><code>curses.set_escdelay</code>(<em>ms</em>)</p>
<p>设置读取一个转义字符后要等待的毫秒数，以区分在键盘上输入的单个转义字符与通过光标和功能键发送的转义序列。</p>
<p>3.9 新版功能.</p>
<p><code>curses.get_tabsize</code>()</p>
<p>提取通过 <code>set_tabsize()</code> 设置的值。</p>
<p>3.9 新版功能.</p>
<p><code>curses.set_tabsize</code>(<em>size</em>)</p>
<p>设置 curses 库在将制表符添加到窗口时将制表符转换为空格所使用的列数。</p>
<p>3.9 新版功能.</p>
<p><code>curses.setsyx</code>(<em>y</em>, <em>x</em>)</p>
<p>将虚拟屏幕光标设置到 <em>y</em>, <em>x</em>。 如果 <em>y</em> 和 <em>x</em> 均为 <code>-1</code>，则 <code>leaveok</code> 将设为 <code>True</code>。</p>
<p><code>curses.setupterm</code>(<em>term=None</em>, <em>fd=- 1</em>)</p>
<p>初始化终端。 <em>term</em> 为给出终端名称的字符串或为 <code>None</code>；如果省略或为 <code>None</code>，则将使用 <code>TERM</code> 环境变量的值。 <em>fd</em> 是任何初始化序列将被发送到的文件描述符；如未指定或为 <code>-1</code>，则将使用 <code>sys.stdout</code> 的文件描述符。</p>
<p><code>curses.start_color</code>()</p>
<p>如果程序员想要使用颜色，则必须在任何其他颜色操作例程被调用之前调用它。 在 <code>initscr()</code> 之后立即调用此例程是一个很好的做法。</p>
<p><code>start_color()</code> 会初始化八种基本颜色（黑、红、绿、黄、蓝、品、青和白）以及 <code>curses</code> 模块中的两个全局变量 <code>COLORS</code> 和 <code>COLOR_PAIRS</code>，其中包含终端可支持的颜色和颜色对的最大数量。 它还会将终端中的颜色恢复为终端刚启动时的值。</p>
<p><code>curses.termattrs</code>()</p>
<p>返回终端所支持的所有视频属性逻辑 OR 的值。 此信息适用于当 curses 程序需要对屏幕外观进行完全控制的情况。</p>
<p><code>curses.termname</code>()</p>
<p>将环境变量 <code>TERM</code> 的值截短至 14 个字节，作为字节串对象返回。</p>
<p><code>curses.tigetflag</code>(<em>capname</em>)</p>
<p>将与 terminfo 功能名称 <em>capname</em> 相对应的布尔功能值以整数形式返回。 如果 <em>capname</em> 不是一个布尔功能则返回 <code>-1</code>，如果其被取消或不存在于终端描述中则返回 <code>0</code>。</p>
<p><code>curses.tigetnum</code>(<em>capname</em>)</p>
<p>将与 terminfo 功能名称 <em>capname</em> 相对应的数字功能值以整数形式返回。 如果 <em>capname</em> 不是一个数字功能则返回 <code>-2</code>，如果其被取消或不存在于终端描述中则返回 <code>-1</code>。</p>
<p><code>curses.tigetstr</code>(<em>capname</em>)</p>
<p>将与 terminfo 功能名称 <em>capname</em> 相对应的字符串功能值以字节串对象形式返回。 如果 <em>capname</em> 不是一个 terminfo “字符串功能” 或者如果其被取消或不存在于终端描述中则返回 <code>None</code>。</p>
<p><code>curses.tparm</code>(<em>str</em>[, <em>…</em>])</p>
<p>使用提供的形参初始化字节串对象 <em>str*，其中 *str</em> 应当是从 terminfo 数据库获取的参数化字符串。 例如 <code>tparm(tigetstr("cup"), 5, 3)</code> 的结果可能为 <code>b'\033[6;4H'</code>，实际结果将取决于终端类型。</p>
<p><code>curses.typeahead</code>(<em>fd</em>)</p>
<p>指定将被用于预输入检查的文件描述符 <em>fd*。 如果 *fd</em> 为 <code>-1</code>，则不执行预输入检查。</p>
<p>curses 库会在更新屏幕时通过定期查找预输入来执行 “断行优化”。 如果找到了输入，并且输入是来自于 tty，则会将当前更新推迟至 refresh 或 doupdate 再次被调用的时候，以便允许更快地响应预先输入的命令。 此函数允许为预输入检查指定其他的文件描述符。</p>
<p><code>curses.unctrl</code>(<em>ch</em>)</p>
<p>返回一个字节串对象作为字符 <em>ch</em> 的可打印表示形式。 控制字符会表示为一个变换符加相应的字符，例如 <code>b'^C'</code>。 可打印字符则会保持原样。</p>
<p><code>curses.ungetch</code>(<em>ch</em>)</p>
<p>推送 <em>ch</em> 以便让下一个 <code>getch()</code> 返回该字符。</p>
<p>注解</p>
<p>在 <code>getch()</code> 被调用之前只能推送一个 <em>ch</em>。</p>
<p><code>curses.update_lines_cols</code>()</p>
<p>更新 <code>LINES</code> 和 <code>COLS</code>。 适用于检测屏幕大小的手动调整。</p>
<p>3.5 新版功能.</p>
<p><code>curses.unget_wch</code>(<em>ch</em>)</p>
<p>推送 <em>ch</em> 以便让下一个 <code>get_wch()</code> 返回该字符。</p>
<p>注解</p>
<p>在 <code>get_wch()</code> 被调用之前只能推送一个 <em>ch</em>。</p>
<p>3.3 新版功能.</p>
<p><code>curses.ungetmouse</code>(<em>id</em>, <em>x</em>, <em>y</em>, <em>z</em>, <em>bstate</em>)</p>
<p>将 <code>KEY_MOUSE</code> 事件推送到输入队列，将其与给定的状态数据进行关联。</p>
<p><code>curses.use_env</code>(<em>flag</em>)</p>
<p>如果使用此函数，则应当在调用 <code>initscr()</code> 或 newterm 之前调用它。 当 <em>flag</em> 为 <code>False</code> 时，将会使用在 terminfo 数据库中指定的行和列的值，即使设置了环境变量 <code>LINES</code> 和 <code>COLUMNS</code> (默认使用)，或者如果 curses 是在窗口中运行（在此情况下如果未设置 <code>LINES</code> 和 <code>COLUMNS</code> 则默认行为将是使用窗口大小）。</p>
<p><code>curses.use_default_colors</code>()</p>
<p>允许在支持此特性的终端上使用默认的颜色值。 使用此函数可在你的应用程序中支持透明效果。 默认颜色会被赋给颜色编号 <code>-1</code>。 举例来说，在调用此函数后，<code>init_pair(x, curses.COLOR_RED, -1)</code> 会将颜色对 <em>x</em> 初始化为红色前景和默认颜色背景。</p>
<p><code>curses.wrapper</code>(<em>func</em>, <em>/</em>, <em>\</em>args<em>,</em> <em>*kwargs</em>)</p>
<p>初始化 curses 并调用另一个可调用对象 <em>func*，该对象应当为你的使用 curses 的应用程序的其余部分。 如果应用程序引发了异常，此函数将在重新引发异常并生成回溯信息之前将终端恢复到正常状态。 随后可调用对象 *func</em> 会被传入主窗口 ‘stdscr’ 作为其第一个参数，再带上其他所有传给 <code>wrapper()</code> 的参数。 在调用 <em>func</em> 之前，<code>wrapper()</code> 会启用 cbreak 模式，关闭回显，启用终端键盘，并在终端具有颜色支持的情况下初始化颜色。 在退出时（无论是正常退出还是异常退出）它会恢复 cooked 模式，打开回显，并禁用终端键盘。</p>
<h3 id="Window-对象"><a href="#Window-对象" class="headerlink" title="Window 对象"></a>Window 对象</h3><p>Window 对象会由上面的 <code>initscr()</code> 和 <code>newwin()</code> 返回，它具有以下方法和属性:</p>
<p><code>window.addch</code>(<em>ch</em>[, <em>attr</em>])</p>
<p><code>window.addch</code>(<em>y</em>, <em>x</em>, <em>ch</em>[, <em>attr</em>])</p>
<p>将带有属性 <em>attr</em> 的字符 <em>ch</em> 绘制到 <code>(y, x)</code>，覆盖之前在该位置上绘制的任何字符。 默认情况下，字符的位置和属性均为窗口对象的当前设置。</p>
<p>注解</p>
<p>在窗口、子窗口或面板之外写入会引发 <code>curses.error</code>。 尝试在窗口、子窗口或面板的右下角写入将在字符被打印之后导致异常被引发。</p>
<p><code>window.addnstr</code>(<em>str</em>, <em>n</em>[, <em>attr</em>])</p>
<p><code>window.addnstr</code>(<em>y</em>, <em>x</em>, <em>str</em>, <em>n</em>[, <em>attr</em>])</p>
<p>将带有属性 <em>attr</em> 的字符串 <em>str</em> 中的至多 <em>n</em> 个字符绘制到 <code>(y, x)</code>，覆盖之前在屏幕上的任何内容。</p>
<p><code>window.addstr</code>(<em>str</em>[, <em>attr</em>])</p>
<p><code>window.addstr</code>(<em>y</em>, <em>x</em>, <em>str</em>[, <em>attr</em>])</p>
<p>将带有属性 <em>attr</em> 的字符串 <em>str</em> 绘制到 <code>(y, x)</code>，覆盖之前在屏幕上的任何内容。</p>
<p>注解</p>
<ul>
<li>在窗口、子窗口或面板之外写入会引发 <code>curses.error</code>。 尝试在窗口、子窗口或面板的右下角写入将在字符串被打印之后导致异常被引发。</li>
<li>此 Python 模块的后端 <a href="https://bugs.python.org/issue35924" target="_blank" rel="noopener">ncurses 中的一个缺陷</a> 会在调整窗口大小时导致段错误。 此缺陷已在 ncurses-6.1-20190511 中被修复。 如果你必须使用较早版本的 ncurses，则你只要在调用 <code>addstr()</code> 时不传入嵌入了换行符的 <em>str</em> 即可避免触发此错误。 请为每一行分别调用 <code>addstr()</code>。</li>
</ul>
<p><code>window.attroff</code>(<em>attr</em>)</p>
<p>从应用于写入到当前窗口的 “background” 集中移除属性 <em>attr</em>。</p>
<p><code>window.attron</code>(<em>attr</em>)</p>
<p>向应用于写入到当前窗口的 “background” 集中添加属性 <em>attr</em>。</p>
<p><code>window.attrset</code>(<em>attr</em>)</p>
<p>将 “background” 属性集设为 <em>attr</em>。 该集合初始时为 <code>0</code> (无属性)。</p>
<p><code>window.bkgd</code>(<em>ch</em>[, <em>attr</em>])</p>
<p>将窗口 background 特征属性设为带有属性 <em>attr</em> 的字符 <em>ch</em>。 随后此修改将应用于放置到该窗口中的每个字符。</p>
<ul>
<li>窗口中每个字符的属性会被修改为新的 background 属性。</li>
<li>不论之前的 background 字符出现在哪里，它都会被修改为新的 background 字符。</li>
</ul>
<p><code>window.bkgdset</code>(<em>ch</em>[, <em>attr</em>])</p>
<p>设置窗口的背景。 窗口的背景由字符和属性的任意组合构成。 背景的属性部分会与写入窗口的所有非空白字符合并（即 OR 运算）。 背景和字符和属性部分均会与空白字符合并。 背景将成为字符的特征属性并在任何滚动与插入/删除行/字符操作中与字符一起移动。</p>
<p><code>window.border</code>([<em>ls</em>[, <em>rs</em>[, <em>ts</em>[, <em>bs</em>[, <em>tl</em>[, <em>tr</em>[, <em>bl</em>[, <em>br</em>]]]]]]]])</p>
<p>在窗口边缘绘制边框。每个参数指定用于边界特定部分的字符;请参阅下表了解更多详情。</p>
<p>注解</p>
<p>任何形参的值为 <code>0</code> 都将导致该形参使用默认字符。 关键字形参 <em>不可</em> 被使用。 默认字符在下表中列出:</p>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">描述</th>
<th align="left">默认值</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><em>ls</em></td>
<td align="left">左侧</td>
<td align="left"><code>ACS_VLINE</code></td>
</tr>
<tr>
<td align="left"><em>rs</em></td>
<td align="left">右侧</td>
<td align="left"><code>ACS_VLINE</code></td>
</tr>
<tr>
<td align="left"><em>ts</em></td>
<td align="left">顶部</td>
<td align="left"><code>ACS_HLINE</code></td>
</tr>
<tr>
<td align="left"><em>bs</em></td>
<td align="left">底部</td>
<td align="left"><code>ACS_HLINE</code></td>
</tr>
<tr>
<td align="left"><em>tl</em></td>
<td align="left">左上角</td>
<td align="left"><code>ACS_ULCORNER</code></td>
</tr>
<tr>
<td align="left"><em>tr</em></td>
<td align="left">右上角</td>
<td align="left"><code>ACS_URCORNER</code></td>
</tr>
<tr>
<td align="left"><em>bl</em></td>
<td align="left">左下角</td>
<td align="left"><code>ACS_LLCORNER</code></td>
</tr>
<tr>
<td align="left"><em>br</em></td>
<td align="left">右下角</td>
<td align="left"><code>ACS_LRCORNER</code></td>
</tr>
</tbody></table>
<p><code>window.box</code>([<em>vertch</em>, <em>horch</em>])</p>
<p>类似于 <code>border()</code>，但 <em>ls</em> 和 <em>rs</em> 均为 <em>vertch</em> 而 <em>ts</em> 和 <em>bs</em> 均为 <em>horch</em>。 此函数总是会使用默认的转角字符。</p>
<p><code>window.chgat</code>(<em>attr</em>)</p>
<p><code>window.chgat</code>(<em>num</em>, <em>attr</em>)</p>
<p><code>window.chgat</code>(<em>y</em>, <em>x</em>, <em>attr</em>)</p>
<p><code>window.chgat</code>(<em>y</em>, <em>x</em>, <em>num</em>, <em>attr</em>)</p>
<p>在当前光标位置或是在所提供的位置 <code>(y, x)</code> 设置 <em>num</em> 个字符的属性。 如果 <em>num</em> 未给出或为 <code>-1</code>，则将属性设置到所有字符上直至行尾。 如果提供了位置 <code>(y, x)</code> 则此函数会将光标移至该位置。 修改过的行将使用 <code>touchline()</code> 方法处理以便下次窗口刷新时内容会重新显示。</p>
<p><code>window.clear</code>()</p>
<p>类似于 <code>erase()</code>，但还会导致在下次调用 <code>refresh()</code> 时整个窗口被重新绘制。</p>
<p><code>window.clearok</code>(<em>flag</em>)</p>
<p>如果 <em>flag</em> 为 <code>True</code>，则在下次调用 <code>refresh()</code> 时将完全清除窗口。</p>
<p><code>window.clrtobot</code>()</p>
<p>从光标位置开始擦除直至窗口末端：光标以下的所有行都会被删除，然后会执行 <code>clrtoeol()</code> 的等效操作。</p>
<p><code>window.clrtoeol</code>()</p>
<p>从光标位置开始擦除直至行尾。</p>
<p><code>window.cursyncup</code>()</p>
<p>更新窗口所有上级窗口的当前光标位置以反映窗口的当前光标位置。</p>
<p><code>window.delch</code>([<em>y</em>, <em>x</em>])</p>
<p>删除位于 <code>(y, x)</code> 的任何字符。</p>
<p><code>window.deleteln</code>()</p>
<p>删除在光标之下的行。 所有后续的行都会上移一行。</p>
<p><code>window.derwin</code>(<em>begin_y</em>, <em>begin_x</em>)</p>
<p><code>window.derwin</code>(<em>nlines</em>, <em>ncols</em>, <em>begin_y</em>, <em>begin_x</em>)</p>
<p>“derive window” 的缩写，<code>derw</code></p>
<p><code>in()</code> 与调用 <code>subwin()</code> 等效，不同之处在于 <em>begin_y</em> 和 <em>begin_x</em> 是想对于窗口的初始位置，而不是相对于整个屏幕。 返回代表所派生窗口的窗口对象。</p>
<p><code>window.echochar</code>(<em>ch</em>[, <em>attr</em>])</p>
<p>使用属性 <em>attr</em> 添加字符 <em>ch</em>，并立即在窗口上调用 <code>refresh()</code>。</p>
<p><code>window.enclose</code>(<em>y</em>, <em>x</em>)</p>
<p>检测给定的相对屏幕的字符-单元格坐标是否被给定的窗口所包围，返回 <code>True</code> 或 <code>False</code>。 它适用于确定是哪个屏幕窗口子集包围着某个鼠标事件的位置。</p>
<p>在 3.10 版更改: 在之前版本中它会返回 <code>1</code> 或 <code>0</code> 而不是 <code>True</code> 或 <code>False</code>。</p>
<pre><code>window.encoding</code></pre><p>用于编码方法参数（Unicode 字符串和字符）的编码格式。 encoding 属性是在创建子窗口时从父窗口继承的，例如通过 <code>window.subwin()</code>。 默认情况下，会使用当前区域的编码格式 。</p>
<p>3.3 新版功能.</p>
<p><code>window.erase</code>()</p>
<p>清空窗口。</p>
<p><code>window.getbegyx</code>()</p>
<p>返回左上角坐标的元组 <code>(y, x)</code>。</p>
<p><code>window.getbkgd</code>()</p>
<p>返回给定窗口的当前背景字符/属性对。</p>
<p><code>window.getch</code>([<em>y</em>, <em>x</em>])</p>
<p>获取一个字符。 请注意所返回的整数 <em>不一定</em> 要在 ASCII 范围以内：功能键、小键盘键等等是由大于 255 的数字表示的。 在无延迟模式下，如果没有输入则返回 <code>-1</code>，在其他情况下都会等待直至有键被按下。</p>
<p><code>window.get_wch</code>([<em>y</em>, <em>x</em>])</p>
<p>获取一个宽字符。 对于大多数键都是返回一个字符，对于功能键、小键盘键和其他特殊键则是返回一个整数。 在无延迟模式下，如果没有输入则引发一个异常。</p>
<p>3.3 新版功能.</p>
<p><code>window.getkey</code>([<em>y</em>, <em>x</em>])</p>
<p>获取一个字符，返回一个字符串而不是像 <code>getch()</code> 那样返回一个整数。 功能键、小键盘键和其他特殊键则是返回一个包含键名的多字节字符串。 在无延迟模式下，如果没有输入则引发一个异常。</p>
<p><code>window.getmaxyx</code>()</p>
<p>返回窗口高度和宽度的元组 <code>(y, x)</code>。</p>
<p><code>window.getparyx</code>()</p>
<p>将此窗口相对于父窗口的起始坐标作为元组 <code>(y, x)</code> 返回。 如果此窗口没有父窗口则返回 <code>(-1, -1)</code>。</p>
<p><code>window.getstr</code>()</p>
<p><code>window.getstr</code>(<em>n</em>)</p>
<p><code>window.getstr</code>(<em>y</em>, <em>x</em>)</p>
<p><code>window.getstr</code>(<em>y</em>, <em>x</em>, <em>n</em>)</p>
<p>从用户读取一个字节串对象，附带基本的行编辑功能。</p>
<p><code>window.getyx</code>()</p>
<p>返回当前光标相对于窗口左上角的位置的元组 <code>(y, x)</code>。</p>
<p><code>window.hline</code>(<em>ch</em>, <em>n</em>)</p>
<p><code>window.hline</code>(<em>y</em>, <em>x</em>, <em>ch</em>, <em>n</em>)</p>
<p>显示一条起始于 <code>(y, x)</code> 长度为 <em>n</em> 个字符 <em>ch</em> 的水平线。</p>
<p><code>window.idcok</code>(<em>flag</em>)</p>
<p>如果 <em>flag</em> 为 <code>False</code>，curses 将不再考虑使用终端的硬件插入/删除字符功能；如果 <em>flag</em> 为 <code>True</code>，则会启用字符插入和删除。 当 curses 首次初始化时，默认会启用字符插入/删除。</p>
<p><code>window.idlok</code>(<em>flag</em>)</p>
<p>如果 <em>flag</em> 为 <code>True</code>，<code>curses</code> 将尝试使用硬件行编辑功能。 否则，行插入/删除会被禁用。</p>
<p><code>window.immedok</code>(<em>flag</em>)</p>
<p>如果 <em>flag</em> 为 <code>True</code>，窗口图像中的任何改变都会自动导致窗口被刷新；你不必再自己调用 <code>refresh()</code>。 但是，这可能会由于重复调用 wrefresh 而显著降低性能。 此选项默认被禁用。</p>
<p><code>window.inch</code>([<em>y</em>, <em>x</em>])</p>
<p>返回窗口中给定位置上的字符。 下面的 8 个比特位是字符本身，上面的比特位则为属性。</p>
<p><code>window.insch</code>(<em>ch</em>[, <em>attr</em>])</p>
<p><code>window.insch</code>(<em>y</em>, <em>x</em>, <em>ch</em>[, <em>attr</em>])</p>
<p>将带有属性 <em>attr</em> 的字符 <em>ch</em> 绘制到 <code>(y, x)</code>，将该行从位置 <em>x</em> 开始右移一个字符。</p>
<p><code>window.insdelln</code>(<em>nlines</em>)</p>
<p>在指定窗口的当前行上方插入 <em>nlines</em> 行。 下面的 <em>nlines</em> 行将丢失。 对于 <em>nlines</em> 为负值的情况，则从光标下方的行开始删除 <em>nlines</em> 行，并将其余的行向上移动。 下面的 <em>nlines</em> 行会被清空。 当前光标位置将保持不变。</p>
<p><code>window.insertln</code>()</p>
<p>在光标下方插入一个空行。 所有后续的行都会下移一行。</p>
<p><code>window.insnstr</code>(<em>str</em>, <em>n</em>[, <em>attr</em>])</p>
<p><code>window.insnstr</code>(<em>y</em>, <em>x</em>, <em>str</em>, <em>n</em>[, <em>attr</em>])</p>
<p>在光标下方的字符之前插入一个至多为 <em>n</em> 个字符的字符串（字符数量将与该行相匹配）。 如果 <em>n</em> 为零或负数，则插入整个字符串。 光标右边的所有字符将被右移，该行右端的字符将丢失。 光标位置将保持不变（在移到可能指定的 <em>y</em>, <em>x</em> 之后）。</p>
<p><code>window.insstr</code>(<em>str</em>[, <em>attr</em>])</p>
<p><code>window.insstr</code>(<em>y</em>, <em>x</em>, <em>str</em>[, <em>attr</em>])</p>
<p>在光标下方的字符之前插入一个字符串（字符数量将与该行相匹配）。 光标右边的所有字符将被右移，该行右端的字符将丢失。 光标位置将保持不变（在移到可能指定的 <em>y</em>, <em>x</em> 之后）。</p>
<p><code>window.instr</code>([<em>n</em>])</p>
<p><code>window.instr</code>(<em>y</em>, <em>x</em>[, <em>n</em>])</p>
<p>返回从窗口的当前光标位置，或者指定的 <em>y</em>, <em>x</em> 开始提取的字符所对应的字节串对象。 属性会从字符中去除。 如果指定了 <em>n</em>，<code>instr()</code> 将返回长度至多为 <em>n</em> 个字符的字符串（不包括末尾的 NUL）。</p>
<p><code>window.is_linetouched</code>(<em>line</em>)</p>
<p>如果指定的行自上次调用 <code>refresh()</code> 后发生了改变则返回 <code>True</code>；否则返回 <code>False</code>。 如果 <em>line</em> 对于给定的窗口不可用则会引发 <code>curses.error</code> 异常。</p>
<p><code>window.is_wintouched</code>()</p>
<p>如果指定的窗口自上次调用 <code>refresh()</code> 后发生了改变则返回 <code>True</code>；否则返回 <code>False</code>。</p>
<p><code>window.keypad</code>(<em>flag</em>)</p>
<p>如果 <em>flag</em> 为 <code>True</code>，则某些键（小键盘键、功能键等）生成的转义序列将由 <code>curses</code> 来解析。 如果 <em>flag</em> 为 <code>False</code>，转义序列将保持在输入流中的原样。</p>
<p><code>window.leaveok</code>(<em>flag</em>)</p>
<p>如果 <em>flag</em> 为 <code>True</code>，则在更新时光标将停留在原地，而不是在“光标位置”。 这将可以减少光标的移动。 在可能的情况下光标将变为不可见。</p>
<p>如果 <em>flag</em> 为 <code>False</code>，光标在更新后将总是位于“光标位置”。</p>
<p><code>window.move</code>(<em>new_y</em>, <em>new_x</em>)</p>
<p>将光标移至 <code>(new_y, new_x)</code>。</p>
<p><code>window.mvderwin</code>(<em>y</em>, <em>x</em>)</p>
<p>让窗口在其父窗口内移动。 窗口相对于屏幕的参数不会被更改。 此例程用于在屏幕的相同物理位置显示父窗口的不同部分。</p>
<p><code>window.mvwin</code>(<em>new_y</em>, <em>new_x</em>)</p>
<p>移动窗口以使其左上角位于 <code>(new_y, new_x)</code>。</p>
<p><code>window.nodelay</code>(<em>flag</em>)</p>
<p>如果 <em>flag</em> 为 <code>True</code>，则 <code>getch()</code> 将为非阻塞的。</p>
<p><code>window.notimeout</code>(<em>flag</em>)</p>
<p>如果 <em>flag</em> 为 <code>True</code>，则转义序列将不会发生超时。</p>
<p>如果 <em>flag</em> 为 <code>False</code>，则在几毫秒之后，转义序列将不会被解析，并将保持在输入流中的原样。</p>
<p><code>window.noutrefresh</code>()</p>
<p>标记为刷新但保持等待。 此函数会更新代表预期窗口状态的数据结构，但并不强制更新物理屏幕。 要完成后者，请调用 <code>doupdate()</code>。</p>
<p><code>window.overlay</code>(<em>destwin</em>[, <em>sminrow</em>, <em>smincol</em>, <em>dminrow</em>, <em>dmincol</em>, <em>dmaxrow</em>, <em>dmaxcol</em>])</p>
<p>将窗口覆盖在 <em>destwin</em> 上方。 窗口的大小不必相同，只有重叠的区域会被复制。 此复制是非破坏性的，这意味着当前背景字符不会覆盖掉 <em>destwin</em> 的旧内容。</p>
<p>为了获得对被复制区域的细粒度控制，可以使用 <code>overlay()</code> 的第二种形式。 <em>sminrow</em> 和 <em>smincol</em> 是源窗口的左上角坐标，而其他变量则在目标窗口中标记出一个矩形。</p>
<p><code>window.overwrite</code>(<em>destwin</em>[, <em>sminrow</em>, <em>smincol</em>, <em>dminrow</em>, <em>dmincol</em>, <em>dmaxrow</em>, <em>dmaxcol</em>])</p>
<p>将窗口覆盖在 <em>destwin</em> 上方。 窗口的大小不必相同，此时只有重叠的区域会被复制。 此复制是破坏性的，这意味着当前背景字符会覆盖掉 <em>destwin</em> 的旧内容。</p>
<p>为了获得对被复制区域的细粒度控制，可以使用 <code>overwrite()</code> 的第二种形式。 <em>sminrow</em> 和 <em>smincol</em> 是源窗口的左上角坐标，而其他变量则在目标窗口中标记出一个矩形。</p>
<p><code>window.putwin</code>(<em>file</em>)</p>
<p>将关联到窗口的所有数据写入到所提供的文件对象。 此信息可在以后使用 <code>getwin()</code> 函数来提取。</p>
<p><code>window.redrawln</code>(<em>beg</em>, <em>num</em>)</p>
<p>指明从 <em>beg</em> 行开始的 <em>num</em> 个屏幕行已被破坏并且应当在下次 <code>refresh()</code> 调用时完全重绘。</p>
<p><code>window.redrawwin</code>()</p>
<p>触碰整个窗口，以使其在下次 <code>refresh()</code> 调用时完全重绘。</p>
<p><code>window.refresh</code>([<em>pminrow</em>, <em>pmincol</em>, <em>sminrow</em>, <em>smincol</em>, <em>smaxrow</em>, <em>smaxcol</em>])</p>
<p>立即更新显示（将实际屏幕与之前的绘制/删除方法进行同步）。</p>
<p>6 个可选参数仅在窗口为使用 <code>newpad()</code> 创建的面板时可被指定。 需要额外的形参来指定所涉及到的是面板和屏幕的哪一部分。 <em>pminrow</em> 和 <em>pmincol</em> 指定要在面板中显示的矩形的左上角。 <em>sminrow</em>, <em>smincol</em>, <em>smaxrow</em> 和 <em>smaxcol</em> 指定要在屏幕中显示的矩形的边。 要在面板中显示的矩形的右下角是根据屏幕坐标计算出来的，由于矩形的大小必须相同。 两个矩形都必须完全包含在其各自的结构之内。 负的 <em>pminrow</em>, <em>pmincol</em>, <em>sminrow</em> 或 <em>smincol</em> 值会被视为将它们设为零值。</p>
<p><code>window.resize</code>(<em>nlines</em>, <em>ncols</em>)</p>
<p>为 curses 窗口重新分配存储空间以将其尺寸调整为指定的值。 如果任一维度的尺寸大于当前值，则窗口的数据将以具有合并了当前背景渲染（由 <code>bkgdset()</code> 设置）的空白来填充。</p>
<p><code>window.scroll</code>([<em>lines=1</em>])</p>
<p>将屏幕或滚动区域向上滚动 <em>lines</em> 行。</p>
<p><code>window.scrollok</code>(<em>flag</em>)</p>
<p>控制当一个窗口的光标移出窗口或滚动区域边缘时会发生什么，这可能是在底端行执行换行操作，或者在最后一行输入最后一个字符导致的结果。 如果 <em>flag</em> 为 <code>False</code>，光标会留在底端行。 如果 <em>flag</em> 为 <code>True</code>，窗口会向上滚动一行。 请注意为了在终端上获得实际的滚动效果，还需要调用 <code>idlok()</code>。</p>
<p><code>window.setscrreg</code>(<em>top</em>, <em>bottom</em>)</p>
<p>设置从 <em>top</em> 行至 <em>bottom</em> 行的滚动区域。 所有滚动操作将在此区域中进行。</p>
<p><code>window.standend</code>()</p>
<p>关闭 standout 属性。 在某些终端上此操作会有关闭所有属性的副作用。</p>
<p><code>window.standout</code>()</p>
<p>启用属性 <em>A_STANDOUT</em>。</p>
<p><code>window.subpad</code>(<em>begin_y</em>, <em>begin_x</em>)</p>
<p><code>window.subpad</code>(<em>nlines</em>, <em>ncols</em>, <em>begin_y</em>, <em>begin_x</em>)</p>
<p>返回一个子窗口，其左上角位于 <code>(begin_y, begin_x)</code>，并且其宽度/高度为 <em>ncols</em>/<em>nlines</em>。</p>
<p><code>window.subwin</code>(<em>begin_y</em>, <em>begin_x</em>)</p>
<p><code>window.subwin</code>(<em>nlines</em>, <em>ncols</em>, <em>begin_y</em>, <em>begin_x</em>)</p>
<p>返回一个子窗口，其左上角位于 <code>(begin_y, begin_x)</code>，并且其宽度/高度为 <em>ncols</em>/<em>nlines</em>。</p>
<p>默认情况下，子窗口将从指定位置扩展到窗口的右下角。</p>
<p><code>window.syncdown</code>()</p>
<p>触碰已在上级窗口上被触碰的每个位置。 此例程由 <code>refresh()</code> 调用，因此几乎从不需要手动调用。</p>
<p><code>window.syncok</code>(<em>flag</em>)</p>
<p>如果 <em>flag</em> 为 <code>True</code>，则 <code>syncup()</code> 会在窗口发生改变的任何时候自动被调用。</p>
<p><code>window.syncup</code>()</p>
<p>触碰已在窗口中被改变的此窗口的各个上级窗口中的所有位置。</p>
<p><code>window.timeout</code>(<em>delay</em>)</p>
<p>为窗口设置阻塞或非阻塞读取行为。 如果 <em>delay</em> 为负值，则会使用阻塞读取（这将无限期地等待输入）。 如果 <em>delay</em> 为零，则会使用非阻塞读取，并且当没有输入在等待时 <code>getch()</code> 将返回 <code>-1</code>。 如果 <em>delay</em> 为正值，则 <code>getch()</code> 将阻塞 <em>delay</em> 毫秒，并且当此延时结束时仍无输入将返回 <code>-1</code>。</p>
<p><code>window.touchline</code>(<em>start</em>, <em>count</em>[, <em>changed</em>])</p>
<p>假定从行 <em>start</em> 开始的 <em>count</em> 行已被更改。 如果提供了 <em>changed</em>，它将指明是将受影响的行标记为已更改 (<em>changed</em><code>=True</code>) 还是未更改 (<em>changed</em><code>=False</code>)。</p>
<p><code>window.touchwin</code>()</p>
<p>假定整个窗口已被更改，其目的是用于绘制优化。</p>
<p><code>window.untouchwin</code>()</p>
<p>将自上次调用 <code>refresh()</code> 以来窗口中的所有行标记为未改变。</p>
<p><code>window.vline</code>(<em>ch</em>, <em>n</em>)</p>
<p><code>window.vline</code>(<em>y</em>, <em>x</em>, <em>ch</em>, <em>n</em>)</p>
<p>显示一条起始于 <code>(y, x)</code> 长度为 <em>n</em> 个字符 <em>ch</em> 的垂直线。</p>
<h3 id="常量-1"><a href="#常量-1" class="headerlink" title="常量"></a>常量</h3><p><code>curses</code> 模块定义了以下数据成员:</p>
<pre><code>curses.ERR</code></pre><p>一些返回整数的 curses 例程，例如 <code>getch()</code>，在失败时将返回 <code>ERR</code>。</p>
<pre><code>curses.OK</code></pre><p>一些返回整数的 curses 例程，例如 <code>napms()</code>，在成功时将返回 <code>OK</code>。</p>
<pre><code>curses.version</code></pre><p>一个代表当前模块版本的字节串对象。 也作 <code>__version__</code>。</p>
<pre><code>curses.ncurses_version</code></pre><p>一个具名元组，它包含构成 ncurses 库版本号的三个数字: <em>major</em>, <em>minor</em> 和 <em>patch</em>。 三个值均为整数。 三个值也可通过名称来访问，因此 <code>curses.ncurses_version[0]</code> 等价于 <code>curses.ncurses_version.major</code>，依此类推。</p>
<p>可用性：如果使用了 ncurses 库。</p>
<p>3.8 新版功能.</p>
<p>有些常量可用于指定字符单元属性。 实际可用的常量取决于具体的系统。</p>
<table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">含意</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>A_ALTCHARSET</code></td>
<td align="left">备用字符集模式</td>
</tr>
<tr>
<td align="left"><code>A_BLINK</code></td>
<td align="left">闪烁模式</td>
</tr>
<tr>
<td align="left"><code>A_BOLD</code></td>
<td align="left">粗体模式</td>
</tr>
<tr>
<td align="left"><code>A_DIM</code></td>
<td align="left">暗淡模式</td>
</tr>
<tr>
<td align="left"><code>A_INVIS</code></td>
<td align="left">不可见或空白模式</td>
</tr>
<tr>
<td align="left"><code>A_ITALIC</code></td>
<td align="left">斜体模式</td>
</tr>
<tr>
<td align="left"><code>A_NORMAL</code></td>
<td align="left">正常属性</td>
</tr>
<tr>
<td align="left"><code>A_PROTECT</code></td>
<td align="left">保护模式</td>
</tr>
<tr>
<td align="left"><code>A_REVERSE</code></td>
<td align="left">反转背景色和前景色</td>
</tr>
<tr>
<td align="left"><code>A_STANDOUT</code></td>
<td align="left">突出模式</td>
</tr>
<tr>
<td align="left"><code>A_UNDERLINE</code></td>
<td align="left">下划线模式</td>
</tr>
<tr>
<td align="left"><code>A_HORIZONTAL</code></td>
<td align="left">水平突出显示</td>
</tr>
<tr>
<td align="left"><code>A_LEFT</code></td>
<td align="left">左高亮</td>
</tr>
<tr>
<td align="left"><code>A_LOW</code></td>
<td align="left">底部高亮</td>
</tr>
<tr>
<td align="left"><code>A_RIGHT</code></td>
<td align="left">右高亮</td>
</tr>
<tr>
<td align="left"><code>A_TOP</code></td>
<td align="left">顶部高亮</td>
</tr>
<tr>
<td align="left"><code>A_VERTICAL</code></td>
<td align="left">垂直突出显示</td>
</tr>
<tr>
<td align="left"><code>A_CHARTEXT</code></td>
<td align="left">用于提取字符的位掩码</td>
</tr>
</tbody></table>
<p>3.7 新版功能: <code>A_ITALIC</code> was added.</p>
<p>有几个常量可用于提取某些方法返回的相应属性。</p>
<table>
<thead>
<tr>
<th align="left">位掩码</th>
<th align="left">含意</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>A_ATTRIBUTES</code></td>
<td align="left">用于提取属性的位掩码</td>
</tr>
<tr>
<td align="left"><code>A_CHARTEXT</code></td>
<td align="left">用于提取字符的位掩码</td>
</tr>
<tr>
<td align="left"><code>A_COLOR</code></td>
<td align="left">用于提取颜色对字段信息的位掩码</td>
</tr>
</tbody></table>
<p>键由名称以 <code>KEY_</code> 开头的整数常量引用。确切的可用键取决于系统。</p>
<table>
<thead>
<tr>
<th align="left">关键常数</th>
<th align="left">键</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>KEY_MIN</code></td>
<td align="left">最小键值</td>
</tr>
<tr>
<td align="left"><code>KEY_BREAK</code></td>
<td align="left">中断键（不可靠）</td>
</tr>
<tr>
<td align="left"><code>KEY_DOWN</code></td>
<td align="left">向下箭头</td>
</tr>
<tr>
<td align="left"><code>KEY_UP</code></td>
<td align="left">向上箭头</td>
</tr>
<tr>
<td align="left"><code>KEY_LEFT</code></td>
<td align="left">向左箭头</td>
</tr>
<tr>
<td align="left"><code>KEY_RIGHT</code></td>
<td align="left">向右箭头</td>
</tr>
<tr>
<td align="left"><code>KEY_HOME</code></td>
<td align="left">Home 键 (上+左箭头)</td>
</tr>
<tr>
<td align="left"><code>KEY_BACKSPACE</code></td>
<td align="left">退格（不可靠）</td>
</tr>
<tr>
<td align="left"><code>KEY_F0</code></td>
<td align="left">功能键。 支持至多 64 个功能键。</td>
</tr>
<tr>
<td align="left"><code>KEY_Fn</code></td>
<td align="left">功能键 <em>n</em> 的值</td>
</tr>
<tr>
<td align="left"><code>KEY_DL</code></td>
<td align="left">删除行</td>
</tr>
<tr>
<td align="left"><code>KEY_IL</code></td>
<td align="left">插入行</td>
</tr>
<tr>
<td align="left"><code>KEY_DC</code></td>
<td align="left">删除字符</td>
</tr>
<tr>
<td align="left"><code>KEY_IC</code></td>
<td align="left">插入字符或进入插入模式</td>
</tr>
<tr>
<td align="left"><code>KEY_EIC</code></td>
<td align="left">退出插入字符模式</td>
</tr>
<tr>
<td align="left"><code>KEY_CLEAR</code></td>
<td align="left">清空屏幕</td>
</tr>
<tr>
<td align="left"><code>KEY_EOS</code></td>
<td align="left">清空至屏幕底部</td>
</tr>
<tr>
<td align="left"><code>KEY_EOL</code></td>
<td align="left">清空至行尾</td>
</tr>
<tr>
<td align="left"><code>KEY_SF</code></td>
<td align="left">向前滚动 1 行</td>
</tr>
<tr>
<td align="left"><code>KEY_SR</code></td>
<td align="left">向后滚动 1 行 (反转)</td>
</tr>
<tr>
<td align="left"><code>KEY_NPAGE</code></td>
<td align="left">下一页</td>
</tr>
<tr>
<td align="left"><code>KEY_PPAGE</code></td>
<td align="left">上一页</td>
</tr>
<tr>
<td align="left"><code>KEY_STAB</code></td>
<td align="left">设置制表符</td>
</tr>
<tr>
<td align="left"><code>KEY_CTAB</code></td>
<td align="left">清除制表符</td>
</tr>
<tr>
<td align="left"><code>KEY_CATAB</code></td>
<td align="left">清除所有制表符</td>
</tr>
<tr>
<td align="left"><code>KEY_ENTER</code></td>
<td align="left">回车或发送 (不可靠)</td>
</tr>
<tr>
<td align="left"><code>KEY_SRESET</code></td>
<td align="left">软 (部分) 重置 (不可靠)</td>
</tr>
<tr>
<td align="left"><code>KEY_RESET</code></td>
<td align="left">重置或硬重置 (不可靠)</td>
</tr>
<tr>
<td align="left"><code>KEY_PRINT</code></td>
<td align="left">打印</td>
</tr>
<tr>
<td align="left"><code>KEY_LL</code></td>
<td align="left">Home 向下或到底 (左下)</td>
</tr>
<tr>
<td align="left"><code>KEY_A1</code></td>
<td align="left">键盘的左上角</td>
</tr>
<tr>
<td align="left"><code>KEY_A3</code></td>
<td align="left">键盘的右上角</td>
</tr>
<tr>
<td align="left"><code>KEY_B2</code></td>
<td align="left">键盘的中心</td>
</tr>
<tr>
<td align="left"><code>KEY_C1</code></td>
<td align="left">键盘左下方</td>
</tr>
<tr>
<td align="left"><code>KEY_C3</code></td>
<td align="left">键盘右下方</td>
</tr>
<tr>
<td align="left"><code>KEY_BTAB</code></td>
<td align="left">回退制表符</td>
</tr>
<tr>
<td align="left"><code>KEY_BEG</code></td>
<td align="left">Beg (开始)</td>
</tr>
<tr>
<td align="left"><code>KEY_CANCEL</code></td>
<td align="left">取消</td>
</tr>
<tr>
<td align="left"><code>KEY_CLOSE</code></td>
<td align="left">关闭</td>
</tr>
<tr>
<td align="left"><code>KEY_COMMAND</code></td>
<td align="left">Cmd (命令行)</td>
</tr>
<tr>
<td align="left"><code>KEY_COPY</code></td>
<td align="left">复制</td>
</tr>
<tr>
<td align="left"><code>KEY_CREATE</code></td>
<td align="left">创建</td>
</tr>
<tr>
<td align="left"><code>KEY_END</code></td>
<td align="left">End</td>
</tr>
<tr>
<td align="left"><code>KEY_EXIT</code></td>
<td align="left">退出</td>
</tr>
<tr>
<td align="left"><code>KEY_FIND</code></td>
<td align="left">查找</td>
</tr>
<tr>
<td align="left"><code>KEY_HELP</code></td>
<td align="left">帮助</td>
</tr>
<tr>
<td align="left"><code>KEY_MARK</code></td>
<td align="left">标记</td>
</tr>
<tr>
<td align="left"><code>KEY_MESSAGE</code></td>
<td align="left">消息</td>
</tr>
<tr>
<td align="left"><code>KEY_MOVE</code></td>
<td align="left">移动</td>
</tr>
<tr>
<td align="left"><code>KEY_NEXT</code></td>
<td align="left">下一个</td>
</tr>
<tr>
<td align="left"><code>KEY_OPEN</code></td>
<td align="left">打开</td>
</tr>
<tr>
<td align="left"><code>KEY_OPTIONS</code></td>
<td align="left">选项</td>
</tr>
<tr>
<td align="left"><code>KEY_PREVIOUS</code></td>
<td align="left">Prev (上一个)</td>
</tr>
<tr>
<td align="left"><code>KEY_REDO</code></td>
<td align="left">重做</td>
</tr>
<tr>
<td align="left"><code>KEY_REFERENCE</code></td>
<td align="left">Ref (引用)</td>
</tr>
<tr>
<td align="left"><code>KEY_REFRESH</code></td>
<td align="left">刷新</td>
</tr>
<tr>
<td align="left"><code>KEY_REPLACE</code></td>
<td align="left">替换</td>
</tr>
<tr>
<td align="left"><code>KEY_RESTART</code></td>
<td align="left">重启</td>
</tr>
<tr>
<td align="left"><code>KEY_RESUME</code></td>
<td align="left">恢复</td>
</tr>
<tr>
<td align="left"><code>KEY_SAVE</code></td>
<td align="left">保存</td>
</tr>
<tr>
<td align="left"><code>KEY_SBEG</code></td>
<td align="left">Shift + Beg (开始)</td>
</tr>
<tr>
<td align="left"><code>KEY_SCANCEL</code></td>
<td align="left">Shift + Cancel</td>
</tr>
<tr>
<td align="left"><code>KEY_SCOMMAND</code></td>
<td align="left">Shift + Command</td>
</tr>
<tr>
<td align="left"><code>KEY_SCOPY</code></td>
<td align="left">Shift + Copy</td>
</tr>
<tr>
<td align="left"><code>KEY_SCREATE</code></td>
<td align="left">Shift + Create</td>
</tr>
<tr>
<td align="left"><code>KEY_SDC</code></td>
<td align="left">Shift + 删除字符</td>
</tr>
<tr>
<td align="left"><code>KEY_SDL</code></td>
<td align="left">Shift + 删除行</td>
</tr>
<tr>
<td align="left"><code>KEY_SELECT</code></td>
<td align="left">选择</td>
</tr>
<tr>
<td align="left"><code>KEY_SEND</code></td>
<td align="left">Shift + End</td>
</tr>
<tr>
<td align="left"><code>KEY_SEOL</code></td>
<td align="left">Shift + 清空行</td>
</tr>
<tr>
<td align="left"><code>KEY_SEXIT</code></td>
<td align="left">Shift + 退出</td>
</tr>
<tr>
<td align="left"><code>KEY_SFIND</code></td>
<td align="left">Shift + 查找</td>
</tr>
<tr>
<td align="left"><code>KEY_SHELP</code></td>
<td align="left">Shift + 帮助</td>
</tr>
<tr>
<td align="left"><code>KEY_SHOME</code></td>
<td align="left">Shift + Home</td>
</tr>
<tr>
<td align="left"><code>KEY_SIC</code></td>
<td align="left">Shift + 输入</td>
</tr>
<tr>
<td align="left"><code>KEY_SLEFT</code></td>
<td align="left">Shift + 向左箭头</td>
</tr>
<tr>
<td align="left"><code>KEY_SMESSAGE</code></td>
<td align="left">Shift + 消息</td>
</tr>
<tr>
<td align="left"><code>KEY_SMOVE</code></td>
<td align="left">Shift + 移动</td>
</tr>
<tr>
<td align="left"><code>KEY_SNEXT</code></td>
<td align="left">Shift + 下一个</td>
</tr>
<tr>
<td align="left"><code>KEY_SOPTIONS</code></td>
<td align="left">Shift + 选项</td>
</tr>
<tr>
<td align="left"><code>KEY_SPREVIOUS</code></td>
<td align="left">Shift + 上一个</td>
</tr>
<tr>
<td align="left"><code>KEY_SPRINT</code></td>
<td align="left">Shift + 打印</td>
</tr>
<tr>
<td align="left"><code>KEY_SREDO</code></td>
<td align="left">Shift + 重做</td>
</tr>
<tr>
<td align="left"><code>KEY_SREPLACE</code></td>
<td align="left">Shift + 替换</td>
</tr>
<tr>
<td align="left"><code>KEY_SRIGHT</code></td>
<td align="left">Shift + 向右箭头</td>
</tr>
<tr>
<td align="left"><code>KEY_SRSUME</code></td>
<td align="left">Shift + 恢复</td>
</tr>
<tr>
<td align="left"><code>KEY_SSAVE</code></td>
<td align="left">Shift + 保存</td>
</tr>
<tr>
<td align="left"><code>KEY_SSUSPEND</code></td>
<td align="left">Shift + 挂起</td>
</tr>
<tr>
<td align="left"><code>KEY_SUNDO</code></td>
<td align="left">Shift + 撤销</td>
</tr>
<tr>
<td align="left"><code>KEY_SUSPEND</code></td>
<td align="left">挂起</td>
</tr>
<tr>
<td align="left"><code>KEY_UNDO</code></td>
<td align="left">撤销操作</td>
</tr>
<tr>
<td align="left"><code>KEY_MOUSE</code></td>
<td align="left">鼠标事件已发生</td>
</tr>
<tr>
<td align="left"><code>KEY_RESIZE</code></td>
<td align="left">终端大小改变事件</td>
</tr>
<tr>
<td align="left"><code>KEY_MAX</code></td>
<td align="left">最大键值</td>
</tr>
</tbody></table>
<p>在VT100及其软件仿真（例如X终端仿真器）上，通常至少有四个功能键（ <code>KEY_F1</code>, <code>KEY_F2</code>, <code>KEY_F3</code>, <code>KEY_F4</code> ）可用，并且箭头键以明显的方式映射到 <code>KEY_UP</code>, <code>KEY_DOWN</code>, <code>KEY_LEFT</code> 和 <code>KEY_RIGHT</code> 。如果您的机器有一个PC键盘，可以安全地使用箭头键和十二个功能键（旧的PC键盘可能只有十个功能键）;此外，以下键盘映射是标准的：</p>
<table>
<thead>
<tr>
<th align="left">键帽</th>
<th align="left">常量</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Insert</td>
<td align="left">KEY_IC</td>
</tr>
<tr>
<td align="left">Delete</td>
<td align="left">KEY_DC</td>
</tr>
<tr>
<td align="left">Home</td>
<td align="left">KEY_HOME</td>
</tr>
<tr>
<td align="left">End</td>
<td align="left">KEY_END</td>
</tr>
<tr>
<td align="left">Page Up</td>
<td align="left">KEY_PPAGE</td>
</tr>
<tr>
<td align="left">Page Down</td>
<td align="left">KEY_NPAGE</td>
</tr>
</tbody></table>
<p>下表列出了替代字符集中的字符。 这些字符继承自 VT100 终端，在 X 终端等软件模拟器上通常均为可用。 当没有可用的图形时，curses 会回退为粗糙的可打印 ASCII 近似符号。</p>
<p>注解</p>
<p>只有在调用 <code>initscr()</code> 之后才能使用它们</p>
<table>
<thead>
<tr>
<th align="left">ACS代码</th>
<th align="left">含意</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>ACS_BBSS</code></td>
<td align="left">右上角的别名</td>
</tr>
<tr>
<td align="left"><code>ACS_BLOCK</code></td>
<td align="left">实心方块</td>
</tr>
<tr>
<td align="left"><code>ACS_BOARD</code></td>
<td align="left">正方形</td>
</tr>
<tr>
<td align="left"><code>ACS_BSBS</code></td>
<td align="left">水平线的别名</td>
</tr>
<tr>
<td align="left"><code>ACS_BSSB</code></td>
<td align="left">左上角的别名</td>
</tr>
<tr>
<td align="left"><code>ACS_BSSS</code></td>
<td align="left">顶部 T 型的别名</td>
</tr>
<tr>
<td align="left"><code>ACS_BTEE</code></td>
<td align="left">底部 T 型</td>
</tr>
<tr>
<td align="left"><code>ACS_BULLET</code></td>
<td align="left">正方形</td>
</tr>
<tr>
<td align="left"><code>ACS_CKBOARD</code></td>
<td align="left">棋盘（点刻）</td>
</tr>
<tr>
<td align="left"><code>ACS_DARROW</code></td>
<td align="left">向下箭头</td>
</tr>
<tr>
<td align="left"><code>ACS_DEGREE</code></td>
<td align="left">等级符</td>
</tr>
<tr>
<td align="left"><code>ACS_DIAMOND</code></td>
<td align="left">菱形</td>
</tr>
<tr>
<td align="left"><code>ACS_GEQUAL</code></td>
<td align="left">大于或等于</td>
</tr>
<tr>
<td align="left"><code>ACS_HLINE</code></td>
<td align="left">水平线</td>
</tr>
<tr>
<td align="left"><code>ACS_LANTERN</code></td>
<td align="left">灯形符号</td>
</tr>
<tr>
<td align="left"><code>ACS_LARROW</code></td>
<td align="left">向左箭头</td>
</tr>
<tr>
<td align="left"><code>ACS_LEQUAL</code></td>
<td align="left">小于或等于</td>
</tr>
<tr>
<td align="left"><code>ACS_LLCORNER</code></td>
<td align="left">左下角</td>
</tr>
<tr>
<td align="left"><code>ACS_LRCORNER</code></td>
<td align="left">右下角</td>
</tr>
<tr>
<td align="left"><code>ACS_LTEE</code></td>
<td align="left">左侧 T 型</td>
</tr>
<tr>
<td align="left"><code>ACS_NEQUAL</code></td>
<td align="left">不等号</td>
</tr>
<tr>
<td align="left"><code>ACS_PI</code></td>
<td align="left">字母π</td>
</tr>
<tr>
<td align="left"><code>ACS_PLMINUS</code></td>
<td align="left">正负号</td>
</tr>
<tr>
<td align="left"><code>ACS_PLUS</code></td>
<td align="left">加号</td>
</tr>
<tr>
<td align="left"><code>ACS_RARROW</code></td>
<td align="left">向右箭头</td>
</tr>
<tr>
<td align="left"><code>ACS_RTEE</code></td>
<td align="left">右侧 T 型</td>
</tr>
<tr>
<td align="left"><code>ACS_S1</code></td>
<td align="left">扫描线 1</td>
</tr>
<tr>
<td align="left"><code>ACS_S3</code></td>
<td align="left">扫描线3</td>
</tr>
<tr>
<td align="left"><code>ACS_S7</code></td>
<td align="left">扫描线7</td>
</tr>
<tr>
<td align="left"><code>ACS_S9</code></td>
<td align="left">扫描线 9</td>
</tr>
<tr>
<td align="left"><code>ACS_SBBS</code></td>
<td align="left">右下角的别名</td>
</tr>
<tr>
<td align="left"><code>ACS_SBSB</code></td>
<td align="left">垂直线的别名</td>
</tr>
<tr>
<td align="left"><code>ACS_SBSS</code></td>
<td align="left">右侧 T 型的别名</td>
</tr>
<tr>
<td align="left"><code>ACS_SSBB</code></td>
<td align="left">左下角的别名</td>
</tr>
<tr>
<td align="left"><code>ACS_SSBS</code></td>
<td align="left">底部 T 型的别名</td>
</tr>
<tr>
<td align="left"><code>ACS_SSSB</code></td>
<td align="left">左侧 T 型的别名</td>
</tr>
<tr>
<td align="left"><code>ACS_SSSS</code></td>
<td align="left">交叉或大加号的替代名称</td>
</tr>
<tr>
<td align="left"><code>ACS_STERLING</code></td>
<td align="left">英镑</td>
</tr>
<tr>
<td align="left"><code>ACS_TTEE</code></td>
<td align="left">顶部 T 型</td>
</tr>
<tr>
<td align="left"><code>ACS_UARROW</code></td>
<td align="left">向上箭头</td>
</tr>
<tr>
<td align="left"><code>ACS_ULCORNER</code></td>
<td align="left">左上角</td>
</tr>
<tr>
<td align="left"><code>ACS_URCORNER</code></td>
<td align="left">右上角</td>
</tr>
<tr>
<td align="left"><code>ACS_VLINE</code></td>
<td align="left">垂线</td>
</tr>
</tbody></table>
<p>下表列出了预定义的颜色：</p>
<table>
<thead>
<tr>
<th align="left">常量</th>
<th align="left">颜色</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>COLOR_BLACK</code></td>
<td align="left">黑色</td>
</tr>
<tr>
<td align="left"><code>COLOR_BLUE</code></td>
<td align="left">蓝色</td>
</tr>
<tr>
<td align="left"><code>COLOR_CYAN</code></td>
<td align="left">青色（浅绿蓝色）</td>
</tr>
<tr>
<td align="left"><code>COLOR_GREEN</code></td>
<td align="left">绿色</td>
</tr>
<tr>
<td align="left"><code>COLOR_MAGENTA</code></td>
<td align="left">洋红色（紫红色）</td>
</tr>
<tr>
<td align="left"><code>COLOR_RED</code></td>
<td align="left">红色</td>
</tr>
<tr>
<td align="left"><code>COLOR_WHITE</code></td>
<td align="left">白色</td>
</tr>
<tr>
<td align="left"><code>COLOR_YELLOW</code></td>
<td align="left">黄色</td>
</tr>
</tbody></table>
<h2 id="curses-textpad-—-用于-curses-程序的文本输入控件"><a href="#curses-textpad-—-用于-curses-程序的文本输入控件" class="headerlink" title="curses.textpad —- 用于 curses 程序的文本输入控件"></a><code>curses.textpad</code> —- 用于 curses 程序的文本输入控件</h2><p><code>curses.textpad</code> 模块提供了一个 <code>Textbox</code> 类，该类在 curses 窗口中处理基本的文本编辑，支持一组与 Emacs 类似的键绑定（因此这也适用于 Netscape Navigator, BBedit 6.x, FrameMaker 和许多其他程序）。 该模块还提供了一个绘制矩形的函数，适用于容纳文本框或其他目的。</p>
<p><code>curses.textpad</code> 模块定义了以下函数:</p>
<p><code>curses.textpad.rectangle</code>(<em>win</em>, <em>uly</em>, <em>ulx</em>, <em>lry</em>, <em>lrx</em>)</p>
<p>绘制一个矩形。 第一个参数必须为窗口对象；其余参数均为相对于该窗口的坐标值。 第二和第三个参数为要绘制的矩形的左上角的 y 和 x 坐标值；第四和第五个参数为其右下角的 y 和 x 坐标值。 将会使用 VT100/IBM PC 形式的字符在可用的终端上（包括 xterm 和大多数其他软件终端模拟器）绘制矩形。 在其他情况下则将使用 ASCII 横杠、竖线和加号绘制。</p>
<h3 id="文本框对象"><a href="#文本框对象" class="headerlink" title="文本框对象"></a>文本框对象</h3><p>你可以通过如下方式实例化一个 <code>Textbox</code>:</p>
<p><em>class</em> <code>curses.textpad.Textbox</code>(<em>win</em>)</p>
<p>返回一个文本框控件对象。 <em>win</em> 参数必须是一个 curses 窗口 对象，文本框将被包含在其中。 文本框的编辑光标在初始时位于包含窗口的左上角，坐标值为 <code>(0, 0)</code>。 实例的 <code>stripspaces</code> 旗标初始时为启用。</p>
<p><code>Textbox</code> 对象具有以下方法:</p>
<ul>
<li><p><code>edit</code>([<em>validator</em>])</p>
<p>这是你通常将使用的入口点。 它接受编辑按键直到键入了一个终止按键。 如果提供了 <em>validator</em>，它必须是一个函数。 它将在每次按键时被调用并传入相应的按键作作为形参；命令发送将在结果上执行。 此方法会以字符串形式返回窗口内容；是否包括窗口中的空白将受到 <code>stripspaces</code> 属性的影响。</p>
</li>
<li><p><code>do_command</code>(<em>ch</em>)</p>
<p>处理单个按键命令。以下是支持的特殊按键：</p>
<table>
<thead>
<tr>
<th align="left">按键</th>
<th align="left">动作</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Control-A</td>
<td align="left">转到窗口的左边缘。</td>
</tr>
<tr>
<td align="left">Control-B</td>
<td align="left">光标向左，如果可能，包含前一行。</td>
</tr>
<tr>
<td align="left">Control-D</td>
<td align="left">删除光标下的字符。</td>
</tr>
<tr>
<td align="left">Control-E</td>
<td align="left">前往右边缘（stripspaces 关闭时）或者行尾（stripspaces 启用时）。</td>
</tr>
<tr>
<td align="left">Control-F</td>
<td align="left">向右移动光标，适当时换行到下一行。</td>
</tr>
<tr>
<td align="left">Control-G</td>
<td align="left">终止，返回窗口内容。</td>
</tr>
<tr>
<td align="left">Control-H</td>
<td align="left">向后删除字符。</td>
</tr>
<tr>
<td align="left">Control-J</td>
<td align="left">如果窗口是1行则终止，否则插入换行符。</td>
</tr>
<tr>
<td align="left">Control-K</td>
<td align="left">如果行为空，则删除它，否则清除到行尾。</td>
</tr>
<tr>
<td align="left">Control-L</td>
<td align="left">刷新屏幕。</td>
</tr>
<tr>
<td align="left">Control-N</td>
<td align="left">光标向下;向下移动一行。</td>
</tr>
<tr>
<td align="left">Control-O</td>
<td align="left">在光标位置插入一个空行。</td>
</tr>
<tr>
<td align="left">Control-P</td>
<td align="left">光标向上;向上移动一行。</td>
</tr>
</tbody></table>
<p>如果光标位于无法移动的边缘，则移动操作不执行任何操作。在可能的情况下，支持以下同义词：</p>
<table>
<thead>
<tr>
<th align="left">常量</th>
<th align="left">按键</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>KEY_LEFT</code></td>
<td align="left">Control-B</td>
</tr>
<tr>
<td align="left"><code>KEY_RIGHT</code></td>
<td align="left">Control-F</td>
</tr>
<tr>
<td align="left"><code>KEY_UP</code></td>
<td align="left">Control-P</td>
</tr>
<tr>
<td align="left"><code>KEY_DOWN</code></td>
<td align="left">Control-N</td>
</tr>
<tr>
<td align="left"><code>KEY_BACKSPACE</code></td>
<td align="left">Control-h</td>
</tr>
</tbody></table>
<p>所有其他按键将被视为插入给定字符并右移的命令（带有自动折行）。</p>
</li>
<li><p><code>gather</code>()</p>
<p>以字符串形式返回窗口内容；是否包括窗口中的空白将受到 <code>stripspaces</code> 成员的影响。</p>
</li>
<li><p><code>stripspaces</code></p>
<p>此属性是控制窗口中空白解读方式的旗标。 当启用时，每一行的末尾空白会被忽略；任何将光标定位至末尾空白的光标动作都将改为前往该行末尾，并且在收集窗口内容时将去除末尾空白。</p>
</li>
</ul>
<h2 id="curses-ascii-—-用于-ASCII-字符的工具"><a href="#curses-ascii-—-用于-ASCII-字符的工具" class="headerlink" title="curses.ascii —- 用于 ASCII 字符的工具"></a><code>curses.ascii</code> —- 用于 ASCII 字符的工具</h2><p><code>curses.ascii</code> 模块提供了一些 ASCII 字符的名称常量以及在各种 ASCII 字符类中执行成员检测的函数。 所提供的控制字符常量如下:</p>
<table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">含意</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>NUL</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>SOH</code></td>
<td align="left">标题开始，控制台中断</td>
</tr>
<tr>
<td align="left"><code>STX</code></td>
<td align="left">文本开始</td>
</tr>
<tr>
<td align="left"><code>ETX</code></td>
<td align="left">文本结束</td>
</tr>
<tr>
<td align="left"><code>EOT</code></td>
<td align="left">传输结束</td>
</tr>
<tr>
<td align="left"><code>ENQ</code></td>
<td align="left">查询，附带 <code>ACK</code> 流量控制</td>
</tr>
<tr>
<td align="left"><code>ACK</code></td>
<td align="left">确认</td>
</tr>
<tr>
<td align="left"><code>BEL</code></td>
<td align="left">蜂鸣器</td>
</tr>
<tr>
<td align="left"><code>BS</code></td>
<td align="left">退格</td>
</tr>
<tr>
<td align="left"><code>TAB</code></td>
<td align="left">制表符</td>
</tr>
<tr>
<td align="left"><code>HT</code></td>
<td align="left"><code>TAB</code> 的别名： “水平制表符”</td>
</tr>
<tr>
<td align="left"><code>LF</code></td>
<td align="left">换行</td>
</tr>
<tr>
<td align="left"><code>NL</code></td>
<td align="left"><code>LF</code> 的别名： “新行”</td>
</tr>
<tr>
<td align="left"><code>VT</code></td>
<td align="left">垂直制表符</td>
</tr>
<tr>
<td align="left"><code>FF</code></td>
<td align="left">换页</td>
</tr>
<tr>
<td align="left"><code>CR</code></td>
<td align="left">回车</td>
</tr>
<tr>
<td align="left"><code>SO</code></td>
<td align="left">Shift-out，开始替换字符集</td>
</tr>
<tr>
<td align="left"><code>SI</code></td>
<td align="left">Shift-in，恢复默认字符集</td>
</tr>
<tr>
<td align="left"><code>DLE</code></td>
<td align="left">Data-link escape，数据链接转义</td>
</tr>
<tr>
<td align="left"><code>DC1</code></td>
<td align="left">XON，用于流程控制</td>
</tr>
<tr>
<td align="left"><code>DC2</code></td>
<td align="left">Device control 2，块模式流程控制</td>
</tr>
<tr>
<td align="left"><code>DC3</code></td>
<td align="left">XOFF，用于流程控制</td>
</tr>
<tr>
<td align="left"><code>DC4</code></td>
<td align="left">设备控制4</td>
</tr>
<tr>
<td align="left"><code>NAK</code></td>
<td align="left">否定确认</td>
</tr>
<tr>
<td align="left"><code>SYN</code></td>
<td align="left">同步空闲</td>
</tr>
<tr>
<td align="left"><code>ETB</code></td>
<td align="left">末端传输块</td>
</tr>
<tr>
<td align="left"><code>CAN</code></td>
<td align="left">取消</td>
</tr>
<tr>
<td align="left"><code>EM</code></td>
<td align="left">媒体结束</td>
</tr>
<tr>
<td align="left"><code>SUB</code></td>
<td align="left">替换</td>
</tr>
<tr>
<td align="left"><code>ESC</code></td>
<td align="left">退出</td>
</tr>
<tr>
<td align="left"><code>FS</code></td>
<td align="left">文件分隔符</td>
</tr>
<tr>
<td align="left"><code>GS</code></td>
<td align="left">组分隔符</td>
</tr>
<tr>
<td align="left"><code>RS</code></td>
<td align="left">Record separator，块模式终止符</td>
</tr>
<tr>
<td align="left"><code>US</code></td>
<td align="left">单位分隔符</td>
</tr>
<tr>
<td align="left"><code>SP</code></td>
<td align="left">空格</td>
</tr>
<tr>
<td align="left"><code>DEL</code></td>
<td align="left">删除</td>
</tr>
</tbody></table>
<p>请注意其中有许多在现今已经没有实际作用。 这些助记符是来源于数字计算机之前的电传打印机规范。</p>
<p>此模块提供了下列函数，对应于标准 C 库中的函数:</p>
<p><code>curses.ascii.isalnum</code>(<em>c</em>)</p>
<p>检测 ASCII 字母数字类字符；它等价于 <code>isalpha(c) 或 isdigit(c)</code>。</p>
<p><code>curses.ascii.isalpha</code>(<em>c</em>)</p>
<p>检测 ASCII 字母类字符；它等价于 <code>isupper(c) or islower(c)</code>。</p>
<p><code>curses.ascii.isascii</code>(<em>c</em>)</p>
<p>检测字符值是否在 7 位 ASCII 集范围内。</p>
<p><code>curses.ascii.isblank</code>(<em>c</em>)</p>
<p>检测 ASCII 空白字符；包括空格或水平制表符。</p>
<p><code>curses.ascii.iscntrl</code>(<em>c</em>)</p>
<p>检测 ASCII 控制字符（在 0x00 到 0x1f 或 0x7f 范围内）。</p>
<p><code>curses.ascii.isdigit</code>(<em>c</em>)</p>
<p>检测 ASCII 十进制数码，即 <code>'0'</code> 至 <code>'9'</code>。 它等价于 <code>c in string.digits</code>。</p>
<p><code>curses.ascii.isgraph</code>(<em>c</em>)</p>
<p>检测任意 ASCII 可打印字符，不包括空白符。</p>
<p><code>curses.ascii.islower</code>(<em>c</em>)</p>
<p>检测 ASCII 小写字母字符。</p>
<p><code>curses.ascii.isprint</code>(<em>c</em>)</p>
<p>检测任意 ASCII 可打印字符，包括空白符。</p>
<p><code>curses.ascii.ispunct</code>(<em>c</em>)</p>
<p>检测任意 ASCII 可打印字符，不包括空白符或字母数字类字符。</p>
<p><code>curses.ascii.isspace</code>(<em>c</em>)</p>
<p>检测 ASCII 空白字符；包括空格，换行，回车，进纸，水平制表和垂直制表。</p>
<p><code>curses.ascii.isupper</code>(<em>c</em>)</p>
<p>检测 ASCII 大写字母字符。</p>
<p><code>curses.ascii.isxdigit</code>(<em>c</em>)</p>
<p>检测 ASCII 十六进制数码。 这等价于 <code>c in string.hexdigits</code>。</p>
<p><code>curses.ascii.isctrl</code>(<em>c</em>)</p>
<p>检测 ASCII 控制字符（码位值 0 至 31）。</p>
<p><code>curses.ascii.ismeta</code>(<em>c</em>)</p>
<p>检测非 ASCII 字符（码位值 0x80 及以上）。</p>
<p>这些函数接受整数或单字符字符串；当参数为字符串时，会先使用内置函数 <a href="https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#ord" target="_blank" rel="noopener"><code>ord()</code></a> 进行转换。</p>
<p>请注意所有这些函数都是检测根据你传入的字符串的字符所生成的码位值；它们实际上完全不会知晓本机的字符编码格式。</p>
<p>以下两个函数接受单字符字符串或整数形式的字节值；它们会返回相同类型的值。</p>
<p><code>curses.ascii.ascii</code>(<em>c</em>)</p>
<p>返回对应于 <em>c</em> 的下个 7 比特位的 ASCII 值。</p>
<p><code>curses.ascii.ctrl</code>(<em>c</em>)</p>
<p>返回对应于给定字符的控制字符（字符比特值会与 0x1f 进行按位与运算）。</p>
<p><code>curses.ascii.alt</code>(<em>c</em>)</p>
<p>返回对应于给定 ASCII 字符的 8 比特位字符（字符比特值会与 0x80 进行按位或运算）。</p>
<p>以下函数接受单字符字符串或整数值；它会返回一个字符串。</p>
<p><code>curses.ascii.unctrl</code>(<em>c</em>)</p>
<p>返回 ASCII 字符 <em>c</em> 的字符串表示形式。 如果 <em>c</em> 是可打印字符，则字符串为字符本身。 如果该字符是控制字符 (0x00—0x1f) 则字符串由一个插入符 (<code>'^'</code>) 加相应的大写字母组成。 如果该字符是 ASCII 删除符 (0x7f) 则字符串为 <code>'^?'</code>。 如果该字符设置了元比特位 (0x80)，元比特位会被去除，应用以上规则后将在结果之前添加 <code>'!'</code>。</p>
<pre><code>curses.ascii.controlnames</code></pre><p>一个 33 元素的字符串数据，其中按从 0 (NUL) 到 0x1f (US) 的顺序包含了三十二个 ASCII 控制字符的 ASCII 助记符，另加空格符的助记符 <code>SP</code>。</p>
<h2 id="curses-panel-—-curses-的面板栈扩展"><a href="#curses-panel-—-curses-的面板栈扩展" class="headerlink" title="curses.panel —- curses 的面板栈扩展"></a><code>curses.panel</code> —- curses 的面板栈扩展</h2><p>面板是具有添加深度功能的窗口，因此它们可以从上至下堆叠为栈，只有显示每个窗口的可见部分会显示出来。 面板可以在栈中被添加、上移或下移，也可以被移除。</p>
<h3 id="函数-2"><a href="#函数-2" class="headerlink" title="函数"></a>函数</h3><p><code>curses.panel</code> 模块定义了以下函数:</p>
<p><code>curses.panel.bottom_panel</code>()</p>
<p>返回面板栈中的底部面板。</p>
<p><code>curses.panel.new_panel</code>(<em>win</em>)</p>
<p>返回一个面板对象，将其与给定的窗口 <em>win</em> 相关联。 请注意你必须显式地保持所返回的面板对象。 如果你不这样做，面板对象会被垃圾回收并从面板栈中被移除。</p>
<p><code>curses.panel.top_panel</code>()</p>
<p>返回面板栈中的顶部面板。</p>
<p><code>curses.panel.update_panels</code>()</p>
<p>在面板栈发生改变后更新虚拟屏幕。 这不会调用 <code>curses.doupdate()</code>，因此你不必自己执行此操作。</p>
<h3 id="Panel-对象"><a href="#Panel-对象" class="headerlink" title="Panel 对象"></a>Panel 对象</h3><p>Panel 对象，如上面 <code>new_panel()</code> 所返回的对象，是带有栈顺序的多个窗口。 总是会有一个窗口与确定内容的面板相关联，面板方法会负责窗口在面板栈中的深度。</p>
<p>Panel 对象具有以下方法:</p>
<p><code>Panel.above</code>()</p>
<p>返回当前面板之上的面板。</p>
<p><code>Panel.below</code>()</p>
<p>返回当前面板之下的面板。</p>
<p><code>Panel.bottom</code>()</p>
<p>将面板推至栈底部。</p>
<p><code>Panel.hidden</code>()</p>
<p>如果面板被隐藏（不可见）则返回 <code>True</code>，否则返回 <code>False</code>。</p>
<p><code>Panel.hide</code>()</p>
<p>隐藏面板。 这不会删除对象，它只是让窗口在屏幕上不可见。</p>
<p><code>Panel.move</code>(<em>y</em>, <em>x</em>)</p>
<p>将面板移至屏幕坐标 <code>(y, x)</code>。</p>
<p><code>Panel.replace</code>(<em>win</em>)</p>
<p>将与面板相关联的窗口改为窗口 <em>win</em>。</p>
<p><code>Panel.set_userptr</code>(<em>obj</em>)</p>
<p>将面板的用户指向设为 <em>obj</em>。 这被用来将任意数据与面板相关联，数据可以是任何 Python 对象。</p>
<p><code>Panel.show</code>()</p>
<p>显示面板（面板可能已被隐藏）。</p>
<p><code>Panel.top</code>()</p>
<p>将面板推至栈顶部。</p>
<p><code>Panel.userptr</code>()</p>
<p>返回面板的用户指针。 这可以是任何 Python 对象。</p>
<p><code>Panel.window</code>()</p>
<p>返回与面板相关联的窗口对象。</p>
<h2 id="platform-—-获取底层平台的标识数据"><a href="#platform-—-获取底层平台的标识数据" class="headerlink" title="platform —- 获取底层平台的标识数据"></a><code>platform</code> —- 获取底层平台的标识数据</h2><p><strong>源代码：</strong> <a href="https://github.com/python/cpython/tree/3.10/Lib/platform.py" target="_blank" rel="noopener">Lib/platform.py</a></p>
<hr>
<p>注解</p>
<p>特定平台按字母顺序排列，Linux 包括在 Unix 小节之中。</p>
<h3 id="跨平台"><a href="#跨平台" class="headerlink" title="跨平台"></a>跨平台</h3><p><code>platform.architecture</code>(<em>executable=sys.executable</em>, <em>bits=’’</em>, <em>linkage=’’</em>)</p>
<p>查询给定的可执行文件（默认为 Python 解释器二进制码文件）来获取各种架构信息。</p>
<p>返回一个元素 <code>(bits, linkage)</code>，其中包含可执行文件所使用的位架构和链接格式信息。 这两个值均以字符串形式返回。</p>
<p>无法确定的值将返回为形参预设所给出的值。 如果给出的位数为 <code>''</code>，则会使用 <code>sizeof(pointer)</code> (或者当 Python 版本 &lt; 1.5.2 时为 <code>sizeof(long)</code>) 作为所支持的指针大小的提示。</p>
<p>此函数依赖于系统的 <code>file</code> 命令来执行实际的操作。 这在几乎所有 Unix 平台和某些非 Unix 平台上只有当可执行文件指向 Python 解释器时才可用。 当以上要求不满足时将会使用合理的默认值。</p>
<p>注解</p>
<p>在 macOS (也许还有其他平台) 上，可执行文件可能是包含多种架构的通用文件。</p>
<p>要获取当前解释器的“64 位性”，更可靠的做法是查询 <code>sys.maxsize</code> 属性:</p>
<pre><code>is_64bits = sys.maxsize &gt; 2**32</code></pre><p><code>platform.machine</code>()</p>
<p>返回机器类型，例如 <code>'i386'</code>。 如果该值无法确定则会返回一个空字符串。</p>
<p><code>platform.node</code>()</p>
<p>返回计算机的网络名称（可能不是完整限定名称！）。 如果该值无法确定则会返回一个空字符串。</p>
<p><code>platform.platform</code>(<em>aliased=0</em>, <em>terse=0</em>)</p>
<p>返回一个标识底层平台的字符串，其中带有尽可能多的有用信息。</p>
<p>输出信息的目标是“人类易读”而非机器易解析。 它在不同平台上可能看起来不一致，这是有意为之的。</p>
<p>如果 <em>aliased</em> 为真值，此函数将使用各种平台不同与其通常名称的别名来报告系统名称，例如 SunOS 将被报告为 Solaris。 <code>system_alias()</code> 函数将被用于实现此功能。</p>
<p>将 <em>terse</em> 设为真值将导致此函数只返回标识平台所必须的最小量信息。</p>
<p>在 3.8 版更改: 在 macOS 上，此函数现在会在 <code>mac_ver()</code> 返回的发布版字符串非空时使用它，以便获取 macOS 版本而非 darwin 版本。</p>
<p><code>platform.processor</code>()</p>
<p>返回（真实的）处理器名称，例如 <code>'amdk6'</code>。</p>
<p>如果该值无法确定则将返回空字符串。 请注意许多平台都不提供此信息或是简单地返回与 <code>machine()</code> 相同的值。 NetBSD 则会提供此信息。</p>
<p><code>platform.python_build</code>()</p>
<p>返回一个元组 <code>(buildno, builddate)</code>，以字符串表示的 Python 编译代码和日期。</p>
<p><code>platform.python_compiler</code>()</p>
<p>返回一个标识用于编译 Python 的编译器的的字符串。</p>
<p><code>platform.python_branch</code>()</p>
<p>返回一个标识 Python 实现的 SCM 分支的字符串。</p>
<p><code>platform.python_implementation</code>()</p>
<p>返回一个标识 Python 实现的字符串。 可能的返回值有: ‘CPython’, ‘IronPython’, ‘Jython’, ‘PyPy’。</p>
<p><code>platform.python_revision</code>()</p>
<p>返回一个标识 Python 实现的 SCM 修订版的字符串。</p>
<p><code>platform.python_version</code>()</p>
<p>将 Python 版本以字符串 <code>'major.minor.patchlevel'</code> 形式返回。</p>
<p>请注意此返回值不同于 Python <code>sys.version</code>，它将总是包括 patchlevel (默认为 0)。</p>
<p><code>platform.python_version_tuple</code>()</p>
<p>将 Python 版本以字符串元组 <code>(major, minor, patchlevel)</code> 形式返回。</p>
<p>请注意此返回值不同于 Python <code>sys.version</code>，它将总是包括 patchlevel (默认为 <code>'0'</code>)。</p>
<p><code>platform.release</code>()</p>
<p>返回系统的发布版本，例如 <code>'2.2.0'</code> 或 <code>'NT'</code>，如果该值无法确定则将返回一个空字符串。</p>
<p><code>platform.system</code>()</p>
<p>返回系统平台/OS的名称，例如 <code>'Linux'</code>, <code>'Darwin'</code>, <code>'Java'</code>, <code>'Windows'</code>。 如果该值无法确定则将返回一个空字符串。</p>
<p><code>platform.system_alias</code>(<em>system</em>, <em>release</em>, <em>version</em>)</p>
<p>返回别名为某些系统所使用的常见营销名称的 <code>(system, release, version)</code>。 它还会在可能导致混淆的情况下对信息进行一些重排序操作。</p>
<p><code>platform.version</code>()</p>
<p>返回系统的发布版本信息，例如 <code>'#3 on degas'</code>。 如果该值无法确定则将返回一个空字符串。</p>
<p><code>platform.uname</code>()</p>
<p>具有高可移植性的 uname 接口。 返回包含六个属性的 <code>namedtuple()</code>: <code>system</code>, <code>node</code>, <code>release</code>, <code>version</code>, <code>machine</code> 和 <code>processor</code>。</p>
<p>请注意此函数添加的第六个属性 (<code>processor</code>) 并不存在于 <code>os.uname()</code> 的结果中。 并且前两个属性的属性名称也不一致；<code>os.uname()</code> 是将它们称为 <code>sysname</code> 和 <code>nodename</code>。</p>
<p>无法确定的条目会被设为 <code>''</code>。</p>
<p>在 3.3 版更改: 将结果从元组改为命名元组。</p>
<h3 id="Java平台"><a href="#Java平台" class="headerlink" title="Java平台"></a>Java平台</h3><p><code>platform.java_ver</code>(<em>release=’’</em>, <em>vendor=’’</em>, <em>vminfo=’’, ‘’, ‘’</em>, <em>osinfo=’’, ‘’, ‘’</em>)</p>
<p>Jython 的版本接口</p>
<p>返回一个元组 <code>(release, vendor, vminfo, osinfo)</code>，其中 <em>vminfo</em> 为元组 <code>(vm_name, vm_release, vm_vendor)</code> 而 <em>osinfo</em> 为元组 <code>(os_name, os_version, os_arch)</code>。 无法确定的值将设为由形参所给出的默认值 (默认均为 <code>''</code>)。</p>
<h3 id="Windows平台"><a href="#Windows平台" class="headerlink" title="Windows平台"></a>Windows平台</h3><p><code>platform.win32_ver</code>(<em>release=’’</em>, <em>version=’’</em>, <em>csd=’’</em>, <em>ptype=’’</em>)</p>
<p>从 Windows 注册表获取额外的版本信息并返回一个元组 <code>(release, version, csd, ptype)</code> 表示 OS 发行版, 版本号, CSD 级别 (Service Pack) 和 OS 类型 (多个/单个处理器)。</p>
<p>一点提示: <em>ptype</em> 在单个处理器的 NT 机器上为 <code>'Uniprocessor Free'</code> 而在多个处理器的机器上为 <code>'Multiprocessor Free'</code>。 <em>‘Free’</em> 是指该 OS 版本没有调试代码。 它还可能显示 <em>‘Checked’</em> 表示该 OS 版本使用了调试代码，即检测参数、范围等的代码。</p>
<p><code>platform.win32_edition</code>()</p>
<p>返回一个代表当前 Windows 版本的字符串。 可能的值包括但不限于 <code>'Enterprise'</code>, <code>'IoTUAP'</code>, <code>'ServerStandard'</code> 和 <code>'nanoserver'</code>。</p>
<p>3.8 新版功能.</p>
<p><code>platform.win32_is_iot</code>()</p>
<p>如果 <code>win32_edition()</code> 返回的 Windows 版本被识别为 IoT 版则返回 <code>True</code>。</p>
<p>3.8 新版功能.</p>
<h3 id="macOS-Platform"><a href="#macOS-Platform" class="headerlink" title="macOS Platform"></a>macOS Platform</h3><p><code>platform.mac_ver</code>(<em>release=’’</em>, <em>versioninfo=’’, ‘’, ‘’</em>, <em>machine=’’</em>)</p>
<p>Get macOS version information and return it as tuple <code>(release, versioninfo, machine)</code> with <em>versioninfo</em> being a tuple <code>(version, dev_stage, non_release_version)</code>.</p>
<p>无法确定的条目会被设为 <code>''</code>。 所有元组条目均为字符串。</p>
<h3 id="Unix-平台"><a href="#Unix-平台" class="headerlink" title="Unix 平台"></a>Unix 平台</h3><p><code>platform.libc_ver</code>(<em>executable=sys.executable</em>, <em>lib=’’</em>, <em>version=’’</em>, <em>chunksize=16384</em>)</p>
<p>尝试确定可执行文件（默认为 Python 解释器）所链接到的 libc 版本。 返回一个字符串元组 <code>(lib, version)</code>，当查找失败时其默认值将设为给定的形参值。</p>
<p>请注意此函数对于不同 libc 版本向可执行文件添加符号的方式有深层的关联，可能仅适用于使用 <strong>gcc</strong> 编译出来的可执行文件。</p>
<p>文件将按 <em>chunksize</em> 个字节的分块来读取和扫描。</p>
<h3 id="Linux-平台"><a href="#Linux-平台" class="headerlink" title="Linux 平台"></a>Linux 平台</h3><p><code>platform.freedesktop_os_release</code>()</p>
<p>从 <code>os-release</code> 文件获取操作系统标识并将其作为一个字典返回。 <code>os-release</code> 文件是 <a href="https://www.freedesktop.org/software/systemd/man/os-release.html" target="_blank" rel="noopener">freedesktop.org 标准</a> 并在大多数 Linux 发行版上可用。 一个重要的例外是 Android 和基于 Android 的发行版。</p>
<p>当 <code>/etc/os-release</code> 或 <code>/usr/lib/os-release</code> 均无法读取时将引发 <code>OSError</code> 或其子类。</p>
<p>成功时，该函数将返回一个字典，其中键和值均为字符串。 值当中的特殊字符例如 <code>"</code> 和 <code>{TX-PL-LABEL}#x60;</code> 会被复原。 字段 ``NAME<code>,</code>ID<code>和</code>PRETTY_NAME` 总是会按照标准来定义。 所有其他字段都是可选的。 厂商可能会包括额外的字段。</p>
<p>请注意 <code>NAME</code>, <code>VERSION</code> 和 <code>VARIANT</code> 等字段是适用于向用户展示的字符串。 程序应当使用 <code>ID</code>, <code>ID_LIKE</code>, <code>VERSION_ID</code> 或 <code>VARIANT_ID</code> 等字段来标识 Linux 发行版。</p>
<p>示例:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">get_like_distro</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    info <span class="token operator">=</span> platform<span class="token punctuation">.</span>freedesktop_os_release<span class="token punctuation">(</span><span class="token punctuation">)</span>
    ids <span class="token operator">=</span> <span class="token punctuation">[</span>info<span class="token punctuation">[</span><span class="token string">"ID"</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
    <span class="token keyword">if</span> <span class="token string">"ID_LIKE"</span> <span class="token keyword">in</span> info<span class="token punctuation">:</span>
        <span class="token comment" spellcheck="true"># ids are space separated and ordered by precedence</span>
        ids<span class="token punctuation">.</span>extend<span class="token punctuation">(</span>info<span class="token punctuation">[</span><span class="token string">"ID_LIKE"</span><span class="token punctuation">]</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> ids<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="errno-—-标准-errno-系统符号"><a href="#errno-—-标准-errno-系统符号" class="headerlink" title="errno —- 标准 errno 系统符号"></a><code>errno</code> —- 标准 errno 系统符号</h2><p>本模块提供标准的 <code>errno</code> 系统符号。每个符号的值是其对应的整数值。符号的名称和描述来自 <code>linux/include/errno.h</code>，应该是非常全面的。</p>
<pre><code>errno.errorcode</code></pre><p>提供从 errno 值到底层系统中字符串名称的映射的字典。例如， <code>errno.errorcode[errno.EPERM]</code> 映射为 <code>'EPERM'</code> 。</p>
<p>如果要将数字的错误代码转换为错误信息，请使用 <code>os.strerror()</code>。</p>
<p>在下面的列表中，当前平台上没有使用的符号没有被本模块定义。 已定义的符号的具体列表可参见 <code>errno.errorcode.keys()</code>。 可用的符号包括：</p>
<pre><code>errno.EPERM</code></pre><p>操作不被允许</p>
<pre><code>errno.ENOENT</code></pre><p>无此文件或目录</p>
<pre><code>errno.ESRCH</code></pre><p>无此进程</p>
<pre><code>errno.EINTR</code></pre><p>系统调用中断。</p>
<p>参见</p>
<p>此错误被映射到异常 <code>InterruptedError</code>。</p>
<pre><code>errno.EIO</code></pre><p>I/O 错误</p>
<pre><code>errno.ENXIO</code></pre><p>无此设备或地址</p>
<pre><code>errno.E2BIG</code></pre><p>参数列表过长</p>
<pre><code>errno.ENOEXEC</code></pre><p>执行格式错误</p>
<pre><code>errno.EBADF</code></pre><p>错误的文件号</p>
<pre><code>errno.ECHILD</code></pre><p>没有子进程</p>
<pre><code>errno.EAGAIN</code></pre><p>重试</p>
<pre><code>errno.ENOMEM</code></pre><p>内存不足</p>
<pre><code>errno.EACCES</code></pre><p>没有权限</p>
<pre><code>errno.EFAULT</code></pre><p>错误的地址</p>
<pre><code>errno.ENOTBLK</code></pre><p>需要块设备</p>
<pre><code>errno.EBUSY</code></pre><p>设备或资源忙</p>
<pre><code>errno.EEXIST</code></pre><p>文件已存在</p>
<pre><code>errno.EXDEV</code></pre><p>跨设备链接</p>
<pre><code>errno.ENODEV</code></pre><p>无此设备</p>
<pre><code>errno.ENOTDIR</code></pre><p>不是目录</p>
<pre><code>errno.EISDIR</code></pre><p>是目录</p>
<pre><code>errno.EINVAL</code></pre><p>无效的参数</p>
<pre><code>errno.ENFILE</code></pre><p>文件表溢出</p>
<pre><code>errno.EMFILE</code></pre><p>打开的文件过多</p>
<pre><code>errno.ENOTTY</code></pre><p>不是打字机</p>
<pre><code>errno.ETXTBSY</code></pre><p>文本文件忙</p>
<pre><code>errno.EFBIG</code></pre><p>文件过大</p>
<pre><code>errno.ENOSPC</code></pre><p>设备已无可用空间</p>
<pre><code>errno.ESPIPE</code></pre><p>非法查找</p>
<pre><code>errno.EROFS</code></pre><p>只读文件系统</p>
<pre><code>errno.EMLINK</code></pre><p>链接过多</p>
<pre><code>errno.EPIPE</code></pre><p>管道已损坏</p>
<pre><code>errno.EDOM</code></pre><p>数学参数超出函数范围</p>
<pre><code>errno.ERANGE</code></pre><p>数学运算结果无法表示</p>
<pre><code>errno.EDEADLK</code></pre><p>将发生资源死锁</p>
<pre><code>errno.ENAMETOOLONG</code></pre><p>文件名过长</p>
<pre><code>errno.ENOLCK</code></pre><p>没有可用的记录锁</p>
<pre><code>errno.ENOSYS</code></pre><p>功能未实现</p>
<pre><code>errno.ENOTEMPTY</code></pre><p>目录非空</p>
<pre><code>errno.ELOOP</code></pre><p>遇到过多的符号链接</p>
<pre><code>errno.EWOULDBLOCK</code></pre><p>操作将阻塞</p>
<pre><code>errno.ENOMSG</code></pre><p>没有所需类型的消息</p>
<pre><code>errno.EIDRM</code></pre><p>标识符被移除</p>
<pre><code>errno.ECHRNG</code></pre><p>信道编号超出范围</p>
<pre><code>errno.EL2NSYNC</code></pre><p>级别 2 未同步</p>
<pre><code>errno.EL3HLT</code></pre><p>级别 3 已停止</p>
<pre><code>errno.EL3RST</code></pre><p>级别 3 重置</p>
<pre><code>errno.ELNRNG</code></pre><p>链接编号超出范围</p>
<pre><code>errno.EUNATCH</code></pre><p>未附加协议驱动</p>
<pre><code>errno.ENOCSI</code></pre><p>没有可用的 CSI 结构</p>
<pre><code>errno.EL2HLT</code></pre><p>级别 2 已停止</p>
<pre><code>errno.EBADE</code></pre><p>无效的交换</p>
<pre><code>errno.EBADR</code></pre><p>无效的请求描述符</p>
<pre><code>errno.EXFULL</code></pre><p>交换已满</p>
<pre><code>errno.ENOANO</code></pre><p>没有阳极</p>
<pre><code>errno.EBADRQC</code></pre><p>无效的请求码·</p>
<pre><code>errno.EBADSLT</code></pre><p>无效的槽位</p>
<pre><code>errno.EDEADLOCK</code></pre><p>文件锁定死锁错误</p>
<pre><code>errno.EBFONT</code></pre><p>错误的字体文件格式</p>
<pre><code>errno.ENOSTR</code></pre><p>设备不是流</p>
<pre><code>errno.ENODATA</code></pre><p>没有可用的数据</p>
<pre><code>errno.ETIME</code></pre><p>计时器已到期</p>
<pre><code>errno.ENOSR</code></pre><p>流资源不足</p>
<pre><code>errno.ENONET</code></pre><p>机器不在网络上</p>
<pre><code>errno.ENOPKG</code></pre><p>包未安装</p>
<pre><code>errno.EREMOTE</code></pre><p>对象是远程的</p>
<pre><code>errno.ENOLINK</code></pre><p>链接已被切断</p>
<pre><code>errno.EADV</code></pre><p>广告错误</p>
<pre><code>errno.ESRMNT</code></pre><p>挂载错误</p>
<pre><code>errno.ECOMM</code></pre><p>发送时通讯错误</p>
<pre><code>errno.EPROTO</code></pre><p>协议错误</p>
<pre><code>errno.EMULTIHOP</code></pre><p>已尝试多跳</p>
<pre><code>errno.EDOTDOT</code></pre><p>RFS 专属错误</p>
<pre><code>errno.EBADMSG</code></pre><p>非数据消息</p>
<pre><code>errno.EOVERFLOW</code></pre><p>值相对于已定义数据类型过大</p>
<pre><code>errno.ENOTUNIQ</code></pre><p>名称在网络上不唯一</p>
<pre><code>errno.EBADFD</code></pre><p>文件描述符处于错误状态</p>
<pre><code>errno.EREMCHG</code></pre><p>远端地址已改变</p>
<pre><code>errno.ELIBACC</code></pre><p>无法访问所需的共享库</p>
<pre><code>errno.ELIBBAD</code></pre><p>访问已损坏的共享库</p>
<pre><code>errno.ELIBSCN</code></pre><p>a.out 中的 .lib 部分已损坏</p>
<pre><code>errno.ELIBMAX</code></pre><p>尝试链接过多的共享库</p>
<pre><code>errno.ELIBEXEC</code></pre><p>无法直接执行共享库</p>
<pre><code>errno.EILSEQ</code></pre><p>非法字节序列</p>
<pre><code>errno.ERESTART</code></pre><p>已中断系统调用需要重启</p>
<pre><code>errno.ESTRPIPE</code></pre><p>流管道错误</p>
<pre><code>errno.EUSERS</code></pre><p>用户过多</p>
<pre><code>errno.ENOTSOCK</code></pre><p>在非套接字上执行套接字操作</p>
<pre><code>errno.EDESTADDRREQ</code></pre><p>需要目标地址</p>
<pre><code>errno.EMSGSIZE</code></pre><p>消息过长</p>
<pre><code>errno.EPROTOTYPE</code></pre><p>套接字的协议类型错误</p>
<pre><code>errno.ENOPROTOOPT</code></pre><p>协议不可用</p>
<pre><code>errno.EPROTONOSUPPORT</code></pre><p>协议不受支持</p>
<pre><code>errno.ESOCKTNOSUPPORT</code></pre><p>套接字类型不受支持</p>
<pre><code>errno.EOPNOTSUPP</code></pre><p>操作在传输端点上不受支持</p>
<pre><code>errno.EPFNOSUPPORT</code></pre><p>协议族不受支持</p>
<pre><code>errno.EAFNOSUPPORT</code></pre><p>地址族不受协议支持</p>
<pre><code>errno.EADDRINUSE</code></pre><p>地址已被使用</p>
<pre><code>errno.EADDRNOTAVAIL</code></pre><p>无法分配要求的地址</p>
<pre><code>errno.ENETDOWN</code></pre><p>网络已断开</p>
<pre><code>errno.ENETUNREACH</code></pre><p>网络不可达</p>
<pre><code>errno.ENETRESET</code></pre><p>网络因重置而断开连接</p>
<pre><code>errno.ECONNABORTED</code></pre><p>软件导致连接中止</p>
<pre><code>errno.ECONNRESET</code></pre><p>连接被对方重置</p>
<pre><code>errno.ENOBUFS</code></pre><p>没有可用的缓冲区空间</p>
<pre><code>errno.EISCONN</code></pre><p>传输端点已连接</p>
<pre><code>errno.ENOTCONN</code></pre><p>传输端点未连接</p>
<pre><code>errno.ESHUTDOWN</code></pre><p>传输端点关闭后无法发送</p>
<pre><code>errno.ETOOMANYREFS</code></pre><p>引用过多：无法拼接</p>
<pre><code>errno.ETIMEDOUT</code></pre><p>连接超时</p>
<pre><code>errno.ECONNREFUSED</code></pre><p>连接被拒</p>
<pre><code>errno.EHOSTDOWN</code></pre><p>主机已关闭</p>
<pre><code>errno.EHOSTUNREACH</code></pre><p>没有到主机的路由</p>
<pre><code>errno.EALREADY</code></pre><p>操作已在进行</p>
<pre><code>errno.EINPROGRESS</code></pre><p>操作正在进行</p>
<pre><code>errno.ESTALE</code></pre><p>过期的 NFS 文件句柄</p>
<pre><code>errno.EUCLEAN</code></pre><p>结构需要清理</p>
<pre><code>errno.ENOTNAM</code></pre><p>不是 XENIX 命名类型文件</p>
<pre><code>errno.ENAVAIL</code></pre><p>没有可用的 XENIX 信标</p>
<pre><code>errno.EISNAM</code></pre><p>是命名类型文件</p>
<pre><code>errno.EREMOTEIO</code></pre><p>远程 I/O 错误</p>
<pre><code>errno.EDQUOT</code></pre><p>超出配额</p>
<h2 id="ctypes-—-Python-的外部函数库"><a href="#ctypes-—-Python-的外部函数库" class="headerlink" title="ctypes —- Python 的外部函数库"></a><code>ctypes</code> —- Python 的外部函数库</h2><p><code>ctypes</code> 是 Python 的外部函数库。它提供了与 C 兼容的数据类型，并允许调用 DLL 或共享库中的函数。可使用该模块以纯 Python 形式对这些库进行封装。</p>
<h3 id="ctypes-教程"><a href="#ctypes-教程" class="headerlink" title="ctypes 教程"></a>ctypes 教程</h3><p>Note: The code samples in this tutorial use <code>doctest</code> to make sure that they actually work. Since some code samples behave differently under Linux, Windows, or macOS, they contain doctest directives in comments.</p>
<p>注意：部分示例代码引用了 ctypes <code>c_int</code> 类型。在 <code>sizeof(long) == sizeof(int)</code> 的平台上此类型是 <code>c_long</code> 的一个别名。所以，在程序输出 <code>c_long</code> 而不是你期望的 <code>c_int</code> 时不必感到迷惑 —- 它们实际上是同一种类型。</p>
<h4 id="载入动态连接库"><a href="#载入动态连接库" class="headerlink" title="载入动态连接库"></a>载入动态连接库</h4><p><code>ctypes</code> 导出了 <em>cdll</em> 对象，在 Windows 系统中还导出了 <em>windll</em> 和 <em>oledll</em> 对象用于载入动态连接库。</p>
<p>通过操作这些对象的属性，你可以载入外部的动态链接库。<em>cdll</em> 载入按标准的 <code>cdecl</code> 调用协议导出的函数，而 <em>windll</em> 导入的库按 <code>stdcall</code> 调用协议调用其中的函数。 <em>oledll</em> 也按 <code>stdcall</code> 调用协议调用其中的函数，并假定该函数返回的是 Windows <code>HRESULT</code> 错误代码，并当函数调用失败时，自动根据该代码甩出一个 <code>OSError</code> 异常。</p>
<p>在 3.3 版更改: 原来在 Windows 下抛出的异常类型 <code>WindowsError</code> 现在是 <code>OSError</code> 的一个别名。</p>
<p>这是一些 Windows 下的例子。注意：<code>msvcrt</code> 是微软 C 标准库，包含了大部分 C 标准函数，这些函数都是以 cdecl 调用协议进行调用的。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> ctypes <span class="token keyword">import</span> <span class="token operator">*</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>windll<span class="token punctuation">.</span>kernel32<span class="token punctuation">)</span>  
<span class="token operator">&lt;</span>WinDLL <span class="token string">'kernel32'</span><span class="token punctuation">,</span> handle <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> at <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">></span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>cdll<span class="token punctuation">.</span>msvcrt<span class="token punctuation">)</span>      
<span class="token operator">&lt;</span>CDLL <span class="token string">'msvcrt'</span><span class="token punctuation">,</span> handle <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> at <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">></span>
<span class="token operator">>></span><span class="token operator">></span> libc <span class="token operator">=</span> cdll<span class="token punctuation">.</span>msvcrt      
<span class="token operator">>></span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>Windows 会自动添加通常的 <code>.dll</code> 文件扩展名。</p>
<p>注解</p>
<p>通过 <code>cdll.msvcrt</code> 调用的标准 C 函数，可能会导致调用一个过时的，与当前 Python 所不兼容的函数。因此，请尽量使用标准的 Python 函数，而不要使用 <code>msvcrt</code> 模块。</p>
<p>在 Linux 下，必须使用 <em>包含</em> 文件扩展名的文件名来导入共享库。因此不能简单使用对象属性的方式来导入库。因此，你可以使用方法 <code>LoadLibrary()</code>，或构造 CDLL 对象来导入库。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> cdll<span class="token punctuation">.</span>LoadLibrary<span class="token punctuation">(</span><span class="token string">"libc.so.6"</span><span class="token punctuation">)</span>  
<span class="token operator">&lt;</span>CDLL <span class="token string">'libc.so.6'</span><span class="token punctuation">,</span> handle <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> at <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">></span>
<span class="token operator">>></span><span class="token operator">></span> libc <span class="token operator">=</span> CDLL<span class="token punctuation">(</span><span class="token string">"libc.so.6"</span><span class="token punctuation">)</span>       
<span class="token operator">>></span><span class="token operator">></span> libc                           
<span class="token operator">&lt;</span>CDLL <span class="token string">'libc.so.6'</span><span class="token punctuation">,</span> handle <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> at <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">></span>
<span class="token operator">>></span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="操作导入的动态链接库中的函数"><a href="#操作导入的动态链接库中的函数" class="headerlink" title="操作导入的动态链接库中的函数"></a>操作导入的动态链接库中的函数</h4><p>通过操作dll对象的属性来操作这些函数。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> ctypes <span class="token keyword">import</span> <span class="token operator">*</span>
<span class="token operator">>></span><span class="token operator">></span> libc<span class="token punctuation">.</span>printf
<span class="token operator">&lt;</span>_FuncPtr object at 0x<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">></span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>windll<span class="token punctuation">.</span>kernel32<span class="token punctuation">.</span>GetModuleHandleA<span class="token punctuation">)</span>  
<span class="token operator">&lt;</span>_FuncPtr object at 0x<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">></span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>windll<span class="token punctuation">.</span>kernel32<span class="token punctuation">.</span>MyOwnFunction<span class="token punctuation">)</span>     
Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>
  File <span class="token string">"&lt;stdin>"</span><span class="token punctuation">,</span> line <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">></span>
  File <span class="token string">"ctypes.py"</span><span class="token punctuation">,</span> line <span class="token number">239</span><span class="token punctuation">,</span> <span class="token keyword">in</span> __getattr__
    func <span class="token operator">=</span> _StdcallFuncPtr<span class="token punctuation">(</span>name<span class="token punctuation">,</span> self<span class="token punctuation">)</span>
AttributeError<span class="token punctuation">:</span> function <span class="token string">'MyOwnFunction'</span> <span class="token operator">not</span> found
<span class="token operator">>></span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>注意：Win32 系统的动态库，比如 <code>kernel32</code> 和 <code>user32</code>，通常会同时导出同一个函数的 ANSI 版本和 UNICODE 版本。UNICODE 版本通常会在名字最后以 <code>W</code> 结尾，而 ANSI 版本的则以 <code>A</code> 结尾。 win32的 <code>GetModuleHandle</code> 函数会根据一个模块名返回一个 <em>模块句柄</em>，该函数暨同时包含这样的两个版本的原型函数，并通过宏 UNICODE 是否定义，来决定宏 <code>GetModuleHandle</code> 导出的是哪个具体函数。</p>
<pre><code>/* ANSI version */
HMODULE GetModuleHandleA(LPCSTR lpModuleName);
/* UNICODE version */
HMODULE GetModuleHandleW(LPCWSTR lpModuleName);</code></pre><p><em>windll</em> 不会通过这样的魔法手段来帮你决定选择哪一种函数，你必须显式的调用 <code>GetModuleHandleA</code> 或 <code>GetModuleHandleW</code>，并分别使用字节对象或字符串对象作参数。</p>
<p>有时候，dlls的导出的函数名不符合 Python 的标识符规范，比如 <code>"??2@YAPAXI@Z"</code>。此时，你必须使用 <code>getattr()</code> 方法来获得该函数。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> getattr<span class="token punctuation">(</span>cdll<span class="token punctuation">.</span>msvcrt<span class="token punctuation">,</span> <span class="token string">"??2@YAPAXI@Z"</span><span class="token punctuation">)</span>  
<span class="token operator">&lt;</span>_FuncPtr object at 0x<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">></span>
<span class="token operator">>></span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>Windows 下，有些 dll 导出的函数没有函数名，而是通过其顺序号调用。对此类函数，你也可以通过 dll 对象的数值索引来操作这些函数。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> cdll<span class="token punctuation">.</span>kernel32<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>  
<span class="token operator">&lt;</span>_FuncPtr object at 0x<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">></span>
<span class="token operator">>></span><span class="token operator">></span> cdll<span class="token punctuation">.</span>kernel32<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>  
Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>
  File <span class="token string">"&lt;stdin>"</span><span class="token punctuation">,</span> line <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">></span>
  File <span class="token string">"ctypes.py"</span><span class="token punctuation">,</span> line <span class="token number">310</span><span class="token punctuation">,</span> <span class="token keyword">in</span> __getitem__
    func <span class="token operator">=</span> _StdcallFuncPtr<span class="token punctuation">(</span>name<span class="token punctuation">,</span> self<span class="token punctuation">)</span>
AttributeError<span class="token punctuation">:</span> function ordinal <span class="token number">0</span> <span class="token operator">not</span> found
<span class="token operator">>></span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h4><p>你可以貌似是调用其它 Python 函数那样直接调用这些函数。在这个例子中，我们调用了 <code>time()</code> 函数，该函数返回一个系统时间戳（从 Unix 时间起点到现在的秒数），而<code>GetModuleHandleA()</code> 函数返回一个 win32 模块句柄。</p>
<p>此函数中调用的两个函数都使用了空指针（用 <code>None</code> 作为空指针）:</p>
<pre><code>&gt;&gt;&gt; print(libc.time(None))  
1150640792
&gt;&gt;&gt; print(hex(windll.kernel32.GetModuleHandleA(None)))  
0x1d000000
&gt;&gt;&gt;</code></pre><p>如果你用 <code>cdecl</code> 调用方式调用 <code>stdcall</code> 约定的函数，则会甩出一个异常 <code>ValueError</code>。反之亦然。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> cdll<span class="token punctuation">.</span>kernel32<span class="token punctuation">.</span>GetModuleHandleA<span class="token punctuation">(</span>None<span class="token punctuation">)</span>  
Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>
  File <span class="token string">"&lt;stdin>"</span><span class="token punctuation">,</span> line <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">></span>
ValueError<span class="token punctuation">:</span> Procedure probably called <span class="token keyword">with</span> <span class="token operator">not</span> enough arguments <span class="token punctuation">(</span><span class="token number">4</span> bytes missing<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span>
<span class="token operator">>></span><span class="token operator">></span> windll<span class="token punctuation">.</span>msvcrt<span class="token punctuation">.</span>printf<span class="token punctuation">(</span>b<span class="token string">"spam"</span><span class="token punctuation">)</span>  
Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>
  File <span class="token string">"&lt;stdin>"</span><span class="token punctuation">,</span> line <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">></span>
ValueError<span class="token punctuation">:</span> Procedure probably called <span class="token keyword">with</span> too many arguments <span class="token punctuation">(</span><span class="token number">4</span> bytes <span class="token keyword">in</span> excess<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>你必须阅读这些库的头文件或说明文档来确定它们的正确的调用协议。</p>
<p>在 Windows 中，<code>ctypes</code> 使用 win32 结构化异常处理来防止由于在调用函数时使用非法参数导致的程序崩溃。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> windll<span class="token punctuation">.</span>kernel32<span class="token punctuation">.</span>GetModuleHandleA<span class="token punctuation">(</span><span class="token number">32</span><span class="token punctuation">)</span>  
Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>
  File <span class="token string">"&lt;stdin>"</span><span class="token punctuation">,</span> line <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">></span>
OSError<span class="token punctuation">:</span> exception<span class="token punctuation">:</span> access violation reading <span class="token number">0x00000020</span>
<span class="token operator">>></span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>然而，总有许多办法，通过调用 <code>ctypes</code> 使得 Python 程序崩溃。因此，你必须小心使用。 <code>faulthandler</code> 模块可以用于帮助诊断程序崩溃的原因。（比如由于错误的C库函数调用导致的段错误）。</p>
<p><code>None</code>，整型，字节对象和（UNICODE）字符串是仅有的可以直接作为函数参数使用的四种Python本地数据类型。None<code>作为C的空指针 (</code>NULL`)，字节和字符串类型作为一个指向其保存数据的内存块指针 （char* 或 wchar_t*)。Python 的整型则作为平台默认的C的 int 类型，他们的数值被截断以适应C类型的整型长度。</p>
<p>在我们开始调用函数前，我们必须先了解作为函数参数的 <code>ctypes</code> 数据类型。</p>
<h4 id="基础数据类型"><a href="#基础数据类型" class="headerlink" title="基础数据类型"></a>基础数据类型</h4><p><code>ctypes</code> 定义了一些和C兼容的基本数据类型：</p>
<table>
<thead>
<tr>
<th align="left">ctypes 类型</th>
<th align="left">C 类型</th>
<th align="left">Python 类型</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>c_bool</code></td>
<td align="left">_Bool</td>
<td align="left">bool (1)</td>
</tr>
<tr>
<td align="left"><code>c_char</code></td>
<td align="left">char</td>
<td align="left">单字符字节串对象</td>
</tr>
<tr>
<td align="left"><code>c_wchar</code></td>
<td align="left"><code>wchar_t</code></td>
<td align="left">单字符字符串</td>
</tr>
<tr>
<td align="left"><code>c_byte</code></td>
<td align="left">char</td>
<td align="left">int</td>
</tr>
<tr>
<td align="left"><code>c_ubyte</code></td>
<td align="left">unsigned char</td>
<td align="left">int</td>
</tr>
<tr>
<td align="left"><code>c_short</code></td>
<td align="left">short</td>
<td align="left">int</td>
</tr>
<tr>
<td align="left"><code>c_ushort</code></td>
<td align="left">unsigned short</td>
<td align="left">int</td>
</tr>
<tr>
<td align="left"><code>c_int</code></td>
<td align="left">int</td>
<td align="left">int</td>
</tr>
<tr>
<td align="left"><code>c_uint</code></td>
<td align="left">unsigned int</td>
<td align="left">int</td>
</tr>
<tr>
<td align="left"><code>c_long</code></td>
<td align="left">long</td>
<td align="left">int</td>
</tr>
<tr>
<td align="left"><code>c_ulong</code></td>
<td align="left">unsigned long</td>
<td align="left">int</td>
</tr>
<tr>
<td align="left"><code>c_longlong</code></td>
<td align="left"><code>int64</code> 或 long long</td>
<td align="left">int</td>
</tr>
<tr>
<td align="left"><code>c_ulonglong</code></td>
<td align="left">unsigned int64 或 unsigned long long</td>
<td align="left">int</td>
</tr>
<tr>
<td align="left"><code>c_size_t</code></td>
<td align="left"><code>size_t</code></td>
<td align="left">int</td>
</tr>
<tr>
<td align="left"><code>c_ssize_t</code></td>
<td align="left"><code>ssize_t</code> 或 <code>Py_ssize_t</code></td>
<td align="left">int</td>
</tr>
<tr>
<td align="left"><code>c_float</code></td>
<td align="left">float</td>
<td align="left">float</td>
</tr>
<tr>
<td align="left"><code>c_double</code></td>
<td align="left">double</td>
<td align="left">float</td>
</tr>
<tr>
<td align="left"><code>c_longdouble</code></td>
<td align="left">long double</td>
<td align="left">float</td>
</tr>
<tr>
<td align="left"><code>c_char_p</code></td>
<td align="left">char <em>(以 NUL 结尾)</em></td>
<td align="left">字节串对象或 <code>None</code></td>
</tr>
<tr>
<td align="left"><code>c_wchar_p</code></td>
<td align="left">wchar_t (以 NUL 结尾)</td>
<td align="left">字符串或 <code>None</code></td>
</tr>
<tr>
<td align="left"><code>c_void_p</code></td>
<td align="left">void*</td>
<td align="left">int 或 <code>None</code></td>
</tr>
</tbody></table>
<ol>
<li>构造函数接受任何具有真值的对象。</li>
</ol>
<p>所有这些类型都可以通过使用正确类型和值的可选初始值调用它们来创建:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> c_int<span class="token punctuation">(</span><span class="token punctuation">)</span>
c_long<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> c_wchar_p<span class="token punctuation">(</span><span class="token string">"Hello, World"</span><span class="token punctuation">)</span>
c_wchar_p<span class="token punctuation">(</span><span class="token number">140018365411392</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> c_ushort<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">)</span>
c_ushort<span class="token punctuation">(</span><span class="token number">65533</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>由于这些类型是可变的，它们的值也可以在以后更改:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> i <span class="token operator">=</span> c_int<span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>
c_long<span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>i<span class="token punctuation">.</span>value<span class="token punctuation">)</span>
<span class="token number">42</span>
<span class="token operator">>></span><span class="token operator">></span> i<span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">99</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>i<span class="token punctuation">.</span>value<span class="token punctuation">)</span>
<span class="token operator">-</span><span class="token number">99</span>
<span class="token operator">>></span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>当给指针类型的对象 <code>c_char_p</code>, <code>c_wchar_p</code> 和 <code>c_void_p</code> 等赋值时，将改变它们所指向的 <em>内存地址*，而 *不是</em> 它们所指向的内存区域的 <em>内容</em> (这是理所当然的，因为 Python 的 bytes 对象是不可变的):</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> s <span class="token operator">=</span> <span class="token string">"Hello, World"</span>
<span class="token operator">>></span><span class="token operator">></span> c_s <span class="token operator">=</span> c_wchar_p<span class="token punctuation">(</span>s<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>c_s<span class="token punctuation">)</span>
c_wchar_p<span class="token punctuation">(</span><span class="token number">139966785747344</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>c_s<span class="token punctuation">.</span>value<span class="token punctuation">)</span>
Hello World
<span class="token operator">>></span><span class="token operator">></span> c_s<span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token string">"Hi, there"</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>c_s<span class="token punctuation">)</span>              <span class="token comment" spellcheck="true"># the memory location has changed</span>
c_wchar_p<span class="token punctuation">(</span><span class="token number">139966783348904</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>c_s<span class="token punctuation">.</span>value<span class="token punctuation">)</span>
Hi<span class="token punctuation">,</span> there
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span>                <span class="token comment" spellcheck="true"># first object is unchanged</span>
Hello<span class="token punctuation">,</span> World
<span class="token operator">>></span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>但你要注意不能将它们传递给会改变指针所指内存的函数。如果你需要可改变的内存块，ctypes 提供了 <code>create_string_buffer()</code> 函数，它提供多种方式创建这种内存块。当前的内存块内容可以通过 <code>raw</code> 属性存取，如果你希望将它作为NUL结束的字符串，请使用 <code>value</code> 属性:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> ctypes <span class="token keyword">import</span> <span class="token operator">*</span>
<span class="token operator">>></span><span class="token operator">></span> p <span class="token operator">=</span> create_string_buffer<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>            <span class="token comment" spellcheck="true"># create a 3 byte buffer, initialized to NUL bytes</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>sizeof<span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">,</span> repr<span class="token punctuation">(</span>p<span class="token punctuation">.</span>raw<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token number">3</span> b<span class="token string">'\x00\x00\x00'</span>
<span class="token operator">>></span><span class="token operator">></span> p <span class="token operator">=</span> create_string_buffer<span class="token punctuation">(</span>b<span class="token string">"Hello"</span><span class="token punctuation">)</span>     <span class="token comment" spellcheck="true"># create a buffer containing a NUL terminated string</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>sizeof<span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">,</span> repr<span class="token punctuation">(</span>p<span class="token punctuation">.</span>raw<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token number">6</span> b<span class="token string">'Hello\x00'</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>repr<span class="token punctuation">(</span>p<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span>
b<span class="token string">'Hello'</span>
<span class="token operator">>></span><span class="token operator">></span> p <span class="token operator">=</span> create_string_buffer<span class="token punctuation">(</span>b<span class="token string">"Hello"</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># create a 10 byte buffer</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>sizeof<span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">,</span> repr<span class="token punctuation">(</span>p<span class="token punctuation">.</span>raw<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token number">10</span> b<span class="token string">'Hello\x00\x00\x00\x00\x00'</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>value <span class="token operator">=</span> b<span class="token string">"Hi"</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>sizeof<span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">,</span> repr<span class="token punctuation">(</span>p<span class="token punctuation">.</span>raw<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token number">10</span> b<span class="token string">'Hi\x00lo\x00\x00\x00\x00\x00'</span>
<span class="token operator">>></span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>create_string_buffer()</code> 函数替代以前的ctypes版本中的 <code>c_buffer()</code> 函数 (仍然可当作别名使用)和 <code>c_string()</code> 函数。<code>create_unicode_buffer()</code> 函数创建包含 unicode 字符的可变内存块，与之对应的C语言类型是 <code>wchar_t</code>。</p>
<h4 id="调用函数，继续"><a href="#调用函数，继续" class="headerlink" title="调用函数，继续"></a>调用函数，继续</h4><p>注意 printf 将打印到真正标准输出设备，而<em>不是</em> <code>sys.stdout</code>，因此这些实例只能在控制台提示符下工作，而不能在 <em>IDLE</em> 或 <em>PythonWin</em> 中运行。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> printf <span class="token operator">=</span> libc<span class="token punctuation">.</span>printf
<span class="token operator">>></span><span class="token operator">></span> printf<span class="token punctuation">(</span>b<span class="token string">"Hello, %s\n"</span><span class="token punctuation">,</span> b<span class="token string">"World!"</span><span class="token punctuation">)</span>
Hello<span class="token punctuation">,</span> World!
<span class="token number">14</span>
<span class="token operator">>></span><span class="token operator">></span> printf<span class="token punctuation">(</span>b<span class="token string">"Hello, %S\n"</span><span class="token punctuation">,</span> <span class="token string">"World!"</span><span class="token punctuation">)</span>
Hello<span class="token punctuation">,</span> World!
<span class="token number">14</span>
<span class="token operator">>></span><span class="token operator">></span> printf<span class="token punctuation">(</span>b<span class="token string">"%d bottles of beer\n"</span><span class="token punctuation">,</span> <span class="token number">42</span><span class="token punctuation">)</span>
<span class="token number">42</span> bottles of beer
<span class="token number">19</span>
<span class="token operator">>></span><span class="token operator">></span> printf<span class="token punctuation">(</span>b<span class="token string">"%f bottles of beer\n"</span><span class="token punctuation">,</span> <span class="token number">42.5</span><span class="token punctuation">)</span>
Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>
  File <span class="token string">"&lt;stdin>"</span><span class="token punctuation">,</span> line <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">></span>
ArgumentError<span class="token punctuation">:</span> argument <span class="token number">2</span><span class="token punctuation">:</span> exceptions<span class="token punctuation">.</span>TypeError<span class="token punctuation">:</span> Don't know how to convert parameter <span class="token number">2</span>
<span class="token operator">>></span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>正如前面所提到过的，除了整数、字符串以及字节串之外，所有的 Python 类型都必须使用它们对应的 <code>ctypes</code> 类型包装，才能够被正确地转换为所需的C语言类型。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> printf<span class="token punctuation">(</span>b<span class="token string">"An int %d, a double %f\n"</span><span class="token punctuation">,</span> <span class="token number">1234</span><span class="token punctuation">,</span> c_double<span class="token punctuation">(</span><span class="token number">3.14</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
An int <span class="token number">1234</span><span class="token punctuation">,</span> a double <span class="token number">3.140000</span>
<span class="token number">31</span>
<span class="token operator">>></span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="使用自定义的数据类型调用函数"><a href="#使用自定义的数据类型调用函数" class="headerlink" title="使用自定义的数据类型调用函数"></a>使用自定义的数据类型调用函数</h4><p>你也可以通过自定义 <code>ctypes</code> 参数转换方式来允许自定义类型作为参数。 <code>ctypes</code> 会寻找 <code>_as_parameter_</code> 属性并使用它作为函数参数。当然，它必须是数字、字符串或者二进制字符串:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">class</span> <span class="token class-name">Bottles</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> number<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         self<span class="token punctuation">.</span>_as_parameter_ <span class="token operator">=</span> number
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> bottles <span class="token operator">=</span> Bottles<span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> printf<span class="token punctuation">(</span>b<span class="token string">"%d bottles of beer\n"</span><span class="token punctuation">,</span> bottles<span class="token punctuation">)</span>
<span class="token number">42</span> bottles of beer
<span class="token number">19</span>
<span class="token operator">>></span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果你不想把实例的数据存储到 <code>_as_parameter_</code> 属性。可以通过定义 <code>property</code> 函数计算出这个属性。</p>
<h4 id="指定必选参数的类型-函数原型"><a href="#指定必选参数的类型-函数原型" class="headerlink" title="指定必选参数的类型(函数原型)"></a>指定必选参数的类型(函数原型)</h4><p>可以通过设置 <code>argtypes</code> 属性的方法指定从 DLL 中导出函数的必选参数类型。</p>
<p><code>argtypes</code> 必须是一个 C 数据类型的序列 (这里的 <code>printf</code> 可能不是个好例子，因为它是变长参数，而且每个参数的类型依赖于格式化字符串，不过尝试这个功能也很方便):</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> printf<span class="token punctuation">.</span>argtypes <span class="token operator">=</span> <span class="token punctuation">[</span>c_char_p<span class="token punctuation">,</span> c_char_p<span class="token punctuation">,</span> c_int<span class="token punctuation">,</span> c_double<span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> printf<span class="token punctuation">(</span>b<span class="token string">"String '%s', Int %d, Double %f\n"</span><span class="token punctuation">,</span> b<span class="token string">"Hi"</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">2.2</span><span class="token punctuation">)</span>
String <span class="token string">'Hi'</span><span class="token punctuation">,</span> Int <span class="token number">10</span><span class="token punctuation">,</span> Double <span class="token number">2.200000</span>
<span class="token number">37</span>
<span class="token operator">>></span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>指定数据类型可以防止不合理的参数传递（就像 C 函数的原型），并且会自动尝试将参数转换为需要的类型:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> printf<span class="token punctuation">(</span>b<span class="token string">"%d %d %d"</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span>
Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>
  File <span class="token string">"&lt;stdin>"</span><span class="token punctuation">,</span> line <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">></span>
ArgumentError<span class="token punctuation">:</span> argument <span class="token number">2</span><span class="token punctuation">:</span> exceptions<span class="token punctuation">.</span>TypeError<span class="token punctuation">:</span> wrong type
<span class="token operator">>></span><span class="token operator">></span> printf<span class="token punctuation">(</span>b<span class="token string">"%s %d %f\n"</span><span class="token punctuation">,</span> b<span class="token string">"X"</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span>
X <span class="token number">2</span> <span class="token number">3.000000</span>
<span class="token number">13</span>
<span class="token operator">>></span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果你想通过自定义类型传递参数给函数，必须实现 <code>from_param()</code> 类方法，才能够将此自定义类型用于 <code>argtypes</code> 序列。<code>from_param()</code> 类方法接受一个 Python 对象作为函数输入，它应该进行类型检查或者其他必要的操作以保证接收到的对象是合法的，然后返回这个对象，或者它的 <code>_as_parameter_</code> 属性，或者其他你想要传递给 C 函数的参数。这里也一样，返回的结果必须是整型、字符串、二进制字符串、 <code>ctypes</code> 类型，或者一个具有 <code>_as_parameter_</code> 属性的对象。</p>
<h4 id="返回类型"><a href="#返回类型" class="headerlink" title="返回类型"></a>返回类型</h4><p>默认情况下都会假定函数返回 C int 类型。 其他返回类型可以通过设置函数对象的 <code>restype</code> 属性来指定。</p>
<p>这是个更高级的例子，它调用了 <code>strchr</code> 函数，这个函数接收一个字符串指针以及一个字符作为参数，返回另一个字符串指针。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> strchr <span class="token operator">=</span> libc<span class="token punctuation">.</span>strchr
<span class="token operator">>></span><span class="token operator">></span> strchr<span class="token punctuation">(</span>b<span class="token string">"abcdef"</span><span class="token punctuation">,</span> ord<span class="token punctuation">(</span><span class="token string">"d"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  
<span class="token number">8059983</span>
<span class="token operator">>></span><span class="token operator">></span> strchr<span class="token punctuation">.</span>restype <span class="token operator">=</span> c_char_p    <span class="token comment" spellcheck="true"># c_char_p is a pointer to a string</span>
<span class="token operator">>></span><span class="token operator">></span> strchr<span class="token punctuation">(</span>b<span class="token string">"abcdef"</span><span class="token punctuation">,</span> ord<span class="token punctuation">(</span><span class="token string">"d"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
b<span class="token string">'def'</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>strchr<span class="token punctuation">(</span>b<span class="token string">"abcdef"</span><span class="token punctuation">,</span> ord<span class="token punctuation">(</span><span class="token string">"x"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
None
<span class="token operator">>></span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果希望避免上述的 <code>ord("x")</code> 调用，可以设置 <code>argtypes</code> 属性，第二个参数就会将单字符的 Python 二进制字符对象转换为 C 字符:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> strchr<span class="token punctuation">.</span>restype <span class="token operator">=</span> c_char_p
<span class="token operator">>></span><span class="token operator">></span> strchr<span class="token punctuation">.</span>argtypes <span class="token operator">=</span> <span class="token punctuation">[</span>c_char_p<span class="token punctuation">,</span> c_char<span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> strchr<span class="token punctuation">(</span>b<span class="token string">"abcdef"</span><span class="token punctuation">,</span> b<span class="token string">"d"</span><span class="token punctuation">)</span>
<span class="token string">'def'</span>
<span class="token operator">>></span><span class="token operator">></span> strchr<span class="token punctuation">(</span>b<span class="token string">"abcdef"</span><span class="token punctuation">,</span> b<span class="token string">"def"</span><span class="token punctuation">)</span>
Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>
  File <span class="token string">"&lt;stdin>"</span><span class="token punctuation">,</span> line <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">></span>
ArgumentError<span class="token punctuation">:</span> argument <span class="token number">2</span><span class="token punctuation">:</span> exceptions<span class="token punctuation">.</span>TypeError<span class="token punctuation">:</span> one character string expected
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>strchr<span class="token punctuation">(</span>b<span class="token string">"abcdef"</span><span class="token punctuation">,</span> b<span class="token string">"x"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
None
<span class="token operator">>></span><span class="token operator">></span> strchr<span class="token punctuation">(</span>b<span class="token string">"abcdef"</span><span class="token punctuation">,</span> b<span class="token string">"d"</span><span class="token punctuation">)</span>
<span class="token string">'def'</span>
<span class="token operator">>></span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果外部函数返回了一个整数，你也可以使用要给可调用的 Python 对象（比如函数或者类）作为 <code>restype</code> 属性的值。将会以 C 函数返回的 <em>整数</em> 对象作为参数调用这个可调用对象，执行后的结果作为最终函数返回值。这在错误返回值校验和自动抛出异常等方面比较有用。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> GetModuleHandle <span class="token operator">=</span> windll<span class="token punctuation">.</span>kernel32<span class="token punctuation">.</span>GetModuleHandleA  
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">def</span> <span class="token function">ValidHandle</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">if</span> value <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         <span class="token keyword">raise</span> WinError<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">return</span> value
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span>
<span class="token operator">>></span><span class="token operator">></span> GetModuleHandle<span class="token punctuation">.</span>restype <span class="token operator">=</span> ValidHandle  
<span class="token operator">>></span><span class="token operator">></span> GetModuleHandle<span class="token punctuation">(</span>None<span class="token punctuation">)</span>  
<span class="token number">486539264</span>
<span class="token operator">>></span><span class="token operator">></span> GetModuleHandle<span class="token punctuation">(</span><span class="token string">"something silly"</span><span class="token punctuation">)</span>  
Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>
  File <span class="token string">"&lt;stdin>"</span><span class="token punctuation">,</span> line <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">></span>
  File <span class="token string">"&lt;stdin>"</span><span class="token punctuation">,</span> line <span class="token number">3</span><span class="token punctuation">,</span> <span class="token keyword">in</span> ValidHandle
OSError<span class="token punctuation">:</span> <span class="token punctuation">[</span>Errno <span class="token number">126</span><span class="token punctuation">]</span> The specified module could <span class="token operator">not</span> be found<span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>WinError</code> 函数可以调用 Windows 的 <code>FormatMessage()</code> API 获取错误码的字符串说明，然后 <em>返回</em> 一个异常。 <code>WinError</code> 接收一个可选的错误码作为参数，如果没有的话，它将调用 <code>GetLastError()</code> 获取错误码。</p>
<p>请注意，使用 <code>errcheck</code> 属性可以实现更强大的错误检查手段；详情请见参考手册。</p>
<h4 id="传递指针（或以引用方式传递形参）"><a href="#传递指针（或以引用方式传递形参）" class="headerlink" title="传递指针（或以引用方式传递形参）"></a>传递指针（或以引用方式传递形参）</h4><p>有时候 C 函数接口可能由于要往某个地址写入值，或者数据太大不适合作为值传递，从而希望接收一个 <em>指针</em> 作为数据参数类型。这和 <em>传递参数引用</em> 类似。</p>
<p><code>ctypes</code> 暴露了 <code>byref()</code> 函数用于通过引用传递参数，使用 <code>pointer()</code> 函数也能达到同样的效果，只不过 <code>pointer()</code> 需要更多步骤，因为它要先构造一个真实指针对象。所以在 Python 代码本身不需要使用这个指针对象的情况下，使用 <code>byref()</code> 效率更高。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> i <span class="token operator">=</span> c_int<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> f <span class="token operator">=</span> c_float<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> s <span class="token operator">=</span> create_string_buffer<span class="token punctuation">(</span>b<span class="token string">'\000'</span> <span class="token operator">*</span> <span class="token number">32</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>i<span class="token punctuation">.</span>value<span class="token punctuation">,</span> f<span class="token punctuation">.</span>value<span class="token punctuation">,</span> repr<span class="token punctuation">(</span>s<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token number">0</span> <span class="token number">0.0</span> b<span class="token string">''</span>
<span class="token operator">>></span><span class="token operator">></span> libc<span class="token punctuation">.</span>sscanf<span class="token punctuation">(</span>b<span class="token string">"1 3.14 Hello"</span><span class="token punctuation">,</span> b<span class="token string">"%d %f %s"</span><span class="token punctuation">,</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>             byref<span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">,</span> byref<span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">,</span> s<span class="token punctuation">)</span>
<span class="token number">3</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>i<span class="token punctuation">.</span>value<span class="token punctuation">,</span> f<span class="token punctuation">.</span>value<span class="token punctuation">,</span> repr<span class="token punctuation">(</span>s<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token number">1</span> <span class="token number">3.1400001049</span> b<span class="token string">'Hello'</span>
<span class="token operator">>></span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="结构体和联合"><a href="#结构体和联合" class="headerlink" title="结构体和联合"></a>结构体和联合</h4><p>结构体和联合必须继承自 <code>ctypes</code> 模块中的 <code>Structure</code> 和 <code>Union</code> 。子类必须定义 <code>_fields_</code> 属性。 <code>_fields_</code> 是一个二元组列表，二元组中包含 <em>field name</em> 和 <em>field type</em> 。</p>
<p>type 字段必须是一个 <code>ctypes</code> 类型，比如 <code>c_int</code>，或者其他 <code>ctypes</code> 类型: 结构体、联合、数组、指针。</p>
<p>这是一个简单的 POINT 结构体，它包含名称为 <em>x</em> 和 <em>y</em> 的两个变量，还展示了如何通过构造函数初始化结构体。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> ctypes <span class="token keyword">import</span> <span class="token operator">*</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">class</span> <span class="token class-name">POINT</span><span class="token punctuation">(</span>Structure<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     _fields_ <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token string">"x"</span><span class="token punctuation">,</span> c_int<span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                 <span class="token punctuation">(</span><span class="token string">"y"</span><span class="token punctuation">,</span> c_int<span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> point <span class="token operator">=</span> POINT<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>point<span class="token punctuation">.</span>x<span class="token punctuation">,</span> point<span class="token punctuation">.</span>y<span class="token punctuation">)</span>
<span class="token number">10</span> <span class="token number">20</span>
<span class="token operator">>></span><span class="token operator">></span> point <span class="token operator">=</span> POINT<span class="token punctuation">(</span>y<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>point<span class="token punctuation">.</span>x<span class="token punctuation">,</span> point<span class="token punctuation">.</span>y<span class="token punctuation">)</span>
<span class="token number">0</span> <span class="token number">5</span>
<span class="token operator">>></span><span class="token operator">></span> POINT<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span>
Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>
  File <span class="token string">"&lt;stdin>"</span><span class="token punctuation">,</span> line <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">></span>
TypeError<span class="token punctuation">:</span> too many initializers
<span class="token operator">>></span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>当然，你可以构造更复杂的结构体。一个结构体可以通过设置 type 字段包含其他结构体或者自身。</p>
<p>这是以一个 RECT 结构体，他包含了两个 POINT ，分别叫 <em>upperleft</em> 和 <em>lowerright</em>:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">class</span> <span class="token class-name">RECT</span><span class="token punctuation">(</span>Structure<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     _fields_ <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token string">"upperleft"</span><span class="token punctuation">,</span> POINT<span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                 <span class="token punctuation">(</span><span class="token string">"lowerright"</span><span class="token punctuation">,</span> POINT<span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> rc <span class="token operator">=</span> RECT<span class="token punctuation">(</span>point<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>rc<span class="token punctuation">.</span>upperleft<span class="token punctuation">.</span>x<span class="token punctuation">,</span> rc<span class="token punctuation">.</span>upperleft<span class="token punctuation">.</span>y<span class="token punctuation">)</span>
<span class="token number">0</span> <span class="token number">5</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>rc<span class="token punctuation">.</span>lowerright<span class="token punctuation">.</span>x<span class="token punctuation">,</span> rc<span class="token punctuation">.</span>lowerright<span class="token punctuation">.</span>y<span class="token punctuation">)</span>
<span class="token number">0</span> <span class="token number">0</span>
<span class="token operator">>></span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>嵌套结构体可以通过几种方式构造初始化:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> r <span class="token operator">=</span> RECT<span class="token punctuation">(</span>POINT<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> POINT<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> r <span class="token operator">=</span> RECT<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>可以通过 <em>类</em> 获取字段 descriptor ，它能提供很多有用的调试信息。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>POINT<span class="token punctuation">.</span>x<span class="token punctuation">)</span>
<span class="token operator">&lt;</span>Field type<span class="token operator">=</span>c_long<span class="token punctuation">,</span> ofs<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> size<span class="token operator">=</span><span class="token number">4</span><span class="token operator">></span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>POINT<span class="token punctuation">.</span>y<span class="token punctuation">)</span>
<span class="token operator">&lt;</span>Field type<span class="token operator">=</span>c_long<span class="token punctuation">,</span> ofs<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">,</span> size<span class="token operator">=</span><span class="token number">4</span><span class="token operator">></span>
<span class="token operator">>></span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>警告</p>
<p><code>ctypes</code> 不支持带位域的结构体、联合以值的方式传给函数。这可能在 32 位 x86 平台上可以正常工作，但是对于一般情况，这种行为是未定义的。带位域的结构体、联合应该总是通过指针传递给函数。</p>
<h4 id="结构体-联合字段对齐及字节顺序"><a href="#结构体-联合字段对齐及字节顺序" class="headerlink" title="结构体/联合字段对齐及字节顺序"></a>结构体/联合字段对齐及字节顺序</h4><p>默认情况下，结构体和联合的字段与 C 的字节对齐是一样的。也可以在定义子类的时候指定类的 <code>_pack_</code> 属性来覆盖这种行为。 它必须设置为一个正整数，表示字段的最大对齐字节。这和 MSVC 中的 <code>#pragma pack(n)</code> 功能一样。</p>
<p><code>ctypes</code> 中的结构体和联合使用的是本地字节序。要使用非本地字节序，可以使用 <code>BigEndianStructure</code>, <code>LittleEndianStructure</code>, <code>BigEndianUnion</code>, and <code>LittleEndianUnion</code> 作为基类。这些类不能包含指针字段。</p>
<h4 id="结构体和联合中的位域"><a href="#结构体和联合中的位域" class="headerlink" title="结构体和联合中的位域"></a>结构体和联合中的位域</h4><p>结构体和联合中是可以包含位域字段的。位域只能用于整型字段，位长度通过 <code>_fields_</code> 中的第三个参数指定:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">class</span> <span class="token class-name">Int</span><span class="token punctuation">(</span>Structure<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     _fields_ <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token string">"first_16"</span><span class="token punctuation">,</span> c_int<span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                 <span class="token punctuation">(</span><span class="token string">"second_16"</span><span class="token punctuation">,</span> c_int<span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>Int<span class="token punctuation">.</span>first_16<span class="token punctuation">)</span>
<span class="token operator">&lt;</span>Field type<span class="token operator">=</span>c_long<span class="token punctuation">,</span> ofs<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">,</span> bits<span class="token operator">=</span><span class="token number">16</span><span class="token operator">></span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>Int<span class="token punctuation">.</span>second_16<span class="token punctuation">)</span>
<span class="token operator">&lt;</span>Field type<span class="token operator">=</span>c_long<span class="token punctuation">,</span> ofs<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token number">16</span><span class="token punctuation">,</span> bits<span class="token operator">=</span><span class="token number">16</span><span class="token operator">></span>
<span class="token operator">>></span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>数组是一个序列，包含指定个数元素，且必须类型相同。</p>
<p>创建数组类型的推荐方式是使用一个类型乘以一个正数:</p>
<pre class="line-numbers language-python"><code class="language-python">TenPointsArrayType <span class="token operator">=</span> POINT <span class="token operator">*</span> <span class="token number">10</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>下面是一个构造的数据案例，结构体中包含了4个 POINT 和一些其他东西。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> ctypes <span class="token keyword">import</span> <span class="token operator">*</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">class</span> <span class="token class-name">POINT</span><span class="token punctuation">(</span>Structure<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     _fields_ <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token string">"x"</span><span class="token punctuation">,</span> c_int<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">"y"</span><span class="token punctuation">,</span> c_int<span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">class</span> <span class="token class-name">MyStruct</span><span class="token punctuation">(</span>Structure<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     _fields_ <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">,</span> c_int<span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                 <span class="token punctuation">(</span><span class="token string">"b"</span><span class="token punctuation">,</span> c_float<span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                 <span class="token punctuation">(</span><span class="token string">"point_array"</span><span class="token punctuation">,</span> POINT <span class="token operator">*</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>len<span class="token punctuation">(</span>MyStruct<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>point_array<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token number">4</span>
<span class="token operator">>></span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>和平常一样，通过调用它创建实例:</p>
<pre class="line-numbers language-python"><code class="language-python">arr <span class="token operator">=</span> TenPointsArrayType<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">for</span> pt <span class="token keyword">in</span> arr<span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>pt<span class="token punctuation">.</span>x<span class="token punctuation">,</span> pt<span class="token punctuation">.</span>y<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>以上代码会打印几行 <code>0 0</code> ，因为数组内容被初始化为 0.</p>
<p>也能通过指定正确类型的数据来初始化:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> ctypes <span class="token keyword">import</span> <span class="token operator">*</span>
<span class="token operator">>></span><span class="token operator">></span> TenIntegers <span class="token operator">=</span> c_int <span class="token operator">*</span> <span class="token number">10</span>
<span class="token operator">>></span><span class="token operator">></span> ii <span class="token operator">=</span> TenIntegers<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>ii<span class="token punctuation">)</span>
<span class="token operator">&lt;</span>c_long_Array_10 object at 0x<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">></span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">for</span> i <span class="token keyword">in</span> ii<span class="token punctuation">:</span> <span class="token keyword">print</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> end<span class="token operator">=</span><span class="token string">" "</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span> <span class="token number">5</span> <span class="token number">6</span> <span class="token number">7</span> <span class="token number">8</span> <span class="token number">9</span> <span class="token number">10</span>
<span class="token operator">>></span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h4><p>可以将 <code>ctypes</code> 类型数据传入 <code>pointer()</code> 函数创建指针:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> ctypes <span class="token keyword">import</span> <span class="token operator">*</span>
<span class="token operator">>></span><span class="token operator">></span> i <span class="token operator">=</span> c_int<span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> pi <span class="token operator">=</span> pointer<span class="token punctuation">(</span>i<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>指针实例拥有 <code>contents</code> 属性，它返回指针指向的真实对象，如上面的 <code>i</code> 对象:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> pi<span class="token punctuation">.</span>contents
c_long<span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>注意 <code>ctypes</code> 并没有 OOR （返回原始对象）, 每次访问这个属性时都会构造返回一个新的相同对象:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> pi<span class="token punctuation">.</span>contents <span class="token keyword">is</span> i
<span class="token boolean">False</span>
<span class="token operator">>></span><span class="token operator">></span> pi<span class="token punctuation">.</span>contents <span class="token keyword">is</span> pi<span class="token punctuation">.</span>contents
<span class="token boolean">False</span>
<span class="token operator">>></span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>将这个指针的 contents 属性赋值为另一个 <code>c_int</code> 实例将会导致该指针指向该实例的内存地址:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> i <span class="token operator">=</span> c_int<span class="token punctuation">(</span><span class="token number">99</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> pi<span class="token punctuation">.</span>contents <span class="token operator">=</span> i
<span class="token operator">>></span><span class="token operator">></span> pi<span class="token punctuation">.</span>contents
c_long<span class="token punctuation">(</span><span class="token number">99</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>指针对象也可以通过整数下标进行访问:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> pi<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
<span class="token number">99</span>
<span class="token operator">>></span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>通过整数下标赋值可以改变指针所指向的真实内容:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>
c_long<span class="token punctuation">(</span><span class="token number">99</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> pi<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">22</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>
c_long<span class="token punctuation">(</span><span class="token number">22</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>使用 0 以外的索引也是合法的，但是你必须确保知道自己为什么这么做，就像 C 语言中: 你可以访问或者修改任意内存内容。 通常只会在函数接收指针是才会使用这种特性，而且你 <em>知道</em> 这个指针指向的是一个数组而不是单个值。</p>
<p>内部细节, <code>pointer()</code> 函数不只是创建了一个指针实例，它首先创建了一个指针 <em>类型</em> 。这是通过调用 <code>POINTER()</code> 函数实现的，它接收 <code>ctypes</code> 类型为参数，返回一个新的类型:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> PI <span class="token operator">=</span> POINTER<span class="token punctuation">(</span>c_int<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> PI
<span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token string">'ctypes.LP_c_long'</span><span class="token operator">></span>
<span class="token operator">>></span><span class="token operator">></span> PI<span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span>
Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>
  File <span class="token string">"&lt;stdin>"</span><span class="token punctuation">,</span> line <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">></span>
TypeError<span class="token punctuation">:</span> expected c_long instead of int
<span class="token operator">>></span><span class="token operator">></span> PI<span class="token punctuation">(</span>c_int<span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token operator">&lt;</span>ctypes<span class="token punctuation">.</span>LP_c_long object at 0x<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">></span>
<span class="token operator">>></span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>无参调用指针类型可以创建一个 <code>NULL</code> 指针。 <code>NULL</code> 指针的布尔值是 <code>False</code></p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> null_ptr <span class="token operator">=</span> POINTER<span class="token punctuation">(</span>c_int<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>bool<span class="token punctuation">(</span>null_ptr<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token boolean">False</span>
<span class="token operator">>></span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>解引用指针的时候， <code>ctypes</code> 会帮你检测是否指针为 <code>NULL</code> (但是解引用无效的 非 <code>NULL</code> 指针仍会导致 Python 崩溃):</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> null_ptr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
ValueError<span class="token punctuation">:</span> NULL pointer access
<span class="token operator">>></span><span class="token operator">></span>
<span class="token operator">>></span><span class="token operator">></span> null_ptr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1234</span>
Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
ValueError<span class="token punctuation">:</span> NULL pointer access
<span class="token operator">>></span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><p>通常情况下, ctypes 具有严格的类型检查。这代表着, 如果在函数 <code>argtypes</code> 中或者结构体定义成员中有 <code>POINTER(c_int)</code> 类型，只有相同类型的实例才会被接受。 也有一些例外。比如，你可以传递兼容的数组实例给指针类型。所以，对于 <code>POINTER(c_int)</code> ，ctypes 也可以接受 c_int 类型的数组:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">class</span> <span class="token class-name">Bar</span><span class="token punctuation">(</span>Structure<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     _fields_ <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token string">"count"</span><span class="token punctuation">,</span> c_int<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">"values"</span><span class="token punctuation">,</span> POINTER<span class="token punctuation">(</span>c_int<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> bar <span class="token operator">=</span> Bar<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> bar<span class="token punctuation">.</span>values <span class="token operator">=</span> <span class="token punctuation">(</span>c_int <span class="token operator">*</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> bar<span class="token punctuation">.</span>count <span class="token operator">=</span> <span class="token number">3</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>bar<span class="token punctuation">.</span>count<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">print</span><span class="token punctuation">(</span>bar<span class="token punctuation">.</span>values<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token number">1</span>
<span class="token number">2</span>
<span class="token number">3</span>
<span class="token operator">>></span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>另外，如果一个函数 <code>argtypes</code> 列表中的参数显式的定义为指针类型(如 <code>POINTER(c_int)</code> )，指针所指向的 类型 (这个例子中是 <code>c_int</code> )也可以传递给函数。ctypes 会自动调用对应的 <code>byref()</code> 转换。</p>
<p>可以给指针内容赋值为 None 将其设置为 <code>Null</code></p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> bar<span class="token punctuation">.</span>values <span class="token operator">=</span> None
<span class="token operator">>></span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>有时候你拥有一个不兼容的类型。 在 C 中，你可以将一个类型强制转换为另一个。 <code>ctypes</code> 中的 a <code>cast()</code> 函数提供了相同的功能。 上面的结构体 <code>Bar</code> 的 <code>value</code> 字段接收 <code>POINTER(c_int)</code> 指针或者 <code>c_int</code> 数组，但是不能接受其他类型的实例:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> bar<span class="token punctuation">.</span>values <span class="token operator">=</span> <span class="token punctuation">(</span>c_byte <span class="token operator">*</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>
  File <span class="token string">"&lt;stdin>"</span><span class="token punctuation">,</span> line <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">></span>
TypeError<span class="token punctuation">:</span> incompatible types<span class="token punctuation">,</span> c_byte_Array_4 instance instead of LP_c_long instance
<span class="token operator">>></span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这种情况下, 需要手动使用 <code>cast()</code> 函数。</p>
<p><code>cast()</code> 函数可以将一个指针实例强制转换为另一种 ctypes 类型。 <code>cast()</code> 接收两个参数，一个 ctypes 指针对象或者可以被转换为指针的其他类型对象，和一个 ctypes 指针类型。 返回第二个类型的一个实例，该返回实例和第一个参数指向同一片内存空间:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> a <span class="token operator">=</span> <span class="token punctuation">(</span>c_byte <span class="token operator">*</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> cast<span class="token punctuation">(</span>a<span class="token punctuation">,</span> POINTER<span class="token punctuation">(</span>c_int<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token operator">&lt;</span>ctypes<span class="token punctuation">.</span>LP_c_long object at <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">></span>
<span class="token operator">>></span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>所以 <code>cast()</code> 可以用来给结构体 <code>Bar</code> 的 <code>values</code> 字段赋值:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> bar <span class="token operator">=</span> Bar<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> bar<span class="token punctuation">.</span>values <span class="token operator">=</span> cast<span class="token punctuation">(</span><span class="token punctuation">(</span>c_byte <span class="token operator">*</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> POINTER<span class="token punctuation">(</span>c_int<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>bar<span class="token punctuation">.</span>values<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token number">0</span>
<span class="token operator">>></span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="不完整类型"><a href="#不完整类型" class="headerlink" title="不完整类型"></a>不完整类型</h4><p><em>不完整类型</em> 即还没有定义成员的结构体、联合或者数组。在 C 中，它们通常用于前置声明，然后在后面定义:</p>
<pre class="line-numbers language-python"><code class="language-python">struct cell<span class="token punctuation">;</span> <span class="token operator">/</span><span class="token operator">*</span> forward declaration <span class="token operator">*</span><span class="token operator">/</span>
struct cell <span class="token punctuation">{</span>
    char <span class="token operator">*</span>name<span class="token punctuation">;</span>
    struct cell <span class="token operator">*</span>next<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>直接翻译成 ctypes 的代码如下，但是这行不通:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">class</span> <span class="token class-name">cell</span><span class="token punctuation">(</span>Structure<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     _fields_ <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">,</span> c_char_p<span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                 <span class="token punctuation">(</span><span class="token string">"next"</span><span class="token punctuation">,</span> POINTER<span class="token punctuation">(</span>cell<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>
  File <span class="token string">"&lt;stdin>"</span><span class="token punctuation">,</span> line <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">></span>
  File <span class="token string">"&lt;stdin>"</span><span class="token punctuation">,</span> line <span class="token number">2</span><span class="token punctuation">,</span> <span class="token keyword">in</span> cell
NameError<span class="token punctuation">:</span> name <span class="token string">'cell'</span> <span class="token keyword">is</span> <span class="token operator">not</span> defined
<span class="token operator">>></span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>因为新的 <code>cell 类</code> 在 class 语句结束之前还没有完成定义。在 <code>ctypes</code> 中，我们可以先定义 <code>cell</code> 类，在 class 语句结束之后再设置 <code>_fields_</code> 属性:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> ctypes <span class="token keyword">import</span> <span class="token operator">*</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">class</span> <span class="token class-name">cell</span><span class="token punctuation">(</span>Structure<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">pass</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> cell<span class="token punctuation">.</span>_fields_ <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">,</span> c_char_p<span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                  <span class="token punctuation">(</span><span class="token string">"next"</span><span class="token punctuation">,</span> POINTER<span class="token punctuation">(</span>cell<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>让我们试试。我们定义两个 <code>cell</code> 实例，让它们互相指向对方，然后通过指针链式访问几次:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> c1 <span class="token operator">=</span> cell<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> c1<span class="token punctuation">.</span>name <span class="token operator">=</span> b<span class="token string">"foo"</span>
<span class="token operator">>></span><span class="token operator">></span> c2 <span class="token operator">=</span> cell<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> c2<span class="token punctuation">.</span>name <span class="token operator">=</span> b<span class="token string">"bar"</span>
<span class="token operator">>></span><span class="token operator">></span> c1<span class="token punctuation">.</span>next <span class="token operator">=</span> pointer<span class="token punctuation">(</span>c2<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> c2<span class="token punctuation">.</span>next <span class="token operator">=</span> pointer<span class="token punctuation">(</span>c1<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p <span class="token operator">=</span> c1
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">print</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>name<span class="token punctuation">,</span> end<span class="token operator">=</span><span class="token string">" "</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     p <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
foo bar foo bar foo bar foo bar
<span class="token operator">>></span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h4><p><code>ctypes</code> 允许创建一个指向 Python 可调用对象的 C 函数。它们有时候被称为 <em>回调函数</em> 。</p>
<p>首先，你必须为回调函数创建一个类，这个类知道调用约定，包括返回值类型以及函数接收的参数类型及个数。</p>
<p><code>CFUNCTYPE()</code> 工厂函数使用 <code>cdecl</code> 调用约定创建回调函数类型。在 Windows 上， <code>WINFUNCTYPE()</code> 工厂函数使用 <code>stdcall</code> 调用约定为回调函数创建类型。</p>
<p>这些工厂函数的第一个参数是返回值类型，回调函数的参数类型作为剩余参数。</p>
<p>这里展示一个使用 C 标准库函数 <code>qsort()</code> 的例子，它使用一个回调函数对数据进行排序。 <code>qsort()</code> 将用来给整数数组排序:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> IntArray5 <span class="token operator">=</span> c_int <span class="token operator">*</span> <span class="token number">5</span>
<span class="token operator">>></span><span class="token operator">></span> ia <span class="token operator">=</span> IntArray5<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">33</span><span class="token punctuation">,</span> <span class="token number">99</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> qsort <span class="token operator">=</span> libc<span class="token punctuation">.</span>qsort
<span class="token operator">>></span><span class="token operator">></span> qsort<span class="token punctuation">.</span>restype <span class="token operator">=</span> None
<span class="token operator">>></span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>qsort()</code> 必须接收的参数，一个指向待排序数据的指针，元素个数，每个元素的大小，以及一个指向排序函数的指针，即回调函数。然后回调函数接收两个元素的指针，如果第一个元素小于第二个，则返回一个负整数，如果相等则返回0，否则返回一个正整数。</p>
<p>所以，我们的回调函数要接收两个整数指针，返回一个整数。首先我们创建回调函数的 <code>类型</code></p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> CMPFUNC <span class="token operator">=</span> CFUNCTYPE<span class="token punctuation">(</span>c_int<span class="token punctuation">,</span> POINTER<span class="token punctuation">(</span>c_int<span class="token punctuation">)</span><span class="token punctuation">,</span> POINTER<span class="token punctuation">(</span>c_int<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>首先，这是一个简单的回调，它会显示传入的值:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">def</span> <span class="token function">py_cmp_func</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"py_cmp_func"</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> b<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">return</span> <span class="token number">0</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> cmp_func <span class="token operator">=</span> CMPFUNC<span class="token punctuation">(</span>py_cmp_func<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>结果:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> qsort<span class="token punctuation">(</span>ia<span class="token punctuation">,</span> len<span class="token punctuation">(</span>ia<span class="token punctuation">)</span><span class="token punctuation">,</span> sizeof<span class="token punctuation">(</span>c_int<span class="token punctuation">)</span><span class="token punctuation">,</span> cmp_func<span class="token punctuation">)</span>  
py_cmp_func <span class="token number">5</span> <span class="token number">1</span>
py_cmp_func <span class="token number">33</span> <span class="token number">99</span>
py_cmp_func <span class="token number">7</span> <span class="token number">33</span>
py_cmp_func <span class="token number">5</span> <span class="token number">7</span>
py_cmp_func <span class="token number">1</span> <span class="token number">7</span>
<span class="token operator">>></span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>现在我们可以比较两个元素并返回有用的结果了:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">def</span> <span class="token function">py_cmp_func</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"py_cmp_func"</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> b<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">return</span> a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">-</span> b<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span>
<span class="token operator">>></span><span class="token operator">></span> qsort<span class="token punctuation">(</span>ia<span class="token punctuation">,</span> len<span class="token punctuation">(</span>ia<span class="token punctuation">)</span><span class="token punctuation">,</span> sizeof<span class="token punctuation">(</span>c_int<span class="token punctuation">)</span><span class="token punctuation">,</span> CMPFUNC<span class="token punctuation">(</span>py_cmp_func<span class="token punctuation">)</span><span class="token punctuation">)</span> 
py_cmp_func <span class="token number">5</span> <span class="token number">1</span>
py_cmp_func <span class="token number">33</span> <span class="token number">99</span>
py_cmp_func <span class="token number">7</span> <span class="token number">33</span>
py_cmp_func <span class="token number">1</span> <span class="token number">7</span>
py_cmp_func <span class="token number">5</span> <span class="token number">7</span>
<span class="token operator">>></span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们可以轻易地验证，现在数组是有序的了:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">for</span> i <span class="token keyword">in</span> ia<span class="token punctuation">:</span> <span class="token keyword">print</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> end<span class="token operator">=</span><span class="token string">" "</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token number">1</span> <span class="token number">5</span> <span class="token number">7</span> <span class="token number">33</span> <span class="token number">99</span>
<span class="token operator">>></span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>这些工厂函数可以当作装饰器工厂，所以可以这样写:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> @CFUNCTYPE<span class="token punctuation">(</span>c_int<span class="token punctuation">,</span> POINTER<span class="token punctuation">(</span>c_int<span class="token punctuation">)</span><span class="token punctuation">,</span> POINTER<span class="token punctuation">(</span>c_int<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">def</span> <span class="token function">py_cmp_func</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"py_cmp_func"</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> b<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">return</span> a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">-</span> b<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> qsort<span class="token punctuation">(</span>ia<span class="token punctuation">,</span> len<span class="token punctuation">(</span>ia<span class="token punctuation">)</span><span class="token punctuation">,</span> sizeof<span class="token punctuation">(</span>c_int<span class="token punctuation">)</span><span class="token punctuation">,</span> py_cmp_func<span class="token punctuation">)</span>
py_cmp_func <span class="token number">5</span> <span class="token number">1</span>
py_cmp_func <span class="token number">33</span> <span class="token number">99</span>
py_cmp_func <span class="token number">7</span> <span class="token number">33</span>
py_cmp_func <span class="token number">1</span> <span class="token number">7</span>
py_cmp_func <span class="token number">5</span> <span class="token number">7</span>
<span class="token operator">>></span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>注解</p>
<p>请确保你维持的 <code>CFUNCTYPE()</code> 对象的引用周期与它们在 C 代码中的使用期一样长。 <code>ctypes</code> 不会确保这一点，如果不这样做，它们可能会被垃圾回收，导致程序在执行回调函数时发生崩溃。</p>
<p>注意，如果回调函数在Python之外的另外一个线程使用(比如，外部代码调用这个回调函数)， ctypes 会在每一次调用上创建一个虚拟 Python 线程。这个行为在大多数情况下是合理的，但也意味着如果有数据使用 <code>threading.local</code> 方式存储，将无法访问，就算它们是在同一个 C 线程中调用的 。</p>
<h4 id="访问-dll-的导出变量"><a href="#访问-dll-的导出变量" class="headerlink" title="访问 dll 的导出变量"></a>访问 dll 的导出变量</h4><p>一些动态链接库不仅仅导出函数，也会导出变量。一个例子就是 Python 库本身的 <code>Py_OptimizeFlag</code> ，根据启动选项 <code>-O</code> 、 <code>-OO</code> 的不同，它是值可能为 0、1、2 的整型。</p>
<p><code>ctypes</code> 可以通过 <code>in_dll()</code> 类方法访问这类变量 。 <em>pythonapi</em> 是用于访问 Python C 接口的预定义符号:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> opt_flag <span class="token operator">=</span> c_int<span class="token punctuation">.</span>in_dll<span class="token punctuation">(</span>pythonapi<span class="token punctuation">,</span> <span class="token string">"Py_OptimizeFlag"</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>opt_flag<span class="token punctuation">)</span>
c_long<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果解释器使用 <code>-O</code> 选项启动，这个例子会打印 <code>c_long(1)</code> ， 如果使用 <code>-OO</code> 启动，则会打印 <code>c_long(2)</code> 。</p>
<p>一个扩展例子, 同时也展示了使用指针访问 Python 导出的 <code>PyImport_FrozenModules</code> 指针对象。</p>
<p>对文档中这个值的解释说明</p>
<blockquote>
<p>该指针被初始化为指向 <em>struct</em> _frozen 数组，以 <code>NULL</code> 或者 0 作为结束标记。当一个冻结模块被导入，首先要在这个表中搜索。第三方库可以以此来提供动态创建的冻结模块集合。</p>
</blockquote>
<p>这足以证明修改这个指针是很有用的。为了让实例大小不至于太长，这里只展示如何使用 <code>ctypes</code> 读取这个表:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> ctypes <span class="token keyword">import</span> <span class="token operator">*</span>
<span class="token operator">>></span><span class="token operator">></span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">class</span> <span class="token class-name">struct_frozen</span><span class="token punctuation">(</span>Structure<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     _fields_ <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">,</span> c_char_p<span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                 <span class="token punctuation">(</span><span class="token string">"code"</span><span class="token punctuation">,</span> POINTER<span class="token punctuation">(</span>c_ubyte<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                 <span class="token punctuation">(</span><span class="token string">"size"</span><span class="token punctuation">,</span> c_int<span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们定义了 <em>struct</em> _frozen 数据类型，接着就可以获取这张表的指针了:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> FrozenTable <span class="token operator">=</span> POINTER<span class="token punctuation">(</span>struct_frozen<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> table <span class="token operator">=</span> FrozenTable<span class="token punctuation">.</span>in_dll<span class="token punctuation">(</span>pythonapi<span class="token punctuation">,</span> <span class="token string">"PyImport_FrozenModules"</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>由于 <code>table</code> 是指向 <code>struct_frozen</code> 数组的 <code>指针</code> ，我们可以遍历它，只不过需要自己判断循环是否结束，因为指针本身并不包含长度。它早晚会因为访问到野指针或者什么的把自己搞崩溃，所以我们最好在遇到 <code>NULL</code> 后就让它退出循环:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">for</span> item <span class="token keyword">in</span> table<span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">if</span> item<span class="token punctuation">.</span>name <span class="token keyword">is</span> None<span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         <span class="token keyword">break</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">print</span><span class="token punctuation">(</span>item<span class="token punctuation">.</span>name<span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token string">"ascii"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> item<span class="token punctuation">.</span>size<span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
_frozen_importlib <span class="token number">31764</span>
_frozen_importlib_external <span class="token number">41499</span>
__hello__ <span class="token number">161</span>
__phello__ <span class="token operator">-</span><span class="token number">161</span>
__phello__<span class="token punctuation">.</span>spam <span class="token number">161</span>
<span class="token operator">>></span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>Python 的冻结模块和冻结包(由负 <code>size</code> 成员表示)并不是广为人知的事情，它们仅仅用于实验。例如，可以使用 <code>import __hello__</code> 尝试一下这个功能。</p>
<h4 id="意外"><a href="#意外" class="headerlink" title="意外"></a>意外</h4><p><code>ctypes</code> 也有自己的边界，有时候会发生一些意想不到的事情。</p>
<p>比如下面的例子:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> ctypes <span class="token keyword">import</span> <span class="token operator">*</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">class</span> <span class="token class-name">POINT</span><span class="token punctuation">(</span>Structure<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     _fields_ <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token string">"x"</span><span class="token punctuation">,</span> c_int<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">"y"</span><span class="token punctuation">,</span> c_int<span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">class</span> <span class="token class-name">RECT</span><span class="token punctuation">(</span>Structure<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     _fields_ <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">,</span> POINT<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">"b"</span><span class="token punctuation">,</span> POINT<span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> p1 <span class="token operator">=</span> POINT<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p2 <span class="token operator">=</span> POINT<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> rc <span class="token operator">=</span> RECT<span class="token punctuation">(</span>p1<span class="token punctuation">,</span> p2<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>rc<span class="token punctuation">.</span>a<span class="token punctuation">.</span>x<span class="token punctuation">,</span> rc<span class="token punctuation">.</span>a<span class="token punctuation">.</span>y<span class="token punctuation">,</span> rc<span class="token punctuation">.</span>b<span class="token punctuation">.</span>x<span class="token punctuation">,</span> rc<span class="token punctuation">.</span>b<span class="token punctuation">.</span>y<span class="token punctuation">)</span>
<span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token comment" spellcheck="true"># now swap the two points</span>
<span class="token operator">>></span><span class="token operator">></span> rc<span class="token punctuation">.</span>a<span class="token punctuation">,</span> rc<span class="token punctuation">.</span>b <span class="token operator">=</span> rc<span class="token punctuation">.</span>b<span class="token punctuation">,</span> rc<span class="token punctuation">.</span>a
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>rc<span class="token punctuation">.</span>a<span class="token punctuation">.</span>x<span class="token punctuation">,</span> rc<span class="token punctuation">.</span>a<span class="token punctuation">.</span>y<span class="token punctuation">,</span> rc<span class="token punctuation">.</span>b<span class="token punctuation">.</span>x<span class="token punctuation">,</span> rc<span class="token punctuation">.</span>b<span class="token punctuation">.</span>y<span class="token punctuation">)</span>
<span class="token number">3</span> <span class="token number">4</span> <span class="token number">3</span> <span class="token number">4</span>
<span class="token operator">>></span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>嗯。我们预想应该打印 <code>3 4 1 2</code> 。但是为什么呢? 这是 <code>rc.a, rc.b = rc.b, rc.a</code> 这行代码展开后的步骤:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> temp0<span class="token punctuation">,</span> temp1 <span class="token operator">=</span> rc<span class="token punctuation">.</span>b<span class="token punctuation">,</span> rc<span class="token punctuation">.</span>a
<span class="token operator">>></span><span class="token operator">></span> rc<span class="token punctuation">.</span>a <span class="token operator">=</span> temp0
<span class="token operator">>></span><span class="token operator">></span> rc<span class="token punctuation">.</span>b <span class="token operator">=</span> temp1
<span class="token operator">>></span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>注意 <code>temp0</code> 和 <code>temp1</code> 对象始终引用了对象 <code>rc</code> 的内容。然后执行 <code>rc.a = temp0</code> 会把 <code>temp0</code> 的内容拷贝到 <code>rc</code> 的空间。这也改变了 <code>temp1</code> 的内容。最终导致赋值语句 <code>rc.b = temp1</code> 没有产生预想的效果。</p>
<p>记住，访问被包含在结构体、联合、数组中的对象并不会将其 <em>复制</em> 出来，而是得到了一个代理对象，它是对根对象的内部内容的一层包装。</p>
<p>下面是另一个可能和预期有偏差的例子:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> s <span class="token operator">=</span> c_char_p<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> s<span class="token punctuation">.</span>value <span class="token operator">=</span> b<span class="token string">"abc def ghi"</span>
<span class="token operator">>></span><span class="token operator">></span> s<span class="token punctuation">.</span>value
b<span class="token string">'abc def ghi'</span>
<span class="token operator">>></span><span class="token operator">></span> s<span class="token punctuation">.</span>value <span class="token keyword">is</span> s<span class="token punctuation">.</span>value
<span class="token boolean">False</span>
<span class="token operator">>></span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>注解</p>
<p>使用 <code>c_char_p</code> 实例化的对象只能将其值设置为 bytes 或者整数。</p>
<p>为什么这里打印了 <code>False</code> ？ ctypes 实例是一些内存块加上一些用于访问这些内存块的 descriptor 组成。将 Python 对象存储在内存块并不会存储对象本身，而是存储了对象的 <code>内容</code> 。每次访问对象的内容都会构造一个新的 Python 对象。</p>
<h4 id="变长数据类型"><a href="#变长数据类型" class="headerlink" title="变长数据类型"></a>变长数据类型</h4><p><code>ctypes</code> 对变长数组和结构体提供了一些支持 。</p>
<p>The <code>resize()</code> function can be used to resize the memory buffer of an existing ctypes object. The function takes the object as first argument, and the requested size in bytes as the second argument. The memory block cannot be made smaller than the natural memory block specified by the objects type, a <code>ValueError</code> is raised if this is tried:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> short_array <span class="token operator">=</span> <span class="token punctuation">(</span>c_short <span class="token operator">*</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>sizeof<span class="token punctuation">(</span>short_array<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token number">8</span>
<span class="token operator">>></span><span class="token operator">></span> resize<span class="token punctuation">(</span>short_array<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span>
Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
ValueError<span class="token punctuation">:</span> minimum size <span class="token keyword">is</span> <span class="token number">8</span>
<span class="token operator">>></span><span class="token operator">></span> resize<span class="token punctuation">(</span>short_array<span class="token punctuation">,</span> <span class="token number">32</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> sizeof<span class="token punctuation">(</span>short_array<span class="token punctuation">)</span>
<span class="token number">32</span>
<span class="token operator">>></span><span class="token operator">></span> sizeof<span class="token punctuation">(</span>type<span class="token punctuation">(</span>short_array<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token number">8</span>
<span class="token operator">>></span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这非常好，但是要怎么访问数组中额外的元素呢？因为数组类型已经定义包含4个元素，导致我们访问新增元素时会产生以下错误:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> short_array<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> short_array<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span>
Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
IndexError<span class="token punctuation">:</span> invalid index
<span class="token operator">>></span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>使用 <code>ctypes</code> 访问变长数据类型的一个可行方法是利用 Python 的动态特性，根据具体情况，在知道这个数据的大小后，(重新)指定这个数据的类型。</p>
<h3 id="ctypes-参考手册"><a href="#ctypes-参考手册" class="headerlink" title="ctypes 参考手册"></a>ctypes 参考手册</h3><h4 id="寻找动态链接库"><a href="#寻找动态链接库" class="headerlink" title="寻找动态链接库"></a>寻找动态链接库</h4><p>在编译型语言中，动态链接库会在编译、链接或者程序运行时访问。</p>
<p>The purpose of the <code>find_library()</code> function is to locate a library in a way similar to what the compiler or runtime loader does (on platforms with several versions of a shared library the most recent should be loaded), while the ctypes library loaders act like when a program is run, and call the runtime loader directly.</p>
<p><code>ctypes.util</code> 模块提供了一个函数，可以帮助确定需要加载的库。</p>
<p><code>ctypes.util.find_library</code>(<em>name</em>)</p>
<p>尝试寻找一个库然后返回其路径名， <em>name</em> 是库名称, 且去除了 <em>lib</em> 等前缀和 <code>.so</code> 、 <code>.dylib</code> 、版本号等后缀(这是 posix 连接器 <code>-l</code> 选项使用的格式)。如果没有找到对应的库，则返回 <code>None</code> 。</p>
<p>确切的功能取决于系统。</p>
<p>在 Linux 上， <code>find_library()</code> 会尝试运行外部程序(<code>/sbin/ldconfig</code>, <code>gcc</code>, <code>objdump</code> 以及 <code>ld</code>) 来寻找库文件。返回库文件的文件名。</p>
<p>在 3.6 版更改: 在Linux 上，如果其他方式找不到的话，会使用环境变量 <code>LD_LIBRARY_PATH</code> 搜索动态链接库。</p>
<p>这是一些例子:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> ctypes<span class="token punctuation">.</span>util <span class="token keyword">import</span> find_library
<span class="token operator">>></span><span class="token operator">></span> find_library<span class="token punctuation">(</span><span class="token string">"m"</span><span class="token punctuation">)</span>
<span class="token string">'libm.so.6'</span>
<span class="token operator">>></span><span class="token operator">></span> find_library<span class="token punctuation">(</span><span class="token string">"c"</span><span class="token punctuation">)</span>
<span class="token string">'libc.so.6'</span>
<span class="token operator">>></span><span class="token operator">></span> find_library<span class="token punctuation">(</span><span class="token string">"bz2"</span><span class="token punctuation">)</span>
<span class="token string">'libbz2.so.1.0'</span>
<span class="token operator">>></span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>On macOS, <code>find_library()</code> tries several predefined naming schemes and paths to locate the library, and returns a full pathname if successful:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> ctypes<span class="token punctuation">.</span>util <span class="token keyword">import</span> find_library
<span class="token operator">>></span><span class="token operator">></span> find_library<span class="token punctuation">(</span><span class="token string">"c"</span><span class="token punctuation">)</span>
<span class="token string">'/usr/lib/libc.dylib'</span>
<span class="token operator">>></span><span class="token operator">></span> find_library<span class="token punctuation">(</span><span class="token string">"m"</span><span class="token punctuation">)</span>
<span class="token string">'/usr/lib/libm.dylib'</span>
<span class="token operator">>></span><span class="token operator">></span> find_library<span class="token punctuation">(</span><span class="token string">"bz2"</span><span class="token punctuation">)</span>
<span class="token string">'/usr/lib/libbz2.dylib'</span>
<span class="token operator">>></span><span class="token operator">></span> find_library<span class="token punctuation">(</span><span class="token string">"AGL"</span><span class="token punctuation">)</span>
<span class="token string">'/System/Library/Frameworks/AGL.framework/AGL'</span>
<span class="token operator">>></span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在 Windows 上， <code>find_library()</code> 在系统路径中搜索，然后返回全路径，但是如果没有预定义的命名方案， <code>find_library("c")</code> 调用会返回 <code>None</code></p>
<p>使用 <code>ctypes</code> 包装动态链接库，更好的方式 <em>可能</em> 是在开发的时候就确定名称，然后硬编码到包装模块中去，而不是在运行时使用 <code>find_library()</code> 寻找库。</p>
<h4 id="加载动态链接库"><a href="#加载动态链接库" class="headerlink" title="加载动态链接库"></a>加载动态链接库</h4><p>有很多方式可以将动态链接库加载到 Python 进程。其中之一是实例化以下类的其中一个:</p>
<p><em>class</em> <code>ctypes.CDLL</code>(<em>name</em>, <em>mode=DEFAULT_MODE</em>, <em>handle=None</em>, <em>use_errno=False</em>, <em>use_last_error=False</em>, <em>winmode=0</em>)</p>
<p>此类的实例即已加载的动态链接库。库中的函数使用标准 C 调用约定，并假定返回 int 。</p>
<p>在 Windows 上创建 <code>CDLL</code> 实例可能会失败，即使 DLL 名称确实存在。 当某个被加载 DLL 所依赖的 DLL 未找到时，将引发 <code>OSError</code> 错误并附带消息 <em>“[WinError 126] The specified module could not be found”.</em> 此错误消息不包含缺失 DLL 的名称，因为 Windows API 并不会返回此类信息，这使得此错误难以诊断。 要解决此错误并确定是哪一个 DLL 未找到，你需要找出所依赖的 DLL 列表并使用 Windows 调试与跟踪工具确定是哪一个未找到。</p>
<p>参见</p>
<p><a href="https://docs.microsoft.com/cpp/build/reference/dependents" target="_blank" rel="noopener">Microsoft DUMPBIN 工具</a> — 一个用于查找 DLL 依赖的工具。</p>
<p><em>class</em> <code>ctypes.OleDLL</code>(<em>name</em>, <em>mode=DEFAULT_MODE</em>, <em>handle=None</em>, <em>use_errno=False</em>, <em>use_last_error=False</em>, <em>winmode=0</em>)</p>
<p>仅 Windows : 此类的实例即加载好的动态链接库，其中的函数使用 <code>stdcall</code> 调用约定，并且假定返回 windows 指定的 <code>HRESULT</code> 返回码。 <code>HRES</code></p>
<p><code>ULT</code> 的值包含的信息说明函数调用成功还是失败，以及额外错误码。 如果返回值表示失败，会自动抛出 <code>OSError</code> 异常。</p>
<p>在 3.3 版更改: 以前是引发 <code>WindowsError</code>。</p>
<p><em>class</em> <code>ctypes.WinDLL</code>(<em>name</em>, <em>mode=DEFAULT_MODE</em>, <em>handle=None</em>, <em>use_errno=False</em>, <em>use_last_error=False</em>, <em>winmode=0</em>)</p>
<p>仅 Windows: 此类的实例即加载好的动态链接库，其中的函数使用 <code>stdcall</code> 调用约定，并假定默认返回 int 。</p>
<p>在 Windows CE 上，只能使用 stdcall 调用约定，为了方便， <code>WinDLL</code> 和 <code>OleDLL</code> 在这个平台上都使用标准调用约定。</p>
<p>调用动态库导出的函数之前，Python会释放 global interpreter lock ，并在调用后重新获取。</p>
<p><em>class</em> <code>ctypes.PyDLL</code>(<em>name</em>, <em>mode=DEFAULT_MODE</em>, <em>handle=None</em>)</p>
<p>这个类实例的行为与 <code>CDLL</code> 类似，只不过 <em>不会</em> 在调用函数的时候释放 GIL 锁，且调用结束后会检查 Python 错误码。 如果错误码被设置，会抛出一个 Python 异常。</p>
<p>所以，它只在直接调用 Python C 接口函数的时候有用。</p>
<p>通过使用至少一个参数（共享库的路径名）调用它们，可以实例化所有这些类。也可以传入一个已加载的动态链接库作为 <code>handler</code> 参数，其他情况会调用系统底层的 <code>dlopen</code> 或 <code>LoadLibrary</code> 函数将库加载到进程，并获取其句柄。</p>
<p><em>mode</em> 可以指定库加载方式。 在 Windows 上， 会忽略 <em>mode</em> ，在 posix 系统上， 总是会加上 RTLD_NOW ，且无法配置。</p>
<p><em>use_errno</em> 参数如果设置为 true，可以启用ctypes的机制，通过一种安全的方法获取系统的 <code>errno</code> 错误码。 <code>ctypes</code> 维护了一个线程局部变量，它是系统 <code>errno</code> 的一份拷贝；如果调用了使用 <code>use_errno=True</code> 创建的外部函数， <code>errno</code> 的值会与 ctypes 自己拷贝的那一份进行交换，函数执行完后立即再交换一次。</p>
<p>The function <code>ctypes.get_errno()</code> returns the value of the ctypes private copy, and the function <code>ctypes.set_errno()</code> changes the ctypes private copy to a new value and returns the former value.</p>
<p><em>use_last_error</em> 参数如果设置为 true，可以在 Windows 上启用相同的策略，它是通过 Windows API 函数 <code>GetLastError()</code> 和 <code>SetLastError()</code> 管理的。 <code>ctypes.get_last_error()</code> 和 <code>ctypes.set_last_error()</code> 可用于获取和设置 ctypes 自己维护的 windows 错误码拷贝。</p>
<p><em>winmode</em> 参数用于在 Windows 平台上指定库的加载方式( 因为 <em>mode</em> 会被忽略)。他接受任何与 Win32 API 的 <code>LoadLibraryEx</code> 的标志兼容的值作为参数。省略时，默认设置使用最安全的DLL加载的标志，以避免DLL劫持等问题。传入 DLL 的全路径是保证正确加载库及其依赖最安全的方法。</p>
<p>在 3.8 版更改: 增加了 <em>winmode</em> 参数。</p>
<pre><code>ctypes.RTLD_GLOBAL</code></pre><p>用于 <em>mode</em> 参数的标识值。在此标识不可用的系统上，它被定义为整数0。</p>
<pre><code>ctypes.RTLD_LOCAL</code></pre><p>Flag to use as <em>mode</em> parameter. On platforms where this is not available, it is the same as <em>RTLD_GLOBAL</em>.</p>
<pre><code>ctypes.DEFAULT_MODE</code></pre><p>加载动态链接库的默认模式。在 OSX 10.3 上，它是 <em>RTLD_GLOBAL</em> ，其余系统上是 <em>RTLD_LOCAL</em> 。</p>
<p>这些类的实例没有共用方法。动态链接库的导出函数可以通过属性或者索引的方式访问。注意，通过属性的方式访问会缓存这个函数，因而每次访问它时返回的都是同一个对象。另一方面，通过索引访问，每次都会返回一个新的对象:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> ctypes <span class="token keyword">import</span> CDLL
<span class="token operator">>></span><span class="token operator">></span> libc <span class="token operator">=</span> CDLL<span class="token punctuation">(</span><span class="token string">"libc.so.6"</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># On Linux</span>
<span class="token operator">>></span><span class="token operator">></span> libc<span class="token punctuation">.</span>time <span class="token operator">==</span> libc<span class="token punctuation">.</span>time
<span class="token boolean">True</span>
<span class="token operator">>></span><span class="token operator">></span> libc<span class="token punctuation">[</span><span class="token string">'time'</span><span class="token punctuation">]</span> <span class="token operator">==</span> libc<span class="token punctuation">[</span><span class="token string">'time'</span><span class="token punctuation">]</span>
<span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>还有下面这些属性可用，他们的名称以下划线开头，以避免和导出函数重名:</p>
<pre><code>PyDLL._handle</code></pre><p>用于访问库的系统句柄。</p>
<pre><code>PyDLL._name</code></pre><p>传入构造函数的库名称。</p>
<p>共享库也可以通用使用一个预制对象来加载，这种对象是 <code>LibraryLoader</code> 类的实例，具体做法或是通过调用 <code>LoadLibrary()</code> 方法，或是通过将库作为加载器实例的属性来提取。</p>
<p><em>class</em> <code>ctypes.LibraryLoader</code>(<em>dlltype</em>)</p>
<p>加载共享库的类。 <em>dlltype</em> 应当为 <code>CDLL</code>, <code>PyDLL</code>, <code>WinDLL</code> 或 <code>OleDLL</code> 类型之一。</p>
<p><code>__getattr__()</code> 具有特殊的行为：它允许通过将一个共享库作为库加载器实例的属性进行访问来加载它。 加载结果将被缓存，因此重复的属性访问每次都会返回相同的库。</p>
<ul>
<li><p><code>LoadLibrary</code>(<em>name</em>)</p>
<p>加载一个共享库到进程中并将其返回。 此方法总是返回一个新的库实例。</p>
</li>
</ul>
<p>可用的预制库加载器有如下这些:</p>
<pre><code>ctypes.cdll</code></pre><p>创建 <code>CDLL</code> 实例。</p>
<pre><code>ctypes.windll</code></pre><p>仅限 Windows：创建 <code>WinDLL</code> 实例.</p>
<pre><code>ctypes.oledll</code></pre><p>仅限 Windows：创建 <code>OleDLL</code> 实例。</p>
<pre><code>ctypes.pydll</code></pre><p>创建 <code>PyDLL</code> 实例。</p>
<p>要直接访问 C Python api，可以使用一个现成的 Python 共享库对象:</p>
<pre><code>ctypes.pythonapi</code></pre><p>一个 <code>PyDLL</code> 的实例，它将 Python C API 函数作为属性公开。 请注意所有这些函数都应返回 C int，当然这也不是绝对的，因此你必须分配正确的 <code>restype</code> 属性以使用这些函数。</p>
<p>引发一个 审计事件 <code>ctypes.dlopen</code>，附带参数 <code>name</code>。</p>
<p>引发一个审计事件 <code>ctypes.dlsym</code>，附带参数 <code>library</code>, <code>name</code>。</p>
<p>引发一个审计事件 <code>ctypes.dlsym/handle</code>，附带参数 <code>handle</code>, <code>name</code>。</p>
<h4 id="外部函数"><a href="#外部函数" class="headerlink" title="外部函数"></a>外部函数</h4><p>正如之前小节的说明，外部函数可作为被加载共享库的属性来访问。 用此方式创建的函数对象默认接受任意数量的参数，接受任意 ctypes 数据实例作为参数，并且返回库加载器所指定的默认结果类型。 它们是一个私有类的实例:</p>
<p><em>class</em> <code>ctypes._FuncPtr</code></p>
<p>C 可调用外部函数的基类。</p>
<p>外部函数的实例也是兼容 C 的数据类型；它们代表 C 函数指针。</p>
<p>此行为可通过对外部函数对象的特殊属性赋值来自定义。</p>
<ul>
<li><p><code>restype</code></p>
<p>赋值为一个 ctypes 类型来指定外部函数的结果类型。 使用 <code>None</code> 表示 void，即不返回任何结果的函数。</p>
<p>赋值为一个不为 ctypes 类型的可调用 Python 对象也是可以的，在此情况下函数应返回 C int，该可调用对象将附带此整数被调用，以允许进一步的处理或错误检测。 这种用法已被弃用，为了更灵活的后续处理或错误检测请使用一个 ctypes 数据类型作为 <code>restype</code> 并将 <code>errcheck</code> 属性赋值为一个可调用对象。</p>
</li>
<li><p><code>argtypes</code></p>
<p>赋值为一个 ctypes 类型的元组来指定函数所接受的参数类型。 使用 <code>stdcall</code> 调用规范的函数只能附带与此元组长度相同数量的参数进行调用；使用 C 调用规范的函数还可接受额外的未指明参数。</p>
<p>当外部函数被调用时，每个实际参数都会被传给 <code>argtypes</code> 元组中条目的 <code>from_param()</code> 类方法，此方法允许将实际参数适配为此外部函数所接受的对象。 例如，<code>argtypes</code> 元组中的 <code>c_char_p</code> 条目将使用 ctypes 约定规则把作为参数传入的字符串转换为字节串对象。</p>
<p>新增：现在可以将不是 ctypes 类型的条目放入 argtypes，但每个条目都必须具有 <code>from_param()</code> 方法用于返回可作为参数的值（整数、字符串、ctypes 实例）。 这样就允许定义可将自定义对象适配为函数形参的适配器。</p>
</li>
<li><p><code>errcheck</code></p>
<p>将一个 Python 函数或其他可调用对象赋值给此属性。 该可调用对象将附带三个及以上的参数被调用。</p>
<ul>
<li><p><code>callable</code>(<em>result</em>, <em>func</em>, <em>arguments</em>)</p>
<p><em>result</em> 是外部函数返回的结果，由 <code>restype</code> 属性指明。</p>
<p><em>func</em> 是外部函数对象本身，这样就允许重新使用相同的可调用对象来对多个函数进行检查或后续处理。</p>
<p><em>arguments</em> 是一个包含最初传递给函数调用的形参的元组，这样就允许对所用参数的行为进行特别处理。</p>
</li>
</ul>
<p>此函数所返回的对象将会由外部函数调用返回，但它还可以在外部函数调用失败时检查结果并引发异常。</p>
</li>
</ul>
<p><em>exception</em> <code>ctypes.ArgumentError</code></p>
<p>此异常会在外部函数无法对某个传入参数执行转换时被引发。</p>
<p>引发一个审计事件 <code>ctypes.seh_exception</code> 并附带参数 <code>code</code>。</p>
<p>引发一个审计事件 <code>ctypes.call_function</code>，附带参数 <code>func_pointer</code>, <code>arguments</code>。</p>
<h4 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h4><p>外部函数也可通过实例化函数原型来创建。 函数原型类似于 C 中的函数原型；它们在不定义具体实现的情况下描述了一个函数（返回类型、参数类型、调用约定）。 工厂函数必须使用函数所需要的结果类型和参数类型来调用，并可被用作装饰器工厂函数，在此情况下可以通过 <code>@wrapper</code> 语法应用于函数。</p>
<p><code>ctypes.CFUNCTYPE</code>(<em>restype</em>, <em>\</em>argtypes<em>,</em> use_errno=False<em>,</em> use_last_error=False*)</p>
<p>返回的函数原型会创建使用标准 C 调用约定的函数。 该函数在调用过程中将释放 GIL。 如果 <em>use_errno</em> 设为真值，则在调用之前和之后系统 <code>errno</code> 变量的 ctypes 私有副本会与真正的 <code>errno</code> 值进行交换；<em>use_last_error</em> 会为 Windows 错误码执行同样的操作。</p>
<p><code>ctypes.WINFUNCTYPE</code>(<em>restype</em>, <em>\</em>argtypes<em>,</em> use_errno=False<em>,</em> use_last_error=False*)</p>
<p>仅限 Windows only：返回的函数原型会创建使用 <code>stdcall</code> 调用约定的函数，但在 Windows CE 上 <code>WINFUNCTYPE()</code> 则会与 <code>CFUNCTYPE()</code> 相同。 该函数在调用过程中将释放 GIL。 <em>use_errno</em> 和 <em>use_last_error</em> 具有与前面相同的含义。</p>
<p><code>ctypes.PYFUNCTYPE</code>(<em>restype</em>, <em>\</em>argtypes*)</p>
<p>返回的函数原型会创建使用 Python 调用约定的函数。 该函数在调用过程中将 <em>不会</em> 释放 GIL。</p>
<p>这些工厂函数所创建的函数原型可通过不同的方式来实例化，具体取决于调用中的类型与数量:</p>
<blockquote>
<p><code>prototype</code>(<em>address</em>)</p>
<p>在指定地址上返回一个外部函数，地址值必须为整数。</p>
<p><code>prototype</code>(<em>callable</em>)</p>
<p>基于 Python <em>callable</em> 创建一个 C 可调用函数（回调函数）。</p>
<p><code>prototype</code>(<em>func_spec</em>[, <em>paramflags</em>])</p>
<p>返回由一个共享库导出的外部函数。 <em>func_spec</em> 必须为一个 2 元组 <code>(name_or_ordinal, library)</code>。 第一项是字符串形式的所导出函数名称，或小整数形式的所导出函数序号。 第二项是该共享库实例。</p>
<p><code>prototype</code>(<em>vtbl_index</em>, <em>name</em>[, <em>paramflags</em>[, <em>iid</em>]])</p>
<p>返回将调用一个 COM 方法的外部函数。 <em>vtbl_index</em> 虚拟函数表中的索引。 <em>name</em> 是 COM 方法的名称。 <em>iid</em> 是可选的指向接口标识符的指针，它被用于扩展的错误报告。</p>
<p>COM 方法使用特殊的调用约定：除了在 <code>argtypes</code> 元组中指定的形参，它们还要求一个指向 COM 接口的指针作为第一个参数。</p>
<p>可选的 <em>paramflags</em> 形参会创建相比上述特性具有更多功能的外部函数包装器。</p>
<p><em>paramflags</em> 必须为一个与 <code>argtypes</code> 长度相同的元组。</p>
<p>此元组中的每一项都包含有关形参的更多信息，它必须为包含一个、两个或更多条目的元组。</p>
<p>第一项是包含形参指令旗标组合的整数。</p>
<blockquote>
<p>1</p>
<p>指定函数的一个输入形参。</p>
<p>2</p>
<p>输出形参。 外部函数会填入一个值。</p>
<p>4</p>
<p>默认为整数零值的输入形参。</p>
</blockquote>
<p>可选的第二项是字符串形式的形参名称。 如果指定此项，则可以使用该形参名称来调用外部函数。</p>
<p>可选的第三项是该形参的默认值。</p>
</blockquote>
<p>这个例子演示了如何包装 Windows 的 <code>MessageBoxW</code> 函数以使其支持默认形参和已命名参数。 相应 windows 头文件的 C 声明是这样的:</p>
<pre><code>WINUSERAPI int WINAPI
MessageBoxW(
    HWND hWnd,
    LPCWSTR lpText,
    LPCWSTR lpCaption,
    UINT uType);</code></pre><p>这是使用 <code>ctypes</code> 的包装:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> ctypes <span class="token keyword">import</span> c_int<span class="token punctuation">,</span> WINFUNCTYPE<span class="token punctuation">,</span> windll
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> ctypes<span class="token punctuation">.</span>wintypes <span class="token keyword">import</span> HWND<span class="token punctuation">,</span> LPCWSTR<span class="token punctuation">,</span> UINT
<span class="token operator">>></span><span class="token operator">></span> prototype <span class="token operator">=</span> WINFUNCTYPE<span class="token punctuation">(</span>c_int<span class="token punctuation">,</span> HWND<span class="token punctuation">,</span> LPCWSTR<span class="token punctuation">,</span> LPCWSTR<span class="token punctuation">,</span> UINT<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> paramflags <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"hwnd"</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"text"</span><span class="token punctuation">,</span> <span class="token string">"Hi"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"caption"</span><span class="token punctuation">,</span> <span class="token string">"Hello from ctypes"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"flags"</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> MessageBox <span class="token operator">=</span> prototype<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">"MessageBoxW"</span><span class="token punctuation">,</span> windll<span class="token punctuation">.</span>user32<span class="token punctuation">)</span><span class="token punctuation">,</span> paramflags<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>现在 <code>MessageBox</code> 外部函数可以通过以下方式来调用:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> MessageBox<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> MessageBox<span class="token punctuation">(</span>text<span class="token operator">=</span><span class="token string">"Spam, spam, spam"</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> MessageBox<span class="token punctuation">(</span>flags<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span> text<span class="token operator">=</span><span class="token string">"foo bar"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>第二个例子演示了输出形参。 这个 win32 <code>GetWindowRect</code> 函数通过将指定窗口的维度拷贝至调用者必须提供的 <code>RECT</code> 结构体来提取这些值。 这是相应的 C 声明:</p>
<pre><code>WINUSERAPI BOOL WINAPI
GetWindowRect(
     HWND hWnd,
     LPRECT lpRect);</code></pre><p>这是使用 <code>ctypes</code> 的包装:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> ctypes <span class="token keyword">import</span> POINTER<span class="token punctuation">,</span> WINFUNCTYPE<span class="token punctuation">,</span> windll<span class="token punctuation">,</span> WinError
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> ctypes<span class="token punctuation">.</span>wintypes <span class="token keyword">import</span> BOOL<span class="token punctuation">,</span> HWND<span class="token punctuation">,</span> RECT
<span class="token operator">>></span><span class="token operator">></span> prototype <span class="token operator">=</span> WINFUNCTYPE<span class="token punctuation">(</span>BOOL<span class="token punctuation">,</span> HWND<span class="token punctuation">,</span> POINTER<span class="token punctuation">(</span>RECT<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> paramflags <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"hwnd"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">"lprect"</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> GetWindowRect <span class="token operator">=</span> prototype<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">"GetWindowRect"</span><span class="token punctuation">,</span> windll<span class="token punctuation">.</span>user32<span class="token punctuation">)</span><span class="token punctuation">,</span> paramflags<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>带有输出形参的函数如果输出形参存在单一值则会自动返回该值，或是当输出形参存在多个值时返回包含这些值的元组，因此当 GetWindowRect 被调用时现在将返回一个 RECT 实例。</p>
<p>输出形参可以与 <code>errcheck</code> 协议相结合以执行进一步的输出处理与错误检查。 Win32 <code>GetWindowRect</code> API 函数返回一个 <code>BOOL</code> 来表示成功或失败，因此此函数可执行错误检查，并在 API 调用失败时引发异常:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">def</span> <span class="token function">errcheck</span><span class="token punctuation">(</span>result<span class="token punctuation">,</span> func<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">if</span> <span class="token operator">not</span> result<span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         <span class="token keyword">raise</span> WinError<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">return</span> args
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> GetWindowRect<span class="token punctuation">.</span>errcheck <span class="token operator">=</span> errcheck
<span class="token operator">>></span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果 <code>errcheck</code> 不加更改地返回它所接收的参数元组，则 <code>ctypes</code> 会继续对输出形参执行常规处理。 如果你希望返回一个窗口坐标的元组而非 <code>RECT</code> 实例，你可以从函数中提取这些字段并返回它们，常规处理将不会再执行:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">def</span> <span class="token function">errcheck</span><span class="token punctuation">(</span>result<span class="token punctuation">,</span> func<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">if</span> <span class="token operator">not</span> result<span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         <span class="token keyword">raise</span> WinError<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     rc <span class="token operator">=</span> args<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">return</span> rc<span class="token punctuation">.</span>left<span class="token punctuation">,</span> rc<span class="token punctuation">.</span>top<span class="token punctuation">,</span> rc<span class="token punctuation">.</span>bottom<span class="token punctuation">,</span> rc<span class="token punctuation">.</span>right
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> GetWindowRect<span class="token punctuation">.</span>errcheck <span class="token operator">=</span> errcheck
<span class="token operator">>></span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="工具函数"><a href="#工具函数" class="headerlink" title="工具函数"></a>工具函数</h4><p><code>ctypes.addressof</code>(<em>obj</em>)</p>
<p>以整数形式返回内存缓冲区地址。 <em>obj</em> 必须为一个 ctypes 类型的实例。</p>
<p>引发一个 审计事件 <code>ctypes.addressof</code>，附带参数 <code>obj</code>。</p>
<p><code>ctypes.alignment</code>(<em>obj_or_type</em>)</p>
<p>返回一个 ctypes 类型的对齐要求。 <em>obj_or_type</em> 必须为一个 ctypes 类型或实例。</p>
<p><code>ctypes.byref</code>(<em>obj</em>[, <em>offset</em>])</p>
<p>返回指向 <em>obj</em> 的轻量指针，该对象必须为一个 ctypes 类型的实例。 <em>offset</em> 默认值为零，且必须为一个将被添加到内部指针值的整数。</p>
<p><code>byref(obj, offset)</code> 对应于这段 C 代码:</p>
<pre><code>(((char *)&amp;obj) + offset)</code></pre><p>返回的对象只能被用作外部函数调用形参。 它的行为类似于 <code>pointer(obj)</code>，但构造起来要快很多。</p>
<p><code>ctypes.cast</code>(<em>obj</em>, <em>type</em>)</p>
<p>此函数类似于 C 的强制转换运算符。 它返回一个 <em>type</em> 的新实例，该实例指向与 <em>obj</em> 相同的内存块。 <em>type</em> 必须为指针类型，而 <em>obj</em> 必须为可以被作为指针来解读的对象。</p>
<p><code>ctypes.create_string_buffer</code>(<em>init_or_size</em>, <em>size=None</em>)</p>
<p>此函数会创建一个可变的字符缓冲区。 返回的对象是一个 <code>c_char</code> 的 ctypes 数组。</p>
<p><em>init_or_size</em> 必须是一个指明数组大小的整数，或者是一个将被用来初始化数组条目的字节串对象。</p>
<p>如果将一个字节串对象指定为第一个参数，则将使缓冲区大小比其长度多一项以便数组的最后一项为一个 NUL 终结符。 可以传入一个整数作为第二个参数以允许在不使用字节串长度的情况下指定数组大小。</p>
<p>引发一个 审计事件 <code>ctypes.create_string_buffer</code>，附带参数 <code>init</code>, <code>size</code>。</p>
<p><code>ctypes.create_unicode_buffer</code>(<em>init_or_size</em>, <em>size=None</em>)</p>
<p>此函数会创建一个可变的 unicode 字符缓冲区。 返回的对象是一个 <code>c_wchar</code> 的 ctypes 数组。</p>
<p><em>init_or_size</em> 必须是一个指明数组大小的整数，或者是一个将被用来初始化数组条目的字符串。</p>
<p>如果将一个字符串指定为第一个参数，则将使缓冲区大小比其长度多一项以便数组的最后一项为一个 NUL 终结符。 可以传入一个整数作为第二个参数以允许在不使用字符串长度的情况下指定数组大小。</p>
<p>引发一个 审计事件 <code>ctypes.create_unicode_buffer</code>，附带参数 <code>init</code>, <code>size</code>。</p>
<p><code>ctypes.DllCanUnloadNow</code>()</p>
<p>仅限 Windows：此函数是一个允许使用 ctypes 实现进程内 COM 服务的钩子。 它将由 _ctypes 扩展 dll 所导出的 DllCanUnloadNow 函数来调用。</p>
<p><code>ctypes.DllGetClassObject</code>()</p>
<p>仅限 Windows：此函数是一个允许使用 ctypes 实现进程内 COM 服务的钩子。 它将由 <code>_ctypes</code> 扩展 dll 所导出的 DllGetClassObject 函数来调用。</p>
<p><code>ctypes.util.find_library</code>(<em>name</em>)</p>
<p>尝试寻找一个库并返回路径名称。 <em>name</em> 是库名称并且不带任何前缀如 <code>lib</code> 以及后缀如 <code>.so</code>，<code>.dylib</code> 或版本号（形式与 posix 链接器选项 <code>-l</code> 所用的一致）。 如果找不到库，则返回 <code>None</code>。</p>
<p>确切的功能取决于系统。</p>
<p><code>ctypes.util.find_msvcrt</code>()</p>
<p>仅限 Windows：返回 Python 以及扩展模块所使用的 VC 运行时库的文件名。 如果无法确定库名称，则返回 <code>None</code>。</p>
<p>如果你需要通过调用 <code>free(void *)</code> 来释放内存，例如某个扩展模块所分配的内存，重要的一点是你应当使用分配内存的库中的函数。</p>
<p><code>ctypes.FormatError</code>([<em>code</em>])</p>
<p>仅限 Windows：返回错误码 <em>code</em> 的文本描述。 如果未指定错误码，则会通过调用 Windows api 函数 GetLastError 来获得最新的错误码。</p>
<p><code>ctypes.GetLastError</code>()</p>
<p>仅限 Windows：返回 Windows 在调用线程中设置的最新错误码。 此函数会直接调用 Windows GetLastError() 函数，它并不返回错误码的 ctypes 私有副本。</p>
<p><code>ctypes.get_errno</code>()</p>
<p>返回调用线程中系统 <code>errno</code> 变量的 ctypes 私有副本的当前值。</p>
<p>引发一个 审计事件 <code>ctypes.get_errno</code>，不附带任何参数。</p>
<p><code>ctypes.get_last_error</code>()</p>
<p>仅限 Windows：返回调用线程中系统 <code>LastError</code> 变量的 ctypes 私有副本的当前值。</p>
<p>引发一个 审计事件 <code>ctypes.get_last_error</code>，不附带任何参数。</p>
<p><code>ctypes.memmove</code>(<em>dst</em>, <em>src</em>, <em>count</em>)</p>
<p>与标准 C memmove 库函数相同：将 <em>count</em> 个字节从 <em>src</em> 拷贝到 <em>dst*。 *dst</em> 和 <em>src</em> 必须为整数或可被转换为指针的 ctypes 实例。</p>
<p><code>ctypes.memset</code>(<em>dst</em>, <em>c</em>, <em>count</em>)</p>
<p>与标准 C memset 库函数相同：将位于地址 <em>dst</em> 的内存块用 <em>count</em> 个字节的 <em>c</em> 值填充。 <em>dst</em> 必须为指定地址的整数或 ctypes 实例。</p>
<p><code>ctypes.POINTER</code>(<em>type</em>)</p>
<p>这个工厂函数创建并返回一个新的 ctypes 指针类型。 指针类型会被缓存并在内部重用，因此重复调用此函数耗费不大。 <em>type</em> 必须为 ctypes 类型。</p>
<p><code>ctypes.pointer</code>(<em>obj</em>)</p>
<p>此函数会创建一个新的指向 <em>obj</em> 的指针实例。 返回的对象类型为 <code>POINTER(type(obj))</code>。</p>
<p>注意：如果你只是想向外部函数调用传递一个对象指针，你应当使用更为快速的 <code>byref(obj)</code>。</p>
<p><code>ctypes.resize</code>(<em>obj</em>, <em>size</em>)</p>
<p>此函数可改变 <em>obj</em> 的内部内存缓冲区大小，其参数必须为 ctypes 类型的实例。 没有可能将缓冲区设为小于对象类型的本机大小值，该值由 <code>sizeof(type(obj))</code> 给出，但将缓冲区加大则是可能的。</p>
<p><code>ctypes.set_errno</code>(<em>value</em>)</p>
<p>设置调用线程中系统 <code>errno</code> 变量的 ctypes 私有副本的当前值为 <em>value</em> 并返回原来的值。</p>
<p>引发一个 审计事件 <code>ctypes.set_errno</code> 附带参数 <code>errno</code>。</p>
<p><code>ctypes.set_last_error</code>(<em>value</em>)</p>
<p>仅限 Windows：设置调用线程中系统 <code>LastError</code> 变量的 ctypes 私有副本的当前值为 <em>value</em> 并返回原来的值。</p>
<p>引发一个 审计事件 <code>ctypes.set_last_error</code>，附带参数 <code>error</code>。</p>
<p><code>ctypes.sizeof</code>(<em>obj_or_type</em>)</p>
<p>返回 ctypes 类型或实例的内存缓冲区以字节表示的大小。 其功能与 C <code>sizeof</code> 运算符相同。</p>
<p><code>ctypes.string_at</code>(<em>address</em>, <em>size=- 1</em>)</p>
<p>此函数返回从内存地址 <em>address</em> 开始的以字节串表示的 C 字符串。 如果指定了 size，则将其用作长度，否则将假定字符串以零值结尾。</p>
<p>引发一个 审计事件 <code>ctypes.string_at</code>，附带参数 <code>address</code>, <code>size</code>。</p>
<p><code>ctypes.WinError</code>(<em>code=None</em>, <em>descr=None</em>)</p>
<p>仅限 Windows：此函数可能是 ctypes 中名字起得最差的函数。 它会创建一个 OSError 的实例。 如果未指定 <em>code</em>，则会调用 <code>GetLastError</code> 来确定错误码。 如果未指定 <em>descr</em>，则会调用 <code>FormatError()</code> 来获取错误的文本描述。</p>
<p>在 3.3 版更改: 以前是会创建一个 <code>WindowsError</code> 的实例。</p>
<p><code>ctypes.wstring_at</code>(<em>address</em>, <em>size=- 1</em>)</p>
<p>此函数返回从内存地址 <em>address</em> 开始的以字符串表示的宽字节字符串。 如果指定了 <em>size</em>，则将其用作字符串中的字符数量，否则将假定字符串以零值结尾。</p>
<p>引发一个 审计事件 <code>ctypes.wstring_at</code>，附带参数 <code>address</code>, <code>size</code>。</p>
<h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><p><em>class</em> <code>ctypes._CData</code></p>
<p>这个非公有类是所有 ctypes 数据类型的共同基类。 另外，所有 ctypes 类型的实例都包含一个存放 C 兼容数据的内存块；该内存块的地址可由 <code>addressof()</code> 辅助函数返回。 还有一个实例变量被公开为 <code>_objects</code>；此变量包含其他在内存块包含指针的情况下需要保持存活的 Python 对象。</p>
<p>ctypes 数据类型的通用方法，它们都是类方法（严谨地说，它们是 metaclass 的方法）:</p>
<ul>
<li><p><code>from_buffer</code>(<em>source</em>[, <em>offset</em>])</p>
<p>此方法返回一个共享 <em>source</em> 对象缓冲区的 ctypes 实例。 <em>source</em> 对象必须支持可写缓冲区接口。 可选的 <em>offset</em> 形参指定以字节表示的源缓冲区内偏移量；默认值为零。 如果源缓冲区不够大则会引发 <code>ValueError</code>。</p>
<p>引发一个 审计事件 <code>ctypes.cdata/buffer</code> 附带参数 <code>pointer</code>, <code>size</code>, <code>offset</code>。</p>
</li>
<li><p><code>from_buffer_copy</code>(<em>source</em>[, <em>offset</em>])</p>
<p>此方法创建一个 ctypes 实例，从 <em>source</em> 对象缓冲区拷贝缓冲区，该对象必须是可读的。 可选的 <em>offset</em> 形参指定以字节表示的源缓冲区内偏移量；默认值为零。 如果源缓冲区不够大则会引发 <code>ValueError</code>。</p>
<p>引发一个 审计事件 <code>ctypes.cdata/buffer</code> 附带参数 <code>pointer</code>, <code>size</code>, <code>offset</code>。</p>
</li>
<li><p><code>from_address</code>(<em>address</em>)</p>
<p>此方法会使用 <em>address</em> 所指定的内存返回一个 ctypes 类型的实例，该参数必须为一个整数。</p>
<p>引发一个 审计事件 <code>ctypes.cdata</code>，附带参数 <code>address</code>。</p>
</li>
<li><p><code>from_param</code>(<em>obj</em>)</p>
<p>此方法会将 <em>obj</em> 适配为一个 ctypes 类型。 它调用时会在当该类型存在于外部函数的 <code>argtypes</code> 元组时传入外部函数调用所使用的实际对象；它必须返回一个可被用作函数调用参数的对象。</p>
<p>所有 ctypes 数据类型都带有这个类方法的默认实现，它通常会返回 <em>obj</em>，如果该对象是此类型的实例的话。 某些类型也能接受其他对象。</p>
</li>
<li><p><code>in_dll</code>(<em>library</em>, <em>name</em>)</p>
<p>此方法返回一个由共享库导出的 ctypes 类型。 <em>name</em> 为导出数据的符号名称，<em>library</em> 为所加载的共享库。</p>
</li>
</ul>
<p>ctypes 数据类型的通用实例变量:</p>
<ul>
<li><p><code>_b_base_</code></p>
<p>有时 ctypes 数据实例并不拥有它们所包含的内存块，它们只是共享了某个基对象的部分内存块。 <code>_b_base_</code> 只读成员是拥有内存块的根 ctypes 对象。</p>
</li>
<li><p><code>_b_needsfree_</code></p>
<p>这个只读变量在 ctypes 数据实例自身已分配了内存块时为真值，否则为假值。</p>
</li>
<li><p><code>_objects</code></p>
<p>这个成员或者为 <code>None</code>，或者为一个包含需要保持存活以使内存块的内存保持有效的 Python 对象的字典。 这个对象只是出于调试目的而对外公开；绝对不要修改此字典的内容。</p>
</li>
</ul>
<h4 id="基础数据类型-1"><a href="#基础数据类型-1" class="headerlink" title="基础数据类型"></a>基础数据类型</h4><p><em>class</em> <code>ctypes._SimpleCData</code></p>
<p>这个非公有类是所有基本 ctypes 数据类型的基类。 它在这里被提及是因为它包含基本 ctypes 数据类型共有的属性。 <code>_SimpleCData</code> 是 <code>_CData</code> 的子类，因此继承了其方法和属性。 非指针及不包含指针的 ctypes 数据类型现在将可以被封存。</p>
<p>实例拥有一个属性:</p>
<ul>
<li><p><code>value</code></p>
<p>这个属性包含实例的实际值。 对于整数和指针类型，它是一个整数，对于字符类型，它是一个单字符字符串对象或字符串，对于字符指针类型，它是一个 Python 字节串对象或字符串。</p>
<p>当从 ctypes 实例提取 <code>value</code> 属性时，通常每次会返回一个新的对象。 <code>ctypes</code> 并 <em>没有</em> 实现原始对象返回，它总是会构造一个新的对象。 所有其他 ctypes 对象实例也同样如此。</p>
</li>
</ul>
<p>基本数据类型当作为外部函数调用结果被返回或者作为结构字段成员或数组项被提取时，会透明地转换为原生 Python 类型。 换句话说，如果某个外部函数具有 <code>c_char_p</code> 的 <code>restype</code>，你将总是得到一个 Python 字节串对象，而 <em>不是</em> 一个 <code>c_char_p</code> 实例。</p>
<p>基本数据类型的子类并 <em>没有</em> 继续此行为。 因此，如果一个外部函数的 <code>restype</code> 是 <code>c_void_p</code> 的一个子类，你将从函数调用得到一个该子类的实例。 当然，你可以通过访问 <code>value</code> 属性来获取指针的值。</p>
<p>这些是基本 ctypes 数据类型:</p>
<p><em>class</em> <code>ctypes.c_byte</code></p>
<p>代表 C signed char 数据类型，并将值解读为一个小整数。 该构造器接受一个可选的整数初始化器；不会执行溢出检查。</p>
<p><em>class</em> <code>ctypes.c_char</code></p>
<p>代表 C char 数据类型，并将值解读为单个字符。 该构造器接受一个可选的字符串初始化器，字符串的长度必须恰好为一个字符。</p>
<p><em>class</em> <code>ctypes.c_char_p</code></p>
<p>当指向一个以零为结束符的字符串时代表 C char* 数据类型。 对于通用字符指针来说也可能指向二进制数据，必须要使用 <code>POINTER(c_char)</code>。 该构造器接受一个整数地址，或者一个字节串对象。</p>
<p><em>class</em> <code>ctypes.c_double</code></p>
<p>代表 C double 数据类型。 该构造器接受一个可选的浮点数初始化器。</p>
<p><em>class</em> <code>ctypes.c_longdouble</code></p>
<p>代表 C long double 数据类型。 该构造器接受一个可选的浮点数初始化器。 在 <code>sizeof(long double) == sizeof(double)</code> 的平台上它是 <code>c_double</code> 的一个别名。</p>
<p><em>class</em> <code>ctypes.c_float</code></p>
<p>代表 C float 数据类型。 该构造器接受一个可选的浮点数初始化器。</p>
<p><em>class</em> <code>ctypes.c_int</code></p>
<p>代表 C signed int 数据类型。 该构造器接受一个可选的整数初始化器；不会执行溢出检查。 在 <code>sizeof(int) == sizeof(long)</code> 的平台上它是 <code>c_long</code> 的一个别名。</p>
<p><em>class</em> <code>ctypes.c_int8</code></p>
<p>代表 C 8 位 signed int 数据类型。 通常是 <code>c_byte</code> 的一个别名。</p>
<p><em>class</em> <code>ctypes.c_int16</code></p>
<p>代表 C 16 位 signed int 数据类型。 通常是 <code>c_short</code> 的一个别名。</p>
<p><em>class</em> <code>ctypes.c_int32</code></p>
<p>代表 C 32 位 signed int 数据类型。 通常是 <code>c_int</code> 的一个别名。</p>
<p><em>class</em> <code>ctypes.c_int64</code></p>
<p>代表 C 64 位 signed int 数据类型。 通常是 <code>c_longlong</code> 的一个别名。</p>
<p><em>class</em> <code>ctypes.c_long</code></p>
<p>代表 C signed long 数据类型。 该构造器接受一个可选的整数初始化器；不会执行溢出检查。</p>
<p><em>class</em> <code>ctypes.c_longlong</code></p>
<p>代表 C signed long long 数据类型。 该构造器接受一个可选的整数初始化器；不会执行溢出检查。</p>
<p><em>class</em> <code>ctypes.c_short</code></p>
<p>代表 C signed short 数据类型。 该构造器接受一个可选的整数初始化器；不会执行溢出检查。</p>
<p><em>class</em> <code>ctypes.c_size_t</code></p>
<p>代表 C <code>size_t</code> 数据类型。</p>
<p><em>class</em> <code>ctypes.c_ssize_t</code></p>
<p>代表 C <code>ssize_t</code> 数据类型。</p>
<p>3.2 新版功能.</p>
<p><em>class</em> <code>ctypes.c_ubyte</code></p>
<p>代表 C unsigned char 数据类型，它将值解读为一个小整数。 该构造器接受一个可选的整数初始化器；不会执行溢出检查。</p>
<p><em>class</em> <code>ctypes.c_uint</code></p>
<p>代表 C unsigned int 数据类型。 该构造器接受一个可选的整数初始化器；不会执行溢出检查。 在 <code>sizeof(int) == sizeof(long)</code> 的平台上它是 <code>c_ulong</code> 的一个别名。</p>
<p><em>class</em> <code>ctypes.c_uint8</code></p>
<p>代表 C 8 位 unsigned int 数据类型。 通常是 <code>c_ubyte</code> 的一个别名。</p>
<p><em>class</em> <code>ctypes.c_uint16</code></p>
<p>代表 C 16 位 unsigned int 数据类型。 通常是 <code>c_ushort</code> 的一个别名。</p>
<p><em>class</em> <code>ctypes.c_uint32</code></p>
<p>代表 C 32 位 unsigned int 数据类型。 通常是 <code>c_uint</code> 的一个别名。</p>
<p><em>class</em> <code>ctypes.c_uint64</code></p>
<p>代表 C 64 位 unsigned int 数据类型。 通常是 <code>c_ulonglong</code> 的一个别名。</p>
<p><em>class</em> <code>ctypes.c_ulong</code></p>
<p>代表 C unsigned long 数据类型。 该构造器接受一个可选的整数初始化器；不会执行溢出检查。</p>
<p><em>class</em> <code>ctypes.c_ulonglong</code></p>
<p>代表 C unsigned long long 数据类型。 该构造器接受一个可选的整数初始化器；不会执行溢出检查。</p>
<p><em>class</em> <code>ctypes.c_ushort</code></p>
<p>代表 C unsigned short 数据类型。 该构造器接受一个可选的整数初始化器；不会执行溢出检查。</p>
<p><em>class</em> <code>ctypes.c_void_p</code></p>
<p>代表 C void* 类型。 该值被表示为整数形式。 该构造器接受一个可选的整数初始化器。</p>
<p><em>class</em> <code>ctypes.c_wchar</code></p>
<p>代表 C <code>wchar_t</code> 数据类型，并将值解读为一单个字符的 unicode 字符串。 该构造器接受一个可选的字符串初始化器，字符串的长度必须恰好为一个字符。</p>
<p><em>class</em> <code>ctypes.c_wchar_p</code></p>
<p>代表 C wchar_t* 数据类型，它必须为指向以零为结束符的宽字符串的指针。 该构造器接受一个整数地址或者一个字符串。</p>
<p><em>class</em> <code>ctypes.c_bool</code></p>
<p>代表 C bool 数据类型 (更准确地说是 C99 _Bool)。 它的值可以为 <code>True</code> 或 <code>False</code>，并且该构造器接受任何具有逻辑值的对象。</p>
<p><em>class</em> <code>ctypes.HRESULT</code></p>
<p>Windows 专属：代表一个 <code>HRESULT</code> 值，它包含某个函数或方法调用的成功或错误信息。</p>
<p><em>class</em> <code>ctypes.py_object</code></p>
<p>代表 C PyObject* 数据类型。 不带参数地调用此构造器将创建一个 <code>NULL</code> PyObject* 指针。</p>
<p><code>ctypes.wintypes</code> 模块提供了其他许多 Windows 专属的数据类型，例如 <code>HWND</code>, <code>WPARAM</code> 或 <code>DWORD</code>。 还定义了一些有用的结构体例如 <code>MSG</code> 或 <code>RECT</code>。</p>
<h4 id="结构化数据类型"><a href="#结构化数据类型" class="headerlink" title="结构化数据类型"></a>结构化数据类型</h4><p><em>class</em> <code>ctypes.Union</code>(<em>\</em>args<em>,</em> <em>*kw</em>)</p>
<p>本机字节序的联合所对应的抽象基类。</p>
<p><em>class</em> <code>ctypes.BigEndianStructure</code>(<em>\</em>args<em>,</em> <em>*kw</em>)</p>
<p><em>大端</em> 字节序的结构体所对应的抽象基类。</p>
<p><em>class</em> <code>ctypes.LittleEndianStructure</code>(<em>\</em>args<em>,</em> <em>*kw</em>)</p>
<p><em>小端</em> 字节序的结构体所对应的抽象基类。</p>
<p>非本机字节序的结构体不能包含指针类型字段，或任何其他包含指针类型字段的数据类型。</p>
<p><em>class</em> <code>ctypes.Structure</code>(<em>\</em>args<em>,</em> <em>*kw</em>)</p>
<p><em>本机</em> 字节序的结构体所对应的抽象基类。</p>
<p>实际的结构体和联合类型必须通过子类化这些类型之一来创建，并且至少要定义一个 <code>_fields_</code> 类变量。 <code>ctypes</code> 将创建 descriptor，它允许通过直接属性访问来读取和写入字段。 这些是</p>
<ul>
<li><p><code>_fields_</code></p>
<p>一个定义结构体字段的序列。 其中的条目必须为 2 元组或 3 元组。 元组的第一项是字段名称，第二项指明字段类型；它可以是任何 ctypes 数据类型。</p>
<p>对于整数类型字段例如 <code>c_int</code>，可以给定第三个可选项。 它必须是一个定义字段比特位宽度的小正整数。</p>
<p>字段名称在一个结构体或联合中必须唯一。 不会检查这个唯一性，但当名称出现重复时将只有一个字段可被访问。</p>
<p>可以在定义 Structure 子类的类语句 <em>之后</em> 再定义 <code>_fields_</code> 类变量，这将允许创建直接或间接引用其自身的数据类型:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">List</span><span class="token punctuation">(</span>Structure<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">pass</span>
List<span class="token punctuation">.</span>_fields_ <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token string">"pnext"</span><span class="token punctuation">,</span> POINTER<span class="token punctuation">(</span>List<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                 <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
                <span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>但是，<code>_fields_</code> 类变量必须在类型第一次被使用（创建实例，调用 <code>sizeof()</code> 等等）之前进行定义。 在此之后对 <code>_fields_</code> 类变量赋值将会引发 AttributeError。</p>
<p>可以定义结构体类型的子类，它们会继承基类的字段再加上在子类中定义的任何 <code>_fields_</code>。</p>
</li>
<li><p><code>_pack_</code></p>
<p>一个可选的小整数，它允许覆盖实体中结构体字段的对齐方式。 当 <code>_fields_</code> 被赋值时必须已经定义了 <code>_pack_</code>，否则它将没有效果。</p>
</li>
<li><p><code>_anonymous_</code></p>
<p>一个可选的序列，它会列出未命名（匿名）字段的名称。 当 <code>_fields_</code> 被赋值时必须已经定义了 <code>_anonymous_</code>，否则它将没有效果。</p>
<p>在此变量中列出的字段必须为结构体或联合类型字段。 <code>ctypes</code> 将在结构体类型中创建描述器以允许直接访问嵌套字段，而无需创建对应的结构体或联合字段。</p>
<p>以下是一个示例类型（Windows）:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">_U</span><span class="token punctuation">(</span>Union<span class="token punctuation">)</span><span class="token punctuation">:</span>
    _fields_ <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token string">"lptdesc"</span><span class="token punctuation">,</span> POINTER<span class="token punctuation">(</span>TYPEDESC<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                <span class="token punctuation">(</span><span class="token string">"lpadesc"</span><span class="token punctuation">,</span> POINTER<span class="token punctuation">(</span>ARRAYDESC<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                <span class="token punctuation">(</span><span class="token string">"hreftype"</span><span class="token punctuation">,</span> HREFTYPE<span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token keyword">class</span> <span class="token class-name">TYPEDESC</span><span class="token punctuation">(</span>Structure<span class="token punctuation">)</span><span class="token punctuation">:</span>
    _anonymous_ <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token string">"u"</span><span class="token punctuation">,</span><span class="token punctuation">)</span>
    _fields_ <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token string">"u"</span><span class="token punctuation">,</span> _U<span class="token punctuation">)</span><span class="token punctuation">,</span>
                <span class="token punctuation">(</span><span class="token string">"vt"</span><span class="token punctuation">,</span> VARTYPE<span class="token punctuation">)</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>TYPEDESC</code> 结构体描述了一个 COM 数据类型，<code>vt</code> 字段指明哪个联合字段是有效的。 由于 <code>u</code> 字段被定义为匿名字段，现在可以直接从 TYPEDESC 实例访问成员。 <code>td.lptdesc</code> 和 <code>td.u.lptdesc</code> 是等价的，但前者速度更快，因为它不需要创建临时的联合实例:</p>
<pre class="line-numbers language-python"><code class="language-python">td <span class="token operator">=</span> TYPEDESC<span class="token punctuation">(</span><span class="token punctuation">)</span>
td<span class="token punctuation">.</span>vt <span class="token operator">=</span> VT_PTR
td<span class="token punctuation">.</span>lptdesc <span class="token operator">=</span> POINTER<span class="token punctuation">(</span>some_type<span class="token punctuation">)</span>
td<span class="token punctuation">.</span>u<span class="token punctuation">.</span>lptdesc <span class="token operator">=</span> POINTER<span class="token punctuation">(</span>some_type<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
<p>可以定义结构体的子类，它们会继承基类的字段。 如果子类定义具有单独的 <code>_fields_</code> 变量，在其中指定的字段会被添加到基类的字段中。</p>
<p>结构体和联合的构造器均可接受位置和关键字参数。 位置参数用于按照 <code>_fields_</code> 中的出现顺序来初始化成员字段。 构造器中的关键字参数会被解读为属性赋值，因此它们将以相应的名称来初始化 <code>_fields_</code>，或为不存在于 <code>_fields_</code> 中的名称创建新的属性。</p>
<h4 id="数组与指针"><a href="#数组与指针" class="headerlink" title="数组与指针"></a>数组与指针</h4><p><em>class</em> <code>ctypes.Array</code>(<em>\</em>args*)</p>
<p>数组的抽象基类。</p>
<p>创建实际数组类型的推荐方式是通过将任意 <code>ctypes</code> 类型与一个正整数相乘。 作为替代方式，你也可以子类化这个类型并定义 <code>_length_</code> 和 <code>_type_</code> 类变量。 数组元素可使用标准的抽取和切片方式来读写；对于切片读取，结果对象本身 <em>并非</em> 一个 <code>Array</code>。</p>
<ul>
<li><p><code>_length_</code></p>
<p>一个指明数组中元素数量的正整数。 超出范围的抽取会导致 <code>IndexError</code>。 该值将由 <code>len()</code> 返回。</p>
</li>
<li><p><code>_type_</code></p>
<p>指明数组中每个元素的类型。</p>
</li>
</ul>
<p>Array 子类构造器可接受位置参数，用来按顺序初始化元素。</p>
<p><em>class</em> <code>ctypes._Pointer</code></p>
<p>私有对象，指针的抽象基类。</p>
<p>实际的指针类型是通过调用 <code>POINTER()</code> 并附带其将指向的类型来创建的；这会由 <code>pointer()</code> 自动完成。</p>
<p>如果一个指针指向的是数组，则其元素可使用标准的抽取和切片方式来读写。 指针对象没有长度，因此 <code>len()</code> 将引发 <code>TypeError</code>。 抽取负值将会从指针 <em>之前</em> 的内存中读取（与 C 一样），并且超出范围的抽取将可能因非法访问而导致崩溃（视你的运气而定）。</p>
<ul>
<li><p><code>_type_</code></p>
<p>指明所指向的类型。</p>
</li>
<li><p><code>contents</code></p>
<p>返回指针所指向的对象。 对此属性赋值会使指针改为指向所赋值的对象。</p>
</li>
</ul>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://jackhcc.github.io" rel="external nofollow noreferrer">杰克成</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://jackhcc.github.io/posts/Language-Python-Lib2.html">https://jackhcc.github.io/posts/Language-Python-Lib2.html</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="https://jackhcc.github.io" target="_blank">杰克成</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/Python/">
                                    <span class="chip bg-color">Python</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/share/css/share.min.css">

<div id="article-share">
    
    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/medias/reward/aliqr.png" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/medias/reward/wxqr.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>
            
        </div>
    </div>

    
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/gitalk/gitalk.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/css/my-gitalk.css">

<div class="card gitalk-card" data-aos="fade-up">
    <div class="comment_headling" style="font-size: 20px; font-weight: 700; position: relative; left: 20px; top: 15px; padding-bottom: 5px;">
        <i class="fas fa-comments fa-fw" aria-hidden="true"></i>
        <span>评论</span>
    </div>
    <div id="gitalk-container" class="card-content"></div>
</div>

<script src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/gitalk/gitalk.min.js"></script>
<script>
    let gitalk = new Gitalk({
        clientID: '3821a0bbb773038a51fc',
        clientSecret: '4b30b507d67ec5497ec0e77f43f80cb3e0d7dd3a',
        repo: 'JackHCC.github.io',
        owner: 'JackHCC',
        admin: "JackHCC",
        id: '2021-11-04T18-42-52',
        distractionFreeMode: false  // Facebook-like distraction free mode
    });

    gitalk.render('gitalk-container');
</script>
    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/posts/dl-series17.html">
                    <div class="card-image">
                        
                        
                        <img src="/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/medias/featureimages/9.jpg" class="responsive-img" alt="DL专栏17-网络可视化">
                        
                        <span class="card-title">DL专栏17-网络可视化</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            深度学习模型网络可视化概述
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2021-11-05
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/Deep-Learning/" class="post-category">
                                    Deep Learning
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Deep-Learning/">
                        <span class="chip bg-color">Deep Learning</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/posts/Language-Python-Lib1.html">
                    <div class="card-image">
                        
                        
                        <img src="/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/medias/featureimages/7.jpg" class="responsive-img" alt="Python-Standard Library">
                        
                        <span class="card-title">Python-Standard Library</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            Python标准库详解【1】
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2021-11-03
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/Language/" class="post-category">
                                    Language
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Python/">
                        <span class="chip bg-color">Python</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/codeBlock/codeShrink.js"></script>


<!-- 代码块折行 -->

<style type="text/css">
code[class*="language-"], pre[class*="language-"] { white-space: pre !important; }
</style>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('4'),
            headingSelector: 'h1, h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h1, h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>



    <footer class="page-footer bg-color">
    <div class="container row center-align" style="margin-bottom: 15px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            <span id="year">2020</span>
            <a href="https://jackhcc.github.io" target="_blank">杰克成</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                class="white-color">3591.2k</span>&nbsp;字
            
            
            
            
            
            
            <span id="busuanzi_container_site_pv">
                |&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv"
                    class="white-color"></span>&nbsp;次
            </span>
            
            
            <span id="busuanzi_container_site_uv">
                |&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv"
                    class="white-color"></span>&nbsp;人
            </span>
            
            <br>
            
            <span id="sitetime">载入运行时间...</span>
            <script>
                function siteTime() {
                    var seconds = 1000;
                    var minutes = seconds * 60;
                    var hours = minutes * 60;
                    var days = hours * 24;
                    var years = days * 365;
                    var today = new Date();
                    var startYear = "2020";
                    var startMonth = "2";
                    var startDate = "27";
                    var startHour = "6";
                    var startMinute = "30";
                    var startSecond = "0";
                    var todayYear = today.getFullYear();
                    var todayMonth = today.getMonth() + 1;
                    var todayDate = today.getDate();
                    var todayHour = today.getHours();
                    var todayMinute = today.getMinutes();
                    var todaySecond = today.getSeconds();
                    var t1 = Date.UTC(startYear, startMonth, startDate, startHour, startMinute, startSecond);
                    var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
                    var diff = t2 - t1;
                    var diffYears = Math.floor(diff / years);
                    var diffDays = Math.floor((diff / days) - diffYears * 365);
                    var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours);
                    var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) /
                        minutes);
                    var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours -
                        diffMinutes * minutes) / seconds);
                    if (startYear == todayYear) {
                        document.getElementById("year").innerHTML = todayYear;
                        document.getElementById("sitetime").innerHTML = "本站已安全运行 " + diffDays + " 天 " + diffHours +
                            " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                    } else {
                        document.getElementById("year").innerHTML = startYear + " - " + todayYear;
                        document.getElementById("sitetime").innerHTML = "本站已安全运行 " + diffYears + " 年 " + diffDays +
                            " 天 " + diffHours + " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                    }
                }
                setInterval(siteTime, 1000);
            </script>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/JackHCC" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:jackcc0701@163.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>



    <a href="https://www.facebook.com/profile.php?id=100046343443643" class="tooltipped" target="_blank" data-tooltip="关注我的Facebook: https://www.facebook.com/profile.php?id=100046343443643" data-position="top" data-delay="50">
        <i class="fab fa-facebook-f"></i>
    </a>



    <a href="https://twitter.com/JackChe66021834" class="tooltipped" target="_blank" data-tooltip="关注我的Twitter: https://twitter.com/JackChe66021834" data-position="top" data-delay="50">
        <i class="fab fa-twitter"></i>
    </a>



    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=2508074836" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 2508074836" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>



    <a href="https://weibo.com/u/6885584679" class="tooltipped" target="_blank" data-tooltip="关注我的微博: https://weibo.com/u/6885584679" data-position="top" data-delay="50">
        <i class="fab fa-weibo"></i>
    </a>



    <a href="https://www.zhihu.com/people/8f8482f01f0d6a04e844efe32e0f0710" class="tooltipped" target="_blank" data-tooltip="关注我的知乎: https://www.zhihu.com/people/8f8482f01f0d6a04e844efe32e0f0710" data-position="top" data-delay="50">
        <i class="fab fa-zhihu1">知</i>
    </a>



</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/js/search.js"></script>
<script type="text/javascript">
$(function () {
    searchFunc("https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/" + "search.xml", 'searchInput', 'searchResult');
});
</script>
    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/materialize/materialize.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/aos/aos.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/js/matery.js"></script>

    <canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" ></canvas>
    <script type="text/javascript" src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script>
    <script type="text/javascript" src="/js/fireworks.js"></script>

    <script type="text/javascript">
        //只在桌面版网页启用特效
        var windowWidth = $(window).width();
        if (windowWidth > 768) {
            document.write('<script type="text/javascript" src="/js/sakura.js"><\/script>'); }
    </script>

    <!-- weather -->
	<script type="text/javascript">
	WIDGET = {FID: 'TToslpmkVO'}
	</script>
	<script type="text/javascript" src="https://apip.weatherdt.com/float/static/js/r.js?v=1111"></script>


    <!-- Global site tag (gtag.js) - Google Analytics -->


    <!-- Baidu Analytics -->

<script>
    var _hmt = _hmt || [];
    (function () {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
    })();
</script>

    <!-- Baidu Push -->

    
    
    <script async src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/others/busuanzi.pure.mini.js"></script>
    

    
        <script src="//code.tidio.co/kqhlkxviiccyoa0czpfpu4ijuey9hfre.js"></script>
        <script> 
            $(document).ready(function () {
                setInterval(change_Tidio, 50);  
                function change_Tidio() { 
                    var tidio=$("#tidio-chat iframe");
                    if(tidio.css("display")=="block"&& $(window).width()>977 ){
                        document.getElementById("tidio-chat-iframe").style.bottom= ($("div#backTop.top-scroll").css("display")=="none" &&$(window).width()>977)>0? "-40px" : ($("div.toc-title").length&&$(window).width()>977)>0?"85px":"20px";   
                        document.getElementById("tidio-chat-iframe").style.right="-15px";   
                        document.getElementById("tidio-chat-iframe").style.height=parseInt(tidio.css("height"))>=520?"520px":tidio.css("height");
                        document.getElementById("tidio-chat-iframe").style.zIndex="997";
                    } 
                    else if(tidio.css("display")=="block"&&$(window).width()>601 &&$(window).width()<992 ){
                        document.getElementById("tidio-chat-iframe").style.bottom= ($("div#backTop.top-scroll").css("display")=="none" && 601< $(window).width()<992)>0? "-40px":"20px" ;   
                        document.getElementById("tidio-chat-iframe").style.right="-15px"; 
                        document.getElementById("tidio-chat-iframe").style.zIndex="997";
                    }
                    else if(tidio.css("display")=="block"&&$(window).width()<601 && parseInt(tidio.css("height"))<230){
                        document.getElementById("tidio-chat-iframe").style.bottom= ($("div#backTop.top-scroll").css("display")=="none" && $(window).width()<601)>0? "-10px":"45px" ;   
                        document.getElementById("tidio-chat-iframe").style.zIndex="997";
                    }
                    if( tidio.css("display")=="block"&&$(window).width()<601 && parseInt(tidio.css("height"))>=230){
                        document.getElementById("tidio-chat-iframe").style.zIndex="998";
                    }
                } 
            }); 
        </script>
    

    

    
    <script type="text/javascript" color="0,0,255"
        pointColor="0,0,255" opacity='0.7'
        zIndex="-1" count="99"
        src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/background/canvas-nest.js"></script>
    

    

    
    <script type="text/javascript" src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/background/ribbon-dynamic.js" async="async"></script>
    
    
    
    <script src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/instantpage/instantpage.js" type="module"></script>
    

        <script src="//cdn.jsdelivr.net/npm/js-base64/base64.min.js"></script>
        <script>
        $('a').each(function() {
          const $this = $(this);
          const href = $this.attr('href');
          if (href && href.match('^((http|https|thunder|qqdl|ed2k|Flashget|qbrowser|ftp|rtsp|mms)://)')) {
            const strs = href.split('/');
            if (strs.length >= 3) {
                const host = strs[2];
                if (host !== 'your_domain' || window.location.host) {
                    $this.attr('href', '/go.html?u='+Base64.encode(href)+'').attr('rel', 'external nofollow noopener noreferrer');
                    if (true) {
                        $this.attr('target', '_blank');
                    }
                }
            }
          }
        });
        </script><script>!function(e){var c=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));function i(){for(var r=0;r<c.length;r++)t=c[r],0<=(n=t.getBoundingClientRect()).bottom&&0<=n.left&&n.top<=(e.innerHeight||document.documentElement.clientHeight)&&function(){var t,n,e,i,o=c[r];t=o,n=function(){c=c.filter(function(t){return o!==t})},e=new Image,i=t.getAttribute("data-original"),e.onload=function(){t.src=i,n&&n()},e.src=i}();var t,n}i(),e.addEventListener("scroll",function(){var t,n;t=i,n=e,clearTimeout(t.tId),t.tId=setTimeout(function(){t.call(n)},500)})}(this);</script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script></body>

</html>

