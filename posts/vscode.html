<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="Vscode源码与插件详解, JackHCC">
    <meta name="description" content="Vscode源码与插件开发学习">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Vscode源码与插件详解 | JackHCC</title>
    <link rel="icon" type="image/png" href="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/medias/favicon.png">

    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/css/matery.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/css/my.css">
    
    <script src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/jquery/jquery.min.js"></script>
    
<meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="JackHCC" type="application/atom+xml">
<link rel="stylesheet" href="/css/prism-hopscotch.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper head-container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/medias/me.jpg" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">JackHCC</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="" class="waves-effect waves-light">

      
      <i class="fas fa-list" style="zoom: 0.6;"></i>
      
      <span>Tools</span>
      <i class="fas fa-chevron-down" aria-hidden="true" style="zoom: 0.6;"></i>
    </a>
    <ul class="sub-nav menus_item_child ">
      
      <li>
        <a href="https://creativecc.cn/" target="_blank" rel="noopener">
          
          <i class="fas fa-book" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>Creative工具导航</span>
        </a>
      </li>
      
      <li>
        <a href="https://blog.creativecc.cn/Arxiv-NLP-Reporter/" target="_blank" rel="noopener">
          
          <i class="fas fa-film" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>NLP每日论文</span>
        </a>
      </li>
      
      <li>
        <a href="http://chat.creativecc.cn/" target="_blank" rel="noopener">
          
          <i class="fas fa-music" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>RocketChat聊天室</span>
        </a>
      </li>
      
      <li>
        <a href="/contact">
          
          <i class="fas fa-comments" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>Contact留言板</span>
        </a>
      </li>
      
    </ul>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>

<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/medias/me.jpg" class="logo-img circle responsive-img">
        
        <div class="logo-name">JackHCC</div>
        <div class="logo-desc">
            
            Make the world betterrrr!!!
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="javascript:;">
			
				<i class="fa-fw fas fa-list"></i>
			
			Tools
			<span class="m-icon"><i class="fas fa-chevron-right"></i></span>
		</a>
            <ul  style="background:  ;" >
              
                <li>   
				
                  <a href="https://creativecc.cn/ " target="_blank" rel="noopener" style="margin-left:75px";>
				  
				   <i class="fa fas fa-book" style="position: absolute;left:50px" ></i>
			      
		          <span>Creative工具导航</span>
                  </a>
                </li>
              
                <li>   
				
                  <a href="https://blog.creativecc.cn/Arxiv-NLP-Reporter/ " target="_blank" rel="noopener" style="margin-left:75px";>
				  
				   <i class="fa fas fa-film" style="position: absolute;left:50px" ></i>
			      
		          <span>NLP每日论文</span>
                  </a>
                </li>
              
                <li>   
				
                  <a href="http://chat.creativecc.cn/ " target="_blank" rel="noopener" style="margin-left:75px";>
				  
				   <i class="fa fas fa-music" style="position: absolute;left:50px" ></i>
			      
		          <span>RocketChat聊天室</span>
                  </a>
                </li>
              
                <li>   
				
                  <a href="/contact " style="margin-left:75px";>
				  
				   <i class="fa fas fa-comments" style="position: absolute;left:50px" ></i>
			      
		          <span>Contact留言板</span>
                  </a>
                </li>
               
            </ul>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/JackHCC/JackHCC.github.io" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>

        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/JackHCC/JackHCC.github.io" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    
<script src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/cryptojs/crypto-js.min.js"></script>
<script>
    (function() {
        let pwd = '';
        if (pwd && pwd.length > 0) {
            if (pwd !== CryptoJS.SHA256(prompt('请输入访问本文章的密码')).toString(CryptoJS.enc.Hex)) {
                alert('密码错误，将返回主页！');
                location.href = '/';
            }
        }
    })();
</script>




<div class="bg-cover pd-header post-cover" style="background-image: url('https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/medias/featureimages/20.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">Vscode源码与插件详解</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        margin: 35px 0 15px 0;
        padding-left: 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        height: calc(100vh - 250px);
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #toc-content .is-active-link::before {
        background-color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 30px;
        bottom: 146px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/Vscode/">
                                <span class="chip bg-color">Vscode</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/Development/" class="post-category">
                                Development
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2021-09-11
                </div>
                

                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-check fa-fw"></i>更新日期:&nbsp;&nbsp;
                    2021-09-15
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    85.7k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    341 分
                </div>
                

                
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="far fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>

        </div>
        <hr class="clearfix">
        <div class="card-content article-card-content">
            <div id="articleContent">
                <h1 id="Keyboard-Reference-Sheets"><a href="#Keyboard-Reference-Sheets" class="headerlink" title="Keyboard Reference Sheets"></a>Keyboard Reference Sheets</h1><p>Download the keyboard shortcut reference sheet for your platform (<a href="https://go.microsoft.com/fwlink/?linkid=832143" target="_blank" rel="noopener">macOS</a>, <a href="https://go.microsoft.com/fwlink/?linkid=832145" target="_blank" rel="noopener">Windows</a>, <a href="https://go.microsoft.com/fwlink/?linkid=832144" target="_blank" rel="noopener">Linux</a>).</p>
<p><img src="/images/loading.gif" data-original="../images/development/KeyboardReferenceSheet.png" alt=""></p>
<h1 id="🤩Vscode源码分析"><a href="#🤩Vscode源码分析" class="headerlink" title="🤩Vscode源码分析"></a>🤩Vscode源码分析</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Visual Studio Code(简称VSCode) 是开源免费的IDE编辑器，原本是微软内部使用的云编辑器(Monaco)。</p>
<p>git仓库地址： <a href="https://github.com/microsoft/vscode" target="_blank" rel="noopener">https://github.com/microsoft/vscode</a></p>
<p>通过Eletron集成了桌面应用，可以跨平台使用，开发语言主要采用微软自家的TypeScript。 整个项目结构比较清晰，方便阅读代码理解。成为了最流行跨平台的桌面IDE应用</p>
<p>微软希望VSCode在保持核心轻量级的基础上，增加项目支持，智能感知，编译调试。 <img src="/images/loading.gif" data-original="../images/development/vscode-vside-zh.png" alt=""></p>
<h3 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h3><p>下载最新版本,目前我用的是1.37.1版本 官方的wiki中有编译安装的说明 <a href="https://github.com/microsoft/vscode/wiki/How-to-Contribute?_blank" target="_blank" rel="noopener">How to Contribute</a></p>
<p>Linux, Window, MacOS三个系统编译时有些差别，参考官方文档， 在编译安装依赖时如果遇到connect timeout, 需要进行科学上网。</p>
<blockquote>
<p>需要注意的一点 运行环境依赖版本 Nodejs x64 version &gt;= 10.16.0, &lt; 11.0.0, python 2.7(3.0不能正常执行)</p>
</blockquote>
<h3 id="技术架构"><a href="#技术架构" class="headerlink" title="技术架构"></a>技术架构</h3><p><img src="/images/loading.gif" data-original="../images/development/vscode-framework.png" alt=""></p>
<h4 id="Electron"><a href="#Electron" class="headerlink" title="Electron"></a>Electron</h4><blockquote>
<p><a href="https://electronjs.org/?_blank" target="_blank" rel="noopener">Electron</a> 是一个使用 JavaScript, HTML 和 CSS 等 Web 技术创建原生程序的框架，它负责比较难搞的部分，你只需把精力放在你的应用的核心上即可 (Electron = Node.js + Chromium + Native API)</p>
</blockquote>
<h4 id="Monaco-Editor"><a href="#Monaco-Editor" class="headerlink" title="Monaco Editor"></a>Monaco Editor</h4><blockquote>
<p><a href="https://github.com/microsoft/monaco-editor?_blank" target="_blank" rel="noopener">Monaco Editor</a>是微软开源项目, 为VS Code提供支持的代码编辑器，运行在浏览器环境中。编辑器提供代码提示，智能建议等功能。供开发人员远程更方便的编写代码，可独立运行。</p>
</blockquote>
<h4 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h4><blockquote>
<p>TypeScript是一种由微软开发的自由和开源的编程语言。它是JavaScript的一个超集，而且本质上向这个语言添加了可选的静态类型和基于类的面向对象编程</p>
</blockquote>
<h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><pre><code>├── build         # gulp编译构建脚本
├── extensions    # 内置插件
├── product.json  # App meta信息
├── resources     # 平台相关静态资源
├── scripts       # 工具脚本，开发/测试
├── src           # 源码目录
└── typings       # 函数语法补全定义
└── vs
├──base# 通用工具/协议和UI库
│├── browser # 基础UI组件，DOM操作
│├── common  # diff描述，markdown解析器，worker协议，各种工具函数
│├── node    # Node工具函数
│├── parts   # IPC协议（Electron、Node），quickopen、tree组件
│├── test    # base单测用例
│└── worker  # Worker factory和main Worker（运行IDE Core：Monaco）
├── code        # VSCode主运行窗口
├── editor        # IDE代码编辑器
|├── browser     # 代码编辑器核心
|├── common      # 代码编辑器核心
|├── contrib     # vscode 与独立 IDE共享的代码
|└── standalone  # 独立 IDE 独有的代码
├── platform      # 支持注入服务和平台相关基础服务（文件、剪切板、窗体、状态栏）
├── workbench     # 工作区UI布局，功能主界面
│├── api              # 
│├── browser          # 
│├── common           # 
│├── contrib          # 
│├── electron-browser # 
│├── services         # 
│└── test             # 
├── css.build.js  # 用于插件构建的CSS loader
├── css.js        # CSS loader
├── editor        # 对接IDE Core（读取编辑/交互状态），提供命令、上下文菜单、hover、snippet等支持
├── loader.js     # AMD loader（用于异步加载AMD模块）
├── nls.build.js  # 用于插件构建的NLS loader
└── nls.js        # NLS（National Language Support）多语言loader</code></pre><h4 id="核心层"><a href="#核心层" class="headerlink" title="核心层"></a>核心层</h4><ul>
<li>base: 提供通用服务和构建用户界面</li>
<li>platform: 注入服务和基础服务代码</li>
<li>editor: 微软Monaco编辑器，也可独立运行使用</li>
<li>wrokbench: 配合Monaco并且给viewlets提供框架：如：浏览器状态栏，菜单栏利用electron实现桌面程序</li>
</ul>
<h4 id="核心环境"><a href="#核心环境" class="headerlink" title="核心环境"></a>核心环境</h4><p>整个项目完全使用typescript实现，electron中运行主进程和渲染进程，使用的api有所不同，所以在core中每个目录组织也是按照使用的api来安排， 运行的环境分为几类：</p>
<ul>
<li>common: 只使用javascritp api的代码，能在任何环境下运行</li>
<li>browser: 浏览器api, 如操作dom; 可以调用common</li>
<li>node: 需要使用node的api,比如文件io操作</li>
<li>electron-brower: 渲染进程api, 可以调用common, brower, node, 依赖<a href="https://github.com/electron/electron/tree/master/docs#modules-for-the-renderer-process-web-page" target="_blank" rel="noopener">electron renderer-process API</a></li>
<li>electron-main: 主进程api, 可以调用: common, node 依赖于<a href="https://github.com/electron/electron/tree/master/docs#modules-for-the-main-process" target="_blank" rel="noopener">electron main-process AP</a></li>
</ul>
<p><img src="/images/loading.gif" data-original="../images/development/vscode-welcome.png" alt=""></p>
<h2 id="主启动流程"><a href="#主启动流程" class="headerlink" title="主启动流程"></a>主启动流程</h2><p><strong>Electron通过package.json中的main字段来定义应用入口。</strong></p>
<p>main.js是vscode的入口。</p>
<ul>
<li>src/main.js<ul>
<li>vs/code/electron-main/main.ts</li>
<li>vs/code/electron-main/app.ts</li>
<li>vs/code/electron-main/windows.ts</li>
<li>vs/workbench/electron-browser/desktop.main.ts</li>
<li>vs/workbench/browser/workbench.ts</li>
</ul>
</li>
</ul>
<pre><code>app.once('ready', function () {
    //启动追踪，后面会讲到，跟性能检测优化相关。
    if (args['trace']) {
        // @ts-ignore
        const contentTracing = require('electron').contentTracing;
        const traceOptions = {
            categoryFilter: args['trace-category-filter'] || '*',
            traceOptions: args['trace-options'] || 'record-until-full,enable-sampling'
        };
        contentTracing.startRecording(traceOptions, () =&gt; onReady());
    } else {
        onReady();
    }
});
function onReady() {
    perf.mark('main:appReady');
    Promise.all([nodeCachedDataDir.ensureExists(), userDefinedLocale]).then(([cachedDataDir, locale]) =&gt; {
        //1. 这里尝试获取本地配置信息，如果有的话会传递到startup
        if (locale &amp;&amp; !nlsConfiguration) {
            nlsConfiguration = lp.getNLSConfiguration(product.commit, userDataPath, metaDataFile, locale);
        }
        if (!nlsConfiguration) {
            nlsConfiguration = Promise.resolve(undefined);
        }
        nlsConfiguration.then(nlsConfig =&gt; {
            //4. 首先会检查用户语言环境配置，如果没有设置默认使用英语 
            const startup = nlsConfig =&gt; {
                nlsConfig._languagePackSupport = true;
                process.env['VSCODE_NLS_CONFIG'] = JSON.stringify(nlsConfig);
                process.env['VSCODE_NODE_CACHED_DATA_DIR'] = cachedDataDir || '';
                perf.mark('willLoadMainBundle');
                //使用微软的loader组件加载electron-main/main文件
                require('./bootstrap-amd').load('vs/code/electron-main/main', () =&gt; {
                    perf.mark('didLoadMainBundle');
                });
            };
            // 2. 接收到有效的配置传入是其生效，调用startup
            if (nlsConfig) {
                startup(nlsConfig);
            }
            // 3. 这里尝试使用本地的应用程序
            // 应用程序设置区域在ready事件后才有效
            else {
                let appLocale = app.getLocale();
                if (!appLocale) {
                    startup({ locale: 'en', availableLanguages: {} });
                } else {
                    // 配置兼容大小写敏感，所以统一转换成小写
                    appLocale = appLocale.toLowerCase();
                    // 这里就会调用config服务，把本地配置加载进来再调用startup
                    lp.getNLSConfiguration(product.commit, userDataPath, metaDataFile, appLocale).then(nlsConfig =&gt; {
                        if (!nlsConfig) {
                            nlsConfig = { locale: appLocale, availableLanguages: {} };
                        }
                        startup(nlsConfig);
                    });
                }
            }
        });
    }, console.error);
}</code></pre><h3 id="vs-code-electron-main-main-ts"><a href="#vs-code-electron-main-main-ts" class="headerlink" title="vs/code/electron-main/main.ts"></a>vs/code/electron-main/main.ts</h3><p>electron-main/main 是程序真正启动的入口,进入main process初始化流程.</p>
<h4 id="这里主要做了两件事情："><a href="#这里主要做了两件事情：" class="headerlink" title="这里主要做了两件事情："></a>这里主要做了两件事情：</h4><ol>
<li>初始化Service</li>
<li>启动主实例</li>
</ol>
<p>直接看startup方法的实现,基础服务初始化完成后会加载 CodeApplication, mainIpcServer, instanceEnvironment，调用 startup 方法启动APP</p>
<pre><code>private async startup(args: ParsedArgs): Promise&lt;void&gt; {
        //spdlog 日志服务
        const bufferLogService = new BufferLogService();
        // 1. 调用 createServices
        const [instantiationService, instanceEnvironment] = this.createServices(args, bufferLogService);
        try {
            // 1.1 初始化Service服务
            await instantiationService.invokeFunction(async accessor =&gt; {
                // 基础服务，包括一些用户数据，缓存目录
                const environmentService = accessor.get(IEnvironmentService);
                // 配置服务
                const configurationService = accessor.get(IConfigurationService);
                // 持久化数据
                const stateService = accessor.get(IStateService);
                try {
                    await this.initServices(environmentService, configurationService as ConfigurationService, stateService as StateService);
                } catch (error) {
                    // 抛出错误对话框
                    this.handleStartupDataDirError(environmentService, error);
                    throw error;
                }
            });
            // 1.2 启动实例
            await instantiationService.invokeFunction(async accessor =&gt; {
                const environmentService = accessor.get(IEnvironmentService);
                const logService = accessor.get(ILogService);
                const lifecycleService = accessor.get(ILifecycleService);
                const configurationService = accessor.get(IConfigurationService);
                const mainIpcServer = await this.doStartup(logService, environmentService, lifecycleService, instantiationService, true);
                bufferLogService.logger = new SpdLogService('main', environmentService.logsPath, bufferLogService.getLevel());
                once(lifecycleService.onWillShutdown)(() =&gt; (configurationService as ConfigurationService).dispose());
                return instantiationService.createInstance(CodeApplication, mainIpcServer, instanceEnvironment).startup();
            });
        } catch (error) {
            instantiationService.invokeFunction(this.quit, error);
        }
    }</code></pre><h4 id="vs-code-electron-main-app-ts"><a href="#vs-code-electron-main-app-ts" class="headerlink" title="vs/code/electron-main/app.ts"></a>vs/code/electron-main/app.ts</h4><p>这里首先触发CodeApplication.startup()方法， 在第一个窗口打开3秒后成为共享进程，</p>
<pre><code>async startup(): Promise&lt;void&gt; {
    ...
    // 1. 第一个窗口创建共享进程
    const sharedProcess = this.instantiationService.createInstance(SharedProcess, machineId, this.userEnv);
    const sharedProcessClient = sharedProcess.whenReady().then(() =&gt; connect(this.environmentService.sharedIPCHandle, 'main'));
    this.lifecycleService.when(LifecycleMainPhase.AfterWindowOpen).then(() =&gt; {
        this._register(new RunOnceScheduler(async () =&gt; {
            const userEnv = await getShellEnvironment(this.logService, this.environmentService);
            sharedProcess.spawn(userEnv);
        }, 3000)).schedule();
    });
    // 2. 创建app实例
    const appInstantiationService = await this.createServices(machineId, trueMachineId, sharedProcess, sharedProcessClient);
    // 3. 打开一个窗口 调用 
    const windows = appInstantiationService.invokeFunction(accessor =&gt; this.openFirstWindow(accessor, electronIpcServer, sharedProcessClient));
    // 4. 窗口打开后执行生命周期和授权操作
    this.afterWindowOpen();
    ...
    //vscode结束了性能问题的追踪
    if (this.environmentService.args.trace) {
        this.stopTracingEventually(windows);
    }
}</code></pre><p>openFirstWindow 主要实现 CodeApplication.openFirstWindow 首次开启窗口时，创建 Electron 的 IPC，使主进程和渲染进程间通信。 window会被注册到sharedProcessClient，主进程和共享进程通信 根据 environmentService 提供的参数(path,uri)调用windowsMainService.open 方法打开窗口</p>
<pre><code>private openFirstWindow(accessor: ServicesAccessor, electronIpcServer: ElectronIPCServer, sharedProcessClient: Promise&lt;Client&lt;string&gt;&gt;): ICodeWindow[] {
        ...
        // 1. 注入Electron IPC Service, windows窗口管理，菜单栏等服务
        // 2. 根据environmentService进行参数配置
        const macOpenFiles: string[] = (&lt;any&gt;global).macOpenFiles;
        const context = !!process.env['VSCODE_CLI'] ? OpenContext.CLI : OpenContext.DESKTOP;
        const hasCliArgs = hasArgs(args._);
        const hasFolderURIs = hasArgs(args['folder-uri']);
        const hasFileURIs = hasArgs(args['file-uri']);
        const noRecentEntry = args['skip-add-to-recently-opened'] === true;
        const waitMarkerFileURI = args.wait &amp;&amp; args.waitMarkerFilePath ? URI.file(args.waitMarkerFilePath) : undefined;
        ...
        // 打开主窗口，默认从执行命令行中读取参数 
        return windowsMainService.open({
            context,
            cli: args,
            forceNewWindow: args['new-window'] || (!hasCliArgs &amp;&amp; args['unity-launch']),
            diffMode: args.diff,
            noRecentEntry,
            waitMarkerFileURI,
            gotoLineMode: args.goto,
            initialStartup: true
        });
    }</code></pre><h4 id="vs-code-electron-main-windows-ts"><a href="#vs-code-electron-main-windows-ts" class="headerlink" title="vs/code/electron-main/windows.ts"></a>vs/code/electron-main/windows.ts</h4><p>接下来到了electron的windows窗口，open方法在doOpen中执行窗口配置初始化，最终调用openInBrowserWindow -&gt; 执行doOpenInBrowserWindow是其打开window,主要步骤如下：</p>
<pre><code>private openInBrowserWindow(options: IOpenBrowserWindowOptions): ICodeWindow {
    ...
    // New window
    if (!window) {
        //1.判断是否全屏创建窗口
         ...
        // 2. 创建实例窗口
        window = this.instantiationService.createInstance(CodeWindow, {
            state,
            extensionDevelopmentPath: configuration.extensionDevelopmentPath,
            isExtensionTestHost: !!configuration.extensionTestsPath
        });
        // 3.添加到当前窗口控制器
        WindowsManager.WINDOWS.push(window);
        // 4.窗口监听器
        window.win.webContents.removeAllListeners('devtools-reload-page'); // remove built in listener so we can handle this on our own
        window.win.webContents.on('devtools-reload-page', () =&gt; this.reload(window!));
        window.win.webContents.on('crashed', () =&gt; this.onWindowError(window!, WindowError.CRASHED));
        window.win.on('unresponsive', () =&gt; this.onWindowError(window!, WindowError.UNRESPONSIVE));
        window.win.on('closed', () =&gt; this.onWindowClosed(window!));
        // 5.注册窗口生命周期
        (this.lifecycleService as LifecycleService).registerWindow(window);
    }
    ...
    return window;
}</code></pre><p>doOpenInBrowserWindow会调用window.load方法 在window.ts中实现</p>
<pre><code>load(config: IWindowConfiguration, isReload?: boolean, disableExtensions?: boolean): void {
    ...
    // Load URL
    perf.mark('main:loadWindow');
    this._win.loadURL(this.getUrl(configuration));
    ...
}
private getUrl(windowConfiguration: IWindowConfiguration): string {
    ...
    //加载欢迎屏幕的html
    let configUrl = this.doGetUrl(config);
    ...
    return configUrl;
}
//默认加载 vs/code/electron-browser/workbench/workbench.html
private doGetUrl(config: object): string {
    return `${require.toUrl('vs/code/electron-browser/workbench/workbench.html')}?config=${encodeURIComponent(JSON.stringify(config))}`;
}</code></pre><p>main process的使命完成, 主界面进行构建布局。</p>
<p>在workbench.html中加载了workbench.js， 这里调用return require(‘vs/workbench/electron-browser/desktop.main’).main(configuration);实现对主界面的展示</p>
<h4 id="vs-workbench-electron-browser-desktop-main-ts"><a href="#vs-workbench-electron-browser-desktop-main-ts" class="headerlink" title="vs/workbench/electron-browser/desktop.main.ts"></a>vs/workbench/electron-browser/desktop.main.ts</h4><p>创建工作区，调用workbench.startup()方法，构建主界面展示布局</p>
<pre><code>...
async open(): Promise&lt;void&gt; {
    const services = await this.initServices();
    await domContentLoaded();
    mark('willStartWorkbench');
    // 1.创建工作区
    const workbench = new Workbench(document.body, services.serviceCollection, services.logService);
    // 2.监听窗口变化
    this._register(addDisposableListener(window, EventType.RESIZE, e =&gt; this.onWindowResize(e, true, workbench)));
    // 3.工作台生命周期
    this._register(workbench.onShutdown(() =&gt; this.dispose()));
    this._register(workbench.onWillShutdown(event =&gt; event.join(services.storageService.close())));
    // 3.启动工作区
    const instantiationService = workbench.startup();
    ...
}
...</code></pre><h4 id="vs-workbench-browser-workbench-ts"><a href="#vs-workbench-browser-workbench-ts" class="headerlink" title="vs/workbench/browser/workbench.ts"></a>vs/workbench/browser/workbench.ts</h4><p>工作区继承自layout类，主要作用是构建工作区，创建界面布局。</p>
<pre><code>export class Workbench extends Layout {
    ...
    startup(): IInstantiationService {
        try {
            ...
            // Services
            const instantiationService = this.initServices(this.serviceCollection);
            instantiationService.invokeFunction(async accessor =&gt; {
                const lifecycleService = accessor.get(ILifecycleService);
                const storageService = accessor.get(IStorageService);
                const configurationService = accessor.get(IConfigurationService);
                // Layout
                this.initLayout(accessor);
                // Registries
                this.startRegistries(accessor);
                // Context Keys
                this._register(instantiationService.createInstance(WorkbenchContextKeysHandler));
                // 注册监听事件
                this.registerListeners(lifecycleService, storageService, configurationService);
                // 渲染工作区
                this.renderWorkbench(instantiationService, accessor.get(INotificationService) as NotificationService, storageService, configurationService);
                // 创建工作区布局
                this.createWorkbenchLayout(instantiationService);
                // 布局构建
                this.layout();
                // Restore
                try {
                    await this.restoreWorkbench(accessor.get(IEditorService), accessor.get(IEditorGroupsService), accessor.get(IViewletService), accessor.get(IPanelService), accessor.get(ILogService), lifecycleService);
                } catch (error) {
                    onUnexpectedError(error);
                }
            });
            return instantiationService;
        } catch (error) {
            onUnexpectedError(error);
            throw error; // rethrow because this is a critical issue we cannot handle properly here
        }
    }
    ...
}</code></pre><h2 id="实例化服务"><a href="#实例化服务" class="headerlink" title="实例化服务"></a>实例化服务</h2><p>SyncDescriptor负责注册这些服务，当用到该服务时进程实例化使用</p>
<p>src/vs/platform/instantiation/common/descriptors.ts</p>
<pre><code>export class SyncDescriptor&lt;T&gt; {
    readonly ctor: any;
    readonly staticArguments: any[];
    readonly supportsDelayedInstantiation: boolean;
    constructor(ctor: new (...args: any[]) =&gt; T, staticArguments: any[] = [], supportsDelayedInstantiation: boolean = false) {
        this.ctor = ctor;
        this.staticArguments = staticArguments;
        this.supportsDelayedInstantiation = supportsDelayedInstantiation;
    }
}</code></pre><p>main.ts中startup方法调用invokeFunction.get实例化服务</p>
<pre><code>await instantiationService.invokeFunction(async accessor =&gt; {
    const environmentService = accessor.get(IEnvironmentService);
    const configurationService = accessor.get(IConfigurationService);
    const stateService = accessor.get(IStateService);
    try {
        await this.initServices(environmentService, configurationService as ConfigurationService, stateService as StateService);
    } catch (error) {
        // Show a dialog for errors that can be resolved by the user
        this.handleStartupDataDirError(environmentService, error);
        throw error;
    }
});</code></pre><p>get方法调用_getOrCreateServiceInstance，这里第一次创建会存入缓存中 下次实例化对象时会优先从缓存中获取对象。</p>
<p>src/vs/platform/instantiation/common/instantiationService.ts</p>
<pre><code>invokeFunction&lt;R, TS extends any[] = []&gt;(fn: (accessor: ServicesAccessor, ...args: TS) =&gt; R, ...args: TS): R {
    let _trace = Trace.traceInvocation(fn);
    let _done = false;
    try {
        const accessor: ServicesAccessor = {
            get: &lt;T&gt;(id: ServiceIdentifier&lt;T&gt;, isOptional?: typeof optional) =&gt; {
                if (_done) {
                    throw illegalState('service accessor is only valid during the invocation of its target method');
                }
                const result = this._getOrCreateServiceInstance(id, _trace);
                if (!result &amp;&amp; isOptional !== optional) {
                    throw new Error(`[invokeFunction] unknown service '${id}'`);
                }
                return result;
            }
        };
        return fn.apply(undefined, [accessor, ...args]);
    } finally {
        _done = true;
        _trace.stop();
    }
}
private _getOrCreateServiceInstance&lt;T&gt;(id: ServiceIdentifier&lt;T&gt;, _trace: Trace): T {
    let thing = this._getServiceInstanceOrDescriptor(id);
    if (thing instanceof SyncDescriptor) {
        return this._createAndCacheServiceInstance(id, thing, _trace.branch(id, true));
    } else {
        _trace.branch(id, false);
        return thing;
    }
}</code></pre><h2 id="事件分发"><a href="#事件分发" class="headerlink" title="事件分发"></a>事件分发</h2><h3 id="event"><a href="#event" class="headerlink" title="event"></a>event</h3><p>src/vs/base/common/event.ts</p>
<p>程序中常见使用once方法进行事件绑定, 给定一个事件，返回一个只触发一次的事件，放在匿名函数返回</p>
<pre><code>export function once&lt;T&gt;(event: Event&lt;T&gt;): Event&lt;T&gt; {
    return (listener, thisArgs = null, disposables?) =&gt; {
        // 设置次变量，防止事件重复触发造成事件污染
        let didFire = false;
        let result: IDisposable;
        result = event(e =&gt; {
            if (didFire) {
                return;
            } else if (result) {
                result.dispose();
            } else {
                didFire = true;
            }
            return listener.call(thisArgs, e);
        }, null, disposables);
        if (didFire) {
            result.dispose();
        }
        return result;
    };
}</code></pre><p>循环派发了所有注册的事件， 事件会存储到一个事件队列，通过fire方法触发事件</p>
<p>private _deliveryQueue?: LinkedList&lt;[Listener, T]&gt;;//事件存储队列</p>
<pre><code>fire(event: T): void {
    if (this._listeners) {
        // 将所有事件传入 delivery queue
        // 内部/嵌套方式通过emit发出.
        // this调用事件驱动
        if (!this._deliveryQueue) {
            this._deliveryQueue = new LinkedList();
        }
        for (let iter = this._listeners.iterator(), e = iter.next(); !e.done; e = iter.next()) {
            this._deliveryQueue.push([e.value, event]);
        }
        while (this._deliveryQueue.size &gt; 0) {
            const [listener, event] = this._deliveryQueue.shift()!;
            try {
                if (typeof listener === 'function') {
                    listener.call(undefined, event);
                } else {
                    listener[0].call(listener[1], event);
                }
            } catch (e) {
                onUnexpectedError(e);
            }
        }
    }
}</code></pre><h2 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h2><h3 id="主进程"><a href="#主进程" class="headerlink" title="主进程"></a>主进程</h3><p>src/vs/code/electron-main/main.ts</p>
<p>main.ts在启动应用后就创建了一个主进程 main process，它可以通过electron中的一些模块直接与原生GUI交互。</p>
<pre><code>server = await serve(environmentService.mainIPCHandle);
once(lifecycleService.onWillShutdown)(() =&gt; server.dispose());</code></pre><h3 id="渲染进程"><a href="#渲染进程" class="headerlink" title="渲染进程"></a>渲染进程</h3><p>仅启动主进程并不能给你的应用创建应用窗口。窗口是通过main文件里的主进程调用叫BrowserWindow的模块创建的。</p>
<h3 id="主进程与渲染进程之间的通信"><a href="#主进程与渲染进程之间的通信" class="headerlink" title="主进程与渲染进程之间的通信"></a>主进程与渲染进程之间的通信</h3><p>在electron中，主进程与渲染进程有很多通信的方法。比如ipcRenderer和ipcMain，还可以在渲染进程使用remote模块。</p>
<h3 id="ipcMain-amp-ipcRenderer"><a href="#ipcMain-amp-ipcRenderer" class="headerlink" title="ipcMain &amp; ipcRenderer"></a>ipcMain &amp; ipcRenderer</h3><ul>
<li>主进程：ipcMain</li>
<li>渲染进程：ipcRenderer</li>
</ul>
<p>ipcMain模块和ipcRenderer是类EventEmitter的实例。</p>
<p>在主进程中使用ipcMain接收渲染线程发送过来的异步或同步消息，发送过来的消息将触发事件。</p>
<p>在渲染进程中使用ipcRenderer向主进程发送同步或异步消息，也可以接收到主进程的消息。</p>
<ul>
<li>发送消息，事件名为 channel .</li>
<li>回应同步消息, 你可以设置 event.returnValue .</li>
<li>回应异步消息, 你可以使用 event.sender.send(…)</li>
</ul>
<p>创建IPC服务 src/vs/base/parts/ipc/node/ipc.net.ts</p>
<p>这里返回一个promise对象，成功则createServer</p>
<pre><code>export function serve(hook: any): Promise&lt;Server&gt; {
    return new Promise&lt;Server&gt;((c, e) =&gt; {
        const server = createServer();
        server.on('error', e);
        server.listen(hook, () =&gt; {
            server.removeListener('error', e);
            c(new Server(server));
        });
    });
}</code></pre><h4 id="创建信道"><a href="#创建信道" class="headerlink" title="创建信道"></a>创建信道</h4><p>src/vs/code/electron-main/app.ts</p>
<ul>
<li>mainIpcServer<ul>
<li>launchChannel</li>
</ul>
</li>
<li>electronIpcServer<ul>
<li>updateChannel</li>
<li>issueChannel</li>
<li>workspacesChannel</li>
<li>windowsChannel</li>
<li>menubarChannel</li>
<li>urlChannel</li>
<li>storageChannel</li>
<li>logLevelChannel</li>
</ul>
</li>
</ul>
<pre><code>private openFirstWindow(accessor: ServicesAccessor, electronIpcServer: ElectronIPCServer, sharedProcessClient: Promise&lt;Client&lt;string&gt;&gt;): ICodeWindow[] {
        // Register more Main IPC services
        const launchService = accessor.get(ILaunchService);
        const launchChannel = new LaunchChannel(launchService);
        this.mainIpcServer.registerChannel('launch', launchChannel);
        // Register more Electron IPC services
        const updateService = accessor.get(IUpdateService);
        const updateChannel = new UpdateChannel(updateService);
        electronIpcServer.registerChannel('update', updateChannel);
        const issueService = accessor.get(IIssueService);
        const issueChannel = new IssueChannel(issueService);
        electronIpcServer.registerChannel('issue', issueChannel);
        const workspacesService = accessor.get(IWorkspacesMainService);
        const workspacesChannel = new WorkspacesChannel(workspacesService);
        electronIpcServer.registerChannel('workspaces', workspacesChannel);
        const windowsService = accessor.get(IWindowsService);
        const windowsChannel = new WindowsChannel(windowsService);
        electronIpcServer.registerChannel('windows', windowsChannel);
        sharedProcessClient.then(client =&gt; client.registerChannel('windows', windowsChannel));
        const menubarService = accessor.get(IMenubarService);
        const menubarChannel = new MenubarChannel(menubarService);
        electronIpcServer.registerChannel('menubar', menubarChannel);
        const urlService = accessor.get(IURLService);
        const urlChannel = new URLServiceChannel(urlService);
        electronIpcServer.registerChannel('url', urlChannel);
        const storageMainService = accessor.get(IStorageMainService);
        const storageChannel = this._register(new GlobalStorageDatabaseChannel(this.logService, storageMainService));
        electronIpcServer.registerChannel('storage', storageChannel);
        // Log level management
        const logLevelChannel = new LogLevelSetterChannel(accessor.get(ILogService));
        electronIpcServer.registerChannel('loglevel', logLevelChannel);
        sharedProcessClient.then(client =&gt; client.registerChannel('loglevel', logLevelChannel));
        ...
        // default: read paths from cli
        return windowsMainService.open({
            context,
            cli: args,
            forceNewWindow: args['new-window'] || (!hasCliArgs &amp;&amp; args['unity-launch']),
            diffMode: args.diff,
            noRecentEntry,
            waitMarkerFileURI,
            gotoLineMode: args.goto,
            initialStartup: true
        });
    }</code></pre><p>每一个信道，内部实现两个方法 listen和call</p>
<p>例如：src/vs/platform/localizations/node/localizationsIpc.ts</p>
<p>构造函数绑定事件</p>
<pre><code>export class LocalizationsChannel implements IServerChannel {
    onDidLanguagesChange: Event&lt;void&gt;;
    constructor(private service: ILocalizationsService) {
        this.onDidLanguagesChange = Event.buffer(service.onDidLanguagesChange, true);
    }
    listen(_: unknown, event: string): Event&lt;any&gt; {
        switch (event) {
            case 'onDidLanguagesChange': return this.onDidLanguagesChange;
        }
        throw new Error(`Event not found: ${event}`);
    }
    call(_: unknown, command: string, arg?: any): Promise&lt;any&gt; {
        switch (command) {
            case 'getLanguageIds': return this.service.getLanguageIds(arg);
        }
        throw new Error(`Call not found: ${command}`);
    }
}</code></pre><h2 id="主要窗口"><a href="#主要窗口" class="headerlink" title="主要窗口"></a>主要窗口</h2><p>workbench.ts中startup里面Workbench负责创建主界面 src/vs/workbench/browser/workbench.ts</p>
<pre><code>startup(): IInstantiationService {
    try {
        ...
        instantiationService.invokeFunction(async accessor =&gt; {
            // 渲染主工作界面
            this.renderWorkbench(instantiationService, accessor.get(INotificationService) as NotificationService, storageService, configurationService);
            // 界面布局
            this.createWorkbenchLayout(instantiationService);
            // Layout
            this.layout();
            // Restore
            try {
                await this.restoreWorkbench(accessor.get(IEditorService), accessor.get(IEditorGroupsService), accessor.get(IViewletService), accessor.get(IPanelService), accessor.get(ILogService), lifecycleService);
            } catch (error) {
                onUnexpectedError(error);
            }
        });
        return instantiationService;
    } catch (error) {
        onUnexpectedError(error);
        throw error; // rethrow because this is a critical issue we cannot handle properly here
    }
}</code></pre><p>渲染主工作台，渲染完之后加入到container中，container加入到parent, parent就是body了。</p>
<p>this.parent.appendChild(this.container);</p>
<pre><code>private renderWorkbench(instantiationService: IInstantiationService, notificationService: NotificationService, storageService: IStorageService, configurationService: IConfigurationService): void {
        ...
        //TITLEBAR_PART 顶部操作栏
        //ACTIVITYBAR_PART 最左侧菜单选项卡
        //SIDEBAR_PART 左侧边栏，显示文件，结果展示等
        //EDITOR_PART 右侧窗口，代码编写,欢迎界面等
        //STATUSBAR_PART 底部状态栏
        [
            { id: Parts.TITLEBAR_PART, role: 'contentinfo', classes: ['titlebar'] },
            { id: Parts.ACTIVITYBAR_PART, role: 'navigation', classes: ['activitybar', this.state.sideBar.position === Position.LEFT ? 'left' : 'right'] },
            { id: Parts.SIDEBAR_PART, role: 'complementary', classes: ['sidebar', this.state.sideBar.position === Position.LEFT ? 'left' : 'right'] },
            { id: Parts.EDITOR_PART, role: 'main', classes: ['editor'], options: { restorePreviousState: this.state.editor.restoreEditors } },
            { id: Parts.PANEL_PART, role: 'complementary', classes: ['panel', this.state.panel.position === Position.BOTTOM ? 'bottom' : 'right'] },
            { id: Parts.STATUSBAR_PART, role: 'contentinfo', classes: ['statusbar'] }
        ].forEach(({ id, role, classes, options }) =&gt; {
            const partContainer = this.createPart(id, role, classes);
            if (!configurationService.getValue('workbench.useExperimentalGridLayout')) {
                // TODO@Ben cleanup once moved to grid
                // Insert all workbench parts at the beginning. Issue #52531
                // This is primarily for the title bar to allow overriding -webkit-app-region
                this.container.insertBefore(partContainer, this.container.lastChild);
            }
            this.getPart(id).create(partContainer, options);
        });
        // 将工作台添加至container dom渲染
        this.parent.appendChild(this.container);
    }</code></pre><p>workbench最后调用this.layout()方法，将窗口占据整个界面，渲染完成</p>
<pre><code>layout(options?: ILayoutOptions): void {
        if (!this.disposed) {
            this._dimension = getClientArea(this.parent);
            if (this.workbenchGrid instanceof Grid) {
                position(this.container, 0, 0, 0, 0, 'relative');
                size(this.container, this._dimension.width, this._dimension.height);
                // Layout the grid widget
                this.workbenchGrid.layout(this._dimension.width, this._dimension.height);
            } else {
                this.workbenchGrid.layout(options);
            }
            // Emit as event
            this._onLayout.fire(this._dimension);
        }
    }</code></pre><h2 id="开发调试"><a href="#开发调试" class="headerlink" title="开发调试"></a>开发调试</h2><pre><code>app.once('ready', function () {
    //启动追踪
    if (args['trace']) {
        // @ts-ignore
        const contentTracing = require('electron').contentTracing;
        const traceOptions = {
            categoryFilter: args['trace-category-filter'] || '*',
            traceOptions: args['trace-options'] || 'record-until-full,enable-sampling'
        };
        contentTracing.startRecording(traceOptions, () =&gt; onReady());
    } else {
        onReady();
    }
});</code></pre><h3 id="启动追踪"><a href="#启动追踪" class="headerlink" title="启动追踪"></a>启动追踪</h3><p>这里如果传入trace参数，在onReady启动之前会调用chromium的收集跟踪数据， 提供的底层的追踪工具允许我们深度了解 V8 的解析以及其他时间消耗情况，</p>
<p>一旦收到可以开始记录的请求，记录将会立马启动并且在子进程是异步记录听的. 当所有的子进程都收到 startRecording 请求的时候，callback 将会被调用.</p>
<p>categoryFilter是一个过滤器，它用来控制那些分类组应该被用来查找.过滤器应当有一个可选的 - 前缀来排除匹配的分类组.不允许同一个列表既是包含又是排斥.</p>
<h4 id="contentTracing-startRecording-options-callback"><a href="#contentTracing-startRecording-options-callback" class="headerlink" title="contentTracing.startRecording(options, callback)"></a>contentTracing.startRecording(options, callback)</h4><ul>
<li>options Object<ul>
<li>categoryFilter String</li>
<li>traceOptions String</li>
</ul>
</li>
<li>callback Function</li>
</ul>
<p><a href="https://www.w3cschool.cn/electronmanual/electronmanual-content-tracing.html" target="_blank" rel="noopener">关于trace的详细介绍</a></p>
<h3 id="结束追踪"><a href="#结束追踪" class="headerlink" title="结束追踪"></a>结束追踪</h3><h4 id="contentTracing-stopRecording-resultFilePath-callback"><a href="#contentTracing-stopRecording-resultFilePath-callback" class="headerlink" title="contentTracing.stopRecording(resultFilePath, callback)"></a>contentTracing.stopRecording(resultFilePath, callback)</h4><ul>
<li>resultFilePath String</li>
<li>callback Function 在成功启动窗口后，程序结束性能追踪，停止对所有子进程的记录.</li>
</ul>
<p>子进程通常缓存查找数据，并且仅仅将数据截取和发送给主进程.这有利于在通过 IPC 发送查找数据之前减小查找时的运行开销，这样做很有价值.因此，发送查找数据，我们应当异步通知所有子进程来截取任何待查找的数据.</p>
<p>一旦所有子进程接收到了 stopRecording 请求，将调用 callback ，并且返回一个包含查找数据的文件.</p>
<p>如果 resultFilePath 不为空，那么将把查找数据写入其中，否则写入一个临时文件.实际文件路径如果不为空，则将调用 callback .</p>
<h3 id="debug"><a href="#debug" class="headerlink" title="debug"></a>debug</h3><p>调试界面在菜单栏找到 Help-&gt;Toggle Developers Tools</p>
<p>调出Chrome开发者调试工具进行调试 <img src="/images/loading.gif" data-original="../images/development/vscode-debugg.png" alt=""></p>
<h1 id="🤡VS-Code-插件开发文档"><a href="#🤡VS-Code-插件开发文档" class="headerlink" title="🤡VS Code 插件开发文档"></a>🤡VS Code 插件开发文档</h1><h1 id="术语表"><a href="#术语表" class="headerlink" title="术语表"></a>术语表</h1><hr>
<p>术语表收录出现在VS Code中独有的或是易引起歧义的词汇，不包含常见词汇，如Extension。该表按首字母排序。 该表格式：</p>
<ul>
<li><p>普通词汇 <code>英文名称 术语名称</code></p>
</li>
<li><p>单义词 <code>[出处或参考解释链接]() 术语名称：解释</code></p>
</li>
<li><p>多义词 <code>[出处或参考解释链接]() 术语名称1/术语名称2：解释</code></p>
</li>
<li><p><a href="https://code.visualstudio.com/docs/extensionAPI/overview" target="_blank" rel="noopener">Activation Events</a> 激活事件：用于激活插件的VS Code事件钩子。</p>
</li>
<li><p><a href="https://code.visualstudio.com/docs/extensionAPI/overview" target="_blank" rel="noopener">Contribution Points</a> 发布内容配置点：package.json的一部分，用于配置插件启动命令、用户可更改的插件配置，可以理解为插件的主要配置文件。</p>
</li>
<li><p><a href="https://code.visualstudio.com/docs/extensions/overview#_language-servers" target="_blank" rel="noopener">Debug Adapter</a> 调试适配器：连接真正的调试程序（或运行时）和调试界面的插件称之为调试适配器。VS Code没有原生调试程序，而是依赖【调试器插件】调用通信协议（调试适配器协议）和VS Code的调试器界面实现。</p>
</li>
<li><p><a href="https://code.visualstudio.com/docs/extensionAPI/overview" target="_blank" rel="noopener">Extension Manifest</a> 插件清单：VS Code自定义的pacakge.json文件，其中包含着插件的入口、配置等重要信息。</p>
</li>
<li><p>Extensibility 扩展性</p>
</li>
<li><p><a href="https://code.visualstudio.com/docs/extensionAPI/patterns-and-principles" target="_blank" rel="noopener">Extension Host</a> 扩展主机：与VS Code主进程隔离的插件进程，插件运行的地方，开发者可在这个进程中调用VS Code提供的各类API。</p>
</li>
<li><p><a href="https://code.visualstudio.com/docs/extensions/overview#_language-servers" target="_blank" rel="noopener">Language Servers</a> 语言服务器：插件模式中使用C/S结构的的服务器端，用于高消耗的特殊插件场景，如语言解析、智能提示等。与之相对，客户端则是普通的插件，两者通过VS Code 的API进行通信。</p>
</li>
<li><p><a href="https://code.visualstudio.com/docs/languages/identifiers" target="_blank" rel="noopener">Language Identifier</a> 语言标识符：定义在发布内容配置的特定标识/名称，便于后续引用该语言配置。通常为某种编程语言的通俗名称，如JavaScript的语言标识符是【javascript】，Python的语言标识符是【python】。</p>
</li>
</ul>
<h1 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h1><h2 id="认识TypeScript-变量和类型"><a href="#认识TypeScript-变量和类型" class="headerlink" title="认识TypeScript-变量和类型"></a>认识TypeScript-变量和类型</h2><p>本节将介绍基础的TypeScript变量以及它的类型系统，它本质上和JavaScript是一样的，不过东西会更多一点，对于非js开发者来说，你可能会遇到熟悉的“枚举”、“元组”类型，了解了这点，或许能让你安心并更快地掌握TS，但是这并不意味着你就可以高枕无忧了，虽然TS扩展了JS的类型能力，但它本质上依旧是一门弱类型语言，请在书写代码时遵循社区的最佳实践并保持谨慎。</p>
<p>?&gt; 本文参考社区翻译文档，详见<a href="https://www.tslang.cn/docs/handbook/basic-types.html" target="_blank" rel="noopener">https://www.tslang.cn/docs/handbook/basic-types.html</a></p>
<h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><hr>
<p>变量声明的基础规则请自行参考JavaScript，JavaScript支持加分号和不加分号两种风格，方便起见，本章的所有示例代码都不会刻意添加分号，有关分号风格，请参阅。</p>
<h4 id="类型注解"><a href="#类型注解" class="headerlink" title="类型注解"></a>类型注解</h4><p>TS扩展了JS的语法格式，规则：在变量、声明的后面立即加上冒号<code>:</code>，如：</p>
<pre><code>// 字符串注解
const XXX: string = 'string type'
// 布尔值注解
let true_or_false: boolean = false
// 函数参数类型注解
function params (value: string) {
    console.log(value) // 返回string类型
}
// 函数返回值类型注解
function returnValue (): string {
    return 'value is stirng'
}</code></pre><p>请注意，类型注释应使用小写，而不是使用首字母大写的JavaScript的衍生类型（应使用<code>string</code>，而不是<code>String</code>）</p>
<h4 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h4><p>最基本的数据类型就是简单的true/false值，在JavaScript和TypeScript里叫做boolean（其它语言中也一样）。</p>
<pre><code>let isDone: boolean = false;</code></pre><h4 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h4><p>和JavaScript一样，TypeScript里的所有数字都是浮点数。 这些浮点数的类型是 number。 除了支持十进制和十六进制字面量，TypeScript还支持ECMAScript 2015中引入的二进制和八进制字面量。非JS开发者需要注意的是，TS和JS一样，没有区分数字类型（如Int，Long），如果你需要整数，需使用<code>Number.parseInt()</code>方法。</p>
<pre><code>let decLiteral: number = 6;
let hexLiteral: number = 0xf00d;
let binaryLiteral: number = 0b1010;
let octalLiteral: number = 0o744;</code></pre><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>JavaScript程序的另一项基本操作是处理网页或服务器端的文本数据。 像其它语言里一样，我们使用 string表示文本数据类型。 和JavaScript一样，可以使用双引号（ “）或单引号（’）表示字符串。</p>
<pre><code>let name: string = "bob";
name = "smith";</code></pre><p>你还可以使用模版字符串，它可以定义多行文本和内嵌表达式。 这种字符串是被反引号包围（ <code>），并且以</code>${ expr }`这种形式嵌入表达式</p>
<pre><code>let name: string = `Gene`;
let age: number = 37;
let sentence: string = `Hello, my name is ${ name }.
I'll be ${ age + 1 } years old next month.`;</code></pre><p>这与下面定义<code>sentence</code>的方式效果相同：</p>
<pre><code>let sentence: string = "Hello, my name is " + name + ".\n\n" +
    "I'll be " + (age + 1) + " years old next month.";</code></pre><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>TypeScript像JavaScript一样可以操作数组元素。 有两种方式可以定义数组。 第一种，可以在元素类型后面接上 []，表示由此类型元素组成的一个数组：</p>
<pre><code>let list: number[] = [1, 2, 3];</code></pre><p>第二种方式是使用数组泛型，Array&lt;元素类型&gt;：</p>
<pre><code>let list: Array&lt;number&gt; = [1, 2, 3];</code></pre><h4 id="元组-Tuple"><a href="#元组-Tuple" class="headerlink" title="元组 Tuple"></a>元组 Tuple</h4><p>元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。 比如，你可以定义一对值分别为 string和number类型的元组。</p>
<pre><code>// 声明一个元组
let x: [string, number];
// 将其初始化
x = ['hello', 10]; // OK
// 将其错误地初始化
x = [10, 'hello']; // Error
当访问一个已知索引的元素，会得到正确的类型：
console.log(x[0].substr(1)); // OK
console.log(x[1].substr(1)); // Error, 'number'类型没有'substr'方法</code></pre><h4 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h4><p>enum类型是对JavaScript标准数据类型的一个补充。 像C#等其它语言一样，使用枚举类型可以为一组数值赋予友好的名字。</p>
<pre><code>enum Color {Red, Green, Blue}
let c: Color = Color.Green;</code></pre><p>默认情况下，从0开始为元素编号。 你也可以手动的指定成员的数值。 例如，我们将上面的例子改成从 1开始编号：</p>
<pre><code>enum Color {Red = 1, Green, Blue}
let c: Color = Color.Green;</code></pre><p>或者，全部都采用手动赋值：</p>
<pre><code>enum Color {Red = 1, Green = 2, Blue = 4}
let c: Color = Color.Green;</code></pre><p>枚举类型提供的一个便利是你可以由枚举的值得到它的名字。 例如，我们知道数值为2，但是不确定它映射到Color里的哪个名字，我们可以查找相应的名字：</p>
<pre><code>enum Color {Red = 1, Green, Blue}
let colorName: string = Color[2];
console.log(colorName);  // 显示'Green'因为上面代码里它的值是2</code></pre><h4 id="Any"><a href="#Any" class="headerlink" title="Any"></a>Any</h4><p>有时候，我们会想要为那些在编写阶段还不清楚类型的变量指定一个类型。 这些值可能来自于动态的内容，比如来自用户输入或第三方代码库。 这种情况下，我们不希望类型检查器对这些值进行检查而是直接让它们通过编译阶段的检查。 那么我们可以使用 any类型来标记这些变量：</p>
<pre><code>let notSure: any = 4;
notSure = "maybe a string instead";
notSure = false; // 合法, 定义了一个布尔值</code></pre><p>当你只知道一部分数据的类型时，any类型也是有用的。 比如，你有一个数组，它包含了不同的类型的数据：</p>
<pre><code>let list: any[] = [1, true, "free"];
list[1] = 100;</code></pre><h4 id="Void"><a href="#Void" class="headerlink" title="Void"></a>Void</h4><p>某种程度上来说，void类型像是与any类型相反，它表示没有任何类型。 当一个函数没有返回值时，你通常会见到其返回值类型是 void：</p>
<pre><code>function warnUser(): void {
    console.log("This is my warning message");
}</code></pre><p>声明一个void类型的变量没有什么大用，因为你只能为它赋予undefined和null：</p>
<pre><code>let unusable: void = undefined;</code></pre><h4 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h4><p>object表示非原始类型，也就是除number，string，boolean，symbol，null或undefined之外的类型。</p>
<p>使用object类型，就可以更好的表示像<code>Object.create</code>这样的API。例如：</p>
<pre><code>declare function create(o: object | null): void;
create({ prop: 0 }); // OK
create(null); // OK
create(42); // Error
create("string"); // Error
create(false); // Error
create(undefined); // Error</code></pre><h3 id="TypeScript类型表"><a href="#TypeScript类型表" class="headerlink" title="TypeScript类型表"></a>TypeScript类型表</h3><hr>
<table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">例子</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>基本类型</strong></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">boolean</td>
<td align="left"><code>x: boolean = false</code></td>
</tr>
<tr>
<td align="left">number</td>
<td align="left"><code>x: number = 10</code></td>
</tr>
<tr>
<td align="left">string</td>
<td align="left"><code>x: string = '10'</code></td>
</tr>
<tr>
<td align="left">undefined</td>
<td align="left"><code>x: undefined = undefined</code></td>
</tr>
<tr>
<td align="left">null</td>
<td align="left"><code>x: null = null</code></td>
</tr>
<tr>
<td align="left"><strong>引用类型以及其他类型</strong></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">object</td>
<td align="left"><code>x: object = { age: '14', name: 'John' }</code></td>
</tr>
<tr>
<td align="left">array</td>
<td align="left"><code>x: array = [1, '2', 3.0]</code></td>
</tr>
<tr>
<td align="left">function</td>
<td align="left"><code>x: function = (args) =&gt; { console.log(args) }</code></td>
</tr>
<tr>
<td align="left">symbol</td>
<td align="left"><code>x: symbol = Symbol('id')</code></td>
</tr>
<tr>
<td align="left"><strong>TypeScript 补充类型</strong></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">any</td>
<td align="left"><code>x: any = null</code></td>
</tr>
<tr>
<td align="left">never</td>
<td align="left"><code>function error (msg): never =&gt; { throw new Error(msg) }</code></td>
</tr>
<tr>
<td align="left">enum</td>
<td align="left"><code>enum Color {Red = 1, Green, Blue}</code></td>
</tr>
<tr>
<td align="left">tuple</td>
<td align="left"><code>x: [string, number] = ['name', 12]</code></td>
</tr>
</tbody></table>
<h3 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h3><hr>
<p>有时候你会遇到这样的情况，你比TypeScript更了解某个值的具体信息。</p>
<p>通过<em>类型断言</em>这种方式可以告诉编译器，“相信我，我知道自己在干什么”。 类型断言好比其它语言里的类型转换，但是不进行特殊的数据检查和解构。它没有运行时的影响，只是在编译阶段起作用。TypeScript会假设你——程序员——已经进行了必须的检查。</p>
<p>类型断言有两种形式。 其一是“尖括号”语法：</p>
<pre><code>let someValue: any = "this is a string";
let strLength: number = (&lt;string&gt;someValue).length;</code></pre><p>另一个为as语法：</p>
<pre><code>let someValue: any = "this is a string";
let strLength: number = (someValue as string).length;</code></pre><p>!&gt; 注意：本章全部采用了let，const关键字，以及你接下来可以见到的所有例子中，都不再使用var声明变量，为了避免var带来的副作用和影响，我们更提倡使用新的关键字。</p>
<h3 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h3><hr>
<h4 id="let声明"><a href="#let声明" class="headerlink" title="let声明"></a>let声明</h4><p>let的声明格式</p>
<pre><code>let hello = "Hello!";</code></pre><h5 id="块作用域"><a href="#块作用域" class="headerlink" title="块作用域"></a>块作用域</h5><p>当用let声明一个变量，它使用的是词法作用域或块作用域。 不同于使用 var声明的变量那样可以在包含它们的函数外访问，块作用域变量在包含它们的块或for循环之外是不能访问的。</p>
<pre><code>function f(input: boolean) {
    let a = 100;
    if (input) {
        // 你在这里还可以访问到a
        let b = a + 1;
        return b;
    }
    // 错误: 'b'不存在
    return b;
}</code></pre><p>这里我们定义了2个变量<code>a</code>和<code>b</code>。 <code>a</code>的作用域在<code>f</code>函数体内，而<code>b</code>的作用域只在<code>if</code>语句块里。</p>
<p>拥有块级作用域的变量的另一个特点是，它们不能在被声明之前读或写。 虽然这些变量始终“存在”于它们的作用域里，但在直到声明它的代码之前的区域都属于 <em>暂时性死区</em>。 它只是用来说明我们不能在 let语句之前访问它们，幸运的是TypeScript可以告诉我们这些信息。</p>
<pre><code>a++; // illegal to use 'a' before it's declared;
let a;</code></pre><p>注意一点，我们仍然可以在一个拥有块作用域变量被声明前获取它。 只是我们不能在变量声明前去调用那个函数。 如果生成代码目标为ES2015，运行时会抛出一个错误；然而，目前TypeScript是不会报错的。</p>
<pre><code>function foo() {
    // okay to capture 'a'
    return a;
}
// 不能在'a'被声明前调用'foo'
// 运行时会抛出错误
foo();
let a;</code></pre><h4 id="重定义及屏蔽"><a href="#重定义及屏蔽" class="headerlink" title="重定义及屏蔽"></a>重定义及屏蔽</h4><p>你不可以重复定义同一个变量，在使用<code>var</code>时，这是被允许的。</p>
<pre><code>let x = 10;
let x = 20; // 错误，不能在1个作用域里多次声明`x`</code></pre><p>以下情况，TypeScript均会报错</p>
<pre><code>function f(x) {
    let x = 100; // error: interferes with parameter declaration
}
function g() {
    let x = 100;
    var x = 100; // error: can't have both declarations of 'x'
}</code></pre><p>注意函数作用域和块作用域不同，你可以在函数作用域里嵌套块作用域，作用域之间的变量声明互不影响，同时，块作用域是允许嵌套的。</p>
<p>在一个嵌套作用域里引入一个新名字的行为称做<strong>屏蔽</strong>。 它是一把双刃剑，它可能会不小心地引入新问题，还可能会遮蔽掉一些错误。</p>
<pre><code>function f(condition, x) {
    if (condition) {
        let x = 100;
        return x;
    }
    return x;
}
f(false, 0); // returns 0
f(true, 0);  // returns 100</code></pre><h4 id="const声明"><a href="#const声明" class="headerlink" title="const声明"></a>const声明</h4><p><code>const</code>声明是声明变量的另一种方式。它们与let声明相似，但是就像它的名字所表达的，它们被赋值后不能再改变。 换句话说，它们拥有与 let相同的作用域规则，但是不能对它们重新赋值。</p>
<p>这很好理解，它们引用的值是不可变的。</p>
<pre><code>const numLivesForCat = 9;
const kitty = {
    name: "Aurora",
    numLives: numLivesForCat,
}
// Error
kitty = {
    name: "Danielle",
    numLives: numLivesForCat
};
// all "okay"
kitty.name = "Rory";
kitty.name = "Kitty";
kitty.name = "Cat";
kitty.numLives--;</code></pre><p>除非你使用特殊的方法去避免，实际上const变量的内部状态是可修改的。</p>
<h3 id="访问-设置对象的属性和方法"><a href="#访问-设置对象的属性和方法" class="headerlink" title="访问/设置对象的属性和方法"></a>访问/设置对象的属性和方法</h3><hr>
<p>我们在前面已经看过很多对象的例子了，而且JavaScript的各种衍生类型都是基于Object构造出来的，所以本小节介绍的内容也同时适用数组、元组等数据类型。</p>
<h4 id="点表示法"><a href="#点表示法" class="headerlink" title="点表示法"></a>点表示法</h4><p>对象的名字表现为一个命名空间(namespace)，它必须写在第一位——当你想访问对象内部的属性或方法时，然后是一个点<code>.</code>，紧接着是你想要访问的项目，标识可以是简单属性的名字(name)，或者是数组属性的一个子元素，又或者是对象的方法调用。</p>
<pre><code>person.age
person.interests[1]
person.bio()</code></pre><p>创建一个对象在TypeScript中非常简单，在赋值语句右侧使用形如<code>{}</code>的方式就能创建对象</p>
<pre><code>const name = {
  first : 'Bob',
  last : 'Smith'
}</code></pre><p>用点表示法访问对象属性</p>
<pre><code>name.firstname.last</code></pre><h4 id="中括号表示法"><a href="#中括号表示法" class="headerlink" title="中括号表示法"></a>中括号表示法</h4><p>另外一种访问属性的方式是使用括号表示法(bracket notation)，替代这样的代码</p>
<pre><code>person.age
person.name.first

person['age']
person['name']['first']</code></pre><p>同样，创建一个数组也非常容易</p>
<pre><code>const name = ['Bob', 'Smith']</code></pre><p>用中括号表示法访问数组元素</p>
<pre><code>name[0]
name[1]
// 数组或类数组格式的数据只能用括号表示法访问元素，不可以使用`name.0`方式访问</code></pre><h4 id="设置对象成员"><a href="#设置对象成员" class="headerlink" title="设置对象成员"></a>设置对象成员</h4><p>分别用点表示法和中括号表示法设置对象成员的值</p>
<pre><code>person.age = 45
person['name']['last'] = 'Cratchit'</code></pre><p>设置成员并不意味着你只能更新已经存在的属性的值，你完全可以创建新的成员，尝试以下代码：</p>
<pre><code>person['eyes'] = 'hazel'
person.farewell = function() { alert("Bye everybody!") }</code></pre><p>现在你可以测试你新创建的成员</p>
<pre><code>person['eyes']
person.farewell()</code></pre><h3 id="变量解构"><a href="#变量解构" class="headerlink" title="变量解构"></a>变量解构</h3><hr>
<p>ES2015的变量解构本质来说是一种便利的语法糖</p>
<h4 id="解构数组"><a href="#解构数组" class="headerlink" title="解构数组"></a>解构数组</h4><p>最简单的解构莫过于数组的解构赋值了：</p>
<pre><code>let input = [1, 2];
let [first, second] = input;
console.log(first); // outputs 1
console.log(second); // outputs 2</code></pre><p>上面的例子等价于</p>
<pre><code>first = input[0];
second = input[1];</code></pre><p>作用于函数参数：</p>
<pre><code>function f([first, second]: [number, number]) { // 注意后面部分[number, number]是typescript的类型注解
    console.log(first);
    console.log(second);
}
const input = [12, 44]
f(input);</code></pre><p>你可以在数组里使用<code>...</code>语法创建剩余变量：</p>
<pre><code>let [first, ...rest] = [1, 2, 3, 4];
console.log(first); // outputs 1
console.log(rest); // outputs [ 2, 3, 4 ]</code></pre><p>当然，由于是JavaScript, 你可以忽略你不关心的尾随元素：</p>
<pre><code>let [first] = [1, 2, 3, 4];
console.log(first); // outputs 1</code></pre><p>或其它元素：</p>
<pre><code>let [, second, , fourth] = [1, 2, 3, 4];</code></pre><h4 id="对象解构"><a href="#对象解构" class="headerlink" title="对象解构"></a>对象解构</h4><p>你也可以解构对象：</p>
<pre><code>let o = {
    a: "foo",
    b: 12,
    c: "bar"
};
let { a, b } = o;</code></pre><p>你可以在对象里使用<code>...</code>语法创建剩余变量：</p>
<pre><code>let { a, ...passthrough } = o;
let total = passthrough.b + passthrough.c.length;</code></pre><p>你也可以给属性以不同的名字：</p>
<pre><code>let { a: newName1, b: newName2 } = o;</code></pre><p>这里的语法开始有些混乱。 你可以将 <code>a: newName1</code> 读做讲 “a” 取出作为 “newName1”。 方向是从左到右，好像你写成了以下样子：</p>
<pre><code>let newName1 = o.a;
let newName2 = o.b;</code></pre><p>令你困惑的可能是=这里的冒号不是指示类型的，我们前面说，以冒号后跟的是<em>类型注解</em>。 如果你想指定它的类型，仍然需要在其后写上完整的模式。</p>
<pre><code>// 正确
let {a, b}: {a: string, b: number} = o;
// 错误
let {a: n1, b: n2}: {n1: string, n2: number} = o;</code></pre><h4 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h4><p>默认值可以让你在属性为 undefined 时使用缺省值：</p>
<pre><code>function keepWholeObject(wholeObject: { a: string, b?: number }) {
    let { a, b = 1001 } = wholeObject;
}</code></pre><p>现在，即使 <code>b</code> 为 <code>undefined</code> ， keepWholeObject 函数的变量 <code>wholeObject</code> 的属性 a 和 b 都会有值。</p>
<h4 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h4><p>解构也能用于函数声明。 看以下简单的情况：</p>
<pre><code>
type C = { a: string, b?: number }
// 普通写法
function f(C) {
    // ...
}
// 解构
function f({ a, b }: C): void {
    // ...
}</code></pre><h4 id="变量展开"><a href="#变量展开" class="headerlink" title="变量展开"></a>变量展开</h4><p>展开操作符正与解构相反。 它允许你将一个数组展开为另一个数组，或将一个对象展开为另一个对象。 例如：</p>
<pre><code>let first = [1, 2];
let second = [3, 4];
let bothPlus = [0, ...first, ...second, 5];</code></pre><p>这会令bothPlus的值为<code>[0, 1, 2, 3, 4, 5]</code>。 展开操作创建了 first和second的一份<strong>浅拷贝</strong>。 它们不会被展开操作所改变。</p>
<p>你还可以展开对象：</p>
<pre><code>let defaults = { food: "spicy", price: "$$", ambiance: "noisy" };
let search = { ...defaults, food: "rich" };</code></pre><p>search的值为<code>{ food: "rich", price: "$$", ambiance: "noisy" }</code>。 对象的展开比数组的展开要复杂的多。 像数组展开一样，它是从左至右进行处理，但结果仍为对象。 这就意味着出现在<strong>展开对象后面的属性会覆盖前面的属性</strong>。 因此，如果我们修改上面的例子，在结尾处进行展开的话：</p>
<pre><code>let defaults = { food: "spicy", price: "$$", ambiance: "noisy" };
let search = { food: "rich", ...defaults };</code></pre><p>那么，defaults里的food属性会重写<code>food: "rich"</code>，在这里这并不是我们想要的结果。</p>
<h2 id="认识Typescript-类"><a href="#认识Typescript-类" class="headerlink" title="认识Typescript-类"></a>认识Typescript-类</h2><p>传统的JavaScript程序使用<strong>函数</strong>和基于<strong>原型</strong>的继承来创建可重用的组件。Typescript则在此基础上加入了语法糖<strong>类</strong>。</p>
<p>了解Javascript的基础内容请参考<a href="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Objects/Object_prototypes" target="_blank" rel="noopener">对象原型</a>。</p>
<h3 id="声明类"><a href="#声明类" class="headerlink" title="声明类"></a>声明类</h3><p>我们首先来看一个例子</p>
<pre><code>class Greeter {
    greeting: string;
    constructor(message: string) {
        this.greeting = message;
    }
    greet() {
        return "Hello, " + this.greeting;
    }
}
let greeter = new Greeter("world");</code></pre><p>如果你使用过C#或Java，你会对这种语法非常熟悉。 我们声明一个 Greeter类。这个类有3个成员：一个叫做 greeting的属性，一个构造函数和一个 greet方法。</p>
<p>你会注意到，我们在引用任何一个类成员的时候都用了 this。 它表示我们访问的是类的成员。</p>
<p>最后一行，我们使用 new构造了 Greeter类的一个实例。 它会调用之前定义的构造函数，创建一个 Greeter类型的新对象，并执行构造函数初始化它。</p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>在TypeScript里，我们可以使用常用的面向对象模式。 基于类的程序设计中一种最基本的模式是允许使用继承来扩展现有的类。</p>
<p>看下面的例子：</p>
<pre><code>class Animal {
    move(distance: number = 0) {
        console.log(`Animal moved ${distance}m.`);
    }
}
class Dog extends Animal {
    bark() {
        console.log('Woof! Woof!');
    }
}
const dog = new Dog();
dog.bark();
dog.move(10);
dog.bark();</code></pre><p>这个例子展示了最基本的继承：类从基类中继承了属性和方法。这里，<code>Dog</code>是一个 <em>派生类</em>，通过 <code>extends</code>关键字使它从 <code>Animal</code> 基类中派生出来。 派生类通常被称作 子类，基类通常被称作 超类或父类。</p>
<p>因为 Dog继承了 Animal的功能，因此我们可以创建一个 Dog的实例，它能够 bark()和 move()。</p>
<p>下面我们来看个更加复杂的例子。</p>
<pre><code>class Animal {
    name: string;
    constructor(theName: string) { this.name = theName; }
    move(distance: number = 0) {
        console.log(`${this.name} moved ${distance}m.`);
    }
}
class Snake extends Animal {
    constructor(name: string) { super(name); }
    move(distance = 5) {
        console.log("Slithering...");
        super.move(distance);
    }
}
class Horse extends Animal {
    constructor(name: string) { super(name); }
    move(distance = 45) {
        console.log("Galloping...");
        super.move(distance);
    }
}
let sam = new Snake("Sammy the Python");
let tom: Animal = new Horse("Tommy the Palomino");
sam.move();
tom.move(34);</code></pre><p>与前一个例子的不同点是，这次两个派生类包含了一个构造函数，它<strong>必须调用 <code>super()</code></strong>，它会执行基类的构造函数。 而且，在构造函数里访问 this的属性之前，我们 <strong>必须</strong>要调用 super()，这个是TypeScript强制规定的。</p>
<h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><h4 id="public"><a href="#public" class="headerlink" title="public"></a>public</h4><p>如果你对其它语言中的类比较了解，就会注意到我们在之前的代码里并没有使用 <code>public</code>来做修饰；例如，C#要求必须明确地使用 <code>public</code>指定成员是可见的。 在TypeScript里，成员都默认为 <code>public</code>。在上面的例子里，我们可以自由的访问程序里定义的成员。</p>
<h4 id="private"><a href="#private" class="headerlink" title="private"></a>private</h4><p>当成员被标记成 <code>private</code>时，它就不能在声明它的类的外部访问。比如</p>
<pre><code>class Animal {
    private name: string;
    constructor(theName: string) { this.name = theName; }
}
new Animal("Cat").name; // 错误: 'name' 是私有的.</code></pre><h4 id="protected"><a href="#protected" class="headerlink" title="protected"></a>protected</h4><p>protected修饰符与 private修饰符的行为很相似，但有一点不同， protected成员在派生类中仍然可以访问。</p>
<pre><code>class Person {
    protected name: string;
    constructor(name: string) { this.name = name; }
}
class Employee extends Person {
    private department: string;
    constructor(name: string, department: string) {
        super(name)
        this.department = department;
    }
    public getElevatorPitch() {
        return `Hello, my name is ${this.name} and I work in ${this.department}.`;
    }
}
let howard = new Employee("Howard", "Sales");
console.log(howard.getElevatorPitch());
console.log(howard.name); // 错误</code></pre><p>注意，我们不能在 <code>Person</code>类外使用 <code>name</code>，但是我们仍然可以通过 <code>Employee</code>类的<strong>实例方法</strong>访问，因为 <code>Employee</code>是由 <code>Person</code>派生而来的。</p>
<h4 id="readonly"><a href="#readonly" class="headerlink" title="readonly"></a>readonly</h4><p>你可以使用 <code>readonly</code>关键字将属性设置为只读的。 只读属性必须在声明时或构造函数里被初始化。</p>
<pre><code>class Octopus {
    readonly name: string;
    readonly numberOfLegs: number = 8;
    constructor (theName: string) {
        this.name = theName;
    }
}
let dad = new Octopus("Man with the 8 strong legs");
dad.name = "Man with the 3-piece suit"; // 错误! name 是只读的.</code></pre><h4 id="get-set"><a href="#get-set" class="headerlink" title="get/set"></a>get/set</h4><p>TypeScript支持通过<code>getters/setters</code>来截取对对象成员的访问。 它能帮助你有效的控制对对象成员的访问。</p>
<p>下面来看如何把一个简单的类改写成使用 <code>get</code>和 <code>set</code>。 首先，我们从一个没有使用存取器的例子开始。</p>
<pre><code>class Employee {
    fullName: string;
}
let employee = new Employee();
employee.fullName = "Bob Smith";
if (employee.fullName) {
    console.log(employee.fullName);
}</code></pre><p>下面这个版本里，我们先检查用户密码是否正确，然后再允许其修改员工信息。 我们把对 <code>fullName</code>的直接访问改成了可以检查密码的 set方法。 我们也加了一个 get方法，让上面的例子仍然可以工作。</p>
<pre><code>let passcode = "secret passcode";
class Employee {
    private _fullName: string;
    get fullName(): string {
        return this._fullName;
    }
    set fullName(newName: string) {
        if (passcode &amp;&amp; passcode == "secret passcode") {
            this._fullName = newName;
        }
        else {
            console.log("Error: Unauthorized update of employee!");
        }
    }
}
let employee = new Employee();
employee.fullName = "Bob Smith";
if (employee.fullName) {
    alert(employee.fullName);
}</code></pre><h4 id="static"><a href="#static" class="headerlink" title="static"></a>static</h4><p>到目前为止，我们只讨论了类的实例成员，那些仅当类被实例化的时候才会被初始化的属性。 我们也可以创建类的静态成员，这些属性存在于类本身上面而不是类的实例上。</p>
<pre><code>class Router {
    static baseRoute = '/basePath';
    calculateRoute(path: string) {
        return this.baseRoute + this.commonPrefix  + path;
    }
    constructor (public commonPrefix: number) { }
}
let route1 = new Router('/api');  // 一级路径为/api
let route2 = new Router('/page');  // 一级路径为/page
console.log(route1.calculateRoute('/main');  // 最终路径/basePath/api/main
console.log(route2.calculateRoute('/user');  // 最终路径/basePath/page/user</code></pre><h4 id="abstract"><a href="#abstract" class="headerlink" title="abstract"></a>abstract</h4><p>抽象类做为其它派生类的基类使用。 它们一般不会直接被实例化。 不同于接口，抽象类可以包含成员的实现细节。 <code>abstract</code>关键字是用于定义抽象类和在抽象类内部定义抽象方法。</p>
<pre><code>abstract class Animal {
    abstract makeSound(): void;
    move(): void {
        console.log('roaming the earch...');
    }
}</code></pre><h2 id="认识TypeScript-类型接口和命名空间"><a href="#认识TypeScript-类型接口和命名空间" class="headerlink" title="认识TypeScript-类型接口和命名空间"></a>认识TypeScript-类型接口和命名空间</h2><p>TypeScript的核心原则之一是对数据的结构进行类型检查。 它有时被称做“鸭式辨型法”或“结构性子类型化”。 在TypeScript里，<strong>接口</strong>的作用就是为这些类型命名和为你的代码或第三方代码定义<strong>契约</strong>。</p>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><hr>
<h4 id="接口初探"><a href="#接口初探" class="headerlink" title="接口初探"></a>接口初探</h4><p>下面通过一个简单示例来观察接口是如何工作的：</p>
<pre><code>function printLabel(labelledObj: { label: string }) {
  console.log(labelledObj.label);
}
let myObj = { size: 10, label: "Size 10 Object" };
printLabel(myObj);</code></pre><p>类型检查器会检查<code>printLabel</code>的调用。 <code>printLabel</code>有一个参数，并要求这个对象参数有一个名为<code>label</code>类型为<code>string</code>的属性。 需要注意的是，我们传入的对象参数实际上会包含很多属性，但是编译器只会检查那些必需的属性是否存在，并且其类型是否匹配。 然而，有些时候TypeScript却并不会这么宽松，我们下面会稍做讲解。</p>
<p>下面我们重写上面的例子，这次使用接口来描述：必须包含一个<code>label</code>属性且类型为<code>string</code>：</p>
<pre><code>interface LabelledValue {
  label: string;
}
function printLabel(labelledObj: LabelledValue) {
  console.log(labelledObj.label);
}
let myObj = {size: 10, label: "Size 10 Object"};
printLabel(myObj);</code></pre><p><code>LabelledValue</code>接口就好比一个名字，用来描述上面例子里的要求。 它代表了有一个 <code>label</code>属性且类型为<code>string</code>的对象。 需要注意的是，我们在这里并不能像在其它语言里一样，说传给 <code>printLabel</code>的对象实现了这个接口。我们只会去关注值的外形。 只要传入的对象满足上面提到的必要条件，那么它就是被允许的。</p>
<p>还有一点值得提的是，类型检查器不会去检查属性的顺序，只要相应的属性存在并且类型也是对的就可以。</p>
<h4 id="可选属性"><a href="#可选属性" class="headerlink" title="可选属性"></a>可选属性</h4><p>接口里的属性不全都是必需的。 有些是只在某些条件下存在，或者根本不存在。 可选属性在应用“option bags”模式时很常用，即给函数传入的参数对象中只有部分属性赋值了。</p>
<p>下面是应用了“option bags”的例子：</p>
<pre><code>interface SquareConfig {
  color?: string;
  width?: number;
}
function createSquare(config: SquareConfig): {color: string; area: number} {
  let newSquare = {color: "white", area: 100};
  if (config.color) {
    newSquare.color = config.color;
  }
  if (config.width) {
    newSquare.area = config.width * config.width;
  }
  return newSquare;
}
let mySquare = createSquare({color: "black"});</code></pre><p>带有可选属性的接口与普通的接口定义差不多，只是在可选属性名字定义的后面加一个<code>?</code>符号。</p>
<p>可选属性的好处之一是可以对可能存在的属性进行预定义，好处之二是可以捕获引用了不存在的属性时的错误。 比如，我们故意将 createSquare里的color属性名拼错，就会得到一个错误提示：</p>
<pre><code>interface SquareConfig {
  color?: string;
  width?: number;
}
function createSquare(config: SquareConfig): { color: string; area: number } {
  let newSquare = {color: "white", area: 100};
  if (config.clor) {
    // Error: Property 'clor' does not exist on type 'SquareConfig'
    newSquare.color = config.clor;
  }
  if (config.width) {
    newSquare.area = config.width * config.width;
  }
  return newSquare;
}
let mySquare = createSquare({color: "black"});</code></pre><h4 id="只读属性"><a href="#只读属性" class="headerlink" title="只读属性"></a>只读属性</h4><p>一些对象属性只能在对象刚刚创建的时候修改其值。 你可以在属性名前用 readonly来指定只读属性:</p>
<pre><code>interface Point {
    readonly x: number;
    readonly y: number;
}</code></pre><p>你可以通过赋值一个对象字面量来构造一个Point。 赋值后， x和y再也不能被改变了。</p>
<pre><code>let p1: Point = { x: 10, y: 20 };
p1.x = 5; // error!</code></pre><p>TypeScript具有<code>ReadonlyArray&lt;T&gt;</code>类型，它与<code>Array&lt;T&gt;</code>相似，只是把所有可变方法去掉了，因此可以确保数组创建后再也不能被修改：</p>
<pre><code>let a: number[] = [1, 2, 3, 4];
let ro: ReadonlyArray&lt;number&gt; = a;
ro[0] = 12; // error!
ro.push(5); // error!
ro.length = 100; // error!
a = ro; // error!</code></pre><p>上面代码的最后一行，可以看到就算把整个ReadonlyArray赋值到一个普通数组也是不可以的。 但是你可以用类型断言重写：</p>
<pre><code>a = ro as number[];</code></pre><p><strong>readonly vs const</strong></p>
<p>最简单判断该用<strong>readonly</strong>还是<strong>const</strong>的方法是看要把它做为变量使用还是做为一个属性。 做为变量使用的话用 const，若做为属性则使用readonly。</p>
<h4 id="额外的属性检查"><a href="#额外的属性检查" class="headerlink" title="额外的属性检查"></a>额外的属性检查</h4><p>我们在第一个例子里使用了接口，TypeScript让我们传入<code>{ size: number; label: string; }</code>到仅期望得到<code>{ label: string; }</code>的函数里。 我们已经学过了可选属性，并且知道他们在“option bags”模式里很有用。</p>
<p>然而，天真地将这两者结合的话就会像在JavaScript里那样搬起石头砸自己的脚。 比如，拿<code>createSquare</code>例子来说：</p>
<pre><code>interface SquareConfig {
    color?: string;
    width?: number;
}
function createSquare(config: SquareConfig): { color: string; area: number } {
    // ...
}
let mySquare = createSquare({ colour: "red", width: 100 });</code></pre><p>注意传入<code>createSquare</code>的参数拼写为<code>colour</code>而不是<code>color</code>。 在JavaScript里，这会导致静默失败。</p>
<p>你可能会争辩这个程序已经正确地类型化了，因为width属性是兼容的，不存在<code>color</code>属性，而且额外的<code>colour</code>属性是无意义的。</p>
<p>然而，TypeScript会认为这段代码可能存在bug。 对象字面量会被特殊对待而且会经过 额外属性检查，当将它们赋值给变量或作为参数传递的时候。 如果一个对象字面量存在任何“目标类型”不包含的属性时，你会得到一个错误。</p>
<pre><code>// error: 'colour' not expected in type 'SquareConfig'
let mySquare = createSquare({ colour: "red", width: 100 });</code></pre><p>绕开这些检查非常简单。 最简便的方法是使用类型断言：</p>
<pre><code>let mySquare = createSquare({ width: 100, opacity: 0.5 } as SquareConfig);</code></pre><p>然而，最佳的方式是能够添加一个字符串索引签名，前提是你能够确定这个对象可能具有某些做为特殊用途使用的额外属性。 如果 <code>SquareConfig</code>带有上面定义的类型的<code>color</code>和<code>width</code>属性，并且还会带有任意数量的其它属性，那么我们可以这样定义它：</p>
<pre><code>interface SquareConfig {
    color?: string;
    width?: number;
    [propName: string]: any;
}</code></pre><p>我们稍后会讲到索引签名，但在这我们要表示的是<code>SquareConfig</code>可以有任意数量的属性，并且只要它们不是<code>color</code>和<code>width</code>，那么就无所谓它们的类型是什么。</p>
<p>还有最后一种跳过这些检查的方式，这可能会让你感到惊讶，它就是将这个对象赋值给一个另一个变量： 因为 <code>squareOptions</code>不会经过额外属性检查，所以编译器不会报错。</p>
<pre><code>let squareOptions = { colour: "red", width: 100 };
let mySquare = createSquare(squareOptions);</code></pre><p>要留意，在像上面一样的简单代码里，你可能不应该去绕开这些检查。 对于包含方法和内部状态的复杂对象字面量来讲，你可能需要使用这些技巧，但是大部额外属性检查错误是真正的bug。 就是说你遇到了额外类型检查出的错误，比如“option bags”，你应该去审查一下你的类型声明。 在这里，如果支持传入 <code>color</code>或<code>colour</code>属性到<code>createSquare</code>，你应该修改<code>SquareConfig</code>定义来体现出这一点。</p>
<h4 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h4><p>接口能够描述JavaScript中对象拥有的各种各样的外形。 除了描述带有属性的普通对象外，接口也可以描述函数类型。</p>
<p>为了使用接口表示函数类型，我们需要给接口定义一个调用签名。 它就像是一个只有参数列表和返回值类型的函数定义。参数列表里的每个参数都需要名字和类型。</p>
<pre><code>interface SearchFunc {
  (source: string, subString: string): boolean;
}</code></pre><p>这样定义后，我们可以像使用其它接口一样使用这个函数类型的接口。下例展示了如何创建一个函数类型的变量，并将一个同类型的函数赋值给这个变量。</p>
<pre><code>let mySearch: SearchFunc;
mySearch = function(source: string, subString: string) {
  let result = source.search(subString);
  return result &gt; -1;
}</code></pre><p>对于函数类型的类型检查来说，函数的参数名不需要与接口里定义的名字相匹配。 比如，我们使用下面的代码重写上面的例子：</p>
<pre><code>let mySearch: SearchFunc;
mySearch = function(src: string, sub: string): boolean {
  let result = src.search(sub);
  return result &gt; -1;
}</code></pre><p>函数的参数会<strong>逐个进行检查</strong>，要求<strong>对应位置上的参数类型是兼容的</strong>。 如果你不想指定类型，TypeScript的类型系统会推断出参数类型，因为函数直接赋值给了 <code>SearchFunc</code>类型变量。 函数的返回值类型是通过其返回值推断出来的（此例是 false和true）。 如果让这个函数返回数字或字符串，类型检查器会警告我们函数的返回值类型与 <code>SearchFunc</code>接口中的定义不匹配。</p>
<pre><code>let mySearch: SearchFunc;
mySearch = function(src, sub) {
    let result = src.search(sub);
    return result &gt; -1;
}</code></pre><h4 id="可索引的类型"><a href="#可索引的类型" class="headerlink" title="可索引的类型"></a>可索引的类型</h4><p>与使用接口描述函数类型差不多，我们也可以描述那些能够“通过索引得到”的类型，比如<code>a[10]</code>或<code>ageMap["daniel"]</code>。 可索引类型具有一个 <em>索引签名</em>，它描述了对象索引的类型，还有相应的索引返回值类型。 让我们看一个例子：</p>
<pre><code>interface StringArray {
  [index: number]: string;
}
let myArray: StringArray;
myArray = ["Bob", "Fred"];
let myStr: string = myArray[0];</code></pre><p>上面例子里，我们定义了<code>StringArray</code>接口，它具有索引签名。 这个索引签名表示了当用 <code>number</code>去索引<code>StringArray</code>时会得到<code>string</code>类型的返回值。</p>
<p>TypeScript支持两种索引签名：字符串和数字。 可以同时使用两种类型的索引，但是数字索引的返回值必须是字符串索引返回值类型的子类型。 这是因为当使用 <code>number</code>来索引时，JavaScript会将它转换成<code>string</code>然后再去索引对象。 也就是说用 100（一个<code>number</code>）去索引等同于使用”100”（一个<code>string</code>）去索引，因此两者需要保持一致。</p>
<pre><code>class Animal {
    name: string;
}
class Dog extends Animal {
    breed: string;
}
// 错误：使用数值型的字符串索引，有时会得到完全不同的Animal!
interface NotOkay {
    [x: number]: Animal;
    [x: string]: Dog;
}</code></pre><p>字符串索引签名能够很好的描述dictionary模式，并且它们也会确保所有属性与其返回值类型相匹配。 因为字符串索引声明了 <code>obj.property</code>和<code>obj["property"]</code>两种形式都可以。 下面的例子里， name的类型与字符串索引类型不匹配，所以类型检查器给出一个错误提示：</p>
<pre><code>interface NumberDictionary {
  [index: string]: number;
  length: number;    // 可以，length是number类型
  name: string       // 错误，`name`的类型与索引类型返回值的类型不匹配
}</code></pre><p>最后，你可以将索引签名设置为只读，这样就防止了给索引赋值：</p>
<pre><code>interface ReadonlyStringArray {
    readonly [index: number]: string;
}
let myArray: ReadonlyStringArray = ["Alice", "Bob"];
myArray[2] = "Mallory"; // error!</code></pre><p>你不能设置<code>myArray[2]</code>，因为索引签名是只读的。</p>
<h4 id="类类型"><a href="#类类型" class="headerlink" title="类类型"></a>类类型</h4><p>与C#或Java里接口的基本作用一样，TypeScript也能够用它来明确或强制一个类去符合某种契约。</p>
<pre><code>interface ClockInterface {
    currentTime: Date;
}
class Clock implements ClockInterface {
    currentTime: Date;
    constructor(h: number, m: number) { }
}</code></pre><p>你也可以在接口中描述一个方法，在类里实现它，如同下面的<code>setTime</code>方法一样：</p>
<pre><code>interface ClockInterface {
    currentTime: Date;
    setTime(d: Date);
}
class Clock implements ClockInterface {
    currentTime: Date;
    setTime(d: Date) {
        this.currentTime = d;
    }
    constructor(h: number, m: number) { }
}</code></pre><p>接口描述了类的公共部分，而不是公共和私有两部分。 它不会帮你检查类是否具有某些私有成员。</p>
<h4 id="类的静态部分和实例部分"><a href="#类的静态部分和实例部分" class="headerlink" title="类的静态部分和实例部分"></a>类的静态部分和实例部分</h4><p>当你在类上面使用接口时，你需要注意一个<strong>类</strong>是由两部分构成的：类的静态部分和实例部分。如果你的接口上面声明了构造器签名，然后将这个接口应用在类上，你会看到报错：</p>
<pre><code>interface ClockConstructor {
    new (hour: number, minute: number);
}
class Clock implements ClockConstructor {
    currentTime: Date;
    constructor(h: number, m: number) { }
}</code></pre><p>这是因为一个类实现某个接口时，接口只检查<strong>类</strong>的实例部分，而<code>constructor</code>构造器方法是类的静态部分，因此它不包含在类型检查之内。</p>
<p>所以，我们其实只要直接操作类的静态部分就可以了。在下述例子中，我们定义2个接口，一个<code>ClockConstructor</code>给构造器使用，一个<code>ClockInterface</code>供实例方法使用。方便起见，我们再定义一个构造器函数<code>createClock</code>：</p>
<pre><code>interface ClockConstructor {
    new (hour: number, minute: number): ClockInterface;
}
interface ClockInterface {
    tick(): void;
}
function createClock(ctor: ClockConstructor, hour: number, minute: number): ClockInterface {
    return new ctor(hour, minute);
}
class DigitalClock implements ClockInterface {
    constructor(h: number, m: number) { }
    tick() {
        console.log("beep beep");
    }
}
class AnalogClock implements ClockInterface {
    constructor(h: number, m: number) { }
    tick() {
        console.log("tick tock");
    }
}</code></pre><p>因为<code>createClock</code>的第一个参数是<code>ClockConstructor</code>类型，在<code>createClock(AnalogClock, 7, 32)</code>里，会检查<code>AnalogClock</code>是否符合构造函数签名。</p>
<h4 id="接口继承"><a href="#接口继承" class="headerlink" title="接口继承"></a>接口继承</h4><p>和类一样，接口也可以相互继承。 这让我们能够从一个接口里复制成员到另一个接口里，可以更灵活地将接口分割到可重用的模块里。</p>
<pre><code>interface Shape {
    color: string;
}
interface Square extends Shape {
    sideLength: number;
}
let square = &lt;Square&gt;{};
square.color = "blue";
square.sideLength = 10;</code></pre><p>一个接口可以继承多个接口，创建出多个接口的合成接口。</p>
<pre><code>interface Shape {
    color: string;
}
interface PenStroke {
    penWidth: number;
}
interface Square extends Shape, PenStroke {
    sideLength: number;
}
let square = &lt;Square&gt;{};
square.color = "blue";
square.sideLength = 10;
square.penWidth = 5.0;</code></pre><h4 id="混合类型"><a href="#混合类型" class="headerlink" title="混合类型"></a>混合类型</h4><p>先前我们提过，接口能够描述JavaScript里丰富的类型。 因为JavaScript其动态灵活的特点，有时你会希望一个对象可以同时具有上面提到的多种类型。</p>
<p>一个例子就是，一个对象可以同时做为函数和对象使用，并带有额外的属性。</p>
<pre><code>interface Counter {
    (start: number): string;
    interval: number;
    reset(): void;
}
function getCounter(): Counter {
    let counter = &lt;Counter&gt;function (start: number) { };
    counter.interval = 123;
    counter.reset = function () { };
    return counter;
}
let c = getCounter();
c(10);
c.reset();
c.interval = 5.0;</code></pre><h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3><hr>
<h4 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h4><p>我们先来写一段程序并将在整篇文章中都使用这个例子。 我们定义几个简单的字符串验证器，假设你会使用它们来验证表单里的用户输入或验证外部数据。</p>
<p>所有的验证器都放在一个文件里：</p>
<pre><code>interface StringValidator {
    isAcceptable(s: string): boolean;
}
let lettersRegexp = /^[A-Za-z]+$/;
let numberRegexp = /^[0-9]+$/;
class LettersOnlyValidator implements StringValidator {
    isAcceptable(s: string) {
        return lettersRegexp.test(s);
    }
}
class ZipCodeValidator implements StringValidator {
    isAcceptable(s: string) {
        return s.length === 5 &amp;&amp; numberRegexp.test(s);
    }
}
// 一个使用例子
let strings = ["Hello", "98052", "101"];
// 可以使用的校验器
let validators: { [s: string]: StringValidator; } = {};
validators["ZIP code"] = new ZipCodeValidator();
validators["Letters only"] = new LettersOnlyValidator();
// 每个strings是否都能找到对应的校验器
for (let s of strings) {
    for (let name in validators) {
        let isMatch = validators[name].isAcceptable(s);
        console.log(`'${ s }' ${ isMatch ? "matches" : "does not match" } '${ name }'.`);
    }
}</code></pre><h4 id="命名空间-1"><a href="#命名空间-1" class="headerlink" title="命名空间"></a>命名空间</h4><p>随着更多验证器的加入，我们需要一种手段来组织代码，以便于在记录它们类型的同时还不用担心与其它对象产生命名冲突。 因此，我们把验证器包裹到一个命名空间内，而不是把它们放在全局命名空间下。</p>
<p>下面的例子里，把所有与验证器相关的类型都放到一个叫做<code>Validation</code>的命名空间里。 因为我们想让这些接口和类在命名空间之外也是可访问的，所以需要使用<code>export</code>。 相反的，变量 <code>lettersRegexp</code>和<code>numberRegexp</code>是实现的细节，不需要导出，因此它们在命名空间外是不能访问的。 在文件末尾的测试代码里，由于是在命名空间之外访问，因此需要限定类型的名称，比如 <code>Validation.LettersOnlyValidator</code>。</p>
<p>使用命名空间的验证器:</p>
<pre><code>namespace Validation {
    export interface StringValidator {
        isAcceptable(s: string): boolean;
    }
    const lettersRegexp = /^[A-Za-z]+$/;
    const numberRegexp = /^[0-9]+$/;
    export class LettersOnlyValidator implements StringValidator {
        isAcceptable(s: string) {
            return lettersRegexp.test(s);
        }
    }
    export class ZipCodeValidator implements StringValidator {
        isAcceptable(s: string) {
            return s.length === 5 &amp;&amp; numberRegexp.test(s);
        }
    }
}
// 一个例子
let strings = ["Hello", "98052", "101"];
let validators: { [s: string]: Validation.StringValidator; } = {};
validators["ZIP code"] = new Validation.ZipCodeValidator();
validators["Letters only"] = new Validation.LettersOnlyValidator();
for (let s of strings) {
    for (let name in validators) {
        console.log(`"${ s }" - ${ validators[name].isAcceptable(s) ? "matches" : "does not match" } ${ name }`);
    }
}</code></pre><h4 id="分离文件"><a href="#分离文件" class="headerlink" title="分离文件"></a>分离文件</h4><p>当应用变得越来越大时，我们需要将代码分离到不同的文件中以便于维护。</p>
<p>现在，我们把<code>Validation</code>命名空间分割成多个文件。 尽管是不同的文件，它们仍是同一个命名空间，并且在使用的时候就如同它们在一个文件中定义的一样。 因为不同文件之间存在依赖关系，所以我们加入了引用标签来告诉编译器文件之间的关联。 我们的测试代码保持不变。</p>
<pre><code>Validation.ts

namespace Validation {
    export interface StringValidator {
        isAcceptable(s: string): boolean;
    }
}

LettersOnlyValidator.ts

/// &lt;reference path="Validation.ts" /&gt;
namespace Validation {
    const lettersRegexp = /^[A-Za-z]+$/;
    export class LettersOnlyValidator implements StringValidator {
        isAcceptable(s: string) {
            return lettersRegexp.test(s);
        }
    }
}

ZipCodeValidator.ts

/// &lt;reference path="Validation.ts" /&gt;
namespace Validation {
    const numberRegexp = /^[0-9]+$/;
    export class ZipCodeValidator implements StringValidator {
        isAcceptable(s: string) {
            return s.length === 5 &amp;&amp; numberRegexp.test(s);
        }
    }
}

Test.ts

/// &lt;reference path="Validation.ts" /&gt;
/// &lt;reference path="LettersOnlyValidator.ts" /&gt;
/// &lt;reference path="ZipCodeValidator.ts" /&gt;
// Some samples to try
let strings = ["Hello", "98052", "101"];
// Validators to use
let validators: { [s: string]: Validation.StringValidator; } = {};
validators["ZIP code"] = new Validation.ZipCodeValidator();
validators["Letters only"] = new Validation.LettersOnlyValidator();
// Show whether each string passed each validator
for (let s of strings) {
    for (let name in validators) {
        console.log(`"${ s }" - ${ validators[name].isAcceptable(s) ? "matches" : "does not match" } ${ name }`);
    }
}</code></pre><p>当涉及到多文件时，我们必须确保所有编译后的代码都被加载了。 我们有两种方式。</p>
<p>第一种方式，把所有的输入文件编译为一个输出文件，需要使用—outFile标记：</p>
<pre><code>tsc --outFile sample.js Test.ts</code></pre><p>编译器会根据源码里的引用标签自动地对输出进行排序。你也可以单独地指定每个文件。</p>
<pre><code>tsc --outFile sample.js Validation.ts LettersOnlyValidator.ts ZipCodeValidator.ts Test.ts</code></pre><p>第二种方式，我们可以编译每一个文件（默认方式），那么每个源文件都会对应生成一个JavaScript文件。 然后，在页面上通过 <code>&lt;script&gt;</code>标签把所有生成的JavaScript文件按正确的顺序引进来，比如：</p>
<pre><code>&lt;script src="Validation.js" type="text/javascript" /&gt;
&lt;script src="LettersOnlyValidator.js" type="text/javascript" /&gt;
&lt;script src="ZipCodeValidator.js" type="text/javascript" /&gt;
&lt;script src="Test.js" type="text/javascript" /&gt;</code></pre><h2 id="认识Typescript-泛型"><a href="#认识Typescript-泛型" class="headerlink" title="认识Typescript-泛型"></a>认识Typescript-泛型</h2><p>软件工程中，我们不仅要创建一致的定义良好的API，同时也要考虑可重用性。 组件不仅能够支持当前的数据类型，同时也能支持未来的数据类型，这在创建大型系统时为你提供了十分灵活的功能。</p>
<p>在像C#和Java这样的语言中，可以使用<strong>泛型</strong>来创建可重用的组件，一个组件可以支持多种类型的数据。 这样用户就可以以自己的数据类型来使用组件。</p>
<h3 id="泛型之Hello-World"><a href="#泛型之Hello-World" class="headerlink" title="泛型之Hello World"></a>泛型之Hello World</h3><hr>
<p>下面来创建第一个使用泛型的例子：identity函数。 这个函数会返回任何传入它的值。 你可以把这个函数当成是 <code>echo</code>命令。</p>
<p>不用泛型的话，这个函数可能是下面这样：</p>
<pre><code>function identity(arg: number): number {
    return arg;
}</code></pre><p>或者，我们使用any类型来定义函数：</p>
<pre><code>function identity(arg: any): any {
    return arg;
}</code></pre><p>使用<code>any</code>类型会导致这个函数可以接收任何类型的arg参数，这样就丢失了一些信息：传入的类型与返回的类型应该是相同的。如果我们传入一个数字，我们只知道任何类型的值都有可能被返回。</p>
<p>因此，我们需要一种方法使返回值的类型与传入参数的类型是相同的。 这里，我们使用了<strong>类型变量</strong>，它是一种特殊的变量，<em>只用于表示类型而不是值</em>。</p>
<pre><code>function identity&lt;T&gt;(arg: T): T {
    return arg;
}</code></pre><p>我们给identity添加了类型变量<code>T</code>。 <code>T</code>帮助我们捕获用户传入的类型（比如：<code>number</code>），之后我们就可以使用这个类型。 之后我们再次使用了<code>T</code>当做返回值类型。现在我们可以知道参数类型与返回值类型是相同的了。 这允许我们跟踪函数里使用的类型的信息。</p>
<p>我们把这个版本的<code>identity</code>函数叫做泛型，因为它可以适用于多个类型。 不同于使用<code>any</code>，它不会丢失信息，像第一个例子那像保持准确性，传入数值类型并返回数值类型。</p>
<p>我们定义了泛型函数后，可以用两种方法使用。 第一种是，传入所有的参数，包含类型参数：</p>
<pre><code>let output = identity&lt;string&gt;("myString");  // type of output will be 'string'</code></pre><p>这里我们明确的指定了<code>T</code>是<code>string</code>类型，并做为一个参数传给函数，使用了<code>&lt;&gt;</code>括起来而不是<code>()</code>。</p>
<p>第二种方法更普遍。利用了<em>类型推论</em> — 即编译器会根据传入的参数自动地帮助我们确定T的类型：</p>
<pre><code>let output = identity("myString");  // type of output will be 'string'</code></pre><p>注意我们没必要使用尖括号（<code>&lt;&gt;</code>）来明确地传入类型；编译器可以查看<code>myString</code>的值，然后把<code>T</code>设置为它的类型。 类型推论帮助我们保持代码精简和高可读性。如果编译器不能够自动地推断出类型的话，只能像上面那样明确的传入<code>T</code>的类型，在一些复杂的情况下，这是可能出现的。</p>
<h3 id="使用泛型变量"><a href="#使用泛型变量" class="headerlink" title="使用泛型变量"></a>使用泛型变量</h3><hr>
<p>使用泛型创建像<code>identity</code>这样的泛型函数时，编译器要求你在函数体必须正确的使用这个通用的类型。 换句话说，你必须把这些参数当做是任意或所有类型。</p>
<p>看下之前identity例子：</p>
<pre><code>function identity&lt;T&gt;(arg: T): T {
    return arg;
}</code></pre><p>如果我们想同时打印出arg的长度。 我们很可能会这样做：</p>
<pre><code>function loggingIdentity&lt;T&gt;(arg: T): T {
    console.log(arg.length);  // Error: T doesn't have .length
    return arg;
}</code></pre><p>如果这么做，编译器会报错说我们使用了<code>arg</code>的<code>.length</code>属性，但是没有地方指明<code>arg</code>具有这个属性。 记住，这些类型变量代表的是任意类型，所以使用这个函数的人可能传入的是个数字，而数字是没有 <code>.length</code>属性的。</p>
<p>现在假设我们想操作T类型的数组而不直接是T。由于我们操作的是数组，所以<code>.length</code>属性是应该存在的。 我们可以像创建其它数组一样创建这个数组：</p>
<pre><code>function loggingIdentity&lt;T&gt;(arg: T[]): T[] {
    console.log(arg.length);  // Array has a .length, so no more error
    return arg;
}</code></pre><p>你可以这样理解<code>loggingIdentity</code>的类型：泛型函数<code>loggingIdentity</code>，接收类型参数<code>T</code>和参数<code>arg</code>，它是个元素类型是<code>T</code>的数组，并返回元素类型是<code>T</code>的数组。 如果我们传入数字数组，将返回一个数字数组，因为此时 <code>T</code>的的类型为number。 这可以让我们把泛型变量<code>T</code>当做类型的一部分使用，而不是整个类型，增加了灵活性。</p>
<p>我们也可以这样实现上面的例子：</p>
<pre><code>function loggingIdentity&lt;T&gt;(arg: Array&lt;T&gt;): Array&lt;T&gt; {
    console.log(arg.length);  // Array has a .length, so no more error
    return arg;
}</code></pre><p>使用过其它语言的话，你可能对这种语法已经很熟悉了。 在下一节，会介绍如何创建自定义泛型像 Array一样。</p>
<h3 id="泛型类型"><a href="#泛型类型" class="headerlink" title="泛型类型"></a>泛型类型</h3><hr>
<p>上一节，我们创建了identity通用函数，可以适用于不同的类型。 在这节，我们研究一下函数本身的类型，以及如何创建泛型接口。</p>
<p>泛型函数的类型与非泛型函数的类型没什么不同，只是有一个类型参数在最前面，像函数声明一样：</p>
<pre><code>function identity&lt;T&gt;(arg: T): T {
    return arg;
}
let myIdentity: &lt;T&gt;(arg: T) =&gt; T = identity;</code></pre><p>我们也可以使用不同的泛型参数名，只要在数量上和使用方式上能对应上就可以。</p>
<pre><code>function identity&lt;T&gt;(arg: T): T {
    return arg;
}
let myIdentity: &lt;U&gt;(arg: U) =&gt; U = identity;</code></pre><p>我们还可以使用带有调用签名的对象字面量来定义泛型函数：</p>
<pre><code>function identity&lt;T&gt;(arg: T): T {
    return arg;
}
let myIdentity: {&lt;T&gt;(arg: T): T} = identity;</code></pre><p>这引导我们去写第一个泛型接口了。 我们把上面例子里的对象字面量拿出来做为一个接口：</p>
<pre><code>interface GenericIdentityFn {
    &lt;T&gt;(arg: T): T;
}
function identity&lt;T&gt;(arg: T): T {
    return arg;
}
let myIdentity: GenericIdentityFn = identity;</code></pre><p>一个相似的例子，我们可能想把泛型参数当作整个接口的一个参数。 这样我们就能清楚的知道使用的具体是哪个泛型类型（比如： <code>Dictionary&lt;string&gt;而不只是Dictionary</code>）。 这样接口里的其它成员也能知道这个参数的类型了。</p>
<pre><code>interface GenericIdentityFn&lt;T&gt; {
    (arg: T): T;
}
function identity&lt;T&gt;(arg: T): T {
    return arg;
}
let myIdentity: GenericIdentityFn&lt;number&gt; = identity;</code></pre><p>注意，我们的示例做了少许改动。 不再描述泛型函数，而是把非泛型函数签名作为泛型类型一部分。 当我们使用 <code>GenericIdentityFn</code> 的时候，还得传入一个类型参数来指定泛型类型（这里是：<code>number</code>），锁定了之后代码里使用的类型。 对于描述哪部分类型属于泛型部分来说，理解何时把参数放在调用签名里和何时放在接口上是很有帮助的。</p>
<p>除了泛型接口，我们还可以创建泛型类。 注意，无法创建泛型枚举和泛型命名空间。</p>
<h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><hr>
<pre><code>class GenericNumber&lt;T&gt; {
    zeroValue: T;
    add: (x: T, y: T) =&gt; T;
}
let myGenericNumber = new GenericNumber&lt;number&gt;();
myGenericNumber.zeroValue = 0;
myGenericNumber.add = function(x, y) { return x + y; };</code></pre><p>GenericNumber类的使用是十分直观的，并且你可能已经注意到了，没有什么去限制它只能使用number类型。 也可以使用字符串或其它更复杂的类型。</p>
<pre><code>let stringNumeric = new GenericNumber&lt;string&gt;();
stringNumeric.zeroValue = "";
stringNumeric.add = function(x, y) { return x + y; };
console.log(stringNumeric.add(stringNumeric.zeroValue, "test"));</code></pre><p>与接口一样，直接把泛型类型放在类后面，可以帮助我们确认类的所有属性都在使用相同的类型。</p>
<h3 id="泛型约束"><a href="#泛型约束" class="headerlink" title="泛型约束"></a>泛型约束</h3><hr>
<p>你应该会记得之前的一个例子，我们有时候想操作某类型的一组值，并且我们知道这组值具有什么样的属性。 在 <code>loggingIdentity</code> 例子中，我们想访问<code>arg</code>的<code>length</code>属性，但是编译器并不能证明每种类型都有<code>length</code>属性，所以就报错了。</p>
<pre><code>function loggingIdentity&lt;T&gt;(arg: T): T {
    console.log(arg.length);  // Error: T doesn't have .length
    return arg;
}</code></pre><p>相比于操作any所有类型，我们想要限制函数去处理任意带有<code>.length</code>属性的所有类型。 只要传入的类型有这个属性，我们就允许，就是说至少包含这一属性。 为此，我们需要列出对于T的约束要求。</p>
<p>为此，我们定义一个接口来描述约束条件。 创建一个包含 <code>.length</code>属性的接口，使用这个接口和extends关键字来实现约束：</p>
<pre><code>interface Lengthwise {
    length: number;
}
function loggingIdentity&lt;T extends Lengthwise&gt;(arg: T): T {
    console.log(arg.length);  // Now we know it has a .length property, so no more error
    return arg;
}</code></pre><p>现在这个泛型函数被定义了约束，因此它不再是适用于任意类型：</p>
<pre><code>loggingIdentity(3);  // Error, number doesn't have a .length property</code></pre><p>我们需要传入符合约束类型的值，必须包含必须的属性：</p>
<pre><code>loggingIdentity({length: 10, value: 3});</code></pre><h4 id="在泛型约束中使用类型参数"><a href="#在泛型约束中使用类型参数" class="headerlink" title="在泛型约束中使用类型参数"></a>在泛型约束中使用类型参数</h4><p>你可以声明一个类型参数，且它被另一个类型参数所约束。 比如，现在我们想要用属性名从对象里获取这个属性。 并且我们想要确保这个属性存在于对象 obj上，因此我们需要在这两个类型之间使用约束。</p>
<pre><code>function getProperty(obj: T, key: K) {
    return obj[key];
}
let x = { a: 1, b: 2, c: 3, d: 4 };
getProperty(x, "a"); // okay
getProperty(x, "m"); // error: Argument of type 'm' isn't assignable to 'a' | 'b' | 'c' | 'd'.</code></pre><h2 id="认识Typescript-声明文件"><a href="#认识Typescript-声明文件" class="headerlink" title="认识Typescript-声明文件"></a>认识Typescript-声明文件</h2><p>当你在使用VS Code编写TypeScript文件时，你不太可能在每个文件上都标明<code>interface</code>字样的接口，一旦某个文件的方法或者变量比较多，你的代码可能就会被非常多的类型注解占据，在大型项目或者是你生成的库文件中为了保持代码的整洁，你就可能需要<strong>声明文件</strong>的帮助。</p>
<h3 id="创建一个声明文件"><a href="#创建一个声明文件" class="headerlink" title="创建一个声明文件"></a>创建一个声明文件</h3><hr>
<p>声明文件以<code>.d.ts</code>结尾，与TypeScript文件<code>.ts</code>稍有区别。当你的项目目录中出现了<code>.d.ts</code>结尾的文件时，所有与之关联的规则都会自动应用。声明文件支持我们前面介绍的各类语法，但是你得在语法前面加上<code>declare</code>。</p>
<h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h3><p><strong>文档</strong></p>
<blockquote>
<p>全局变量foo包含了存在组件总数。</p>
</blockquote>
<p><strong>代码</strong></p>
<pre><code>console.log("Half the number of widgets is " + (foo / 2));</code></pre><p><strong>声明</strong></p>
<p>使用declare var声明变量。 如果变量是只读的，那么可以使用 declare const。 你还可以使用 declare let如果变量拥有块级作用域。</p>
<pre><code>/** 组件总数 */
declare var foo: number;</code></pre><h3 id="全局函数"><a href="#全局函数" class="headerlink" title="全局函数"></a>全局函数</h3><p><strong>文档</strong></p>
<blockquote>
<p>用一个字符串参数调用greet函数向用户显示一条欢迎信息。</p>
</blockquote>
<p><strong>代码</strong></p>
<pre><code>greet("hello, world");</code></pre><p><strong>声明</strong></p>
<p>使用declare function声明函数。</p>
<pre><code>declare function greet(greeting: string): void;</code></pre><h3 id="带属性的对象"><a href="#带属性的对象" class="headerlink" title="带属性的对象"></a>带属性的对象</h3><p><strong>文档</strong></p>
<blockquote>
<p>全局变量myLib包含一个makeGreeting函数， 还有一个属性 numberOfGreetings指示目前为止欢迎数量。</p>
</blockquote>
<p><strong>代码</strong></p>
<pre><code>let result = myLib.makeGreeting("hello, world");
console.log("The computed greeting is:" + result);
let count = myLib.numberOfGreetings;</code></pre><p><strong>声明</strong></p>
<p>使用declare namespace描述用点表示法访问的类型或值。</p>
<pre><code>declare namespace myLib {
    function makeGreeting(s: string): string;
    let numberOfGreetings: number;
}</code></pre><h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><p><strong>文档</strong></p>
<p>getWidget函数接收一个数字，返回一个组件，或接收一个字符串并返回一个组件数组。</p>
<p><strong>代码</strong></p>
<pre><code>let x: Widget = getWidget(43);
let arr: Widget[] = getWidget("all of them");</code></pre><p><strong>声明</strong></p>
<pre><code>declare function getWidget(n: number): Widget;
declare function getWidget(s: string): Widget[];</code></pre><h3 id="可重用类型（接口）"><a href="#可重用类型（接口）" class="headerlink" title="可重用类型（接口）"></a>可重用类型（接口）</h3><p><strong>文档</strong></p>
<blockquote>
<p>当指定一个欢迎词时，你必须传入一个GreetingSettings对象。 这个对象具有以下几个属性：</p>
<p>1- greeting：必需的字符串</p>
<p>2- duration: 可选的时长（毫秒表示）</p>
<p>3- color: 可选字符串，比如‘#ff00ff’</p>
</blockquote>
<p><strong>代码</strong></p>
<pre><code>greet({
  greeting: "hello world",
  duration: 4000
});</code></pre><p><strong>声明</strong></p>
<p>使用interface定义一个带有属性的类型。</p>
<pre><code>interface GreetingSettings {
  greeting: string;
  duration?: number;
  color?: string;
}
declare function greet(setting: GreetingSettings): void;</code></pre><h3 id="可重用类型（类型别名）"><a href="#可重用类型（类型别名）" class="headerlink" title="可重用类型（类型别名）"></a>可重用类型（类型别名）</h3><p><strong>文档</strong></p>
<blockquote>
<p>在任何需要欢迎词的地方，你可以提供一个string，一个返回string的函数或一个Greeter实例。</p>
</blockquote>
<p><strong>代码</strong></p>
<pre><code>function getGreeting() {
    return "howdy";
}
class MyGreeter extends Greeter { }
greet("hello");
greet(getGreeting);
greet(new MyGreeter());</code></pre><p><strong>声明</strong></p>
<p>你可以使用类型别名来定义类型的短名：</p>
<pre><code>type GreetingLike = string | (() =&gt; string) | MyGreeter;
declare function greet(g: GreetingLike): void;</code></pre><h3 id="组织类型"><a href="#组织类型" class="headerlink" title="组织类型"></a>组织类型</h3><p><strong>文档</strong></p>
<blockquote>
<p>greeter对象能够记录到文件或显示一个警告。 你可以为 .log(…)提供LogOptions和为.alert(…)提供选项。</p>
</blockquote>
<p><strong>代码</strong></p>
<pre><code>const g = new Greeter("Hello");
g.log({ verbose: true });
g.alert({ modal: false, title: "Current Greeting" });</code></pre><p><strong>声明</strong></p>
<p>使用命名空间组织类型。</p>
<pre><code>declare namespace GreetingLib {
    interface LogOptions {
        verbose?: boolean;
    }
    interface AlertOptions {
        modal: boolean;
        title?: string;
        color?: string;
    }
}</code></pre><p>你也可以在一个声明中创建嵌套的命名空间：</p>
<pre><code>declare namespace GreetingLib.Options {
    // Refer to via GreetingLib.Options.Log
    interface Log {
        verbose?: boolean;
    }
    interface Alert {
        modal: boolean;
        title?: string;
        color?: string;
    }
}</code></pre><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p><strong>文档</strong></p>
<blockquote>
<p>你可以通过实例化Greeter对象来创建欢迎词，或者继承Greeter对象来自定义欢迎词。</p>
</blockquote>
<p><strong>代码</strong></p>
<pre><code>const myGreeter = new Greeter("hello, world");
myGreeter.greeting = "howdy";
myGreeter.showGreeting();
class SpecialGreeter extends Greeter {
    constructor() {
        super("Very special greetings");
    }
}</code></pre><p><strong>声明</strong></p>
<p>使用declare class描述一个类或像类一样的对象。 类可以有属性和方法，就和构造函数一样。</p>
<pre><code>declare class Greeter {
    constructor(greeting: string);
    greeting: string;
    showGreeting(): void;
}</code></pre><h1 id="插件-API"><a href="#插件-API" class="headerlink" title="插件 API"></a>插件 API</h1><p>VS Code内置了扩展能力，在插件API加持之下，VS Code几乎每一个部分都可以自定义或者加强。而且，VS Code中的很多核心功能已编译为<a href="https://github.com/Microsoft/vscode/tree/master/extensions" target="_blank" rel="noopener">插件</a>，它们都共用了一套插件API。</p>
<p>本文档将介绍：</p>
<ul>
<li>如何构建、运行、调试、测试和发布插件</li>
<li>如何利用好VS Code丰富的插件API</li>
<li>代码示例和各个指南的位置，方便你快速入门。如果你只是想看看已经发布的插件，可移步至<a href="https://marketplace.visualstudio.com/vscode" target="_blank" rel="noopener">VS Code插件市场</a></li>
</ul>
<h2 id="插件能做什么？"><a href="#插件能做什么？" class="headerlink" title="插件能做什么？"></a>插件能做什么？</h2><hr>
<p>下面我们看看使用插件API能做到些什么：</p>
<ul>
<li>改变VS Code的颜色和图标主题——主题</li>
<li>在UI中添加自定义组件和视图——扩展工作台</li>
<li>创建Webview，使用HTML/CSS/JS显示自定义网页——Webview指南</li>
<li>支持新的编程语言——语言插件概览</li>
<li>支持特定运行时的调试——调试插件指南</li>
</ul>
<p>如果你想大概浏览一下所有的插件API，请参阅插件功能概述。插件指南列出了各种插件API使用的示例代码和指南。</p>
<h2 id="如何构建插件？"><a href="#如何构建插件？" class="headerlink" title="如何构建插件？"></a>如何构建插件？</h2><hr>
<p>想要做出一个好插件需要花费不少精力，我们来看看这个教程的每个章节能为你做点什么：</p>
<ul>
<li><strong>第一步</strong> Hello World示例会教你贯穿于制作插件时的基本概念</li>
<li><strong>开发插件</strong> 包含了各类插件开发更深的主题，比如发布和测试插件</li>
<li><strong>插件功能</strong> 将VS Code庞杂的API拆解成了几个小分类，帮你掌握到每个主题下的开发细节</li>
<li><strong>插件指南</strong> 包括指南和代码实例，详细介绍特定API的使用场景</li>
<li><strong>语言插件</strong> 通过代码和指南阐述如何添加编程语言支持</li>
<li><strong>进阶主题</strong> 解释了插件主机和使用不稳定的API等更深层级的概念</li>
</ul>
<h2 id="寻求帮助"><a href="#寻求帮助" class="headerlink" title="寻求帮助"></a>寻求帮助</h2><hr>
<p>如果你在开发中遇到了问题，请尝试：</p>
<ul>
<li><a href="https://stackoverflow.com/questions/tagged/visual-studio-code" target="_blank" rel="noopener">Stack Overflow</a>：其中有将近<a href="https://stackoverflow.com/questions/tagged/visual-studio-code" target="_blank" rel="noopener">12k</a>个打了<code>visual-studio-code</code>标签的问题，而且半数以上都已经有了答案，搜索你遇到的问题，提问，或者帮助其他人解决VS Code中遇到的问题。</li>
<li><a href="https://gitter.im/Microsoft/vscode" target="_blank" rel="noopener">Gitter频道</a>和<a href="https://join.slack.com/t/vscode-dev-community/shared_invite/enQtMjIxOTgxNDE3NzM0LWU5M2ZiZDU1YjBlMzdlZjA2YjBjYzRhYTM5NTgzMTAxMjdiNWU0ZmQzYWI3MWU5N2Q1YjBiYmQ4MzY0NDE1MzY" target="_blank" rel="noopener">VS Code Dev Slack</a>：插件开发人员的公共聊天室，VS Code项目组成员偶尔也会出现。</li>
</ul>
<p>你若对本文档有任何建议，请在<a href="https://github.com/Microsoft/vscode-docs/issues" target="_blank" rel="noopener">Microsoft/vscode-docs</a>中创建issue。如果你的插件问题无法解决，或者对VS Code插件API有任何建议，请在<a href="https://github.com/Microsoft/vscode/issues" target="_blank" rel="noopener">Microsoft/vscode</a>中新建issue。</p>
<h1 id="第一步-1"><a href="#第一步-1" class="headerlink" title="第一步"></a>第一步</h1><h2 id="你的第一个插件"><a href="#你的第一个插件" class="headerlink" title="你的第一个插件"></a>你的第一个插件</h2><p>在本小节中，我们会教你一些基础概念，请先安装好<a href="https://nodejs.org/en/" target="_blank" rel="noopener">Node.js</a>和<a href="https://git-scm.com/" target="_blank" rel="noopener">Git</a>，然后安装<a href="http://yeoman.io/" target="_blank" rel="noopener">Yeoman</a>和<a href="https://www.npmjs.com/package/generator-code" target="_blank" rel="noopener">VS Code Extension Generator</a>：</p>
<pre><code>npm install -g yo generator-code</code></pre><p>这个脚手架会生成一个可以立马开发的项目。运行生成器，然后填好下列字段：</p>
<pre><code>yo code
# ? What type of extension do you want to create? New Extension (TypeScript)
# ? What's the name of your extension? HelloWorld
### Press &lt;Enter&gt; to choose default for all options below ###
# ? What's the identifier of your extension? helloworld
# ? What's the description of your extension? LEAVE BLANK
# ? Enable stricter TypeScript checking in 'tsconfig.json'? Yes
# ? Setup linting using 'tslint'? Yes
# ? Initialize a git repository? Yes
# ? Which package manager to use? npm
code ./helloworld</code></pre><p>完成后进入 VS Code，按下<code>F5</code>，你会立即看到一个<strong>插件发开主机</strong>窗口，其中就运行着插件。</p>
<p>在命令面板(<code>Ctrl+Shift+P</code>)中输入<code>Hello World</code>命令。</p>
<p>如果你看到了<code>Hello World</code>提示弹窗，恭喜你成功了！</p>
<h3 id="开发插件"><a href="#开发插件" class="headerlink" title="开发插件"></a>开发插件</h3><hr>
<p>现在让我们稍稍改动一下弹窗显示的内容：</p>
<ul>
<li>将项目文件<code>extension.ts</code>中的<code>Hello World</code>改为<code>Hello VS Code</code></li>
<li>重新加载开发窗口</li>
<li>再次运行<code>Hello World</code>命令</li>
</ul>
<p>请浏览你的项目目录和代码，然后进行下面的小练习：</p>
<ul>
<li>为命令面板中的<code>Hello World</code>换一个名字</li>
<li>配置一个新的命令：打开一个提示弹窗，显示当前时间</li>
<li>用显示警告信息的VS Code API替换原本的<code>vscode.window.showInformationMessage</code></li>
</ul>
<h3 id="调试插件"><a href="#调试插件" class="headerlink" title="调试插件"></a>调试插件</h3><hr>
<p>VS Code 内置的调试功能已经非常方便了，在代码序号的左侧空白处点击一下，VS Code 就会设下断点，进入调试模式后将鼠标悬停于变量上显示变量值，或是在调试侧边栏中检查变量值，此时，你还可以用<strong>调试控制台</strong>直接对表达式求值。</p>
<h2 id="解析插件结构"><a href="#解析插件结构" class="headerlink" title="解析插件结构"></a>解析插件结构</h2><p>上一节中，你已经能够自己创建一个基础的插件了，但是在面纱之下，它究竟是怎么运作的呢？</p>
<p><code>Hello World</code>插件包含了3个部分：</p>
<ul>
<li>注册<code>onCommand</code> <strong>激活事件</strong>: <code>onCommand:extension.helloWorld</code>，所以用户可以在输入<code>Hello World</code>命令后激活插件。</li>
<li>使用<code>contributes.commands</code> <strong>发布内容配置</strong>，绑定一个命令ID <code>extension.helloWorld</code>，然后 <code>Hello World</code>命令就可以在命令面板中使用了。</li>
<li>使用<code>commands.registerCommand</code> <strong>VS Code API</strong> 将一个函数绑定到你注册的命令ID<code>extension.helloWorld</code>上。</li>
</ul>
<p>理解下面三个关键概念你才能作出一个基本的插件：</p>
<ul>
<li><strong>激活事件</strong>: 插件激活的时机。</li>
<li><strong>发布内容配置</strong>: VS Code扩展了 <code>package.json</code> 插件清单的字段以便于开发插件。</li>
<li><strong>VS Code API</strong>: 你的插件代码中需要调用的一系列JavaScript API。</li>
</ul>
<p>大体上，你的插件就是通过组合发布内容配置和VS Code API扩展VS Code的功能。你能在插件功能概述主题中找到合适你插件的配置点和VS Code API。</p>
<p>好了，现在让我们自己瞧一瞧<code>Hello World</code>示例的源码部分，以及我们上面提到的3个概念是如何应用其中的。</p>
<h3 id="插件目录结构"><a href="#插件目录结构" class="headerlink" title="插件目录结构"></a>插件目录结构</h3><hr>
<pre><code>.
├── .vscode
│   ├── launch.json     // 插件加载和调试的配置
│   └── tasks.json      // 配置TypeScript编译任务
├── .gitignore          // 忽略构建输出和node_modules文件
├── README.md           // 一个友好的插件文档
├── src
│   └── extension.ts    // 插件源代码
├── package.json        // 插件配置清单
├── tsconfig.json       // TypeScript配置</code></pre><p>下面的几个文件超出了本节讨论的范围，你可以自行前往相应的章节挖掘详细内容：</p>
<ul>
<li><code>launch.json</code> 用于配置VS Code <a href="https://code.visualstudio.com/docs/editor/debugging" target="_blank" rel="noopener">调试</a></li>
<li><code>tasks.json</code> 用于定义VS Code <a href="https://code.visualstudio.com/docs/editor/tasks" target="_blank" rel="noopener">任务</a></li>
<li><code>tsconfig.json</code> 参阅TypeScript <a href="https://www.typescriptlang.org/docs/handbook/tsconfig-json.html" target="_blank" rel="noopener">Handbook</a></li>
</ul>
<p>现在，让我们把精力集中在这个插件的关键部分——<code>package.json</code>和<code>extensions.ts</code>。</p>
<h4 id="插件清单"><a href="#插件清单" class="headerlink" title="插件清单"></a>插件清单</h4><p>每个VS Code插件都必须包含一个<code>package.json</code>，它就是插件的配置清单。<code>package.json</code>混合了Node.js字段，如：<code>scripts</code>、<code>dependencies</code>，还加入了一些VS Code独有的字段，如：<code>publisher</code>、<code>activationEvents</code>、<code>contributes</code>等。关于这些VS Code字段说明都在插件清单参考中可以找到。我们在本节介绍一些非常重要的字段：</p>
<ul>
<li><code>name</code> 和 <code>publisher</code>: VS Code 使用<code>&lt;publisher&gt;.&lt;name&gt;</code>作为一个插件的ID。你可以这么理解，Hello World 例子的 ID 就是<code>vscode-samples.helloworld-sample</code>。VS Code 使用 ID 来区分各个不同的插件。</li>
<li><code>main</code>: 插件的主入口。</li>
<li><code>activationEvents</code> 和 <code>contributes</code>: 激活事件 and 发布内容配置。</li>
<li><code>engines.vscode</code>: 描述了这个插件依赖的最低VS Code API版本。</li>
<li><code>postinstall</code> 脚本: 如果你的<code>engines.vscode</code>声明的是1.25版的VS Code API，那它就会按照这个声明去安装目标版本。一旦<code>vscode.d.ts</code>文件存在于<code>node_modules/vscode/vscode.d.ts</code>，IntelliSense就会开始运作，你就可以对所有VS Code API进行定义跳转或者语法检查了。</li>
</ul>
<pre><code>{
    "name": "helloworld-sample",
    "displayName": "helloworld-sample",
    "description": "HelloWorld example for VS Code",
    "version": "0.0.1",
    "publisher": "vscode-samples",
    "repository": "https://github.com/Microsoft/vscode-extension-samples/helloworld-sample",
    "engines": {
        "vscode": "^1.25.0"
    },
    "categories": ["Other"],
    "activationEvents": ["onCommand:extension.helloWorld"],
    "main": "./out/extension.js",
    "contributes": {
        "commands": [
            {
                "command": "extension.helloWorld",
                "title": "Hello World"
            }
        ]
    },
    "scripts": {
        "vscode:prepublish": "npm run compile",
        "compile": "tsc -p ./",
        "watch": "tsc -watch -p ./",
        "postinstall": "node ./node_modules/vscode/bin/install"
    },
    "devDependencies": {
        "@types/node": "^8.10.25",
        "tslint": "^5.11.0",
        "typescript": "^2.6.1",
        "vscode": "^1.1.22"
    }
}</code></pre><h3 id="插件入口文件"><a href="#插件入口文件" class="headerlink" title="插件入口文件"></a>插件入口文件</h3><hr>
<p>插件入口文件会导出两个函数，<code>activate</code> 和 <code>deactivate</code>，你注册的<strong>激活事件</strong>被触发之时执行<code>activate</code>，<code>deactivate</code>则提供了插件关闭前执行清理工作的机会。</p>
<p><a href="https://www.npmjs.com/package/vscode" target="_blank" rel="noopener"><code>vscode</code></a>模块包含了一个位于<code>node ./node_modules/vscode/bin/install</code>的脚本，这个脚本会拉取<code>package.json</code>中<code>engines.vscode</code>字段定义的VS Code API。这个脚本执行过后，你就得到了智能代码提示，定义跳转等TS特性了。</p>
<pre><code>// 'vscode'模块包含了VS Code extensibility API
// 按下述方式导入这个模块
import * as vscode from 'vscode';
// 一旦你的插件激活，vscode会立刻调用下述方法
export function activate(context: vscode.ExtensionContext) {
    // 用console输出诊断信息(console.log)和错误(console.error)
    // 下面的代码只会在你的插件激活时执行一次
    console.log('Congratulations, your extension "my-first-extension" is now active!');
    // 入口命令已经在package.json文件中定义好了，现在调用registerCommand方法
    // registerCommand中的参数必须与package.json中的command保持一致
    let disposable = vscode.commands.registerCommand('extension.sayHello', () =&gt; {
        // 把你的代码写在这里，每次命令执行时都会调用这里的代码
        // ...
        // 给用户显示一个消息提示
        vscode.window.showInformationMessage('Hello World!');
    });
    context.subscriptions.push(disposable);
}</code></pre><h1 id="开发插件-1"><a href="#开发插件-1" class="headerlink" title="开发插件"></a>开发插件</h1><h2 id="测试插件"><a href="#测试插件" class="headerlink" title="测试插件"></a>测试插件</h2><p>VS Code 为你的插件提供了运行和调试的能力。测试会运行在一个特殊的 VS Code 实例中——<code>扩展开发环境</code>，这个特殊实例拥有访问 VS Code API 的全部权限。本篇侧重于 VS Code 的集成测试，至于单元测试，你可以使用任何流行的测试框架，如<a href="https://mochajs.org/" target="_blank" rel="noopener">Mocha</a>或者<a href="https://jasmine.github.io/" target="_blank" rel="noopener">Jasmine</a>。</p>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><hr>
<p><em>如果你原本使用<code>vscode</code>库进行测试，可以参考从<code>vscode</code>迁移部分</em></p>
<p>如果你正在使用<a href="https://github.com/Microsoft/vscode-generator-code" target="_blank" rel="noopener">yo code 生成器</a>，那么生成的项目中应该已经包含了一些测试示例和指引。</p>
<p>使用<code>npm run test</code>或者<code>yarn test</code>启动集成测试，测试工程随后会：</p>
<ul>
<li>下载并解压最新的 VS Code 版本</li>
<li>运行插件的<strong>测试脚本</strong>中所规定的<a href="https://mochajs.org/" target="_blank" rel="noopener">Mocha</a>测试</li>
</ul>
<p>你可以在<a href="https://github.com/microsoft/vscode-extension-samples/tree/master/helloworld-test-sample" target="_blank" rel="noopener">helloworld-test-sample</a>中找到本篇示例，本篇剩余部分将解释例子中的如下部分：</p>
<ul>
<li>测试入口（<a href="https://github.com/microsoft/vscode-extension-samples/blob/master/helloworld-test-sample/src/test/runTest.ts" target="_blank" rel="noopener">src/test/runTest.ts</a>）</li>
<li>测试脚本(<a href="https://github.com/microsoft/vscode-extension-samples/blob/master/helloworld-test-sample/src/test/suite/index.ts" target="_blank" rel="noopener">src/test/suite/index.ts</a>)</li>
</ul>
<h3 id="测试入口"><a href="#测试入口" class="headerlink" title="测试入口"></a>测试入口</h3><hr>
<p>VS Code 提供了 2 个 CLI 参数来运行插件测试——<code>--extensionDevelopmentPath</code>和<code>--extensionTestsPath</code>。</p>
<p>例如：</p>
<pre><code># - Launches VS Code Extension Host
# - Loads the extension at &lt;EXTENSION-ROOT-PATH&gt;
# - Executes the test runner script at &lt;TEST-RUNNER-SCRIPT-PATH&gt;
code \
--extensionDevelopmentPath=&lt;EXTENSION-ROOT-PATH&gt; \
--extensionTestsPath=&lt;TEST-RUNNER-SCRIPT-PATH&gt;</code></pre><p><strong>测试入口</strong>（<a href="https://github.com/microsoft/vscode-extension-samples/blob/master/helloworld-test-sample/src/test/runTest.ts" target="_blank" rel="noopener">src/test/runTest.ts</a>））使用了<code>vscode-test</code>API，简化了下载、解压、启动 VS Code 的测试流程：</p>
<pre><code>import*as path from"path";
import{ runTests }from"vscode-test";
async function main(){
try{
// The folder containing the Extension Manifest package.json
// Passed to `--extensionDevelopmentPath`
const extensionDevelopmentPath = path.resolve(__dirname,"../../");
// The path to the extension test runner script
// Passed to --extensionTestsPath
const extensionTestsPath = path.resolve(__dirname,"./suite/index");
// Download VS Code, unzip it and run the integration test
    await runTests({ extensionDevelopmentPath, extensionTestsPath });
}catch(err){
    console.error("Failed to run tests");
    process.exit(1);
}
}
main();</code></pre><p><code>vscode-test</code>还支持：</p>
<ul>
<li>启动 VS Code 时打开指定工作区</li>
<li>下载不同版本的 VS Code</li>
<li>使用其他 CLI 参数启动</li>
</ul>
<p>你可以在<a href="https://github.com/microsoft/vscode-test" target="_blank" rel="noopener">microsoft/vscode-test</a>中找到更多用法。</p>
<h3 id="测试脚本"><a href="#测试脚本" class="headerlink" title="测试脚本"></a>测试脚本</h3><hr>
<p>当你运行插件的集成测试时，<code>--extensionTestsPath</code>会指向<strong>测试脚本</strong>(<a href="https://github.com/microsoft/vscode-extension-samples/blob/master/helloworld-test-sample/src/test/suite/index.ts" target="_blank" rel="noopener">src/test/suite/index.ts</a>)，然后这个脚本会进一步运行测试套件。下面是<code>helloworld-test-sample</code>中的<a href="https://github.com/microsoft/vscode-extension-samples/blob/master/helloworld-test-sample/src/test/suite/index.ts" target="_blank" rel="noopener">测试脚本</a>，它使用了 Mocha 运行测试套件。你可以把这个文件视为测试的起点，你可以用<a href="https://mochajs.org/api/mocha" target="_blank" rel="noopener">Mocha 的 API</a>自定义启动时的配置，你也可以用其他任意喜欢的测试框架替代 Mocha。</p>
<pre><code>import*as path from"path";
import*asMochafrom"mocha";
import*as glob from"glob";
exportfunction run():Promise&lt;void&gt;{
// Create the mocha test
const mocha =newMocha({
    ui:"tdd"
});
  mocha.useColors(true);
const testsRoot = path.resolve(__dirname,"..");
returnnewPromise((c, e)=&gt;{
    glob("**/**.test.js",{ cwd: testsRoot },(err, files)=&gt;{
if(err){
return e(err);
}
// Add files to the test suite
      files.forEach(f =&gt; mocha.addFile(path.resolve(testsRoot, f)));
try{
// Run the mocha test
        mocha.run(failures =&gt;{
if(failures &gt;0){
            e(newError(`${failures} tests failed.`));
}else{
            c();
}
});
}catch(err){
        e(err);
}
});
});
}</code></pre><p>所有测试脚本和<code>*.test.js</code>文件都有访问 VS Code API 的权限。 看看这个例子(<a href="https://github.com/microsoft/vscode-extension-samples/blob/master/helloworld-test-sample/src/test/suite/extension.test.ts" target="_blank" rel="noopener">src/test/suite/extension.test.ts</a>)</p>
<pre><code>import*asassertfrom"assert";
import{ after }from"mocha";
// You can import and use all API from the 'vscode' module
// as well as import your extension to test it
import*as vscode from"vscode";
// import * as myExtension from '../extension';
suite("Extension Test Suite",()=&gt;{
  after(()=&gt;{
    vscode.window.showInformationMessage("All tests done!");
});
  test("Sample test",()=&gt;{
assert.equal(-1,[1,2,3].indexOf(5));
assert.equal(-1,[1,2,3].indexOf(0));
});
});</code></pre><h3 id="调试测试文件"><a href="#调试测试文件" class="headerlink" title="调试测试文件"></a>调试测试文件</h3><hr>
<p>调试测试文件和调试插件是一样的，我们看一个<code>launch.json</code>调试器配置的例子：</p>
<pre><code>{
"version":"0.2.0",
"configurations":[
{
"name":"Extension Tests",
"type":"extensionHost",
"request":"launch",
"runtimeExecutable":"${execPath}",
"args":[
"--extensionDevelopmentPath=${workspaceFolder}",
"--extensionTestsPath=${workspaceFolder}/out/test/suite/index"
],
"outFiles":["${workspaceFolder}/out/test/**/*.js"]
}
]
}</code></pre><h3 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h3><hr>
<h4 id="使用-Insider-版本开发插件"><a href="#使用-Insider-版本开发插件" class="headerlink" title="使用 Insider 版本开发插件"></a>使用 Insider 版本开发插件</h4><p>由于 VS Code 的限制，如果你使用 VS Code 稳定版来运行集成测试，它会报错：</p>
<pre><code>Running extension tests from the command line is currently only supported ifno other instance of Codeis running.</code></pre><p>所以推荐你使用<a href="https://code.visualstudio.com/insiders/" target="_blank" rel="noopener">VS Code Insiders</a>测试插件。</p>
<h4 id="调试时禁用其他插件"><a href="#调试时禁用其他插件" class="headerlink" title="调试时禁用其他插件"></a>调试时禁用其他插件</h4><p>当你在 VS Code 中对测试进行调试时，VS Code 使用的是全局安装的 VS Code 实例，它会加载所有插件。你可以在<code>launch.json</code>中添加<code>--disable-extensions</code>或者在<code>runTests</code>的<code>launchArgs</code>选项中添加该项以禁用其他插件。</p>
<pre><code>{
"version":"0.2.0",
"configurations":[
{
"name":"Extension Tests",
"type":"extensionHost",
"request":"launch",
"runtimeExecutable":"${execPath}",
"args":[
"--disable-extensions",
"--extensionDevelopmentPath=${workspaceFolder}",
"--extensionTestsPath=${workspaceFolder}/out/test/suite/index"
],
"outFiles":["${workspaceFolder}/out/test/**/*.js"]
}
]
}</code></pre><h4 id="使用vscode-test自定义配置"><a href="#使用vscode-test自定义配置" class="headerlink" title="使用vscode-test自定义配置"></a>使用<code>vscode-test</code>自定义配置</h4><p>你可能会需要自定义一些启动配置，比如启动测试前执行<code>code --install-extension</code>安装一些其他插件这样的场景。<code>vscode-test</code>提供粒度更细的 API 来操作这样的场景：</p>
<pre><code>await runTests({
  extensionDevelopmentPath,
  extensionTestsPath,
/**
   * A list of launch arguments passed to VS Code executable, in addition to `--extensionDevelopmentPath`
   * and `--extensionTestsPath` which are provided by `extensionDevelopmentPath` and `extensionTestsPath`
   * options.
   *
   * If the first argument is a path to a file/folder/workspace, the launched VS Code instance
   * will open it.
   *
   * See `code --help` for possible arguments.
   */
  launchArgs:["--disable-extensions"]
});</code></pre><h4 id="从-vscode-迁移"><a href="#从-vscode-迁移" class="headerlink" title="从 vscode 迁移"></a>从 vscode 迁移</h4><p><code>vscode</code>中的集成测试模块已迁移到<code>vscode-test</code>，你可以按下面的步骤进行迁移：</p>
<ul>
<li>移除<code>vscode</code>依赖</li>
<li>添加<code>vscode-test</code>依赖</li>
<li>由于旧的<code>vscode</code>模块会下载 VS Code 类型定义，所以你需要<ul>
<li>手动安装<code>@types/vscode</code>，这个版本需和你<code>package.json</code>的<code>engine.vscode</code>版本一致，比如你的<code>engine.vscode</code>版本是<code>1.30</code>，那么就安装<code>@types/vscode@1.30</code></li>
<li>删除<code>package.json</code>中的<code>"postinstall": "node ./node_modules/vscode/bin/install"</code></li>
</ul>
</li>
<li>添加一个测试入口，你可以像我们的示例一样，用<code>runTest.ts</code>作为入口。</li>
<li>指定<code>package.json</code>中的<code>test</code>脚本，运行编译后的<code>runTest.ts</code>。</li>
<li>添加一个测试脚本，你可以用<a href="https://github.com/microsoft/vscode-extension-samples/blob/master/helloworld-test-sample/src/test/suite/index.ts" target="_blank" rel="noopener">sample test runner script</a>作为入口。注意<code>vscode</code>过去依赖<code>mocha@4</code>和<code>glob</code>，现在你需要自己安装到<code>devDependency</code>里去。</li>
</ul>
<h2 id="发布插件"><a href="#发布插件" class="headerlink" title="发布插件"></a>发布插件</h2><h3 id="vsce-——-发布工具参阅"><a href="#vsce-——-发布工具参阅" class="headerlink" title="vsce —— 发布工具参阅"></a>vsce —— 发布工具参阅</h3><p><a href="https://github.com/Microsoft/vsce" target="_blank" rel="noopener">vsce</a>是一个用于将插件发布到<a href="https://code.visualstudio.com/docs/editor/extension-gallery" target="_blank" rel="noopener">市场</a>上的命令行工具。</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><hr>
<p>请确认本机已经安装了<a href="https://nodejs.org/" target="_blank" rel="noopener">Node.js</a>，然后运行：</p>
<pre><code>npm install -g vsce</code></pre><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><hr>
<p>然后你就可以在命令行里直接使用<code>vsce</code>了。下面是一个快速发布的示例（在你登录和打包好插件之后）:</p>
<pre><code>$ vsce publish
Publishing uuid@0.0.1...
Successfully published uuid@0.0.1!</code></pre><p>更多可用的命令参数，请使用<code>vsce --help</code></p>
<h3 id="发布教程"><a href="#发布教程" class="headerlink" title="发布教程"></a>发布教程</h3><hr>
<p>!&gt; <strong>注意：</strong> 出于安全考虑，<code>vsce</code>不会发布包含用户提供 SVG 图片的插件。</p>
<p>发布工具会检查以下内容：</p>
<ul>
<li><code>pacakge.json</code>文件中的 icon 不可以是 SVG。</li>
<li><code>pacakge.json</code>中的徽章不可以是 SVG，除非来自于可靠的图标来源</li>
<li><code>README.md</code>和<code>CHANGELOG.md</code>中的图片链接需要使用<code>https</code>协议</li>
<li><code>README.md</code>和<code>CHANGELOG.md</code>中的图片不可以是 SVG，除非来自可靠的图标来源</li>
</ul>
<hr>
<p>VS Code 插件市场的服务是<a href="https://visualstudio.microsoft.com/team-services" target="_blank" rel="noopener">Visual Studio Team Services</a>提供的，因此验证、代理、管理插件都是由这个服务提供的。</p>
<p><code>vsce</code>只能用<a href="https://docs.microsoft.com/vsts/integrate/get-started/authentication/pats" target="_blank" rel="noopener">Personal Access Tokens</a>发布插件，所以至少要创建一个 Token 以便发布插件。</p>
<h4 id="获取-Personal-Access-Token"><a href="#获取-Personal-Access-Token" class="headerlink" title="获取 Personal Access Token"></a>获取 Personal Access Token</h4><p>首先，你得有一个<a href="https://docs.microsoft.com/azure/devops/organizations/accounts/create-organization-msa-or-work-student" target="_blank" rel="noopener">Azure DevOps 组织</a>。</p>
<p>下面的例子里，我们假设组织名为<code>vscode</code>，从你的组织主页（例如：<code>https://dev.azure.com/vscode</code> ）进入<strong>安全（Security）</strong>页面：</p>
<p><img src="/images/loading.gif" data-original="../images/development/855dd98a1f1058f9e3ca0b838cd98381.png" alt=""></p>
<p>选择 Personal Access Token，点击<strong>New Token</strong>创建一个新的 Personal Access Token</p>
<p><img src="/images/loading.gif" data-original="../images/development/a41340c10ea46a9762691fca55215117.png" alt=""></p>
<p>给 Personal Access Token 添加描述，过期时间等等，你最好把过期时间设置为 1 年，这样你接下就能方便很多，选择<strong>custom defined（用户自定义）</strong>范围，然后点击<strong>Show all scopes(显示全部)</strong></p>
<p><img src="/images/loading.gif" data-original="../images/development/d8ef65068357c95e06ae7c2ab54da95b.png" alt=""></p>
<p>最后，在这个列表中找到<strong>Marketplace</strong>，并勾选<strong>Acquire</strong>和<strong>Manage</strong></p>
<p><img src="/images/loading.gif" data-original="../images/development/c90dfa5bd63a7eba98997629e3f0f9c0.png" alt=""></p>
<p>点击<strong>Create</strong>，你就会看到新创建的 Personal Access Token 了，复制好，你接下来就会用到这个 token 来创建一个<em>发行方</em>了。</p>
<h4 id="创建一个发行方"><a href="#创建一个发行方" class="headerlink" title="创建一个发行方"></a>创建一个发行方</h4><p><strong>发行方</strong>是 VS Code 市场有权发布插件的唯一标识，每个插件的package.json文件都包含着<code>publisher</code>字段。</p>
<p>现在我们已经有了Personal Access Token，我们马上可以用<code>vsce</code>创建一个发行方：</p>
<pre><code>vsce create-publisher (publisher name)</code></pre><p><code>vsce</code>会记住这个 Personal Access Token，日后你需要再次使用的时候会自动带上。</p>
<p>?&gt; 注意：另外，你也可以在市场的发行方<a href="https://marketplace.visualstudio.com/manage" target="_blank" rel="noopener">管理页</a>中创建发行方，然后用这个账号登录<code>vsce</code>。</p>
<h4 id="发行方登录"><a href="#发行方登录" class="headerlink" title="发行方登录"></a>发行方登录</h4><p>如果你已经有发行方账号了：</p>
<pre><code>vsce login (publisher name)</code></pre><p>和<code>create-publisher</code>命令类似地，<code>vsce</code>会要求输入你的 Personal Access Token。</p>
<p>你也可以用命令参数<code>-p &lt;token&gt;</code>直接登录然后立即发布插件：</p>
<pre><code>vsce publish -p &lt;token&gt;</code></pre><h4 id="增量更新插件版本"><a href="#增量更新插件版本" class="headerlink" title="增量更新插件版本"></a>增量更新插件版本</h4><p>用 SemVer 语义标识符：<code>major</code>，<code>minor</code>，<code>patch</code>增量更新插件版本号。</p>
<p>例如，你想把插件从 1.0.0 更新到 1.1.0，那么加上<code>minor</code>：</p>
<pre><code>vsce publish minor</code></pre><p>插件<code>package.json</code>的 version 会先更新，然后才发布插件。</p>
<p>你也可以通过命令行指定版本号：</p>
<pre><code>vsce publish 2.0.1</code></pre><h4 id="下架插件"><a href="#下架插件" class="headerlink" title="下架插件"></a>下架插件</h4><p>通过指定插件 id<code>publisher.extension</code>下架插件：</p>
<pre><code>vsce unpublish (publisher name).(extension name)</code></pre><p>!&gt; <strong>注意：</strong>当你下架插件的时候，市场会移除所有插件的历史统计数据，请在下架前再三考虑，最好还是更新插件吧。</p>
<h4 id="插件打包"><a href="#插件打包" class="headerlink" title="插件打包"></a>插件打包</h4><p>你也可能只是想打包一下插件，而不是发布到商店里。用下列命令将插件打包到<code>.vsix</code>文件中：</p>
<pre><code>vsce package</code></pre><p>这个命令会在当前目录生成一个<code>.vsix</code>文件，直接从<code>.vsix</code>安装插件是允许的，查看<a href="https://github.com/Microsoft/vscode-docs/blob/master/docs/editor/extension-gallery.md#install-from-a-vsix" target="_blank" rel="noopener">从 VSIX 安装插件</a>了解更多内容。</p>
<h4 id="VS-Code-版本兼容性"><a href="#VS-Code-版本兼容性" class="headerlink" title="VS Code 版本兼容性"></a>VS Code 版本兼容性</h4><p>当你制作插件的时候，你需要描述插件对 VS Code 的版本兼容性——修改<code>package.json</code>中的<code>engines.vscode</code>：</p>
<pre><code>{
  "engines": {
    "vscode": "^1.8.0"
  }
}</code></pre><p><code>1.8.0</code>表示你的插件只能兼容<code>1.8.0</code>版本的 VS Code，<code>^1.8.0</code>则表示你的插件向上兼容，包括<code>1.8.1, 1.9.0</code>等等。</p>
<p>使用<code>engines.vscode</code>可以确保插件安装环境包含了插件依赖的 API。这个机制在稳定版和 Insider 版本都适用。</p>
<p>现在我们假设最新的稳定版 API 是<code>1.8.0</code>，而<code>1.9.0</code>引入了新的 API，所以你可以用<code>1.9.0-insider</code>标识插件在 Insider 版中也可正常使用。 如果你想使用这些刚刚引入的 API，则将依赖版本设置为<code>^1.9.0</code>，你的插件则只能安装在<code>&gt;=1.9.0</code>的 VS Code 上，也就意味着所有当前的 Insider 版本都可以用得上，而稳定版只有在更新到<code>1.9.0</code>才能使用你的插件。</p>
<h3 id="进阶用法"><a href="#进阶用法" class="headerlink" title="进阶用法"></a>进阶用法</h3><hr>
<h4 id="符合市场的插件"><a href="#符合市场的插件" class="headerlink" title="符合市场的插件"></a>符合市场的插件</h4><p>你可以自定义插件在市场中的外观，查看示例<a href="https://marketplace.visualstudio.com/items/ms-vscode.Go" target="_blank" rel="noopener">GO 插件</a>。</p>
<p>下面是一些让你的插件在市场看起来更酷的小提示：</p>
<ul>
<li><p>插件根目录下面的</p>
<pre><code>README.md</code></pre><p>文件可以用来填充插件市场的页面内容。</p>
<pre><code>vsce</code></pre><p>会将 README 中的链接通过下面两种方式修改掉：</p>
<ul>
<li>如果你的<code>package.json</code>的<code>repository</code>字段是一个 Github 仓库，<code>vsce</code>会自动检测，然后相应地调整链接。</li>
<li>运行<code>vsce package</code>时，加上<code>--baseContentUrl</code>和<code>--baseImagesUrl</code>标识重载上述行为。</li>
</ul>
</li>
<li><p>插件根目录下的<code>LICENSE</code>会成为插件的 license。</p>
</li>
<li><p>同样的<code>CHANGELOG.md</code>文件会成为插件的发布日志。</p>
</li>
<li><p>通过设置<code>package.json</code>的<code>galleryBanner.color</code>hex 值，修改 banner 的背景色。</p>
</li>
<li><p>通过给<code>package.json</code>中的<code>icon</code>设置一个相对路径，可以将一个<code>128px</code>的 PNG 图标放进你的插件中。</p>
</li>
<li><p>参见<a href="https://github.com/Microsoft/vscode-docs/blob/master/docs/extensionAPI/extension-manifest.md#marketplace-presentation-tips" target="_blank" rel="noopener">插件市场展现小提示</a></p>
</li>
</ul>
<h4 id="vscodeignore"><a href="#vscodeignore" class="headerlink" title=".vscodeignore"></a><code>.vscodeignore</code></h4><p>创建一个<code>.vscodeignore</code>文件可以排除插件目录中的内容。这个文件支持<a href="https://github.com/isaacs/minimatch" target="_blank" rel="noopener">glob</a>模式，每个表达式一行。</p>
<p>例如：</p>
<pre><code>**/*.ts
**/tsconfig.json
!file.ts</code></pre><p>你应该忽略哪些不必在运行时用到的文件。例如：你的插件是用 Typescript 写的，那么你就应该忽略所有的<code>**/*.ts</code>文件。</p>
<p>?&gt; <strong>注意：</strong>在<code>devDependencies</code>列出的开发依赖会被自动忽略，你不必将他们加入到<code>.vscodeignore</code>中。</p>
<h5 id="预发布步骤"><a href="#预发布步骤" class="headerlink" title="预发布步骤"></a>预发布步骤</h5><p>你是可以在清单文件中添加预发布步骤的，下面的命令会在插件每次打包时执行：</p>
<pre><code>{
  "name": "uuid",
  "version": "0.0.1",
  "publisher": "joaomoreno",
  "engines": {
    "vscode": "0.10.x"
  },
  "scripts": {
    "vscode:prepublish": "tsc"
  }
}</code></pre><p>上面的示例会在每次插件打包时调用 Typescript 编译器。</p>
<h3 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h3><h5 id="问：当我发布插件时遇到了-403-Forbidden（或-401-Unauthorized）错误？"><a href="#问：当我发布插件时遇到了-403-Forbidden（或-401-Unauthorized）错误？" class="headerlink" title="问：当我发布插件时遇到了 403 Forbidden（或 401 Unauthorized）错误？"></a>问：当我发布插件时遇到了 403 Forbidden（或 401 Unauthorized）错误？</h5><p>答：很有可能是你创建 PAT (Personal Access Token) 时没有选择<code>all accessible accounts</code>。你还需要将授权范围设置为<code>All scopes</code>，这样发布工具才能工作。</p>
<h5 id="问：我没办法用vsce工具下架插件？"><a href="#问：我没办法用vsce工具下架插件？" class="headerlink" title="问：我没办法用vsce工具下架插件？"></a>问：我没办法用<code>vsce</code>工具下架插件？</h5><p>答：你可能改变了插件 ID 或者发行方名称。不过你还可以在<a href="https://marketplace.visualstudio.com/manage" target="_blank" rel="noopener">管理页面</a>发布或者下架插件。</p>
<h5 id="问：为什么-vsce-不保留文件属性？"><a href="#问：为什么-vsce-不保留文件属性？" class="headerlink" title="问：为什么 vsce 不保留文件属性？"></a>问：为什么 vsce 不保留文件属性？</h5><p>答：请注意，当你在 Windows 平台构建和发布插件的时候，所有插件包内的文件会丢失 POSIX 文件属性，或称之为执行位（executable bit）的东西。一些基于这些属性的<code>node_modules</code>依赖则会调整工作方式。从 Linux 和 macOS 平台构建则会如预期执行。</p>
<h2 id="打包插件"><a href="#打包插件" class="headerlink" title="打包插件"></a>打包插件</h2><p>VS Code 插件体积常常随着更新越来越大，它会产生很多文件，而且还依赖各种<a href="https://www.npmjs.com/" target="_blank" rel="noopener">npm</a>包。 程序开发的最佳实践是抽象和重用，但过度拆分和庞大的代码结构产生的代价就是更大的插件体积和更慢的运行效率。加载 100 个小文件远比加载一个大文件来的慢，这就是我们更推荐打包插件的原因。 <em>打包</em>是将多个小的源文件打包成单个入口文件的过程。</p>
<p>对于 Javascript 而言，可选的构建工具非常多，比较流行的如<a href="https://rollupjs.org/" target="_blank" rel="noopener">rollup.js</a>，<a href="https://parceljs.org/" target="_blank" rel="noopener">parcel</a>和<a href="https://webpack.js.org/" target="_blank" rel="noopener">webpack</a>。大部分构建工具的概念和功能都是相似的，本节主要使用<strong>webpack</strong>打包。</p>
<h3 id="使用-webpack"><a href="#使用-webpack" class="headerlink" title="使用 webpack"></a>使用 webpack</h3><hr>
<p>webpack 这个开发工具可以在<a href="https://www.npmjs.com/" target="_blank" rel="noopener">npm</a>里找到，为了获取 webpack 和它的命令行界面，打开终端然后输入：</p>
<pre><code>npm i --save-dev webpack webpack-cli</code></pre><p>这行命令会先安装 webpack，然后更新你插件里的<code>package.json</code>中的<code>devDependencies</code>字段。Webpack 是一个 Javascrip 打包工具，但是大部分 VS Code 插件是用 Typescript 写的，所以你需要在 webpack 中配置<code>ts-loader</code>，它才能正确编译 Typescript。安装<code>ts-loader</code>：</p>
<pre><code>npm i --save-dev ts-loader</code></pre><h3 id="配置-webpack"><a href="#配置-webpack" class="headerlink" title="配置 webpack"></a>配置 webpack</h3><hr>
<p>既然所有的工具都安装好了，我们现在可以开始配置 webpack 了。通常来说，你的项目目录中需要创建一个<code>webpack.config.js</code>文件，webpack 才能知道按什么规则打包你的插件。下面的配置示例是 VS Code 插件专用的，让我们来开这个头吧：</p>
<pre><code>/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
//@ts-check
"use strict";
const path = require("path");
/**@type {import('webpack').Configuration}*/
const config = {
  target: "node", // vscode插件运行在Node.js环境中 📖 -&gt; https://webpack.js.org/configuration/node/
  entry: "./src/extension.ts", // 插件的入口文件 📖 -&gt; https://webpack.js.org/configuration/entry-context/
  output: {
    // 打包好的文件储存在'dist'文件夹中 (请参考package.json), 📖 -&gt; https://webpack.js.org/configuration/output/
    path: path.resolve(__dirname, "dist"),
    filename: "extension.js",
    libraryTarget: "commonjs2",
    devtoolModuleFilenameTemplate: "../[resource-path]"
  },
  devtool: "source-map",
  externals: {
    vscode: "commonjs vscode" // vscode-module是热更新的临时目录，所以要排除掉。 在这里添加其他不应该被webpack打包的文件, 📖 -&gt; https://webpack.js.org/configuration/externals/
  },
  resolve: {
    // 支持读取TypeScript和JavaScript文件, 📖 -&gt; https://github.com/TypeStrong/ts-loader
    extensions: [".ts", ".js"]
  },
  module: {
    rules: [
      {
        test: /\.ts$/,
        exclude: /node_modules/,
        use: [
          {
            loader: "ts-loader"
          }
        ]
      }
    ]
  }
};
module.exports = config;</code></pre><p>这份文件是<a href="https://github.com/Microsoft/vscode-extension-samples/blob/master/webpack-sample" target="_blank" rel="noopener">webpack-extension</a>中的<a href="https://github.com/Microsoft/vscode-extension-samples/blob/master/webpack-sample/webpack.config.js" target="_blank" rel="noopener">一部分</a>。webpack 配置最后输出的就是 JS 对象。</p>
<p>在上面的例子里，我们定义了如下内容：</p>
<ul>
<li><code>traget</code>：’node’，因为我们的插件运行在 Node.js 环境中。</li>
<li><code>entry</code>：webpack 使用的入口文件。这就像是<code>package.json</code>中的<code>main</code>属性，有点不一样的是你还需要给 webpack 提供”source”—— 一般就是<code>src/extension.ts</code>，小心不要配置在”output”里了。webpack 可以解析 Typescript，所以我们不需要再单独执行 Typescript 编译了。</li>
<li><code>output</code>配置告诉 webpack 应该把打包好的文件放在哪里，一般而言我们会放在<code>dist</code>文件夹里。在这个例子里，webpack 最后会产生一个<code>dist/extension.js</code>文件。</li>
<li>在<code>resolve</code>和<code>module/rules</code>中配置 Typescript 和 Javascript 的解析器。</li>
<li><code>externals</code>即排除配置，在这里可以配置打包文件不应包含的文件和模块。<code>vscode</code>不需要被打包是因为它并不储存在磁盘上，它是 VS Code 热更新生成的临时文件夹。根据插件依赖的具体 node 模块，你可能需要通过这个配置优化打包文件。</li>
</ul>
<h3 id="运行-webpack"><a href="#运行-webpack" class="headerlink" title="运行 webpack"></a>运行 webpack</h3><hr>
<p><code>webpack.config.js</code>文件创建好之后，webpack 就可以正式开始工作了。你可以从命令行中运行 webpack，不过为了避免重复工作用 npm script 会更有效率。</p>
<p>将下列脚本复制到<code>package.json</code>的<code>scripts</code>中去：</p>
<pre><code>"scripts": {
  "vscode:prepublish": "webpack --mode production",
  "compile": "webpack --mode none",
  "watch": "webpack --mode none --watch",
},</code></pre><p><code>compile</code>和<code>watch</code>脚本是开发时使用的，它们会产生构建文件。<code>vscode:prepublish</code>是<code>vsce</code>使用的，<code>vsce</code>是 VS Code 的打包和发布工具，你需要在发布插件之前运行这个命令。webpack 中的<a href="https://webpack.js.org/concepts/mode/" target="_blank" rel="noopener">mode</a>是控制优化级别的配置项，如果你使用<code>production</code>字段，那么就会打包出最小的构建文件，但是也会耗费更多时间，所以我们开发中使用<code>none</code>。想要运行上述脚本，我们可以打开终端（命令行）输入<code>npm run compile</code>或者从<em>命令面板</em>（Ctrl+Shift+P）中使用<strong>运行任务</strong>来开始。</p>
<h3 id="运行插件"><a href="#运行插件" class="headerlink" title="运行插件"></a>运行插件</h3><hr>
<p>运行插件之前，你需要将<code>package.json</code>中的<code>main</code>属性指向到构建文件上，也就是我们上面提到的<a href="https://github.com/Microsoft/vscode-references-view/blob/d649d01d369e338bbe70c86e03f28269cbf87027/package.json#L26" target="_blank" rel="noopener"><code>"./dist/extension"</code></a>，改好之后我们就可以运行和测试插件了。关于调试配置，请注意更新<code>launch.json</code>中的<code>outFiles</code>属性。</p>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><hr>
<p>插件开发者一般都会给插件源代码进行单元测试，但是有了完备的底层架构支持，插件的源代码可以不依赖测试，webpack 产生的构建文件中也不应该包含任何测试代码。如果需要运行单元测试，只需要简单地编译就好了。在上面的例子里，我们有一个<code>test-compile</code>脚本，它会把调用 Typescript 编译器将插件编译至<code>out</code>目录中。这样一来我们就有了 JS 文件，再使用下面的<code>launch.json</code>就足够应付测试了。</p>
<pre><code>{
  "name": "Extension Tests",
  "type": "extensionHost",
  "request": "launch",
  "runtimeExecutable": "${execPath}",
  "args": [
    "--extensionDevelopmentPath=${workspaceFolder}",
    "--extensionTestsPath=${workspaceFolder}/out/test"
  ],
  "outFiles": ["${workspaceFolder}/out/test/**/*.js"],
  "preLaunchTask": "npm: test-compile"
}</code></pre><p>这个测试配置对于非 webpack 打包的插件来说也是可以使用的。我们没必要将单元测试打包起来，因为它们不应包含在我们发布的插件里。</p>
<h3 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h3><hr>
<p>发布前你需要更新<code>.vscodeignore</code>文件。现在所有东西都打包到了<code>dist/extension.js</code>文件中，所以应该排除这个文件还有<code>out</code>文件夹（怕你漏了，特此提醒），以及最重要的<code>node_modules</code>文件夹。</p>
<p>一般来说，<code>.vsignore</code>文件应该是这样的：</p>
<pre><code>.vscode
node_modules
out/
src/
tsconfig.json
webpack.config.js</code></pre><h3 id="迁移插件"><a href="#迁移插件" class="headerlink" title="迁移插件"></a>迁移插件</h3><hr>
<p>用 webpack 迁移现有的插件是很容易的，整个过程就像我们上面的指南一样。真实的例子如 VS Code 的 References 视图就是从这个<a href="https://github.com/Microsoft/vscode-references-view/pull/50" target="_blank" rel="noopener">pull request</a>应用了 webpack 而来的。</p>
<p>在里面，你可以看到：</p>
<ul>
<li><code>devDependencies</code>中添加<code>webpack</code>，<code>webpack-cli</code>和<code>ts-loader</code></li>
<li>更新 npm 脚本以便开发时使用 webpack</li>
<li>更新调试配置文件<code>launch.json</code></li>
<li>添加和修改<code>webpack.config.js</code></li>
<li>更新<code>.vscodeignore</code>排除<code>node_modules</code>和其他开发时产生的临时文件</li>
<li>开始享受体积更小、安装更快的插件！</li>
</ul>
<h3 id="疑难解答"><a href="#疑难解答" class="headerlink" title="疑难解答"></a>疑难解答</h3><hr>
<h4 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h4><p>使用<code>production</code>模式会执行代码压缩，它会去除源代码中的空格和注释，并把变量名和函数名进行替换——混淆和压缩。不过形如<code>Function.prototype.name</code>的代码不会压缩。</p>
<h4 id="webpack-critical-dependencies"><a href="#webpack-critical-dependencies" class="headerlink" title="webpack critical dependencies"></a>webpack critical dependencies</h4><p>当你运行 webpack 时，你可能会碰到像<strong>Critical dependencies: the request of a dependency is an expression</strong>字样的警告。这些警告必须立即处理，一般来说会影响到打包过程。这句话意味着 webpack 不能静态分析某些依赖，一般是由动态使用<code>require</code>导致的，比如<code>require(someDynamicVariable)</code>。</p>
<p>想要处理这类警告，你需要：</p>
<ul>
<li>将需要打包的部分变成静态的依赖。</li>
<li>通过<code>externals</code>排除这部分依赖，但是注意它们的 Javascript 文件还是应该保留在我们打包的插件里，在<code>.vscodeignore</code>中使用 glob 模式，比如<code>!node_modules/mySpecialModule</code>。</li>
</ul>
<h2 id="持续集成"><a href="#持续集成" class="headerlink" title="持续集成"></a>持续集成</h2><p>插件测试也可以用诸如<a href="https://travis-ci.org/" target="_blank" rel="noopener">Travis CI</a>自动运行测试。<a href="https://github.com/Microsoft/vscode-test" target="_blank" rel="noopener"><code>vscode-test</code></a>库可以基于 CI 设置插件测试，而且里面还包含了一个 Azure Pipelines 的<a href="https://github.com/microsoft/vscode-test/tree/master/sample" target="_blank" rel="noopener">示例插件</a>。你可以先看看<a href="https://dev.azure.com/vscode/vscode-test/_build?definitionId=15" target="_blank" rel="noopener">构建管线</a>是什么样子的，或者直接查看<a href="https://github.com/microsoft/vscode-test/blob/master/sample/azure-pipelines.yml" target="_blank" rel="noopener"><code>azure-pipelines.yml</code>file</a>。</p>
<h3 id="Azure-Pipelines"><a href="#Azure-Pipelines" class="headerlink" title="Azure Pipelines"></a>Azure Pipelines</h3><hr>
<p><img src="/images/loading.gif" data-original="../images/development/6309bb25cbdaf818b7956a84541d12b7.png" alt=""></p>
<p>你可以在<a href="https://azure.microsoft.com/services/devops/" target="_blank" rel="noopener">Azure DevOps</a>上创建免费的项目，它为你提供了代码托管、看板、构建和测试基础设施等等。最重要的是，你可以获得<a href="https://azure.microsoft.com/services/devops/pipelines/" target="_blank" rel="noopener">10 个免费的并行任务</a>容量，用于你构建项目，不论是在 Windows, macOS 还是 Linux 上。</p>
<p>首先，你需要创建一个免费的<a href="https://azure.microsoft.com/services/devops/" target="_blank" rel="noopener">Azure DevOps</a>账号，然后给你的插件创建一个<a href="https://azure.microsoft.com/en-us/features/devops-projects/" target="_blank" rel="noopener">Azure DevOps 项目</a>。</p>
<p>然后，把<code>azure-pipelines.yml</code>文件添加到插件仓库的根目录下，不同于 Linux 中的<code>xvfb</code>配置脚本，需要 VS Code 运行在 Linux 的无头 CI 机器上，我们的配置文件非常简单：</p>
<pre><code>trigger:
  - master
strategy:
  matrix:
    linux:
      imageName: "ubuntu-16.04"
    mac:
      imageName: "macos-10.13"
    windows:
      imageName: "vs2017-win2016"
pool:
  vmImage: $(imageName)
steps:
  - task: NodeTool@0
    inputs:
      versionSpec: "8.x"
    displayName: "Install Node.js"
  - bash: |
      /usr/bin/Xvfb :99 -screen 0 1024x768x24 &gt; /dev/null 2&gt;&amp;1 &amp;
      echo "&gt;&gt;&gt; Started xvfb"
    displayName: Start xvfb
    condition: and(succeeded(), eq(variables['Agent.OS'], 'Linux'))
  - bash: |
      echo "&gt;&gt;&gt; Compile vscode-test"
      yarn &amp;&amp; yarn compile
      echo "&gt;&gt;&gt; Compiled vscode-test"
      cd sample
      echo "&gt;&gt;&gt; Run sample integration test"
      yarn &amp;&amp; yarn compile &amp;&amp; yarn test
    displayName: Run Tests
    env:
      DISPLAY: ":99.0"</code></pre><p>最后，在你的 DveOps 项目里<a href="https://docs.microsoft.com/azure/devops/pipelines/get-started-yaml?view=vsts#get-your-first-build" target="_blank" rel="noopener">创建一个新的管线</a>，然后指向<code>azure-pipelines.yml</code>文件，启动 build，然后……真香~</p>
<p><img src="/images/loading.gif" data-original="../images/development/a5a729d9b0bb4fe4f13c0cbd71013d19.png" alt=""></p>
<p>你可以启用持续构建——每当有 pull requests 进入特定分支的时候自动进行构建。相关内容请查看<a href="https://docs.microsoft.com/azure/devops/pipelines/build/triggers" target="_blank" rel="noopener">构建管线触发器</a>。</p>
<h3 id="Travis-CI"><a href="#Travis-CI" class="headerlink" title="Travis CI"></a>Travis CI</h3><hr>
<p><a href="https://github.com/microsoft/vscode-test" target="_blank" rel="noopener">vscode-test</a>还包含了一份<a href="https://github.com/microsoft/vscode-test/blob/master/.travis.yml" target="_blank" rel="noopener">Travis CI 构建文件</a>，因为 Travis 上的环境变量定义和 Azure 所有不同，<code>xvfb</code>脚本也有些许不一样：</p>
<pre><code>language: node_js
os:
  - osx
  - linux
node_js: 8
install:
  - |
    if [ $TRAVIS_OS_NAME == "linux" ]; then
      export DISPLAY=':99.0'
      /usr/bin/Xvfb :99 -screen 0 1024x768x24 &gt; /dev/null 2&gt;&amp;1 &amp;
    fi
script:
  - |
    echo "&gt;&gt;&gt; Compile vscode-test"
    yarn &amp;&amp; yarn compile
    echo "&gt;&gt;&gt; Compiled vscode-test"
    cd sample
    echo "&gt;&gt;&gt; Run sample integration test"
    yarn &amp;&amp; yarn compile &amp;&amp; yarn test
cache: yarn</code></pre><h1 id="插件功能"><a href="#插件功能" class="headerlink" title="插件功能"></a>插件功能</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p>VS Code 提供了非常多的方法，供插件扩展VS Code本身的能力。但是有的时候也很难找到对的发布内容配置和VS Code API。这章内容将插件的功能分成了几个部分，每个部分都将告诉你：</p>
<ul>
<li>插件可以使用的功能</li>
<li>这些功能点的细节索引</li>
<li>一些插件灵感</li>
</ul>
<p>不过，我们也会告诉你一些限制，为了避免插件影响到VS Code的性能和稳定性。比如：插件不可以修改VS Code UI底层的DOM。</p>
<h3 id="常用功能"><a href="#常用功能" class="headerlink" title="常用功能"></a>常用功能</h3><hr>
<p>常用功能是你在任何插件中都可能用到的核心功能。</p>
<p>这些功能包括：</p>
<ul>
<li>注册命令、配置、快捷键绑定、菜单等。</li>
<li>保存工作区或全局数据。</li>
<li>显示通知信息。</li>
<li>使用快速选择获得用户输入。</li>
<li>打开系统的文件选择工具，以便用户选择文件或文件夹。</li>
<li>使用进度API提示耗时较长的操作。</li>
</ul>
<h3 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h3><hr>
<p>主题控制着VS Code的外观——编辑器中的源代码的颜色和VS Code UI颜色。如果你曾经想要把VS Code搞成绿色，想象自己在黑客帝国里写代码，或者想要追求极简性冷淡灰色风格，那么主题章节就是为你而来。</p>
<h5 id="插件灵感"><a href="#插件灵感" class="headerlink" title="插件灵感"></a>插件灵感</h5><ul>
<li>改变你的代码颜色</li>
<li>改变VS Code UI颜色</li>
<li>将现有的TextMate主题应用到VS Code中</li>
<li>添加自定义图标</li>
</ul>
<h3 id="声明式添加语言特性"><a href="#声明式添加语言特性" class="headerlink" title="声明式添加语言特性"></a>声明式添加语言特性</h3><hr>
<p>声明式语言特性添加了基础的编程语言编辑支持，如括号匹配、自动缩进和语法高亮。这些功能都可以通过声明配置而不用写任何代码就可以获得，更高级的语言特性如IntelliSense或调试，请看编程式添加语言特性</p>
<h5 id="插件灵感-1"><a href="#插件灵感-1" class="headerlink" title="插件灵感"></a>插件灵感</h5><ul>
<li>将常用的JS代码片段打包到插件中</li>
<li>为VS Code添加新的语言支持</li>
<li>为一门语言添加或替换语法</li>
<li>通过注入的方式，扩展一门语法</li>
<li>将现有的 TextMate 语法迁移到VS Code中</li>
</ul>
<h3 id="编程式添加语言特性"><a href="#编程式添加语言特性" class="headerlink" title="编程式添加语言特性"></a>编程式添加语言特性</h3><hr>
<p>编程式添加语言特性可以为编程语言添加更为丰富的特性，如：悬停提示、转跳定义、错误诊断、IntelliSense和CodeLens。这些语言特性暴露于<a href="https://code.visualstudio.com/api/references/vscode-api#languages" target="_blank" rel="noopener"><code>vscode.languages.*</code></a>API。语言插件可以直接使用这些API，或是自己写一个语言服务器，通过<a href="https://github.com/Microsoft/vscode-languageserver-node" target="_blank" rel="noopener">语言服务器库</a>将它适配到VS Code。</p>
<p>虽然我们提供了一个语言特性列表，但是并不阻碍你发挥想象，自由使用这些API。比方说，在行内显示额外信息，使用CodeLens和代码悬停是非常好的方式，而错误诊断可以高亮拼写或代码风格错误。</p>
<h5 id="插件灵感-2"><a href="#插件灵感-2" class="headerlink" title="插件灵感"></a>插件灵感</h5><ul>
<li>鼠标悬停于API上时, 出现用法示例</li>
<li>使用诊断，报告代码风格错误</li>
<li>注册新的HTML代码格式化</li>
<li>提供丰富的IntelliSense中间件</li>
<li>为一门语言添加代码折叠、面包屑、轮廓支持</li>
</ul>
<h3 id="扩展工作台"><a href="#扩展工作台" class="headerlink" title="扩展工作台"></a>扩展工作台</h3><hr>
<p>扩展工作台加强了 VS Code 工作台的UI，为资源管理侧边栏添加了新的右击行为，你甚至可以用 TreeView API构建自定义的资源管理侧边栏。如果你的插件需要完全自定义用户界面，那就使用Webview API和HTML，CSS，Javascript构建你自己的UI。</p>
<h5 id="插件灵感-3"><a href="#插件灵感-3" class="headerlink" title="插件灵感"></a>插件灵感</h5><ul>
<li>自定义资源管理侧边栏的菜单行为</li>
<li>在侧边栏中创建新的、交互式的TreeView</li>
<li>定义新的活动栏视图</li>
<li>在状态栏显示新的信息</li>
<li>使用<code>WebView</code> API显示自定义内容</li>
<li>配置<em>源控制(git/svn等)</em>来源</li>
</ul>
<h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><hr>
<p>你可以利用<a href="https://code.visualstudio.com/docs/editor/debugging" target="_blank" rel="noopener">调试</a>来制作调试器插件，这个插件需要将VS Code的调试UI连接到真实的调试器或者运行时上。</p>
<h5 id="插件灵感-4"><a href="#插件灵感-4" class="headerlink" title="插件灵感"></a>插件灵感</h5><ul>
<li>通过<a href="https://microsoft.github.io/debug-adapter-protocol/implementors/adapters/" target="_blank" rel="noopener">调试适配器</a>将VS Code的调试UI连接到真实的调试器或者运行时上</li>
<li>通过调试器插件添加语言支持</li>
<li>为调试配置文件添加丰富的智能提示或者悬停信息</li>
<li>为调试配置文件添加代码片段</li>
</ul>
<p>另一方面，VS Code也提供了非常多的<a href="https://code.visualstudio.com/api/references/vscode-api#debug" target="_blank" rel="noopener">调试器插件API</a>，你可以用来实现任何VS Code调试器相关的功能，加强用户的调试体验。</p>
<h5 id="插件灵感-5"><a href="#插件灵感-5" class="headerlink" title="插件灵感"></a>插件灵感</h5><ul>
<li>动态生成调试器配置文件，启动调试器会话</li>
<li>跟踪调试会话的声明周期</li>
<li>编程式管理断点</li>
</ul>
<h3 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h3><hr>
<p>最后，我还对插件也提出了一些限制。</p>
<h4 id="不可访问DOM"><a href="#不可访问DOM" class="headerlink" title="不可访问DOM"></a>不可访问DOM</h4><p>插件没有权限访问VS Code UI的底层DOM，<strong>禁止</strong>添加自定义的CSS 和 HTML片段到VS Code UI上。</p>
<p>我们在一直努力优化VS Code底层的web技术，为用户创造高可用、持续响应的编辑器，而我们也会继续调整这些技术中使用到的DOM。为了确保不会干扰到VS Code的性能和稳定性，同时不阻断其他插件的运行，所以我们的插件都跑在插件主机进程中，而且阻止了插件直接访问DOM的途径。</p>
<h2 id="常用功能-1"><a href="#常用功能-1" class="headerlink" title="常用功能"></a>常用功能</h2><p>常用功能对你的插件来说非常重要，几乎所有的都会或多或少地用到这些功能，下面我们为你简单地介绍一下它们。</p>
<h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><hr>
<p>命令是VS Code 运作的核心。你可以打开<em>命令面板</em>执行，用快捷键执行，还可以在菜单中鼠标右键执行。</p>
<p>一个插件应该：</p>
<ul>
<li>使用<a href="https://code.visualstudio.com/api/references/vscode-api#commands" target="_blank" rel="noopener"><code>vscode.commands</code></a>注册和执行命令</li>
<li>配置<code>contributes.commands</code>，确保命令面板中可以顺利执行你注册的命令</li>
</ul>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><hr>
<p>插件需要在<code>contributes.configuration</code>发布内容配置点中填写有关的配置，你可以<code>workspace.getConfiguration</code> API中阅读有关内容。</p>
<h3 id="键位绑定"><a href="#键位绑定" class="headerlink" title="键位绑定"></a>键位绑定</h3><hr>
<p>插件可以添加自定义键位映射，在<code>contributes.keybindings</code>和<a href="https://code.visualstudio.com/docs/getstarted/keybindings" target="_blank" rel="noopener">键位绑定</a>中了解更多有关内容。</p>
<h3 id="菜单"><a href="#菜单" class="headerlink" title="菜单"></a>菜单</h3><hr>
<p>插件可以自定义上下文菜单项，菜单会根据用户右击VS Code UI的不同位置而各不相同。查看更多<code>contributes.menus</code>发布内容配置。</p>
<h3 id="数据储存"><a href="#数据储存" class="headerlink" title="数据储存"></a>数据储存</h3><hr>
<p>VS Code中有三种数据储存方式：</p>
<ul>
<li><a href="https://code.visualstudio.com/api/references/vscode-api#ExtensionContext.workspaceState" target="_blank" rel="noopener"><code>ExtensionContext.workspaceState</code></a>：键值对组成的工作区数据。当同一个工作区再次打开时会重新取出数据。</li>
<li><a href="https://code.visualstudio.com/api/references/vscode-api#ExtensionContext.globalState" target="_blank" rel="noopener"><code>ExtensionContext.globalState</code></a>：键值对组成的全局数据。当插件激活时会再次取出这些数据。</li>
<li><a href="https://code.visualstudio.com/api/references/vscode-api#ExtensionContext.storagePath" target="_blank" rel="noopener"><code>ExtensionContext.storagePath</code></a>：指向你的插件可以读写的本地文件夹的路径。如果你要储存比较大的数据，这是一个非常好的选择。</li>
<li><a href="https://code.visualstudio.com/api/references/vscode-api#ExtensionContext.globalStoragePath" target="_blank" rel="noopener"><code>ExtensionContext.globalStoragePath</code></a>：指向你的插件可以读写的本地存储的路径。如果你要存储所有工作区内的大文件，这时一个非常好的选择。</li>
</ul>
<p>插件的执行上下文在<code>activate</code>函数。</p>
<h3 id="显示通知"><a href="#显示通知" class="headerlink" title="显示通知"></a>显示通知</h3><hr>
<p>几乎所有的插件都需要在某些时候为用户提示信息。VS Code提供了3个API来展示不同重要程度的信息：</p>
<ul>
<li><a href="https://code.visualstudio.com/api/references/vscode-api#window.showInformationMessage" target="_blank" rel="noopener"><code>window.showInformationMessage</code></a></li>
<li><a href="https://code.visualstudio.com/api/references/vscode-api#window.showWarningMessage" target="_blank" rel="noopener"><code>window.showWarningMessage</code></a></li>
<li><a href="https://code.visualstudio.com/api/references/vscode-api#window.showErrorMessage" target="_blank" rel="noopener"><code>window.showErrorMessage</code></a></li>
</ul>
<h3 id="快速选择"><a href="#快速选择" class="headerlink" title="快速选择"></a>快速选择</h3><hr>
<p>使用<a href="https://code.visualstudio.com/api/references/vscode-api#QuickPick" target="_blank" rel="noopener"><code>vscode.QuickPick</code></a>API，你可以轻松地收集用户输入或者为用户显示选择列表。<a href="https://github.com/Microsoft/vscode-extension-samples/tree/master/quickinput-sample" target="_blank" rel="noopener">快速输入 示例</a>将详细解释这个API。</p>
<h3 id="文件选择"><a href="#文件选择" class="headerlink" title="文件选择"></a>文件选择</h3><hr>
<p>插件可以使用<a href="https://code.visualstudio.com/api/references/vscode-api#vscode.window.showOpenDialog" target="_blank" rel="noopener"><code>vscode.window.showOpenDialog</code></a>API打开系统文件选择器，然后选择文件或是文件夹。</p>
<h3 id="输出渠道"><a href="#输出渠道" class="headerlink" title="输出渠道"></a>输出渠道</h3><hr>
<p><em>输出面板</em>显示了一组<a href="https://code.visualstudio.com/api/references/vscode-api#OutputChannel" target="_blank" rel="noopener"><code>输出渠道</code></a>，以便于你查看日志。你可以使用<a href="https://code.visualstudio.com/api/references/vscode-api#window.createOutputChannel" target="_blank" rel="noopener"><code>window.createOutputChannel</code></a>创建一个新的输出渠道。</p>
<h3 id="进度API"><a href="#进度API" class="headerlink" title="进度API"></a>进度API</h3><hr>
<p>使用<a href="https://code.visualstudio.com/api/references/vscode-api#Progress" target="_blank" rel="noopener"><code>vscode.Progress</code></a>将处理进度报告给用户。</p>
<p>通过<a href="https://code.visualstudio.com/api/references/vscode-api#ProgressLocation" target="_blank" rel="noopener"><code>ProgressLocation</code></a>选项，进度可以显示在不同的区域：</p>
<ul>
<li>显示在通知区</li>
<li>显示在源控制视图</li>
<li>VS Code窗口中的通用进度条位置</li>
</ul>
<p>详见<a href="https://github.com/Microsoft/vscode-extension-samples/tree/master/progress-sample" target="_blank" rel="noopener">进度 示例</a>。</p>
<h2 id="主题-1"><a href="#主题-1" class="headerlink" title="主题"></a>主题</h2><p>VS Code中的主题分为两类：</p>
<ul>
<li><strong>色彩主题</strong>：UI组件ID和文本符号ID到色彩间的映射。通过色彩主题你可以修改VS Code UI组和编辑器中的文本。</li>
<li><strong>图标主题</strong>：文件类型/名称到图片之间的映射。文件图标显示于VS Code的资源管理侧边栏、快速打开列表和编辑器Tab等UI中。</li>
</ul>
<h3 id="色彩主题"><a href="#色彩主题" class="headerlink" title="色彩主题"></a>色彩主题</h3><hr>
<p><img src="/images/loading.gif" data-original="../images/development/1dcbc165af80dbe5d13595380bf56157.png" alt=""></p>
<p>如上图所示，色彩主题定义了2种映射：</p>
<ul>
<li><code>colors</code>控制UI组件的颜色</li>
<li><code>tokenColors</code>控制了每个代码标记单元(你的代码会根据语法分割成一个个标记单元)的颜色。</li>
</ul>
<p>创建主题详见色彩主题指南和<a href="https://github.com/Microsoft/vscode-extension-samples/tree/master/theme-sample" target="_blank" rel="noopener">色彩主题 示例</a></p>
<h3 id="图标主题"><a href="#图标主题" class="headerlink" title="图标主题"></a>图标主题</h3><hr>
<p>图标主题允许你：</p>
<ul>
<li>将图标ID映射至图片或者字体图标上。</li>
<li>根据文件名或这个文件的语言类型关联上图标ID</li>
</ul>
<h2 id="扩展工作台-1"><a href="#扩展工作台-1" class="headerlink" title="扩展工作台"></a>扩展工作台</h2><p>“工作台”是指整个VS Code UI和其中包含的下列UI 组件：</p>
<ul>
<li>标题栏</li>
<li>活动栏</li>
<li>侧边栏</li>
<li>面板</li>
<li>编辑器群</li>
<li>状态栏</li>
</ul>
<p>VS Code提供了各式各样的API让在工作台你添加自己的组件。比如下图：</p>
<p><img src="/images/loading.gif" data-original="../images/development/f838b50a645e72e2b4ff80292406d341.png" alt=""></p>
<ul>
<li>活动栏：<a href="https://marketplace.visualstudio.com/items?itemName=ms-azuretools.vscode-azureappservice" target="_blank" rel="noopener">Azure App Service extension</a>添加了一个视图容器</li>
<li>侧边栏：内置的<a href="https://github.com/Microsoft/vscode/tree/master/extensions/npm" target="_blank" rel="noopener">NPM 插件</a> 添加了一个 Tree View 到资源管理器视图</li>
<li>编辑器群：内置的<a href="https://github.com/Microsoft/vscode/tree/master/extensions/markdown-language-features" target="_blank" rel="noopener">Markdown 插件</a> 添加了一个Webview 到编辑器的旁边</li>
<li>状态栏：<a href="https://marketplace.visualstudio.com/items?itemName=vscodevim.vim" target="_blank" rel="noopener">VSCodeVim 插件</a> 添加了一个状态栏项目</li>
</ul>
<h3 id="视图容器"><a href="#视图容器" class="headerlink" title="视图容器"></a>视图容器</h3><hr>
<p>在<code>contributes.viewsContainers</code>发布内容配置中，你可以添加新的视图容器在5个内置的视图容器中。学习更多树视图。</p>
<h3 id="树视图"><a href="#树视图" class="headerlink" title="树视图"></a>树视图</h3><hr>
<p>在<code>contributes.views</code>发布内容配置中，你可以添加在任何视图容器岁添加新的视图。学习更多树视图。</p>
<h3 id="Webview"><a href="#Webview" class="headerlink" title="Webview"></a>Webview</h3><hr>
<p>Webview是使用HTML/CSS/JS高度定制的视图。它们显示在编辑器区域中。详见Webview指南。</p>
<h3 id="状态栏项"><a href="#状态栏项" class="headerlink" title="状态栏项"></a>状态栏项</h3><hr>
<p>插件可以创建自定义的<a href="https://code.visualstudio.com/api/references/vscode-api#StatusBarItem" target="_blank" rel="noopener"><code>StatusBarItem</code></a>显示在状态栏中。状态栏项可以显示文本和图标，还可以在点击事件触发时运行命令。</p>
<ul>
<li>显示文本和图标</li>
<li>点击时运行命令</li>
</ul>
<p>状态栏插件的例子可以<a href="https://github.com/Microsoft/vscode-extension-samples/tree/master/statusbar-sample" target="_blank" rel="noopener">戳这里</a></p>
<h1 id="插件指南"><a href="#插件指南" class="headerlink" title="插件指南"></a>插件指南</h1><h2 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h2><p>通过Hello World学习过基本的VS Code插件API之后，现在是时间搞搞真正的插件了。在插件功能章节，在更宽泛的层面上介绍了插件<strong>能做</strong>些什么，本章则细化了各个功能点，并提供了<strong>详细的代码</strong>和VS Code API的解释。</p>
<p>在每个指南-示例组合中，你将会看到：</p>
<ul>
<li>贯穿整个代码的注释</li>
<li>使用示例插件的gif或者图片</li>
<li>运行示例插件指引</li>
<li>使用过的VS Code API列表</li>
<li>使用过的配置点列表</li>
<li>真正的组合插件示例</li>
<li>API概念解释</li>
</ul>
<h3 id="指南和例子"><a href="#指南和例子" class="headerlink" title="指南和例子"></a>指南和例子</h3><hr>
<p>下面是一份指南和例子的表格，虽然每个指南都要有示例代码，但是一些示例目前暂时还没有与之匹配的指南。</p>
<p>每个例子都至少阐释了一个VS Code API或者发布内容配置的使用。</p>
<table>
<thead>
<tr>
<th align="left">例子</th>
<th align="left">VS Code网页指南</th>
<th align="left">API &amp; 配置</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a href="https://github.com/Microsoft/vscode-extension-samples/tree/master/webview-sample" target="_blank" rel="noopener">Webview Sample</a></td>
<td align="left">/extension-guides/webview</td>
<td align="left"><a href="https://code.visualstudio.com/api/references/vscode-api#window.createWebviewPanel" target="_blank" rel="noopener">window.createWebviewPanel</a> <a href="https://code.visualstudio.com/api/references/vscode-api#window.registerWebviewPanelSerializer" target="_blank" rel="noopener">window.registerWebviewPanelSerializer</a></td>
</tr>
<tr>
<td align="left"><a href="https://github.com/Microsoft/vscode-extension-samples/tree/master/statusbar-sample" target="_blank" rel="noopener">Status Bar Sample</a></td>
<td align="left">N/A</td>
<td align="left"><a href="https://code.visualstudio.com/api/references/vscode-api#window.createStatusBarItem" target="_blank" rel="noopener">window.createStatusBarItem</a> <a href="https://code.visualstudio.com/api/references/vscode-api#StatusBarItem" target="_blank" rel="noopener">StatusBarItem</a></td>
</tr>
<tr>
<td align="left"><a href="https://github.com/Microsoft/vscode-extension-samples/tree/master/tree-view-sample" target="_blank" rel="noopener">Tree View Sample</a></td>
<td align="left">/extension-guides/tree-view</td>
<td align="left"><a href="https://code.visualstudio.com/api/references/vscode-api#window.createTreeView" target="_blank" rel="noopener">window.createTreeView</a> <a href="https://code.visualstudio.com/api/references/vscode-api#window.registerTreeDataProvider" target="_blank" rel="noopener">window.registerTreeDataProvider</a> <a href="https://code.visualstudio.com/api/references/vscode-api#TreeView" target="_blank" rel="noopener">TreeView</a> <a href="https://code.visualstudio.com/api/references/vscode-api#TreeDataProvider" target="_blank" rel="noopener">TreeDataProvider</a> <a href="https://www.bookstack.cn/read/VS-Code-Extension-Doc-ZH/$docs-extension-guides-references-contribution-points?#contributesviews" target="_blank" rel="noopener">contributes.views</a> <a href="https://www.bookstack.cn/read/VS-Code-Extension-Doc-ZH/$docs-extension-guides-references-contribution-points#contributesviewscontainers" target="_blank" rel="noopener">contributes.viewsContainers</a></td>
</tr>
<tr>
<td align="left"><a href="https://github.com/Microsoft/vscode-extension-samples/tree/master/task-provider-sample" target="_blank" rel="noopener">Task Provider Sample</a></td>
<td align="left">/extension-guides/task-provider</td>
<td align="left"><a href="https://code.visualstudio.com/api/references/vscode-api#tasks.registerTaskProvider" target="_blank" rel="noopener">tasks.registerTaskProvider</a> <a href="https://code.visualstudio.com/api/references/vscode-api#Task" target="_blank" rel="noopener">Task</a> <a href="https://code.visualstudio.com/api/references/vscode-api#ShellExecution" target="_blank" rel="noopener">ShellExecution</a> <a href="https://www.bookstack.cn/read/VS-Code-Extension-Doc-ZH/$docs-extension-guides-references-contribution-points?id=contributestaskdefinitions" target="_blank" rel="noopener">contributes.taskDefinitions</a></td>
</tr>
<tr>
<td align="left"><a href="https://github.com/Microsoft/vscode-extension-samples/tree/master/basic-multi-root-sample" target="_blank" rel="noopener">Multi Root Sample</a></td>
<td align="left">N/A</td>
<td align="left"><a href="https://code.visualstudio.com/api/references/vscode-api#workspace.getWorkspaceFolder" target="_blank" rel="noopener">workspace.getWorkspaceFolder</a> <a href="https://code.visualstudio.com/api/references/vscode-api#workspace.onDidChangeWorkspaceFolders" target="_blank" rel="noopener">workspace.onDidChangeWorkspaceFolders</a></td>
</tr>
<tr>
<td align="left"><a href="https://github.com/Microsoft/vscode-extension-samples/tree/master/completions-sample" target="_blank" rel="noopener">Completion Provider Sample</a></td>
<td align="left">N/A</td>
<td align="left"><a href="https://code.visualstudio.com/api/references/vscode-api#languages.registerCompletionItemProvider" target="_blank" rel="noopener">languages.registerCompletionItemProvider</a> <a href="https://code.visualstudio.com/api/references/vscode-api#CompletionItem" target="_blank" rel="noopener">CompletionItem</a> <a href="https://code.visualstudio.com/api/references/vscode-api#SnippetString" target="_blank" rel="noopener">SnippetString</a></td>
</tr>
<tr>
<td align="left"><a href="https://github.com/Microsoft/vscode-extension-samples/tree/master/fsprovider-sample" target="_blank" rel="noopener">File System Provider Sample</a></td>
<td align="left">N/A</td>
<td align="left"><a href="https://code.visualstudio.com/api/references/vscode-api#workspace.registerFileSystemProvider" target="_blank" rel="noopener">workspace.registerFileSystemProvider</a></td>
</tr>
<tr>
<td align="left"><a href="https://github.com/Microsoft/vscode-extension-samples/tree/master/decorator-sample" target="_blank" rel="noopener">Editor Decorator Sample</a></td>
<td align="left">N/A</td>
<td align="left"><a href="https://code.visualstudio.com/api/references/vscode-api#TextEditor.setDecorations" target="_blank" rel="noopener">TextEditor.setDecorations</a> <a href="https://code.visualstudio.com/api/references/vscode-api#DecorationOptions" target="_blank" rel="noopener">DecorationOptions</a> <a href="https://code.visualstudio.com/api/references/vscode-api#DecorationInstanceRenderOptions" target="_blank" rel="noopener">DecorationInstanceRenderOptions</a> <a href="https://code.visualstudio.com/api/references/vscode-api#ThemableDecorationInstanceRenderOptions" target="_blank" rel="noopener">ThemableDecorationInstanceRenderOptions</a> <a href="https://code.visualstudio.com/api/references/vscode-api#window.createTextEditorDecorationType" target="_blank" rel="noopener">window.createTextEditorDecorationType</a> <a href="https://code.visualstudio.com/api/references/vscode-api#TextEditorDecorationType" target="_blank" rel="noopener">TextEditorDecorationType</a> <a href="https://www.bookstack.cn/read/VS-Code-Extension-Doc-ZH/$docs-extension-guides-references-contribution-points#contributescolors" target="_blank" rel="noopener">contributes.colors</a></td>
</tr>
<tr>
<td align="left"><a href="https://github.com/Microsoft/vscode-extension-samples/tree/master/i18n-sample" target="_blank" rel="noopener">I18n Sample</a></td>
<td align="left">N/A</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><a href="https://github.com/Microsoft/vscode-extension-samples/tree/master/terminal-sample" target="_blank" rel="noopener">Terminal Sample</a></td>
<td align="left">N/A</td>
<td align="left"><a href="https://code.visualstudio.com/api/references/vscode-api#window.createTerminal" target="_blank" rel="noopener">window.createTerminal</a> <a href="https://code.visualstudio.com/api/references/vscode-api#window.onDidChangeActiveTerminal" target="_blank" rel="noopener">window.onDidChangeActiveTerminal</a> <a href="https://code.visualstudio.com/api/references/vscode-api#window.onDidCloseTerminal" target="_blank" rel="noopener">window.onDidCloseTerminal</a> <a href="https://code.visualstudio.com/api/references/vscode-api#window.onDidOpenTerminal" target="_blank" rel="noopener">window.onDidOpenTerminal</a> <a href="https://code.visualstudio.com/api/references/vscode-api#window.Terminal" target="_blank" rel="noopener">window.Terminal</a> <a href="https://code.visualstudio.com/api/references/vscode-api#window.terminals" target="_blank" rel="noopener">window.terminals</a></td>
</tr>
<tr>
<td align="left"><a href="https://github.com/Microsoft/vscode-extension-samples/tree/master/vim-sample" target="_blank" rel="noopener">Vim Sample</a></td>
<td align="left">N/A</td>
<td align="left"><a href="https://code.visualstudio.com/api/references/vscode-api#commands" target="_blank" rel="noopener">commands</a> <a href="https://code.visualstudio.com/api/references/vscode-api#StatusBarItem" target="_blank" rel="noopener">StatusBarItem</a> <a href="https://code.visualstudio.com/api/references/vscode-api#window.createStatusBarItem" target="_blank" rel="noopener">window.createStatusBarItem</a> <a href="https://code.visualstudio.com/api/references/vscode-api#TextEditorCursorStyle" target="_blank" rel="noopener">TextEditorCursorStyle</a> <a href="https://code.visualstudio.com/api/references/vscode-api#window.activeTextEditor" target="_blank" rel="noopener">window.activeTextEditor</a> <a href="https://code.visualstudio.com/api/references/vscode-api#Position" target="_blank" rel="noopener">Position</a> <a href="https://code.visualstudio.com/api/references/vscode-api#Range" target="_blank" rel="noopener">Range</a> <a href="https://code.visualstudio.com/api/references/vscode-api#Selection" target="_blank" rel="noopener">Selection</a> <a href="https://code.visualstudio.com/api/references/vscode-api#TextEditor" target="_blank" rel="noopener">TextEditor</a> <a href="https://code.visualstudio.com/api/references/vscode-api#TextEditorRevealType" target="_blank" rel="noopener">TextEditorRevealType</a> <a href="https://code.visualstudio.com/api/references/vscode-api#TextDocument" target="_blank" rel="noopener">TextDocument</a></td>
</tr>
</tbody></table>
<h3 id="语言插件示例"><a href="#语言插件示例" class="headerlink" title="语言插件示例"></a>语言插件示例</h3><hr>
<p>下面的部分是语言插件相关示例：</p>
<table>
<thead>
<tr>
<th align="left">例子</th>
<th align="left">VS Code网页指南</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a href="https://github.com/Microsoft/vscode-extension-samples/tree/master/snippet-sample" target="_blank" rel="noopener">Snippet Sample</a></td>
<td align="left">/language-extensions/snippet-guide</td>
<td><a href="https://code.visualstudio.com/api/references/contribution-points#contributes.snippets" target="_blank" rel="noopener">contributes.snippets</a></td>
</tr>
<tr>
<td align="left"><a href="https://github.com/Microsoft/vscode-extension-samples/tree/master/language-configuration-sample" target="_blank" rel="noopener">Language Configuration Sample</a></td>
<td align="left">/language-extensions/language-configuration-guide</td>
<td><a href="https://code.visualstudio.com/api/references/contribution-points#contributes.languages" target="_blank" rel="noopener">contributes.languages</a></td>
</tr>
<tr>
<td align="left"><a href="https://github.com/Microsoft/vscode-extension-samples/tree/master/lsp-sample" target="_blank" rel="noopener">LSP Sample</a></td>
<td align="left">/language-extensions/language-server-extension-guide</td>
<td></td>
</tr>
<tr>
<td align="left"><a href="https://github.com/Microsoft/vscode-extension-samples/tree/master/lsp-log-streaming-sample" target="_blank" rel="noopener">LSP Log Streaming Sample</a></td>
<td align="left">N/A</td>
<td></td>
</tr>
<tr>
<td align="left"><a href="https://github.com/Microsoft/vscode-extension-samples/tree/master/lsp-multi-server-sample" target="_blank" rel="noopener">LSP Multi Root Server Sample</a></td>
<td align="left"><a href="https://github.com/Microsoft/vscode/wiki/Adopting-Multi-Root-Workspace-APIs#language-client--language-server" target="_blank" rel="noopener">https://github.com/Microsoft/vscode/wiki/Adopting-Multi-Root-Workspace-APIs#language-client--language-server</a></td>
<td></td>
</tr>
</tbody></table>
<h2 id="命令-1"><a href="#命令-1" class="headerlink" title="命令"></a>命令</h2><p>命令会触发VS Code中注册的行为，如果你<a href="https://code.visualstudio.com/docs/getstarted/keybindings" target="_blank" rel="noopener">配置过键位</a>，那么你就处理过了命令。命令也是插件将功能暴露给用户的地方，它绑定了VS Code UI中的行为，并在内部处理了相关逻辑。</p>
<h3 id="使用命令"><a href="#使用命令" class="headerlink" title="使用命令"></a>使用命令</h3><hr>
<p>VS Code内部含有大量和编辑器交互、控制UI、后台操作的内置命令。许多插件将它们的核心功能暴露为<em>命令</em>的形式供用户或者其他插件使用。</p>
<h4 id="程序性执行一个命令"><a href="#程序性执行一个命令" class="headerlink" title="程序性执行一个命令"></a>程序性执行一个命令</h4><p><a href="https://code.visualstudio.com/api/references/vscode-api#commands.executeCommand" target="_blank" rel="noopener"><code>vscode.commands.executeCommand</code></a>API可以程序性调用一个命令，你可以通过它将VS Code的内置函数构建在你的插件中，比如VS Code内置的Git和Markdown插件中的东西。</p>
<p>我们看个例子🌰：<code>editor.action.addCommentLine</code>命令可以将当前选中行变成注释(你可以偷偷把这个功能地集成到你自己的插件中哦)：</p>
<pre><code>import * as vscode from 'vscode';
function commentLine() {
    vscode.commands.executeCommand('editor.action.addCommentLine');
}</code></pre><p>有些命令可以接收改变行为的参数，有些会有返回结果。形如<code>vscode.executeDefinitionProvider</code>的API，它要求传入一个document的URI地址和position作为参数，并返回一个包含定义列表的promise：</p>
<pre><code>import * as vscode from 'vscode';
async function printDefinitionsForActiveEditor() {
    const activeEditor = vscode.window.activeTextEditor;
    if (!activeEditor) {
        return;
    }
    const definitions = await vscode.commands.executeCommand&lt;vscode.Location[]&gt;(
        'vscode.executeDefinitionProvider',
        activeEditor.document.uri,
        activeEditor.selection.active
    );
    for (const definition of definitions) {
        console.log(definition);
    }
}</code></pre><p>更多命令详见：</p>
<ul>
<li><a href="https://code.visualstudio.com/docs/getstarted/keybindings" target="_blank" rel="noopener">浏览键盘快捷键</a></li>
<li><a href="https://www.bookstack.cn/read/VS-Code-Extension-Doc-ZH/$docs-extension-guides-references-commands" target="_blank" rel="noopener">VS Code内置高级命令API</a></li>
</ul>
<h4 id="命令的URLs"><a href="#命令的URLs" class="headerlink" title="命令的URLs"></a>命令的URLs</h4><p>命令URI是执行注册命令的链接。它们可被用于悬停文本上的可点击链接，代码补全提示中的细节信息，甚至可以出现在webview中。</p>
<p>命令URI使用<code>command</code>作为协议头，然后紧跟着命令名称。比如：<code>editor.action.addCommentLine</code>的命令URI是：<code>command:editor.action.addCommentLine</code>。下面是一个显示在当前行注释中显示链接的悬停函数。</p>
<pre><code>import * as vscode from 'vscode';
export function activate(context: vscode.ExtensionContext) {
    vscode.languages.registerHoverProvider(
        'javascript',
        new class implements vscode.HoverProvider {
            provideHover(
                _document: vscode.TextDocument,
                _position: vscode.Position,
                _token: vscode.CancellationToken
            ): vscode.ProviderResult&lt;vscode.Hover&gt; {
                const commentCommandUri = vscode.Uri.parse(`command:editor.action.addCommentLine`);
                const contents = new vscode.MarkdownString(`[Add comment](${commentCommandUri})`);
                // command URIs如果想在Markdown 内容中生效, 你必须设置`isTrusted`。
                // 当创建可信的Markdown 字符, 请合理地清理所有的输入内容
                // 以便你期望的命令command URIs生效
                contents.isTrusted = true;
                return new vscode.Hover(contents);
            }
        }()
    );
}</code></pre><p>命令上的参数列表会从JSON数组变成URI格式：下面的例子使用了<code>git.stage</code>命令创建一个悬停操作——将当前文件进行git暂存：</p>
<pre><code>import * as vscode from 'vscode';
export function activate(context: vscode.ExtensionContext) {
    vscode.languages.registerHoverProvider(
        'javascript',
        new class implements vscode.HoverProvider {
            provideHover(
                document: vscode.TextDocument,
                _position: vscode.Position,
                _token: vscode.CancellationToken
            ): vscode.ProviderResult&lt;vscode.Hover&gt; {
                const args = [{ resourceUri: document.uri }];
                const commentCommandUri = vscode.Uri.parse(
                    `command:git.stage?${encodeURIComponent(JSON.stringify(args))}`
                );
                const contents = new vscode.MarkdownString(`[Stage file](${commentCommandUri})`);
                contents.isTrusted = true;
                return new vscode.Hover(contents);
            }
        }()
    );
}</code></pre><h3 id="新建命令"><a href="#新建命令" class="headerlink" title="新建命令"></a>新建命令</h3><hr>
<h4 id="注册一个命令"><a href="#注册一个命令" class="headerlink" title="注册一个命令"></a>注册一个命令</h4><p><a href="https://code.visualstudio.com/api/references/vscode-api#commands.registerCommand" target="_blank" rel="noopener"><code>vscode.commands.registerCommand</code></a>会把命令ID绑定到你插件的函数上：</p>
<pre><code>import * as vscode from 'vscode';
export function activate(context: vscode.ExtensionContext) {
    const command = 'myExtension.sayHello';
    const commandHandler = (name?: string = 'world') =&gt; {
        console.log(`Hello ${name}!!!`);
    };
    context.subscriptions.push(vscode.commands.registerCommand(command, commandHandler));
}</code></pre><p>只要<code>myExtension.sayHello</code>命令执行，就会调用对应的处理函数，你也可以通过<code>executeCommand</code>程序性调用它，或者从VS Code UI中，抑或快捷键的方式调用。</p>
<h4 id="创建面向用户的命令"><a href="#创建面向用户的命令" class="headerlink" title="创建面向用户的命令"></a>创建面向用户的命令</h4><p><code>vscode.commands.registerCommand</code>仅仅是将命令id绑定到了处理函数上，如果想让用户从<em>命令面板</em>中找到你的命令，你还需要在<code>package.json</code>中配置对应的命令<code>配置项(contribution)</code>：</p>
<pre><code>{
    "contributes": {
        "commands": [
            {
                "command": "myExtension.sayHello",
                "title": "Say Hello"
            }
        ]
    }
}</code></pre><p><code>commands</code>配置告诉VS Code你的插件提供了一个命令，而且允许你控制命令在UI中的显示。现在，我们的命令终于出现在<em>命令面板</em>中了：</p>
<p><img src="/images/loading.gif" data-original="../images/development/ac15f3d3bd3899033a1607d9ad850fe5.png" alt=""></p>
<p>我们依旧需要使用<code>registerCommand</code>将真实的命令id绑定到函数上。也就是说，如果我们的插件没有激活，那么用户从<em>命令面板</em>中选择<code>myExtension.sayHello</code>也不会有任何效果。为了避免这种事，插件必须注册一个面向全部用户场景的命令<code>onCommand</code> <code>activiationEvent</code>：</p>
<pre><code>{
    "activationEvents": ["onCommand:myExtension.sayHello"]
}</code></pre><p>现在当用户第一次调用<code>myExtension.sayHello</code>时，插件就会自动激活，<code>registerCommand</code>会将<code>myExtension.sayHello</code>绑定到正确的处理函数上。</p>
<p>对于内部命令你不需要使用<code>onCommand</code>，但是下面的场景中你必须定义好激活事件：</p>
<ul>
<li>需要使用<em>命令面板</em>调用</li>
<li>需要快捷键调用</li>
<li>需要通过VS Code UI调用，比如在编辑器标题栏上触发</li>
<li>意在供其他插件使用时</li>
</ul>
<h4 id="控制命令出现在命令面板的时机"><a href="#控制命令出现在命令面板的时机" class="headerlink" title="控制命令出现在命令面板的时机"></a>控制命令出现在<em>命令面板</em>的时机</h4><p>默认情况下，所有<em>命令面板</em>中出现的命令都可以在<code>package.json</code>的<code>commands</code>部分中配置。不过，有些命令是场景相关的，比如在特定的语言的编辑器中，或者只有用户设置了某些选项时才展示。</p>
<p><code>menus.commandPalette</code>发布内容配置运行你限制命令出现在<em>命令面板</em>的时机。你需要配置命令ID和一条<a href="https://code.visualstudio.com/docs/getstarted/keybindings#_when-clause-contexts" target="_blank" rel="noopener">when语句</a>：</p>
<pre><code>{
    "contributes": {
        "menus": {
            "commandPalette": [
                {
                    "command": "myExtension.sayHello",
                    "when": "editorLangId == markdown"
                }
            ]
        }
    }
}</code></pre><p>现在<code>myExtension.sayHello</code>命令只会出现在用户的Markdown文件中了。</p>
<h2 id="色彩主题-1"><a href="#色彩主题-1" class="headerlink" title="色彩主题"></a>色彩主题</h2><p>色彩可视化工作在VS Code可以分成两种类型：</p>
<ul>
<li>工作台（Workbench）色彩：在视图和编辑器中使用的工作台（Workbench）色彩，包括视图、编辑器、活动栏、状态栏等。</li>
<li>语法色彩：语法色彩就是编辑器中代码的颜色，它基于TextMate语法和TextMate主题规则进行着色。</li>
</ul>
<p>下面将分别介绍这两种类型。</p>
<h3 id="工作台色彩"><a href="#工作台色彩" class="headerlink" title="工作台色彩"></a>工作台色彩</h3><hr>
<p>创建工作台色彩最简单的方式就是使用现成的主题，然后开始定制。</p>
<ul>
<li>在VS Code中切换到你想要编辑的色彩主题。</li>
<li>打开<a href="https://code.visualstudio.com/docs/getstarted/settings" target="_blank" rel="noopener">设置</a>，用<code>workbench.colorCustomizations</code>修改视图和编辑器色彩。一般来说会即时生效，如果没有生效你需要自己重启VS Code。</li>
</ul>
<p>下面是一个改变了标题栏颜色的配置</p>
<pre><code>{
    "workbench.colorCustomizations": {
        "titleBar.activeBackground": "#ff0000"
    }
}</code></pre><h3 id="语法色彩"><a href="#语法色彩" class="headerlink" title="语法色彩"></a>语法色彩</h3><hr>
<p>新建语法高亮色彩有两种方式：</p>
<ul>
<li>直接使用社区现成的TextMate主题（<code>.tmTheme</code>文件）</li>
<li>自己想一个主题规则出来</li>
</ul>
<p>当然，还有更简单的方式：</p>
<ul>
<li>切换到色彩主题，用<a href="https://code.visualstudio.com/docs/getstarted/settings" target="_blank" rel="noopener">设置</a>中的<code>editor.tokenColorCustomizations</code>进行自定义，就像上面修改工作台色彩一样，修改会立即呈现，你不需要重启VS Code。</li>
</ul>
<p>下面的例子修改了编辑器中注释的颜色：</p>
<pre><code>{
    "editor.tokenColorCustomizations": {
        "comments": "#FF0000"
    }
}</code></pre><p>设置支持一些简单的语法标识模型，比如“comments”，“strings”，“numbers”等等。如果你想定制更多颜色，那么直接应用TextMate语法规则就可以了。</p>
<h3 id="创建新的色彩主题"><a href="#创建新的色彩主题" class="headerlink" title="创建新的色彩主题"></a>创建新的色彩主题</h3><hr>
<p>既然你已经用过<code>workbench.colorCustomizations</code>和<code>editor.tokenColorCustomizations</code>笨拙地修改过颜色，那么接下来我们可以见识见识大杀器了。</p>
<ul>
<li><p>打开<strong>命令面板</strong>输入<strong>Developer: Generate Color Theme from Current Settings</strong></p>
</li>
<li><p>使用VS Code的<a href="https://yeoman.io/" target="_blank" rel="noopener">Yeoman</a>插件生成器，生成新的主题：</p>
<pre><code>npm install -g yo generator-code
yo code</code></pre></li>
<li><p>如果你像下图这样选择了自定义主题，则选择’Start fresh’</p>
</li>
</ul>
<p><img src="/images/loading.gif" data-original="../images/development/1758bab6b5674142162310f4d43cf80e.png" alt=""></p>
<ul>
<li>把从设置中生成的主题文件复制到新的插件中</li>
<li>如果你想使用现成的TextMate主题，那你就需要在插件生成的时候选择导入TextMate主题并打包。另外，如果你下载了一个主题，那么只要用<code>.tmTheme</code>链接替换<code>tokenColors</code>部分就可以了。</li>
</ul>
<pre><code>{
    "type": "dark",
    "colors": {
        "editor.background": "#1e1e1e",
        "editor.foreground": "#d4d4d4",
        "editorIndentGuide.background": "#404040",
        "editorRuler.foreground": "#333333",
        "activityBarBadge.background": "#007acc",
        "sideBarTitle.foreground": "#bbbbbb"
    },
    "tokenColors": "./Diner.tmTheme"
}</code></pre><p>?&gt; 为你的色彩文件添加<code>.color-theme.json</code>前缀，那么你在编辑这个文件时就能自动获得悬浮提示、代码补全、色彩装饰器和色彩选择器等功能了。</p>
<p>?&gt; <a href="https://colorsublime.github.io/" target="_blank" rel="noopener">ColorSublime</a>有成百上千个现成的TextMate主题。你可以选择一个你喜欢的主题，复制下载链接，然后用Yeoman选择这个主题生成你的插件。格式如：<code>"https://raw.githubusercontent.com/Colorsublime/Colorsublime-Themes/master/themes/(name).tmTheme"</code></p>
<h3 id="测试新的主题"><a href="#测试新的主题" class="headerlink" title="测试新的主题"></a>测试新的主题</h3><hr>
<p>通过按F5打开一个插件主机开发窗口，来测试主题。</p>
<p>通过<strong>文件 &gt; 首选项 &gt; 颜色主题</strong>，在下拉菜单里找到你的主题。然后通过移动上下箭头，预览你自己的主题。</p>
<p><img src="/images/loading.gif" data-original="../images/development/a7ac8c3bb83073bdcdea0b86e5b21603.png" alt=""></p>
<p>主题文件的改动，会实时同步到<code>插件开发主机</code>窗口。</p>
<h3 id="将主题发布到插件市场"><a href="#将主题发布到插件市场" class="headerlink" title="将主题发布到插件市场"></a>将主题发布到插件市场</h3><hr>
<p>如果你想把主题分享给社区，通过<a href="https://code.visualstudio.com/docs/editor/extension-gallery" target="_blank" rel="noopener">插件市场</a>去发布它吧。用vsce publishing tool打包你的主题然后发布到VS Code市场。</p>
<p>?&gt; 小贴士：想要用户轻松地找到你的主题，最好修改一下<code>package.json</code>，把关键字”theme”写到插件描述（extension description）中，然后把<code>Category</code>设置为<code>Theme</code></p>
<h3 id="添加新的色彩id"><a href="#添加新的色彩id" class="headerlink" title="添加新的色彩id"></a>添加新的色彩id</h3><hr>
<p>色彩配置点可以配置插件的<em>色彩id</em>，当在<code>workbench.colorCustomizations</code>和主题文件中使用代码补全时，这些色彩也会出现。用户可以在插件配置选项卡中看到插件定义了什么颜色。</p>
<h3 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h3><ul>
<li><a href="https://css-tricks.com/creating-a-vs-code-theme/" target="_blank" rel="noopener">CSS Tricks - 新建一个VS Code主题</a></li>
</ul>
<h2 id="图标主题-1"><a href="#图标主题-1" class="headerlink" title="图标主题"></a>图标主题</h2><p>VS Code的UI在文件名称左边显示图标，插件配置的图标系列可以让用户自由选择他们喜爱的图标。</p>
<h3 id="添加新的图标主题"><a href="#添加新的图标主题" class="headerlink" title="添加新的图标主题"></a>添加新的图标主题</h3><hr>
<p>你能使用图标文件（最好是SVG）和字体图标创建自己的图标主题。作为示例，你可以参考一下2个内置主题：<a href="https://github.com/Microsoft/vscode/tree/master/extensions/theme-defaults" target="_blank" rel="noopener">Minimal</a>，<a href="https://github.com/Microsoft/vscode/tree/master/extensions/theme-seti" target="_blank" rel="noopener">Seti</a></p>
<p>首先，创建一个VS Code插件，然后把<code>iconTheme</code>配置点(contribution point)添加进去</p>
<pre><code>"contributes": {
    "iconThemes": [
        {
            "id": "turtles",
            "label": "Turtles",
            "path": "./fileicons/turtles-icon-theme.json"
        }
    ]
}</code></pre><ul>
<li><code>id</code>作为这个图标主题的标识，目前只做内部使用，未来可能会用在设置里面，所以最好设置一个可读性强的唯一值。</li>
<li><code>label</code>会显示在<em>主题选择</em>下拉框中。</li>
<li><code>path</code>指示了图标集所在的位置。如果你的图标系列名称遵循<code>*icon-theme.json</code>命名规范，那么VS Code就能提供完整的支持。</li>
</ul>
<h3 id="图标文件集-Icon-set-file"><a href="#图标文件集-Icon-set-file" class="headerlink" title="图标文件集(Icon set file)"></a>图标文件集(Icon set file)</h3><p>图标文件集是一个JSON文件，包含了所有的<strong>关联图标</strong>和图标定义。</p>
<p>一个<strong>关联图标</strong>将<strong>图标定义</strong>映射到一个文件上（类型如：文件，文件夹，json文件…）。<strong>图标定义</strong>指示了图标的所在位置：可以是一个图片文件，或者glyph字体。</p>
<h3 id="图标定义"><a href="#图标定义" class="headerlink" title="图标定义"></a>图标定义</h3><p><code>iconDefinitions</code>部分包含了所有定义。每个定义有一个id，用于指向定义。一个定义能供多个文件关联引用。</p>
<pre><code>"iconDefinitions": {
    "_folder_dark": {
        "iconPath": "./images/Folder_16x_inverse.svg"
    }
}</code></pre><p>这里，<strong>图标定义</strong>包含了一个标识符<code>_folder_dark</code>。除此之外还支持以下属性：</p>
<ul>
<li><code>iconPath</code>：当使用svg/png文件时：指向图片的路径。</li>
<li><code>fontCharacter</code>：当使用glyph字体时：字体中使用的字符。</li>
<li><code>fontColor</code>：当使用glyph字体时：设置glyph的颜色。</li>
<li><code>fontSize</code>：当使用字体时：设置字体大小。默认情况下会使用字体本身定义的字体大小。这个值应为父级字号的相对值(如 150%)。</li>
<li><code>fontId</code>：当使用字体时: 字体的ID。如果没有指定，则会采用<code>font specification</code>部分的第一个字体。</li>
</ul>
<h3 id="关联文件"><a href="#关联文件" class="headerlink" title="关联文件"></a>关联文件</h3><p>图标能关联到文件夹，文件夹名称，文件，文件名称，文件插件，和语言Id。</p>
<p>这些关联都能被提炼为诸如’light’和’highContrast’色彩主题。</p>
<p>每个文件关联指向一个<strong>图标定义</strong></p>
<pre><code>"file": "_file_dark",
"folder": "_folder_dark",
"folderExpanded": "_folder_open_dark",
"folderNames": {
    ".vscode": "_vscode_folder",
},
"fileExtensions": {
    "ini": "_ini_file",
},
"fileNames": {
    "win.ini": "_win_ini_file",
},
"languageIds": {
    "ini": "_ini_file"
},
"light": {
    "folderExpanded": "_folder_open_light",
    "folder": "_folder_light",
    "file": "_file_light",
    "fileExtensions": {
        "ini": "_ini_file_light",
    }
},
"highContrast": {
}</code></pre><ul>
<li><code>file</code>是一个默认文件图标，为那些没有匹配到任何插件、文件名、语言类型的文件所准备的。目前所有文件图标属性都会被继承(只适用于：glyphs字体、字体大小(fontSize))。</li>
<li><code>folder</code>收起的文件夹图标，如果<code>folderExpanded</code>没有设置，那么展开的文件夹也会使用这个图标。使用<code>folderNames</code>关联特殊名称的文件夹。文件夹图标是可选的，如果不设置，那文件夹就不会显示任何图标。</li>
<li><code>folderExpanded</code>展开的文件夹图标。这个图标是可选的，如果不设置就会使用<code>folder</code>定义好的图标。</li>
<li><code>folderNames</code>特殊名称文件夹图标。这个键是用于文件夹名称的，不支持包含路径的名称，不支持匹配模式和通配符。大小写不敏感。</li>
<li><code>folderNamesExpanded</code>展开的特殊名称文件夹图标。</li>
<li><code>rootFolder</code> 收起的工作区根文件夹图标，如果<code>rootFolderExpanded</code>没有设置，那么展开的工作区根文件夹也会使用这个图标。如果不设置，则会使用<code>folder</code>定义的文件夹图标。</li>
<li><code>rootFolderExpanded</code> 展开的工作区根文件夹图标。如果没有设置，则会使用<code>rootFolder</code>定义的文件夹图标。</li>
<li><code>languageIds</code>语言类型图标。这个键将匹配在<em>语言配置点（contribution point）</em>配置的语言id。注意语言配置的’第一行’是不考虑在内的。</li>
<li><code>fileExtensions</code>文件插件图标。根据文件插件的名称匹配。插件名称是文件名点号后面（不包含点号）。拥有多重点号的文件名称，如<code>lib.d.ts</code>会匹配多个模式——<code>d.ts</code>和<code>ts</code>。大小写敏感。</li>
<li><code>fileNames</code>文件图标。这个键需要文件的全称进行匹配，不支持包含路径的名称，不支持模式和通配符。大小写敏感。<code>fileNames</code>是最高优先匹配。</li>
</ul>
<p>匹配优先级：<code>fileNames</code> &gt; <code>fileExtensions</code> &gt; <code>languageIds</code></p>
<p><code>light</code>和<code>highContrast</code>部分的属性表和上面相同，只是会在对应的主题下覆盖原有图标配置。</p>
<h3 id="字体定义"><a href="#字体定义" class="headerlink" title="字体定义"></a>字体定义</h3><p>在’font’部分添加任意你喜欢的字形和字体。定义好之后，你就可以在图标定义中使用它们了。如果没有指定字体id，那么默认使用第一个定义的字体。</p>
<p>将字体文件移动到你的插件中，设置好对应的路径。推荐使用<a href="https://developer.mozilla.org/zh-CN/docs/WOFF" target="_blank" rel="noopener">WOFF</a>字体。</p>
<ul>
<li>设置格式为’woff’</li>
<li>字重键值的定义参考<a href="https://developer.mozilla.org/docs/Web/CSS/font-weight#Values" target="_blank" rel="noopener">这里</a></li>
<li>样式键值对的定义参考在<a href="https://developer.mozilla.org/docs/Web/CSS/@font-face/font-style#Values" target="_blank" rel="noopener">这里</a></li>
<li>使用图标引用该字体时的字号。因此字体字号总是以百分比表示。</li>
</ul>
<pre><code>"fonts": [
    {
        "id": "turtles-font",
        "src": [
            {
                "path": "./turtles.woff",
                "format": "woff"
            }
        ],
        "weight": "normal",
        "style": "normal",
        "size": "150%"
    }
],
"iconDefinitions": {
    "_file": {
        "fontCharacter": "\\E002",
        "fontColor": "#5f8b3b",
        "fontId": "turtles-font"
    }
}</code></pre><h3 id="图标主题中的文件夹图标"><a href="#图标主题中的文件夹图标" class="headerlink" title="图标主题中的文件夹图标"></a>图标主题中的文件夹图标</h3><p>文件图标主题会告诉文件浏览器不要显示默认文件夹图标（倒三角或者横杠），这个模式可在配置中加入<code>"hidesExplorerArrows":true</code>覆盖默认VS Code的设置。</p>
<h2 id="树视图-1"><a href="#树视图-1" class="headerlink" title="树视图"></a>树视图</h2><p>本节将教你如何为VS Code添加<em>视图容器</em>和<em>树视图</em>的插件，示例插件的源代码请查看<a href="https://github.com/Microsoft/vscode-extension-samples/tree/master/tree-view-sample。" target="_blank" rel="noopener">https://github.com/Microsoft/vscode-extension-samples/tree/master/tree-view-sample。</a></p>
<h3 id="视图容器-1"><a href="#视图容器-1" class="headerlink" title="视图容器"></a>视图容器</h3><hr>
<p><em>视图容器</em>包含了一列<em>视图(views)</em>，这些<em>视图</em>又包含在内置的<em>视图容器</em>中。</p>
<p><img src="/images/loading.gif" data-original="../images/development/ce00849fe0fd21034e79861492ab10c3.png" alt=""></p>
<p>要想配置一个视图容器，你首先得注册<code>package.json</code>中的<code>contributes.viewsContainers</code>。你还必须配置以下字段：</p>
<ul>
<li><code>id</code>: 新视图容器的名称</li>
<li><code>title</code>: 展示给用户的视图容器名称，它会显示在视图容器上方</li>
<li><code>icon</code>: 在活动栏中展示的图标</li>
</ul>
<pre><code>"contributes": {
  "viewsContainers": {
    "activitybar": [
      {
        "id": "package-explorer",
        "title": "Package Explorer",
        "icon": "media/dep.svg"
      }
    ]
  }
}</code></pre><h3 id="树视图-2"><a href="#树视图-2" class="headerlink" title="树视图"></a>树视图</h3><hr>
<p><em>视图</em>是显示在视图容器中的UI片段。使用<code>contributes.views</code>进行配置，你就可以将新的<em>视图</em>添加到内置或者你配置好的视图容器中了。</p>
<p><img src="/images/loading.gif" data-original="../images/development/view.png" alt=""></p>
<p>要想配置一个<em>视图</em>，你首先得注册<code>package.json</code>中的<code>contributes.views</code>。你必须给<em>视图</em>配置一个ID外加一个名称，你还可以配置<em>视图</em>出现的位置：</p>
<ul>
<li><code>explorer</code>: 显示在资源管理器侧边栏</li>
<li><code>debug</code>: 显示在调试侧边栏</li>
<li><code>scm</code>: 显示在源代码侧边栏</li>
<li><code>test</code>: 测试侧边栏中的资源管理器视图</li>
<li>显示在你定义好的<em>视图容器</em>中</li>
</ul>
<pre><code>"contributes": {
  "views": {
    "package-explorer": [
      {
        "id": "nodeDependencies",
        "name": "Node Dependencies",
        "when": "explorer"
      }
    ]
  }
}</code></pre><p>当用户打开了对应的视图，VS Code会触发<code>onView:${viewId}</code>事件(如上面例子中，这个事件写为<code>onView:nodeDependencies</code>)。你也可以通过配置<code>when</code>字段控制视图的展示。</p>
<h3 id="视图的操作"><a href="#视图的操作" class="headerlink" title="视图的操作"></a>视图的操作</h3><hr>
<p>你可以配置<em>视图</em>下述位置的操作：</p>
<ul>
<li><code>view/title</code>: <em>视图</em>标题位置显示的操作。这里可以配置主要的操作，使用<code>"group": "navigation"</code>进行配置，剩余的二级操作则出现在<code>...</code>菜单中。</li>
<li><code>view/item/context</code>: 每个<em>视图项</em>的操作。这里可以配置主要的操作，使用<code>"group": "inline"</code>，剩余的二级操作则出现在<code>...</code>菜单中。</li>
</ul>
<p>使用<code>when</code>属性控制这些操作的展示。</p>
<p><img src="/images/loading.gif" data-original="../images/development/11f85ec0816b83d978832d66127831a3.png" alt=""></p>
<p>例如：</p>
<pre><code>"contributes": {
  "commands": [
    {
      "command": "nodeDependencies.refreshEntry",
      "title": "Refresh",
      "icon": {
        "light": "resources/light/refresh.svg",
        "dark": "resources/dark/refresh.svg"
      }
    },
    {
      "command": "nodeDependencies.addEntry",
      "title": "Add"
    },
    {
      "command": "nodeDependencies.editEntry",
      "title": "Edit",
      "icon": {
        "light": "resources/light/edit.svg",
        "dark": "resources/dark/edit.svg"
      }
    },
    {
      "command": "nodeDependencies.deleteEntry",
      "title": "Delete"
    }
  ],
  "menus": {
    "view/title": [
      {
        "command": "nodeDependencies.refreshEntry",
        "when": "view == nodeDependencies",
        "group": "navigation"
      },
      {
        "command": "nodeDependencies.addEntry",
        "when": "view == nodeDependencies"
      }
    ],
    "view/item/context": [
      {
        "command": "nodeDependencies.editEntry",
        "when": "view == nodeDependencies &amp;&amp; viewItem == dependency",
        "group": "inline"
      },
      {
        "command": "nodeDependencies.deleteEntry",
        "when": "view == nodeDependencies &amp;&amp; viewItem == dependency"
      }
    ]
  }
}</code></pre><p>!&gt; <strong>注意</strong>：如果你需要针对特定的条目显示特殊的操作，定义树视图项的<code>TreeItem.contextValue</code>，并且在<code>when</code>中使用表达式，视图项的值储存在表达式的<code>viewItem</code>中。</p>
<p>如：</p>
<pre><code>"contributes": {
  "menus": {
    "view/item/context": [
      {
        "command": "nodeDependencies.deleteEntry",
        "when": "view == nodeDependencies &amp;&amp; viewItem == dependency"
      }
    ]
  }
}</code></pre><h3 id="为树视图提供数据"><a href="#为树视图提供数据" class="headerlink" title="为树视图提供数据"></a>为树视图提供数据</h3><hr>
<p>插件创作者需要注册<a href="https://code.visualstudio.com/api/references/vscode-api#TreeDataProvider" target="_blank" rel="noopener"><code>TreeDataProvider</code></a>，以便动态生成<em>视图</em>中的数据。</p>
<pre><code>vscode.window.registerTreeDataProvider('nodeDependencies', new DepNodeProvider());</code></pre><p>更多实现请参考<a href="https://github.com/Microsoft/vscode-extension-samples/tree/master/tree-view-sample/src/nodeDependencies.ts" target="_blank" rel="noopener">nodeDependencies.ts</a></p>
<h3 id="动态创建树视图"><a href="#动态创建树视图" class="headerlink" title="动态创建树视图"></a>动态创建树视图</h3><hr>
<p>如果你想在<em>视图</em>中通过编程手段创建一些操作，你就不能再注册<code>window.registerTreeDataProvider</code>了，而是<code>window.createTreeView</code>，这样一来你就有权限提供你喜欢的视图操作了：</p>
<pre><code>vscode.window.createTreeView('ftpExplorer', {  treeDataProvider: new FtpTreeDataProvider()});</code></pre><p>更多实现请参考<a href="https://github.com/Microsoft/vscode-extension-samples/tree/master/tree-view-sample/src/ftpExplorer.ts" target="_blank" rel="noopener">ftpExplorer.ts</a></p>
<h2 id="Webview-API"><a href="#Webview-API" class="headerlink" title="Webview API"></a>Webview API</h2><p>webview API为开发者提供了完全自定义视图的能力，例如内置的Markdown插件使用了webview渲染Markdown预览文件。Webview也能用于构建比VS Code原生API支持构建的更加复杂的用户交互界面。</p>
<p>可以把webview看成是VS Code中的<code>iframe</code>，它可以渲染几乎全部的HTML内容，它通过消息机制和插件通信。这样的自由度令我们的webview非常强劲并将插件的潜力提升到了新的高度。</p>
<h3 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h3><hr>
<ul>
<li><a href="https://github.com/Microsoft/vscode-extension-samples/blob/master/webview-sample/README.md" target="_blank" rel="noopener">Webview 示例</a></li>
</ul>
<h4 id="使用的VS-Code-API"><a href="#使用的VS-Code-API" class="headerlink" title="使用的VS Code API"></a>使用的VS Code API</h4><ul>
<li><a href="https://code.visualstudio.com/api/references/vscode-api#window.createWebviewPanel" target="_blank" rel="noopener">window.createWebviewPanel</a></li>
<li><a href="https://code.visualstudio.com/api/references/vscode-api#window.registerWebviewPanelSerializer" target="_blank" rel="noopener">window.registerWebviewPanelSerializer</a></li>
</ul>
<h3 id="我应该用webview吗？"><a href="#我应该用webview吗？" class="headerlink" title="我应该用webview吗？"></a>我应该用webview吗？</h3><hr>
<p>webview虽然很赞，但是我们应该节制地使用这个功能——比如当VS Code原生API不够用时。Webview重度依赖资源，所以它脱离插件的进程而单独运行在其他环境中。在VS Code中使用设计不良的webview会让用户抓狂。</p>
<p>在使用webview之前，请作以下考虑：</p>
<ul>
<li>这个功能真的需要VS Code来提供吗？分离成一个应用或者网站会不会更好？</li>
<li>webview是实现这个特性的最后方案吗？VS Code原生API是否能达到同样的目的呢？</li>
<li>你的webview所牺牲的高资源占用是否能换得同样的用户价值？</li>
</ul>
<p>请记住：不要因为能使用webview而滥用webview。相反，如果你有充足的理由和自信，那么本篇教程对你来说会非常有用，现在就让我们开始吧。</p>
<h3 id="Webviews-API-基础"><a href="#Webviews-API-基础" class="headerlink" title="Webviews API 基础"></a>Webviews API 基础</h3><hr>
<p>为了解释webviewAPI，我们先构建一个简单的<strong>Cat Coding</strong>插件。这个插件会用一个webview显示猫写代码的gif。随着我们不断了解API，我们会不断地给插件添加功能，包括我们的猫写了多少行代码的计数跟踪器，如果猫猫写出了bug还会有一个提示弹出框。</p>
<p>这是<strong>Cat Coding</strong>插件的第一版<code>package.json</code>，你可以在<a href="https://github.com/Microsoft/vscode-extension-samples/blob/master/webview-sample/README.md" target="_blank" rel="noopener">这里</a>找到完整的代码。我们的第一版插件提供了一个命令，叫做<code>catCoding.start</code>。当用户从<strong>命令面板</strong>调用<em>Cat Coding: Start new cat coding session</em>，或者一个创建好的<em>键绑定</em>命令，我们的猫猫会出现在webview窗口内。</p>
<pre><code>{
  "name": "cat-coding",
  "description": "Cat Coding",
  "version": "0.0.1",
  "publisher": "bierner",
  "engines": {
    "vscode": "^1.23.0"
  },
  "activationEvents": ["onCommand:catCoding.start"],
  "main": "./out/src/extension",
  "contributes": {
    "commands": [
      {
        "command": "catCoding.start",
        "title": "Start new cat coding session",
        "category": "Cat Coding"
      }
    ]
  },
  "scripts": {
    "vscode:prepublish": "tsc -p ./",
    "compile": "tsc -watch -p ./",
    "postinstall": "node ./node_modules/vscode/bin/install"
  },
  "dependencies": {
    "vscode": "*"
  },
  "devDependencies": {
    "@types/node": "^9.4.6",
    "typescript": "^2.8.3"
  }
}</code></pre><p>现在让我们实现<code>catCoding.start</code>命令，在我们的主文件中，像下面这样注册一个基础的webview：</p>
<pre><code>import * as vscode from 'vscode';
export function activate(context: vscode.ExtensionContext) {
  context.subscriptions.push(
    vscode.commands.registerCommand('catCoding.start', () =&gt; {
      // 创建并显示新的webview
      const panel = vscode.window.createWebviewPanel(
        'catCoding', // 只供内部使用，这个webview的标识
        'Cat Coding', // 给用户显示的面板标题
        vscode.ViewColumn.One, // 给新的webview面板一个编辑器视图
        {} // Webview选项。我们稍后会用上
      );
    })
  );
}</code></pre><p><code>vscode.window.createWebviewPanel</code>函数创建并在编辑区展示了一个webview，下图显示了如果你试着运行<code>catCoding.start</code>命令会显示的东西：</p>
<p><img src="/images/loading.gif" data-original="../images/development/08b3020ccda1d57f14212c25e8926abe.png" alt=""></p>
<p>我们的命令以正确的标题打开了一个新的webview面板，但是没有任何内容！要想把我们的猫加到这个面板里面，我们需要<code>webview.html</code>设置HTML内容。</p>
<pre><code>import * as vscode from 'vscode';
export function activate(context: vscode.ExtensionContext) {
  context.subscriptions.push(
    vscode.commands.registerCommand('catCoding.start', () =&gt; {
      // 创建和显示webview
      const panel = vscode.window.createWebviewPanel(
        'catCoding',
        'Cat Coding',
        vscode.ViewColumn.One,
        {}
      );
      // 设置HTML内容
      panel.webview.html = getWebviewContent();
    })
  );
}
function getWebviewContent() {
  return
    `
        &lt;!DOCTYPE html&gt;
        &lt;html lang="en"&gt;
        &lt;head&gt;
            &lt;meta charset="UTF-8"&gt;
            &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
            &lt;title&gt;Cat Coding&lt;/title&gt;
        &lt;/head&gt;
        &lt;body&gt;
            &lt;img src="https://media.giphy.com/media/JIX9t2j0ZTN9S/giphy.gif" width="300" /&gt;
        &lt;/body&gt;
        &lt;/html&gt;
    `;
}</code></pre><p>如果你再次运行命令，应该能看到下图：</p>
<p><img src="/images/loading.gif" data-original="../images/development/d880aa929d45fdf9b55cd623e7e880d4.png" alt=""></p>
<p>大功告成！</p>
<p><code>webview.html</code>应该是一个完整的HTML文档。使用HTML片段或者格式错乱的HTML会造成异常。</p>
<h4 id="更新webview内容"><a href="#更新webview内容" class="headerlink" title="更新webview内容"></a>更新webview内容</h4><p><code>webview.html</code>也能在webview创建后更新内容，让我们用猫猫轮播图使<strong>Cat Coding</strong>具有动态性：</p>
<pre><code>import * as vscode from 'vscode';
const cats = {
  'Coding Cat': 'https://media.giphy.com/media/JIX9t2j0ZTN9S/giphy.gif',
  'Compiling Cat': 'https://media.giphy.com/media/mlvseq9yvZhba/giphy.gif'
};
export function activate(context: vscode.ExtensionContext) {
  context.subscriptions.push(
    vscode.commands.registerCommand('catCoding.start', () =&gt; {
      const panel = vscode.window.createWebviewPanel(
        'catCoding',
        'Cat Coding',
        vscode.ViewColumn.One,
        {}
      );
      let iteration = 0;
      const updateWebview = () =&gt; {
        const cat = iteration++ % 2 ? 'Compiling Cat' : 'Coding Cat';
        panel.title = cat;
        panel.webview.html = getWebviewContent(cat);
      };
      // 设置初始化内容
      updateWebview();
      // 每秒更新内容
      setInterval(updateWebview, 1000);
    })
  );
}
function getWebviewContent(cat: keyof typeof cats) {
  return
    `
        &lt;!DOCTYPE html&gt;
        &lt;html lang="en"&gt;
        &lt;head&gt;
            &lt;meta charset="UTF-8"&gt;
            &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
            &lt;title&gt;Cat Coding&lt;/title&gt;
        &lt;/head&gt;
        &lt;body&gt;
            &lt;img src="${cats[cat]}" width="300" /&gt;
        &lt;/body&gt;
        &lt;/html&gt;
    `;
}</code></pre><p><img src="/images/loading.gif" data-original="../images/development/basics-update.gif" alt=""></p>
<p>因为<code>webview.html</code>方法替换了整个webview内容，页面看起来像重新加载了一个iframe。记住：如果你在webview中使用了脚本，那就意味着<code>webview.html</code>的重置会使脚本状态重置。</p>
<p>上述示例也使用了<code>webview.title</code>改变编辑器中的展示的文件名称，设置标题不会使webview重载。</p>
<h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><p>webview从属于创建他们的插件，插件必须保持住从webview返回的<code>createWebviewPanel</code>。如果你的插件失去了这个关联，它就不能再访问webview了，不过即使这样，webview还会继续展示在VS Code中。</p>
<p>因为webview是一个文本编辑器视图，所以用户可以随时关闭webview。当用户关闭了webview面板后，webview就被销毁了。在我们的例子中，销毁webview时抛出了一个异常，说明我们上面的示例中使用的<code>seInterval</code>实际上产生了非常严重的Bug：如果用户关闭了面板，<code>setInterval</code>会继续触发，而且还会尝试更新<code>panel.webview.html</code>，这当然会抛出异常。喵星人可不喜欢异常，我们现在就来解决这个问题吧。</p>
<p><code>onDidDispose</code>事件在webview被销毁时触发，我们在这个事件结束之后更新并释放webview资源。</p>
<pre><code>import * as vscode from 'vscode';
const cats = {
  'Coding Cat': 'https://media.giphy.com/media/JIX9t2j0ZTN9S/giphy.gif',
  'Compiling Cat': 'https://media.giphy.com/media/mlvseq9yvZhba/giphy.gif'
};
export function activate(context: vscode.ExtensionContext) {
  context.subscriptions.push(
    vscode.commands.registerCommand('catCoding.start', () =&gt; {
      const panel = vscode.window.createWebviewPanel(
        'catCoding',
        'Cat Coding',
        vscode.ViewColumn.One,
        {}
      );
      let iteration = 0;
      const updateWebview = () =&gt; {
        const cat = iteration++ % 2 ? 'Compiling Cat' : 'Coding Cat';
        panel.title = cat;
        panel.webview.html = getWebviewContent(cat);
      };
      updateWebview();
      const interval = setInterval(updateWebview, 1000);
      panel.onDidDispose(
        () =&gt; {
          // 当面板关闭时，取消webview内容之后的更新
          clearInterval(interval);
        },
        null,
        context.subscriptions
      );
    })
  );
}</code></pre><p>插件也可以通过编程方式关闭webview视图——调用它们的<code>dispose()</code>方法。我们假设，现在限制我们的猫猫每天工作5秒钟：</p>
<pre><code>export function activate(context: vscode.ExtensionContext) {
  context.subscriptions.push(
    vscode.commands.registerCommand('catCoding.start', () =&gt; {
      const panel = vscode.window.createWebviewPanel(
        'catCoding',
        'Cat Coding',
        vscode.ViewColumn.One,
        {}
      );
      panel.webview.html = getWebviewContent(cats['Coding Cat']);
      // 5秒后，程序性地关闭webview面板
      const timeout = setTimeout(() =&gt; panel.dispose(), 5000);
      panel.onDidDispose(
        () =&gt; {
          // 在第五秒结束之前处理用户手动的关闭动作
          clearTimeout(timeout);
        },
        null,
        context.subscriptions
      );
    })
  );
}</code></pre><h4 id="移动和可见性"><a href="#移动和可见性" class="headerlink" title="移动和可见性"></a>移动和可见性</h4><p>当webview面板被移动到了非激活标签上，它就隐藏起来了。但这时并不是销毁，当重新激活标签后，VS Code会从<code>webview.html</code>自动恢复webview的内容。</p>
<p><img src="/images/loading.gif" data-original="../images/development/basics-restore.gif" alt=""></p>
<p><code>.visible</code>属性告诉你当前webview面板是否是可见的。</p>
<p>插件也可以通过调用<code>reveal()</code>方法，程序性地将webview面板激活。这个方法可以接受一个用于放置面板的目标视图布局。一个面板一次只能显示在一个编辑布局中。调用<code>reveal()</code>或者拖动webview面板到新的编辑布局中去。</p>
<p><img src="/images/loading.gif" data-original="https://static.sitestack.cn/projects/VS-Code-Extension-Doc-ZH/e485d3c3e56f2cca65cfb5a564632480.gif" alt=""></p>
<p>现在更新我们的插件，一次只允许存在一个webview视图。如果面板处于非激活状态，那<code>catCoding.start</code>命令就把这个面板激活。</p>
<pre><code>export function activate(context: vscode.ExtensionContext) {
  // 追踪当前webview面板
  let currentPanel: vscode.WebviewPanel | undefined = undefined;
  context.subscriptions.push(
    vscode.commands.registerCommand('catCoding.start', () =&gt; {
      const columnToShowIn = vscode.window.activeTextEditor
        ? vscode.window.activeTextEditor.viewColumn
        : undefined;
      if (currentPanel) {
        // 如果我们已经有了一个面板，那就把它显示到目标列布局中
        currentPanel.reveal(columnToShowIn);
      } else {
        // 不然，创建一个新面板
        currentPanel = vscode.window.createWebviewPanel(
          'catCoding',
          'Cat Coding',
          columnToShowIn,
          {}
        );
        currentPanel.webview.html = getWebviewContent(cats['Coding Cat']);
        // 当前面板被关闭后重置
        currentPanel.onDidDispose(
          () =&gt; {
            currentPanel = undefined;
          },
          null,
          context.subscriptions
        );
      }
    })
  );
}</code></pre><p>下面是一个新插件的行为：</p>
<p><img src="/images/loading.gif" data-original="../images/development/62651359ccf00c8ef99ddd8170194ffc.gif" alt=""></p>
<p>不论何时，如果webview的可见性改变了，或者当webview移动到了新的视图布局中，就会触发<code>onDidChangeViewState</code>。我们的插件可以利用这个时间改变布局中的webview显示的猫：</p>
<pre><code>const cats = {
  'Coding Cat': 'https://media.giphy.com/media/JIX9t2j0ZTN9S/giphy.gif',
  'Compiling Cat': 'https://media.giphy.com/media/mlvseq9yvZhba/giphy.gif',
  'Testing Cat': 'https://media.giphy.com/media/3oriO0OEd9QIDdllqo/giphy.gif'
};
export function activate(context: vscode.ExtensionContext) {
  context.subscriptions.push(
    vscode.commands.registerCommand('catCoding.start', () =&gt; {
      const panel = vscode.window.createWebviewPanel(
        'catCoding',
        'Cat Coding',
        vscode.ViewColumn.One,
        {}
      );
      panel.webview.html = getWebviewContent(cats['Coding Cat']);
      // 根据视图状态变动更新内容
      panel.onDidChangeViewState(
        e =&gt; {
          const panel = e.webviewPanel;
          switch (panel.viewColumn) {
            case vscode.ViewColumn.One:
              updateWebviewForCat(panel, 'Coding Cat');
              return;
            case vscode.ViewColumn.Two:
              updateWebviewForCat(panel, 'Compiling Cat');
              return;
            case vscode.ViewColumn.Three:
              updateWebviewForCat(panel, 'Testing Cat');
              return;
          }
        },
        null,
        context.subscriptions
      );
    })
  );
}
function updateWebviewForCat(panel: vscode.WebviewPanel, catName: keyof typeof cats) {
  panel.title = catName;
  panel.webview.html = getWebviewContent(cats[catName]);
}</code></pre><p><img src="/images/loading.gif" data-original="../images/development/basics-ondidchangeviewstate.gif" alt=""></p>
<h4 id="检查和调试webviews"><a href="#检查和调试webviews" class="headerlink" title="检查和调试webviews"></a>检查和调试webviews</h4><p>在命令面板中输入<strong>Developer: Toggle Developer Tools</strong>能帮助你调试webview。运行命令之后会为当前可见的webview加载一个devtool：</p>
<p><img src="/images/loading.gif" data-original="../images/development/a4526c670d7d41753f8c9141e42d9d3e.png" alt=""></p>
<p>webview的内容是在webview文档中的一个iframe中的，用开发者工具检查和修改webview的DOM，在webview内调试脚本。</p>
<p>如果你用了webview开发者工具的console，确保你在Console面板左上角的下拉框里选中了当前<strong>激活窗体</strong>环境：</p>
<p><img src="/images/loading.gif" data-original="../images/development/dccc5a34084408288c435084eac3bd37.png" alt=""></p>
<p><strong>激活窗体</strong>环境是webview脚本执行的地方。</p>
<p>另外，<strong>Developer: Reload Webview</strong>命令会刷新所有已激活的webview。如果你需要重置一个webview的状态，这个命令会非常有用，或者你想要读取硬盘内容的webview更新一下，也可以使用这个方法。</p>
<h3 id="加载本地内容"><a href="#加载本地内容" class="headerlink" title="加载本地内容"></a>加载本地内容</h3><hr>
<p>webview运行在独立的环境中，因此不能直接访问本地资源，这是出于安全性考虑的做法。这也意味着要想从你的插件中加载图片、样式等其他资源，或是从用户当前的工作区加载任何内容的话，你必须使用webview中的<code>vscode-resource:</code>协议。</p>
<p><code>vscode-resource:</code>协议就像<code>file:</code>协议一样，不过它只允许访问本地文件。和<code>file:</code>一样的是，<code>vscode-resource:</code>只能从绝对路径中加载资源。</p>
<p>想想一下，我们想要从本地把喵喵们的gif打包进来，而不是从Giphy（国外出名的gif收集站）里加载进来。要想做到这点，我们首先给本地文件新建一个URI，然后用<code>vscode-resource:</code>协议更新这些URI：</p>
<pre><code>import * as vscode from 'vscode';
import * as path from 'path';
export function activate(context: vscode.ExtensionContext) {
  context.subscriptions.push(
    vscode.commands.registerCommand('catCoding.start', () =&gt; {
      const panel = vscode.window.createWebviewPanel(
        'catCoding',
        'Cat Coding',
        vscode.ViewColumn.One,
        {}
      );
      // 获取磁盘上的资源路径
      const onDiskPath = vscode.Uri.file(
        path.join(context.extensionPath, 'media', 'cat.gif')
      );
      // 获取在webview中使用的特殊URI
      const catGifSrc = onDiskPath.with({ scheme: 'vscode-resource' });
      panel.webview.html = getWebviewContent(catGifSrc);
    })
  );
}</code></pre><p><code>catGifSrc</code>的值最后会像这样：</p>
<pre><code>vscode-resource:/Users/toonces/projects/vscode-cat-coding/media/cat.gif</code></pre><p>默认情况下，<code>scode-resource:</code>只能访问下列地址的资源：</p>
<ul>
<li>你的插件安装的目录</li>
<li>用户当前激活的工作区</li>
</ul>
<p>你也可以用data URI将资源直接嵌套到webview中去。</p>
<h4 id="控制本地资源访问"><a href="#控制本地资源访问" class="headerlink" title="控制本地资源访问"></a>控制本地资源访问</h4><p>使用<code>localResourceRoots</code>选项，webview可以控制<code>vscode-resource:</code>加载的的资源。 <code>localResourceRoots</code>定义了可能被加载的本地内容的根URI。</p>
<p>我们用<code>localResourceRoots</code>去约束<strong>Cat Coding</strong>webview只加载我们插件的<code>media</code>目录下的内容：</p>
<pre><code>import * as vscode from 'vscode';
import * as path from 'path';
export function activate(context: vscode.ExtensionContext) {
  context.subscriptions.push(
    vscode.commands.registerCommand('catCoding.start', () =&gt; {
      const panel = vscode.window.createWebviewPanel(
        'catCoding',
        'Cat Coding',
        vscode.ViewColumn.One,
        {
          // 只允许webview加载我们插件的`media`目录下的资源
          localResourceRoots: [vscode.Uri.file(path.join(context.extensionPath, 'media'))]
        }
      );
      const onDiskPath = vscode.Uri.file(
        path.join(context.extensionPath, 'media', 'cat.gif')
      );
      const catGifSrc = onDiskPath.with({ scheme: 'vscode-resource' });
      panel.webview.html = getWebviewContent(catGifSrc);
    })
  );
}</code></pre><p>为了禁止所有的本地资源，只要把<code>localResourceRoots</code>设为<code>[]</code>就好了。</p>
<p>通常来说，webview应该和加载本地资源一样严格，然而，<code>vscode-resource</code>和<code>localResourceRoots</code>并不保证百分百的安全性。请确保你的webview遵循安全性最佳实践，强烈建议考虑添加一个内容安全政策以便约束之后加载的内容。</p>
<h4 id="给webview内容加上主题"><a href="#给webview内容加上主题" class="headerlink" title="给webview内容加上主题"></a>给webview内容加上主题</h4><p>webview可以基于当前的VS Code主题和CSS改变自身的样式。VS Code将主题分成3中类别，而且在<code>body</code>元素上加上了特殊类名以表明当前主题：</p>
<ul>
<li><code>vscode-light</code>——亮色主题</li>
<li><code>vscode-dark</code>——暗色主题</li>
<li><code>vscode-high-contrast</code>——高反差主题</li>
</ul>
<p>下列CSS改变了基于用户当前主题的webview字体颜色：</p>
<pre><code>body.vscode-light {
  color: black;
}
body.vscode-dark {
  color: white;
}
body.vscode-high-contrast {
  color: red;
}</code></pre><p>当开发一个webview应用的时候，请保证应用能在三种主题下都可以运作，务必在高反差模式下测试你的webview，以便有视觉障碍的用户也能正常使用。</p>
<p>webview可以通过<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Using_CSS_variables" target="_blank" rel="noopener">CSS variables</a>访问VS Code主题，这些变量以<code>vscode</code>为前缀，并且用<code>-</code>替代了<code>.</code>，例如<code>editor.foreground</code>变成了<code>var(--vscode-editor-foreground)</code>：</p>
<pre><code>code {
  color: var(--vscode-editor-foreground);
}</code></pre><p>更多可用的主题变量，参阅主题色彩。</p>
<p>下面也定义了一些与字体有关的变量：</p>
<ul>
<li><code>-vscode-editor-font-family</code> - 编辑器的文字类型(设置中的<code>editor.fontFamily</code>配置项)</li>
<li><code>-vscode-editor-font-weight</code> - 编辑器的文字粗细(设置中的<code>editor.fontWeight</code>配置项)</li>
<li><code>-vscode-editor-font-size</code> - 编辑器文字大小(设置中的<code>editor.fontSize</code>配置项)</li>
</ul>
<h3 id="脚本和信息传递"><a href="#脚本和信息传递" class="headerlink" title="脚本和信息传递"></a>脚本和信息传递</h3><hr>
<p>既然webview就像iframe一样，也就是说它们也可以运行脚本，webview中的Javascript默认是禁用的，不过我们能用<code>enableScripts: true</code>打开它。</p>
<p>让我们写一段脚本，追踪我们家喵星人写代码的行数。运行一个基础脚本非常的容易，但是注意这个示例只作演示用途，在实践中，你的webview应该遵循内容安全政策，禁止行内脚本。</p>
<pre><code>import * as path from 'path';
import * as vscode from 'vscode';
export function activate(context: vscode.ExtensionContext) {
    context.subscriptions.push(vscode.commands.registerCommand('catCoding.start', () =&gt; {
        const panel = vscode.window.createWebviewPanel('catCoding', "Cat Coding", vscode.ViewColumn.One, {
            // 在webview中启用脚本
            enableScripts: true
        });
        panel.webview.html = getWebviewContent();
    }));
}
function getWebviewContent() {
    return
        `
            &lt;!DOCTYPE html&gt;
            &lt;html lang="en"&gt;
            &lt;head&gt;
                &lt;meta charset="UTF-8"&gt;
                &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
                &lt;title&gt;Cat Coding&lt;/title&gt;
            &lt;/head&gt;
            &lt;body&gt;
                &lt;img src="https://media.giphy.com/media/JIX9t2j0ZTN9S/giphy.gif" width="300" /&gt;
                &lt;h1 id="lines-of-code-counter"&gt;0&lt;/h1&gt;
                &lt;script&gt;
                    const counter = document.getElementById('lines-of-code-counter');
                    let count = 0;
                    setInterval(() =&gt; {
                        counter.textContent = count++;
                    }, 100);
                &lt;/script&gt;
            &lt;/body&gt;
            &lt;/html&gt;
        `;
}</code></pre><p><img src="/images/loading.gif" data-original="../images/development/scripts-basic.gif" alt=""></p>
<p>哇！真是位高产的喵主子!</p>
<p>!&gt; webveiw的脚本能做到任何普通网页脚本能做到的事情，但是webview运行在自己的上下文中，脚本不能访问VS Code API。</p>
<h4 id="将插件的信息传递到webview"><a href="#将插件的信息传递到webview" class="headerlink" title="将插件的信息传递到webview"></a>将插件的信息传递到webview</h4><p>插件可以用<code>webview.postMessage()</code>将数据发送到它的webview中。这个方法能发送任何序列化的JSON数据到webview中，在webview中则通过<code>message</code>事件接受信息。</p>
<p>我们现在就来看看这个实现，在Cat Coding中新增一个命令来表示我们家的喵在重构他的代码（所以会减少代码总行数）。新增<code>catCoding.doRefactor</code>命令，利用<code>postMessage</code>把指示发送到webview中，webview中的<code>window.addEventListener('message' event =&gt; { ... })</code>则会处理这些信息：</p>
<pre><code>export function activate(context: vscode.ExtensionContext) {
    // 现在只有一只喵喵程序员了
    let currentPanel: vscode.WebviewPanel | undefined = undefined;
    context.subscriptions.push(vscode.commands.registerCommand('catCoding.start', () =&gt; {
        if (currentPanel) {
            currentPanel.reveal(vscode.ViewColumn.One);
        } else {
            currentPanel = vscode.window.createWebviewPanel('catCoding', "Cat Coding", vscode.ViewColumn.One, {
                enableScripts: true
            });
            currentPanel.webview.html = getWebviewContent();
            currentPanel.onDidDispose(() =&gt; { currentPanel = undefined; }, undefined, context.subscriptions);
        }
    }));
    // 我们新的命令
    context.subscriptions.push(vscode.commands.registerCommand('catCoding.doRefactor', () =&gt; {
        if (!currentPanel) {
            return;
        }
        // 把信息发送到webview
        // 你可以发送任何序列化的JSON数据
        currentPanel.webview.postMessage({ command: 'refactor' });
    }));
}
function getWebviewContent() {
    return
        `
            &lt;!DOCTYPE html&gt;
            &lt;html lang="en"&gt;
            &lt;head&gt;
                &lt;meta charset="UTF-8"&gt;
                &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
                &lt;title&gt;Cat Coding&lt;/title&gt;
            &lt;/head&gt;
            &lt;body&gt;
                &lt;img src="https://media.giphy.com/media/JIX9t2j0ZTN9S/giphy.gif" width="300" /&gt;
                &lt;h1 id="lines-of-code-counter"&gt;0&lt;/h1&gt;
                &lt;script&gt;
                    const counter = document.getElementById('lines-of-code-counter');
                    let count = 0;
                    setInterval(() =&gt; {
                        counter.textContent = count++;
                    }, 100);
                    // Handle the message inside the webview
                    window.addEventListener('message', event =&gt; {
                        const message = event.data; // The JSON data our extension sent
                        switch (message.command) {
                            case 'refactor':
                                count = Math.ceil(count * 0.5);
                                counter.textContent = count;
                                break;
                        }
                    });
                &lt;/script&gt;
            &lt;/body&gt;
            &lt;/html&gt;
        `;</code></pre><p><img src="/images/loading.gif" data-original="../images/development/scripts-extension_to_webview.gif" alt=""></p>
<h4 id="将webview的信息传递到插件中"><a href="#将webview的信息传递到插件中" class="headerlink" title="将webview的信息传递到插件中"></a>将webview的信息传递到插件中</h4><p>webview也可以把信息传递回对应的插件中，用VS Code API 为webview提供的<code>postMessage</code>函数我们就可以完成这个目标。调用webview中的<code>acquireVsCodeApi</code>获取VS Code API对象。这个函数在一个会话中只能调用一次，你必须保持住这个方法返回的VS Code API实例，然后再转交到需要调用这个实例的地方。</p>
<p>现在我们在<strong>Cat Coding</strong>添加一个弹出bug的警示框：</p>
<pre><code>export function activate(context: vscode.ExtensionContext) {
    context.subscriptions.push(vscode.commands.registerCommand('catCoding.start', () =&gt; {
        const panel = vscode.window.createWebviewPanel('catCoding', "Cat Coding", vscode.ViewColumn.One, {
            enableScripts: true
        });
        panel.webview.html = getWebviewContent();
        // 处理webview中的信息
        panel.webview.onDidReceiveMessage(message =&gt; {
            switch (message.command) {
                case 'alert':
                    vscode.window.showErrorMessage(message.text);
                    return;
            }
        }, undefined, context.subscriptions);
    }));
}
function getWebviewContent() {
    return
        `
            &lt;!DOCTYPE html&gt;
            &lt;html lang="en"&gt;
            &lt;head&gt;
                &lt;meta charset="UTF-8"&gt;
                &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
                &lt;title&gt;Cat Coding&lt;/title&gt;
            &lt;/head&gt;
            &lt;body&gt;
                &lt;img src="https://media.giphy.com/media/JIX9t2j0ZTN9S/giphy.gif" width="300" /&gt;
                &lt;h1 id="lines-of-code-counter"&gt;0&lt;/h1&gt;
                &lt;script&gt;
                    (function() {
                        const vscode = acquireVsCodeApi();
                        const counter = document.getElementById('lines-of-code-counter');
                        let count = 0;
                        setInterval(() =&gt; {
                            counter.textContent = count++;
                            // Alert the extension when our cat introduces a bug
                            if (Math.random() &lt; 0.001 * count) {
                                vscode.postMessage({
                                    command: 'alert',
                                    text: '🐛  on line ' + count
                                })
                            }
                        }, 100);
                    }())
                &lt;/script&gt;
            &lt;/body&gt;
            &lt;/html&gt;
        `;
}</code></pre><p><img src="/images/loading.gif" data-original="../images/development/scripts-webview_to_extension.gif" alt=""></p>
<p>出于安全性考虑，你必须保证VS Code API的私有性，也不会泄露到全局状态中去。</p>
<h3 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h3><hr>
<p>每一个你创建的webview都必须遵循这些基础的安全性最佳实践。</p>
<h4 id="限制能力"><a href="#限制能力" class="headerlink" title="限制能力"></a>限制能力</h4><p>webview应该留有它所需的最小功能集合即可。例如：如果你的webview不需要运行脚本，就不要设置<code>enableScripts: true</code>。如果你的webview不需要加载用户工作区的资源，就把<code>localResourceRoots</code>设置为<code>[vscode.Uri.file(extensionContext.extensionPath)]</code>或者<code>[]</code>以便禁止访问任何本地资源。</p>
<h4 id="内容安全策略"><a href="#内容安全策略" class="headerlink" title="内容安全策略"></a>内容安全策略</h4><p><a href="https://developers.google.com/web/fundamentals/security/csp/" target="_blank" rel="noopener">内容安全策略</a>可以进一步限制webview可以加载和执行的内容。例如：内容安全策略强制可以运行在webview中的脚本白名单，或者告诉webview只加载带<code>https</code>协议的图片。</p>
<p>要想加上内容安全策略，将<code>&lt;meta http-equiv="Content-Security-Policy"&gt;</code>指令放到webview的<code>&lt;head&gt;</code>中</p>
<pre><code>function getWebviewContent() {
    return
        `
            &lt;!DOCTYPE html&gt;
            &lt;html lang="en"&gt;
            &lt;head&gt;
                &lt;meta charset="UTF-8"&gt;
                &lt;meta http-equiv="Content-Security-Policy" content="default-src 'none';"&gt;
                &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
                &lt;title&gt;Cat Coding&lt;/title&gt;
            &lt;/head&gt;
            &lt;body&gt;
                ...
            &lt;/body&gt;
            &lt;/html&gt;
        `;
}</code></pre><p><code>default-src 'none';</code>策略直接禁止了所有内容。我们可以按插件需要的最少内容修改这个指令，如只允许通过<code>https</code>加载本地脚本、样式和图片：</p>
<pre><code>&lt;meta
    http-equiv="Content-Security-Policy"
    content="default-src 'none'; img-src vscode-resource: https:; script-src vscode-resource:; style-src vscode-resource:;"
&gt;</code></pre><p>上述策略也隐式地禁用了内联脚本和样式。把内联样式和脚本提取到外部文件中是一个非常好的实践，也不会与内容安全策略冲突。</p>
<h4 id="只通过https加载内容"><a href="#只通过https加载内容" class="headerlink" title="只通过https加载内容"></a>只通过https加载内容</h4><p>如果你的webview允许加载外部资源，我们强烈建议你只允许通过<code>https</code>加载而不要使用http，上面的例子已经用内容安全策略展示了使用<code>https</code>的方式。</p>
<h4 id="审查用户输入"><a href="#审查用户输入" class="headerlink" title="审查用户输入"></a>审查用户输入</h4><p>就像构建普通HTML页面一样，你也同样需要在webview中审查用户输入的内容。 没有审查输入内容可能会导致内容注入，也就意味着将用户置于了危险之中。</p>
<p>可能需要审查的值：</p>
<ul>
<li>文件内容</li>
<li>文件和文件夹路径</li>
<li>用户工作区设置</li>
</ul>
<p>可以考虑用一个辅助库去构建HTML模板，或者确保所有来自用户工作区的内容都通过了审查</p>
<p>只依赖审查内容的安全性是不够的，你也要遵循其他安全性的最佳实践，尽可能减少潜在的内容注入。</p>
<h3 id="持久性"><a href="#持久性" class="headerlink" title="持久性"></a>持久性</h3><hr>
<p>在webview的标准生命周期中，<code>createWebviewPanel</code>负责创建和销毁（用户关闭或者调用<code>.dispose()</code>方法）webview。而webview的内容再是在webview可见时创建的，在webview处于非激活状态时销毁。webview处于非激活标签中时，任何webview中的保留的状态都会丢失。</p>
<p>所以最好减少webview中的状态，取而代之用消息传递储存状态。</p>
<h4 id="getState和setState"><a href="#getState和setState" class="headerlink" title="getState和setState"></a>getState和setState</h4><p>运行在webview中的脚本可以使用<code>getState</code>和<code>setState</code>方法保存和恢复JSON序列化的状态对象。这个状态可以一直保留，即使webview面板已经被隐藏，只有当它销毁时，状态则会一起销毁。</p>
<pre><code>// webview中的脚本
const vscode = acquireVsCodeApi();
const counter = document.getElementById('lines-of-code-counter');
// 检查是否需要恢复状态
const previousState = vscode.getState();
let count = previousState ? previousState.count : 0;
counter.textContent = count;
setInterval(() =&gt; {
    counter.textContent = count++;
    // 更新已经保存的状态
    vscode.setState({ count })
}, 100);</code></pre><p><code>getState</code>和<code>setState</code>是用来保存状态的比较好的办法，因为他们的性能消耗要远低于<code>retainContextWhenHidden</code>。</p>
<h4 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h4><p>使用<code>WebviewPanelSerializer</code>之后，你的webview可以在VS Code关闭后自动恢复。序列化构建于<code>getState</code>和<code>setState</code>之上，只有你的插件注册了<code>WebviewPanelSerializer</code>，这个功能才会生效。</p>
<p>给插件的<code>package.json</code>添加一个<code>onWebviewPanel</code>激活事件，然后我们的代码喵就能在VS Code重启后继续工作了：</p>
<pre><code>"activationEvents": [
    ...,
    "onWebviewPanel:catCoding"
]</code></pre><p>这个激活事件确保我们的插件不论VS Code何时恢复<code>catCoding</code>webview时都会启动。</p>
<p>然后在我们插件的<code>activate</code>方法中调用<code>registerWebviewPanelSerializer</code>注册一个新的<code>WebviewPanelSerializer</code>，这个函数负责恢复webview之前保存的内容。其中的state就是webview用<code>setState</code>设置的JSON格式的状态。</p>
<pre><code>export function activate(context: vscode.ExtensionContext) {
    // 常见设置...
    // 确保我们注册了一个序列化器
    vscode.window.registerWebviewPanelSerializer('catCoding', new CatCodingSerializer());
}
class CatCodingSerializer implements vscode.WebviewPanelSerializer {
    async deserializeWebviewPanel(webviewPanel: vscode.WebviewPanel, state: any) {
        // `state`是webview内调用`setState`保留住的
        console.log(`Got state: ${state}`);
        // 恢复我们的webview内容
        //
        // 确保我们将`webviewPanel`传递到了这里
        // 然后用事件侦听器恢复我们的内容
        webviewPanel.webview.html = getWebviewContent();
    }
}</code></pre><p>在VS Code中打开一个喵喵打代码的面板，关闭后重启就能看到这个面板恢复到了之前的状态和位置。</p>
<h4 id="隐藏时保留上下文"><a href="#隐藏时保留上下文" class="headerlink" title="隐藏时保留上下文"></a>隐藏时保留上下文</h4><p>如果webview的视图非常复杂，或者状态不能很快地保存和恢复，你则可以用<code>retainContextWhenHidden</code>选项，这个选项在不可见的状态中保存了webview的内容，即使webview本身不处于激活状态。</p>
<p>虽然<strong>Cat Coding</strong>说不上有很复杂的状态，不过我们可以打开<code>retainContextWhenHidden</code>看看webview的行为会发生什么变化：</p>
<pre><code>import * as vscode from 'vscode';
export function activate(context: vscode.ExtensionContext) {
  context.subscriptions.push(
    vscode.commands.registerCommand('catCoding.start', () =&gt; {
      const panel = vscode.window.createWebviewPanel(
        'catCoding',
        'Cat Coding',
        vscode.ViewColumn.One,
        {
          enableScripts: true,
          retainContextWhenHidden: true
        }
      );
      panel.webview.html = getWebviewContent();
    })
  );
}
function getWebviewContent() {
  return
    `
        &lt;!DOCTYPE html&gt;
        &lt;html lang="en"&gt;
        &lt;head&gt;
            &lt;meta charset="UTF-8"&gt;
            &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
            &lt;title&gt;Cat Coding&lt;/title&gt;
        &lt;/head&gt;
        &lt;body&gt;
            &lt;img src="https://media.giphy.com/media/JIX9t2j0ZTN9S/giphy.gif" width="300" /&gt;
            &lt;h1 id="lines-of-code-counter"&gt;0&lt;/h1&gt;
            &lt;script&gt;
                const counter = document.getElementById('lines-of-code-counter');
                let count = 0;
                setInterval(() =&gt; {
                    counter.textContent = count++;
                }, 100);
            &lt;/script&gt;
        &lt;/body&gt;
        &lt;/html&gt;
    `;
}</code></pre><p><img src="/images/loading.gif" data-original="https://static.sitestack.cn/projects/VS-Code-Extension-Doc-ZH/d23cbf17e1baa0f8b4b9af8fcfcbb35a.gif" alt=""></p>
<p>我们可以注意到计数器没有重置，webview隐藏之后就恢复了。而且不需要多余的代码！<code>retainContextWhenHidden</code>的行为就像浏览器一样，脚本和其他内容被暂时挂起，但是一旦webview可见之后就会立即恢复。但是在webview隐藏状态下，你还是不能给它发送消息的。</p>
<p>虽然<code>retainContextWhenHidden</code>很吸引人，但是记住这个功能的内容占用很高，只有其他的持久化技术无能为力之时再选择这种方式。</p>
<h2 id="虚拟文档"><a href="#虚拟文档" class="headerlink" title="虚拟文档"></a>虚拟文档</h2><p>通过VS Code的文本内容供应器API(text document content provider API)，你可以为任意来源的文件创建只读文档。本示例源码请查看<a href="https://github.com/Microsoft/vscode-extension-samples/blob/master/virtual-document-sample/README.md" target="_blank" rel="noopener">https://github.com/Microsoft/vscode-extension-samples/blob/master/virtual-document-sample/README.md</a></p>
<h3 id="Text-Document-Content-Provider"><a href="#Text-Document-Content-Provider" class="headerlink" title="Text Document Content Provider"></a>Text Document Content Provider</h3><hr>
<p>这个API工作于uri协议之上，你需要声明一个<em>供应器函数(provider)</em>，然后这个函数还需要返回文本内容。供应器函数必须提供<em>协议(scheme)</em>，而且函数注册之后不可改变这个协议。一个供应器函数可以对应多个协议，而多个供应器函数也可以只注册一个协议。</p>
<pre><code>vscode.workspace.registerTextDocumentContentProvider(myScheme, myProvider);</code></pre><p>调用<code>registerTextDocumentContentProvider</code>函数会返回一个用于释放资源的<em>释放器</em>。供应器函数还必须实现<code>provideTextDocumentContent</code>函数，这个函数需要传入uri参数和取消式令牌(cancellation token)调用。</p>
<pre><code>const myProvider = class implements vscode.TextDocumentContentProvider {
    provideTextDocumentContent(uri: vscode.Uri): string {
        // 简单调用cowsay, 直接把uri-path当做文本内容
        return cowsay.say({ text: uri.path });
    }
};</code></pre><p>!&gt; <strong>注意</strong>：我们的供应器函数不为虚拟文档创建uri——他的角色仅仅只是<strong>根据uri返回对应的文本内容</strong>。</p>
<p>下面我们简单使用一个’cowsay’命令创建一个uri，然后编辑器就能显示了：</p>
<pre><code>vscode.commands.registerCommand('cowsay.say', async () =&gt; {
    let what = await vscode.window.showInputBox({ placeHolder: 'cow say?' });
    if (what) {
        let uri = vscode.Uri.parse('cowsay:' + what);
        let doc = await vscode.workspace.openTextDocument(uri); // 调用供应器函数
        await vscode.window.showTextDocument(doc, { preview: false });
    }
});</code></pre><p>这个命令首先弹出了一个输入框，然后创建了一个<em><code>cowsay</code>协议</em>的uri，再然后根据这个uri读取了文档，最后为这个文档内容打开了一个编辑器（这里的“编辑器”不是指VS Code本身，而是VS Code中打开的单个编辑区tab）。在第三步中，<em>供应器函数</em>需要为这个uri提供对应的内容。</p>
<p>经过这整个流程，我们才算完整地实现了一个<em>文本内容供应器</em>，接下来的部分我们继续学习怎么更新虚拟文档，怎么注册虚拟文档的 UI命令。</p>
<h3 id="更新虚拟文档"><a href="#更新虚拟文档" class="headerlink" title="更新虚拟文档"></a>更新虚拟文档</h3><p>为了支持跟踪虚拟文档发生的变化，供应器实现了<code>onDidChange</code>事件。如果文档正在被使用，那么必须为其提供一个uri来调用它，同时编辑器会请求新的内容。</p>
<p><code>vscode.Event</code>定义了VS Code的事件规范。实现事件的最好方式就是使用<code>vscode.EventEmitter</code>，比如：</p>
<pre><code>const myProvider = class implements vscode.TextDocumentContentProvider {
  // 事件发射器和事件
  onDidChangeEmitter = new vscode.EventEmitter&lt;vscode.Uri&gt;();
  onDidChange = this.onDidChangeEmitter.event;
  //...
};</code></pre><p>上述就是VS Code监听虚拟文档变化所必须的内容。下面将使用事件发射器来添加<em>编辑器行为</em>。</p>
<h3 id="添加编辑器命令"><a href="#添加编辑器命令" class="headerlink" title="添加编辑器命令"></a>添加编辑器命令</h3><p>为了阐述事件变动和获取更多cowsay，我们需要倒叙cow刚刚说的东西。首先我们需要一个命令：</p>
<pre><code>// 注册一个可以更新当前cow的命令
subscriptions.push(
    vscode.commands.registerCommand('cowsay.backwards', async () =&gt; {
        if (!vscode.window.activeTextEditor) {
            return; // 不打开编辑器
        }
        let { document } = vscode.window.activeTextEditor;
        if (document.uri.scheme !== myScheme) {
            return; // 不是我的协议时直接返回
        }
        // 获取path的内容, 对这个内容倒序处理, 然后创建一个新的uri
        let say = document.uri.path;
        let newSay = say
            .split('')
            .reverse()
            .join('');
        let newUri = document.uri.with({ path: newSay });
        await vscode.window.showTextDocument(newUri, { preview: false });
    })
);</code></pre><p>上面的代码片段检查了我们当前是不是激活了一个编辑器（用户当前选中的编辑器tab），对应的文档是不是符合我们的协议。因为命令是对任何人生效的，所以我们有必要去做这些检查。然后uri的path对象被翻转，再重新创建出一个新的uri，最后则打开了一个编辑器。</p>
<p>注册命令最重要事就是在<code>package.json</code>中声明配置。我们在<code>contributes</code>部分添加下列配置：</p>
<pre><code>"menus": {
  "editor/title": [
    {
      "command": "cowsay.backwards",
      "group": "navigation",
      "when": "resourceScheme == cowsay"
    }
  ]
}</code></pre><p><code>contributes/commands</code>中的<code>cowsay.backwards</code>命令告诉编辑器<em>操作</em>出现在编辑器的标题菜单中（工具栏右上角），但如果只是这样简单的配置，每个编辑器就都会显示这个命令。然后我们的<code>when</code>语句就出场了，它描述了何时才显示这个操作。在这个例子中，文档的资源协议必须是<code>cowsay</code>，我们的命令才会生效。这个配置对默认显示全部命令的<code>commandPalette</code>菜单同样生效。</p>
<p><img src="/images/loading.gif" data-original="../images/development/015208fedf08c680ecd175c9572dc323.png" alt=""></p>
<h3 id="事件的可见性"><a href="#事件的可见性" class="headerlink" title="事件的可见性"></a>事件的可见性</h3><p><em>文档供应器函数</em>是VS Code中的一等公民，它们的内容以常规的文本文档格式呈现，它们共用一套基础实现方式——如：使用了文件系统的实现。这也就意味着“你的”文档无法被隐藏，它们必定会出现在<code>onDidOpenTextDocument</code>和<code>onDidCloseTextDocument</code>事件中，它们是<code>vscode.workspace.textDocuments</code>中的一部分。通用的准则就是根据文档的<code>协议</code>决定你是否需要对文档进行什么操作。</p>
<h3 id="文件系统API"><a href="#文件系统API" class="headerlink" title="文件系统API"></a>文件系统API</h3><p>如果你需要更强的灵活性和掌控力，请查看<a href="https://code.visualstudio.com/api/references/vscode-api#FileSystemProvider" target="_blank" rel="noopener"><code>FileSystemProvider</code></a>API，它可以实现整套完整的文件系统，获取文件、文件夹、二进制数据，删除文件，创建文件等等。</p>
<h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><p>通常，在VS Code中，用户可以通过<code>task.json</code>定义一个<a href="https://code.visualstudio.com/docs/editor/tasks" target="_blank" rel="noopener">任务</a>。不过在软件开发中，VS Code会自动检测某些任务。</p>
<p>本节介绍了插件应该怎样使用<a href="https://ruby.github.io/rake/" target="_blank" rel="noopener">Rakefiles</a>中的<strong>自动检测任务</strong>配置项，为最终用户提供任务。完整的源代码请参阅<a href="https://github.com/Microsoft/vscode-extension-samples/tree/master/task-provider-sample" target="_blank" rel="noopener">这里</a>。</p>
<h3 id="定义任务"><a href="#定义任务" class="headerlink" title="定义任务"></a>定义任务</h3><hr>
<p>想要定义一个系统级别的任务，插件需要通过properties定义任务，在下面叫做Rake的例子中，任务是这样定义的：</p>
<p>?&gt;<strong>译者注：</strong>rake是ruby实现的任务管理和自动构建工具，详细请参考<a href="https://rubygems.org/gems/rake/" target="_blank" rel="noopener">rake</a></p>
<pre><code>"taskDefinitions": [
    {
        "type": "rake",
        "required": [
            "task"
        ],
        "properties": {
            "task": {
                "type": "string",
                "description": "The Rake task to customize"
            },
            "file": {
                "type": "string",
                "description": "The Rake file that provides the task. Can be omitted."
            }
        }
    }
]</code></pre><p>上面代码里面，我们为<code>rake</code><em>任务集</em>配置了一个<strong>任务定义</strong>。任务定义有两个属性<code>task</code>和<code>file</code>，<code>task</code>是Rake任务的名字，file指向了包含任务的文件。<code>task</code>属性是必须的，<code>file</code>则为可选。如果省略了<code>file</code>属性，则会使用工作区根目录下名为<code>RakeFile</code>的文件。</p>
<h3 id="任务供应器函数"><a href="#任务供应器函数" class="headerlink" title="任务供应器函数"></a>任务供应器函数</h3><hr>
<p>和语言供应器函数相同，任务供应器使插件支持代码补全，一个插件可以只注册一个任务供应器函数然后执行所有可用的任务集合。使用<code>vscode.tasks</code>命名空间达成这一目标：</p>
<pre><code>import * as vscode from 'vscode';
let rakePromise: Thenable&lt;vscode.Task[]&gt; | undefined = undefined;
const taskProvider = vscode.tasks.registerTaskProvider('rake', {
    provideTasks: () =&gt; {
        if (!rakePromise) {
            rakePromise = getRakeTasks();
        }
        return rakePromise;
    },
    resolveTask(_task: vscode.Task): vscode.Task | undefined {
        return undefined;
    }
});</code></pre><p>目前<code>resolveTask</code>只返回了<code>undefined</code>，而将来VS Code会通过这个方法优化任务的加载。</p>
<p><code>getRakeTasks</code>的实现做了下面的事情：</p>
<ul>
<li>使用<code>rake -AT -f Rakefile</code>命令列出rake文件中的所有rake任务</li>
<li>转换为stdio输出</li>
<li>对每个任务创建一个<code>vscode.task</code>实现</li>
</ul>
<p>因为一个rake任务初始化需要<code>package.json</code>中有对应的任务定义，VS Code会用TypeScript接口定义出结构，像这样：</p>
<pre><code>interface RakeTaskDefinition extends vscode.TaskDefinition {
    /**
     * The task name
     */
    task: string;
    /**
     * The rake file containing the task
     */
    file?: string;
}</code></pre><p>假设我们的输出最终来自于一个叫<code>compile</code>的任务，那么对应的任务创建过程如下所示：</p>
<pre><code>let task = new vscode.Task(
    { type: 'rake', task: 'compile' },
    'compile',
    'rake',
    new vscode.ShellExecution('rake compile')
);</code></pre><p>每个输出任务都对应着上述过程，最后通过调用<code>getRakeTasks</code>会返回一个任务数组。</p>
<p><code>ShellExecution</code>会针对不同的系统在shell中执行<code>rake compile</code>命令（如：在Windows下会在PowerShell中执行，Ubuntu则是bash）。如果某个任务需要直接执行进程（不通过shell生成），则可以使用<code>vscode.ProcessExecution</code>。<code>ProcessExecution</code>的优势在于插件可以完全控制传入进程的参数，<code>ShellExecution</code>则会使用shell命令转义（比如：bash中的*展开）。如果<code>ShellExecution</code>是通过单个命令创建的，那么插件需要在命令内部确保引号和转义符的正确使用（比如，如何处理空格）。</p>
<h2 id="源控制API"><a href="#源控制API" class="headerlink" title="源控制API"></a>源控制API</h2><p>VS Code 允许插件创作者通过扩展API去定义<em>源控制管理</em>特性（Source Control Management，SCM），VS Code整合了各式各样的SCM体系，而只给用户展现了一组小巧、强大的API接口，还是带用户界面的那种。</p>
<p><img src="/images/loading.gif" data-original="../images/development/c0f272d6f40149ce45389259f99f31e1.png" alt=""></p>
<p>VS Code自带一个源控制器：Git，它是源控制API的最佳实践。如果你想构建你自己的SCM供应器，那么这是<a href="https://github.com/Microsoft/vscode/blob/master/extensions/git/src/repository.ts" target="_blank" rel="noopener">一个很好的起点</a>。</p>
<blockquote>
<p>VS Code插件市场还有很多类似的超赞的插件，比如<a href="https://marketplace.visualstudio.com/items?itemName=johnstoncode.svn-scm" target="_blank" rel="noopener">SVN</a>。</p>
</blockquote>
<p>如果你需要帮助，请查看<a href="https://code.visualstudio.com/api/references/vscode-api#scm" target="_blank" rel="noopener">vscode命名空间API</a>。</p>
<h3 id="源控制模型"><a href="#源控制模型" class="headerlink" title="源控制模型"></a>源控制模型</h3><hr>
<p><code>SourceControl</code>负责生产源控制模型的实体，它里面有<code>SourceControlResourceState</code>实例的<strong>资源状态</strong>，而资源状态又是<code>SourceControlResourceGroup</code>实例整理成<strong>组</strong>的。</p>
<p>通过<code>vscode.scm.createSourceControl</code>创建一个新的<em>源控制器</em>。</p>
<p>为了更好地理解这几种实体的交互，让我们拿<a href="https://github.com/Microsoft/vscode/tree/master/extensions/git" target="_blank" rel="noopener">Git</a>来做例子，考虑下列<code>git status</code>输出：</p>
<pre><code>vsce master* → git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use "git reset HEAD &lt;file&gt;..." to unstage)
        modified:   README.md
        renamed:    src/api.ts -&gt; src/test/api.ts
Changes not staged for commit:
  (use "git add/rm &lt;file&gt;..." to update what will be committed)
  (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)
        deleted:    .travis.yml
        modified:   README.md</code></pre><p>这个工作区里面发生了很多事，首先，<code>README.md</code>文件已经被修改了但还没有提交，然后立刻又被修改了。 其次，<code>src/api.ts</code>文件被移动到了<code>src/test/api.ts</code>，这个修改已经存备（staged）， 最后，<code>.travis.yml</code>文件被删除。</p>
<p>对于这个工作区而言，Git定义了两个资源组：<strong>工作中（Working tree）</strong>和<strong>已索引（Index）</strong>，对于单个组而言，每次<strong>文件修改</strong>就会产生一些资源状态：</p>
<ul>
<li><p>已索引 </p>
<p>- 资源组</p>
<ul>
<li>修改<code>README.md</code> - 资源状态</li>
<li>移动<code>src/api.ts</code>到<code>src/test/api.ts</code> - 资源状态</li>
</ul>
</li>
<li><p>工作中</p>
<p>- 资源组</p>
<ul>
<li>删除<code>.travis.yml</code> - 资源状态</li>
<li>修改<code>README.md</code> - 资源状态</li>
</ul>
</li>
</ul>
<p>同一个<code>README.md</code>是怎么成为两组截然不同的资源状态呢？</p>
<p>下面揭秘Git是如何创建这个模型的：</p>
<pre><code>function createResourceUri(relativePath: string): vscode.Uri {
  const absolutePath = path.join(vscode.workspace.rootPath, relativePath);
  return vscode.Uri.file(absolutePath);
}
const gitSCM = vscode.scm.createSourceControl('git', "Git");
const index = gitSCM.createResourceGroup('index', "Index");
index.resourceStates = [
  { resourceUri: createResourceUri('README.md') },
  { resourceUri: createResourceUri('src/test/api.ts') }
];
const workingTree = gitSCM.createResourceGroup('workingTree', "Changes");
workingTree.resourceStates = [
  { resourceUri: createResourceUri('.travis.yml') },
  { resourceUri: createResourceUri('README.md') }
];</code></pre><p>源变动和最终产生的资源组会传递到源控制视图上。</p>
<h3 id="源控制视图"><a href="#源控制视图" class="headerlink" title="源控制视图"></a>源控制视图</h3><hr>
<p>当源变动时，VS Code会生成源控制视图。源状态可通过<code>SourceControlResourceDecorations</code>自定义：</p>
<pre><code>export interface SourceControlResourceState {
  readonly decorations?: SourceControlResourceDecorations;
}</code></pre><p>上述例子已经足以让源控制视图生成一个简单的列表，不过用户可能想要在不同的资源状态上进行不同的操作。比如，当用户点击资源状态时，会发生什么呢？资源状态提供了一个可选命令去处理这类场景：</p>
<pre><code>export interface SourceControlResourceState {
  readonly command?: Command;
}</code></pre><h4 id="菜单-1"><a href="#菜单-1" class="headerlink" title="菜单"></a>菜单</h4><p>要想提供更加丰富的交互效果，我们提供了5个源控制菜单项供你使用。</p>
<p><code>scm/title</code>菜单在源控制视图的顶部右上方，菜单项水平排列在<code>标题栏</code>中，另外一些会在<code>...</code>下拉菜单中。</p>
<p><code>scm/resourceGroup/context</code>和<code>scm/resourceState/context</code>是类似的，你可以通过前者自定义资源组，后者则是定义资源状态。将菜单项放在<code>inline</code>组里，可以水平在视图中展示它们。而其他的菜单项可以通过鼠标右击的形式展示在菜单中。菜单中调用的命令会传入资源状态作为参数。注意SCM视图提供多选，因此命令函数可能一次性会接收一个或多个参数。</p>
<p>例如，Git支持往<code>scm/resourceState/context</code>菜单中添加<code>git.stage</code>命令和使用下列方法，提供多个文件的存备（staged）：</p>
<pre><code>stage(...resourceStates: SourceControlResourceState[]): Promise&lt;void&gt;;</code></pre><p>创建它们的时候，<code>SourceControl</code>和<code>SourceControlResourceGroup</code>实例会需要你提供一个string类型的<code>id</code>，这些值最终会在<code>scmProvider</code>和<code>scmResourceGroup</code>以上下文键值的形式出现。在菜单项的<code>when</code>语法中使用这些<a href="https://code.visualstudio.com/docs/getstarted/keybindings#_when-clause-contexts" target="_blank" rel="noopener">上下文键值</a>。看个Git如何通过<code>git.stage</code>命令显示菜单项的：</p>
<pre><code>{
  "command": "git.stage",
  "when": "scmProvider == git &amp;&amp; scmResourceGroup == merge",
  "group": "inline"
}</code></pre><p><code>scm/change/title</code>可以对<em>行内变动</em>配置标题栏的命令（contribute commands to the title bar of an inline change）。命令中的参数有文档的URI，变动数组，当前行内变动所在索引。例如下面是一个可以配置菜单的Git<code>stageChange</code>命令声明：</p>
<pre><code>async stageChange(uri: Uri, changes: LineChange[], index: number): Promise&lt;void&gt;;</code></pre><p><code>scm/sourceControl</code>菜单根据环境出现在源控制实例的边上。</p>
<p><img src="/images/loading.gif" data-original="../images/development/c8026055fcc93be5b3838af29383a8d0.png" alt=""></p>
<p>最后，<code>scm/change/title</code>菜单是和快速Diff功能相关联的，越新的文件越靠前，你可以针对特定的代码变动调用命令。</p>
<h4 id="SCM-输入框"><a href="#SCM-输入框" class="headerlink" title="SCM 输入框"></a>SCM 输入框</h4><p>源控制输入框位于每个源控制视图的顶部，接收用户输入的信息。你可以获取（或设置）这个信息供后续使用。在Git中，比如说，这可以作为一个commit框，用户输入了提交信息后，触发<code>git commit</code>命令：</p>
<pre><code>export interface SourceControlInputBox {
  value: string;
}
export interface SourceControl {
  readonly inputBox: SourceControlInputBox;
}</code></pre><p>用户可以通过Ctrl+Enter（Mac上是Cmd+Enter）接收任意信息，在<code>SourceControl</code>中的<code>acceptInputCommand</code>处理这类事件。</p>
<pre><code>export interface SourceControl {
  readonly acceptInputCommand?: Command;
}</code></pre><h3 id="快速Diff"><a href="#快速Diff" class="headerlink" title="快速Diff"></a>快速Diff</h3><hr>
<p>VS Code支持显示<strong>快速Diff</strong>编辑器的高亮槽，点击这些槽会出现一个内部diff交互器，你可以在这里为上下文配置命令。</p>
<p><img src="/images/loading.gif" data-original="../images/development/68bd3a75f4efdf1e16c4d9cd65f086f8.png" alt=""></p>
<p>这些高亮槽是VS Code自己计算出来的，你要做的就是根据给定的文件提供原始文件内容</p>
<pre><code>export interface SourceControl {
  readonly acceptInputCommand?: Command;
}</code></pre><p>使用<code>QuickDiffProvider</code>，你的实现需要告诉VS Code——参数传入的给定资源<code>Uri</code>所对应的原始资源<code>Uri</code>。</p>
<p>?&gt; <strong>提示</strong>: 如果你想在给定<code>Uri</code>的情况下，为任意资源提供内容，那么你可以把<strong>源控制API</strong>和<strong><a href="https://code.visualstudio.com/api/references/vscode-api#workspace" target="_blank" rel="noopener">工作区命名空间的<code>registerTextDocumentContentProvider</code>方法</a></strong>结合起来使用。</p>
<h2 id="调试器插件"><a href="#调试器插件" class="headerlink" title="调试器插件"></a>调试器插件</h2><p>VS Code已经内置了一套通用的用户界面，插件作者能够通过VS Code的调试架构轻松将已有的调试器整合进来。</p>
<p>VS Code已经内置了一个<a href="https://nodejs.org/" target="_blank" rel="noopener">Node.js</a>调试器插件，它将成为你学习VS Code调试器特性的绝佳搭档。</p>
<p><img src="/images/loading.gif" data-original="../images/development/8afbfc784f15b740436f40ae74367717.png" alt=""></p>
<p>上面的截图展示了以下调试功能：</p>
<ol>
<li>管理调试器配置</li>
<li>开始、停止、步进等调试操作</li>
<li>源、函数、条件断点、行断点和记录点</li>
<li>支持多线程和多进程的调用栈</li>
<li>在<em>视图</em>中浏览复杂的数据，鼠标悬停在数据上可以看到更多信息</li>
<li>鼠标悬停在源代码中可以看到变量的值</li>
<li>管理watch表达式</li>
<li>调试控制台支持交互操作，如求值、自动补全等</li>
</ol>
<p>本节将帮你创建一个任意调试器都可以和VS Code协作的调试器插件。</p>
<h3 id="VS-Code-中的调试架构"><a href="#VS-Code-中的调试架构" class="headerlink" title="VS Code 中的调试架构"></a>VS Code 中的调试架构</h3><hr>
<p>VS Code基于抽象协议，实现了一个原生（非语言相关的）的调试器UI，它可以和任意后台调试程序通信。通常来讲，调试器不会实现这份协议，因此调试器中需要一些中间件去“适配”这个协议。这个中间件一般而言是一个独立和调试器通信的进程。</p>
<p><img src="/images/loading.gif" data-original="../images/development/de9b3a492e1d2d0c0fb6b538ae23ae32.png" alt=""></p>
<p>我们将这个中间件称为<strong>调试适配器（Debug Adapter）</strong>（简写为<strong>DA</strong>），在VS Code和DA之间通信的抽象协议称之为<strong>调试适配器协议(Debug Adapter Protocol)</strong> (简写<strong>DAP</strong>)。调试适配器协议独立于VS Code，它有自己的<a href="https://microsoft.github.io/debug-adapter-protocol/" target="_blank" rel="noopener">网站</a>，你在上面可以找到相关的<a href="https://microsoft.github.io/debug-adapter-protocol/overview" target="_blank" rel="noopener">介绍和概述</a>，以及详细的<a href="https://microsoft.github.io/debug-adapter-protocol/specification" target="_blank" rel="noopener">说明书</a>，上面还列出了一些<a href="https://microsoft.github.io/debug-adapter-protocol/implementors/adapters/" target="_blank" rel="noopener">已知实现和支持工具</a>，这份努力背后的故事和动机，我们都记录在了<a href="https://code.visualstudio.com/blogs/2018/08/07/debug-adapter-protocol-website#_why-the-need-for-decoupling-with-protocols" target="_blank" rel="noopener">博客</a>中。</p>
<p>因为调试适配器独立于VSCode，所以它可用在<a href="https://microsoft.github.io/debug-adapter-protocol/implementors/tools/" target="_blank" rel="noopener">其他开发工具</a>中，它们无需匹配VS Code的插件架构，而只需基于插件和<em>发布内容配置</em>即可。</p>
<p>出于这个原因，VS Code提供了一个配置点<code>debuggers</code>，调试适配器在这里可以配置特定的调试类型（例如：Node.js调试器使用<code>node</code>）。用户只要启动了这个类型的调试适配器会话，VS Code就能加载注册好的调试适配器。</p>
<p>因此调试适配器的最小形式就是声明一个配置，对应调试适配器的实现，这个插件就是调试适配器的装载容器，而且不需要任何多余的代码。</p>
<p><img src="/images/loading.gif" data-original="../images/development/f581cdaa81ef0e6b3c2dfe9ab0e140e3.png" alt=""></p>
<p>一个更贴近现实的调试器插件往往会添加很多配置，如下面的：</p>
<ul>
<li>调试器支持的语言。VS Code会为这些语言启用UI界面的断点功能</li>
<li>由调试器引入的JSON格式的调试配置属性。VS Code会使用这个格式校验launch.json中的配置，并提供补全功能</li>
<li>首次加载调试时，VS Code自动生成初始launch.json文件</li>
<li>用户可以给launch.json添加的调试配置片段</li>
<li>声明调试配置中可以使用的变量</li>
</ul>
<h3 id="模拟调试插件"><a href="#模拟调试插件" class="headerlink" title="模拟调试插件"></a>模拟调试插件</h3><hr>
<p>由于从头开始创建一个调试适配器太繁琐了，所以我们将从简单的DA(我们已经创建过的<strong>入门级调试适配器</strong>)开始。因为它不与真正的调试器进行通信，所以就叫它——<em>模拟调试</em>吧。</p>
<p><em>模拟调试</em>模拟了调试器功能，支持：</p>
<ul>
<li>单步调试</li>
<li>跳到下一个断点</li>
<li>断点</li>
<li>异常</li>
<li>访问变量</li>
</ul>
<p>在深入了解开发中的<em>模拟调试</em>之前，我们先去VS Code插件市场安装个<a href="https://marketplace.visualstudio.com/items?itemName=andreweinand.mock-debug" target="_blank" rel="noopener">预构建版本</a>玩一玩，就像下面这样：</p>
<ul>
<li>打开VS Code的插件面板，输入”mock”并找到<strong>Mock Debug</strong>插件</li>
<li><strong>安装</strong>并<strong>重启</strong></li>
</ul>
<p>通过如下流程来启动<em>模拟调试</em>：</p>
<ul>
<li>新建一个空的文件夹<code>mock test</code>并在VS Code中打开</li>
<li>创建一个<code>readme.md</code>，在里面随便写点什么东西</li>
<li>切换到<strong>调试</strong>视图，点一下<strong>齿轮图标</strong></li>
<li>VS Code会让你选择一个”环境”，并将其作为默认的启动配置。这里选择”Mock Debug”。</li>
<li>点击绿色的<strong>开始</strong>按钮，然后开始调试</li>
</ul>
<p>至此，一个调试会话就开始了，你可以在<code>readme.md</code>文件中进行单步调试、打断点。如果某一行出现异常则会跳进该异常。</p>
<p><img src="/images/loading.gif" data-original="../images/development/4f6b0b2fc0103d45a4dc3dd6cd0352c8.gif" alt=""></p>
<p>在使用<em>模拟调试</em>之前，我们建议你卸载掉<a href="https://marketplace.visualstudio.com/items?itemName=andreweinand.mock-debug" target="_blank" rel="noopener">预构建版本</a>：</p>
<ul>
<li>切换到Extensions视图，然后单击<em>模拟调试</em>插件的齿轮图标</li>
<li>卸载该插件并重启VS Code</li>
</ul>
<h3 id="开发环境配置模拟调试"><a href="#开发环境配置模拟调试" class="headerlink" title="开发环境配置模拟调试"></a>开发环境配置模拟调试</h3><hr>
<p>现在让我们下载Mock Debug的源码，然后用VS Code进行开发吧：</p>
<pre><code>git clone https://github.com/Microsoft/vscode-mock-debug.git
cd vscode-mock-debug
npm install</code></pre><p>用VS Code打开<code>vscode-mock-debug</code>项目</p>
<p>我们的项目里面有什么呢？</p>
<ul>
<li><pre><code>package.json</code></pre><p>是mock-debug插件的配置清单：</p>
<ul>
<li>里面是mock-debug插件的<em>发布内容配置</em>清单</li>
<li><code>compile</code>和<code>watch</code>脚本会将Typescript源码编译到<code>out</code>文件夹中，然后<code>watch</code>脚本会追踪源码每个细微的修改</li>
<li><code>vscode-debugprotocol</code>，<code>vscode-debugadapter</code>和<code>vscode-debugadapter-testsupport</code>npm依赖包简化了基于node的调试适配器开发工作</li>
</ul>
</li>
<li><p><code>src/mockRuntime.ts</code>是一个<strong>模拟的</strong>运行时，仅仅包含一些简单的调试API</p>
</li>
<li><p><code>src/mockDebug.ts</code>是我们的主要代码，是它将<em>运行时</em>适配到<strong>调试适配器</strong>上。你可以在里面找到各种处理DAP请求的方式。</p>
</li>
<li><p>调试插件实现于调试适配器，所以你可以完全不使用创建普通插件的代码（比如：原来插件的代码运行在扩展主机环境中），但是mock-debug还是有个小小的<code>src/extension.ts</code>，这份代码里面阐释了调试器插件中<em>插件</em>部分的代码可以做些什么。</p>
</li>
</ul>
<p>现在构建项目，然后加载Mock Debug插件。选择<strong>调试侧边栏</strong>，加载 <strong>Extension</strong> 配置，然后按下<code>F5</code>。接下来，会启动插件的Typescript编译工作，将转换后的代码输出到<code>out</code>文件夹中，然后进行全量编译，再接着，<em>watcher</em>任务会启动以便侦听你的改动。</p>
<p>代码编译完成后，带有”[Extension Development Host]”（中文环境下是”[扩展开发主机]”）VS Code新窗口会自动打开，Mock Debug插件就运行在调试模式中了。在这个窗口中，打开<code>mock test</code>项目，打开里面的<code>readme.md</code>，然后直接按下F5启动调试会话，现在你就可以调试了！</p>
<p><img src="/images/loading.gif" data-original="../images/development/ce06fd67de8136a0646260692a3a29d5.png" alt=""></p>
<p>因为的你插件运行在 <em>调试模式</em> 中，所以你能在<code>src/extension.ts</code>里面打断点，不过就如上文所说，这个插件关于<em>插件</em>本身的代码是没有多少的，最有意思的代码运行在调试适配器里，它是一个独立的进程。</p>
<p>要想调试调试适配器本身，我们需要把它运行在调试模式里。最简单的办法就是将调试适配器以<em>服务器模式</em>运行，然后配置VS Code去连接它。在你的vscode-mock-debug项目中，重新在打开的调试侧边栏的配置下拉菜单中选择<em>Server</em>配置，按下旁边的绿色开始按钮。</p>
<p>因为我们已经启动了一个调试会话，所以VS Code 调试器UI现在会进入 <em>多会话</em> 模式，在<strong>调用栈（CALL STACK）</strong>视图中你现在可以看到2个调试会话—— <strong>Extension</strong> 和 <strong>Server</strong> 。</p>
<p><img src="/images/loading.gif" data-original="../images/development/6d6b6aac5ef3a69ae76e82e129109d7d.png" alt=""></p>
<p>现在我们可以同时调试插件和DA（调试适配器）了。到我们目前这一步还有个更快的方式，启动调试时选择<strong>Extension + Server</strong>配置就会自动加载这两个会话。</p>
<p>另外，调试插件和调试适配器更简单的方式会在下面说明。</p>
<p>在<code>src/mockDebug.ts</code>中的<code>launchRequest(...)</code>最开始的地方打上断点，然后最后一步则是在你的mock test启动配置中添加<code>debugServer</code>属性和对应的端口值<code>4711</code>就完成了调试器和调试适配器的连接。</p>
<pre><code>{
    "version": "0.2.0",
    "configurations": [
        {
            "type": "mock",
            "request": "launch",
            "name": "mock test",
            "program": "${workspaceFolder}/readme.md",
            "stopOnEntry": true,
            "debugServer": 4711
        }
    ]
}</code></pre><p>如果你现在就加载这个调试配置，调试适配器不会以分离的进程启动，而是直接连接到已经存在的本地服务器端口4711上。现在你可以在<code>launchRequest</code>打断点了。</p>
<p>经过这样一连串的配置，你终于可以轻松地编辑、编译和调试Mock Debug插件了。</p>
<p>但是好戏才刚刚开始：你需要替换<code>src/mockDebug.ts</code>和<code>src/mockRuntime.ts</code>的中的调试适配器代码，让它可以和“真正的”调试器或者运行时通信。这项工作涉及到理解和实现调试适配器协议。</p>
<p>更多内容请查看<a href="https://microsoft.github.io/debug-adapter-protocol/overview#How_it_works" target="_blank" rel="noopener">这里</a>。</p>
<h3 id="剖析调试器插件的package-json"><a href="#剖析调试器插件的package-json" class="headerlink" title="剖析调试器插件的package.json"></a>剖析调试器插件的package.json</h3><hr>
<p>除了提供调试适配的特定实现之外，调试器插件还需要一个配置各种各样和调试相关的<code>package.json</code>。</p>
<p>所以下面我们进一步看看Mock Debug的<code>package.json</code>.</p>
<p>就像一般的VS Code插件，<code>package.json</code>声明了一些基础信息，如插件的<strong>name</strong> ，<strong>publisher</strong>，<strong>version</strong>等。其中配置<strong>categories</strong>字段可以让你的插件更容易在插件市场中被其他人发现。</p>
<pre><code>{
    "name": "mock-debug",
    "displayName": "Mock Debug",
    "version": "0.24.0",
    "publisher": "...",
    "description": "Starter extension for developing debug adapters for VS Code.",
    "author": {
        "name": "...",
        "email": "..."
    },
    "engines": {
        "vscode": "^1.17.0",
        "node": "^7.9.0"
    },
    "icon": "images/mock-debug-icon.png",
    "categories": ["Debuggers"],
    "contributes": {
        "breakpoints": [{ "language": "markdown" }],
        "debuggers": [
            {
                "type": "mock",
                "label": "Mock Debug",
                "program": "./out/mockDebug.js",
                "runtime": "node",
                "configurationAttributes": {
                    "launch": {
                        "required": ["program"],
                        "properties": {
                            "program": {
                                "type": "string",
                                "description": "Absolute path to a text file.",
                                "default": "${workspaceFolder}/${command:AskForProgramName}"
                            },
                            "stopOnEntry": {
                                "type": "boolean",
                                "description": "Automatically stop after launch.",
                                "default": true
                            }
                        }
                    }
                },
                "initialConfigurations": [
                    {
                        "type": "mock",
                        "request": "launch",
                        "name": "Ask for file name",
                        "program": "${workspaceFolder}/${command:AskForProgramName}",
                        "stopOnEntry": true
                    }
                ],
                "configurationSnippets": [
                    {
                        "label": "Mock Debug: Launch",
                        "description": "A new configuration for launching a mock debug program",
                        "body": {
                            "type": "mock",
                            "request": "launch",
                            "name": "${2:Launch Program}",
                            "program": "^\"\\${workspaceFolder}/${1:Program}\""
                        }
                    }
                ],
                "variables": {
                    "AskForProgramName": "extension.mock-debug.getProgramName"
                }
            }
        ]
    },
    "activationEvents": ["onDebug", "onCommand:extension.mock-debug.getProgramName"]
}</code></pre><p>现在我们来看看调试器插件中的<code>contributes</code>部分。</p>
<p>首先，<strong>breakpoints</strong>配置部分列出了可以使用断点的语言列表，没有这个配置的话，就不可能在 Markdown文件中设置断点了。</p>
<p>接下来是<strong>debuggers</strong>部分，这里引入了一个类型是<code>mock</code>的调试器，用户可以在调试器加载配置中引用这个类型。可选属性<strong>label</strong>是这个调试器的名字，它会显示在UI上。</p>
<p>因为调试器插件使用了调试适配器，所以它的的关联路径得通过<strong>program</strong>属性配置。为了保证插件的自包含性（self-contained），这个应用必须在我们的插件文件夹中。按惯例，我们将这个应用放在<code>out</code>或者<code>bin</code>中，当然你也可以使用其他名称的文件夹存放。</p>
<p>因为VS Code运行在不同的平台上，我们需要确保DA程序也能够支持不同的平台。对于这点，我们提供了下列选项：</p>
<ol>
<li>如果程序在平台上的实现都是各自独立的，比如：这个程序的运行时支持所有平台，你可以在<strong>runtime</strong>属性中指明。 到目前为止，VS Code支持<code>node</code>和<code>moni</code>运行时，我们的Mock Debug就使用了这个方式。</li>
<li>如果你的DA在不同的平台上对应着不同的可执行程序，那么你可以这样使用<strong>program</strong>属性：</li>
</ol>
<pre><code>"debuggers": [{
    "type": "gdb",
    "windows": {
        "program": "./bin/gdbDebug.exe",
    },
    "osx": {
        "program": "./bin/gdbDebug.sh",
    },
    "linux": {
        "program": "./bin/gdbDebug.sh",
    }
}]</code></pre><ol>
<li>组合上面两种方式也是可以的。下面的例子实现了在macOS和Linux上使用同一个mono应用，但是Windows上就不是。</li>
</ol>
<pre><code>"debuggers": [{
    "type": "mono",
    "program": "./bin/monoDebug.exe",
    "osx": {
        "runtime": "mono"
    },
    "linux": {
        "runtime": "mono"
    }
}]</code></pre><p><strong>configurationAttributes</strong>声明了这个调试器的<code>launch.json</code>中的属性可以使用的协议。这个协议用于校验<code>launch.json</code>，同时支持编辑加载配置时的智能补全和悬停帮助。</p>
<p><strong>initialConfigurations</strong>定义了这个调试器的初始<code>launch.json</code>。当一个项目没有<code>launch.json</code>，然后用户打开了调试会话时，就会使用这个启动配置。然后VS Code会让用户选择一个调试环境，接着再创建对应的<code>launch.json</code>：</p>
<p><img src="/images/loading.gif" data-original="../images/development/c182c8ff8b5d20d22477ae5ce3c4921d.png" alt=""></p>
<p>除了在<code>package.json</code>中静态定义<code>launch.json</code>的初始内容，你还可以使用<code>DebugConfigurationProvider</code>动态注入初始配置内容（详情见下使用DebugConfigurationProvider）。</p>
<p><strong>configurationSnippets</strong>定义了编辑<code>launch.json</code>会为用户呈现的代码补全提示。同样，按约定<code>label</code>属性定义了调试环境的名称，所以当大量补全提示出现的时候，用户才能一眼认出自己想要的那个。</p>
<p><strong>variables</strong>配置，将“变量”绑定到了“命令”上。这些变量会出现在加载配置（launch.json）中，用法是<strong>${command:xyz}</strong>，调试会话启动后，其中的值会被命令中的返回值替换。</p>
<p><em>命令</em>实现在插件（而不是调试适配器）中，它可以由一句简单的表达式实现，也可以复杂到基于插件API和UI特性实现。Mock Debug将变量<code>AskForProgramName</code>绑定到了命令<code>extension.mock-debug.getProgramName</code>，这个命令的<a href="https://github.com/Microsoft/vscode-mock-debug/blob/606454ff3bd669867a38d9b2dc7b348d324a3f6b/src/extension.ts#L21-L26" target="_blank" rel="noopener">实现</a>在<code>src/extension.ts</code>中，代码中的<code>showInputBox</code>允许用户为程序命名：</p>
<pre><code>vscode.commands.registerCommand('extension.mock-debug.getProgramName', config =&gt; {
    return vscode.window.showInputBox({
        placeHolder: 'Please enter the name of a markdown file in the workspace folder',
        value: 'readme.md'
    });
});</code></pre><p>现在加载配置（launch.json）中可以使用<strong>${command:AskForProgramName}</strong>中的值（文本类型）了。</p>
<h3 id="使用DebugConfigurationProvider"><a href="#使用DebugConfigurationProvider" class="headerlink" title="使用DebugConfigurationProvider"></a>使用DebugConfigurationProvider</h3><hr>
<p>如果你觉得<code>package.json</code>中和调试相关的发布内容配置不够你用，<code>DebugConfigurationProvider</code>可以动态控制调试插件下列方面的内容：</p>
<ul>
<li>动态生成launch.json中的配置。比如：根据工作区的信息生成一些配置。</li>
<li>在启动新的调试会话前，解析（或修改）加载配置。有了这个功能，你可以根据工作区的不同填入对应的配置默认值。</li>
</ul>
<p><code>src/extension.ts</code>中的<code>MockConfigurationProvider</code>实现了<code>resolveDebugConfiguration</code>，它会检测调试会话启动时是不是还没有launch.json文件，而且Markdown文件已经打开了。这种场景非常常见，用户已经打开了文件，他想要立刻启动调试而且不想要搞任何配置。</p>
<p>通过<code>vscode.debug.registerDebugConfigurationProvider</code>注册<em>调试配置供应器函数</em>，它一般在插件的<code>active</code>函数中。<code>DebugConfigurationProvider</code>需要尽早注册，一旦调试功能被使用到了，插件就应该启动。我们通过<code>package.json</code>中的<code>onDebug</code>事件轻松搞定这个需求：</p>
<pre><code>"activationEvents": [
    "onDebug",
    // ...
],</code></pre><p>在低开销的插件启动时（启动时不会花太多时间），这个机制会如预期工作。但是如果插件的启动开销较大（比如启动一个语言服务器），那么<code>onDebug</code>事件可能会对其他调试插件产生副作用，因为<code>onDebug</code>事件已经激活了其他插件，但是其他插件因为阻塞还来不及接收到具体的调试类型。</p>
<p>对于高开销的调试插件来说，更好的方法就是使用粒度更细的 激活事件：</p>
<ul>
<li><code>onDebugInitialConfigurations</code>会在<code>DebugConfigurationProvider</code>的<code>provideDebugConfigurations</code>调用前触发</li>
<li><code>onDebugResolve:type</code>会在<code>DebugConfigurationProvider</code>的<code>resolveDebugConfiguration</code>取得具体的调试类型前触发</li>
</ul>
<p>!&gt; <strong>首要原则：</strong>如果调试插件的开销很小，就用<code>onDebug</code>，根据<code>DebugConfigurationProvider</code>是否实现了<code>provideDebugConfigurations</code>或<code>resolveDebugConfiguration</code>，然后在对应的<code>onDebugInitialConfigurations</code>或者<code>onDebugResolve</code>中处理。</p>
<h3 id="发布调试器插件"><a href="#发布调试器插件" class="headerlink" title="发布调试器插件"></a>发布调试器插件</h3><hr>
<p>通过下面的步骤将你的调试适配器发布到市场上：</p>
<ul>
<li>更新<code>package.json</code>中的发布配置内容表明你调试适配器的功能和目标</li>
<li>参考发布插件部分然后将你的插件上传到市场上</li>
</ul>
<h3 id="开发调试器插件的其他方式"><a href="#开发调试器插件的其他方式" class="headerlink" title="开发调试器插件的其他方式"></a>开发调试器插件的其他方式</h3><hr>
<p>如我们所见，开发一个调试插件涉及到<em>一个普通插件</em>再加上一个调试适配器，它们分别运行在不同的会话中。VS Code支持这样的实现，但是简单的办法是还是把<em>插件</em>和调试适配器用一个程序实现，这样你就可以在一个调试会话中同时调试了。</p>
<p>实际上，只要你的调试适配器是基于Typescript/Javascript实现的，这个方法就都是可行的。基本的思路是把调试适配器实现为一个服务器，让<em>插件</em>去启动这个服务，再让VS Code连接上去，这样你就不用每个调试会话都启动一个新的调试适配器了。</p>
<p>Mock Debug的例子阐述了一个<a href="https://github.com/Microsoft/vscode-mock-debug/blob/6a2ef01b95bb22cdf55683f4d616cad501051510/src/extension.ts#L74-L98" target="_blank" rel="noopener">DebugAdapterDescriptorFactory</a>可以怎样创建和<a href="https://github.com/Microsoft/vscode-mock-debug/blob/6a2ef01b95bb22cdf55683f4d616cad501051510/src/extension.ts#L32-L36" target="_blank" rel="noopener">注册</a>一个基于服务器的调试适配器。通过将编译时的<a href="https://github.com/Microsoft/vscode-mock-debug/blob/6a2ef01b95bb22cdf55683f4d616cad501051510/src/extension.ts#L17" target="_blank" rel="noopener"><code>EMBED_DEBUG_ADAPTER</code></a>配置设置为true启用这个特性。现在如果你用<strong>F5</strong>启动调试，你就不仅仅是在插件开发主机中打了断点，你也同时在调试适配器中打了同样的断点。</p>
<h2 id="Markdown插件"><a href="#Markdown插件" class="headerlink" title="Markdown插件"></a>Markdown插件</h2><p>Markdown插件可以帮你扩展和加强VS Code内置的Markdown预览，包括改变预览的样式、添加新的Markdown语法。</p>
<h3 id="用CSS改变Markdown预览样式"><a href="#用CSS改变Markdown预览样式" class="headerlink" title="用CSS改变Markdown预览样式"></a>用CSS改变Markdown预览样式</h3><hr>
<p>配置CSS可以改变markdown预览的布局和样式，在你的插件<code>pacakge.json</code>中注册<code>markdown.previewStyles</code>发布内容配置即可：</p>
<pre><code>"contributes": {
    "markdown.previewStyles": [
        "./style.css"
    ]
}</code></pre><p><code>markdown.previewStyles</code>类型是插件根目录下的文件列表。</p>
<p>配置的样式会在用户的<code>"markdown.styles"</code>之前，内置Markdown预览样式之后加载。</p>
<p><a href="https://marketplace.visualstudio.com/items?itemName=bierner.markdown-preview-github-styles" target="_blank" rel="noopener">Markdown Preview GitHub Styling</a>是一个如何将Markdown预览变成像GitHub渲染风格的好例子，在GitHub上去查看<a href="https://github.com/mjbvz/vscode-github-markdown-preview-style" target="_blank" rel="noopener">源码</a>吧</p>
<h3 id="使用markdown-it插件添加新语法"><a href="#使用markdown-it插件添加新语法" class="headerlink" title="使用markdown-it插件添加新语法"></a>使用markdown-it插件添加新语法</h3><hr>
<p>VS Code Markdown预览支持<a href="https://spec.commonmark.org/" target="_blank" rel="noopener">CommonMark规格</a>，插件可以通过一个<a href="https://github.com/markdown-it/markdown-it#syntax-extensions" target="_blank" rel="noopener">markdown-it插件</a>添加新的Markdown语法。</p>
<p>首先，在你的插件<code>package.json</code>中配置<code>"markdown.markdownItPlugins"</code>：</p>
<pre><code>"contributes": {
    "markdown.markdownItPlugins": true
}</code></pre><p>然后在插件的主<code>activation</code>函数中，返回一个包含名<code>extendMarkdownIt</code>函数的对象。这个函数接收一个markdown-it实例，然后必须返回出新的markdown-it实例：</p>
<pre><code>import * as vscode from 'vscode'
export function activate(context: vscode.ExtensionContext) {
    return {
        extendMarkdownIt(md: any) {
            return md.use(require('markdown-it-emoji'));
        }
    }
}</code></pre><p>若想配置多个markdown-it插件，只需多次链式调用<code>use</code>声明即可。</p>
<pre><code>return md.use(require('markdown-it-emoji')).use(require('markdown-it-hashtag'));</code></pre><p>Markdown预览第一次显示时，配置了markdown-it的插件会变成懒加载激活。</p>
<p><a href="https://marketplace.visualstudio.com/items?itemName=bierner.markdown-emoji" target="_blank" rel="noopener">markdown-emoji</a>插件展示了如何使用markdown-it添加emoji支持，你可以在GitHub上查看Emoji插件的<a href="https://github.com/mjbvz/vscode-markdown-emoji" target="_blank" rel="noopener">源码</a>。</p>
<p>你可能还想了解：</p>
<ul>
<li>markdown-it插件开发者<a href="https://github.com/markdown-it/markdown-it/blob/master/docs/development.md" target="_blank" rel="noopener">指南</a></li>
<li><a href="https://www.npmjs.com/browse/keyword/markdown-it-plugin" target="_blank" rel="noopener">现成的markdown-it插件</a></li>
</ul>
<h3 id="用脚本添加进阶功能"><a href="#用脚本添加进阶功能" class="headerlink" title="用脚本添加进阶功能"></a>用脚本添加进阶功能</h3><hr>
<p>对于进阶特性，在插件中配置可运行的脚本：</p>
<pre><code>"contributes": {
    "markdown.previewScripts": [
        "./main.js"
    ]
}</code></pre><p>配置的脚本是异步加载的，每次内容变动还会重载。</p>
<p><a href="https://marketplace.visualstudio.com/items?itemName=bierner.markdown-mermaid" target="_blank" rel="noopener">Markdown Preview Mermaid Support</a>插件展示了如何使用脚本添加<a href="https://knsv.github.io/mermaid/index.html" target="_blank" rel="noopener">鱼骨图</a>和流程图预览。在<a href="https://github.com/mjbvz/vscode-markdown-mermaid" target="_blank" rel="noopener">这里</a>查看插件源码。</p>
<h1 id="语言插件"><a href="#语言插件" class="headerlink" title="语言插件"></a>语言插件</h1><h2 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h2><p>VS Code通过语言插件可以为各式各样的编程语言提供智能的编辑体验。VS Code并不含内置语言支持，不过提供了一整套支持富文本特性的API。 比如，<a href="https://github.com/Microsoft/vscode/tree/master/extensions/html" target="_blank" rel="noopener">HTML</a>插件是一个可以为VS Code中的HTML文件提供语法高亮的插件。 类似的，当你输入<code>console.</code>时，智能补全会提示<code>log</code>，这是<a href="https://github.com/Microsoft/vscode/tree/master/extensions/typescript-language-features" target="_blank" rel="noopener">Typescript Language Features</a>插件提供的。</p>
<p>语言特性大致可以分为下面两种：</p>
<h3 id="声明式语言特性"><a href="#声明式语言特性" class="headerlink" title="声明式语言特性"></a>声明式语言特性</h3><hr>
<p>定义在配置文件的语言功能称之为<em>编程式语言特性</em>，比如，<a href="https://github.com/Microsoft/vscode/tree/master/extensions/html" target="_blank" rel="noopener">html</a>，<a href="https://github.com/Microsoft/vscode/tree/master/extensions/css" target="_blank" rel="noopener">css</a>和<a href="https://github.com/Microsoft/vscode/tree/master/extensions/typescript-basics" target="_blank" rel="noopener">typescript-基础支持</a>插件都打包在了VS Code中，所以提供了下列声明式语言特性：</p>
<ul>
<li>语法高亮</li>
<li>代码片段补全</li>
<li>括号匹配</li>
<li>自动闭合括号</li>
<li>括号识别</li>
<li>启动、关闭注释</li>
<li>自动缩进</li>
<li>代码折叠</li>
</ul>
<p>我们提供了3个指南供你开发语言插件的声明式特性：</p>
<ul>
<li>语法高亮指南：VS Code 使用TextMate语法来高亮代码。这个指南将教你用简单的TextMate语法开发一个VS Code插件。</li>
<li>代码片段补全指南： 这个指南教你怎么把代码片段打包进插件中。</li>
<li>语言配置指南：VS Code允许插件为任何编程语言定义 <strong>语言配置</strong>。这个文件控制着基本的编辑功能，如开闭注释、括号匹配/识别，和(基础)代码折叠。</li>
</ul>
<h3 id="编程式语言特性"><a href="#编程式语言特性" class="headerlink" title="编程式语言特性"></a>编程式语言特性</h3><hr>
<p>编程式语言特性包括自动补全、错误检查和跳转到定义。这些功能一般通过<em>语言服务器</em>驱动，这个服务器会分析你的项目，然后提供对应的功能。最好的例子就是打包在VS Code中的<a href="https://github.com/Microsoft/vscode/tree/master/extensions/typescript-language-features" target="_blank" rel="noopener"><code>typescript-language-features</code></a>插件，它利用<a href="https://github.com/Microsoft/TypeScript/wiki/Using-the-Language-Service-API" target="_blank" rel="noopener">TypeScript Language Service</a>提供了诸如下面罗列的编程式语言特性：</p>
<ul>
<li>悬停信息（<a href="https://code.visualstudio.com/api/references/vscode-api#languages.registerHoverProvider" target="_blank" rel="noopener">vscode.languages.registerHoverProvider</a>）</li>
<li>自动补全（<a href="https://code.visualstudio.com/api/references/vscode-api#languages.registerDefinitionProvider" target="_blank" rel="noopener">vscode.languages.registerCompletionItemProvider</a>）</li>
<li>转跳到定义（<a href="https://code.visualstudio.com/api/references/vscode-api#languages.registerDefinitionProvider" target="_blank" rel="noopener">vscode.languages.registerDefinitionProvider</a>）</li>
<li>错误检查</li>
<li>格式化</li>
<li>重构</li>
<li>代码折叠</li>
</ul>
<p>下面是编程式语言特性的完整列表。</p>
<p><img src="/images/loading.gif" data-original="../images/development/c2f83fd180bbb1190354e60bd04ea7a3.png" alt=""></p>
<h3 id="语言服务器协议（Language-Server-Protocol）"><a href="#语言服务器协议（Language-Server-Protocol）" class="headerlink" title="语言服务器协议（Language Server Protocol）"></a>语言服务器协议（Language Server Protocol）</h3><hr>
<p><a href="https://microsoft.github.io/language-server-protocol/" target="_blank" rel="noopener">语言服务器协议</a>将语言服务器（一个静态代码分析工具）和语言客户端（一般就是源代码）之间的通信进行了标准化，这样一来插件开发者就可以只写一次代码分析程序，然后在多个编辑器中重用了。</p>
<p>在编程式语言特性列表中，你可以找到所有VS Code的语言特性，以及它和<a href="https://microsoft.github.io/language-server-protocol/specification" target="_blank" rel="noopener">语言服务器协议规格</a>之间的映射关系。</p>
<p>我们提供了一个非常详尽的指南，里面会告诉你怎么实现一个语言服务器插件：</p>
<ul>
<li>语言服务器插件指南</li>
</ul>
<p><img src="/images/loading.gif" data-original="../images/development/a00efb1b622ddb0de026071e93a5919a.png" alt=""></p>
<h3 id="特殊功能"><a href="#特殊功能" class="headerlink" title="特殊功能"></a>特殊功能</h3><hr>
<h4 id="多目录工作区支持"><a href="#多目录工作区支持" class="headerlink" title="多目录工作区支持"></a>多目录工作区支持</h4><p>当用户打开了一个<a href="https://code.visualstudio.com/docs/editor/multi-root-workspaces" target="_blank" rel="noopener">多目录工作区</a>，你可能需要将你的语言服务器插件做相应的调整。这个主题探讨了几种多目录工作区的语言服务器的实现方法。 （译者注：官方可能尚未完成这个部分的文档）</p>
<h4 id="嵌入式语言"><a href="#嵌入式语言" class="headerlink" title="嵌入式语言"></a>嵌入式语言</h4><p>嵌入式语言在web开发中是非常常见的，比如HTML中的CSS/JS，JS/TS中的GraphQL。这个主题探讨了针对嵌入语言实现VS Code语言特性的各种方法。 （译者注：官方可能尚未完成这个部分的文档）</p>
<h2 id="语法高亮"><a href="#语法高亮" class="headerlink" title="语法高亮"></a>语法高亮</h2><p>语法高亮决定源代码的颜色和样式，它主要负责关键字（如javascript中的<code>if</code>，<code>for</code>）、字符串、注释、变量名等等语法的着色工作。</p>
<p>语法高亮由两部分工作组成：</p>
<ul>
<li>根据语法将文本解析成符号和作用域</li>
<li>然后根据这份作用域映射应用对应的颜色和样式</li>
</ul>
<p>本文档只教你第一部分：根据语法将文本解析成符号和作用域，然后使用现成的颜色和样式。自定义样式的部分请参考<a href="https://www.bookstack.cn/read/VS-Code-Extension-Doc-ZH/$docs-language-extensions-extension-guides-color-theme#语法色彩" target="_blank" rel="noopener">色彩主题指南</a></p>
<h3 id="TextMate-语法"><a href="#TextMate-语法" class="headerlink" title="TextMate 语法"></a>TextMate 语法</h3><hr>
<p>VS Code使用<a href="https://macromates.com/manual/en/language_grammars" target="_blank" rel="noopener">TextMate 语法</a>将文本分割成一个个符号。TextMate语法是<a href="https://macromates.com/manual/en/regular_expressions" target="_blank" rel="noopener">Oniguruma正则表达式</a>的集合，一般是一份plist或者JSON格式的文件。你可以在<a href="https://www.apeth.com/nonblog/stories/textmatebundle.html" target="_blank" rel="noopener">这里</a>找到更棒的介绍文档，在里面可以找到你感兴趣的TextMate语法。</p>
<h4 id="符号和作用域"><a href="#符号和作用域" class="headerlink" title="符号和作用域"></a>符号和作用域</h4><p>符号是由一门编程语言中最常见的一到几个字符组成的。符号包括运算符（如：<code>+</code>和<code>*</code>），变量名（如：<code>myVar</code>），或者字符串（如：<code>"my string"</code>）。</p>
<p>每个符号都有其作用域，作用域描述了这个符号的上下文。一个符号可被由<strong>点</strong>符号序列查找到，比如javascript中的<code>+</code>符号有这样的作用域<code>keyword.operator.arithmetic.js</code>。</p>
<p>主题会把颜色和样式映射到作用域上，这样一来就实现了语法高亮。TextMate提供了一些主题中<a href="https://macromates.com/manual/en/language_grammars" target="_blank" rel="noopener">常用的作用域</a>，如果你想要尽可能全面地支持语法，最好从现成的主题中入手，避免重新编写主题。</p>
<p>作用域支持嵌套，每个符号都会关联到它的父作用域上。下面的例子使用了作用域检查器，可以清晰地看到javascript函数中的运算符<code>+</code>和它的作用域层级：</p>
<p><img src="/images/loading.gif" data-original="../images/development/749f00099e6e03f3cd2aa1dc42db764c.png" alt=""></p>
<p>父作用域的信息也同样是主题中的一部分。当主题指定了作用域，该作用域下的所有符号都会进行对应的着色，除非主题里面对单个作用域有其特殊配置。</p>
<h4 id="配置基本语法"><a href="#配置基本语法" class="headerlink" title="配置基本语法"></a>配置基本语法</h4><p>VS Code支持JSON格式的TextMate语法。你可以在发布内容配置里面的<code>grammers</code>进行配置。</p>
<p>这个配置点可以配置的内容有：语言的id，顶层语法作用域的名称，语法文件的路径。下面是一个<code>abc</code>语言的语法配置文件：</p>
<pre><code>{
    "contributes": {
        "languages": [
            {
                "id": "abc",
                "extensions": [".abc"]
            }
        ],
        "grammars": [
            {
                "language": "abc",
                "scopeName": "source.abc",
                "path": "./syntaxes/abc.tmGrammar.json"
            }
        ]
    }
}</code></pre><p>这个语法文件本身包含了一个顶层规则，里面一般分为两个部分，<code>patterns</code>列出了程序(program)和<code>repository</code>的顶层元素。语法中的其他规则需要从<code>repository</code>中使用<code>{ "include": "#id" }</code>引入。</p>
<p><code>abc</code>语法标记了字母<code>a</code>，<code>b</code>和<code>c</code>作为关键字，可以被括号包起来成为一个表达式。</p>
<pre><code>{
    "scopeName": "source.abc",
    "patterns": [{ "include": "#expression" }],
    "repository": {
        "expression": {
            "patterns": [{ "include": "#letter" }, { "include": "#paren-expression" }]
        },
        "letter": {
            "match": "a|b|c",
            "name": "keyword.letter"
        },
        "paren-expression": {
            "begin": "\\(",
            "end": "\\)",
            "beginCaptures": {
                "0": { "name": "punctuation.paren.open" }
            },
            "endCaptures": {
                "0": { "name": "punctuation.paren.close" }
            },
            "name": "expression.group",
            "patterns": [{ "include": "#expression" }]
        }
    }
}</code></pre><p>语法引擎会试着逐步将<code>expression</code>中的规则应用到文本中。比如下面这个简单的程序：</p>
<pre><code>a
(
    b
)
x
(
    (
        c
        xyz
    )
)
(
a</code></pre><p>这个例子中的语法产生了下面的作用域列表（从左到右，从最佳匹配到最不匹配）</p>
<pre><code>a               keyword.letter, source.abc
(               punctuation.paren.open, expression.group, source.abc
    b           expression.group, source.abc
)               punctuation.paren.close, expression.group, source.abc
x               source.abc
(               punctuation.paren.open, expression.group, source.abc
    (           punctuation.paren.open, expression.group, expression.group, source.abc
        c       keyword.letter, expression.group, expression.group, source.abc
        xyz     expression.group, expression.group, source.abc
    )           punctuation.paren.close, expression.group, expression.group, source.abc
)               punctuation.paren.close, expression.group, source.abc
(               source.abc
a               keyword.letter, source.abc</code></pre><p>注意文本匹配不是单一规则，比如字符串<code>xyz</code>，是包含在当前作用域中的。文件的最后一个括号在<code>expression.group</code>里面，因为不会匹配<code>end</code>规则。</p>
<h4 id="嵌入式语言-1"><a href="#嵌入式语言-1" class="headerlink" title="嵌入式语言"></a>嵌入式语言</h4><p>如果你的语法中需要在父语言中嵌入其他语言，比如HTML中的CSS，那么你可以使用<code>embeddedLanguages</code>配置，告诉VSCode怎么处理嵌入的语言。然后嵌入语言的括号匹配，注释，和其他基础语言功能都会正常运作。</p>
<p><code>embeddedLanguages</code>配置将嵌入语言的作用域映射到顶层语言的作用域上。下面里的例子里，<code>meta.embedded.block.javascript</code>作用域中的任何符号都会以javscript处理：</p>
<pre><code>{
    "contributes": {
        "grammars": [
            {
                "path": "./syntaxes/abc.tmLanguage.json",
                "scopeName": "source.abc",
                "embeddedLanguages": {
                    "meta.embedded.block.javascript": "source.js"
                }
            }
        ]
    }
}</code></pre><p>现在，如你对应用了<code>meta.embedded.block.javascript</code>的符号进行注释就会有正确的<code>//</code>javascript风格，如果你触发代码片段，也会提示对应的javascript片段。</p>
<h3 id="开发全新的语法插件"><a href="#开发全新的语法插件" class="headerlink" title="开发全新的语法插件"></a>开发全新的语法插件</h3><hr>
<p>使用VS Code的Yeoman模板快速创建一个新的语法插件，运行<code>yo code</code>然后选择<code>New Language</code>：</p>
<p><img src="/images/loading.gif" data-original="../images/development/92a55a8b23b5e5efa3002190171a7d85.png" alt=""></p>
<p>Yeoman通过问问题的方式最后生成新的插件，对于创建语法插件最重要的几点就是：</p>
<ul>
<li><code>Language Id</code> - 这个语言的id</li>
<li><code>Language Name</code> - 友好的名称</li>
<li><code>Scope names</code> - TextMate根作用域名称</li>
</ul>
<p><img src="/images/loading.gif" data-original="../images/development/yo-new-language-questions.png" alt=""></p>
<p>生成器会假设你要同时对新语言定义好语言id和语法。如果你只是根据已有的语言创建新的语法，那么你只要填好目标语言的信息就好，然后一定要删除生成的<code>package.json</code>中的<code>languages</code>部分。</p>
<p>回答了一大堆问题之后，Yeoman会创建一个新的插件，其结构如下：</p>
<p><img src="/images/loading.gif" data-original="../images/development/bc2fb741735d4e90cb0c0d9028112c6e.png" alt=""></p>
<p>!&gt; 注意：如果你只是配置一个VS Code中已有语言的语法，记得删掉生成的<code>package.json</code>中的<code>languages</code>配置。</p>
<h4 id="迁移现成的TextMate语法"><a href="#迁移现成的TextMate语法" class="headerlink" title="迁移现成的TextMate语法"></a>迁移现成的TextMate语法</h4><p><code>yo code</code>也快成帮你把已有的TextMate语法转成一个VS Code插件。使用<code>yo code</code>，选择<code>Language extension</code>，当询问是否从已有TextMate文件插件的时候，填入后缀为<code>.tmLanguage</code>或<code>.json</code>的TextMate语法文件。</p>
<p><img src="/images/loading.gif" data-original="../images/development/881444e9e7f42d78e6065f1609941a31.png" alt=""></p>
<h4 id="用YAML配置语法"><a href="#用YAML配置语法" class="headerlink" title="用YAML配置语法"></a>用YAML配置语法</h4><p>随着语言日益复杂，你可能很快就会难以理解和维护你的json文件。如果你发现自己需要写很多正则表达式，或是需要添加大量解释语法层面的注释，你可能需要考虑使用yaml定义语法文件了。</p>
<p>Yaml语法和json有着同样的结构，但是它的语法更加精简，如多行字符串和注释。</p>
<p><img src="/images/loading.gif" data-original="../images/development/21e6d5c90d532aeb8cf36fda9c7512b3.png" alt=""></p>
<p>VS Code只能加载json语法，所以yaml格式的语法文件必须最终转换成json文件。<a href="https://www.npmjs.com/package/js-yaml" target="_blank" rel="noopener"><code>js-yaml</code>包</a>可以帮你完成这个任务：</p>
<pre><code># Install js-yaml as a development only dependency in your extension
$ npm install js-yaml --save-dev
# Use the command line tool to convert the yaml grammar to json
$ npx js-yaml syntaxes/abc.tmLanguage.yaml &gt; syntaxes/abc.tmLanguage.json</code></pre><h4 id="作用域检查器"><a href="#作用域检查器" class="headerlink" title="作用域检查器"></a>作用域检查器</h4><p>VS Code自带的作用域检查器能帮你调试语法文件。它能显示当前位置<em>符号</em>作用域，以及应用在上面的主题规则和元信息。</p>
<p>在命令面板中输入<code>Developer: Inspect TM Scopes</code>或者<a href="https://code.visualstudio.com/docs/getstarted/keybindings" target="_blank" rel="noopener">使用快捷键</a>启动<em>作用域检查器</em>。</p>
<pre><code>{
    "key": "cmd+alt+shift+i",
    "command": "editor.action.inspectTMScopes"
}</code></pre><p><img src="/images/loading.gif" data-original="../images/development/f6feb546eda5cf416d64297b6c8acbfe.png" alt=""></p>
<p>作用域检查器可以显示以下的信息：</p>
<ol>
<li>当前符号</li>
<li>关于符号的元信息，这些值都是计算后的值。如果你使用了嵌入语言，那么这里最重要的信息就是<code>language</code>和<code>token type</code>了</li>
<li>符号使用的主题规则。这里只显示当前应用的规则，而不显示被其他样式覆盖的规则。</li>
<li>完整的作用域列表，越往上作用域越明确。</li>
</ol>
<h3 id="语法注入"><a href="#语法注入" class="headerlink" title="语法注入"></a>语法注入</h3><hr>
<p>你可以通过<em>语法注入</em>扩展一个现成的语法文件。<em>语法注入</em>就是常规的TextMate语法，<em>语法注入</em>的应用有：</p>
<ul>
<li>高亮注释中的关键字，如<code>TODO</code></li>
<li>对现有语法添加更明确的作用域信息</li>
<li>向Markdown中的代码区块添加语法高亮</li>
</ul>
<h4 id="创建一个基础语法注入"><a href="#创建一个基础语法注入" class="headerlink" title="创建一个基础语法注入"></a>创建一个基础语法注入</h4><p><em>语法注入</em>也是在<code>package.json</code>中配置的，不过这次不需要配置<code>language</code>，而是配置<code>injectTo</code>指明目需要注入的语言作用域列表。</p>
<p>在这个例子里，我们会新建一个非常简单的注入语法，对javascript注释中的<code>TODO</code>进行高亮。我们在<code>injectTo</code>中用<code>source.js</code>指向目标语言的作用域。</p>
<pre><code>{
    "contributes": {
        "grammars": [
            {
                "path": "./syntaxes/injection.json",
                "scopeName": "todo-comment.injection",
                "injectTo": ["source.js"]
            }
        ]
    }
}</code></pre><p>除了顶层的<code>injectionSelector</code>，语法本身就应该是标准的TextMate语法。<code>injectionSelector</code>是一个作用域选择器，它指明了<em>语法注入</em>生效的作用域。在我们的例子里，我们想要在所有<code>//</code>注释中的<code>TODO</code>高亮。使用作用域检查器，我们会发现JavaScript的双斜杠存在作用域<code>comment.line.double-slash</code>，所以我们的注入选择器是<code>L:comment.line.double-slash</code>：</p>
<pre><code>{
    "scopeName": "todo-comment.injection",
    "injectionSelector": "L:comment.line.double-slash",
    "patterns": [
        {
            "include": "#todo-keyword"
        }
    ],
    "repository": {
        "todo-keyword": {
            "match": "TODO",
            "name": "keyword.todo"
        }
    }
}</code></pre><p>注入选择器中的<code>L:</code>代表注入的语法添加在现有语法规则的左边。也就是说我们注入的语法规则会在任何现有语法规则之前生效。</p>
<h4 id="嵌入语法"><a href="#嵌入语法" class="headerlink" title="嵌入语法"></a>嵌入语法</h4><p><em>语法注入</em>也可以用在嵌入语言中，在他们的父级语法中进行配置。就和普通的语法意义，<em>语法注入</em>也可以使用<code>embeddedLanguages</code>将嵌入语言的作用域映射到顶层的语言作用域上。</p>
<p>比如高亮JS字符串中的sql查询的插件，可以使用<code>embeddedLanguages</code>为字符串中所有匹配<code>meta.embedded.inline.sql</code>的符号应用sql语言的基本功能，比如括号匹配和片段选择。</p>
<pre><code>{
    "contributes": {
        "grammars": [
            {
                "path": "./syntaxes/injection.json",
                "scopeName": "sql-string.injection",
                "injectTo": ["source.js"],
                "embeddedLanguages": {
                    "meta.embedded.inline.sql": "source.sql"
                }
            }
        ]
    }
}</code></pre><h4 id="符号类型和嵌入语言"><a href="#符号类型和嵌入语言" class="headerlink" title="符号类型和嵌入语言"></a>符号类型和嵌入语言</h4><p>对于嵌入语言中的注入语言还会有个副作用，那就是VS Code把所有字符串（string）中的<em>符号</em>视为字符文本，而且把注释中的所有<em>符号</em>视为符号内容（token content）。 因此诸如括号匹配和自动补全在字符串和注释中是无法使用的，如果<em>嵌入语言</em>刚好出现在字符串或注释中，那么这些功能就无法在<em>嵌入语言</em>中使用。</p>
<p>想要重载这个行为，你需要使用<code>meta.embedded.*</code>作用域重置VS Code标记字符串和注释行为。最佳实践就是始终将嵌入语言放在<code>meta.embedded.*</code>作用域中，确保VS Code能够正确处理嵌入语言。</p>
<p>如果你无法为你的语法添加<code>meta.embedded.*</code>作用域，你可以在语法配置中用<code>tokenTypes</code>，指定<em>作用域</em>到内容模式（content mode）上。 下面的<code>tokenTypes</code>确保<code>my.sql.template.string</code>作用域中的任何内容都应视为代码：</p>
<pre><code>{
    "contributes": {
        "grammars": [
            {
                "path": "./syntaxes/injection.json",
                "scopeName": "sql-string.injection",
                "injectTo": ["source.js"],
                "embeddedLanguages": {
                    "my.sql.template.string": "source.sql"
                },
                "tokenTypes": {
                    "my.sql.template.string": "other"
                }
            }
        ]
    }
}</code></pre><h2 id="代码片段"><a href="#代码片段" class="headerlink" title="代码片段"></a>代码片段</h2><p><code>contributes.snippets</code>配置允许你将<em>代码片段</em>打包进VS Code插件中。</p>
<p><a href="https://code.visualstudio.com/docs/editor/userdefinedsnippets#_creating-your-own-snippets" target="_blank" rel="noopener">创建代码片段</a>主题详细介绍了新建代码片段的全部内容。本篇指南只是告诉你关于打包<em>代码片段</em>的大体思路。比较推荐的做法是：</p>
<ul>
<li>用<code>Preferences: Configure User Snippets</code>命令创建和调试代码片段。</li>
<li>如果你觉得满意了，将整个JSON文件复制到插件目录下，起个名字比如说<code>snippets.json</code>文件。</li>
<li>将下列配置添加到你的<code>package.json</code>中</li>
</ul>
<pre><code>{
    "contributes": {
        "snippets": [
            {
                "language": "javascript",
                "path": "./snippets.json"
            }
        ]
    }
}</code></pre><p>本篇的源代码在<a href="https://github.com/Microsoft/vscode-extension-samples/tree/master/snippet-sample" target="_blank" rel="noopener">https://github.com/Microsoft/vscode-extension-samples/tree/master/snippet-sample</a></p>
<p>?&gt; 提示：在<code>package.json</code>中添加如下分类，用户才能轻松找到你的插件。</p>
<pre><code>{
    "categories": ["Snippets"]
}</code></pre><h3 id="使用TextMate代码片段"><a href="#使用TextMate代码片段" class="headerlink" title="使用TextMate代码片段"></a>使用TextMate代码片段</h3><hr>
<p>你也可以用<a href="https://www.bookstack.cn/read/VS-Code-Extension-Doc-ZH/$docs-language-extensions-get-started-your-first-extension" target="_blank" rel="noopener">yo code</a>将TextMate代码片段（.tmSnippets）直接添加到插件里去。生成器中的可选项<code>New Code Snippets</code>会帮你指向.tmSnippets的目录，它们最后都会一起打包到VS Code 插件里。生成器甚至还支持Sublime代码片段（.sublime-snippets）。</p>
<p>生成器最终输出的文件有两个：一份插件清单<code>package.json</code>，和一份转换为VS Code代码片段的<code>snippets.json</code>。</p>
<pre><code>.
├── snippets                    // VS Code integration
│   └── snippets.json           // The JSON file w/ the snippets
└── package.json                // extension's manifest</code></pre><p>把生成的代码片段文件夹复制到你的<code>.vscode/extensions</code>下的新文件夹中，然后重启VS Code。</p>
<h2 id="语言配置"><a href="#语言配置" class="headerlink" title="语言配置"></a>语言配置</h2><p>通过<code>contributes.languages</code>发布内容配置，你可以配置以下<em>声明式语言特性</em>：</p>
<ul>
<li>启用/关闭注释</li>
<li>定义括号</li>
<li>自动闭合符号</li>
<li>自动环绕符号</li>
<li>代码折叠</li>
<li>单词匹配</li>
<li>缩进规则</li>
</ul>
<p><a href="https://github.com/Microsoft/vscode-extension-samples/tree/master/language-configuration-sample" target="_blank" rel="noopener">语言配置示例</a>中配置JavaScript文件中的编辑功能。本篇指南会详细解释<code>language-configuration.json</code>中的内容：</p>
<p>!&gt; <strong>注意</strong>：如果你的语言配置文件以<strong><code>language-configuration.json</code></strong>结尾，那么VS Code会帮你添加代码补全和校验功能。</p>
<pre><code>{
    "comments": {
        "lineComment": "//",
        "blockComment": ["/*", "*/"]
    },
    "brackets": [["{", "}"], ["[", "]"], ["(", ")"]],
    "autoClosingPairs": [
        { "open": "{", "close": "}" },
        { "open": "[", "close": "]" },
        { "open": "(", "close": ")" },
        { "open": "'", "close": "'", "notIn": ["string", "comment"] },
        { "open": "\"", "close": "\"", "notIn": ["string"] },
        { "open": "`", "close": "`", "notIn": ["string", "comment"] },
        { "open": "/**", "close": " */", "notIn": ["string"] }
    ],
    "autoCloseBefore": ";:.,=}])&gt;` \n\t",
    "surroundingPairs": [
        ["{", "}"],
        ["[", "]"],
        ["(", ")"],
        ["'", "'"],
        ["\"", "\""],
        ["`", "`"]
    ],
    "folding": {
        "markers": {
            "start": "^\\s*//\\s*#?region\\b",
            "end": "^\\s*//\\s*#?endregion\\b"
        }
    },
    "wordPattern": "(-?\\d*\\.\\d\\w*)|([^\\`\\~\\!\\@\\#\\%\\^\\&amp;\\*\\(\\)\\-\\=\\+\\[\\{\\]\\}\\\\\\|\\;\\:\\'\\\"\\,\\.\\&lt;\\&gt;\\/\\?\\s]+)",
    "indentationRules": {
        "increaseIndentPattern": "^((?!\\/\\/).)*(\\{[^}\"'`]*|\\([^)\"'`]*|\\[[^\\]\"'`]*)$",
        "decreaseIndentPattern": "^((?!.*?\\/\\*).*\\*/)?\\s*[\\}\\]].*$"
    }
}</code></pre><h3 id="启用-关闭注释"><a href="#启用-关闭注释" class="headerlink" title="启用/关闭注释"></a>启用/关闭注释</h3><hr>
<p>VS Code提供了切换注释开关的命令：</p>
<ul>
<li><strong>Toggle Line Comment</strong></li>
<li><strong>Toggle Block Comment</strong></li>
</ul>
<p>分别来配置<code>comments.lineComment</code>控制块注释和<code>comments.blockComment</code>控制行注释。</p>
<pre><code>{
    "comments": {
        "lineComment": "//",
        "blockComment": ["/*", "*/"]
    }
}</code></pre><h3 id="定义括号"><a href="#定义括号" class="headerlink" title="定义括号"></a>定义括号</h3><hr>
<p>你在VS Code中将鼠标移动到一个括号边上时，VS Code会自动高亮对应的括号。</p>
<pre><code>{
    "brackets": [["{", "}"], ["[", "]"], ["(", ")"]]
}</code></pre><p>另外，当你运行<strong>Go to Bracket</strong>或<strong>Select to Bracket</strong>时，VS Code会自动使用你的定义找到最近、最匹配的括号。</p>
<h3 id="自动闭合符号"><a href="#自动闭合符号" class="headerlink" title="自动闭合符号"></a>自动闭合符号</h3><hr>
<p>当你输入<code>'</code>时，VS Code会自动帮你补全另一个单引号然后将光标放在引号中间，我们来看看是怎么做的：</p>
<pre><code>{
    "autoClosingPairs": [
        { "open": "{", "close": "}" },
        { "open": "[", "close": "]" },
        { "open": "(", "close": ")" },
        { "open": "'", "close": "'", "notIn": ["string", "comment"] },
        { "open": "\"", "close": "\"", "notIn": ["string"] },
        { "open": "`", "close": "`", "notIn": ["string", "comment"] },
        { "open": "/**", "close": " */", "notIn": ["string"] }
    ]
}</code></pre><p>配置<code>notIn</code>键（key）可以在你需要的时候关闭这个功能。比如你在写下面的代码：</p>
<pre><code>// ES6's Template String
`ES6's Template String`;</code></pre><p>此时单引号就不会闭合。</p>
<p>用户可以使用<code>editor.autoClosingQuotes</code>和<code>editor.autoClosingBrackets</code>设置<em>自动闭合符号</em>的行为。</p>
<h4 id="在XXX前闭合符号"><a href="#在XXX前闭合符号" class="headerlink" title="在XXX前闭合符号"></a>在XXX前闭合符号</h4><p>如果符号的右边有空白，那么VS Code默认会启用符号闭合，所以当你在JSX代码中输入<code>{</code>时，符号并不会闭合：</p>
<pre><code>const Component = () =&gt;
  &lt;div className={&gt;
                  ^ VS Code默认不会闭合此处的括号
  &lt;/div&gt;</code></pre><p>但是你可以用下面的定义覆盖默认行为：</p>
<pre><code>{
    "autoCloseBefore": ";:.,=}])&gt;` \n\t"
}</code></pre><p>现在如果你在<code>&gt;</code>前面输入<code>{</code>，VS Code会自动补全<code>}</code>。</p>
<h3 id="自动环绕符号"><a href="#自动环绕符号" class="headerlink" title="自动环绕符号"></a>自动环绕符号</h3><hr>
<p>当你选择了一堆文本然后输入左括号时，VS Code会对选中内容外围加上对应的括号。这个功能叫做<em>自动环绕符号</em>，你可以参考下面的代码指定这项功能：</p>
<pre><code>{
    "surroundingPairs": [
        ["{", "}"],
        ["[", "]"],
        ["(", ")"],
        ["'", "'"],
        ["\"", "\""],
        ["`", "`"]
    ]
}</code></pre><p>注意用户可以通过<code>editor.autoSurround</code>设置<em>自动环绕符号</em>的行为。</p>
<h3 id="代码折叠"><a href="#代码折叠" class="headerlink" title="代码折叠"></a>代码折叠</h3><hr>
<p>在VS Code中有三种代码折叠类型：</p>
<ul>
<li>缩进折叠：这是VS Code中默认的缩进行为，当两行内容有着相同的缩进级别时，你就可以看到折叠标记了。</li>
<li>语言配置折叠：当VS Code发现<code>folding.markers</code>同时定义了<code>start</code>和<code>end</code>时，对应区域内就会出现折叠标记。下述配置会对<code>//#region</code>和<code>//#endregionJSON</code>区域创建代码折叠标记：</li>
</ul>
<pre><code>{
    "folding": {
        "markers": {
            "start": "^\\s*//\\s*#?region\\b",
            "end": "^\\s*//\\s*#?endregion\\b"
        }
    }
}</code></pre><ul>
<li>语言服务器折叠：语言服务器获取到<a href="https://microsoft.github.io/language-server-protocol/specification#textDocument_foldingRange" target="_blank" rel="noopener">textDocument/foldingRange</a>请求中的代码折叠列表数据，VS Code之后根据这份列表创建折叠标记。通过语言服务器协议学习更多关于<a href="https://www.bookstack.cn/read/VS-Code-Extension-Doc-ZH/$docs-language-extensions-language-extensions-programmatic-language-features" target="_blank" rel="noopener">程序性语言特性</a>。</li>
</ul>
<h3 id="单词匹配"><a href="#单词匹配" class="headerlink" title="单词匹配"></a>单词匹配</h3><hr>
<p><code>wordPattern</code>定义了程序语言中<em>单词</em>单位。因此当你使用词语相关的命令，如：<strong>Move cursor to word start</strong>（Ctrl+Left）或者<strong>Move cursor to word end</strong>（Ctrl+Right）时，编辑器会根据正则寻找单词边界。</p>
<pre><code>{
    "wordPattern": "(-?\\d*\\.\\d\\w*)|([^\\`\\~\\!\\@\\#\\%\\^\\&amp;\\*\\(\\)\\-\\=\\+\\[\\{\\]\\}\\\\\\|\\;\\:\\'\\\"\\,\\.\\&lt;\\&gt;\\/\\?\\s]+)"
}</code></pre><h3 id="缩进规则"><a href="#缩进规则" class="headerlink" title="缩进规则"></a>缩进规则</h3><hr>
<p><code>indentationRules</code>定义了编辑器应该如何调整当前行或你粘贴、输入、移动的下一行缩进。</p>
<pre><code>{
    "indentationRules": {
        "increaseIndentPattern": "^((?!\\/\\/).)*(\\{[^}\"'`]*|\\([^)\"'`]*|\\[[^\\]\"'`]*)$",
        "decreaseIndentPattern": "^((?!.*?\\/\\*).*\\*/)?\\s*[\\)\\}\\]].*$"
    }
}</code></pre><p>比如，<code>if (true) {</code>匹配<code>increasedIndentPattern</code>，然后如果你在<code>{</code>后面按下Enter后，编辑器会自动缩进一次，你如代码看起来会像这样：</p>
<pre><code>if (true) {
    console.log();</code></pre><p>如果没有设置缩进规则，当行尾以开符号结尾时编辑器会左缩进，以闭合符号结尾时右缩进。这里的<em>开闭符号</em>由<code>brackets</code>定义。</p>
<p>注意<code>editor.formatOnPaste</code>是由<a href="https://code.visualstudio.com/api/references/vscode-api#DocumentRangeFormattingEditProvider" target="_blank" rel="noopener">DocumentRangeFormattingEditProvider</a>控制，而不由自动缩进控制。</p>
<h2 id="程序性语言特性"><a href="#程序性语言特性" class="headerlink" title="程序性语言特性"></a>程序性语言特性</h2><p>程序性语言特性是由<a href="https://code.visualstudio.com/api/references/vscode-api#languages" target="_blank" rel="noopener"><code>vscode.languages.*</code></a>API提供的一系列智能编辑功能。在VS Code中有两种实现动态语言特性的途径。我们先以悬停提示为例：</p>
<pre><code>vscode.languages.registerHoverProvider('javascript', {
    provideHover(document, position, token) {
        return {
            contents: ['Hover Content']
        };
    }
});</code></pre><p>正如你所见，代码中<a href="https://code.visualstudio.com/api/references/vscode-api#languages.registerHoverProvider" target="_blank" rel="noopener"><code>vscode.languages.registerHoverProvider</code></a>API可以很方便地在JS文件中提供悬停提示的内容。这个插件激活后，只要你悬停到了JS代码上，VS Code就会查询全部对JS注册了的<a href="https://code.visualstudio.com/api/references/vscode-api#HoverProvider" target="_blank" rel="noopener"><code>HoverProvider</code></a>然后在悬浮提示框中显示对应内容。你可以查看下面的语言功能列表，里面包含了VS Code API / LSP实现的语言功能。</p>
<p>那么一种实现就是使用了<a href="https://microsoft.github.io/language-server-protocol/" target="_blank" rel="noopener">语言服务器协议</a>的语言服务器。它的实现方式如下：</p>
<ul>
<li>一个为JS同时提供语言客户端和语言服务器的插件</li>
<li>语言客户端就像普通插件一样，运行于Node.js插件主机环境中。这个插件激活后，会启动另一个进程——语言服务器，然后两者通过<a href="https://microsoft.github.io/language-server-protocol/" target="_blank" rel="noopener">语言服务器协议</a>进行通信。</li>
<li>你悬停到JS代码上</li>
<li>VS Code通知语言客户端</li>
<li>语言客户端向语言服务器发起请求，索要悬停的返回结果，最后再送回给VS Code</li>
<li>VS Code将结果展示在悬浮框中</li>
</ul>
<p>这个过程可能看起来有些复杂，但是这么做主要有两个好处：</p>
<ul>
<li>语言服务器可以用任何语言实现</li>
<li>语言服务器可以被多个编辑器重用，提供更加智能的编辑体验</li>
</ul>
<p>深入指南，请移步至语言服务器插件指南</p>
<h3 id="语言功能列表"><a href="#语言功能列表" class="headerlink" title="语言功能列表"></a>语言功能列表</h3><hr>
<table>
<thead>
<tr>
<th align="left">VS Code API</th>
<th align="left">LSP method</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a href="https://code.visualstudio.com/api/references/vscode-api#languages.createDiagnosticCollection" target="_blank" rel="noopener"><code>createDiagnosticCollection</code></a></td>
<td align="left"><a href="https://microsoft.github.io/language-server-protocol/specification#textDocument_publishDiagnostics" target="_blank" rel="noopener">PublishDiagnostics</a></td>
</tr>
<tr>
<td align="left"><a href="https://code.visualstudio.com/api/references/vscode-api#languages.registerCompletionItemProvider" target="_blank" rel="noopener"><code>registerCompletionItemProvider</code></a></td>
<td align="left"><a href="https://microsoft.github.io/language-server-protocol/specification#textDocument_completion" target="_blank" rel="noopener">Completion</a> &amp; <a href="https://microsoft.github.io/language-server-protocol/specification#completionItem_resolve" target="_blank" rel="noopener">Completion Resolve</a></td>
</tr>
<tr>
<td align="left"><a href="https://code.visualstudio.com/api/references/vscode-api#languages.registerHoverProvider" target="_blank" rel="noopener"><code>registerHoverProvider</code></a></td>
<td align="left"><a href="https://microsoft.github.io/language-server-protocol/specification#textDocument_hover" target="_blank" rel="noopener">Hover</a></td>
</tr>
<tr>
<td align="left"><a href="https://code.visualstudio.com/api/references/vscode-api#languages.registerSignatureHelpProvider" target="_blank" rel="noopener"><code>registerSignatureHelpProvider</code></a></td>
<td align="left"><a href="https://microsoft.github.io/language-server-protocol/specification#textDocument_signatureHelp" target="_blank" rel="noopener">SignatureHelp</a></td>
</tr>
<tr>
<td align="left"><a href="https://code.visualstudio.com/api/references/vscode-api#languages.registerDefinitionProvider" target="_blank" rel="noopener"><code>registerDefinitionProvider</code></a></td>
<td align="left"><a href="https://microsoft.github.io/language-server-protocol/specification#textDocument_definition" target="_blank" rel="noopener">Definition</a></td>
</tr>
<tr>
<td align="left"><a href="https://code.visualstudio.com/api/references/vscode-api#languages.registerTypeDefinitionProvider" target="_blank" rel="noopener"><code>registerTypeDefinitionProvider</code></a></td>
<td align="left"><a href="https://microsoft.github.io/language-server-protocol/specification#textDocument_typeDefinition" target="_blank" rel="noopener">TypeDefinition</a></td>
</tr>
<tr>
<td align="left"><a href="https://code.visualstudio.com/api/references/vscode-api#languages.registerImplementationProvider" target="_blank" rel="noopener"><code>registerImplementationProvider</code></a></td>
<td align="left"><a href="https://microsoft.github.io/language-server-protocol/specification#textDocument_implementation" target="_blank" rel="noopener">Implementation</a></td>
</tr>
<tr>
<td align="left"><a href="https://code.visualstudio.com/api/references/vscode-api#languages.registerReferenceProvider" target="_blank" rel="noopener"><code>registerReferenceProvider</code></a></td>
<td align="left"><a href="https://microsoft.github.io/language-server-protocol/specification#textDocument_references" target="_blank" rel="noopener">References</a></td>
</tr>
<tr>
<td align="left"><a href="https://code.visualstudio.com/api/references/vscode-api#languages.registerDocumentHighlightProvider" target="_blank" rel="noopener"><code>registerDocumentHighlightProvider</code></a></td>
<td align="left"><a href="https://microsoft.github.io/language-server-protocol/specification#textDocument_documentHighlight" target="_blank" rel="noopener">DocumentHighlight</a></td>
</tr>
<tr>
<td align="left"><a href="https://code.visualstudio.com/api/references/vscode-api#languages.registerDocumentSymbolProvider" target="_blank" rel="noopener"><code>registerDocumentSymbolProvider</code></a></td>
<td align="left"><a href="https://microsoft.github.io/language-server-protocol/specification#textDocument_documentSymbol" target="_blank" rel="noopener">DocumentSymbol</a></td>
</tr>
<tr>
<td align="left"><a href="https://code.visualstudio.com/api/references/vscode-api#languages.registerCodeActionsProvider" target="_blank" rel="noopener"><code>registerCodeActionsProvider</code></a></td>
<td align="left"><a href="https://microsoft.github.io/language-server-protocol/specification#textDocument_codeAction" target="_blank" rel="noopener">CodeAction</a></td>
</tr>
<tr>
<td align="left"><a href="https://code.visualstudio.com/api/references/vscode-api#languages.registerCodeLensProvider" target="_blank" rel="noopener"><code>registerCodeLensProvider</code></a></td>
<td align="left"><a href="https://microsoft.github.io/language-server-protocol/specification#textDocument_codeLens" target="_blank" rel="noopener">CodeLens</a> &amp; <a href="https://microsoft.github.io/language-server-protocol/specification#codeLens_resolve" target="_blank" rel="noopener">CodeLens Resolve</a></td>
</tr>
<tr>
<td align="left"><a href="https://code.visualstudio.com/api/references/vscode-api#languages.registerDocumentLinkProvider" target="_blank" rel="noopener"><code>registerDocumentLinkProvider</code></a></td>
<td align="left"><a href="https://microsoft.github.io/language-server-protocol/specification#textDocument_documentLink" target="_blank" rel="noopener">DocumentLink</a> &amp; <a href="https://microsoft.github.io/language-server-protocol/specification#documentLink_resolve" target="_blank" rel="noopener">DocumentLink</a></td>
</tr>
<tr>
<td align="left"><a href="https://code.visualstudio.com/api/references/vscode-api#languages.registerDocumentColorProvider" target="_blank" rel="noopener"><code>registerColorProvider</code></a></td>
<td align="left"><a href="https://microsoft.github.io/language-server-protocol/specification#textDocument_documentColor" target="_blank" rel="noopener">DocumentColor</a> &amp; <a href="https://microsoft.github.io/language-server-protocol/specification#textDocument_colorPresentation" target="_blank" rel="noopener">Color Presentation</a></td>
</tr>
<tr>
<td align="left"><a href="https://code.visualstudio.com/api/references/vscode-api#languages.registerDocumentFormattingEditProvider" target="_blank" rel="noopener"><code>registerDocumentFormattingEditProvider</code></a></td>
<td align="left"><a href="https://microsoft.github.io/language-server-protocol/specification#textDocument_formatting" target="_blank" rel="noopener">Formatting</a></td>
</tr>
<tr>
<td align="left"><a href="https://code.visualstudio.com/api/references/vscode-api#languages.registerDocumentRangeFormattingEditProvider" target="_blank" rel="noopener"><code>registerDocumentRangeFormattingEditProvider</code></a></td>
<td align="left"><a href="https://microsoft.github.io/language-server-protocol/specification#textDocument_rangeFormatting" target="_blank" rel="noopener">RangeFormatting</a></td>
</tr>
<tr>
<td align="left"><a href="https://code.visualstudio.com/api/references/vscode-api#languages.registerOnTypeFormattingEditProvider" target="_blank" rel="noopener"><code>registerOnTypeFormattingEditProvider</code></a></td>
<td align="left"><a href="https://microsoft.github.io/language-server-protocol/specification#textDocument_onTypeFormatting" target="_blank" rel="noopener">OnTypeFormatting</a></td>
</tr>
<tr>
<td align="left"><a href="https://code.visualstudio.com/api/references/vscode-api#languages.registerRenameProvider" target="_blank" rel="noopener"><code>registerRenameProvider</code></a></td>
<td align="left"><a href="https://microsoft.github.io/language-server-protocol/specification#textDocument_rename" target="_blank" rel="noopener">Rename</a> &amp; <a href="https://microsoft.github.io/language-server-protocol/specification#textDocument_prepareRename" target="_blank" rel="noopener">Prepare Rename</a></td>
</tr>
<tr>
<td align="left"><a href="https://code.visualstudio.com/api/references/vscode-api#languages.registerFoldingRangeProvider" target="_blank" rel="noopener"><code>registerFoldingRangeProvider</code></a></td>
<td align="left"><a href="https://microsoft.github.io/language-server-protocol/specification#textDocument_foldingRange" target="_blank" rel="noopener">FoldingRange</a></td>
</tr>
</tbody></table>
<h3 id="提供诊断信息"><a href="#提供诊断信息" class="headerlink" title="提供诊断信息"></a>提供诊断信息</h3><hr>
<p>诊断信息是提示代码问题的一种方式。</p>
<p><img src="/images/loading.gif" data-original="../images/development/f6e7bde40c12e4f663bc392b636903e8.gif" alt=""></p>
<h5 id="语言服务器协议"><a href="#语言服务器协议" class="headerlink" title="语言服务器协议"></a>语言服务器协议</h5><p>语言服务器需要向客户端发送<code>textDocument/publishDiagnostics</code>信息，这个信息中包含了诊断信息url的数组。</p>
<p>!&gt; <strong>注意：</strong>客户端不会主动向服务端请求信息，需要服务器将诊断信息推送到客户端。</p>
<h5 id="直接实现"><a href="#直接实现" class="headerlink" title="直接实现"></a>直接实现</h5><pre><code>let diagnosticCollection: vscode.DiagnosticCollection;
export function activate(ctx: vscode.ExtensionContext): void {
  ...
  ctx.subscriptions.push(getDisposable());
  diagnosticCollection = vscode.languages.createDiagnosticCollection('go');
  ctx.subscriptions.push(diagnosticCollection);
  ...
}
function onChange() {
  let uri = document.uri;
  check(uri.fsPath, goConfig).then(errors =&gt; {
    diagnosticCollection.clear();
    let diagnosticMap: Map&lt;string, vscode.Diagnostic[]&gt; = new Map();
    errors.forEach(error =&gt; {
      let canonicalFile = vscode.Uri.file(error.file).toString();
      let range = new vscode.Range(error.line-1, error.startColumn, error.line-1, error.endColumn);
      let diagnostics = diagnosticMap.get(canonicalFile);
      if (!diagnostics) { diagnostics = []; }
      diagnostics.push(new vscode.Diagnostic(range, error.msg, error.severity));
      diagnosticMap.set(canonicalFile, diagnostics);
    });
    diagnosticMap.forEach((diags, file) =&gt; {
      diagnosticCollection.set(vscode.Uri.parse(file), diags);
    });
  })
}</code></pre><blockquote>
<p><strong>基础实现</strong></p>
<p>只对打开的编辑器提供诊断，保证至少在每次保存文件时诊断一次。诊断信息最好能随编辑器的文档内容变化触发。</p>
<p><strong>进阶实现</strong></p>
<p>不仅仅为打开的编辑器提供诊断，而是诊断当前打开的文件目录中的所有资源，不论文件是被打开还是关闭。</p>
</blockquote>
<h3 id="提供补全建议"><a href="#提供补全建议" class="headerlink" title="提供补全建议"></a>提供补全建议</h3><hr>
<p>代码补全可以给用户提供内容感知建议。</p>
<p><img src="/images/loading.gif" data-original="../images/development/6472fa08b9a126d96a77123539d9f537.gif" alt=""></p>
<h5 id="语言服务器协议-1"><a href="#语言服务器协议-1" class="headerlink" title="语言服务器协议"></a>语言服务器协议</h5><p>在接收响应的<code>initialize</code>方法中，你的语言服务器需要声明它是否能提供补全，以及它是否支持动态计算补全项的<code>completionItem\resolve</code>方法。</p>
<pre><code>{
    ...
    "capabilities" : {
        "completionProvider" : {
            "resolveProvider": "true",
            "triggerCharacters": [ '.' ]
        }
        ...
    }
}</code></pre><h5 id="直接实现-1"><a href="#直接实现-1" class="headerlink" title="直接实现"></a>直接实现</h5><pre><code>class GoCompletionItemProvider implements vscode.CompletionItemProvider {
    public provideCompletionItems(
        document: vscode.TextDocument, position: vscode.Position, token: vscode.CancellationToken):
        Thenable&lt;vscode.CompletionItem[]&gt; {
    ...
    }
}
export function activate(ctx: vscode.ExtensionContext): void {
    ...
    ctx.subscriptions.push(getDisposable());
    ctx.subscriptions.push(
        vscode.languages.registerCompletionItemProvider(
            GO_MODE, new GoCompletionItemProvider(), '.', '\"'));
    ...
}</code></pre><blockquote>
<p><strong>基础实现</strong></p>
<p>不支持本功能</p>
<p><strong>进阶实现</strong></p>
<p>当用户挑选补全项时，动态计算补全项的相关信息，这条信息会浮现在补全项旁边。</p>
</blockquote>
<h3 id="显示悬浮提示"><a href="#显示悬浮提示" class="headerlink" title="显示悬浮提示"></a>显示悬浮提示</h3><hr>
<p>悬浮信息会展示在鼠标光标的下方，为用户提供符号/对象的相关信息，一般展示关于符号的类型和描述。</p>
<p><img src="/images/loading.gif" data-original="../images/development/abf2ea96e0c3a87f2f166233badfb020.gif" alt=""></p>
<h5 id="语言服务器协议-2"><a href="#语言服务器协议-2" class="headerlink" title="语言服务器协议"></a>语言服务器协议</h5><p>为了响应请求<code>initialize</code>方法，语言服务器需要声明它能提供这项功能。</p>
<pre><code>{
    ...
    "capabilities" : {
        "hoverProvider" : "true",
        ...
    }
}</code></pre><p>另外，你的语言服务器还要能够响应<code>textDocument/hover</code>请求。</p>
<h5 id="直接实现-2"><a href="#直接实现-2" class="headerlink" title="直接实现"></a>直接实现</h5><pre><code>class GoHoverProvider implements HoverProvider {
    public provideHover(
        document: TextDocument, position: Position, token: CancellationToken):
        Thenable&lt;Hover&gt; {
    ...
    }
}
export function activate(ctx: vscode.ExtensionContext): void {
    ...
    ctx.subscriptions.push(
        vscode.languages.registerHoverProvider(
            GO_MODE, new GoHoverProvider()));
    ...
}</code></pre><blockquote>
<p><strong>基础实现</strong> 显示符号的类型和相关文档描述。</p>
<p><strong>进阶实现</strong> 对方法名进行着色，就像你的源码一样</p>
</blockquote>
<h3 id="函数和方法签名"><a href="#函数和方法签名" class="headerlink" title="函数和方法签名"></a>函数和方法签名</h3><hr>
<p>当用户输入函数和方法时，显示调用该方法的相关信息。</p>
<p><img src="/images/loading.gif" data-original="../images/development/5da3d03687a5e8b78a3214fc25e8d123.gif" alt=""></p>
<h5 id="语言服务器协议-3"><a href="#语言服务器协议-3" class="headerlink" title="语言服务器协议"></a>语言服务器协议</h5><p>为了响应请求<code>initialize</code>方法，语言服务器需要声明它能提供这项功能。</p>
<pre><code>{
    ...
    "capabilities" : {
        "signatureHelpProvider" : {
            "triggerCharacters": [ '(' ]
        }
        ...
    }
}</code></pre><p>另外，你的语言服务器还要能够响应<code>textDocument/signatureHelp</code>请求。</p>
<h5 id="直接实现-3"><a href="#直接实现-3" class="headerlink" title="直接实现"></a>直接实现</h5><pre><code>class GoSignatureHelpProvider implements SignatureHelpProvider {
    public provideSignatureHelp(
        document: TextDocument, position: Position, token: CancellationToken):
        Promise&lt;SignatureHelp&gt; {
    ...
    }
}
export function activate(ctx: vscode.ExtensionContext): void {
    ...
    ctx.subscriptions.push(
        vscode.languages.registerSignatureHelpProvider(
            GO_MODE, new GoSignatureHelpProvider(), '(', ','));
    ...
}</code></pre><blockquote>
<p><strong>基础实现</strong></p>
<p>签名帮助需要包含参数的相关文档。</p>
<p><strong>进阶实现</strong></p>
<p>无</p>
</blockquote>
<h3 id="符号定义"><a href="#符号定义" class="headerlink" title="符号定义"></a>符号定义</h3><hr>
<p>允许用户查看变量/函数/方法的定义。</p>
<p><img src="/images/loading.gif" data-original="../images/development/goto-definition.gif" alt=""></p>
<h5 id="语言服务器协议-4"><a href="#语言服务器协议-4" class="headerlink" title="语言服务器协议"></a>语言服务器协议</h5><p>为了响应请求<code>initialize</code>方法，语言服务器需要声明它能提供这项功能。</p>
<pre><code>{
    ...
    "capabilities" : {
        "definitionProvider" : "true"
        ...
    }
}</code></pre><p>另外，你的语言服务器还要能够响应<code>textDocument/definition</code>请求。</p>
<h5 id="直接实现-4"><a href="#直接实现-4" class="headerlink" title="直接实现"></a>直接实现</h5><pre><code>lass GoDefinitionProvider implements vscode.DefinitionProvider {
    public provideDefinition(
        document: vscode.TextDocument, position: vscode.Position, token: vscode.CancellationToken):
        Thenable&lt;vscode.Location&gt; {
    ...
    }
}
export function activate(ctx: vscode.ExtensionContext): void {
    ...
    ctx.subscriptions.push(
        vscode.languages.registerDefinitionProvider(
            GO_MODE, new GoDefinitionProvider()));
    ...
}</code></pre><blockquote>
<p><strong>基础实现</strong></p>
<p>如果符号有多个定义，你可以显示多条定义。</p>
<p><strong>进阶实现</strong></p>
<p>无</p>
</blockquote>
<h3 id="查找符号的全部引用"><a href="#查找符号的全部引用" class="headerlink" title="查找符号的全部引用"></a>查找符号的全部引用</h3><hr>
<p>允许用户在当前编辑器直接查看变量/函数/方法的定义的源代码。</p>
<p><img src="/images/loading.gif" data-original="../images/development/87cce207db9dbc10f3d9f170893688db.gif" alt=""></p>
<h5 id="语言服务器协议-5"><a href="#语言服务器协议-5" class="headerlink" title="语言服务器协议"></a>语言服务器协议</h5><p>为了响应请求<code>initialize</code>方法，语言服务器需要声明它能提供这项功能。</p>
<pre><code>{
    ...
    "capabilities" : {
        "referencesProvider" : "true"
        ...
    }
}</code></pre><p>另外，你的语言服务器还要能够响应<code>textDocument/references</code>请求。</p>
<h5 id="直接实现-5"><a href="#直接实现-5" class="headerlink" title="直接实现"></a>直接实现</h5><pre><code>class GoReferenceProvider implements vscode.ReferenceProvider {
    public provideReferences(
        document: vscode.TextDocument, position: vscode.Position,
        options: { includeDeclaration: boolean }, token: vscode.CancellationToken):
        Thenable&lt;vscode.Location[]&gt; {
    ...
    }
}
export function activate(ctx: vscode.ExtensionContext): void {
    ...
    ctx.subscriptions.push(
        vscode.languages.registerReferenceProvider(
            GO_MODE, new GoReferenceProvider()));
    ...
}</code></pre><blockquote>
<p><strong>基础实现</strong></p>
<p>为所有引用返回引用位置（资源的url和范围）</p>
<p><strong>进阶实现</strong></p>
<p>无</p>
</blockquote>
<h3 id="高亮匹配符号"><a href="#高亮匹配符号" class="headerlink" title="高亮匹配符号"></a>高亮匹配符号</h3><hr>
<p>允许用户在打开的编辑器中查看某个符号的全部匹配项。</p>
<p><img src="/images/loading.gif" data-original="../images/development/document-highlights.gif" alt=""></p>
<h5 id="语言服务器协议-6"><a href="#语言服务器协议-6" class="headerlink" title="语言服务器协议"></a>语言服务器协议</h5><p>为了响应请求<code>initialize</code>方法，语言服务器需要声明它能提供这项功能。</p>
<pre><code>{
    ...
    "capabilities" : {
        "documentHighlightProvider" : "true"
        ...
    }
}</code></pre><p>另外，你的语言服务器还要能够响应<code>textDocument/documentHighlight</code>请求。</p>
<h5 id="直接实现-6"><a href="#直接实现-6" class="headerlink" title="直接实现"></a>直接实现</h5><pre><code>class GoDocumentHighlightProvider implements vscode.DocumentHighlightProvider {
    public provideDocumentHighlights(
        document: vscode.TextDocument, position: vscode.Position, token: vscode.CancellationToken):
        vscode.DocumentHighlight[] | Thenable&lt;vscode.DocumentHighlight[]&gt;;
    ...
    }
}
export function activate(ctx: vscode.ExtensionContext): void {
    ...
    ctx.subscriptions.push(
        vscode.languages.registerDocumentHighlightProvider(
            GO_MODE, new GoDocumentHighlightProvider()));
    ...
}</code></pre><blockquote>
<p><strong>基础实现</strong></p>
<p>返回引用文档</p>
<p><strong>进阶实现</strong></p>
<p>无</p>
</blockquote>
<h3 id="显示当前文档中的符号定义"><a href="#显示当前文档中的符号定义" class="headerlink" title="显示当前文档中的符号定义"></a>显示当前文档中的符号定义</h3><hr>
<p>允许用户在打开的编辑器中快速跳转到任何符号定义。</p>
<p><img src="/images/loading.gif" data-original="../images/development/document-symbols.gif" alt=""></p>
<h5 id="语言服务器协议-7"><a href="#语言服务器协议-7" class="headerlink" title="语言服务器协议"></a>语言服务器协议</h5><p>为了响应请求<code>initialize</code>方法，语言服务器需要声明它能提供这项功能。</p>
<pre><code>{
    ...
    "capabilities" : {
        "documentSymbolProvider" : "true"
        ...
    }
}</code></pre><p>另外，你的语言服务器还要能够响应<code>textDocument/documentSymbol</code>请求。</p>
<h5 id="直接实现-7"><a href="#直接实现-7" class="headerlink" title="直接实现"></a>直接实现</h5><pre><code>class GoDocumentSymbolProvider implements vscode.DocumentSymbolProvider {
    public provideDocumentSymbols(
        document: vscode.TextDocument, token: vscode.CancellationToken):
        Thenable&lt;vscode.SymbolInformation[]&gt; {
    ...
    }
}
export function activate(ctx: vscode.ExtensionContext): void {
    ...
    ctx.subscriptions.push(
        vscode.languages.registerDocumentSymbolProvider(
            GO_MODE, new GoDocumentSymbolProvider()));
    ...
}</code></pre><blockquote>
<p><strong>基础实现</strong></p>
<p>返回文档中的所有符号。将符号分类，如变量、函数、类、方法等。</p>
<p><strong>进阶实现</strong></p>
<p>无</p>
</blockquote>
<h3 id="显示文件夹中的符号定义"><a href="#显示文件夹中的符号定义" class="headerlink" title="显示文件夹中的符号定义"></a>显示文件夹中的符号定义</h3><hr>
<p>允许用户在打开的文件夹（工作区）中快速跳转到任何符号定义。</p>
<p><img src="/images/loading.gif" data-original="../images/development/92951bb0d0fedef23d9d214b7792b6df.gif" alt=""></p>
<h5 id="语言服务器协议-8"><a href="#语言服务器协议-8" class="headerlink" title="语言服务器协议"></a>语言服务器协议</h5><p>为了响应请求<code>initialize</code>方法，语言服务器需要声明它能提供这项功能。</p>
<pre><code>{
    ...
    "capabilities" : {
        "workspaceSymbolProvider" : "true"
        ...
    }
}</code></pre><p>另外，你的语言服务器还要能够响应<code>workspace/symbol</code>请求。</p>
<h5 id="直接实现-8"><a href="#直接实现-8" class="headerlink" title="直接实现"></a>直接实现</h5><pre><code>class GoWorkspaceSymbolProvider implements vscode.WorkspaceSymbolProvider {
    public provideWorkspaceSymbols(
        query: string, token: vscode.CancellationToken):
        Thenable&lt;vscode.SymbolInformation[]&gt; {
    ...
    }
}
export function activate(ctx: vscode.ExtensionContext): void {
    ...
    ctx.subscriptions.push(
        vscode.languages.registerWorkspaceSymbolProvider(
            new GoWorkspaceSymbolProvider()));
    ...
}</code></pre><blockquote>
<p><strong>基础实现</strong></p>
<p>返回文件夹中所有匹配的符号。将符号分类，如变量、函数、类、方法等。</p>
<p><strong>进阶实现</strong></p>
<p>无</p>
</blockquote>
<h3 id="处理错误和警告"><a href="#处理错误和警告" class="headerlink" title="处理错误和警告"></a>处理错误和警告</h3><hr>
<p>为用户提供处理错误和警告的办法。如果有更正操作可用，就会在那个错误边上显示一个小灯泡。当用户点击灯泡的时候，会显示出操作列表。</p>
<p><img src="/images/loading.gif" data-original="../images/development/57277cc75f6be1dabda83931669228d3.gif" alt=""></p>
<h5 id="语言服务器协议-9"><a href="#语言服务器协议-9" class="headerlink" title="语言服务器协议"></a>语言服务器协议</h5><p>为了响应请求<code>initialize</code>方法，语言服务器需要声明它能提供这项功能。</p>
<pre><code>{
    ...
    "capabilities" : {
        "codeActionProvider" : "true"
        ...
    }
}</code></pre><p>另外，你的语言服务器还要能够响应<code>textDocument/codeAction</code>请求。</p>
<h5 id="直接实现-9"><a href="#直接实现-9" class="headerlink" title="直接实现"></a>直接实现</h5><pre><code>class GoCodeActionProvider implements vscode.CodeActionProvider {
    public provideCodeActions(
        document: vscode.TextDocument, range: vscode.Range,
        context: vscode.CodeActionContext, token: vscode.CancellationToken):
        Thenable&lt;vscode.Command[]&gt; {
    ...
    }
}
export function activate(ctx: vscode.ExtensionContext): void {
    ...
    ctx.subscriptions.push(
        vscode.languages.registerCodeActionsProvider(
            GO_MODE, new GoCodeActionProvider()));
    ...
}</code></pre><blockquote>
<p><strong>基础实现</strong></p>
<p>为错误/警告提供更正操作。</p>
<p><strong>进阶实现</strong></p>
<p>提供源码级别的操作，如重构、提取方法等。</p>
</blockquote>
<h3 id="CodeLens-为源代码提供更多操作"><a href="#CodeLens-为源代码提供更多操作" class="headerlink" title="CodeLens - 为源代码提供更多操作"></a>CodeLens - 为源代码提供更多操作</h3><hr>
<p>为用户弹出一个可以操作、包含上下文信息的分隔弹出框。</p>
<p><img src="/images/loading.gif" data-original="../images/development/cc9832b4a89362bbc7af69bbd4b1c053.gif" alt=""></p>
<h5 id="语言服务器协议-10"><a href="#语言服务器协议-10" class="headerlink" title="语言服务器协议"></a>语言服务器协议</h5><p>为了响应请求<code>initialize</code>方法，语言服务器需要声明它能提供这项功能，以及它是否支持将<code>codeLens\resolve</code>方法绑定到CodeLens的命令上。</p>
<pre><code>{
    ...
    "capabilities" : {
        "codeLensProvider" : {
            "resolveProvider": "true"
        }
        ...
    }
}</code></pre><p>另外，你的语言服务器还要能够响应<code>textDocument/codeLens</code>请求。</p>
<h5 id="直接实现-10"><a href="#直接实现-10" class="headerlink" title="直接实现"></a>直接实现</h5><pre><code>class GoCodeLensProvider implements vscode.CodeLensProvider {
    public provideCodeLenses(document: TextDocument, token: CancellationToken):
        CodeLens[] | Thenable&lt;CodeLens[]&gt; {
    ...
    }
    public resolveCodeLens?(codeLens: CodeLens, token: CancellationToken):
         CodeLens | Thenable&lt;CodeLens&gt; {
    ...
    }
}
export function activate(ctx: vscode.ExtensionContext): void {
    ...
    ctx.subscriptions.push(
        vscode.languages.registerCodeLensProvider(
            GO_MODE, new GoCodeLensProvider()));
    ...
}</code></pre><blockquote>
<p><strong>基础实现</strong></p>
<p>为文档提供CodeLens结果。</p>
<p><strong>进阶实现</strong></p>
<p>将Codelens结果绑定到响应<code>codeLens/resolve</code>的命令上。</p>
</blockquote>
<h3 id="颜色拾取器"><a href="#颜色拾取器" class="headerlink" title="颜色拾取器"></a>颜色拾取器</h3><hr>
<p>允许用户在文件中预览和修改颜色。</p>
<p><img src="/images/loading.gif" data-original="../images/development/a7411330f51b87675fec30e3810f9909.png" alt=""></p>
<h5 id="语言服务器协议-11"><a href="#语言服务器协议-11" class="headerlink" title="语言服务器协议"></a>语言服务器协议</h5><p>为了响应请求<code>initialize</code>方法，语言服务器需要声明它能提供这项功能。</p>
<pre><code>{
    ...
    "capabilities" : {
        "colorProvider" : "true"
        ...
    }
}</code></pre><p>另外，你的语言服务器还要能够响应<code>textDocument/documentColor</code>和<code>textDocument/colorPresentation</code>请求。</p>
<h5 id="直接实现-11"><a href="#直接实现-11" class="headerlink" title="直接实现"></a>直接实现</h5><pre><code>class GoColorProvider implements vscode.DocumentColorProvider {
    public provideDocumentColors(
        document: vscode.TextDocument, token: vscode.CancellationToken):
        Thenable&lt;vscode.ColorInformation[]&gt; {
    ...
    }
    public provideColorPresentations(
        color: Color, context: { document: TextDocument, range: Range }, token: vscode.CancellationToken):
        Thenable&lt;vscode.ColorPresentation[]&gt; {
    ...
    }
}
export function activate(ctx: vscode.ExtensionContext): void {
    ...
    ctx.subscriptions.push(
        vscode.languages.registerColorProvider(
            GO_MODE, new GoColorProvider()));
    ...
}</code></pre><blockquote>
<p><strong>基础实现</strong></p>
<p>返回文档中的全部颜色引用。在颜色面板岁支持色彩格式（如rgb(…)，hsl(…)）</p>
<p><strong>进阶实现</strong></p>
<p>无</p>
</blockquote>
<h3 id="格式化代码"><a href="#格式化代码" class="headerlink" title="格式化代码"></a>格式化代码</h3><hr>
<p>提供整个文档的代码格式化支持。</p>
<p><img src="/images/loading.gif" data-original="../images/development/a70fb2e212fe5df0391fd733a9fcf688.gif" alt=""></p>
<h5 id="语言服务器协议-12"><a href="#语言服务器协议-12" class="headerlink" title="语言服务器协议"></a>语言服务器协议</h5><p>为了响应请求<code>initialize</code>方法，语言服务器需要声明它能提供这项功能。</p>
<pre><code>{
    ...
    "capabilities" : {
        "documentFormattingProvider" : "true"
        ...
    }
}</code></pre><p>另外，你的语言服务器还要能够响应<code>textDocument/formatting</code>请求。</p>
<h5 id="直接实现-12"><a href="#直接实现-12" class="headerlink" title="直接实现"></a>直接实现</h5><pre><code>class GoDocumentFormatter implements vscode.DocumentFormattingEditProvider {
    public formatDocument(document: vscode.TextDocument):
        Thenable&lt;vscode.TextEdit[]&gt; {
    ...
    }
}
export function activate(ctx: vscode.ExtensionContext): void {
    ...
    ctx.subscriptions.push(
        vscode.languages.registerDocumentFormattingEditProvider(
            GO_MODE, new GoDocumentFormatter()));
    ...
}</code></pre><blockquote>
<p><strong>基础实现</strong></p>
<p>不提供格式化支持</p>
<p><strong>进阶实现</strong></p>
<p>你应该尽量减少代码格式化的影响。稍有不慎，诊断功能就可能失效。</p>
</blockquote>
<h3 id="格式化选中区域"><a href="#格式化选中区域" class="headerlink" title="格式化选中区域"></a>格式化选中区域</h3><hr>
<p>为用户选中区域提供代码格式化支持。</p>
<p><img src="/images/loading.gif" data-original="../images/development/0dc2b33086d472dbd6fdc7c557e30591.gif" alt=""></p>
<h5 id="语言服务器协议-13"><a href="#语言服务器协议-13" class="headerlink" title="语言服务器协议"></a>语言服务器协议</h5><p>为了响应请求<code>initialize</code>方法，语言服务器需要声明它能提供这项功能。</p>
<pre><code>{
    ...
    "capabilities" : {
        "documentRangeFormattingProvider" : "true"
        ...
    }
}</code></pre><p>另外，你的语言服务器还要能够响应<code>textDocument/rangeFormatting</code>请求。</p>
<h5 id="直接实现-13"><a href="#直接实现-13" class="headerlink" title="直接实现"></a>直接实现</h5><pre><code>class GoDocumentRangeFormatter implements vscode.DocumentRangeFormattingEditProvider{
    public provideDocumentRangeFormattingEdits(
        document: vscode.TextDocument, range: vscode.Range,
        options: vscode.FormattingOptions, token: vscode.CancellationToken):
        Thenable&lt;vscode.TextEdit[]&gt;;
    ...
    }
}
export function activate(ctx: vscode.ExtensionContext): void {
    ...
    ctx.subscriptions.push(
        vscode.languages.registerDocumentRangeFormattingEditProvider(
            GO_MODE, new GoDocumentRangeFormatter()));
    ...
}</code></pre><blockquote>
<p><strong>基础实现</strong></p>
<p>不提供格式化支持</p>
<p><strong>进阶实现</strong></p>
<p>你应该尽量减少代码格式化的影响。稍有不慎，诊断功能就可能失效。</p>
</blockquote>
<h3 id="随用户输入格式化代码"><a href="#随用户输入格式化代码" class="headerlink" title="随用户输入格式化代码"></a>随用户输入格式化代码</h3><hr>
<p>支持用户输入时动态调整文本格式。</p>
<p>!&gt; <strong>注意：</strong>用户<a href="https://code.visualstudio.com/docs/getstarted/settings" target="_blank" rel="noopener">设置</a>中的<code>editor.formatOnType</code>控制着本功能。</p>
<p><img src="/images/loading.gif" data-original="../images/development/61b5ac9ca2375a5a619681ae07846796.gif" alt=""></p>
<h5 id="语言服务器协议-14"><a href="#语言服务器协议-14" class="headerlink" title="语言服务器协议"></a>语言服务器协议</h5><p>为了响应请求<code>initialize</code>方法，语言服务器需要声明它能提供这项功能。服务器还得告诉客户端哪些字符需要被格式化，<code>moreTriggerCharacters</code>是可选的。</p>
<pre><code>{
    ...
    "capabilities" : {
        "documentOnTypeFormattingProvider" : {
            "firstTriggerCharacter": "}",
            "moreTriggerCharacter": [";", ","]
        }
        ...
    }
}</code></pre><p>另外，你的语言服务器还要能够响应<code>textDocument/onTypeFormatting</code>请求。</p>
<h5 id="直接实现-14"><a href="#直接实现-14" class="headerlink" title="直接实现"></a>直接实现</h5><pre><code>class GoOnTypingFormatter implements vscode.OnTypeFormattingEditProvider{
    public provideOnTypeFormattingEdits(
        document: vscode.TextDocument, position: vscode.Position,
        ch: string, options: vscode.FormattingOptions, token: vscode.CancellationToken):
        Thenable&lt;vscode.TextEdit[]&gt;;
    ...
    }
}
export function activate(ctx: vscode.ExtensionContext): void {
    ...
    ctx.subscriptions.push(
        vscode.languages.registerOnTypeFormattingEditProvider(
            GO_MODE, new GoOnTypingFormatter()));
    ...
}</code></pre><blockquote>
<p><strong>基础实现</strong></p>
<p>不提供格式化支持</p>
<p><strong>进阶实现</strong></p>
<p>你应该尽量减少代码格式化的影响。稍有不慎，诊断功能就可能失效。</p>
</blockquote>
<h3 id="重命名符号"><a href="#重命名符号" class="headerlink" title="重命名符号"></a>重命名符号</h3><hr>
<p>允许用户重命名符号，并更新对应符号的全部引用。</p>
<p><img src="/images/loading.gif" data-original="../images/development/rename.gif" alt=""></p>
<h5 id="语言服务器协议-15"><a href="#语言服务器协议-15" class="headerlink" title="语言服务器协议"></a>语言服务器协议</h5><p>为了响应请求<code>initialize</code>方法，语言服务器需要声明它能提供这项功能。</p>
<pre><code>{
    ...
    "capabilities" : {
        "renameProvider" : "true"
        ...
    }
}</code></pre><p>另外，你的语言服务器还要能够响应<code>textDocument/rename</code>请求。</p>
<h5 id="直接实现-15"><a href="#直接实现-15" class="headerlink" title="直接实现"></a>直接实现</h5><pre><code>class GoRenameProvider implements vscode.RenameProvider {
    public provideRenameEdits(
        document: vscode.TextDocument, position: vscode.Position,
        newName: string, token: vscode.CancellationToken):
        Thenable&lt;vscode.WorkspaceEdit&gt; {
    ...
    }
}
export function activate(ctx: vscode.ExtensionContext): void {
    ...
    ctx.subscriptions.push(
        vscode.languages.registerRenameProvider(
            GO_MODE, new GoRenameProvider()));
    ...
}</code></pre><blockquote>
<p><strong>基础实现</strong></p>
<p>不提供本功能支持。</p>
<p><strong>进阶实现</strong></p>
<p>返回工作区中全部需要生效的编辑区，比如当一个符号在项目的各个地方都被引用时。</p>
</blockquote>
<h2 id="示例：语言服务器"><a href="#示例：语言服务器" class="headerlink" title="示例：语言服务器"></a>示例：语言服务器</h2><p>就如你在程序性语言特性章节所见，实现语言特性的直接方式是使用<code>languages.*</code>API。但是语言服务器不同，它是另一种语言插件的实现方式。</p>
<p>本章将：</p>
<ul>
<li>解释语言服务器插件的好处</li>
<li>手把手教你实现一个语言服务器<a href="https://github.com/Microsoft/vscode-languageserver-node" target="_blank" rel="noopener"><code>Microsoft/vscode-languageserver-node</code></a>，你觉得啰嗦的话，也可以直接看<a href="https://github.com/Microsoft/vscode-extension-samples/tree/master/lsp-sample" target="_blank" rel="noopener">lsp-sample</a>源码。</li>
</ul>
<h3 id="为什么使用语言服务器？"><a href="#为什么使用语言服务器？" class="headerlink" title="为什么使用语言服务器？"></a>为什么使用语言服务器？</h3><hr>
<p>语言服务器是一种可以提升语言编辑体验的特殊VS Code插件。有了语言服务器，你可以实现如自动补全、错误检查（诊断）、转跳到定义等等其他VS Code语言特性。</p>
<p>但是在VS Code中实现语言功能会面临三个问题：</p>
<p>第一，语言服务器一般是用他们自己原生的语言实现的，那么如何与VS Code中的Node.js运行时整合起来就是一个问题。</p>
<p>其二，语言服务器一般都是高消耗的。比如检查文件，语言服务器需要解析大量的文件，构建起抽象语法树然后进行静态分析。这些操作会吃掉很多CPU和内存，但是与此同时VS Code的性能不能受到任何影响。</p>
<p>第三，通常为多个编辑器开发不同的语言插件需要花费大量精力。对于语言插件开发者来说，他们需要根据不同编辑器各自的API来实现插件。而从编辑器的角度来讲，他们也不能指望语言工具API统一。最终导致了为<code>N</code>种编辑器实现<code>M</code>种语言需要花费<code>N*M</code>的工作和精力。</p>
<p>为了解决这些问题，微软提供了<a href="https://microsoft.github.io/language-server-protocol" target="_blank" rel="noopener">语言服务器协议(Language Server Protocol)</a>意图为语言插件和编辑器提供社区规范。这样一来，语言服务器就可以用任何一种语言来实现，用协议通讯也避免了插件在主进程中运行的高开销。而且任何LSP兼容的语言插件，都能和LSP兼容的代码编辑器整合起来，LSP是语言插件开发者和第三方编辑器的共赢方案。</p>
<p><img src="/images/loading.gif" data-original="../images/development/6738d3e51d334232d048ccfc7f447f1f.png" alt=""></p>
<p>在本章，我们将：</p>
<ul>
<li>根据<a href="https://github.com/Microsoft/vscode-languageserver-node" target="_blank" rel="noopener">Node SDK</a>，学习如何在VS Code中新建一个语言服务器插件</li>
<li>学习如何运行、调试、记录日志和测试语言服务器插件</li>
<li>为你提供更多进阶的语言服务器</li>
</ul>
<p>?&gt; <strong>译者注</strong>：本文及其他章节所涉及的<strong>LSP</strong>全为Language Server Protocol的缩写。<strong>语言服务器协议</strong>是VS Code为了调试、分析语言的自带的中间层协议。众所周知，VS Code本身只是一个编辑器，它不含任何编程语言的功能和运行时（javascript和typescript除外），而是将语言的各种特性交给了插件创作者自由实现。</p>
<h3 id="实现你自己的语言服务器"><a href="#实现你自己的语言服务器" class="headerlink" title="实现你自己的语言服务器"></a>实现你自己的语言服务器</h3><hr>
<p>在VS Code中，一个语言服务器有两个部分：</p>
<ul>
<li><strong>语言客户端</strong>：一个由Javascript/Typescript组成的普通插件，这个插件能使用所有的VS Code 命名空间API。</li>
<li><strong>语言服务器</strong>：运行在单独进程中的语言分析工具。</li>
</ul>
<p>语言服务器运行在单独的进程有两个好处：</p>
<ul>
<li>只要能通过LSP通信，语言分析工具可以用任何语言实现。</li>
<li>语言分析工具一般非常消耗CPU和内存，在单独的进程中运行能避免大性能开销</li>
</ul>
<p>下面是一个运行了2个<strong>语言服务器插件</strong>的示意图。HTML语言客户端和PHP语言客户端是常见的VS Code插件。两个客户端都用LSP与各自对应的语言服务器进行通信——即使PHP语言服务器是用PHP写的，但是仍然能通过LSP与PHP语言客户端建立起通信。</p>
<p><img src="/images/loading.gif" data-original="../images/development/8cafc25dca9e8d0b30ff7e5748e9883e.png" alt=""></p>
<p>本篇将指引你学习如何用我们的<a href="https://github.com/Microsoft/vscode-languageserver-node" target="_blank" rel="noopener">Node SDK</a>构建一个语言客户端/服务器。剩下的内容都建立在你已经了解VS Code插件开发的基础之上。</p>
<h3 id="示例：一个简单的纯文本语言服务器"><a href="#示例：一个简单的纯文本语言服务器" class="headerlink" title="示例：一个简单的纯文本语言服务器"></a>示例：一个简单的纯文本语言服务器</h3><hr>
<p>让我们首先实现一个简单的语言服务器插件吧，这个插件的功能是自动补全、诊断纯文本文件。我们会同时学习客户端/服务端的配置。 如果你想直接上手代码：</p>
<ul>
<li><a href="https://github.com/Microsoft/vscode-extension-samples/tree/master/lsp-sample" target="_blank" rel="noopener">lsp-sample</a>：本篇教程的主要源代码，有大量注释</li>
<li><a href="https://github.com/Microsoft/vscode-extension-samples/tree/master/lsp-multi-server-sample" target="_blank" rel="noopener">lsp-multi-server-sample</a>：<strong>lsp-sample</strong>的进阶版本，同样有大量注释，支持<a href="https://code.visualstudio.com/docs/editor/multi-root-workspaces" target="_blank" rel="noopener">多目录工作区</a>特性的语言服务器实例。</li>
</ul>
<p>复制<a href="https://github.com/Microsoft/vscode-extension-samples" target="_blank" rel="noopener">Microsoft/vscode-extension-samples</a>然后打开示例：</p>
<pre><code>&gt; cd lsp-sample
&gt; npm install
&gt; npm run compile
&gt; code .</code></pre><p>安装完所有依赖然后打开<strong>lsp-sample</strong>工作，里面包含客户端和服务器的代码。下面是一个整体的<strong>lsp-sample</strong>目录结构：</p>
<pre><code>.
├── client // 语言客户端
│   ├── src
│   │   ├── test // 语言客户端 / 服务器 的端到端测试
│   │   └── extension.ts // 语言客户端入口
├── package.json // 插件配置清单
└── server // 语言服务器
    └── src
        └── server.ts // 语言服务器入口</code></pre><h3 id="什么是’Language-Client’"><a href="#什么是’Language-Client’" class="headerlink" title="什么是’Language Client’"></a>什么是’Language Client’</h3><hr>
<p>我们先看看<code>/package.json</code>，这个文件描述了语言客户端的能力。里面有3个有趣的部分：</p>
<p>首先看看activationEvents：</p>
<pre><code>"activationEvents": [
    "onLanguage:plaintext"
]</code></pre><p>这个部分告诉VS Code只要打开纯文本文件之后就立刻激活插件（例如：打开一个<code>.txt</code>文件）</p>
<p>下一步看看configuration部分：</p>
<pre><code>"configuration": {
    "type": "object",
    "title": "Example configuration",
    "properties": {
        "languageServerExample.maxNumberOfProblems": {
            "scope": "resource",
            "type": "number",
            "default": 100,
            "description": "Controls the maximum number of problems produced by the server."
        }
    }
}</code></pre><p>这个部分配置了用户可以自定义的<code>configuration</code>，用户通过这个配置可以在<strong>设置</strong>中对你的插件做一些修改。这并不是本节重点，稍后示例将通过代码呈现——插件如何在设置变动后将<strong>修改后的配置</strong>应用到我们的语言服务器上。</p>
<p>真正的语言客户端代码和对应的<code>package.json</code>在<code>/client</code>文件夹中。<code>package.json</code>最有趣的部分是<code>vscode</code>插件主机API和<code>vscode-languageclient</code>这两个依赖库。</p>
<pre><code>"dependencies": {
    "vscode": "^1.1.18",
    "vscode-languageclient": "^4.1.4"
}</code></pre><p>正如上面所说，客户端实现就是一个普通的VS Code插件，它有使用全部VS Code API的能力。</p>
<p>下面是extension.ts文件的对应内容，也是<strong>lsp-sample</strong>插件的入口：</p>
<pre><code>import * as path from 'path';
import { workspace, ExtensionContext } from 'vscode';
import {
    LanguageClient,
    LanguageClientOptions,
    ServerOptions,
    TransportKind
} from 'vscode-languageclient';
let client: LanguageClient;
export function activate(context: ExtensionContext) {
    // 服务器由node实现
    let serverModule = context.asAbsolutePath(
        path.join('server', 'out', 'server.js')
    );
    // 为服务器提供debug选项
    // --inspect=6009: 运行在Node's Inspector mode，这样VS Code就能调试服务器了
    let debugOptions = { execArgv: ['--nolazy', '--inspect=6009'] };
    // 如果插件运行在调试模式那么就会使用debug server options
    // 不然就使用run options
    let serverOptions: ServerOptions = {
        run: { module: serverModule, transport: TransportKind.ipc },
        debug: {
            module: serverModule,
            transport: TransportKind.ipc,
            options: debugOptions
        }
    };
    // 控制语言客户端的选项
    let clientOptions: LanguageClientOptions = {
        // 注册纯文本服务器
        documentSelector: [{ scheme: 'file', language: 'plaintext' }],
        synchronize: {
            // 当文件变动为'.clientrc'中那样时，统治服务器
            fileEvents: workspace.createFileSystemWatcher('**/.clientrc')
        }
    };
    // 创建语言客户端并启动
    client = new LanguageClient(
        'languageServerExample',
        'Language Server Example',
        serverOptions,
        clientOptions
    );
    // 启动客户端，这也同时启动了服务器
    client.start();
}
export function deactivate(): Thenable&lt;void&gt; {
    if (!client) {
        return undefined;
    }
    return client.stop();
}</code></pre><h3 id="什么是’Language-Server’"><a href="#什么是’Language-Server’" class="headerlink" title="什么是’Language Server’"></a>什么是’Language Server’</h3><hr>
<p>?&gt; <strong>小提示：</strong>本节从Github仓库中克隆下来的’server’代码是已经完成的版本，如果你需要跟随本节的步骤循序渐进，你可以新建一个<code>server.ts</code>或者修改克隆的代码。</p>
<p>在这个例子中，服务器是Typescript实现的，由Node.js运行。因为VS Code自带Node.js运行时，所以你无需安装其他依赖，除非你对运行时有特别要求。</p>
<p>这个语言服务器的源码在<code>/server</code>中。比较重要的<code>pacakge.json</code>部分是：</p>
<pre><code>"dependencies": {
    "vscode-languageserver": "^4.1.3"
}</code></pre><p>这行依赖会下载<code>vscode-languageserver</code>库。</p>
<p>下面是一个服务器的实现，提供了简单的纯文本管理——VS Code会向服务器发送一个文件的全部内容。</p>
<pre><code>import {
    createConnection,
    TextDocuments,
    TextDocument,
    Diagnostic,
    DiagnosticSeverity,
    ProposedFeatures,
    InitializeParams,
    DidChangeConfigurationNotification,
    CompletionItem,
    CompletionItemKind,
    TextDocumentPositionParams
} from 'vscode-languageserver';
// 创建一个服务器连接。使用Node的IPC作为传输方式。
// 也包含所有的预览、建议等LSP特性
let connection = createConnection(ProposedFeatures.all);
// 创建一个简单的文本管理器。
// 文本管理器只支持全文本同步。
let documents: TextDocuments = new TextDocuments();
let hasConfigurationCapability: boolean = false;
let hasWorkspaceFolderCapability: boolean = false;
let hasDiagnosticRelatedInformationCapability: boolean = false;
connection.onInitialize((params: InitializeParams) =&gt; {
    let capabilities = params.capabilities;
    // 客户端是否支持`workspace/configuration`请求?
    // 如果不是的话，降级到使用全局设置
    hasConfigurationCapability =
        capabilities.workspace &amp;&amp; !!capabilities.workspace.configuration;
    hasWorkspaceFolderCapability =
        capabilities.workspace &amp;&amp; !!capabilities.workspace.workspaceFolders;
    hasDiagnosticRelatedInformationCapability =
        capabilities.textDocument &amp;&amp;
        capabilities.textDocument.publishDiagnostics &amp;&amp;
        capabilities.textDocument.publishDiagnostics.relatedInformation;
    return {
        capabilities: {
            textDocumentSync: documents.syncKind,
            // 告诉客户端，服务器支持代码补全
            completionProvider: {
                resolveProvider: true
        }
    }
    };
});
connection.onInitialized(() =&gt; {
    if (hasConfigurationCapability) {
        // 为所有配置Register for all configuration changes.
        connection.client.register(
            DidChangeConfigurationNotification.type,
            undefined
        );
    }
    if (hasWorkspaceFolderCapability) {
        connection.workspace.onDidChangeWorkspaceFolders(_event =&gt; {
            connection.console.log('Workspace folder change event received.');
        });
    }
});
// 配置示例
interface ExampleSettings {
    maxNumberOfProblems: number;
}
// 当客户端不支持`workspace/configuration`请求时，使用global settings
// 请注意，在这个例子中服务器使用的客户端并不是问题所在，而是这种情况还可能发生在其他客户端身上。
const defaultSettings: ExampleSettings = { maxNumberOfProblems: 1000 };
let globalSettings: ExampleSettings = defaultSettings;
// 对所有打开的文档配置进行缓存
let documentSettings: Map&lt;string, Thenable&lt;ExampleSettings&gt;&gt; = new Map();
connection.onDidChangeConfiguration(change =&gt; {
    if (hasConfigurationCapability) {
        // 重置所有已缓存的文档配置
        documentSettings.clear();
    } else {
        globalSettings = &lt;ExampleSettings&gt;(
            (change.settings.languageServerExample || defaultSettings)
        );
    }
    // 重新验证所有打开的文本文档
    documents.all().forEach(validateTextDocument);
});
function getDocumentSettings(resource: string): Thenable&lt;ExampleSettings&gt; {
    if (!hasConfigurationCapability) {
        return Promise.resolve(globalSettings);
    }
    let result = documentSettings.get(resource);
    if (!result) {
        result = connection.workspace.getConfiguration({
            scopeUri: resource,
            section: 'languageServerExample'
        });
        documentSettings.set(resource, result);
    }
    return result;
}
// 只对打开的文档保留设置
documents.onDidClose(e =&gt; {
    documentSettings.delete(e.document.uri);
});
// 文档的文本内容发生了改变。
// 这个事件在文档第一次打开或者内容变动时才会触发。
documents.onDidChangeContent(change =&gt; {
    validateTextDocument(change.document);
});
async function validateTextDocument(textDocument: TextDocument): Promise&lt;void&gt; {
    // 在这个简单的示例中，每次校验运行时我们都获取一次配置
    let settings = await getDocumentSettings(textDocument.uri);
    // 校验器如果检测到连续超过2个以上的大写字母则会报错
    let text = textDocument.getText();
    let pattern = /\b[A-Z]{2,}\b/g;
    let m: RegExpExecArray;
    let problems = 0;
    let diagnostics: Diagnostic[] = [];
    while ((m = pattern.exec(text)) &amp;&amp; problems &lt; settings.maxNumberOfProblems) {
        problems++;
        let diagnosic: Diagnostic = {
            severity: DiagnosticSeverity.Warning,
            range: {
                start: textDocument.positionAt(m.index),
                end: textDocument.positionAt(m.index + m[0].length)
            },
            message: `${m[0]} is all uppercase.`,
            source: 'ex'
        };
        if (hasDiagnosticRelatedInformationCapability) {
            diagnosic.relatedInformation = [
                {
                    location: {
                        uri: textDocument.uri,
                        range: Object.assign({}, diagnosic.range)
                    },
                    message: 'Spelling matters'
                },
                {
                    location: {
                        uri: textDocument.uri,
                        range: Object.assign({}, diagnosic.range)
                    },
                    message: 'Particularly for names'
                }
            ];
        }
        diagnostics.push(diagnosic);
    }
    // 将错误处理结果发送给VS Code
    connection.sendDiagnostics({ uri: textDocument.uri, diagnostics });
}
connection.onDidChangeWatchedFiles(_change =&gt; {
    // 监测VS Code中的文件变动
    connection.console.log('We received an file change event');
});
// 这个处理函数提供了初始补全项列表
connection.onCompletion(
    (_textDocumentPosition: TextDocumentPositionParams): CompletionItem[] =&gt; {
    // 传入的变量包含了文本请求代码补全的位置。
    // 如果我们忽略了这个信息，那就只能提供同样的代码补全项了。
    return [
        {
            label: 'TypeScript',
            kind: CompletionItemKind.Text,
            data: 1
        },
        {
            label: 'JavaScript',
            kind: CompletionItemKind.Text,
            data: 2
        }
        ];
    }
);
// 这个函数为补全列表的选中项提供了更多信息
connection.onCompletionResolve(
    (item: CompletionItem): CompletionItem =&gt; {
        if (item.data === 1) {
            item.detail = 'TypeScript details';
            item.documentation = 'TypeScript documentation';
        } else if (item.data === 2) {
            item.detail = 'JavaScript details';
            item.documentation = 'JavaScript documentation';
        }
        return item;
    }
);
/*
connection.onDidOpenTextDocument((params) =&gt; {
    // A text document got opened in VSCode.
    // params.uri uniquely identifies the document. For documents store on disk this is a file URI.
    // params.text the initial full content of the document.
    connection.console.log(`${params.textDocument.uri} opened.`);
});
connection.onDidChangeTextDocument((params) =&gt; {
    // The content of a text document did change in VSCode.
    // params.uri uniquely identifies the document.
    // params.contentChanges describe the content changes to the document.
    connection.console.log(`${params.textDocument.uri} changed: ${JSON.stringify(params.contentChanges)}`);
});
connection.onDidCloseTextDocument((params) =&gt; {
    // A text document got closed in VSCode.
    // params.uri uniquely identifies the document.
    connection.console.log(`${params.textDocument.uri} closed.`);
});
*/
// 让文档管理器监听文档的打开，变动和关闭事件。
documents.listen(connection);
// 连接后启动监听
connection.listen();</code></pre><h3 id="添加一个简单的语法校验器"><a href="#添加一个简单的语法校验器" class="headerlink" title="添加一个简单的语法校验器"></a>添加一个简单的语法校验器</h3><hr>
<p>为了给服务器添加文本校验，我们给text document manager添加一个listener然后在文本变动时调用，接下来就交给服务器去判断调用校验器的最佳时机了。在我们的示例中，服务器的功能是校验纯文本然后给所有大写单词进行标记。对应的代码片段：</p>
<pre><code>// 事件在文档第一次打开，或者内容变动时触发。
documents.onDidChangeContent(async (change) =&gt; {
    // 在这个简单的示例中，每次校验运行时我们都获取一次配置
    let settings = await getDocumentSettings(textDocument.uri);
    // 校验器如果检测到连续超过2个以上的大写字母则会报错
    let text = textDocument.getText();
    let pattern = /\b[A-Z]{2,}\b/g;
    let m: RegExpExecArray;
    let problems = 0;
    let diagnostics: Diagnostic[] = [];
    while ((m = pattern.exec(text))) {
        problems++;
        let diagnosic: Diagnostic = {
            severity: DiagnosticSeverity.Warning,
            range: {
                start: textDocument.positionAt(m.index),
                end: textDocument.positionAt(m.index + m[0].length)
            },
            message: `${m[0]} is all uppercase.`,
            source: 'ex'
        };
        if (hasDiagnosticRelatedInformationCapability) {
            diagnosic.relatedInformation = [
                {
                    location: {
                        uri: textDocument.uri,
                        range: Object.assign({}, diagnosic.range)
                    },
                    message: 'Spelling matters'
                },
                {
                    location: {
                        uri: textDocument.uri,
                        range: Object.assign({}, diagnosic.range)
                    },
                    message: 'Particularly for names'
                }
            ];
        }
        diagnostics.push(diagnosic);
    }
    // 将错误处理结果发送给VS Code
    connection.sendDiagnostics({ uri: textDocument.uri, diagnostics });
}</code></pre><h3 id="诊断提示和小技巧"><a href="#诊断提示和小技巧" class="headerlink" title="诊断提示和小技巧"></a>诊断提示和小技巧</h3><hr>
<ul>
<li>如果出错的开始点和结束点在同一个位置，VS Code会在那个单词的位置上打上波浪线</li>
<li>如果你想要把波浪线加到行未为止，就把<code>end position</code>设置为<code>Number.MAX_VALUE</code></li>
</ul>
<p>运行语言服务器步骤：</p>
<ol>
<li>通过快捷键(Ctrl+Shift+B)启动build任务。这个任务会把客户端和服务器端都编译掉。</li>
<li>打开调试侧边栏，选择<code>启动客户端</code>加载配置，然后按<code>开始调试</code>按钮启动<code>扩展开发主机</code>。</li>
<li>在根目录下新建一个’test.txt’文件，然后粘贴下述内容：</li>
</ol>
<pre><code>TypeScript lets you write JavaScript the way you really want to.
TypeScript is a typed superset of JavaScript that compiles to plain JavaScript.
ANY browser. ANY host. ANY OS. Open Source.</code></pre><p><code>扩展开发主机</code>实例看起来像是这样：</p>
<p><img src="/images/loading.gif" data-original="../images/development/54edb2028e395a2c853b6d9f6c5af309.png" alt=""></p>
<h3 id="调试客户端和服务端"><a href="#调试客户端和服务端" class="headerlink" title="调试客户端和服务端"></a>调试客户端和服务端</h3><hr>
<p>调试客户端代码就像调试普通插件一样简单。在代码中打上断点，然后按F5启动插件调试。</p>
<p><img src="/images/loading.gif" data-original="../images/development/debugging-client.png" alt=""></p>
<p>因为服务器是由<code>LanguageClient</code>启动的，我们需要附加一个<em>调试器</em>给运行中的服务器。为了做到这一点，切换到<strong>调试</strong>侧边栏，选择加载配置<code>Attach to Server</code>然后按F5启动调试（要保证server已经启动哦，也就是上面一步），看起来会像这样：</p>
<p><img src="/images/loading.gif" data-original="../images/development/debugging-server.png" alt=""></p>
<h3 id="为语言服务器加上日志"><a href="#为语言服务器加上日志" class="headerlink" title="为语言服务器加上日志"></a>为语言服务器加上日志</h3><hr>
<p>如果你是用<code>vscode-languageclient</code>实现的客户端，你可以配置<code>[langId].trace.server</code>指示客户端在<code>output(输出)</code>面板中显示通信日志。</p>
<p>对于<strong>Isp-sample</strong>你能在<code>"languageServerExample.trace.server": "verbose"</code>进行配置。现在看看”Language Server Example”频道，你应该能看到这些日志：</p>
<p><img src="/images/loading.gif" data-original="../images/development/5c09390bb6c9c0786e7a02111543f29b.png" alt=""></p>
<p>因为语言服务器通信会非常啰嗦（5s的正常使用会产生5000行日志），因此我们提供了一个可视化和可筛选的日志工具。你可以先从频道中保存所有的日志，然后在<a href="https://microsoft.github.io/language-server-protocol/inspector/" target="_blank" rel="noopener">语言服务器协议检查器</a>中加载。</p>
<p><img src="/images/loading.gif" data-original="../images/development/lsp-inspector.png" alt=""></p>
<h3 id="在服务器中设置Configuration"><a href="#在服务器中设置Configuration" class="headerlink" title="在服务器中设置Configuration"></a>在服务器中设置Configuration</h3><hr>
<p>当我们写插件的客户端部分的时候，我们已经定义了一个控制最大问题报告数的配置。所以我们也可以在服务器中写一段读取客户端配置的代码：</p>
<pre><code>function getDocumentSettings(resource: string): Thenable&lt;ExampleSettings&gt; {
    if (!hasConfigurationCapability) {
        return Promise.resolve(globalSettings);
    }
    let result = documentSettings.get(resource);
    if (!result) {
        result = connection.workspace.getConfiguration({
            scopeUri: resource,
            section: 'languageServerExample'
        });
        documentSettings.set(resource, result);
    }
    return result;
}</code></pre><p>现在唯一要做的事情就是在服务器端中监听用户修改的设置变动，然后重新验证已经打开的文本文件。为了重用文本变动事件的处理函数，我们把代码提取到<code>validateTextDocument</code>函数中，然后新建一个<code>maxNumberOfProblems</code>变量：</p>
<pre><code>async function validateTextDocument(textDocument: TextDocument): Promise&lt;void&gt; {
    // 在这个简单的示例中，每次校验运行时我们都获取一次配置
    let settings = await getDocumentSettings(textDocument.uri);
    // 校验器如果检测到连续超过2个以上的大写字母则会报错
    let text = textDocument.getText();
    let pattern = /\b[A-Z]{2,}\b/g;
    let m: RegExpExecArray;
    let problems = 0;
    let diagnostics: Diagnostic[] = [];
    while ((m = pattern.exec(text)) &amp;&amp; problems &lt; settings.maxNumberOfProblems) {
        problems++;
        let diagnosic: Diagnostic = {
            severity: DiagnosticSeverity.Warning,
            range: {
                start: textDocument.positionAt(m.index),
                end: textDocument.positionAt(m.index + m[0].length)
            },
            message: `${m[0]} is all uppercase.`,
            source: 'ex'
        };
        if (hasDiagnosticRelatedInformationCapability) {
            diagnosic.relatedInformation = [
                {
                    location: {
                        uri: textDocument.uri,
                        range: Object.assign({}, diagnosic.range)
                    },
                    message: 'Spelling matters'
                },
                {
                    location: {
                        uri: textDocument.uri,
                        range: Object.assign({}, diagnosic.range)
                    },
                    message: 'Particularly for names'
                }
            ];
        }
        diagnostics.push(diagnosic);
    }
    // 将错误处理结果发送给VS Code
    connection.sendDiagnostics({ uri: textDocument.uri, diagnostics });
}</code></pre><p>添加一个<em>通知处理函数</em>监听配置文件变动。</p>
<pre><code>connection.onDidChangeConfiguration(change =&gt; {
    if (hasConfigurationCapability) {
        // Reset all cached document settings
        documentSettings.clear();
    } else {
        globalSettings = &lt;ExampleSettings&gt;(
            (change.settings.languageServerExample || defaultSettings)
        );
    }
    // 重新验证所有打开的文本文档
    documents.all().forEach(validateTextDocument);
});</code></pre><p>再次启动客户端，然后把设置中的<code>maximum report</code>改为1，就能看到：</p>
<p><img src="/images/loading.gif" data-original="../images/development/f969ed33f956ae0bdabfb0b9bfe7ad8c.png" alt=""></p>
<h3 id="添加其他语言特性"><a href="#添加其他语言特性" class="headerlink" title="添加其他语言特性"></a>添加其他语言特性</h3><hr>
<p>第一个有趣的东西是，语言服务器通常会实现成文档校验器，从这个点来说，即使一个linter也算一个语言服务器，所以VS Code中的linter通常都是作为语言服务器实现的（参照<a href="https://github.com/Microsoft/vscode-eslint" target="_blank" rel="noopener">eslint</a>和<a href="https://github.com/Microsoft/vscode-jshint" target="_blank" rel="noopener">jslint</a>）。但是语言服务器还能做得更多，他们能提供代码不全，查找所有匹配项或者转跳到定义。下面的代码展示了为服务器添加代码补全的功能，它提供了2个建议单词”TypeScript”和”JavaScript”。</p>
<pre><code>// 这个处理函数提供了初始补全项列表
connection.onCompletion(
    (_textDocumentPosition: TextDocumentPositionParams): CompletionItem[] =&gt; {
        // 传入的变量包含了文本请求代码补全的位置。
        // 如果我们忽略了这个信息，那就只能提供同样的代码补全项了。
        return [
            {
                label: 'TypeScript',
                kind: CompletionItemKind.Text,
                data: 1
            },
            {
                label: 'JavaScript',
                kind: CompletionItemKind.Text,
                data: 2
            }
        ];
    }
);
// 这个函数为补全列表的选中项提供了更多信息
connection.onCompletionResolve(
    (item: CompletionItem): CompletionItem =&gt; {
        if (item.data === 1) {
            (item.detail = 'TypeScript details'),
                (item.documentation = 'TypeScript documentation');
        } else if (item.data === 2) {
            (item.detail = 'JavaScript details'),
                (item.documentation = 'JavaScript documentation');
        }
        return item;
    }
);</code></pre><p><code>data</code>字段用于鉴别处理函数中传入的补全项。这个属性对协议来说是透明的，因为底层协议信息传输是基于JSON的，因此data字段只能保留从JSON序列化而来的数据。</p>
<p>那么现在只缺告诉VS Code服务器能提供代码补全请求。为了做到点，将对应标记添加到初始化函数中：</p>
<pre><code>connection.onInitialize((params): InitializeResult =&gt; {
    ...
    return {
        capabilities: {
            ...
            // 告诉客户端，服务器支持代码补全
            completionProvider: {
                resolveProvider: true
            }
        }
    };
});</code></pre><p>下面的截屏显示了运行在纯文本文件中的补全代码：</p>
<p><img src="/images/loading.gif" data-original="../images/development/e82f3d735915a7cc0eafbee0869db09b.png" alt=""></p>
<h3 id="测试语言服务器"><a href="#测试语言服务器" class="headerlink" title="测试语言服务器"></a>测试语言服务器</h3><hr>
<p>为了创建一个高质量的语言服务器，我们需要构建一个能覆盖到它所有功能点的测试套件。有两种常见的测试服务器的方式：</p>
<ul>
<li>单元测试：如果你想测试特定的功能点，这是一个非常有用的方式，模拟数据然后发送进去。VC Code的<a href="https://github.com/Microsoft/vscode-html-languageservice" target="_blank" rel="noopener">HTML</a>/<a href="https://github.com/Microsoft/vscode-css-languageservice" target="_blank" rel="noopener">CSS</a>/<a href="https://github.com/Microsoft/vscode-json-languageservice" target="_blank" rel="noopener">JSON</a>语言服务器就采用了这种测试方式。LSP的npm模块包也是用这种方式。在<a href="https://github.com/Microsoft/vscode-languageserver-node/blob/master/protocol/src/test/connection.test.ts" target="_blank" rel="noopener">这里</a>查看更多使用npm协议模块的单元测试。</li>
<li>端到端测试：就像VS Code 插件测试一样，这个方式的好处是通过运行VS Code实例，打开文件，激活语言服务器/客户端然后执行VS Code命令来测试的，如果你配置了文件、设置和依赖（如<code>node_modules</code>）以及难以模拟数据的时候，你应该优先考虑这种模式，流行的<a href="https://github.com/Microsoft/vscode-python" target="_blank" rel="noopener">Python</a>插件就采用了这种测试方式。</li>
</ul>
<p>你可以用任何你喜欢的测试框架做单元测试。这里我们只介绍如何对语言服务器插件进行端到端测试。</p>
<p>打开<code>.vscode/launch.json</code>，你能找到<code>E2E</code>测试目标：</p>
<pre><code>{
    "name": "Language Server E2E Test",
    "type": "extensionHost",
    "request": "launch",
    "runtimeExecutable": "${execPath}",
    "args": [
        "--extensionDevelopmentPath=${workspaceRoot}",
        "--extensionTestsPath=${workspaceRoot}/client/out/test",
        "${workspaceRoot}/client/testFixture"
    ],
    "stopOnEntry": false,
    "sourceMaps": true,
    "outFiles": ["${workspaceRoot}/client/out/test/**/*.js"]
}</code></pre><p>如果你运行了这个测试目标，它会打开一个VS Code实例和一个叫做<code>client/testFixtur</code>的激活工作区。VS Code然后会执行所有<code>client/src/test</code>中的测试。一点调试的小提示，你可以在<code>client/src/test</code>的Typescript文件中添加断点。</p>
<p>我们再来看看<code>completion.test.ts</code>文件：</p>
<pre><code>import * as vscode from 'vscode';
import * as assert from 'assert';
import { getDocUri, activate } from './helper';
describe('Should do completion', () =&gt; {
    const docUri = getDocUri('completion.txt');
    it('Completes JS/TS in txt file', async () =&gt; {
        await testCompletion(docUri, new vscode.Position(0, 0), {
            items: [
                { label: 'JavaScript', kind: vscode.CompletionItemKind.Text },
                { label: 'TypeScript', kind: vscode.CompletionItemKind.Text }
            ]
        });
    });
});
async function testCompletion(
    docUri: vscode.Uri,
    position: vscode.Position,
    expectedCompletionList: vscode.CompletionList
) {
    await activate(docUri);
    // 执行 `vscode.executeCompletionItemProvider` 命令，模拟激活代码补全功能
    const actualCompletionList = (await vscode.commands.executeCommand(
        'vscode.executeCompletionItemProvider',
        docUri,
        position
    )) as vscode.CompletionList;
    assert.equal(actualCompletionList.items.length, expectedCompletionList.items.length);
    expectedCompletionList.items.forEach((expectedItem, i) =&gt; {
        const actualItem = actualCompletionList.items[i];
        assert.equal(actualItem.label, expectedItem.label);
        assert.equal(actualItem.kind, expectedItem.kind);
    });
}</code></pre><p>在这个测试中，我们：</p>
<ul>
<li>激活了插件</li>
<li>带上了一个URI和位置模拟信息，然后运行了<code>vscode.executeCompletionItemProvider</code>去触发补全</li>
<li>断言返回的补全项是不是达到了我们的预期</li>
</ul>
<p>我们再深入一点看看<code>activate(docURI)</code>函数。它被定义在<code>client/src/test/helper.ts</code>中：</p>
<pre><code>import * as vscode from 'vscode';
import * as path from 'path';
export let doc: vscode.TextDocument;
export let editor: vscode.TextEditor;
export let documentEol: string;
export let platformEol: string;
/**
 * 激活 vscode.lsp-sample 插件
 */
export async function activate(docUri: vscode.Uri) {
    // extensionId来自于package.json中的`publisher.name`
    const ext = vscode.extensions.getExtension('vscode.lsp-sample');
    await ext.activate();
    try {
        doc = await vscode.workspace.openTextDocument(docUri);
        editor = await vscode.window.showTextDocument(doc);
        await sleep(2000); // 等待服务器激活
    } catch (e) {
        console.error(e);
    }
}
async function sleep(ms: number) {
    return new Promise(resolve =&gt; setTimeout(resolve, ms));
}</code></pre><p>在激活部分，我们：</p>
<ul>
<li>用<code>publisher.name</code> <code>extensionId</code>在<code>package.json</code>中获取到了插件</li>
<li>打开特定的文档，然后显示在文本编辑区</li>
<li>休眠2秒，确保启动了语言服务器</li>
</ul>
<p>准备好之后，我们可以运行对应语言特性的VS Code命令，然后对结果进行断言测试。 这还有一个关于诊断特性的测试实现，如果你感兴趣，可以查看这个文件<code>client/src/test/diagnostics.test.ts</code></p>
<h3 id="进阶主题"><a href="#进阶主题" class="headerlink" title="进阶主题"></a>进阶主题</h3><hr>
<p>到目前为止，本篇教程提供了：</p>
<ul>
<li>一个简短的<strong>语言服务器</strong>和<strong>语言服务器协议</strong>概览</li>
<li>VS Code中的语言服务器插件架构</li>
<li>实现了一个<strong>Isp-sample</strong>插件，和如何开发、调试、检查和测试语言服务器</li>
</ul>
<h4 id="更多语言服务器特性"><a href="#更多语言服务器特性" class="headerlink" title="更多语言服务器特性"></a>更多语言服务器特性</h4><p>除了代码补全之外，VS Code还支持下列特性：</p>
<ul>
<li>文档高亮：高亮文本中的符号</li>
<li>悬停：为选中的文本符号提供悬停信息</li>
<li>Signature Help：为选中的文本提供提供Signature Help</li>
<li>转跳到定义：为选中的文本符号提供定义转跳</li>
<li>转跳到类型定义：为选中的文本符号提供类型/接口定义转跳</li>
<li>转跳到实现：为选中的文本符号提供实现转跳</li>
<li>引用查找：从整个项目中查找选中文本符号的引用</li>
<li>列出文件符号：列出文本文件中的全部符号</li>
<li>列出工作区符号：列出整个项目中的符号</li>
<li>执行代码：在给定文件和范围的条件下运行命令（通常如：美化、重构）</li>
<li>CodeLens: 为给定文件计算 CodeLens 统计数据</li>
<li>文件格式化：包括整个文件的格式化，部分文本格式化和根据类型格式化</li>
<li>重命名：重命名整个项目内的某些符号</li>
<li>文件链接：计算和解析文件中的链接</li>
<li>文件色彩：计算和解析文件中的色彩，并提供编辑器内的取色器</li>
</ul>
<p>程序性语言特性章节详细介绍了上述的语言特性，并且告诉我们如何通过下述(<strong>两者之一</strong>)去实现它们：</p>
<ul>
<li>语言服务器协议</li>
<li>直接使用VS Code的可拓展性API</li>
</ul>
<h3 id="增量文本同步更新"><a href="#增量文本同步更新" class="headerlink" title="增量文本同步更新"></a>增量文本同步更新</h3><hr>
<p>在<code>vscode-languageserver</code>模块中，我们做了一个简单的<code>text document manager</code>同步VS Code和语言服务器。</p>
<p>但是这种方式有两个缺点：</p>
<ul>
<li>文件变动时，会重复地发送整个文本数据，这个传递的数据量相当可观。</li>
<li>现有的库通常都支持增量文本更新，不可避免地，我们会进行不必要的转换和创建抽象语法树。</li>
</ul>
<p>LSP因此直接提供了增量文本更新的API。</p>
<p>现在我们要通过增加3个通知函数实现我们的增量文本更新：</p>
<ul>
<li>onDidOpenTextDocument：当文件打开后调用</li>
<li>onDidChangeTextDocument：当文本变动后调用</li>
<li>onDidCloseTextDocument：当文件关闭后调用</li>
</ul>
<p>下面的代码片段展示了怎么在通信中挂上这些通知函数钩子，在初始化时因如何返回函数：</p>
<pre><code>connection.onInitialize((params): InitializeResult =&gt; {
    ...
    return {
        capabilities: {
            // 启用文档增量更新同步
            textDocumentSync: TextDocumentSyncKind.Incremental,
            ...
        }
    };
});
connection.onDidOpenTextDocument((params) =&gt; {
    // 当文档打开后触发，params.uri提供了文档的唯一地址。如果文档储存在硬盘上，那么就会是一个file类型的URI
    // params.text——提供了文档一开始的内容
});
connection.onDidChangeTextDocument((params) =&gt; {
    // 文档的文本内容发生了改变时触发。
    // params.uri提供了文档的唯一地址。
    // params.contentChanges 包含文档的变动内容
});
connection.onDidCloseTextDocument((params) =&gt; {
    // 文档关闭后触发。
    // params.uri提供了文档的唯一地址。
});</code></pre><h4 id="直接用VS-Code-API实现语言特性"><a href="#直接用VS-Code-API实现语言特性" class="headerlink" title="直接用VS Code API实现语言特性"></a>直接用VS Code API实现语言特性</h4><p>语言服务器有这么多好处，只是用来提供VS Code编辑扩展能力就显得有些大材小用了。下面的例子里，我们使用<code>vscode.languages.register[LANGUAGE_FEATURE]Provider</code>选项为某类文件提供一些简单的语言服务器特性。</p>
<p><a href="https://github.com/Microsoft/vscode-extension-samples/tree/master/completions-sample" target="_blank" rel="noopener">completions-sample</a>是一个使用<code>vscode.languages.registerCompletionItemProvider</code>为纯文本添加代码片段的例子。</p>
<p>更多例子请参阅<a href="https://github.com/Microsoft/vscode-extension-samples" target="_blank" rel="noopener">https://github.com/Microsoft/vscode-extension-samples</a></p>
<h4 id="语言服务器的容错解析器"><a href="#语言服务器的容错解析器" class="headerlink" title="语言服务器的容错解析器"></a>语言服务器的容错解析器</h4><p>大多数时候，编辑器中的代码都是不完整的，甚至语法都是错的，但是开发人员肯定希望自动补全等语言功能保持正常工作。因此，容错解析器就显得十分必要：解析器仍能从不完整的代码中创建有意义的AST，然后语言服务器根据这份AST提供服务。</p>
<p>我们之前在VS Code中做过PHP的支持，我们意识到PHP官方解析器并没有自带容错，而且也不能直接在语言服务器中直接重用。所以我们一起努力做了<a href="https://github.com/Microsoft/tolerant-php-parser" target="_blank" rel="noopener"> Microsoft/tolerant-php-parser</a>，并留下了详细的<a href="https://github.com/Microsoft/tolerant-php-parser/blob/master/docs/HowItWorks.md" target="_blank" rel="noopener">笔记</a>，或许能帮上需要容错解析器的语言服务器作者。</p>
<h3 id="FAQ-1"><a href="#FAQ-1" class="headerlink" title="FAQ"></a>FAQ</h3><ul>
<li><p><strong>问：当我试着向debug添加服务器的时候，我得到了”cannot connect to runtime process (timeout after 5000ms)”的信息？</strong></p>
<p>答：如果服务器没有运行你还强行添加debbuger的时候，会出现这个超时问题，你也可能需要关闭服务器中的断点。</p>
</li>
<li><p><strong>问：虽然我看完了<a href="https://microsoft.github.io/language-server-protocol/" target="_blank" rel="noopener">LSP Specification</a>，但是我还有很多问题解决不了，我可以在哪获得帮助？</strong></p>
<p>答：可以在<a href="https://github.com/Microsoft/language-server-protocol中开issue。" target="_blank" rel="noopener">https://github.com/Microsoft/language-server-protocol中开issue。</a></p>
</li>
</ul>
<h1 id="进阶主题-1"><a href="#进阶主题-1" class="headerlink" title="进阶主题"></a>进阶主题</h1><h2 id="插件主机"><a href="#插件主机" class="headerlink" title="插件主机"></a>插件主机</h2><p>在插件诊断中学习了插件会将<code>active</code>和<code>deactive</code>声明周期函数暴露给VS Code，在本节我们来看看<strong>插件主机/插件宿主(Extension Host)</strong>是怎么管理所有运行中的插件的。</p>
<p><strong>插件主机</strong>是VS Code中负责加载和运行插件的Node.js进程，虽然你在写插件时不必关心这件事，但是掌握插件主机的运行原理对你创作插件还是非常有用的。</p>
<h3 id="稳定性和性能"><a href="#稳定性和性能" class="headerlink" title="稳定性和性能"></a>稳定性和性能</h3><hr>
<p>VS Code致力于为用户提供一个稳定且高性能的编辑环境，因此出错的插件不应该影响到用户的体验。所以<strong>插件主机</strong>可以预防这些事情：</p>
<ul>
<li>启动性能影响</li>
<li>阻塞的UI操作</li>
<li>修改UI</li>
</ul>
<p>另外，VS Code提供的激活事件机制也让插件只在用到时才懒加载它们，比如，Markdown插件应该只在用户打开了Markdown文件时才启动，因此避免了不必要CPU和内存消耗。</p>
<h2 id="支持远程开发"><a href="#支持远程开发" class="headerlink" title="支持远程开发"></a>支持远程开发</h2><p><a href="https://code.visualstudio.com/docs/remote/remote-overview" target="_blank" rel="noopener">VS Code 远程开发</a>允许你无缝在远程机器上开发代码。有了这项支持后，你就可以完全使用VS Code本地插件和你熟悉的方式远程工作了。</p>
<p>本节会介绍远程开发相关的知识，VS Code远程开发 插件架构，在远程目录测试插件，和远程插件不能正常工作的一些建议。大部分插件不需要改动就能适应远程开发环境，其他的插件也只要稍微改动一点就能适配远程开发了。</p>
<h3 id="架构和插件类型"><a href="#架构和插件类型" class="headerlink" title="架构和插件类型"></a>架构和插件类型</h3><hr>
<p>为了使远程开发尽力透明化，便于理解，我们可以将插件分为两类：</p>
<ul>
<li><strong>UI 插件：</strong> 这些插件可以配置VS Code的用户界面，而且只运行在用户的本地机器上。UI插件不能直接访问工作区的文件，或者在工作区的机器上运行脚本/工具。这类插件如：主题、代码片段、语言语法、快捷键映射。</li>
<li><strong>工作区插件：</strong> 这类插件运行在工作区所在机器上。当运行在本地时，<em>工作区插件</em>运行在本地机器上；在远程项目中，工作区插件运行在远程机器上。工作区插件可以访问工作区的文件并提供富文本支持和多语言服务器，调试和其他复杂的操作（也包含被脚本/工具调起的文件）。不过工作区插件在自定义UI上稍有限制，你可以配置的UI组件有资源管理器，视图容器等其他UI组件。</li>
</ul>
<p>当一个用户安装了一个插件，VS Code会基于插件类型自动将插件安装到正确的环境中去：UI 插件运行在VS Code的本地插件主机中，工作区插件则运行在一个非常小的<strong>VS Code 服务器</strong>的<strong>远程插件主机</strong>中。当你打开一个Windows Subsystem for Linux(WSL)、容器、或者远程SSH主机时这个服务会自动安装（更新）。VS Code还会自动管理这个服务的启停，所以用户根本意识不到它的存在。</p>
<p><img src="/images/loading.gif" data-original="../images/development/4a7ad12fe012bd8f72fa803b9980fa7a.png" alt=""></p>
<p>VS Code API 会自动运行在正确的机器上（不管是本地还是远程）。但是如果你的插件使用的api不是VS Code提供的——比如运行shell脚本的Node API——当运行在远程时可能不会正常工作，因此我们建议你在所有的环境中测试一下你的插件。</p>
<h3 id="测试和调试插件"><a href="#测试和调试插件" class="headerlink" title="测试和调试插件"></a>测试和调试插件</h3><hr>
<p>这个部分将说明如何在远程目录下测试和调试插件。在这之前，我们先看一下怎么使用本地<a href="https://code.visualstudio.com/docs/remote/containers" target="_blank" rel="noopener">开发容器</a>测试一个插件。本地测试容器是跨平台的，很容易部署，但是限制了访问文件系统的端口。由于只占用了非常小的OS空间，开发容器可以提供最为接近插件的真实运行环境。WSL，换句话说，就是一个典型的最小自治SSH主机。大部分场景下，你只要做小小的调整就可以解决问题了，相关主题查看常见问题。</p>
<h4 id="安装开发版插件"><a href="#安装开发版插件" class="headerlink" title="安装开发版插件"></a>安装开发版插件</h4><p>目前，VS Code自动在SSH主机、容器、WSL安装插件时会使用插件市场的版本(而不是你本机上当前安装的版本)。大部分时候这么做事合理的，但是我们现在可能需要一个未发布的版本来测试，所以你可以将插件打包成<code>VSIX</code>格式，然后打开已经连接到远程VS Code窗口中手动安装这个插件。</p>
<p>遵循以下步骤：</p>
<ol>
<li>如果这个插件已经发布，你需要将配置文件<code>setting.json</code>设置成<code>"extensions.autoUpdate": false</code>，阻止插件自动更新到插件市场的最新版本。</li>
<li>下一步，使用<code>vsce package</code>将你的插件打包成VSIX</li>
<li>连接到<a href="https://code.visualstudio.com/docs/remote/containers" target="_blank" rel="noopener">开发容器</a>、<a href="https://code.visualstudio.com/docs/remote/ssh" target="_blank" rel="noopener">SSH主机</a>或<a href="https://code.visualstudio.com/docs/remote/wsl" target="_blank" rel="noopener">WSL环境</a></li>
<li>在你已经连接远程目录的项目中，使用命令 <strong>Install from VSIX…</strong>安装你打包好的插件</li>
<li>完成后重启</li>
</ol>
<p>?&gt; <strong>小提示：</strong>安装完毕后，你可以使用 <strong>Developer: Show Running Extensions</strong>命令查看VS Code在本地运行插件还是在远程运行插件的。</p>
<h4 id="在远程调试你的插件"><a href="#在远程调试你的插件" class="headerlink" title="在远程调试你的插件"></a>在远程调试你的插件</h4><p>通常，你在本地机器上构建、编辑、加载和调试你的插件，远程调试插件也差不多遵循相同的模式，你只要把这些工作全部放在打开的远程开发目录去做就好了。</p>
<h5 id="使用开发容器"><a href="#使用开发容器" class="headerlink" title="使用开发容器"></a>使用开发容器</h5><p>遵循以下步骤开发和调试容器中的插件。</p>
<ol>
<li>添加Node.js开发容器定义。在你的插件文件夹下按<code>F1</code>，选择 <strong>Remote-Containers: Create Configuration File…</strong> 命令，然后选择 <strong>Node.js 8 &amp; Typescript</strong>（或者只是 Node.js 8）。这就定义了你将会编辑和调试的插件容器。</li>
<li>命令运行后，你可以自由修改<code>.devcontainer</code>文件夹，添加比如构建或运行时的其他选项。深入<a href="https://code.visualstudio.com/docs/remote/containers" target="_blank" rel="noopener">容器</a>了解更多内容。</li>
<li><strong>【可选】</strong> 编辑<code>launch.json</code>在<code>args</code>属性后面添加第二个参数，指向你的容器中的工作区目录下的测试项目/测试数据。比如，如果你的测试数据在工作区的一个<code>data</code>文件夹下，需要按照如下步骤添加<code>${workspaceFolder}/data</code>:</li>
</ol>
<blockquote>
<p>注意：你<strong>不可以</strong>单独使用<code>${workspaceFolder}</code>作为第二个参数</p>
</blockquote>
<pre><code>{
  "name": "Launch Extension",
  "type": "extensionHost",
  "request": "launch",
  "runtimeExecutable": "${execPath}",
  "args": ["--extensionDevelopmentPath=${workspaceFolder}", "${workspaceFolder}/data"],
  "stopOnEntry": false,
  "sourceMaps": true,
  "outFiles": ["${workspaceFolder}/dist/**/*.js"],
  "preLaunchTask": "npm"
}</code></pre><ol>
<li>运行 <strong>Remote-Containers: Reopen Folder in Container</strong>，VS Code会部署好容器，然后建立连接。现在你可以从容器内部修改源码了。</li>
<li>最后，按下<code>F5</code>或者使用 <strong>调试视图</strong>从容器内部加载然后启动调试器。</li>
</ol>
<h5 id="使用SSH-或-WSL"><a href="#使用SSH-或-WSL" class="headerlink" title="使用SSH 或 WSL"></a>使用SSH 或 WSL</h5><p>你在 <a href="https://code.visualstudio.com/docs/remote/ssh" target="_blank" rel="noopener">SSH 主机</a> 或 <a href="https://code.visualstudio.com/docs/remote/wsl" target="_blank" rel="noopener">WSL</a> 中遵循类似的步骤。</p>
<ol>
<li>使用SSH，你需要在远程主机上打开对应的项目（比如，使用 <strong>Remote-SSH: Connect to Host…</strong> 命令，然后在 <strong>File &gt; Open</strong>打开对应的插件副本）。使用WSL，使用 <strong>File &gt; New WSL Window</strong>然后 <strong>File &gt; Open</strong>打开对应文件夹。</li>
<li>通过SSH主机/WSL打开文件夹后，你可以像在本地一样编辑源码了。</li>
<li>最后，按下 <code>F5</code> 或者使用 <strong>调试视图</strong>加载插件，像本地一样调试代码。</li>
</ol>
<h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><hr>
<p>VS Code API 会根据项目自动运行在正确的环境上。记住这点，然后我们来看看几个API，它会帮助你避免一些意外问题。</p>
<h4 id="不正确的执行环境"><a href="#不正确的执行环境" class="headerlink" title="不正确的执行环境"></a>不正确的执行环境</h4><p>如果你的插件出错了，它有可能是运行在了错误环境中。比较常见的场景是，你原本期望它运行在本地却运行在了远程上。你可以使用命令面板的 <strong>Developer: Show Running Extensions</strong>命令查看插件的运行情况。</p>
<p>如果这个命令显示某个UI 插件被当做工作区插件或者类似的情况，你可以试着在插件的<code>package.json</code>中设置<code>extensionKind</code>属性：</p>
<pre><code>{
  "extensionKind": "ui"
}</code></pre><ul>
<li><code>"extensionKind": "ui"</code> —— 将插件视为 UI 插件，强制在本地运行。</li>
<li><code>"extensionKind": "ui"</code> —— 将插件视为 工作区插件，它有可能会在远程工作区的VS Code Server中运行。</li>
</ul>
<p>你也可以在<a href="https://code.visualstudio.com/docs/getstarted/settings" target="_blank" rel="noopener">设置</a>中修改 <code>remote.extensionKind</code>插件的类型，这项配置可以立竿见影地看到效果。比如，你想把 <a href="https://marketplace.visualstudio.com/items?itemName=ms-azuretools.vscode-cosmosdb" target="_blank" rel="noopener">Azure Cosmos DB</a>插件强制设置为 UI 插件（默认是工作区插件）然后把<a href="https://marketplace.visualstudio.com/items?itemName=msjsdiag.debugger-for-chrome" target="_blank" rel="noopener">Debugger for Chrome</a>设置为工作区插件（默认是UI 插件），你可以这么设置：</p>
<pre><code>{
  "remote.extensionKind": {
    "ms-azuretools.vscode-cosmosdb": "ui",
    "msjsdiag.debugger-for-chrome": "workspace"
  }
}</code></pre><p>使用 <code>remote.extensionKind</code>可以快速地测试发行版插件，而不用修改插件的<code>package.json</code>或重新构建插件。</p>
<h4 id="保存插件数据或状态"><a href="#保存插件数据或状态" class="headerlink" title="保存插件数据或状态"></a>保存插件数据或状态</h4><p>有的时候，你的插件需要保留住不属于<code>settings.json</code>的数据或者独立的工作区配置文件（如<code>.eslintrc</code>），你可以使用插件激活入口的<code>vscode.ExtensionContext</code>对象。如果你的插件已经使用好了这些属性那就应该不会出错。</p>
<p>但是，你的插件如果依赖VS Code的路径约定（如 <code>~/.vscode</code>）或者特定的OS目录（比如Linux上的 <code>~/.config/Code</code>）来保存数据，那你就可能会遇到问题。不过还好这些小问题只要稍加修改插件就能处理掉。</p>
<p>如果你只是想保存一些键值对全局状态信息，你可以使用<code>vscode.ExtensionContext.workspaceState</code>或<code>vscode.ExtensionContext.globalState</code>。如果数据不止键值对且更为复杂，访问<code>globalStoragePath</code>和<code>storagePath</code>可以安全地获取对应的储存路径，供你读写文件。</p>
<p>这些API在1.31版本之后可用，你需要在<code>package.json</code>中配置版本：</p>
<pre><code>{
  "engines": {
    "vscode": "^1.31.0"
  }
}</code></pre><p>如何使用我们上面介绍的API:</p>
<pre><code>import * as vscode from 'vscode';
import * as fs from 'fs';
import * as path from 'path';
export function activate(context: vscode.ExtensionContext) {
    context.subscriptions.push(
        vscode.commands.registerCommand('myAmazingExtension.persistWorkspaceData', () =&gt; {
        // 如果插件所属的工作区不存在储存路径，则创建一个
        if (!fs.existsSync(context.storagePath)) {
            fs.mkdirSync(context.storagePath);
        }
        // 将文件写入储存目录
        fs.writeFileSync(
            path.join(context.storagePath, 'workspace-data.json'),
            JSON.stringify({ now: Date.now() }));
    }));
    context.subscriptions.push(
        vscode.commands.registerCommand('myAmazingExtension.persistGlobalData', () =&gt; {
        // 如果插件所属的全局（跨工作区）文件夹不存在则创建一个
        if (!fs.existsSync(context.globalStoragePath)) {
            fs.mkdirSync(context.globalStoragePath);
        }
        // 为插件创建一个全局储存文件
        fs.writeFileSync(
            path.join(context.globalStoragePath, 'global-data.json'),
            JSON.stringify({ now: Date.now() }));
    }));
}</code></pre><h4 id="保留密钥"><a href="#保留密钥" class="headerlink" title="保留密钥"></a>保留密钥</h4><p>如果你的插件需要保留密码或者其他密钥，你可能会想到使用本地操作系统的密钥储存功能（Windows Cert Store、 macOS KeyChain、Linux 的 <code>libsecret</code>-based keyring），而不是使用远程主机的储存功能。更有可能的是，你可能需要在Linux上使用<code>libsecret</code>，在插件中使用<code>gnome-keyring</code>去储存你的密钥，通常来说，这项功能在服务端或者容器内不一定能运作起来。</p>
<p>VS Code本身不提供密钥储存机制，不过需要插件作者会转而使用<a href="https://www.npmjs.com/package/keytar" target="_blank" rel="noopener"><code>keytar</code> node module</a>包。因此，VS Code内建了<code>keytar</code>，你在 <em>工作区插件</em> 中如果使用了它，它就会自动无声地运行在后台。这样一来你就可以使用本地系统的 keychain/ keyring/ cert store 同时还避免了各种问题。</p>
<p>比如：</p>
<pre><code>import * as vscode from 'vscode';
function getCoreNodeModule(moduleName) {
  try {
    return require(`${vscode.env.appRoot}/node_modules.asar/${moduleName}`);
  } catch (err) {}
  try {
    return require(`${vscode.env.appRoot}/node_modules/${moduleName}`);
  } catch (err) {}
  return undefined;
}
// Use it
const keytar = getCoreNodeModule('keytar');
await keytar.setPassword('my-service-name', 'my-account', 'iamal337d00d');
const password = await keytar.getPassword('my-service-name', 'my-account');</code></pre><h4 id="使用剪贴板"><a href="#使用剪贴板" class="headerlink" title="使用剪贴板"></a>使用剪贴板</h4><p>由于历史原因，大部分插件作者会使用诸如<code>clipboardy</code>等Node.js的包和剪贴板交互。不幸的的是，如果你使用了这样的包，那么它就很有可能会运行在远程机器上。</p>
<p>VS Code 1.30引入的剪贴板则解决了这个问题。它总是运行在本地中，所以同样的，你只要修改你的<code>engines.vscode</code>版本就可以使用这个API了。</p>
<p>在插件中使用剪贴板API：</p>
<pre><code>import * as vscode from 'vscode';
export function activate(context: vscode.ExtensionContext) {
  context.subscriptions.push(
    vscode.commands.registerCommand('myAmazingExtension.clipboardIt', async () =&gt; {
      // 读取剪贴板
      const text = await vscode.env.clipboard.readText();
      // 写入剪贴板
      await vscode.env.clipboard.writeText(
        `It looks like you're copying "${text}". Would you like help?`
      );
    })
  );
}</code></pre><h4 id="在本地浏览器或者其他应用中打开些什么"><a href="#在本地浏览器或者其他应用中打开些什么" class="headerlink" title="在本地浏览器或者其他应用中打开些什么"></a>在本地浏览器或者其他应用中打开些什么</h4><p>在本地的场景下，通过使用子进程或者<code>opn</code>包启动浏览器或者其他应用是完全可行的，但是一旦插件运行到了远程上，这就会导致应用加载错误。VS Code远程开发<strong>部分</strong>兼容了<code>opn</code>包使得现有插件可以正常运行。你可以使用URI调用这个包，VS Code会带上这个URL在客户端唤起默认应用。由于不是完整实现，有些配置是不支持的，也不会返回<code>child_process</code>对象。</p>
<p>除了依赖第三方包，我们建议你使用<code>vscode.env.openExternal</code>方法在本地操作系统上启动默认应用打开对应的URI。而且<code>vscode.env.openExternal</code><strong>还支持自动端口转发</strong>！你可以指向到远程的web server上，即使那个端口外部不可访问。</p>
<p>这项功能自1.31开始支持，所以你又要修改你的<code>engines.vscode</code>了。</p>
<p>如何使用<code>vscode.env.openExternal</code>API：</p>
<pre><code>import * as vscode from 'vscode';
export async function activate(context: vscode.ExtensionContext) {
  context.subscriptions.push(
    vscode.commands.registerCommand('myAmazingExtension.openExternal', () =&gt; {
      // 示例 1 - 在默认浏览器中打开VS Code主页
      vscode.env.openExternal(vscode.Uri.parse('https://code.visualstudio.com'));
      // 示例 2 - 打开默认email应用
      vscode.env.openExternal(vscode.Uri.parse('mailto:vscode@microsoft.com'));
    })
  );
}</code></pre><h4 id="使用命令在插件间通信"><a href="#使用命令在插件间通信" class="headerlink" title="使用命令在插件间通信"></a>使用命令在插件间通信</h4><p>一些插件意在被其他插件调用（通过<code>vscode.extension.getExtension(extensionName).exports</code>），因此会在激活时返回一些API。如果这些插件都在同一环境（都是UI插件，或者都是工作区插件时）下工作不会出什么问题，但是如果一个是UI插件，一个是工作区插件就会出问题了。</p>
<p>如果你的插件需要彼此产生交互，使用私有命令暴露功能可以避免一些问题。不过记住一点，所有你传入的对象参数都会被字符串化（<code>JSON.stringify</code>），因此这些对象不可以有循环引用，这会导致接受方只收到一个”字符串化的object类型”。</p>
<p>示例：</p>
<pre><code>import * as vscode from 'vscode';
export async function activate(context: vscode.ExtensionContext) {
  // 注册私有命令
  const echoCommand = vscode.commands.registerCommand(
    '_private.command.called.echo',
    (value: string) =&gt; {
      return value;
    }
  );
  context.subscriptions.push(echoCommand);
}</code></pre><h3 id="使用Webview-API"><a href="#使用Webview-API" class="headerlink" title="使用Webview API"></a>使用Webview API</h3><hr>
<p>就像剪贴板API，Webview API也总是运行在本地环境，即使是 <em>工作区插件</em> 调用的。也就是说大部分基于webview的插件都可以正常工作，但是还有些注意事项需要交代一下。</p>
<h4 id="访问localhost"><a href="#访问localhost" class="headerlink" title="访问localhost"></a>访问localhost</h4><p>默认情况下，webview中的<code>localhost</code>会解析到用户本地机器上，也就是说，远程运行的插件所启动的服务在webview里是无法访问的。即使你访问远程机器的ip，云主机或容器中的端口还是默认被拦截的。我们来看一下示意图</p>
<p><img src="/images/loading.gif" data-original="../images/development/7bfe4aca0b236e20c24b1f144a4b0ef0.png" alt=""></p>
<p>你可以用webview的message passingAPI绕过各种限制，你还可以 <strong>添加端口映射</strong> 告诉webview哪些端口可以直接转发到远程机器上。</p>
<p>端口映射可以将webview所使用的localhost端口映射到远程插件启动的任意端口上。如果你的 <em>工作区插件</em> 运行在远程，而且你也定义了端口映射，那么这些流量会自动、安全地转发到远程机器上。如果你的插件只是运行在本地，端口映射则会将一个localhost端口重新映射到另一个端口上。Webview端口映射同时支持<em>UI插件</em>和<em>工作区插件</em>，也同时支持本地和远程环境。</p>
<p>这项功能自1.34开始支持，请修改你的<code>package.json</code>添加该支持。</p>
<p>使用端口映射，只要在你创建的webview中添加传入一个<code>portMapping</code>对象即可：</p>
<pre><code>const STATIC_PORT = 3000;
const dynamicServerPort = getExpressServerPort();
const webviewPort = STATIC_PORT;
// 创建webview然后传入portMapping
const panel = vscode.window.createWebviewPanel(
  'remoteMappingExample',
  'Remote Mapping Example',
  vscode.ViewColumn.One,
  {
    portMapping: [
      // 这里映射了 webview 的 localhost:3000 到远程主机的 express 服务器端口
      { webviewPort: webviewPort, extensionHostPort: dynamicServerPort }
    ]
  }
);
// 你可以在HTML中使用"webviewPort"查看端口
panel.webview.html = `&lt;!DOCTYPE html&gt;
    &lt;body&gt;
        &lt;!-- This will resolve to the dynamic server port on the remote machine --&gt;
        &lt;img src="http://localhost:${webviewPort}/canvas.png"&gt;
    &lt;/body&gt;
    &lt;/html&gt;`;</code></pre><p>现在webview前往<code>localhost:3000</code>的流量都会通过VS Code的安全信道直接走到远程机器上。</p>
<p><img src="/images/loading.gif" data-original="../images/development/2c47e792d1780d8c03acbb12b214aca5.png" alt=""></p>
<h3 id="使用原生Node-js模块"><a href="#使用原生Node-js模块" class="headerlink" title="使用原生Node.js模块"></a>使用原生Node.js模块</h3><hr>
<p>和插件打包（或动态引入的包）的原生node包会被<a href="https://electronjs.org/docs/tutorial/using-native-node-modules" target="_blank" rel="noopener">Electorn的<code>electron-rebuild</code></a>重新编译。但是VS Code Server运行在一个标准的（非Electron）的Node.js中，因此可能造成远程二进制库失效问题。</p>
<p>解决这个问题需要：</p>
<ol>
<li>同时引入Node.js和Elctron标准的两种二进制包（别忘了动态引入的包）。</li>
<li>检查<code>vscode.extensions.getExtension('your.extensionId').extensionKind === vscode.ExtensionKind.Workspace</code>是否根据环境使用了正确的包。</li>
<li>如果你想支持非x86_64构建目标和Alpine Linux则遵循下述类似逻辑。</li>
</ol>
<p>使用VS Code的 <strong>Help &gt; Developer Tools</strong>然后在控制台（console）中打印<code>process.versions.modules</code>可以找到VS Code使用的模块（modules）类型。如果你想要确保原生模块在各个Node.js环境中都能无缝运行，你可能把所有可能支持的平台（Electron Node.js, 官方Node.js Windows/Darwin/Linux的全部版本）相关的包全部引入。<a href="https://github.com/tree-sitter/node-tree-sitter/releases/tag/v0.14.0" target="_blank" rel="noopener">node-tree-sitter</a>包在这方面是个非常好的例子。</p>
<h3 id="为非x86-64主机或Apline-Linux容器提供支持"><a href="#为非x86-64主机或Apline-Linux容器提供支持" class="headerlink" title="为非x86_64主机或Apline Linux容器提供支持"></a>为非x86_64主机或Apline Linux容器提供支持</h3><hr>
<p>如果你的插件只是用JavasSript/TypeScript写的，你的插件可能什么都不用做就能支持其他进程架构或基于<code>musl</code>的Apline Linux。</p>
<p>但是如果你的插件可以运行在Debian 9+, Ubuntu 16.04+, 或者基于 RHEL / CentOS 7+ 的远程SSH主机、容器或 WSL上，却无法支持非x86_64(比如 ARMv7l)或Alpine Linux容器，插件可能需要包含了x86_64的<code>glibc</code>特定机器码或运行时，所以导致了这些架构/操作系统上出现问题。</p>
<p>比如，你的插件坑包含了x86_64编译的原生模块或运行时版本。对于Alpine Linux来说就是因<a href="https://wiki.musl-libc.org/functional-differences-from-glibc.html" target="_blank" rel="noopener">基础架构差异</a>而无法运行这样的插件。</p>
<p>为了解决这个问题：</p>
<ol>
<li>如果你是动态引入编译码，你可以用<code>process.arch</code>检测环境，然后根据对应架构下载对应架构下的依赖。如果你已经在插件中直接使用了二进制包，你也可以用同样的逻辑使用正确的包。</li>
<li>对于Alpine Linux来说，你可以用<code>await fs.exists('/etc/alpine-release')</code>检测操作系统，然后下载或者使用基于<code>musl</code>的正确的二进制包。</li>
<li>如果你不想支持这些平台，你也可以用同样的逻辑提供良好的错误提示。</li>
</ol>
<p>你要非常注意一些第三方包可能依赖了导致这个问题的源码包。所以有时候你需要联系npm包作者提供额外的编译版本。</p>
<h3 id="避免使用Electron模块"><a href="#避免使用Electron模块" class="headerlink" title="避免使用Electron模块"></a>避免使用Electron模块</h3><hr>
<p>虽然依赖未暴露的内置Electron或者VS Code模块非常方便，但是你必须知道VS Code Server运作在标准的（非Electron）Node.js环境中，当插件运行在远程时就会丢失这些包。除了少数个例，比如keytar，用了特殊的实现所以在所有环境中都能正常工作。</p>
<p>使用基于Node.js的模块从而避免这些问题。如果你一定要用Electron模块，那就要确保如果包丢失的时候提供合适的后备方案。</p>
<p>下面的例子使用了Electron的<code>original-fs</code>包，缺失时则使用Node.js的<code>fs</code>模块。</p>
<pre><code>function requireWithFallback(electronModule: string, nodeModule: string) {
  try {
    return require(electronModule);
  } catch (err) {}
  return require(nodeModule);
}
const fs = requireWithFallback('original-fs', 'fs');</code></pre><p>但是不论何时，你都应该避免这些问题。</p>
<h3 id="已知问题"><a href="#已知问题" class="headerlink" title="已知问题"></a>已知问题</h3><hr>
<p>目前我们还有些影响 工作区插件 功能的问题亟待解决。下表是已知的问题列表：</p>
<table>
<thead>
<tr>
<th align="left">问题</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">端口拦截</td>
<td align="left">当使用Docker容器或者SSH服务器开发时端口不会自动转发，而插件中也没有可以程序性转发端口的API。虽然在使用Webview API中已经适配了webview，但是其他场景下还需要插件作者手动暴露端口</td>
</tr>
<tr>
<td align="left">无法访问/传输远程工作区文件到本地</td>
<td align="left">插件通过外部应用打开工作区文件会遇到错误，因为外部应用无法直接访问远程文件。我们正在调查插件怎样才能从远程工作区传输文件的相关方案。</td>
</tr>
<tr>
<td align="left">无法从工作区插件访问关联设备</td>
<td align="left">关联本地设备的插件无法在远程运行时关联对应设备，我们正在调查相关问题的最佳方案。</td>
</tr>
</tbody></table>
<h3 id="FAQ-2"><a href="#FAQ-2" class="headerlink" title="FAQ"></a>FAQ</h3><hr>
<ul>
<li>查看<a href="https://code.visualstudio.com/docs/remote/troubleshooting" target="_blank" rel="noopener">提示和解决方法</a>或者<a href="https://code.visualstudio.com/docs/remote/faq" target="_blank" rel="noopener">FAQ</a></li>
<li>在 <a href="https://stackoverflow.com/questions/tagged/vscode-remote" target="_blank" rel="noopener">Stack Overflow</a>上查找答案</li>
<li><a href="https://aka.ms/vscode-remote/feature-requests" target="_blank" rel="noopener">支持或者新建一项功能</a>，查看<a href="https://aka.ms/vscode-remote/issues" target="_blank" rel="noopener">已知问题</a>，或者<a href="https://aka.ms/vscode-remote/issues/new" target="_blank" rel="noopener">报告问题</a></li>
<li>贡献一个<a href="https://aka.ms/vscode-dev-containers" target="_blank" rel="noopener">开发容器配置</a>方便大家使用</li>
<li>贡献<a href="https://github.com/Microsoft/vscode-docs" target="_blank" rel="noopener">文档</a>或者<a href="https://github.com/Microsoft/vscode" target="_blank" rel="noopener">VS Code</a></li>
</ul>
<h2 id="使用不稳定的API"><a href="#使用不稳定的API" class="headerlink" title="使用不稳定的API"></a>使用不稳定的API</h2><p>在VS Code中，插件API的兼容性非常重要，我们尽最大努力避免API变动以便插件开发人员已经发布的插件可以按预期工作。但是，这对使得我们束手束脚，一旦新的API发布后，就不可能再轻易改动。</p>
<p>不稳定的API（Proposed API）则解决了这个问题，不稳定的API是VS Code已经实现但是还未公开的API。它们只在Insider版的VS Code中可用，而且很有可能再次产生变动，你也不能在想要发布的插件中使用。不管怎样，插件开发者开始可以在本地开发时测试这些API，然后给VS Code团队提供建议的，经过不断修改之后最终可能出现在稳定版中。</p>
<h3 id="使用不稳定的API-1"><a href="#使用不稳定的API-1" class="headerlink" title="使用不稳定的API"></a>使用不稳定的API</h3><p>下面是在本地开发中测试未稳定API的步骤：</p>
<ul>
<li>使用 VS Code的<a href="https://code.visualstudio.com/insiders" target="_blank" rel="noopener">Insider</a>版本</li>
<li>在<code>package.json</code>中添加<code>"enableProposedApi": true</code></li>
<li>把最新的<a href="https://github.com/Microsoft/vscode/blob/master/src/vs/vscode.proposed.d.ts" target="_blank" rel="noopener"><code>vscode.proposed.d.ts</code></a>复制到你的项目中</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><h2 id="VS-Code-API"><a href="#VS-Code-API" class="headerlink" title="VS Code API"></a>VS Code API</h2><p><strong>VS Code API</strong>是VS Code提供给插件使用的一系列Javascript API。</p>
<p>!&gt; 注意：VS Code API 变动较快，请自行参考<a href="https://code.visualstudio.com/api/references/vscode-api" target="_blank" rel="noopener">官方文档</a>，其中包含了完整而且是最新的VS Code API列表。</p>
<h3 id="API模式"><a href="#API模式" class="headerlink" title="API模式"></a>API模式</h3><hr>
<p>以下将介绍我们在VS Code中经常使用的API模式。</p>
<h4 id="Promises（异步）"><a href="#Promises（异步）" class="headerlink" title="Promises（异步）"></a>Promises（异步）</h4><p>VS Code API完全采用了promise的实现。对于插件来说允许任何promise形式的返回格式，如ES6，WinJS，A+等。</p>
<p>一个promise库需要它的API使用<code>Thenable</code>类型来表达，<code>Thenable</code>类型代表了一种通用特性的实现——then方法。</p>
<p>大多数时候promise是一个可选项，VS Code调用插件之后，它能直接处理正常的返回结果也能处理<code>Thenable</code>的结果类型。当promise是可选的API返回结果时，API会在返回类型中用<code>Thenable</code>表示。</p>
<pre><code>provideNumber(): number | Thenable&lt;number&gt;</code></pre><h4 id="Cancellation-Tokens（取消式令牌）"><a href="#Cancellation-Tokens（取消式令牌）" class="headerlink" title="Cancellation Tokens（取消式令牌）"></a>Cancellation Tokens（取消式令牌）</h4><p>有些事件可能从不稳定的变化状态开始，而随着状态变化这一事件最后肯能被取消了。比如：IntelliSense（智能补全）被触发后，用户持续输入的行为使得这一操作最终被取消了。</p>
<p>API也为这种行为提供了解决方案，你可以通过<code>CancellationToken</code>检查取消的状态（<code>isCancellationRequested</code>）或者当<em>取消</em>发生时得到通知（<code>onCancellationRequested</code>）。取消式令牌通常是API函数的最后一个（可选）参数。</p>
<h4 id="Disposables（释放器）"><a href="#Disposables（释放器）" class="headerlink" title="Disposables（释放器）"></a>Disposables（释放器）</h4><p>VS Code API使用了<a href="https://en.wikipedia.org/wiki/Dispose_pattern" target="_blank" rel="noopener">释放器模式</a>，这个模式被用于事件侦听，命令，UI交互和各类语言配置上。</p>
<p>例如：<code>setStatusBarMessage(value: string)</code>事件返回一个<code>Disposable</code>对象，这个对象最终调用<code>dispose</code>方法移除message。</p>
<h4 id="Events（事件）"><a href="#Events（事件）" class="headerlink" title="Events（事件）"></a>Events（事件）</h4><p>事件在API中被暴露为函数，当你订阅一个事件侦听器时绑定。事件侦听器调用后会返回一个<code>Disposable</code>，它会在dispose触发后，移除事件侦听器。</p>
<pre><code>var listener = function(event) {
    console.log("It happened", event);
};
// 开始侦听
var subscription = fsWatcher.onDidDelete(listener);
// 你的代码
subscription.dispose(); // 停止侦听</code></pre><p>事件的命名规则遵循<code>on[Will | Did] 动词 + 名词</code>的形式。通过<code>onWill</code>表示将要发生，<code>onDid</code>表示已经发生，<code>动词</code>表示行为，<code>名词</code>指代上下文或目标。</p>
<p>举个栗子：<code>window.onDidChangeActiveTextEditor</code>中，激活的编辑器（ActiveTextEditor：<code>名词</code>）变动（change：<code>动词</code>）后（<code>onDid</code>）会触发事件。</p>
<h4 id="严格null检查"><a href="#严格null检查" class="headerlink" title="严格null检查"></a>严格null检查</h4><p>VS CodeAPI使用<code>undefined</code>和<code>null</code>的Typescript类型，同样也支持<a href="https://github.com/Microsoft/TypeScript/pull/7140" target="_blank" rel="noopener">严格null检查</a>。</p>
<h2 id="发布内容配置"><a href="#发布内容配置" class="headerlink" title="发布内容配置"></a>发布内容配置</h2><p>发布内容配置（即VS Code为插件扩展提供的配置项）是<code>pacakge.json</code><a href="https://code.visualstudio.com/api/references/extension-manifest" target="_blank" rel="noopener">插件清单</a>的<code>contributes</code>字段，你可以在其中注册各种配置项扩展VS Code的能力。下面是目前可用的配置项列表：</p>
<ul>
<li><code>configuration</code></li>
<li><code>commands</code></li>
<li><code>menus</code></li>
<li><code>keybindings</code></li>
<li><code>languages</code></li>
<li><code>debuggers</code></li>
<li><code>breakpoints</code></li>
<li><code>grammars</code></li>
<li><code>themes</code></li>
<li><code>snippets</code></li>
<li><code>jsonValidation</code></li>
<li><code>views</code></li>
<li><code>viewsContainers</code></li>
<li><code>problemMatchers</code></li>
<li><code>problemPatterns</code></li>
<li><code>taskDefinitions</code></li>
<li><code>colors</code></li>
<li><code>typescriptServerPlugins</code></li>
</ul>
<h3 id="contributes-configuration"><a href="#contributes-configuration" class="headerlink" title="contributes.configuration"></a>contributes.configuration</h3><hr>
<p>在configuration中配置的内容会暴露给用户，用户可以从“用户设置”和“工作区设置”中修改你暴露的选项。</p>
<p>configuration是JSON格式的键值对，用户会在修改设置时获得对应的提示和更好的体验。</p>
<p>你可以用<code>vscode.workspace.getConfiguration('myExtension')</code>读取配置值。</p>
<p>?&gt; 小提示：配置<code>markdownDescription</code>比配置<code>description</code>更好，它能呈现Markdown格式的文档。</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><pre><code>"contributes": {
    "configuration": {
        "type": "object",
        "title": "TypeScript configuration",
        "properties": {
            "typescript.useCodeSnippetsOnMethodSuggest": {
                "type": "boolean",
                "default": false,
                "description": "Complete functions with their parameter signature."
            },
            "typescript.tsdk": {
                "type": ["string", "null"],
                "default": null,
                "description": "Specifies the folder path containing the tsserver and lib*.d.ts files to use."
            }
        }
    }
}</code></pre><p><img src="/images/loading.gif" data-original="../images/development/4492c380ae3cd9b5ca7178d4708dddde.png" alt=""></p>
<h3 id="contributes-configurationDefaults"><a href="#contributes-configurationDefaults" class="headerlink" title="contributes.configurationDefaults"></a>contributes.configurationDefaults</h3><hr>
<p>为特定的语言配置编辑器的默认值，修改这个配置会覆盖编辑器已经为语言提供的默认配置。</p>
<p>下面的示例是修改<code>markdown</code>语言的默认配置。</p>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><pre><code>"contributes": {
    "configurationDefaults": {
        "[markdown]": {
            "editor.wordWrap": "on",
            "editor.quickSuggestions": false
        }
    }
}</code></pre><h3 id="contributes-commands"><a href="#contributes-commands" class="headerlink" title="contributes.commands"></a>contributes.commands</h3><hr>
<p>设置命令标题和命令体，随后这个命令会显示在<strong>命令面板</strong>中。你也可以加上<code>category</code>前缀，在<strong>命令面板</strong>中会以分类显示。</p>
<p>?&gt;<strong>注意：</strong>当调用命令时（通过组合键或者在<strong>命令面板</strong>中调用），VS Code会触发激活事件<code>onCommand:${command}</code>。</p>
<p>下面的示例是修改<code>markdown</code>语言的默认配置。</p>
<h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h4><pre><code>"contributes": {
    "commands": [{
        "command": "extension.sayHello",
        "title": "Hello World",
        "category": "Hello"
    }]
}</code></pre><p>?&gt; <strong>提示</strong>: 想了解更多的有关于在VS Code插件开发中使用命令, 请参阅<a href="https://www.bookstack.cn/read/VS-Code-Extension-Doc-ZH/$docs-references-extension-guides-command" target="_blank" rel="noopener">命令</a>章节</p>
<p><img src="/images/loading.gif" data-original="../images/development/7b6dc1e8e276d094bea34e0e4c63e8a7.png" alt=""></p>
<h3 id="contributes-menus"><a href="#contributes-menus" class="headerlink" title="contributes.menus"></a>contributes.menus</h3><hr>
<p>为编辑器或者文件管理器设置命令的<em>菜单项</em>。菜单项至少包含1️⃣选中时调用的命令和2️⃣何时显示这个菜单项的时机。显示菜单的时机由<code>when</code>键定义，而对应的值语法需要参考键值绑定的<a href="https://github.com/Microsoft/vscode-docs/blob/master/docs/getstarted/keybindings.md#when-clause-contexts" target="_blank" rel="noopener">when语法</a>。</p>
<p><code>command</code>键则是必须的。可选的命令使用<code>alt</code>定义，当你按下ALT键时，菜单中会显示对应的菜单项。</p>
<p>最后，<code>group</code>属性定义了菜单的分组。<code>navigation</code>值不同于普通的<code>group</code>值，一旦设置这个值就会总是显示在菜单的最顶端。</p>
<p>当前插件创作者可以配置的菜单的地方有：</p>
<ul>
<li>全局命令面板 - <code>commandPalette</code></li>
<li>资源管理器上下文菜单 - <code>explorer/context</code></li>
<li>编辑器上下文菜单 - <code>editor/context</code></li>
<li>编辑器标题栏 - <code>editor/title</code></li>
<li>编辑器标题上下文菜单 - <code>editor/title/context</code></li>
<li>调试栈视图的上下文菜单 - <code>debug/callstack/context</code></li>
<li>SCM 标题菜单 - <code>scm/title</code></li>
<li>SCM 资源组 - <code>scm/resourceGroup/context</code></li>
<li>SCM 资源 - <code>scm/resource/context</code></li>
<li>SCM 改变标题 - <code>scm/change/title</code></li>
<li>视图的标题菜单 - <code>view/title</code></li>
<li>视图项的菜单 - <code>view/item/context</code></li>
</ul>
<p>?&gt;<strong>注意：</strong>当菜单中的命令被调用，VS Code会将当前选中资源作为参数传给调用的命令。比方说，资源管理器的菜单被触发，选中资源的URI会作为参数，编辑器中的菜单项被触发，则将当前文件的URI作为参数传入。</p>
<p>关于<em>标题</em>还有一点要说，命令还可以定义图标，VS Code会显示在编辑器的标题菜单栏中。</p>
<h4 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h4><pre><code>"contributes": {
    "menus": {
        "editor/title": [{
            "when": "resourceLangId == markdown",
            "command": "markdown.showPreview",
            "alt": "markdown.showPreviewToSide",
            "group": "navigation"
        }]
    }
}</code></pre><p><img src="/images/loading.gif" data-original="../images/development/156ad806de6d5a6059c2402b6781aa82.png" alt=""></p>
<h4 id="让菜单项只显示在命令面板中"><a href="#让菜单项只显示在命令面板中" class="headerlink" title="让菜单项只显示在命令面板中"></a>让菜单项只显示在命令面板中</h4><p>注册的命令默认显示在<strong>命令面板</strong>中。要想控制命令的可见性，我们提供了一个<code>commandPalette</code>菜单配置，在这个配置中，你可以定义一个<code>when</code>控制是否在<strong>命令菜单</strong>中显示。</p>
<p>下面的片段只在编辑器中选中了什么东西的时候才会在<strong>命令面板</strong>中显示出‘Hello World’：</p>
<pre><code>"commands": [{
    "command": "extension.sayHello",
    "title": "Hello World"
}],
"menus": {
    "commandPalette": [{
        "command": "extension.sayHello",
        "when": "editorHasSelection"
    }]
}</code></pre><h4 id="分组排序"><a href="#分组排序" class="headerlink" title="分组排序"></a>分组排序</h4><p>菜单项可以通过组来分类。根据下列默认规则，然后按照字母排序，</p>
<p><strong>编辑器上下文菜单</strong>默认有这些分组：</p>
<ul>
<li><code>navigation</code> - <code>navigation</code>组始终在最上方。</li>
<li><code>1_modification</code> - 紧接上一个组，这个组包含可以修改你代码的命令。</li>
<li><code>9_cutcopypaste</code> - 然后是基础编辑命令。</li>
<li><code>z_commands</code> - 最后一个分组则是命令面板入口。</li>
</ul>
<p><img src="/images/loading.gif" data-original="../images/development/08a11eb70019e7e8091e2083a6dd17a5.png" alt=""></p>
<p><strong>资源管理器上下文菜单</strong>默认有下列分组：</p>
<ul>
<li><code>navigation</code> - 在VS Code中导航的相关命令。<code>navigation</code>组始终在最上方。</li>
<li><code>2_workspace</code> - 和工作区操作相关的命令。</li>
<li><code>3_compare</code> - 比较文件和diff相关的命令。</li>
<li><code>4_search</code> - 在搜索视图中和搜索相关的命令。</li>
<li><code>5_cutcopypaste</code> - 和剪切、复制、粘贴文件相关的命令。</li>
<li><code>7_modification</code> - 修改文件的相关命令。</li>
</ul>
<p><strong>编辑器标签菜单</strong>默认有下列分组</p>
<ul>
<li>1_close - 和关闭编辑器相关的命令。</li>
<li>3_preview - 和固定编辑器相关的命令。</li>
</ul>
<p><strong>编辑器标题菜单</strong>默认有下列分组</p>
<ul>
<li>1_diff - diff编辑器相关的命令。</li>
<li>3_open - 打开编辑器的相关命令。</li>
<li>5_close - 和关闭编辑器相关的命令。</li>
</ul>
<h4 id="组内排序"><a href="#组内排序" class="headerlink" title="组内排序"></a>组内排序</h4><p>组内的菜单顺序取决于标题或者<em>序号属性</em>。菜单的组内顺序由<code>@&lt;number&gt;</code>加到<code>group</code>值的后面得以确定：</p>
<pre><code>"editor/title": [{
    "when": "editorHasSelection",
    "command": "extension.Command",
    "group": "myGroup@1"
}]</code></pre><h3 id="contributes-keybindings"><a href="#contributes-keybindings" class="headerlink" title="contributes.keybindings"></a>contributes.keybindings</h3><hr>
<p>这个配置确定了用户输入按键组合时的触发规则。在<a href="https://code.visualstudio.com/docs/getstarted/keybindings" target="_blank" rel="noopener">快捷键绑定</a>中，你可以了解更加细节的东西。</p>
<p>配置快捷键绑定会使<em>默认键盘快捷方式</em>中显示你的规则，每一处和命令相关的UI部分也会显示你添加的快捷键组合。</p>
<p>?&gt;<strong>注意</strong>因为VS Code支持Windows，macOS和Linux平台，而</p>
<h4 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h4><p>Windows和Linux下使用<code>Ctrl+F1</code>，macOS下使用<code>Cmd+F1</code>调用<code>"extension.sayHello"</code>命令：</p>
<pre><code>"contributes": {
    "keybindings": [{
        "command": "extension.sayHello",
        "key": "ctrl+f1",
        "mac": "cmd+f1",
        "when": "editorTextFocus"
    }]
}</code></pre><p><img src="/images/loading.gif" data-original="../images/development/f22f87a81f6462aaf1b5c53ecd5a5bf9.png" alt=""></p>
<h3 id="contributes-languages"><a href="#contributes-languages" class="headerlink" title="contributes.languages"></a>contributes.languages</h3><hr>
<p>配置一门语言，引入一门新的语言或者加强VS Code已有的语言支持。</p>
<p>在这部分内容中，一个语言必须要有一个标识符（identifier）关联到文件上（查看 <code>TextDocument.getLanguageId()</code>）。</p>
<p>VS Code提供三种文件应该关联哪种语言的方式。每种方式都可以可以“单独”加强：</p>
<ol>
<li>插件的文件名</li>
<li>文件名</li>
<li>文件内的首行</li>
</ol>
<p>用户打开文件后，三种规则都会使用，然后确定语言。接着VS Code就会触发激活事件<code>onLanguage:${language}</code>（比如：下面的<code>onLanguage:python</code>例子）</p>
<p><code>aliases</code>属性包含着这门语言的可读性名称。这个列表的第一项会作为语言标签（在VS Code右下角状态栏显示）。</p>
<p><code>configuration</code>属性确定了语言配置文件的路径。路径是指相对插件文件夹的路径，通常是<code>./language-configuration.json</code>，这个文件是JSON格式的，包含着下列可配置属性：</p>
<ul>
<li><pre><code>comments</code></pre><p>- 定义了注释的符号</p>
<ul>
<li><code>blockComment</code> - 用于标识块注释的起始和结束token。被’Toggle Block Comment’使用</li>
<li><code>lineComment</code> - 用于标识行注释的起始token。被’Add Line Comment’使用</li>
</ul>
</li>
<li><p><code>brackets</code> - 定义括号，同时也会影响括号内的代码缩进。进入新的一行时，被编辑器用来确定或是更正新的缩进距离</p>
</li>
<li><p><code>autoClosingPairs</code> - 为<em>自动闭合功能<em>定义某个符号的开闭符（open and close symbols）。</em>开符号<em>输入后，编辑器会自动插入</em>闭符号<em>。使用<code>notIn</code>参数，关闭字符串或者注释中的</em>符号对</em></p>
</li>
<li><p><code>surroundingPairs</code> - 定义选中文本的开闭符号</p>
</li>
<li><pre><code>folding</code></pre><p>- 定义编辑器中的代码应何时、应怎么样折叠</p>
<ul>
<li><code>offSide</code> - 和一下个缩进块之间的代码块尾部的空行（用于基于缩进的语言，如Python or F#）</li>
<li><code>markers</code> - 使用正则自定义代码中的折叠区域标识符</li>
</ul>
</li>
<li><p><code>wordPattern</code> - 使用正则匹配编程语言中哪些词应该是单个词</p>
</li>
</ul>
<p>如果你的语言配置文件是<code>language-configuration.json</code>，或者以这样的字符串结尾的，VS Code就会提供校验和编辑支持。</p>
<h4 id="示例-5"><a href="#示例-5" class="headerlink" title="示例"></a>示例</h4><pre><code>...
"contributes": {
    "languages": [{
        "id": "python",
        "extensions": [ ".py" ],
        "aliases": [ "Python", "py" ],
        "filenames": [ ... ],
        "firstLine": "^#!/.*\\bpython[0-9.-]*\\b",
        "configuration": "./language-configuration.json"
    }]
}</code></pre><p>language-configuration.json</p>
<pre><code>{
    "comments": {
        "lineComment": "//",
        "blockComment": [ "/*", "*/" ]
    },
    "brackets": [
        ["{", "}"],
        ["[", "]"],
        ["(", ")"]
    ],
    "autoClosingPairs": [
        ["{", "}"],
        ["[", "]"],
        ["(", ")"],
        { "open": "'", "close": "'", "notIn": ["string", "comment"] },
        { "open": "/**", "close": " */", "notIn": ["string"] }
    ],
    "surroundingPairs": [
        ["{", "}"],
        ["[", "]"],
        ["(", ")"],
        ["&lt;", "&gt;"],
        ["'", "'"]
    ],
    "folding": {
        "offSide": true,
        "markers": {
            "start": "^\\s*//#region",
            "end": "^\\s*//#endregion"
        }
    },
    "wordPattern": "(-?\\d*\\.\\d\\w*)|([^\\`\\~\\!\\@\\#\\%\\^\\&amp;\\*\\(\\)\\-\\=\\+\\[\\{\\]\\}\\\\\\|\\;\\:\\'\\\"\\,\\.\\&lt;\\&gt;\\/\\?\\s]+)"
}</code></pre><h3 id="contributes-debuggers"><a href="#contributes-debuggers" class="headerlink" title="contributes.debuggers"></a>contributes.debuggers</h3><hr>
<p>配置VS Code的调试器，调试器配置有下列属性：</p>
<ul>
<li><p><code>type</code> 用于加载配置的调试器唯一标识——ID。</p>
</li>
<li><p><code>label</code> 会在UI中显示的调试器名称。</p>
</li>
<li><p><code>program</code> 调试适配的路径，调试适配通过VS Code debug protocol连接到真正的调试器或者运行时。</p>
</li>
<li><p><code>runtime</code> 如果调试适配器的路径不是可执行程序，那么就会用到这个运行时。</p>
</li>
<li><p><code>configurationAttributes</code> 调试器的启动配置参数。</p>
</li>
<li><p><code>initialConfigurations</code> 列出了初始化launch.json需要的加载配置。</p>
</li>
<li><p><code>configurationSnippets</code> 列出了编辑launch.json文件时可以提供的加载配置智能提示。</p>
</li>
<li><p><code>variables</code> 引入替代变量，并绑定到调试器插件实现的命令上。</p>
</li>
<li><p><code>languages</code> 调试插件会使用“默认调试器”的语言</p>
</li>
<li><p><code>adapterExecutableCommand</code>调试适配器执行路径和参数动态计算的命令。命令返回的格式如下：</p>
<pre><code>command: "&lt;executable&gt;",
args: [ "&lt;argument1&gt;", "&lt;argument2&gt;", ... ]</code></pre><p><code>command</code>属性必须是一个可执行程序的绝对路径，或者是通过PATH环境变量可以查找到可执行程序的名称。使用特殊值<code>node</code>，则会映射到VS Code内建的node运行时，而不会在PATH中查找。</p>
</li>
</ul>
<h4 id="示例-6"><a href="#示例-6" class="headerlink" title="示例"></a>示例</h4><pre><code>"contributes": {
    "debuggers": [{
        "type": "node",
        "label": "Node Debug",
        "program": "./out/node/nodeDebug.js",
        "runtime": "node",
        "languages": ["javascript", "typescript", "javascriptreact", "typescriptreact"],
        "configurationAttributes": {
            "launch": {
                "required": [ "program" ],
                "properties": {
                    "program": {
                        "type": "string",
                        "description": "The program to debug."
                    }
                }
            }
        },
        "initialConfigurations": [{
            "type": "node",
            "request": "launch",
            "name": "Launch Program",
            "program": "${workspaceFolder}/app.js"
        }],
        "configurationSnippets": [
            {
                "label": "Node.js: Attach Configuration",
                "description": "A new configuration for attaching to a running node program.",
                "body": {
                    "type": "node",
                    "request": "attach",
                    "name": "${2:Attach to Port}",
                    "port": 9229
                }
            }
        ],
        "variables": {
            "PickProcess": "extension.node-debug.pickNodeProcess"
        }
    }]
}</code></pre><h3 id="contributes-breakpoints"><a href="#contributes-breakpoints" class="headerlink" title="contributes.breakpoints"></a>contributes.breakpoints</h3><hr>
<p>通常调试器插件会有<code>contributes.breakpoints</code>入口，插件可以在这里面设置哪些语言可以设置断点。</p>
<pre><code>"contributes": {
    "breakpoints": [
        {
            "language": "javascript"
        },
        {
            "language": "javascriptreact"
        }
    ]
}</code></pre><h3 id="contributes-grammars"><a href="#contributes-grammars" class="headerlink" title="contributes.grammars"></a>contributes.grammars</h3><hr>
<p>为一门语言配置TextMate语法。你必须提供应用语法的<code>language</code>，TextMate的<code>scopeName</code>确定了语法和文件路径。</p>
<p>!&gt;<strong>注意：</strong>包含语法的文件必须是JSON（以.json结尾的文件）或者XML的plist格式文件。</p>
<h4 id="示例-7"><a href="#示例-7" class="headerlink" title="示例"></a>示例</h4><pre><code>"contributes": {
    "grammars": [{
        "language": "markdown",
        "scopeName": "text.html.markdown",
        "path": "./syntaxes/markdown.tmLanguage.json",
        "embeddedLanguages": {
            "meta.embedded.block.frontmatter": "yaml",
            ...
        }
    }]
}</code></pre><p>查看语法高亮指南学习更多从现有的语法高亮插件迁移的内容。</p>
<p><img src="/images/loading.gif" data-original="../images/development/b66201d80ece86f0d0c04043590c8728.png" alt=""></p>
<h3 id="contributes-themes"><a href="#contributes-themes" class="headerlink" title="contributes.themes"></a>contributes.themes</h3><hr>
<p>为VS Code添加TextMate主题。你必须添加一个label，指定这个主题是dark还是light的（以便VS Code根据你的主题调整界面），当然还需要加上目标文件路径（XML plist 格式）。</p>
<p>!&gt;<strong>注意：</strong>包含语法的文件必须是JSON（以.json结尾的文件）或者XML的plist格式文件。</p>
<h4 id="示例-8"><a href="#示例-8" class="headerlink" title="示例"></a>示例</h4><pre><code>"contributes": {
    "themes": [{
        "label": "Monokai",
        "uiTheme": "vs-dark",
        "path": "./themes/Monokai.tmTheme"
    }]
}</code></pre><p>查看改变色彩主题学习使用yo code插件生成器将TextMate.tmTheme文件快速打包成VS Code插件。</p>
<h3 id="contributes-snippets"><a href="#contributes-snippets" class="headerlink" title="contributes.snippets"></a>contributes.snippets</h3><hr>
<p>为语言添加代码片段。<code>language</code>属性必须是<a href="https://code.visualstudio.com/docs/languages/identifiers" target="_blank" rel="noopener">语言标识符</a>而<code>path</code>则必须是使用<a href="https://code.visualstudio.com/docs/editor/userdefinedsnippets#_snippet-syntax" target="_blank" rel="noopener">VS Code代码片段格式</a>的代码片段文件的相对路径。</p>
<h4 id="示例-9"><a href="#示例-9" class="headerlink" title="示例"></a>示例</h4><p>下面是一个Go语言的代码片段：</p>
<pre><code>"contributes": {
    "snippets": [{
        "language": "go",
        "path": "./snippets/go.json"
    }]
}</code></pre><h3 id="contributes-jsonValidation"><a href="#contributes-jsonValidation" class="headerlink" title="contributes.jsonValidation"></a>contributes.jsonValidation</h3><hr>
<p>为<code>json</code>文件添加校验器。<code>url</code>值可以是本地路径也可以是插件中的模式文件（schema file），或者是远程服务器的URL比如：<a href="http://schemastore.org/json" target="_blank" rel="noopener">json schema</a></p>
<h4 id="示例-10"><a href="#示例-10" class="headerlink" title="示例"></a>示例</h4><pre><code>"contributes": {
    "jsonValidation": [{
        "fileMatch": ".jshintrc",
        "url": "http://json.schemastore.org/jshintrc"
    }]
}</code></pre><h3 id="contributes-views"><a href="#contributes-views" class="headerlink" title="contributes.views"></a>contributes.views</h3><hr>
<p>为VS Code 添加视图。你需要为视图指定唯一标识和名称。可以配置的属性如下：</p>
<ul>
<li><code>explorer</code>: 活动栏中的资源管理视图容器。</li>
<li><code>scm</code>: 活动栏中的源代码管理(SCM) 视图容器。</li>
<li><code>debug</code>: 活动栏中的调试视图容器。</li>
<li><code>test</code>: 活动栏中的测试视图容器。</li>
<li>Custom view containers 由插件提供的自定义视图容器。</li>
</ul>
<p>当用户打开视图，VS Code会触发<code>onView:${viewId}</code>激活事件（比如：下面示例中的<code>onView:nodeDependencies</code>）。你也可以用<code>when</code>控制视图的可见性。</p>
<h4 id="示例-11"><a href="#示例-11" class="headerlink" title="示例"></a>示例</h4><pre><code>"contributes": {
    "views": {
        "explorer": [
            {
                "id": "nodeDependencies",
                "name": "Node Dependencies",
                "when": "workspaceHasPackageJSON"
            }
        ]
    }
}</code></pre><p><img src="/images/loading.gif" data-original="../images/development/9ec6be0943eb38bb49edcece9c8c67fc.png" alt=""></p>
<p>插件创作者应该通过<code>createTreeView</code>API提供的<a href="https://code.visualstudio.com/docs/extensionAPI/vscode-api#TreeDataProvider" target="_blank" rel="noopener">data provider</a>创建一个<a href="https://code.visualstudio.com/docs/extensionAPI/vscode-api#TreeView" target="_blank" rel="noopener">TreeView</a>或者直接使用<code>registerTreeDataProvider</code>注册一个<a href="https://code.visualstudio.com/docs/extensionAPI/vscode-api#TreeDataProvider" target="_blank" rel="noopener">data provider</a>。更多示例参考<a href="https://github.com/Microsoft/vscode-extension-samples/tree/master/tree-view-sample" target="_blank" rel="noopener">这里</a></p>
<h3 id="contributes-viewsContainers"><a href="#contributes-viewsContainers" class="headerlink" title="contributes.viewsContainers"></a>contributes.viewsContainers</h3><hr>
<p>配置自定义视图的视图容器。你需要为视图指定唯一标识和标题和图标。目前你只可以配置活动栏（activitybar），下面的示例展示了活动栏中的<code>Package Explorer</code>视图容器应该如何配置。</p>
<h4 id="示例-12"><a href="#示例-12" class="headerlink" title="示例"></a>示例</h4><pre><code>"contributes": {
    "viewsContainers": {
        "activitybar": [
            {
                "id": "package-explorer",
                "title": "Package Explorer",
                "icon": "resources/package-explorer.svg"
            }
        ]
    },
    "views": {
        "package-explorer": [
            {
                "id": "package-dependencies",
                "name": "Dependencies"
            },
            {
                "id": "package-outline",
                "name": "Outline"
            }
        ]
    }
}</code></pre><p><img src="/images/loading.gif" data-original="../images/development/aa867b3a6db0992cd6bddc0b03b15a0a.png" alt=""></p>
<p><strong>图标规格</strong></p>
<ul>
<li><code>Size:</code> 28x28的图标居中于50x40的视图块上。</li>
<li><code>Color:</code> 图标应使用黑白单色。</li>
<li><code>Format:</code> 虽然图片格式的图标都是可以的，但建议使用SVG图标。</li>
<li><code>States:</code> 所有图标状态继承下列样式：</li>
</ul>
<table>
<thead>
<tr>
<th align="left">State</th>
<th align="left">Opacity</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Default</td>
<td align="left">60%</td>
</tr>
<tr>
<td align="left">Hover</td>
<td align="left">100%</td>
</tr>
<tr>
<td align="left">Active</td>
<td align="left">100%</td>
</tr>
</tbody></table>
<h3 id="contributes-problemMatchers"><a href="#contributes-problemMatchers" class="headerlink" title="contributes.problemMatchers"></a>contributes.problemMatchers</h3><hr>
<p>配置问题定位器的模式。这些配置在输出面板和终端中都会有所体现，下面是一个配置了插件中的gcc编译器的问题定位器示例：</p>
<h4 id="示例-13"><a href="#示例-13" class="headerlink" title="示例"></a>示例</h4><pre><code>"contributes": {
    "problemMatchers": [
        {
            "name": "gcc",
            "owner": "cpp",
            "fileLocation": ["relative", "${workspaceFolder}"],
            "pattern": {
                "regexp": "^(.*):(\\d+):(\\d+):\\s+(warning|error):\\s+(.*)$",
                "file": 1,
                "line": 2,
                "column": 3,
                "severity": 4,
                "message": 5
            }
        }
    ]
}</code></pre><p>这个问题定位器现在可以通过名称引用<code>$gcc</code>在<code>task.json</code>中使用了，示例如下：</p>
<pre><code>{
    "version": "2.0.0",
    "tasks": [
        {
            "label": "build",
            "command": "gcc",
            "args": ["-Wall", "helloWorld.c", "-o", "helloWorld"],
            "problemMatcher": "$gcc"
        }
    ]
}</code></pre><p>更多内容请查看：<a href="https://code.visualstudio.com/docs/editor/tasks#_defining-a-problem-matcher" target="_blank" rel="noopener">实现一个问题定位器</a></p>
<h3 id="contributes-problemPatterns"><a href="#contributes-problemPatterns" class="headerlink" title="contributes.problemPatterns"></a>contributes.problemPatterns</h3><hr>
<p>配置可以在问题定位器（见上）中可以使用的问题模式的名称。</p>
<h3 id="contributes-taskDefinitions"><a href="#contributes-taskDefinitions" class="headerlink" title="contributes.taskDefinitions"></a>contributes.taskDefinitions</h3><hr>
<p>配置和定义一个object结构，定义系统中唯一的<em>配置任务</em>。任务定义最少需要一个<code>type</code>属性，不过通常需要更多的属性配置。 在package.json文件中，<em>一个展示脚本的任务</em>看起来是这样的：</p>
<pre><code>"taskDefinitions": [
    {
        "type": "npm",
        "required": [
            "script"
        ],
        "properties": {
            "script": {
                "type": "string",
                "description": "The script to execute"
            },
            "path": {
                "type": "string",
                "description": "The path to the package.json file. If omitted the package.json in the root of the workspace folder is used."
            }
        }
    }
]</code></pre><p>任务定义是JSON格式的，且包含<code>required</code>和<code>properties</code>两个属性。 <code>type</code>属性定义了任务类型，如果上述例子变成：</p>
<ul>
<li><code>"type": "npm"</code>要求任务与npm任务相关联</li>
<li><code>"required": [ "script" ]</code>其中<code>script</code>属性不可或缺。<code>path</code>属性变成可选。</li>
<li><code>"properties": {...}</code>：定义了其他属性和他们的类型</li>
</ul>
<p>当插件真的创建了一个任务，它需要传入一个与package.json中任务配置对应的<code>TaskDefinition</code>。对于<code>npm</code>任务来说，pacakge.json中的脚本应该是这样的：</p>
<pre><code>let task = new vscode.Task({ type: 'npm', script: 'test' }, ....);</code></pre><h3 id="contributes-colors"><a href="#contributes-colors" class="headerlink" title="contributes.colors"></a>contributes.colors</h3><hr>
<p>这些色彩可用于状态栏的编辑器装饰器。定义之后，用户可以在<code>workspace.colorCustomization</code>设置中自定义颜色，用户的主题会覆盖这些色值。</p>
<pre><code>"contributes": {
  "colors": [{
      "id": "superstatus.error",
      "description": "Color for error message in the status bar.",
      "defaults": {
          "dark": "errorForeground",
          "light": "errorForeground",
          "highContrast": "#010203"
      }
  }]
}</code></pre><h3 id="contributes-typescriptServerPlugins"><a href="#contributes-typescriptServerPlugins" class="headerlink" title="contributes.typescriptServerPlugins"></a>contributes.typescriptServerPlugins</h3><hr>
<p>配置VS Code的Javascript和Typescript支持的<a href="https://github.com/Microsoft/TypeScript/wiki/Writing-a-Language-Service-Plugin" target="_blank" rel="noopener">Typescript 服务器插件</a>：</p>
<pre><code>"contributes": {
   "typescriptServerPlugins": [
      {
        "name": "typescript-styled-plugin"
      }
    ]
}</code></pre><p>上述例子配置了<a href="https://github.com/Microsoft/typescript-styled-plugin" target="_blank" rel="noopener"><code>typescript-styled-plugin</code></a>，这个插件为Javascript和Typescript添加了风格化的组件智能提示。这个插件会从扩展插件中加载，而且必须在<code>dependency</code>中列明：</p>
<pre><code>{
    "dependencies": {
        "typescript-styled-plugin": "*"
    }
}</code></pre><p>Typescript 服务器插件可以被所有Javascript和Typescript文件加载，只有当用户的工作区使用Typescript时才会激活。</p>
<h2 id="激活事件"><a href="#激活事件" class="headerlink" title="激活事件"></a>激活事件</h2><p><strong>激活事件</strong>是在<code>package.json</code>中的<code>activationEvents</code>字段声明的一个JSON对象, 参考插件清单. 当<strong>激活事件</strong>触发时, 插件就会被激活. 下面是可用的<strong>激活事件</strong>列表:</p>
<ul>
<li>onLanguage</li>
<li>onCommand</li>
<li>onDebug<ul>
<li>onDebugInitialConfigurations</li>
<li>onDebugResolve</li>
</ul>
</li>
<li>workspaceContains</li>
<li>onFileSystem</li>
<li>onView</li>
<li>onUri</li>
<li>onWebviewPanel</li>
<li>*</li>
</ul>
<p><code>package.json</code>的配置项都可以在插件清单中找到.</p>
<h3 id="onLanguage"><a href="#onLanguage" class="headerlink" title="onLanguage"></a>onLanguage</h3><hr>
<p>打开特定语言文件时激活事件和相关插件</p>
<pre><code>...
"activationEvents": [
  "onLanguage:python"
]
...</code></pre><p><code>onLanguage</code>事件需要指定特定的<a href="https://code.visualstudio.com/docs/languages/identifiers" target="_blank" rel="noopener">语言标识符</a></p>
<p>也可以添加多种语言:</p>
<pre><code>"activationEvents": [
  "onLanguage:json",
  "onLanguage:markdown",
  "onLanguage:typescript"
]</code></pre><h3 id="onCommand"><a href="#onCommand" class="headerlink" title="onCommand"></a>onCommand</h3><hr>
<p>调用命令时激活</p>
<pre><code>...
"activationEvents": [
  "onCommand:extension.sayHello"
]
...</code></pre><h3 id="onDebug"><a href="#onDebug" class="headerlink" title="onDebug"></a>onDebug</h3><hr>
<p>调试会话(debug session)启动前激活</p>
<pre><code>...
"activationEvents": [
  "onDebug"
]
...</code></pre><h4 id="onDebugInitialConfigurations"><a href="#onDebugInitialConfigurations" class="headerlink" title="onDebugInitialConfigurations"></a>onDebugInitialConfigurations</h4><h4 id="onDebugResolve"><a href="#onDebugResolve" class="headerlink" title="onDebugResolve"></a>onDebugResolve</h4><p>这是两个粒度更细的<code>onDebug</code>激活事件:</p>
<ul>
<li><code>DebugConfigurationProvider</code>中的<code>provideDebugConfigurations</code>在<code>onDebugInitialConfigurations</code>之后触发</li>
<li><code>onDebugResolve:type</code>在<code>DebugConfigurationProvider</code>的<code>resolveDebugConfiguration</code>方法之前触发.</li>
</ul>
<p><strong>友情提示</strong>: 如果调试插件比较轻量, 使用<code>onDebug</code>. 相反, 根据<code>DebugConfigurationProvider</code>实现的对应方法（<code>provideDebugConfigurations</code>或<code>resolveDebugConfiguration</code>），使用<code>onDebugInitialConfigurations</code>或<code>onDebugResolve</code>. 参阅使用调试器插件.</p>
<h3 id="workspaceContains"><a href="#workspaceContains" class="headerlink" title="workspaceContains"></a>workspaceContains</h3><hr>
<p>文件夹打开后，且文件夹中至少包含一个符合glob模式的文件时触发.</p>
<pre><code>"activationEvents": [
  "workspaceContains:**/.editorconfig"
]</code></pre><h3 id="onFileSystem"><a href="#onFileSystem" class="headerlink" title="onFileSystem"></a>onFileSystem</h3><hr>
<p>以协议（scheme）打开文件或文件夹时触发。通常是<code>file</code>-协议，也可以用自定义的文件供应器函数替换掉，比如<code>ftp</code>、<code>ssh</code>.</p>
<pre><code>...
"activationEvents": [
  "onFileSystem:sftp"
]
...</code></pre><h3 id="onView"><a href="#onView" class="headerlink" title="onView"></a>onView</h3><hr>
<p>指定id的视图展开时触发:</p>
<pre><code>...
"activationEvents": [
  "onView:nodeDependencies"
]
...</code></pre><h3 id="onUri"><a href="#onUri" class="headerlink" title="onUri"></a>onUri</h3><hr>
<p>插件的系统级URI打开时触发。这个URI协议需要带上<code>vscode</code>或者 <code>vscode-insiders</code>协议。URI主机名必须是插件的唯一标识，剩余的URI是可选的。</p>
<pre><code>...
"activationEvents": [
  "onUri"
]
...</code></pre><p>如果<code>vscode.git</code>插件定义了<code>onUri</code>激活事件，那么下列任意URI打开时就会触发:</p>
<ul>
<li><code>vscode://vscode.git/init</code></li>
<li><code>vscode://vscode.git/clone?url=https%3A%2F%2Fgithub.com%2FMicrosoft%2Fvscode-vsce.git</code></li>
<li><code>vscode-insiders://vscode.git/init</code>(for VS Code Insiders)</li>
</ul>
<h3 id="onWebviewPanel"><a href="#onWebviewPanel" class="headerlink" title="onWebviewPanel"></a>onWebviewPanel</h3><hr>
<p>VS Code需要恢复匹配到<code>viewType</code>的<code>webview</code>视图时触发.</p>
<p>下面是一个例子:</p>
<pre><code>"activationEvents": [
  ...,
  "onWebviewPanel:catCoding"
]</code></pre><p>这会导致插件被激活. 调用<code>window.createWebviewPanel</code>时可以设置<code>viewType</code>, 你可能会需要其它的激活事件(比如: <code>onCommand</code>)来创建<code>webview</code>视图.</p>
<h3 id="Start-up"><a href="#Start-up" class="headerlink" title="Start up"></a>Start up</h3><hr>
<p>当VS Code启动时触发。为了保证良好的用户体验，只在你的插件没有其他任何激活事件的前提下，添加这个激活事件。</p>
<pre><code>...
"activationEvents": [
  "*"
]
...</code></pre><p>!&gt; <strong>注意</strong>: 一个插件如果侦听了多个激活事件, 那么最好用<code>"*"</code>替换掉.</p>
<p>!&gt; <strong>注意</strong>: 插件<strong>必须</strong>从它的主模块中输出一个<code>activate()</code>函数，当任意的激活事件触发时，VS Code会<strong>仅仅调用一次这个函数</strong>。此外，插件也<strong>应该</strong> 导出一个<code>deactivate()</code>函数，当VS Code关闭时执行清理的任务。如果清理进程是异步的，插件的<code>deactivate()</code><strong>必须</strong>返回一个Promise。如果这个清理任务是同步的，那么<code>deactivate()</code>可以返回<code>undefined</code>。</p>
<h2 id="插件清单-1"><a href="#插件清单-1" class="headerlink" title="插件清单"></a>插件清单</h2><h3 id="配置字段"><a href="#配置字段" class="headerlink" title="配置字段"></a>配置字段</h3><hr>
<table>
<thead>
<tr>
<th align="left">名称</th>
<th align="center">必须</th>
<th align="left">类型</th>
<th align="left">详细</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>name</code></td>
<td align="center">Y</td>
<td align="left"><code>string</code></td>
<td align="left">插件的名称必须用全小写无空格的字母组成。</td>
</tr>
<tr>
<td align="left"><code>version</code></td>
<td align="center">Y</td>
<td align="left"><code>string</code></td>
<td align="left"><a href="https://semver.org/" target="_blank" rel="noopener">SemVer</a>版本模式兼容。</td>
</tr>
<tr>
<td align="left"><code>publisher</code></td>
<td align="center">Y</td>
<td align="left"><code>string</code></td>
<td align="left">发行方名称</td>
</tr>
<tr>
<td align="left"><code>engines</code></td>
<td align="center">Y</td>
<td align="left"><code>object</code></td>
<td align="left">一个至少包含<code>vscode</code>字段的对象，其值必须兼容 VS Code版本。不可以是<code>*</code>。例如：<code>^0.10.5</code> 表明最小兼容<code>0.10.5</code>版本的VS Code。</td>
</tr>
<tr>
<td align="left"><code>license</code></td>
<td align="center"></td>
<td align="left"><code>string</code></td>
<td align="left">参考<a href="https://docs.npmjs.com/files/package.json#license" target="_blank" rel="noopener">npm’s documentation</a>。如果你在插件根目录已经提供了<code>LICENSE</code>文件。那么<code>license</code>的值应该是<code>"SEE LICENSE IN &lt;filename&gt;"</code>。</td>
</tr>
<tr>
<td align="left"><code>displayName</code></td>
<td align="center"></td>
<td align="left"><code>string</code></td>
<td align="left">插件市场所显示的插件名称。</td>
</tr>
<tr>
<td align="left"><code>description</code></td>
<td align="center"></td>
<td align="left"><code>string</code></td>
<td align="left">简单地描述一下你的插件是做什么的。</td>
</tr>
<tr>
<td align="left"><code>categories</code></td>
<td align="center"></td>
<td align="left"><code>string[]</code></td>
<td align="left">你想要使用的插件分类，可选值有：<code>[Programming Languages, Snippets, Linters, Themes, Debuggers, Formatters, Keymaps, SCM Providers, Other, Extension Packs, Language Packs]</code></td>
</tr>
<tr>
<td align="left"><code>keywords</code></td>
<td align="center"></td>
<td align="left"><code>array</code></td>
<td align="left"><strong>关键字</strong>（数组），这样用户可以更方便地找到你的插件。到时候会和市场上的其他插件以<strong>标签</strong>筛选在一起。</td>
</tr>
<tr>
<td align="left"><code>galleryBanner</code></td>
<td align="center"></td>
<td align="left"><code>object</code></td>
<td align="left">根据你的icon格式化市场的头部显示。详情见下。</td>
</tr>
<tr>
<td align="left"><code>preview</code></td>
<td align="center"></td>
<td align="left"><code>boolean</code></td>
<td align="left">在市场中会显示Preview标记。</td>
</tr>
<tr>
<td align="left"><code>main</code></td>
<td align="center"></td>
<td align="left"><code>string</code></td>
<td align="left">你的插件入口</td>
</tr>
<tr>
<td align="left"><code>contributes</code></td>
<td align="center"></td>
<td align="left"><code>object</code></td>
<td align="left">描述插件发布内容的对象。</td>
</tr>
<tr>
<td align="left"><code>activationEvents</code></td>
<td align="center"></td>
<td align="left"><code>array</code></td>
<td align="left">激活事件数组。</td>
</tr>
<tr>
<td align="left"><code>badges</code></td>
<td align="center"></td>
<td align="left"><code>array</code></td>
<td align="left">显示在插件市场页面侧边栏的合法标记。 每个标记都是一个对象，包含了3个属性：<code>url</code> 标记的图片URL，当用户点击标记和<code>description</code>时，会跳转到<code>href</code>。</td>
</tr>
<tr>
<td align="left"><code>markdown</code></td>
<td align="center"></td>
<td align="left"><code>string</code></td>
<td align="left">控制市场中使用的Markdown渲染引擎。可以是<code>github</code> (默认) 或 <code>standard</code>。</td>
</tr>
<tr>
<td align="left"><code>qna</code></td>
<td align="center"></td>
<td align="left"><code>marketplace</code> (默认), <code>string</code>, <code>false</code></td>
<td align="left">控制市场中的<strong>Q &amp; A</strong> 链接。 设置成<code>marketplace</code>时，自动使用市场默认的Q &amp; A网址。或者提供一个URL转跳到你的Q &amp; A 地址。设置为<code>false</code>时禁用。</td>
</tr>
<tr>
<td align="left"><code>dependencies</code></td>
<td align="center"></td>
<td align="left"><code>object</code></td>
<td align="left">Node.js 运行时依赖。等同于<a href="https://docs.npmjs.com/files/package.json#dependencies" target="_blank" rel="noopener">npm’s <code>dependencies</code></a>.</td>
</tr>
<tr>
<td align="left"><code>devDependencies</code></td>
<td align="center"></td>
<td align="left"><code>object</code></td>
<td align="left">Node.js 开发时依赖。 等同于<a href="https://docs.npmjs.com/files/package.json#devdependencies" target="_blank" rel="noopener">npm’s <code>devDependencies</code></a>.</td>
</tr>
<tr>
<td align="left"><code>extensionDependencies</code></td>
<td align="center"></td>
<td align="left"><code>array</code></td>
<td align="left">插件依赖，由插件ID组成的数组。当主要插件安装完成后，其他插件会相应安装。插件ID的格式为 <code>${publisher}.${name}</code>。比如：<code>vscode.csharp</code>。</td>
</tr>
<tr>
<td align="left"><code>scripts</code></td>
<td align="center"></td>
<td align="left"><code>object</code></td>
<td align="left">等同于<a href="https://docs.npmjs.com/misc/scripts" target="_blank" rel="noopener">npm的 <code>scripts</code></a>，不过有VS Code额外字段如vscode:prepublish或vscode:uninstall.</td>
</tr>
<tr>
<td align="left"><code>icon</code></td>
<td align="center"></td>
<td align="left"><code>string</code></td>
<td align="left">icon的文件路径，最小 128x128 像素 (视网膜屏幕则需 256x256)。</td>
</tr>
</tbody></table>
<p>你还可以参考<a href="https://docs.npmjs.com/files/package.json" target="_blank" rel="noopener">npm的<code>package.json</code></a></p>
<h3 id="示例-14"><a href="#示例-14" class="headerlink" title="示例"></a>示例</h3><hr>
<p>下面是一份完整的<code>package.json</code>示例</p>
<pre><code>{
    "name": "wordcount",
    "displayName": "Word Count",
    "version": "0.1.0",
    "publisher": "ms-vscode",
    "description": "Markdown Word Count Example - reports out the number of words in a Markdown file.",
    "author": {
        "name": "seanmcbreen"
    },
    "categories": [
        "Other"
    ],
    "icon": "images/icon.png",
    "galleryBanner": {
        "color": "#C80000",
        "theme": "dark"
    },
    "activationEvents": [
        "onLanguage:markdown"
    ],
    "engines": {
        "vscode": "^1.0.0"
    },
    "main": "./out/extension",
    "scripts": {
        "vscode:prepublish": "node ./node_modules/vscode/bin/compile",
        "compile": "node ./node_modules/vscode/bin/compile -watch -p ./"
    },
    "devDependencies": {
        "vscode": "0.10.x",
        "typescript": "^1.6.2"
    },
    "license": "SEE LICENSE IN LICENSE.txt",
    "bugs": {
        "url": "https://github.com/Microsoft/vscode-wordcount/issues",
        "email": "smcbreen@microsoft.com"
    },
    "repository": {
        "type": "git",
        "url": "https://github.com/Microsoft/vscode-wordcount.git"
    },
    "homepage": "https://github.com/Microsoft/vscode-wordcount/blob/master/README.md"
}</code></pre><h3 id="插件市场展示小贴士"><a href="#插件市场展示小贴士" class="headerlink" title="插件市场展示小贴士"></a>插件市场展示小贴士</h3><hr>
<p>下面是一些让你的插件在<a href="https://marketplace.visualstudio.com/VSCode" target="_blank" rel="noopener">市场</a>上看起来狂拽酷帅吊炸天的小建议。</p>
<p>使用<code>npm install -g vsce</code>安装最新的<code>vsce</code>。</p>
<p>在插件根目录中新建一个<code>README.md</code>文件，我们会把里面的内容作为插件的介绍（在市场上），你可以在<code>README.md</code>提供图片的相对路径。</p>
<p>下面是两个栗子🌰：</p>
<ol>
<li><a href="https://www.bookstack.cn/read/VS-Code-Extension-Doc-ZH/$docs-references-extension-authoring-example-word-count" target="_blank" rel="noopener">Word Count</a></li>
<li><a href="https://marketplace.visualstudio.com/items/seanmcbreen.MDTools" target="_blank" rel="noopener">MD Tools</a></li>
</ol>
<p>好的名字和描述是市场展示产品非常重要的部分。下述字符串用于VS Code文本搜索，带上关键字更容易被找到。</p>
<pre><code>    "displayName": "Word Count",
    "description": "Markdown Word Count Example - reports out the number of words in a Markdown file.",</code></pre><p>Icon和banner颜色会展示在市场页面头部，<code>theme</code>属性是指banner中使用的字体主题——<code>dark</code>或<code>light</code>。</p>
<pre><code>{
    "icon": "images/icon.png",
    "galleryBanner": {
        "color": "#C80000",
        "theme": "dark"
    },
}</code></pre><p>下面的几个可选链接（<code>bugs</code>，<code>homepage</code>，<code>repository</code>）会在市场的<strong>Resources</strong>部分显示：</p>
<pre><code>{
    "license": "SEE LICENSE IN LICENSE.txt",
    "homepage": "https://github.com/Microsoft/vscode-wordcount/blob/master/README.md",
    "bugs": {
        "url": "https://github.com/Microsoft/vscode-wordcount/issues",
        "email": "smcbreen@microsoft.com"
    },
    "repository": {
        "type": "git",
        "url": "https://github.com/Microsoft/vscode-wordcount.git"
    },
}</code></pre><table>
<thead>
<tr>
<th align="left">市场资源链接</th>
<th align="left">对应的package.json属性</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Issues</td>
<td align="left"><code>bugs:url</code></td>
</tr>
<tr>
<td align="left">Repository</td>
<td align="left"><code>repository:url</code></td>
</tr>
<tr>
<td align="left">Homepage</td>
<td align="left"><code>homepage</code></td>
</tr>
<tr>
<td align="left">License</td>
<td align="left"><code>license</code></td>
</tr>
</tbody></table>
<p>设置插件的<code>category</code>，<code>category</code>一样的插件会分类到一起以便用户查找和筛选。</p>
<blockquote>
<p><strong>注意：</strong>请使用有意义的分类值，允许的值有<code>[Programming Languages, Snippets, Linters, Themes, Debuggers, Formatters, Keymaps, SCM Providers, Other, Extension Packs, Language Packs]</code>。有语法高亮、代码补全功能的插件，请使用<code>Programming Languages</code>。<code>Language Packs</code>分类是为本地化保留的插件类别（例如：简体中文（本地化））。</p>
</blockquote>
<pre><code>{
    "categories": [
        "Linters", "Programming Languages", "Other"
    ],
}</code></pre><p>?&gt; <strong>小贴士：</strong> The <a href="https://marketplace.visualstudio.com/items?itemName=ms-devlabs.extension-manifest-editor" target="_blank" rel="noopener">Extension Manifest Editor</a> 插件可以帮你预览预览你的插件中的<code>README.md</code> 和 <code>package.json</code>， 生成的预览就像你已经发布到插件市场了一样。</p>
<h4 id="使用认证过的徽章"><a href="#使用认证过的徽章" class="headerlink" title="使用认证过的徽章"></a>使用认证过的徽章</h4><p>出于安全考虑，我们只允许可信服务商提供的标志。 我们允许来自下列URL前缀的标志：</p>
<ul>
<li><a href="http://api.bintray.com/" target="_blank" rel="noopener">api.bintray.com</a></li>
<li><a href="http://api.travis-ci.com/" target="_blank" rel="noopener">api.travis-ci.com</a></li>
<li><a href="http://api.travis-ci.org/" target="_blank" rel="noopener">api.travis-ci.org</a></li>
<li><a href="http://app.fossa.io/" target="_blank" rel="noopener">app.fossa.io</a></li>
<li><a href="http://badge.fury.io/" target="_blank" rel="noopener">badge.fury.io</a></li>
<li><a href="http://badge.waffle.io/" target="_blank" rel="noopener">badge.waffle.io</a></li>
<li><a href="http://badgen.net/" target="_blank" rel="noopener">badgen.net</a></li>
<li><a href="http://badges.frapsoft.com/" target="_blank" rel="noopener">badges.frapsoft.com</a></li>
<li><a href="http://badges.gitter.im/" target="_blank" rel="noopener">badges.gitter.im</a></li>
<li><a href="http://badges.greenkeeper.io/" target="_blank" rel="noopener">badges.greenkeeper.io</a></li>
<li><a href="http://cdn.travis-ci.com/" target="_blank" rel="noopener">cdn.travis-ci.com</a></li>
<li><a href="http://cdn.travis-ci.org/" target="_blank" rel="noopener">cdn.travis-ci.org</a></li>
<li><a href="http://ci.appveyor.com/" target="_blank" rel="noopener">ci.appveyor.com</a></li>
<li><a href="http://circleci.com/" target="_blank" rel="noopener">circleci.com</a></li>
<li><a href="http://cla.opensource.microsoft.com/" target="_blank" rel="noopener">cla.opensource.microsoft.com</a></li>
<li><a href="http://codacy.com/" target="_blank" rel="noopener">codacy.com</a></li>
<li><a href="http://codeclimate.com/" target="_blank" rel="noopener">codeclimate.com</a></li>
<li><a href="http://codecov.io/" target="_blank" rel="noopener">codecov.io</a></li>
<li><a href="http://coveralls.io/" target="_blank" rel="noopener">coveralls.io</a></li>
<li><a href="http://david-dm.org/" target="_blank" rel="noopener">david-dm.org</a></li>
<li><a href="http://deepscan.io/" target="_blank" rel="noopener">deepscan.io</a></li>
<li><a href="http://dev.azure.com/" target="_blank" rel="noopener">dev.azure.com</a></li>
<li><a href="http://gemnasium.com/" target="_blank" rel="noopener">gemnasium.com</a></li>
<li><a href="http://githost.io/" target="_blank" rel="noopener">githost.io</a></li>
<li><a href="http://gitlab.com/" target="_blank" rel="noopener">gitlab.com</a></li>
<li><a href="http://godoc.org/" target="_blank" rel="noopener">godoc.org</a></li>
<li><a href="http://goreportcard.com/" target="_blank" rel="noopener">goreportcard.com</a></li>
<li><a href="http://img.shields.io/" target="_blank" rel="noopener">img.shields.io</a></li>
<li><a href="http://isitmaintained.com/" target="_blank" rel="noopener">isitmaintained.com</a></li>
<li><a href="http://marketplace.visualstudio.com/" target="_blank" rel="noopener">marketplace.visualstudio.com</a></li>
<li><a href="http://nodesecurity.io/" target="_blank" rel="noopener">nodesecurity.io</a></li>
<li><a href="http://opencollective.com/" target="_blank" rel="noopener">opencollective.com</a></li>
<li><a href="http://snyk.io/" target="_blank" rel="noopener">snyk.io</a></li>
<li><a href="http://travis-ci.com/" target="_blank" rel="noopener">travis-ci.com</a></li>
<li><a href="http://travis-ci.org/" target="_blank" rel="noopener">travis-ci.org</a></li>
<li><a href="http://visualstudio.com/" target="_blank" rel="noopener">visualstudio.com</a></li>
<li><a href="http://vsmarketplacebadge.apphb.com/" target="_blank" rel="noopener">vsmarketplacebadge.apphb.com</a></li>
<li><a href="http://www.bithound.io/" target="_blank" rel="noopener">www.bithound.io</a></li>
<li><a href="http://www.versioneye.com/" target="_blank" rel="noopener">www.versioneye.com</a></li>
</ul>
<p>如果你想用其他标志，欢迎在我们的Github <a href="https://github.com/Microsoft/vscode/issues" target="_blank" rel="noopener">issue</a>页面提供建议。</p>
<h3 id="整合插件配置"><a href="#整合插件配置" class="headerlink" title="整合插件配置"></a>整合插件配置</h3><hr>
<p><code>yo code</code>可以帮你轻松地打包TextMate 主题，着色器，代码片段和创建新插件。当你运行了生成器，每一次配置都会创建一个完整、独立的插件包。但是，将多个配置内容整合进一个插件会更方便。比如：你想要支持一门新的语言，你会希望同时提供语法高亮和代码片段，甚至调试支持。</p>
<p>为了整合插件配置，编辑已有的<code>package.json</code>文件，然后添加新的配置内容，关联相关文件。</p>
<p>下面是一个包含了LaTex语言定义（语言标识符和相关文件插件），（语法）着色器和代码片段。</p>
<pre><code>{
    "name": "language-latex",
    "description": "LaTex Language Support",
    "version": "0.0.1",
    "publisher": "someone",
    "engines": {
        "vscode": "0.10.x"
    },
    "categories": [
        "Programming Languages",
        "Snippets"
    ],
    "contributes": {
        "languages": [{
            "id": "latex",
            "aliases": ["LaTeX", "latex"],
            "extensions": [".tex"]
        }],
        "grammars": [{
            "language": "latex",
            "scopeName": "text.tex.latex",
            "path": "./syntaxes/latex.tmLanguage.json"
        }],
        "snippets": [{
            "language": "latex",
            "path": "./snippets/snippets.json"
        }]
    }
}</code></pre><p>注意插件的<code>categories</code>字段现在包含了<code>Programming Languages</code>和<code>Snippets</code>，以便用户在市场中找到这个插件。</p>
<p>?&gt; <strong>小贴士：</strong> 整合好的配置文件应该使用同样的标识符。在上述例子中，所有的标识符都用了”latex”。这样VS Code 才知道（语法）着色器和代码片段是为LaTeX语言准备的，当编辑LaTeX文件的时候才会激活插件。</p>
<h3 id="插件包"><a href="#插件包" class="headerlink" title="插件包"></a>插件包</h3><hr>
<p>你也可以将几个独立的插件打包成一个“插件包”。插件包是指一组可以无冲突安装的插件集合。然后你就可以很方便地把插件分享给其他人，或者为特定情境创建一组插件，比如帮助PHP工程师在VS Code中快速上手。</p>
<p>一个插件包可以包含其他插件，或者直接将其打包到自身中。<code>package.json</code>中的<code>extensionDependencies</code>描述了这项依赖。</p>
<p>举个例子🌰，下面是一个PHP插件包，其中包含了调试器，语言服务器和格式化器。</p>
<pre><code>{
  "extensionDependencies": [
      "felixfbecker.php-debug",
      "felixfbecker.php-intellisense",
      "Kasik96.format-php"
  ]
}</code></pre><p>当安装插件包的时候，VS Code会连同它的插件依赖一起安装。</p>
<p>插件包需要使用市场分类中的<code>Extension Packs</code>：</p>
<pre><code>{
  "categories": [
      "Extension Packs"
  ],
}</code></pre><p>想要创建插件包，你可以使用<code>yo code</code>Yeoman生成器。另外，你也可以用你VS Code中已有的一些插件生成插件包，然后你就可以很轻松地从喜欢的插件中创建出插件包，再发布到市场上或者分享给其他用户。</p>
<p>插件包不应该有除了它内部打包之外的其他插件包，打包好的插件包应该是在整个包里面可以独立管理的。如果一个插件非常依赖另外一个插件，那么这个依赖性应该在<code>extensionDependencies</code>中声明。</p>
<h4 id="插件卸载钩子"><a href="#插件卸载钩子" class="headerlink" title="插件卸载钩子"></a>插件卸载钩子</h4><hr>
<p>如果你的插件在删除时需要做一些清理工作，你可以在package.json中的卸载钩子<code>vscode:uninstall</code>中注册一个<code>node</code>脚本。</p>
<pre><code>{
  "scripts": {
    "vscode:uninstall": "node ./out/src/lifecycle"
  }
}</code></pre><p>这个脚本会在插件完全卸载之后执行，也就是插件完全卸载之后——VS Code重载（关闭然后启动）之后执行。</p>
<p>!&gt; 注意：只支持Node.js脚本</p>
<p>下面有几个npmjs的Node.js 模块，可以帮你实现VS Code插件。你可以在插件的<code>dependencies</code>部分包含进去。</p>
<ul>
<li><a href="https://www.npmjs.com/package/vscode-nls" target="_blank" rel="noopener">vscode-nls</a> - 支持插件的国际化和本地化。</li>
<li><a href="https://www.npmjs.com/package/vscode-uri" target="_blank" rel="noopener">vscode-uri</a> - 使用VS Code实现的URI。</li>
<li><a href="https://www.npmjs.com/package/jsonc-parser" target="_blank" rel="noopener">jsonc-parser</a> - 允许带注释的JSON检查器。</li>
<li><a href="https://www.npmjs.com/package/request-light" target="_blank" rel="noopener">request-light</a> - 带代理支持的轻量级Node.js请求库。</li>
<li><a href="https://www.npmjs.com/package/vscode-extension-telemetry" target="_blank" rel="noopener">vscode-extension</a> - 提供VS Code 插件的持续遥测监控报告。</li>
<li><a href="https://www.npmjs.com/package/vscode-languageclient" target="_blank" rel="noopener">vscode-languageclient</a> - 轻松地将语言服务器绑定到语言服务器协议上。</li>
</ul>
<h2 id="内置命令"><a href="#内置命令" class="headerlink" title="内置命令"></a>内置命令</h2><p>这篇文档列出了可能需要与<code>vscode.commands.executeCommand</code>一起使用的命令集合.</p>
<p>阅读命令指南以了解如何使用<code>commands</code>API.</p>
<p>下面是一个如何在 VS Code 中打开新文件夹的例子:</p>
<pre><code>let uri = Uri.file('/some/path/to/folder');
let success = await commands.executeCommand('vscode.openFolder', uri);</code></pre><h3 id="命令-2"><a href="#命令-2" class="headerlink" title="命令"></a>命令</h3><p><code>vscode.executeWorkspaceSymbolProvider</code> - 执行工作区所有的<strong>符号</strong>供应器函数</p>
<ul>
<li><em>query</em> - 搜索关键词</li>
<li><em>(returns)</em> - promise函数, 且参数为具有SymbolInformation和DocumentSymbol的实例数组.</li>
</ul>
<p><code>vscode.executeDefinitionProvider</code> - 执行所有的<strong>定义</strong>供应器函数</p>
<ul>
<li><em>uri</em> - 文档的Uri</li>
<li><em>position</em> - 某个符号的位置</li>
<li><em>(returns)</em> - promise函数, 且参数为Location实例数组.</li>
</ul>
<p><code>vscode.executeDeclarationProvider</code> - 执行所有的<strong>声明</strong>供应器函数.</p>
<ul>
<li><em>uri</em> - 文档的Uri</li>
<li><em>position</em> - 某个符号的位置</li>
<li><em>(returns)</em> - promise函数, 且参数为Location实例数组.</li>
</ul>
<p><code>vscode.executeTypeDefinitionProvider</code> - 执行所有的<strong>类型定义</strong>供应器函数.</p>
<ul>
<li><em>uri</em> - 文档的Uri</li>
<li><em>position</em> - 某个符号的位置</li>
<li><em>(returns)</em> - promise函数, 且参数为Location实例数组.</li>
</ul>
<p><code>vscode.executeImplementationProvider</code> - 执行所有的<strong>接口</strong>供应器函数</p>
<ul>
<li><em>uri</em> - 文档的Uri</li>
<li><em>position</em> - 某个符号的位置</li>
<li><em>(returns)</em> - promise函数, 且参数为Location实例数组</li>
</ul>
<p><code>vscode.executeHoverProvider</code> - 执行所有的<strong>悬停</strong>供应器函数.</p>
<ul>
<li><em>uri</em> - 文档的Uri</li>
<li><em>position</em> - 某个符号的位置</li>
<li><em>(returns)</em> - promise函数, 且参数为Hover实例数组</li>
</ul>
<p><code>vscode.executeDocumentHighlights</code> - 执行<strong>文档高亮</strong>供应器函数.</p>
<ul>
<li><em>uri</em> - 文档的Uri</li>
<li><em>position</em> - 在文档中的位置</li>
<li><em>(returns)</em> - promise函数, 且参数为DocumentHighlight实例数组</li>
</ul>
<p><code>vscode.executeReferenceProvider</code> - 执行<strong>引用</strong>供应器函数</p>
<ul>
<li><em>uri</em> - 文档的Uri</li>
<li><em>position</em> - 在文档中的位置</li>
<li><em>(returns)</em> - promise函数, 且参数为Location实例数组</li>
</ul>
<p><code>vscode.executeDocumentRenameProvider</code> - 执行<strong>重命名</strong>供应器函数</p>
<ul>
<li><em>uri</em> - 文档的Uri</li>
<li><em>position</em> - 在文档中的位置</li>
<li><em>newName</em> - 新的符号名称</li>
<li><em>(returns)</em> - promise函数, 且参数为WorkspaceEdit</li>
</ul>
<p><code>vscode.executeSignatureHelpProvider</code> - 执行<strong>符号帮助</strong>供应器函数</p>
<ul>
<li><em>uri</em> - 文档的Uri</li>
<li><em>position</em> - 在文档中的位置</li>
<li><em>triggerCharacter</em> - (可选的)当用户输入特定字符时（如<code>,</code> 或 <code>(</code>）触发符号帮助</li>
<li><em>(returns)</em> - promise函数, 且参数为SignatureHelp</li>
</ul>
<p><code>vscode.executeDocumentSymbolProvider</code> - 执行<strong>文档符号</strong>供应器函数</p>
<ul>
<li><em>uri</em> - 文档的Uri</li>
<li><em>(returns)</em> - promise函数, 且参数为具有SymbolInformation和DocumentSymbol的实例数组</li>
</ul>
<p><code>vscode.executeCompletionItemProvider</code> - 执行<strong>自动补全</strong>供应器函数</p>
<ul>
<li><em>uri</em> - 文档的Uri</li>
<li><em>position</em> - 在文档中的位置</li>
<li><em>triggerCharacter</em> - (可选的)当用户输入诸如(<code>,</code> <code>(</code>)之类的字符时触发</li>
<li><em>itemResolveCount</em> - (可选的)补全的符号数量(数目太大会减慢补全速度)</li>
<li><em>(returns)</em> - promise函数, 且参数为CompletionList实例</li>
</ul>
<p><code>vscode.executeCodeActionProvider</code> - 执行<strong>代码操作小灯泡提示</strong>供应器函数</p>
<ul>
<li><em>uri</em> - 文档的Uri</li>
<li><em>range</em> - 在文档中的范围</li>
<li><em>(returns)</em> - promise函数, 且参数为Command实例数组</li>
</ul>
<p><code>vscode.executeCodeLensProvider</code> - 执行<strong>CodeLens</strong>供应器函数</p>
<ul>
<li><em>uri</em> - 文档的Uri</li>
<li><em>itemResolveCount</em> - (可选的)需要解析的lenses数量, 数目太大会影响性能</li>
<li><em>(returns)</em> - promise函数, 且参数为CodeLens实例数组</li>
</ul>
<p><code>vscode.executeFormatDocumentProvider</code> - 执行<strong>格式化文档</strong>供应器函数</p>
<ul>
<li><em>uri</em> - 文档的Uri</li>
<li><em>options</em> - 配置项</li>
<li><em>(returns)</em> - promise函数, 且参数为TextEdits数组</li>
</ul>
<p><code>vscode.executeFormatRangeProvider</code> - 执行<strong>局部格式化</strong>供应器函数</p>
<ul>
<li><em>uri</em> - 文档的Uri</li>
<li><em>range</em> - 限制的范围</li>
<li><em>options</em> - 配置项</li>
<li><em>(returns)</em> - promise函数, 且参数为TextEdits数组</li>
</ul>
<p><code>vscode.executeFormatOnTypeProvider</code> - 执行<strong>格式化文档</strong>供应器函数</p>
<ul>
<li><em>uri</em> - 文档的Uri</li>
<li><em>position</em> - 在文档中的位置</li>
<li><em>ch</em> - 在输入某个字符之后进行格式化</li>
<li><em>options</em> - 配置项</li>
<li><em>(returns)</em> - promise函数, 且参数为TextEdits数组</li>
</ul>
<p><code>vscode.executeLinkProvider</code> - 执行<strong>文档链接</strong>供应器函数</p>
<ul>
<li><em>uri</em> - 文档的Uri</li>
<li><em>(returns)</em> - promise函数, 且参数为DocumentLink实例数组</li>
</ul>
<p><code>vscode.executeDocumentColorProvider</code> - 执行<strong>文档颜色</strong>供应器函数</p>
<ul>
<li><em>uri</em> - 文档的Uri</li>
<li><em>(returns)</em> - promise函数, 且参数为ColorInfomation对象数组</li>
</ul>
<p><code>vscode.executeColorPresentationProvider</code> - 执行<strong>色彩呈现</strong>供应器函数</p>
<ul>
<li><em>color</em> - 需要展示并插入的颜色</li>
<li><em>context</em> - 上下文对象, 包括uri和影响范围</li>
<li><em>(returns)</em> - promise函数, 且参数为ColorPresentation对象数组</li>
</ul>
<p><code>vscode.openFolder</code> - 在当前窗口或者新的窗口打开一个文件夹或者工作区</p>
<ul>
<li><em>uri</em> - 被打开的文件夹或工作区Uri. 如果未提供, 会打开一个询问提示框</li>
<li><em>newWindow</em> - (可选的)是否在新窗口打开. 默认在本窗口</li>
</ul>
<p>!&gt; <strong>注意：</strong> 在当前窗口打开, 如果未设置<code>newWindow = true</code>, 会在指定的工作区或者文件夹开启新的拓展主机进程, 并且关闭当前拓展主机进程.</p>
<p><code>vscode.diff</code> - 在diff编辑器中打开指定资源以比较它们的内容</p>
<ul>
<li><em>left</em> diff编辑器左边的文件</li>
<li><em>right</em> diff编辑器右边的文件</li>
<li><em>title</em> (可选)diff编辑器标题</li>
<li><em>options</em> (可选)编辑器配置项, 参考<code>vscode.TextDocumentShowOptions</code></li>
</ul>
<p><code>vscode.open</code> - 在编辑器打开指定文件</p>
<ul>
<li><em>resource</em> - 要打开的文件</li>
<li><em>columnOrOptions</em> - (可选)可以是要打开的编辑器列，也可以是编辑器选项，参考<code>vscode.TextDocumentShowOptions</code></li>
</ul>
<p>可以是文本文件、二进制文件、http(s) url. 如果需要更多的配置项, 使用<code>vscode.window.showTextDocument</code>代替.</p>
<p><code>vscode.removeFromRecentlyOpened</code> - 在最近打开的列表中移除一个路径</p>
<ul>
<li><em>path</em> - 被移除的路径</li>
</ul>
<p><code>vscode.setEditorLayout</code> - 设置编辑器布局</p>
<ul>
<li><em>layout</em> - 被设置的布局</li>
</ul>
<p>布局是一个对象，带有初始布局方向（可选，0 = 水平布局，1 = 垂直布局），还有一个包含编辑器组的数组。每个编辑器组又有一个尺寸和另一个数组，其中有矩形布局和方向信息。如果设置了编辑器组的大小，每一行或者每一列的总和必须为1。比如一个2x2的网格：<code>{ orientation: 0, groups: [{ groups: [{}, {}], size: 0.5 }, { groups: [{}, {}], size: 0.5 }] }</code></p>
<p><code>cursorMove</code> - 移动光标到视图的合理位置</p>
<ul>
<li><p><em>Cursor move argument object</em></p>
<p>可以传递的键值对</p>
<ul>
<li><p>‘to’: 必选, 鼠标要移动到的合理位置</p>
<pre><code>'left', 'right', 'up', 'down'
'wrappedLineStart', 'wrappedLineEnd', 'wrappedLineColumnCenter'
'wrappedLineFirstNonWhitespaceCharacter', 'wrappedLineLastNonWhitespaceCharacter'
'viewPortTop', 'viewPortCenter', 'viewPortBottom', 'viewPortIfOutside'</code></pre></li>
<li><p>‘by’: 移动的单位. 默认根据’to’来计算.</p>
<pre><code>'line', 'wrappedLine', 'character', 'halfLine'</code></pre></li>
<li><p>‘value’: 单位步数. 默认为’1’.</p>
</li>
<li><p>‘select’: 如果为’true’则会选中. 默认为’false’.</p>
</li>
</ul>
</li>
</ul>
<p><code>editorScroll</code> - 编辑器滚动方向</p>
<ul>
<li><p><em>Editor scroll argument object</em></p>
<p>可以传递的键值对</p>
<ul>
<li><p>‘to’: 必须的. 方向值</p>
<pre><code>'up', 'down'</code></pre></li>
<li><p>‘by’: 移动的单位. 默认根据’to’来计算.</p>
<pre><code>'line', 'wrappedLine', 'page', 'halfPage'</code></pre></li>
<li><p>‘value’: 单位步数. 默认为’1’.</p>
</li>
<li><p>‘revealCursor’: 如果为’true’, 在超出滚动视图也会显示光标.</p>
</li>
</ul>
</li>
</ul>
<p><code>revealLine</code> - 在给定的位置显示行</p>
<ul>
<li><p><em>Reveal line argument object</em></p>
<p>可以传递的键值对</p>
<ul>
<li><p>‘lineNumber’: 必须的. 行号</p>
</li>
<li><p>‘at’: 显示的合理位置</p>
<pre><code>'top', 'center', 'bottom'</code></pre></li>
</ul>
</li>
</ul>
<p><code>editor.unfold</code> - 展开编辑器内容</p>
<ul>
<li><p><em>Unfold editor argument</em></p>
<p>可以传递的键值对</p>
<ul>
<li>‘levels’: 展开的层级数. 默认为 1.</li>
<li>‘direction’: 如果是’up’, 向上展开, 否则向下展开</li>
<li>‘selectionLines’: 要使用展开功能的起始行（从0起）。如果不设置，就会使用当前激活的行（选中区）.</li>
</ul>
</li>
</ul>
<p><code>editor.fold</code> - 折叠编辑器内容</p>
<ul>
<li><p><code>Fold editor argument</code></p>
<p>可以传递的键值对</p>
<ul>
<li>‘levels’: 折叠的的层级数。默认为1</li>
<li>‘direction’: 如果设置为’up’，向上折叠，不然向下折叠</li>
<li>‘selectionLines’: 要使用折叠功能的起始行（从0起）。如果不设置，就会使用当前激活的行（选中区）</li>
</ul>
</li>
</ul>
<p><code>editor.action.showReferences</code> - 在文件中显示引用</p>
<ul>
<li><em>uri</em> - 要显示引用的文件</li>
<li><em>position</em> - 要显示的位置</li>
<li><em>locations</em> - 位置数组</li>
</ul>
<p><code>moveActiveEditor</code> - 通过标签或者组移动激活的编辑器</p>
<ul>
<li><p><em>Active editor move argument</em></p>
<p>参数</p>
<ul>
<li>‘to’: String. 目标位置</li>
<li>‘by’: String. 移动的单位(通过标签或者组).</li>
<li>‘value’: Number. 要移动的位置或者绝对位置值</li>
</ul>
</li>
</ul>
<h3 id="简单命令"><a href="#简单命令" class="headerlink" title="简单命令"></a>简单命令</h3><p>简单的命令不需要参数, 可以在<code>keybindings.json</code>的<strong>键盘快捷方式</strong>列表中找到. 在文件底部的注释块中列出了未绑定的命令.</p>
<p>查看<code>keybindings.json</code>:</p>
<p>Windows, Linux: <strong>文件</strong> &gt; <strong>首选项</strong> &gt; <strong>键盘快捷方式</strong> &gt; <code>keybindings.json</code></p>
<p>macOS: <strong>编码</strong> &gt; <strong>首选项</strong> &gt; <strong>键盘快捷方式</strong> &gt; <code>keybindings.json</code></p>
<h2 id="主题色彩"><a href="#主题色彩" class="headerlink" title="主题色彩"></a>主题色彩</h2><p>可以通过<a href="https://code.visualstudio.com/docs/getstarted/settings" target="_blank" rel="noopener">用户设置</a>的<code>workbench.colorCustomizations</code>配置项，定制Visual Studio Code的<a href="https://code.visualstudio.com/docs/getstarted/themes" target="_blank" rel="noopener">色彩主题</a>。</p>
<pre><code>{
  "workbench.colorCustomizations": {
    "activityBar.background": "#00AA00"
  }
}</code></pre><p>!&gt; <strong>注意</strong>: 如果你想用现成的颜色主题的话，通过<strong>首选项: 颜色主题</strong>的下拉菜单选取即可(Ctrl+K Ctrl+T)，参阅<a href="https://code.visualstudio.com/docs/getstarted/themes" target="_blank" rel="noopener">色彩主题</a>。</p>
<h3 id="颜色格式"><a href="#颜色格式" class="headerlink" title="颜色格式"></a>颜色格式</h3><hr>
<p>可以使用RGBA来定义色值。同样，也支持十六进制表示法: <code>#RGB</code>，<code>#RGBA</code>，<code>#RRGGBB</code>，<code>#RRGGBBAA</code>。R(红)，G(绿)，B(蓝)，A(阿尔法)是一个十六进制字符(0-9，a-f，A-F)。<code>#RRGGBB</code>和<code>#RRGGBBAA</code>分别可以简写为<code>#RGB</code>和<code>#RGBA</code>。比如，<code>#ee3355ff</code>和<code>#e35f</code>是一样的效果。</p>
<p>如果没有定义alpha值，那么它的默认值是<code>ff</code>(不透明，没有透明度)。反之，如果设为<code>00</code>，则完全透明。</p>
<p>一些颜色应该设置成透明的，以免遮挡其他注释的视线。查看颜色描述来了解哪些颜色应该使用这个规则。</p>
<h3 id="对比色"><a href="#对比色" class="headerlink" title="对比色"></a>对比色</h3><hr>
<p>一般用于高对比度的主题。通过给UI项添加额外的边框来增强对比度。</p>
<ul>
<li><code>contrastActiveBorder</code>: 在活动元素周围额外的一层边框，用来提高对比度从而区别其他元素</li>
<li><code>contrastBorder</code>: 在元素周围额外的一层边框，用来提高对比度从而区别其他元素</li>
</ul>
<h3 id="基色"><a href="#基色" class="headerlink" title="基色"></a>基色</h3><hr>
<ul>
<li><code>focusBorder</code>: 焦点元素的整体边框颜色。此颜色仅在不被其他组件覆盖时适用</li>
<li><code>foreground</code>: 整体前景色。此颜色仅在不被组件覆盖时适用</li>
<li><code>widget.shadow</code>: 编辑器内小组件（如查找/替换）的阴影颜色</li>
<li><code>selection.background</code>: 工作台所选文本的背景颜色（例如输入字段或文本区域）。注意，本设置不适用于编辑器</li>
<li><code>descriptionForeground</code>: 提供其他信息的说明文本的前景色，例如标签文本</li>
<li><code>errorForeground</code>: 错误信息的全局前景色。此颜色仅在不被组件覆盖时适用</li>
</ul>
<h3 id="文本颜色"><a href="#文本颜色" class="headerlink" title="文本颜色"></a>文本颜色</h3><hr>
<p>文本文档中的颜色，比如欢迎页</p>
<ul>
<li><code>textBlockQuote.background</code>: 文本中块引用的背景颜色</li>
<li><code>textBlockQuote.border</code>: 文本中块引用的边框颜色</li>
<li><code>textCodeBlock.background</code>: 文本中代码块的背景颜色</li>
<li><code>textLink.activeForeground</code>: 鼠标点击后或悬停时链接的前景色</li>
<li><code>textLink.foreground</code>: 文本中链接的前景色</li>
<li><code>textPreformat.foreground</code>: 预格式化文本段的前景色</li>
<li><code>textSeparator.foreground</code>: 文字分隔符的颜色</li>
</ul>
<h3 id="按钮控件"><a href="#按钮控件" class="headerlink" title="按钮控件"></a>按钮控件</h3><hr>
<p>按钮小组件的颜色，例如新窗口的资源管理器中的<strong>打开文件夹</strong>按钮。</p>
<p><img src="/images/loading.gif" data-original="../images/development/fdca839786244af9139396c2b2debae5.png" alt=""></p>
<ul>
<li><code>button.background</code>: 按钮背景色</li>
<li><code>button.foreground</code>: 按钮前景色</li>
<li><code>button.hoverBackground</code>: 鼠标悬停时按钮的背景颜色</li>
</ul>
<h3 id="下拉列表控件"><a href="#下拉列表控件" class="headerlink" title="下拉列表控件"></a>下拉列表控件</h3><hr>
<p>下拉列表小部件颜色，例如集成终端和输出面板。</p>
<p>!&gt; <strong>注意</strong>: macOS目前还不能用该控件</p>
<p><img src="/images/loading.gif" data-original="../images/development/57abce62236de195297b321cb6b40ed6.png" alt=""></p>
<ul>
<li><code>dropdown.background</code>: 下拉列表背景色</li>
<li><code>dropdown.listBackground</code>: 下拉列表背景色</li>
<li><code>dropdown.border</code>: 下拉列表边框</li>
<li><code>dropdown.foreground</code>: 下拉列表前景色</li>
</ul>
<h3 id="输入框控件"><a href="#输入框控件" class="headerlink" title="输入框控件"></a>输入框控件</h3><hr>
<p>输入框控件颜色，例如搜索视图、搜索/替换对话框。</p>
<p><img src="/images/loading.gif" data-original="../images/development/1b268f4b2ea4ac481052a7b6889c9f83.png" alt=""></p>
<ul>
<li><code>input.background</code>: 输入框背景色</li>
<li><code>input.border</code>: 输入框边框</li>
<li><code>input.foreground</code>: 输入框前景色</li>
<li><code>input.placeholderForeground</code>: 输入框中占位符的前景色</li>
<li><code>inputOption.activeBorder</code>: 输入字段中已激活选项的边框颜色</li>
<li><code>inputValidation.errorBackground</code>: 输入验证结果为错误级别时的背景色</li>
<li><code>inputValidation.errorForeground</code>: 输入验证结果为错误级别时的前景色</li>
<li><code>inputValidation.errorBorder</code>: 严重性为错误时输入验证的边框颜色</li>
<li><code>inputValidation.infoBackground</code>: 输入验证结果为信息级别时的背景色</li>
<li><code>inputValidation.infoForeground</code>: 输入验证结果为信息级别时的前景色</li>
<li><code>inputValidation.infoBorder</code>: 严重性为信息时输入验证的边框颜色</li>
<li><code>inputValidation.warningBackground</code>: 严重性为警告时输入验证的背景色</li>
<li><code>inputValidation.warningForeground</code>: 输入验证结果为警告级别时的前景色</li>
<li><code>inputValidation.warningBorder</code>: 严重性为警告时输入验证的边框颜色</li>
</ul>
<h3 id="滚动条控件"><a href="#滚动条控件" class="headerlink" title="滚动条控件"></a>滚动条控件</h3><hr>
<ul>
<li><code>scrollbar.shadow</code>: 视图滚动后，滚动条的阴影</li>
<li><code>scrollbarSlider.activeBackground</code>: 点击滚动条滑块后的背景色</li>
<li><code>scrollbarSlider.background</code>: 滚动条滑块背景色</li>
<li><code>scrollbarSlider.hoverBackground</code>: 鼠标悬停滚动条滑块时的背景色</li>
</ul>
<h3 id="徽章"><a href="#徽章" class="headerlink" title="徽章"></a>徽章</h3><hr>
<p>Badge 是小型的信息标签，如表示搜索结果数量的标签</p>
<ul>
<li><code>badge.foreground</code>: Badge前景色</li>
<li><code>badge.background</code>: Badge背景色</li>
</ul>
<h3 id="进度条"><a href="#进度条" class="headerlink" title="进度条"></a>进度条</h3><hr>
<ul>
<li><code>progressBar.background</code>: 表示长时间操作的进度条的背景色</li>
</ul>
<h3 id="列表和树"><a href="#列表和树" class="headerlink" title="列表和树"></a>列表和树</h3><hr>
<p>列表和树的色彩，例如资源管理器。激活的列表/树具有键盘焦点，反之则没有。</p>
<ul>
<li><code>list.activeSelectionBackground</code>: 激活列表/树时已选项的背景色</li>
<li><code>list.activeSelectionForeground</code>: 列表/树激活时已选项的前景色</li>
<li><code>list.dropBackground</code>: 使用鼠标移动列表项时，列表/树的背景颜色</li>
<li><code>list.focusBackground</code>: 列表/树激活时焦点项的背景色</li>
<li><code>list.focusForeground</code>: 列表/树激活时焦点项的前景色</li>
<li><code>list.highlightForeground</code>: 在列表或树中搜索时，其中匹配内容的高亮颜色</li>
<li><code>list.hoverBackground</code>: 使用鼠标移动项目时，列表或树的背景颜色</li>
<li><code>list.hoverForeground</code>: 鼠标在项目上悬停时，列表或树的前景颜色</li>
<li><code>list.inactiveSelectionBackground</code>: 列表/树未激活时已选项的背景色</li>
<li><code>list.inactiveSelectionForeground</code>: 列表/树未激活时已选项的前景色</li>
<li><code>list.inactiveFocusBackground</code>: 非激活的列表或树控件中焦点项的背景颜色</li>
<li><code>list.invalidItemForeground</code>: 列表或树中无效项的前景色，例如资源管理器中没有解析的根目录</li>
<li><code>list.errorForeground</code>: 包含错误的列表项的前景颜色</li>
<li><code>list.warningForeground</code>: 包含警告的列表项的前景颜色</li>
<li><code>listFilterWidget.background</code>: 列表和树中类型筛选器小组件的背景色</li>
<li><code>listFilterWidget.outline</code>: 列表和树中类型筛选器小组件的轮廓颜色</li>
<li><code>listFilterWidget.noMatchesOutline</code>: 当没有匹配项时，列表和树中类型筛选器小组件的轮廓颜色</li>
</ul>
<h3 id="活动栏"><a href="#活动栏" class="headerlink" title="活动栏"></a>活动栏</h3><hr>
<p>活动栏可显示在最左侧或最右侧，供用户快速切换侧边栏视图</p>
<ul>
<li><code>activityBar.background</code>: 活动栏背景色</li>
<li><code>activityBar.dropBackground</code>: 拖放活动栏项时的视觉反馈颜色。此颜色应有透明度，以便活动栏条目能透过此颜色</li>
<li><code>activityBar.foreground</code>: 激活时活动栏项的前景色</li>
<li><code>activityBar.inactiveForeground</code>: 未激活时活动栏项的前景色</li>
<li><code>activityBar.border</code>: 活动栏分隔侧边栏的边框颜色</li>
<li><code>activityBarBadge.background</code>: 活动通知徽章背景色</li>
<li><code>activityBarBadge.foreground</code>: 活动通知徽章前景色</li>
</ul>
<h3 id="侧边栏"><a href="#侧边栏" class="headerlink" title="侧边栏"></a>侧边栏</h3><hr>
<p>侧边栏是资源管理器和搜索等视图的容器。</p>
<ul>
<li><code>sideBar.background</code>: 侧边栏背景色</li>
<li><code>sideBar.foreground</code>: 侧边栏前景色</li>
<li><code>sideBar.border</code>: 侧边栏分隔编辑器的边框颜色</li>
<li><code>sideBar.dropBackground</code>: 拖放侧边栏区域时的反馈颜色。此颜色应有透明度，以便侧边栏中的部分仍能透过</li>
<li><code>sideBarTitle.foreground</code>: 侧边栏标题前景色</li>
<li><code>sideBarSectionHeader.background</code>: 侧边栏节标题的背景颜色</li>
<li><code>sideBarSectionHeader.foreground</code>: 侧边栏节标题的前景色</li>
<li><code>sideBarSectionHeader.border</code>: 侧边栏节标题的边框颜色</li>
</ul>
<h3 id="编辑器组-amp-选项卡"><a href="#编辑器组-amp-选项卡" class="headerlink" title="编辑器组 &amp; 选项卡"></a>编辑器组 &amp; 选项卡</h3><hr>
<p>编辑器组是多个编辑器的容器，一个编辑器组可以包含多个编辑器。一个选项卡是一个编辑器的容器。可以在一个编辑器组里面打开多个选项卡。</p>
<ul>
<li><code>editorGroup.border</code>: 编辑器组之间的分隔颜色</li>
</ul>
<p><img src="/images/loading.gif" data-original="../images/development/c861e8e13b391b1a1a5600227ab1ff37.gif" alt=""></p>
<ul>
<li><code>editorGroup.dropBackground</code>: 拖动编辑器时的背景颜色</li>
</ul>
<p><img src="/images/loading.gif" data-original="../images/development/1a5ba4b971530190fe1df41ca721e68c.gif" alt=""></p>
<ul>
<li><code>editorGroupHeader.noTabsBackground</code>: 禁用选项卡 (<code>"workbench.editor.showTabs": false</code>) 时编辑器组标题颜色</li>
</ul>
<p><img src="/images/loading.gif" data-original="../images/development/d2e9c4bb889fd61495a273986f58bb00.gif" alt=""></p>
<ul>
<li><code>editorGroupHeader.tabsBackground</code>: 启用选项卡时编辑器组标题的背景颜色</li>
</ul>
<p><img src="/images/loading.gif" data-original="../images/development/23307f72ad4a71d5d1348eda070563b8.gif" alt=""></p>
<ul>
<li><code>editorGroupHeader.tabsBorder</code>: 选项卡启用时编辑器组标题的边框颜色。</li>
</ul>
<p><img src="/images/loading.gif" data-original="../images/development/c6a5aa451e2e3222d8807dffae02e50a.gif" alt=""></p>
<ul>
<li><code>editorGroup.emptyBackground</code>: 空编辑器组的背景色</li>
<li><code>editorGroup.focusedEmptyBorder</code>: 编辑器组被聚焦时的边框颜色</li>
<li><code>tab.activeBackground</code>: 活动选项卡的背景色</li>
<li><code>tab.activeForeground</code>: 活动组中活动选项卡的前景色</li>
<li><code>tab.border</code>: 分隔多个选项卡的边框</li>
<li><code>tab.activeBorder</code>: 活动选项卡底部的边框</li>
<li><code>tab.unfocusedActiveBorder</code>: 在失去焦点的编辑器组中的活动选项卡底部的边框</li>
<li><code>tab.activeBorderTop</code>: 活动选项卡顶部的边框</li>
<li><code>tab.unfocusedActiveBorderTop</code>: 在失去焦点的编辑器组中的活动选项卡顶部的边框</li>
<li><code>tab.inactiveBackground</code>: 非活动选项卡的背景色</li>
<li><code>tab.inactiveForeground</code>: 活动组中非活动选项卡的前景色</li>
<li><code>tab.unfocusedActiveForeground</code>: 一个失去焦点的编辑器组中的活动选项卡的前景色</li>
<li><code>tab.unfocusedInactiveForeground</code>: 在一个失去焦点的组中非活动选项卡的前景色</li>
<li><code>tab.hoverBackground</code>: 鼠标悬停时选项卡的背景色</li>
<li><code>tab.unfocusedHoverBackground</code>: 鼠标悬停时非焦点组选项卡的背景色</li>
<li><code>tab.hoverBorder</code>: 鼠标悬停时选项卡的边框颜色</li>
<li><code>tab.unfocusedHoverBorder</code>: 鼠标悬停时非焦点组选项卡的边框颜色</li>
<li><code>tab.activeModifiedBorder</code> : 在活动编辑器组中已修改 (存在更新) 的活动选项卡的顶部边框</li>
<li><code>tab.inactiveModifiedBorder</code>: 在活动编辑器组中已修改 (存在更新) 的非活动选项卡的顶部边框</li>
<li><code>tab.unfocusedActiveModifiedBorder</code>: 在未获焦点的编辑器组中已修改 (存在更新) 的活动选项卡的顶部边框</li>
<li><code>tab.unfocusedInactiveModifiedBorder</code>: 在未获焦点的编辑器组中已修改 (存在更新) 的非活动选项卡的顶部边框</li>
<li><code>editorPane.background</code>: 居中编辑器布局中左侧与右侧编辑器窗格的背景色</li>
</ul>
<h3 id="编辑器色彩"><a href="#编辑器色彩" class="headerlink" title="编辑器色彩"></a>编辑器色彩</h3><hr>
<p>编辑器里面最重要的字符符号颜色主要是语法高亮。可以在色彩主题中或者使用<code>editor.tokenColorCustomizations</code>配置。参阅<a href="https://code.visualstudio.com/docs/getstarted/themes#_customizing-a-color-theme" target="_blank" rel="noopener">定制色彩主题</a>以了解更新色彩主题和可用的标记类型</p>
<p>下面列出了所有的编辑器色彩:</p>
<ul>
<li><code>editor.background</code>: 编辑器背景色</li>
<li><code>editor.foreground</code>: 编辑器前景色</li>
<li><code>editorLineNumber.foreground</code>: 编辑器行号的颜色</li>
<li><code>editorLineNumber.activeForeground</code>: 编辑器活动行号的颜色</li>
<li><code>editorCursor.background</code>: 编辑器光标的背景色。可以自定义块型光标覆盖字符的颜色</li>
<li><code>editorCursor.foreground</code>: 编辑器光标的前景色。可以自定义块型光标覆盖字符的颜色</li>
</ul>
<p>当选中多个字符时会显示选区颜色。同时，与所选文本相关的区域也会高亮显示。</p>
<p><img src="/images/loading.gif" data-original="../images/development/0eaf2b00becd85f533244718fda52b37.png" alt=""></p>
<ul>
<li><code>editor.selectionBackground</code>: 所选内容的背景色</li>
<li><code>editor.selectionForeground</code>: 所选文本的前景色</li>
<li><code>editor.inactiveSelectionBackground</code>: 非活动编辑器中所选内容的颜色，颜色需带有透明度，以免遮挡底层样式</li>
<li><code>editor.selectionHighlightBackground</code>: 具有与所选项相关内容的区域的颜色。颜色需带有透明度，以免遮挡底层样式</li>
<li><code>editor.selectionHighlightBorder</code>: 与所选项内容相同的区域的边框颜色</li>
</ul>
<p>当光标出现在符号或单词中时需显示单词高亮，依据语言插件的实现情况，可提供与高亮单词所对应声明和引用的语法高亮效果，但是这个高亮效果需和只读、书写的情况下的高亮效果有所区分。如果文档的语法插件不提供此项功能，那么高亮效果应降级到单纯的单词高亮:</p>
<p><img src="/images/loading.gif" data-original="../images/development/aec1d0d6ee59a45379fd66a0051f5f2a.png" alt=""></p>
<ul>
<li><code>editor.wordHighlightBackground</code>: 读取访问期间符号的背景色，例如读取变量时。颜色需带有透明度，以免遮挡底层样式</li>
<li><code>editor.wordHighlightBorder</code>: 符号在进行读取访问操作时的边框颜色，例如读取变量</li>
<li><code>editor.wordHighlightStrongBackground</code>: 写入访问过程中符号的背景色，例如写入变量时。颜色需带有透明度，以免遮挡底层样式</li>
<li><code>editor.wordHighlightStrongBorder</code>: 符号在进行写入访问操作时的边框颜色，例如写入变量</li>
</ul>
<p>搜索匹配项的颜色取决于搜索/替换对话框中的输入文字:</p>
<p><img src="/images/loading.gif" data-original="../images/development/9b379398bcb3a3d5bbce96db9ef6e5f1.png" alt=""></p>
<ul>
<li><code>editor.findMatchBackground</code>: 当前搜索匹配项的颜色</li>
<li><code>editor.findMatchHighlightBackground</code>: 其他搜索匹配项的颜色。颜色需带有透明度，以免遮挡底层样式</li>
<li><code>editor.findRangeHighlightBackground</code>: 限制搜索范围的颜色(搜索弹出框小部件的‘在结果中查找’中可用)。颜色需带有透明度，以免遮挡底层样式</li>
<li><code>editor.findMatchBorder</code>: 当前搜索匹配项的边框颜色</li>
<li><code>editor.findMatchHighlightBorder</code>: 其他搜索匹配项的边框颜色</li>
<li><code>editor.findRangeHighlightBorder</code>: 搜索范围限制中的边框颜色（搜索弹出框小部件的‘在结果中查找’中可用）</li>
</ul>
<p>鼠标悬停时符号的颜色:</p>
<p><img src="/images/loading.gif" data-original="../images/development/cba6aa86baca5940be6d06dc1b146571.png" alt=""></p>
<ul>
<li><code>editor.hoverHighlightBackground</code>: 在下面突出显示悬停的字词。颜色需带有透明度，以免遮挡底层样式</li>
</ul>
<p>当前行(光标所在行)只会显示背景高亮或者边框高亮(两者之一)</p>
<p><img src="/images/loading.gif" data-original="../images/development/c12939abf9d9ac4a9184b4a47ba4f9e5.png" alt=""></p>
<ul>
<li><code>editor.lineHighlightBackground</code>: 光标所在行高亮内容的背景颜色</li>
<li><code>editor.lineHighlightBorder</code>: 光标所在行四周边框的背景颜色</li>
</ul>
<p>链接被点击时的颜色:</p>
<p><img src="/images/loading.gif" data-original="../images/development/4ea7b00b5dda16a94b213b1e47527ffd.png" alt=""></p>
<ul>
<li><code>editorLink.activeForeground</code>: 激活的链接的前景色</li>
</ul>
<p>选择搜索结果时的范围高亮:</p>
<p><img src="/images/loading.gif" data-original="../images/development/33a96fda8e087d5a5d0a91889960fab8.png" alt=""></p>
<ul>
<li><code>editor.rangeHighlightBackground</code>: 限制搜索范围的颜色，用于快速打开、文件中的符号、搜索结果。颜色需带有透明度，以免遮挡底层样式</li>
<li><code>editor.rangeHighlightBorder</code>: 限制搜索的范围的边框颜色</li>
</ul>
<p>要查看编辑器在空白字符上显示符号的方式，启用(enable)<strong>Toggle Render Whitespace</strong>配置项。</p>
<ul>
<li><code>editorWhitespace.foreground</code>: 编辑器中空白字符的前景色</li>
</ul>
<p>使用<code>"editor.renderIndentGuides: true"</code>配置编辑器显示缩进参考线</p>
<ul>
<li><code>editorIndentGuide.background</code>: 编辑器缩进参考线的颜色</li>
<li><code>editorIndentGuide.activeBackground</code>: 编辑器活动缩进参考线的颜色</li>
</ul>
<p>使用<code>"editor.rulers"</code>来配置编辑器标尺</p>
<ul>
<li><code>editorRuler.foreground</code>: 编辑器标尺的前景色</li>
</ul>
<p>CodeLens:</p>
<p><img src="/images/loading.gif" data-original="../images/development/715ae4b294b9216a52641f65ecbbd915.png" alt=""></p>
<ul>
<li><code>editorCodeLens.foreground</code>: 编辑器 CodeLens 的前景色</li>
</ul>
<p>括号匹配:</p>
<p><img src="/images/loading.gif" data-original="../images/development/1e7560dbcfa74701073598b2d1a2db5c.png" alt=""></p>
<ul>
<li><code>editorBracketMatch.background</code>: 匹配括号的背景色</li>
<li><code>editorBracketMatch.border</code>: 匹配括号外框的颜色</li>
</ul>
<p>缩略图标尺:</p>
<p>位于编辑器右边缘滚动条下方，可以概览整个编辑器。</p>
<ul>
<li><code>editorOverviewRuler.border</code>: 缩略图标尺边框的颜色</li>
<li><code>editorOverviewRuler.findMatchForeground</code>: 用于查找匹配项的概述标尺标记颜色，颜色需带有透明度，以免遮挡底层样式</li>
<li><code>editorOverviewRuler.rangeHighlightForeground</code>: 用于突出显示范围的概述标尺标记颜色，比如快速打开、文件中的符号、查找功能。颜色需带有透明度，以免遮挡底层样式</li>
<li><code>editorOverviewRuler.selectionHighlightForeground</code>: 用于突出显示所选内容的概述标尺标记颜色。颜色需带有透明度，以免遮挡底层样式</li>
<li><code>editorOverviewRuler.wordHighlightForeground</code>: 用于突出显示符号的概述标尺标记颜色。颜色需带有透明度，以免遮挡底层样式</li>
<li><code>editorOverviewRuler.wordHighlightStrongForeground</code>: 用于突出显示写权限符号的概述标尺标记颜色。颜色需带有透明度，以免遮挡底层样式</li>
<li><code>editorOverviewRuler.modifiedForeground</code>: 缩略图标尺中已修改内容的颜色</li>
<li><code>editorOverviewRuler.addedForeground</code>: 缩略图标尺中已增加内容的颜色</li>
<li><code>editorOverviewRuler.deletedForeground</code>: 缩略图标尺中已删除内容的颜色</li>
<li><code>editorOverviewRuler.errorForeground</code>: 缩略图标尺中错误内容的颜色</li>
<li><code>editorOverviewRuler.warningForeground</code>: 缩略图标尺中警告信息的颜色</li>
<li><code>editorOverviewRuler.infoForeground</code>: 缩略图标尺中信息的颜色</li>
<li><code>editorOverviewRuler.bracketMatchForeground</code>: 缩略图标尺上表示匹配括号的标记颜色</li>
</ul>
<p>错误和警告:</p>
<ul>
<li><code>editorError.foreground</code>: 错误信息的整体前景色。此颜色仅在不被组件覆盖时适用</li>
<li><code>editorError.border</code>: 编辑器中错误波浪线的边框颜色</li>
<li><code>editorWarning.foreground</code>: 编辑器中警告波浪线的前景色</li>
<li><code>editorWarning.border</code>: 编辑器中警告波浪线的边框颜色</li>
<li><code>editorInfo.foreground</code>: 编辑器中信息波浪线的前景色</li>
<li><code>editorInfo.border</code>: 编辑器中信息波浪线的边框颜色</li>
<li><code>editorHint.foreground</code>: 编辑器中提示波浪线的前景色</li>
<li><code>editorHint.border</code>: 编辑器中提示波浪线的边框颜色</li>
</ul>
<p>未使用的源代码:</p>
<ul>
<li><code>editorUnnecessaryCode.border</code>: 编辑器中不必要(未使用)的源代码的边框颜色</li>
<li><code>editorUnnecessaryCode.opacity</code>: 不必要（未使用）代码的在编辑器中显示的不透明度。例如，<code>"#000000c0"</code> 将以 75% 的不透明度显示代码。对于高对比度主题，请使用 <code>"editorUnnecessaryCode.border"</code> 主题来为非必须代码添加下划线，以避免颜色淡化</li>
</ul>
<p>导航线包括字符边距和行号:</p>
<ul>
<li><code>editorGutter.background</code>: 编辑器导航线的背景色，导航线包括字符边距和行号</li>
<li><code>editorGutter.modifiedBackground</code>: 编辑器导航线中被修改行的背景颜色</li>
<li><code>editorGutter.addedBackground</code>: 编辑器导航线中已插入行的背景颜色</li>
<li><code>editorGutter.deletedBackground</code>: 编辑器导航线中被删除行的背景颜色</li>
</ul>
<h3 id="差异编辑器色彩"><a href="#差异编辑器色彩" class="headerlink" title="差异编辑器色彩"></a>差异编辑器色彩</h3><hr>
<p>已插入或者移除的文字的颜色，使用背景色或者边框色(两者选其一)</p>
<ul>
<li><code>diffEditor.insertedTextBackground</code>: 已插入的文本的背景色。颜色需带有透明度，以免遮挡底层样式</li>
<li><code>diffEditor.insertedTextBorder</code>: 插入的文本的轮廓颜色</li>
<li><code>diffEditor.removedTextBackground</code>: 已删除的文本的背景色。颜色需带有透明度，以免遮挡底层样式</li>
<li><code>diffEditor.removedTextBorder</code>: 被删除文本的轮廓颜色</li>
<li><code>diffEditor.border</code>: 两个文本编辑器之间的边框颜色</li>
</ul>
<h3 id="编辑器小部件色彩"><a href="#编辑器小部件色彩" class="headerlink" title="编辑器小部件色彩"></a>编辑器小部件色彩</h3><hr>
<p>编辑器组件在其内容的前面。例如(查找/替换)对话框、建议组件、编辑器悬浮提示框</p>
<ul>
<li><code>editorWidget.background</code>: 编辑器组件(如查找/替换)背景颜色</li>
<li><code>editorWidget.border</code>: 编辑器小部件的边框颜色。此颜色仅在小部件有边框且不被小部件重写时适用</li>
<li><code>editorWidget.resizeBorder</code>: 编辑器小部件大小调整条的边框颜色。此颜色仅在小部件有调整边框且不被小部件颜色覆盖时使用</li>
<li><code>editorSuggestWidget.background</code>: 代码提示浮层的背景色</li>
<li><code>editorSuggestWidget.border</code>: 代码提示浮层的边框颜色</li>
<li><code>editorSuggestWidget.foreground</code>: 代码提示浮层的前景色</li>
<li><code>editorSuggestWidget.highlightForeground</code>: 代码提示浮层中匹配内容的高亮颜色</li>
<li><code>editorSuggestWidget.selectedBackground</code>: 代码提示浮层中所选条目的背景色</li>
<li><code>editorHoverWidget.background</code>: 代码提示浮层背景颜色</li>
<li><code>editorHoverWidget.border</code>: 代码提示浮层边框颜色</li>
</ul>
<p>异常小组件是一个速览窗口，当调试抛出异常时出现</p>
<ul>
<li><code>debugExceptionWidget.background</code>: 异常小组件背景颜色</li>
<li><code>debugExceptionWidget.border</code>: 异常小组件边框颜色</li>
</ul>
<p>编辑器标记，当导航至编辑器中的错误和警告时出现(<strong>跳到下一个错误或警告</strong>命令)</p>
<ul>
<li><code>editorMarkerNavigation.background</code>: 编辑器标记导航小组件背景色</li>
<li><code>editorMarkerNavigationError.background</code>: 编辑器标记导航小组件错误颜色</li>
<li><code>editorMarkerNavigationWarning.background</code>: 编辑器标记导航小组件警告颜色</li>
<li><code>editorMarkerNavigationInfo.background</code>: 编辑器标记导航小组件信息颜色</li>
</ul>
<h3 id="速览窗口色彩"><a href="#速览窗口色彩" class="headerlink" title="速览窗口色彩"></a>速览窗口色彩</h3><hr>
<p>速览窗口在编辑器内部，将引用和声明显示为视图</p>
<p><img src="/images/loading.gif" data-original="../images/development/d7ea276dce547c94be5aa9eab9fc2c16.png" alt=""></p>
<ul>
<li><code>peekView.border</code>: 速览视图边框和箭头颜色</li>
<li><code>peekViewEditor.background</code>: 速览视图编辑器背景色</li>
<li><code>peekViewEditorGutter.background</code>: 速览视图编辑器中装订线的背景色</li>
<li><code>peekViewEditor.matchHighlightBackground</code>: 在速览视图编辑器中匹配突出显示颜色</li>
<li><code>peekViewEditor.matchHighlightBorder</code>: 在速览视图编辑器中匹配项的突出显示边框</li>
<li><code>peekViewResult.background</code>: 速览视图结果列表背景色</li>
<li><code>peekViewResult.fileForeground</code>: 速览视图结果列表中文件节点的前景色</li>
<li><code>peekViewResult.lineForeground</code>: 速览视图结果列表中行节点的前景色</li>
<li><code>peekViewResult.matchHighlightBackground</code>: 在速览视图结果列表中匹配突出显示颜色</li>
<li><code>peekViewResult.selectionBackground</code>: 速览视图结果列表中所选条目的背景色</li>
<li><code>peekViewResult.selectionForeground</code>: 速览视图结果列表中所选条目的前景色</li>
<li><code>peekViewTitle.background</code>: 速览视图标题区域背景颜色</li>
<li><code>peekViewTitleDescription.foreground</code>: 速览视图标题信息颜色</li>
<li><code>peekViewTitleLabel.foreground</code>: 速览视图标题颜色</li>
</ul>
<h3 id="合并冲突"><a href="#合并冲突" class="headerlink" title="合并冲突"></a>合并冲突</h3><hr>
<p>合并冲突装饰，当编辑器包含范围差异时显示</p>
<p><img src="/images/loading.gif" data-original="../images/development/2a60dc941d0a65adb22bcb01eeceb5ff.png" alt=""></p>
<ul>
<li><code>merge.currentHeaderBackground</code>: 当前标题的背景颜色。颜色需带有透明度，以免遮挡底层样式</li>
<li><code>merge.currentContentBackground</code>: 当前内容背景色。颜色需带有透明度，以免遮挡底层样式</li>
<li><code>merge.incomingHeaderBackground</code>: 传入标题背景色。颜色需带有透明度，以免遮挡底层样式</li>
<li><code>merge.incomingContentBackground</code>: 传入内容背景色。颜色需带有透明度，以免遮挡底层样式</li>
<li><code>merge.border</code>: 标头和分割线的边框颜色</li>
<li><code>merge.commonContentBackground</code>: 共同祖先的内容背景色。颜色需带有透明度，以免遮挡底层样式</li>
<li><code>merge.commonHeaderBackground</code>: 共同祖先的标头背景色，颜色需带有透明度，以免遮挡底层样式</li>
<li><code>editorOverviewRuler.currentContentForeground</code>: 当前版本区域的缩略图标尺前景色</li>
<li><code>editorOverviewRuler.incomingContentForeground</code>: 传入的版本区域的缩略图标尺前景色</li>
<li><code>editorOverviewRuler.commonContentForeground</code>: 共同祖先内容的缩略图标尺前景色</li>
</ul>
<h3 id="面板色彩"><a href="#面板色彩" class="headerlink" title="面板色彩"></a>面板色彩</h3><hr>
<p>面板显示在编辑器区域下方，包含输出和集成终端等视图</p>
<ul>
<li><code>panel.background</code>: 面板的背景色</li>
<li><code>panel.border</code>: 将面板与编辑器隔开的边框的颜色</li>
<li><code>panel.dropBackground</code>: 拖放面板标题项时的视觉反馈颜色，此颜色应有透明度，以免遮挡面板项</li>
<li><code>panelTitle.activeBorder</code>: 活动面板标题的边框颜色</li>
<li><code>panelTitle.activeForeground</code>: 活动面板的标题颜色</li>
<li><code>panelTitle.inactiveForeground</code>: 非活动面板的标题颜色</li>
</ul>
<h3 id="状态栏色彩"><a href="#状态栏色彩" class="headerlink" title="状态栏色彩"></a>状态栏色彩</h3><hr>
<p>状态栏显示在工作区底部</p>
<ul>
<li><code>statusBar.background</code>: 普通状态下，状态栏的背景色</li>
<li><code>statusBar.foreground</code>: 普通状态下，状态栏的前景色</li>
<li><code>statusBar.border</code>: 状态栏和编辑器间的分隔线颜色</li>
<li><code>statusBar.debuggingBackground</code>: 调试程序时状态栏的背景色</li>
<li><code>statusBar.debuggingForeground</code>: 调试程序时状态栏的前景色</li>
<li><code>statusBar.debuggingBorder</code>: 调试程序时，状态栏和编辑器的分隔线颜色</li>
<li><code>statusBar.noFolderForeground</code>: 没有打开文件夹时状态栏的前景色</li>
<li><code>statusBar.noFolderBackground</code>: 没有打开文件夹时状态栏的背景色</li>
<li><code>statusBar.noFolderBorder</code>: 没有打开文件夹时，状态栏和编辑器间的分隔线颜色</li>
<li><code>statusBarItem.activeBackground</code>: 单击时的状态栏项背景色</li>
<li><code>statusBarItem.hoverBackground</code>: 悬停时状态栏项背景色</li>
<li><code>statusBarItem.prominentBackground</code>: 状态栏突出显示项的背景颜色，突出显示项比状态栏中的其他条目更醒目以表明其重要性，在命令面板中更改<code>切换 Tab 键是否移动焦点</code>可查看示例</li>
<li><code>statusBarItem.prominentHoverBackground</code>: 鼠标悬停过程中状态栏突出显示项的背景颜色，突出显示项比状态栏中的其他条目更醒目以表明其重要性。在命令面板中更改<code>切换 Tab 键是否移动焦点</code>可查看示例</li>
</ul>
<h3 id="标题栏色彩"><a href="#标题栏色彩" class="headerlink" title="标题栏色彩"></a>标题栏色彩</h3><hr>
<ul>
<li><code>titleBar.activeBackground</code>: 窗口处于活动状态时的标题栏背景色</li>
<li><code>titleBar.activeForeground</code>: 窗口处于活动状态时的标题栏前景色</li>
<li><code>titleBar.inactiveBackground</code>: 窗口处于非活动状态时的标题栏背景色</li>
<li><code>titleBar.inactiveForeground</code>: 窗口处于非活动状态时的标题栏前景色</li>
<li><code>titleBar.border</code>: 标题栏边框颜色</li>
</ul>
<h3 id="菜单栏色彩"><a href="#菜单栏色彩" class="headerlink" title="菜单栏色彩"></a>菜单栏色彩</h3><hr>
<ul>
<li><code>menubar.selectionForeground</code>: 菜单栏中选定菜单项的前景色</li>
<li><code>menubar.selectionBackground</code>: 菜单栏中选定菜单项的背景色</li>
<li><code>menubar.selectionBorder</code>: 菜单栏中所选菜单项的边框颜色</li>
<li><code>menu.foreground</code>: 菜单项的前景颜色</li>
<li><code>menu.background</code>: 菜单项的背景颜色</li>
<li><code>menu.selectionForeground</code>: 菜单中选定菜单项的前景色</li>
<li><code>menu.selectionBackground</code>: 菜单中所选菜单项的背景色</li>
<li><code>menu.selectionBorder</code>: 菜单中所选菜单项的边框颜色</li>
<li><code>menu.separatorBackground</code>: 菜单中分隔线的颜色</li>
</ul>
<h3 id="通知框色彩"><a href="#通知框色彩" class="headerlink" title="通知框色彩"></a>通知框色彩</h3><hr>
<p>!&gt; <strong>注意</strong>: 下列的色彩只适用于VS Code-1.21或更高版本</p>
<p>通知横幅从窗口右下角弹出</p>
<p><img src="/images/loading.gif" data-original="../images/development/d7adef69b40402edaf03254e4b11ed81.png" alt=""></p>
<p>通知中心以带标题的列表显示</p>
<p><img src="/images/loading.gif" data-original="../images/development/14d3f17bde96f0efa99d430a439eee2d.png" alt=""></p>
<ul>
<li><code>notificationCenter.border</code>: 通知中心的边框颜色</li>
<li><code>notificationCenterHeader.foreground</code>: 通知中心头部的前景色</li>
<li><code>notificationCenterHeader.background</code>: 通知中心头部的背景色</li>
<li><code>notificationToast.border</code>: 通知横幅的边框颜色</li>
<li><code>notifications.foreground</code>: 通知的前景色</li>
<li><code>notifications.background</code>: 通知的背景色</li>
<li><code>notifications.border</code>: 通知中心中分隔通知的边框的颜色</li>
<li><code>notificationLink.foreground</code>: 通知链接的前景色</li>
</ul>
<p>如果你使用的VS Code版本低于1.21(2018-2)，可以使用旧的色彩(不再支持):</p>
<ul>
<li><code>notification.background</code></li>
<li><code>notification.foreground</code></li>
<li><code>notification.buttonBackground</code></li>
<li><code>notification.buttonForeground</code></li>
<li><code>notification.buttonHoverBackground</code></li>
<li><code>notification.errorBackground</code></li>
<li><code>notification.errorForeground</code></li>
<li><code>notification.infoBackground</code></li>
<li><code>notification.infoForeground</code></li>
<li><code>notification.warningBackground</code></li>
<li><code>notification.warningForeground</code></li>
</ul>
<h3 id="插件栏"><a href="#插件栏" class="headerlink" title="插件栏"></a>插件栏</h3><hr>
<ul>
<li><code>extensionButton.prominentForeground</code>: 扩展中突出操作的按钮前景色(比如 <strong>安装</strong>按钮)</li>
<li><code>extensionButton.prominentBackground</code>: 扩展中突出操作的按钮背景色</li>
<li><code>extensionButton.prominentHoverBackground</code>: 鼠标悬停时插件中突出操作的按钮的颜色</li>
</ul>
<h3 id="快速选取器"><a href="#快速选取器" class="headerlink" title="快速选取器"></a>快速选取器</h3><hr>
<ul>
<li><code>pickerGroup.border</code>: 快速选取(快速打开)器分组边框的颜色</li>
<li><code>pickerGroup.foreground</code>: 快速选取(快速打开)器分组标签的颜色</li>
</ul>
<h3 id="集成终端色彩"><a href="#集成终端色彩" class="headerlink" title="集成终端色彩"></a>集成终端色彩</h3><hr>
<ul>
<li><code>terminal.background</code>: 终端视口的背景颜色</li>
<li><code>terminal.border</code>: 分隔终端中拆分窗格的边框的颜色。默认为 panel.border 的颜色</li>
<li><code>terminal.foreground</code>: 集成终端的默认前景色</li>
<li><code>terminal.ansiBlack</code>: 终端中的’Black’ANSI</li>
<li><code>terminal.ansiBlue</code>: 终端中的’Blue’ANSI</li>
<li><code>terminal.ansiBrightBlack</code>: 终端中的’BrightBlack’ANSI</li>
<li><code>terminal.ansiBrightBlue</code>: 终端中的’BrightBlue’ANSI</li>
<li><code>terminal.ansiBrightCyan</code>: 终端中的’BrightCyan’ANSI</li>
<li><code>terminal.ansiBrightGreen</code>: 终端中的’BrightGreen’ANSI</li>
<li><code>terminal.ansiBrightMagenta</code>: 终端中的’BrightMagenta’ANSI</li>
<li><code>terminal.ansiBrightRed</code>: 终端中的’BrightRed’ANSI</li>
<li><code>terminal.ansiBrightWhite</code>: 终端中的’BrightWhite’ANSI</li>
<li><code>terminal.ansiBrightYellow</code>: 终端中的’BrightYellow’ANSI</li>
<li><code>terminal.ansiCyan</code>: 终端中的’Cyan’ANSI</li>
<li><code>terminal.ansiGreen</code>: 终端中的’Green’ANSI</li>
<li><code>terminal.ansiMagenta</code>: 终端中的’Magenta’ANSI</li>
<li><code>terminal.ansiRed</code>: 终端中的’Red’ANSI</li>
<li><code>terminal.ansiWhite</code>: 终端中的’White’ANSI</li>
<li><code>terminal.ansiYellow</code>: 终端中的’Yellow’ANSI</li>
<li><code>terminal.selectionBackground</code>: 终端中选中内容的背景色</li>
<li><code>terminalCursor.background</code>: 终端光标的背景色。允许自定义被 block 光标遮住的字符的颜色</li>
<li><code>terminalCursor.foreground</code>: 终端光标的前景色</li>
</ul>
<h3 id="调试-1"><a href="#调试-1" class="headerlink" title="调试"></a>调试</h3><hr>
<ul>
<li><code>debugToolBar.background</code>: 调试工具栏背景颜色</li>
<li><code>debugToolBar.border</code>: 调试工具栏边框颜色</li>
<li><code>editor.stackFrameHighlightBackground</code>: 堆栈帧中顶部一行的高亮背景色</li>
<li><code>editor.focusedStackFrameHighlightBackground</code>: 堆栈帧中焦点一行的高亮背景色</li>
</ul>
<h3 id="欢迎界面"><a href="#欢迎界面" class="headerlink" title="欢迎界面"></a>欢迎界面</h3><hr>
<ul>
<li><code>welcomePage.background</code>: 欢迎页面的背景色</li>
<li><code>welcomePage.buttonBackground</code>: 欢迎页按钮的背景色</li>
<li><code>welcomePage.buttonHoverBackground</code>: 鼠标悬停时欢迎页按钮的背景色</li>
<li><code>walkThrough.embeddedEditorBackground</code>: 嵌入于交互式操场中的编辑器的背景颜色</li>
</ul>
<h3 id="Git色彩"><a href="#Git色彩" class="headerlink" title="Git色彩"></a>Git色彩</h3><hr>
<ul>
<li><code>gitDecoration.addedResourceForeground</code>: 新增的Git资源的前景色。用于显示文件标签和源代码管理</li>
<li><code>gitDecoration.modifiedResourceForeground</code>: 修改过的Git资源的前景色。用于显示文件标签和源代码管理</li>
<li><code>gitDecoration.deletedResourceForeground</code>: 移除过的Git资源的前景色。用于显示文件标签和源代码管理</li>
<li><code>gitDecoration.untrackedResourceForeground</code>: 未跟踪的Git资源的前景色。用于文件标签和源代码管理</li>
<li><code>gitDecoration.ignoredResourceForeground</code>: 已忽视的Git资源的前景色。用于文件标签和源代码管理</li>
<li><code>gitDecoration.conflictingResourceForeground</code>: 冲突的Git资源的前景色。用于文件标签和源代码管理</li>
<li><code>gitDecoration.submoduleResourceForeground</code>: 子模块资源的前景色</li>
</ul>
<h3 id="设置编辑器色彩"><a href="#设置编辑器色彩" class="headerlink" title="设置编辑器色彩"></a>设置编辑器色彩</h3><hr>
<p>!&gt; <strong>注意</strong>: 下列色彩配置只适用于<strong>设置</strong>编辑器界面，可以通过<code>首选项: 打开设置(UI)</code>命令打开。</p>
<ul>
<li><code>settings.headerForeground</code>: 小节标题与活动标题的前景色</li>
<li><code>settings.modifiedItemIndicator</code>: 已修改设置指示器的颜色</li>
<li><code>settings.dropdownBackground</code>: 下拉列表的背景色</li>
<li><code>settings.dropdownForeground</code>: 下拉列表的前景色</li>
<li><code>settings.dropdownBorder</code>: 下拉列表的边框颜色</li>
<li><code>settings.dropdownListBorder</code>: 下拉列表选项的边框颜色</li>
<li><code>settings.checkboxBackground</code>: 复选框的背景色</li>
<li><code>settings.checkboxForeground</code>: 复选框的前景色</li>
<li><code>settings.checkboxBorder</code>: 复选框的边框颜色</li>
<li><code>settings.textInputBackground</code>: 文本输入框的背景色</li>
<li><code>settings.textInputForeground</code>: 文本输入框的前景色</li>
<li><code>settings.textInputBorder</code>: 文本输入框的边框颜色</li>
<li><code>settings.numberInputBackground</code>: 数字输入框的背景色</li>
<li><code>settings.numberInputForeground</code>: 数字输入框的前景色</li>
<li><code>settings.numberInputBorder</code>: 数字输入框的边框颜色</li>
</ul>
<h3 id="面包屑导航"><a href="#面包屑导航" class="headerlink" title="面包屑导航"></a>面包屑导航</h3><hr>
<p>面包屑导航的色彩主题:</p>
<ul>
<li><code>breadcrumb.foreground</code>: 导航路径的前景色</li>
<li><code>breadcrumb.background</code>: 导航路径项的背景色</li>
<li><code>breadcrumb.focusForeground</code>: 焦点导航路径的颜色</li>
<li><code>breadcrumb.activeSelectionForeground</code>: 已选导航路径项的颜色</li>
<li><code>breadcrumbPicker.background</code>: 导航路径项选择器的背景色</li>
</ul>
<h3 id="代码片段-1"><a href="#代码片段-1" class="headerlink" title="代码片段"></a>代码片段</h3><hr>
<p>代码片段的色彩主题:</p>
<ul>
<li><code>editor.snippetTabstopHighlightBackground</code>: 代码片段 Tab 位的高亮背景色</li>
<li><code>editor.snippetTabstopHighlightBorder</code>: 代码片段 Tab 位的高亮边框颜色</li>
<li><code>editor.snippetFinalTabstopHighlightBackground</code>: 代码片段中最后的 Tab 位的高亮背景色</li>
<li><code>editor.snippetFinalTabstopHighlightBorder</code>: 代码片段中最后的 Tab 位的高亮边框颜色</li>
</ul>
<p>也可以根据发布内容的颜色配置项，使用插件来发布色彩id(Ids)。当在<code>workbench.colorCustomizations</code>配置项中使用代码补全或者编辑色彩主题文件时，这些色彩也会出现。用户可以在<a href="https://code.visualstudio.com/docs/editor/extension-gallery#_extension-details" target="_blank" rel="noopener">插件发布</a>选项卡中看到插件定义的色彩。</p>
<h3 id="配置插件中的色彩"><a href="#配置插件中的色彩" class="headerlink" title="配置插件中的色彩"></a>配置插件中的色彩</h3><hr>
<p>也可以根据发布内容的颜色配置项，使用插件来发布色彩id。当在<code>workbench.colorCustomizations</code>当编辑<code>workbench.colorCustomizations</code>和主题颜色文件时，这些色彩会出现在代码补全中。用户可以在<a href="https://code.visualstudio.com/docs/editor/extension-gallery#_extension-details" target="_blank" rel="noopener">插件发布</a>选项卡中看到插件定义的色彩。</p>
<h2 id="标签中的图标"><a href="#标签中的图标" class="headerlink" title="标签中的图标"></a>标签中的图标</h2><p>你可以在插件中使用github提供的开源图标<a href="https://octicons.github.com/" target="_blank" rel="noopener">Octicons</a>，你甚至可以在<a href="https://code.visualstudio.com/api/references/vscode-api#StatusBarItem" target="_blank" rel="noopener"><code>StatusBarItem</code></a>文本和<a href="https://code.visualstudio.com/api/references/vscode-api#QuickPickItem" target="_blank" rel="noopener"><code>QuickPickItem</code></a>标签中使用。添加图标的语法如下：</p>
<pre><code>$(alert);</code></pre><p>你还可以像这样使用多个标签</p>
<pre><code>$(eye) $(heart) $(mark-github) GitHub</code></pre><h4 id="图标列表"><a href="#图标列表" class="headerlink" title="图标列表"></a>图标列表</h4><p><strong>图标列表</strong>请参考<a href="https://code.visualstudio.com/api/references/icons-in-labels" target="_blank" rel="noopener">官方文档</a></p>
<h2 id="文档选择器"><a href="#文档选择器" class="headerlink" title="文档选择器"></a>文档选择器</h2><p>插件的特性可以通过语言、类型、位置等文档选择器类型加以筛选，本节将深入文档选择器、文档协议等插件创作者应该了解的内容。</p>
<h3 id="不在磁盘上的文件"><a href="#不在磁盘上的文件" class="headerlink" title="不在磁盘上的文件"></a>不在磁盘上的文件</h3><hr>
<p>并不是所有文件都是储存在磁盘上的，比如一份刚刚创建的文件。除非特别指明，文档选择器通常会应用于<strong>所有</strong>文档类型。使用<a href="https://code.visualstudio.com/api/references/vscode-api#DocumentFilter" target="_blank" rel="noopener">DocumentFilter</a>的<code>scheme</code>属性将协议范围缩小，比如说，<code>{ scheme: 'file', language: 'typescript' }</code>是特定的用于储存在磁盘上的TypeScript文件。</p>
<h3 id="文档选择器-1"><a href="#文档选择器-1" class="headerlink" title="文档选择器"></a>文档选择器</h3><hr>
<p>VS Code插件API结合了特定的语言特性, 通过文档选择器的<a href="https://code.visualstudio.com/api/references/vscode-api#DocumentSelector" target="_blank" rel="noopener">DocumentSelector</a>类型, 可以支持例如智能感知(IntelliSense)等特性. 这是实现特定语言所支持特性的最为简单的机制.</p>
<p>下面的片段注册了一个Typescript文件的<a href="https://code.visualstudio.com/api/references/vscode-api#HoverProvider" target="_blank" rel="noopener">HoverProvider</a>, 此时的文档选择器是<code>typescript</code>语言标识符.</p>
<pre><code>vscode.languages.registerHoverProvider('typescript', {
  provideHover(doc: vscode.TextDocument) {
    return new vscode.Hover('For *all* TypeScript documents.');
  }
});</code></pre><p>文档选择器可以不只是一个语言标识符, 还可以是复杂选择器——比如基于<code>协议(scheme)</code>和文件路径的<a href="https://code.visualstudio.com/api/references/vscode-api#DocumentFilter" target="_blank" rel="noopener">DocumentFilter</a>, 文件路径支持<code>pattern</code>参数和glob模式:</p>
<pre><code>vscode.languages.registerHoverProvider(
  { pattern: '**/test/**' },
  {
    provideHover(doc: vscode.TextDocument) {
      return new vscode.Hover('For documents inside `test`-folders only');
    }
  }
);</code></pre><p>下面这个片段, 使用合并后的<code>协议(scheme)</code>过滤器和语言标识符作为参数. <code>未命名的(untitled)</code>协议正是为暂未保存到本地磁盘的文件准备的.</p>
<pre><code>vscode.languages.registerHoverProvider(
  { scheme: 'untitled', language: 'typescript' },
  {
    provideHover(doc: vscode.TextDocument) {
      return new vscode.Hover('For new, unsaved TypeScript documents only');
    }
  }
);</code></pre><h3 id="文档协议"><a href="#文档协议" class="headerlink" title="文档协议"></a>文档协议</h3><hr>
<p><code>文档协议</code>经常会被忽视, 但是它提供了很重要的信息. 插件开发者经常假设自己正在处理的文档也是存在磁盘上的. 用一个简单的<code>typescript</code>选择器做个例子, 假设<strong>Typescript文件在磁盘上</strong>, 不过大部分开发场景都过于宽松了，使用了诸如<code>{ scheme: 'file', language: 'typescript' }</code>显式的选择器。</p>
<p>当某项功能依赖于从磁盘上读/写文件时, 这个问题显得尤为重要. 请看下面的代码:</p>
<pre><code>// 👎 too lax
vscode.languages.registerHoverProvider('typescript', {
  provideHover(doc: vscode.TextDocument) {
    const { size } = fs.statSync(doc.uri.fsPath); // ⚠️ what about 'untitled:/Untitled1.ts' or others?
    return new vscode.Hover(`Size in bytes is ${size}`);
  }
});</code></pre><p>上面的例子中, 悬浮提示器想展示文件占用的磁盘大小, 但是它不会检查文档是不是真的存储在磁盘上. 比如, 一个新创建但是未保存的文件. 正确的做法是告诉VS Code只在文件存储在磁盘上时才开始工作.</p>
<pre><code>// 👍 only works with files on disk
vscode.languages.registerHoverProvider(
  { scheme: 'file', language: 'typescript' },
  {
    provideHover(doc: vscode.TextDocument) {
      const { size } = fs.statSync(doc.uri.fsPath);
      return new vscode.Hover(`Size in bytes is ${size}`);
    }
  }
);</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><hr>
<p>文档通常都储存在文件系统中，但也有例外：未保存的新文件、Git使用的缓存文件、FTP上的远程文件等等。如果你的插件特性依赖于磁盘读取，那么你就要用文档选择器时应带上file协议。</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://jackhcc.github.io" rel="external nofollow noreferrer">杰克成</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://jackhcc.github.io/posts/vscode.html">https://jackhcc.github.io/posts/vscode.html</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="https://jackhcc.github.io" target="_blank">杰克成</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/Vscode/">
                                    <span class="chip bg-color">Vscode</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/share/css/share.min.css">

<div id="article-share">
    
    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/medias/reward/aliqr.png" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/medias/reward/wxqr.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>
            
        </div>
    </div>

    
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/gitalk/gitalk.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/css/my-gitalk.css">

<div class="card gitalk-card" data-aos="fade-up">
    <div class="comment_headling" style="font-size: 20px; font-weight: 700; position: relative; left: 20px; top: 15px; padding-bottom: 5px;">
        <i class="fas fa-comments fa-fw" aria-hidden="true"></i>
        <span>评论</span>
    </div>
    <div id="gitalk-container" class="card-content"></div>
</div>

<script src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/gitalk/gitalk.min.js"></script>
<script>
    let gitalk = new Gitalk({
        clientID: '3821a0bbb773038a51fc',
        clientSecret: '4b30b507d67ec5497ec0e77f43f80cb3e0d7dd3a',
        repo: 'JackHCC.github.io',
        owner: 'JackHCC',
        admin: "JackHCC",
        id: '2021-09-11T22-47-08',
        distractionFreeMode: false  // Facebook-like distraction free mode
    });

    gitalk.render('gitalk-container');
</script>
    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/posts/design-pattern.html">
                    <div class="card-image">
                        
                        
                        <img src="/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/medias/featureimages/5.jpg" class="responsive-img" alt="Design Pattern详解">
                        
                        <span class="card-title">Design Pattern详解</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            设计模式学习记录
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2021-09-13
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/Development/" class="post-category">
                                    Development
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Design-Pattern/">
                        <span class="chip bg-color">Design Pattern</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/posts/ml-algorithm.html">
                    <div class="card-image">
                        
                        
                        <img src="/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/medias/featureimages/2.jpg" class="responsive-img" alt="Machine Learning Algorithm">
                        
                        <span class="card-title">Machine Learning Algorithm</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            机器学习经典算法
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2021-09-10
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/Algorithm/" class="post-category">
                                    Algorithm
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Machine-Learning/">
                        <span class="chip bg-color">Machine Learning</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/codeBlock/codeShrink.js"></script>


<!-- 代码块折行 -->

<style type="text/css">
code[class*="language-"], pre[class*="language-"] { white-space: pre !important; }
</style>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('4'),
            headingSelector: 'h1, h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h1, h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>



    <footer class="page-footer bg-color">
    <div class="container row center-align" style="margin-bottom: 15px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            <span id="year">2020</span>
            <a href="https://jackhcc.github.io" target="_blank">杰克成</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                class="white-color">3591.2k</span>&nbsp;字
            
            
            
            
            
            
            <span id="busuanzi_container_site_pv">
                |&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv"
                    class="white-color"></span>&nbsp;次
            </span>
            
            
            <span id="busuanzi_container_site_uv">
                |&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv"
                    class="white-color"></span>&nbsp;人
            </span>
            
            <br>
            
            <span id="sitetime">载入运行时间...</span>
            <script>
                function siteTime() {
                    var seconds = 1000;
                    var minutes = seconds * 60;
                    var hours = minutes * 60;
                    var days = hours * 24;
                    var years = days * 365;
                    var today = new Date();
                    var startYear = "2020";
                    var startMonth = "2";
                    var startDate = "27";
                    var startHour = "6";
                    var startMinute = "30";
                    var startSecond = "0";
                    var todayYear = today.getFullYear();
                    var todayMonth = today.getMonth() + 1;
                    var todayDate = today.getDate();
                    var todayHour = today.getHours();
                    var todayMinute = today.getMinutes();
                    var todaySecond = today.getSeconds();
                    var t1 = Date.UTC(startYear, startMonth, startDate, startHour, startMinute, startSecond);
                    var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
                    var diff = t2 - t1;
                    var diffYears = Math.floor(diff / years);
                    var diffDays = Math.floor((diff / days) - diffYears * 365);
                    var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours);
                    var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) /
                        minutes);
                    var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours -
                        diffMinutes * minutes) / seconds);
                    if (startYear == todayYear) {
                        document.getElementById("year").innerHTML = todayYear;
                        document.getElementById("sitetime").innerHTML = "本站已安全运行 " + diffDays + " 天 " + diffHours +
                            " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                    } else {
                        document.getElementById("year").innerHTML = startYear + " - " + todayYear;
                        document.getElementById("sitetime").innerHTML = "本站已安全运行 " + diffYears + " 年 " + diffDays +
                            " 天 " + diffHours + " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                    }
                }
                setInterval(siteTime, 1000);
            </script>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/JackHCC" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:jackcc0701@163.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>



    <a href="https://www.facebook.com/profile.php?id=100046343443643" class="tooltipped" target="_blank" data-tooltip="关注我的Facebook: https://www.facebook.com/profile.php?id=100046343443643" data-position="top" data-delay="50">
        <i class="fab fa-facebook-f"></i>
    </a>



    <a href="https://twitter.com/JackChe66021834" class="tooltipped" target="_blank" data-tooltip="关注我的Twitter: https://twitter.com/JackChe66021834" data-position="top" data-delay="50">
        <i class="fab fa-twitter"></i>
    </a>



    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=2508074836" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 2508074836" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>



    <a href="https://weibo.com/u/6885584679" class="tooltipped" target="_blank" data-tooltip="关注我的微博: https://weibo.com/u/6885584679" data-position="top" data-delay="50">
        <i class="fab fa-weibo"></i>
    </a>



    <a href="https://www.zhihu.com/people/8f8482f01f0d6a04e844efe32e0f0710" class="tooltipped" target="_blank" data-tooltip="关注我的知乎: https://www.zhihu.com/people/8f8482f01f0d6a04e844efe32e0f0710" data-position="top" data-delay="50">
        <i class="fab fa-zhihu1">知</i>
    </a>



</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/js/search.js"></script>
<script type="text/javascript">
$(function () {
    searchFunc("https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/" + "search.xml", 'searchInput', 'searchResult');
});
</script>
    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/materialize/materialize.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/aos/aos.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/js/matery.js"></script>

    <canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" ></canvas>
    <script type="text/javascript" src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script>
    <script type="text/javascript" src="/js/fireworks.js"></script>

    <script type="text/javascript">
        //只在桌面版网页启用特效
        var windowWidth = $(window).width();
        if (windowWidth > 768) {
            document.write('<script type="text/javascript" src="/js/sakura.js"><\/script>'); }
    </script>

    <!-- weather -->
	<script type="text/javascript">
	WIDGET = {FID: 'TToslpmkVO'}
	</script>
	<script type="text/javascript" src="https://apip.weatherdt.com/float/static/js/r.js?v=1111"></script>


    <!-- Global site tag (gtag.js) - Google Analytics -->


    <!-- Baidu Analytics -->

<script>
    var _hmt = _hmt || [];
    (function () {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
    })();
</script>

    <!-- Baidu Push -->

    
    
    <script async src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/others/busuanzi.pure.mini.js"></script>
    

    
        <script src="//code.tidio.co/kqhlkxviiccyoa0czpfpu4ijuey9hfre.js"></script>
        <script> 
            $(document).ready(function () {
                setInterval(change_Tidio, 50);  
                function change_Tidio() { 
                    var tidio=$("#tidio-chat iframe");
                    if(tidio.css("display")=="block"&& $(window).width()>977 ){
                        document.getElementById("tidio-chat-iframe").style.bottom= ($("div#backTop.top-scroll").css("display")=="none" &&$(window).width()>977)>0? "-40px" : ($("div.toc-title").length&&$(window).width()>977)>0?"85px":"20px";   
                        document.getElementById("tidio-chat-iframe").style.right="-15px";   
                        document.getElementById("tidio-chat-iframe").style.height=parseInt(tidio.css("height"))>=520?"520px":tidio.css("height");
                        document.getElementById("tidio-chat-iframe").style.zIndex="997";
                    } 
                    else if(tidio.css("display")=="block"&&$(window).width()>601 &&$(window).width()<992 ){
                        document.getElementById("tidio-chat-iframe").style.bottom= ($("div#backTop.top-scroll").css("display")=="none" && 601< $(window).width()<992)>0? "-40px":"20px" ;   
                        document.getElementById("tidio-chat-iframe").style.right="-15px"; 
                        document.getElementById("tidio-chat-iframe").style.zIndex="997";
                    }
                    else if(tidio.css("display")=="block"&&$(window).width()<601 && parseInt(tidio.css("height"))<230){
                        document.getElementById("tidio-chat-iframe").style.bottom= ($("div#backTop.top-scroll").css("display")=="none" && $(window).width()<601)>0? "-10px":"45px" ;   
                        document.getElementById("tidio-chat-iframe").style.zIndex="997";
                    }
                    if( tidio.css("display")=="block"&&$(window).width()<601 && parseInt(tidio.css("height"))>=230){
                        document.getElementById("tidio-chat-iframe").style.zIndex="998";
                    }
                } 
            }); 
        </script>
    

    

    
    <script type="text/javascript" color="0,0,255"
        pointColor="0,0,255" opacity='0.7'
        zIndex="-1" count="99"
        src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/background/canvas-nest.js"></script>
    

    

    
    <script type="text/javascript" src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/background/ribbon-dynamic.js" async="async"></script>
    
    
    
    <script src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/instantpage/instantpage.js" type="module"></script>
    

        <script src="//cdn.jsdelivr.net/npm/js-base64/base64.min.js"></script>
        <script>
        $('a').each(function() {
          const $this = $(this);
          const href = $this.attr('href');
          if (href && href.match('^((http|https|thunder|qqdl|ed2k|Flashget|qbrowser|ftp|rtsp|mms)://)')) {
            const strs = href.split('/');
            if (strs.length >= 3) {
                const host = strs[2];
                if (host !== 'your_domain' || window.location.host) {
                    $this.attr('href', '/go.html?u='+Base64.encode(href)+'').attr('rel', 'external nofollow noopener noreferrer');
                    if (true) {
                        $this.attr('target', '_blank');
                    }
                }
            }
          }
        });
        </script><script>!function(e){var c=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));function i(){for(var r=0;r<c.length;r++)t=c[r],0<=(n=t.getBoundingClientRect()).bottom&&0<=n.left&&n.top<=(e.innerHeight||document.documentElement.clientHeight)&&function(){var t,n,e,i,o=c[r];t=o,n=function(){c=c.filter(function(t){return o!==t})},e=new Image,i=t.getAttribute("data-original"),e.onload=function(){t.src=i,n&&n()},e.src=i}();var t,n}i(),e.addEventListener("scroll",function(){var t,n;t=i,n=e,clearTimeout(t.tId),t.tId=setTimeout(function(){t.call(n)},500)})}(this);</script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script></body>

</html>

