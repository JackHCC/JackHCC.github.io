<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="Python-Standard Library, JackHCC">
    <meta name="description" content="Python标准库详解【3】">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Python-Standard Library | JackHCC</title>
    <link rel="icon" type="image/png" href="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/medias/favicon.png">

    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/css/matery.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/css/my.css">
    
    <script src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/jquery/jquery.min.js"></script>
    
<meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="JackHCC" type="application/atom+xml">
<link rel="stylesheet" href="/css/prism-hopscotch.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper head-container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/medias/me.jpg" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">JackHCC</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="" class="waves-effect waves-light">

      
      <i class="fas fa-list" style="zoom: 0.6;"></i>
      
      <span>Tools</span>
      <i class="fas fa-chevron-down" aria-hidden="true" style="zoom: 0.6;"></i>
    </a>
    <ul class="sub-nav menus_item_child ">
      
      <li>
        <a href="https://creativecc.cn/" target="_blank" rel="noopener">
          
          <i class="fas fa-book" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>Creative工具导航</span>
        </a>
      </li>
      
      <li>
        <a href="https://blog.creativecc.cn/Arxiv-NLP-Reporter/" target="_blank" rel="noopener">
          
          <i class="fas fa-film" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>NLP每日论文</span>
        </a>
      </li>
      
      <li>
        <a href="http://chat.creativecc.cn/" target="_blank" rel="noopener">
          
          <i class="fas fa-music" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>RocketChat聊天室</span>
        </a>
      </li>
      
      <li>
        <a href="/contact">
          
          <i class="fas fa-comments" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>Contact留言板</span>
        </a>
      </li>
      
    </ul>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>

<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/medias/me.jpg" class="logo-img circle responsive-img">
        
        <div class="logo-name">JackHCC</div>
        <div class="logo-desc">
            
            Make the world betterrrr!!!
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="javascript:;">
			
				<i class="fa-fw fas fa-list"></i>
			
			Tools
			<span class="m-icon"><i class="fas fa-chevron-right"></i></span>
		</a>
            <ul  style="background:  ;" >
              
                <li>   
				
                  <a href="https://creativecc.cn/ " target="_blank" rel="noopener" style="margin-left:75px";>
				  
				   <i class="fa fas fa-book" style="position: absolute;left:50px" ></i>
			      
		          <span>Creative工具导航</span>
                  </a>
                </li>
              
                <li>   
				
                  <a href="https://blog.creativecc.cn/Arxiv-NLP-Reporter/ " target="_blank" rel="noopener" style="margin-left:75px";>
				  
				   <i class="fa fas fa-film" style="position: absolute;left:50px" ></i>
			      
		          <span>NLP每日论文</span>
                  </a>
                </li>
              
                <li>   
				
                  <a href="http://chat.creativecc.cn/ " target="_blank" rel="noopener" style="margin-left:75px";>
				  
				   <i class="fa fas fa-music" style="position: absolute;left:50px" ></i>
			      
		          <span>RocketChat聊天室</span>
                  </a>
                </li>
              
                <li>   
				
                  <a href="/contact " style="margin-left:75px";>
				  
				   <i class="fa fas fa-comments" style="position: absolute;left:50px" ></i>
			      
		          <span>Contact留言板</span>
                  </a>
                </li>
               
            </ul>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/JackHCC/JackHCC.github.io" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>

        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/JackHCC/JackHCC.github.io" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    
<script src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/cryptojs/crypto-js.min.js"></script>
<script>
    (function() {
        let pwd = '';
        if (pwd && pwd.length > 0) {
            if (pwd !== CryptoJS.SHA256(prompt('请输入访问本文章的密码')).toString(CryptoJS.enc.Hex)) {
                alert('密码错误，将返回主页！');
                location.href = '/';
            }
        }
    })();
</script>




<div class="bg-cover pd-header post-cover" style="background-image: url('https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/medias/featureimages/7.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">Python-Standard Library</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        margin: 35px 0 15px 0;
        padding-left: 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        height: calc(100vh - 250px);
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #toc-content .is-active-link::before {
        background-color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 30px;
        bottom: 146px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/Python/">
                                <span class="chip bg-color">Python</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/Python/" class="post-category">
                                Python
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2021-11-09
                </div>
                

                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-check fa-fw"></i>更新日期:&nbsp;&nbsp;
                    2021-11-19
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    174.7k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    718 分
                </div>
                

                
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="far fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>

        </div>
        <hr class="clearfix">
        <div class="card-content article-card-content">
            <div id="articleContent">
                <h1 id="Python-标准库"><a href="#Python-标准库" class="headerlink" title="Python 标准库"></a>Python 标准库</h1><ul>
<li>并发执行<ul>
<li><code>threading</code> —- 基于线程的并行</li>
<li><code>multiprocessing</code> —- 基于进程的并行</li>
<li><code>multiprocessing.shared_memory</code> —- 可从进程直接访问的共享内存</li>
<li><code>concurrent</code> 包</li>
<li><code>concurrent.futures</code> —- 启动并行任务</li>
<li><code>subprocess</code> —- 子进程管理</li>
<li><code>sched</code> —- 事件调度器</li>
<li><code>queue</code> —- 一个同步的队列类</li>
<li><code>contextvars</code> —- 上下文变量</li>
<li><code>_thread</code> —- 底层多线程 API</li>
</ul>
</li>
<li>网络和进程间通信<ul>
<li><code>asyncio</code> —- 异步 I/O</li>
<li><code>socket</code> —- 底层网络接口</li>
<li><code>ssl</code> —- 套接字对象的 TLS/SSL 包装器</li>
<li><code>select</code> —- 等待 I/O 完成</li>
<li><code>selectors</code> —- 高级 I/O 复用库</li>
<li><code>asyncore</code> —- 异步套接字处理器</li>
<li><code>asynchat</code> —- 异步套接字指令/响应处理程序</li>
<li><code>signal</code> —- 设置异步事件处理程序</li>
<li><code>mmap</code> —- 内存映射文件支持</li>
</ul>
</li>
<li>互联网数据处理<ul>
<li><code>email</code> —- 电子邮件与 MIME 处理包</li>
<li><code>json</code> —- JSON 编码和解码器</li>
<li><code>mailcap</code> —- Mailcap 文件处理</li>
<li><code>mailbox</code> —- 操作多种格式的邮箱</li>
<li><code>mimetypes</code> —- 映射文件名到 MIME 类型</li>
<li><code>base64</code> —- Base16, Base32, Base64, Base85 数据编码</li>
<li><code>binhex</code> —- 对binhex4文件进行编码和解码</li>
<li><code>binascii</code> —- 二进制和 ASCII 码互转</li>
<li><code>quopri</code> —- 编码与解码经过 MIME 转码的可打印数据</li>
<li><code>uu</code> —- 对 uuencode 文件进行编码与解码</li>
</ul>
</li>
<li>结构化标记处理工具<ul>
<li><code>html</code> —- 超文本标记语言支持</li>
<li><code>html.parser</code> —- 简单的 HTML 和 XHTML 解析器</li>
<li><code>html.entities</code> —- HTML 一般实体的定义</li>
<li>XML处理模块</li>
<li><code>xml.etree.ElementTree</code> —- ElementTree XML API</li>
<li><code>xml.dom</code> —- 文档对象模型 API</li>
<li><code>xml.dom.minidom</code> —- 最小化的 DOM 实现</li>
<li><code>xml.dom.pulldom</code> —- 支持构建部分 DOM 树</li>
<li><code>xml.sax</code> —- 支持 SAX2 解析器</li>
<li><code>xml.sax.handler</code> —- SAX 处理句柄的基类</li>
<li><code>xml.sax.saxutils</code> —- SAX 工具集</li>
<li><code>xml.sax.xmlreader</code> —- 用于 XML 解析器的接口</li>
<li><code>xml.parsers.expat</code> —- 使用 Expat 的快速 XML 解析</li>
</ul>
</li>
<li>互联网协议和支持<ul>
<li><code>webbrowser</code> —- 方便的 Web 浏览器控制工具</li>
<li><code>cgi</code> —- 通用网关接口支持</li>
<li><code>cgitb</code> —- 用于 CGI 脚本的回溯管理器</li>
<li><code>wsgiref</code> —- WSGI 工具和参考实现</li>
<li><code>urllib</code> —- URL 处理模块</li>
<li><code>urllib.request</code> —- 用于打开 URL 的可扩展库</li>
<li><code>urllib.response</code> —- urllib 使用的 Response 类</li>
<li><code>urllib.parse</code> 用于解析 URL</li>
<li><code>urllib.error</code> —- urllib.request 引发的异常类</li>
<li><code>urllib.robotparser</code> —- robots.txt 语法分析程序</li>
<li><code>http</code> —- HTTP 模块</li>
<li><code>http.client</code> —- HTTP 协议客户端</li>
<li><code>ftplib</code> —- FTP 协议客户端</li>
<li><code>poplib</code> —- POP3 协议客户端</li>
<li><code>imaplib</code> —- IMAP4 协议客户端</li>
<li><code>nntplib</code> —- NNTP protocol client</li>
<li><code>smtplib</code> —-SMTP协议客户端</li>
<li><code>smtpd</code> —- SMTP 服务器</li>
<li><code>telnetlib</code> — Telnet 客户端</li>
<li><code>uuid</code> —- UUID objects according to <strong>RFC 4122</strong></li>
<li><code>socketserver</code> —- A framework for network servers</li>
<li><code>http.server</code> —- HTTP 服务器</li>
<li><code>http.cookies</code> —- HTTP状态管理</li>
<li><code>http.cookiejar</code> —— HTTP 客户端的 Cookie 处理</li>
<li><code>xmlrpc</code> —- XMLRPC 服务端与客户端模块</li>
<li><code>xmlrpc.client</code> —- XML-RPC 客户端访问</li>
<li><code>xmlrpc.server</code> —- 基本 XML-RPC 服务器</li>
<li><code>ipaddress</code> —- IPv4/IPv6 操作库</li>
</ul>
</li>
</ul>
<h1 id="并发执行"><a href="#并发执行" class="headerlink" title="并发执行"></a>并发执行</h1><p>本章中描述的模块支持并发执行代码。 适当的工具选择取决于要执行的任务（CPU密集型或IO密集型）和偏好的开发风格（事件驱动的协作式多任务或抢占式多任务处理）。 这是一个概述：</p>
<ul>
<li><code>threading</code> —- 基于线程的并行<ul>
<li>线程本地数据</li>
<li>线程对象</li>
<li>锁对象</li>
<li>递归锁对象</li>
<li>条件对象</li>
<li>信号量对象<ul>
<li><code>Semaphore</code> 例子</li>
</ul>
</li>
<li>事件对象</li>
<li>定时器对象</li>
<li>栅栏对象</li>
<li>在 <code>with</code> 语句中使用锁、条件和信号量</li>
</ul>
</li>
<li><code>multiprocessing</code> —- 基于进程的并行<ul>
<li>概述<ul>
<li><code>Process</code> 类</li>
<li>上下文和启动方法</li>
<li>在进程之间交换对象</li>
<li>进程间同步</li>
<li>进程间共享状态</li>
<li>使用工作进程</li>
</ul>
</li>
<li>参考<ul>
<li><code>Process</code> 和异常</li>
<li>管道和队列</li>
<li>杂项</li>
<li>连接对象（Connection）</li>
<li>同步原语</li>
<li>共享 <code>ctypes</code> 对象<ul>
<li><code>multiprocessing.sharedctypes</code> 模块</li>
</ul>
</li>
<li>管理器<ul>
<li>自定义管理器</li>
<li>使用远程管理器</li>
</ul>
</li>
<li>代理对象<ul>
<li>清理</li>
</ul>
</li>
<li>进程池</li>
<li>监听器及客户端<ul>
<li>地址格式</li>
</ul>
</li>
<li>认证密码</li>
<li>日志记录</li>
<li><code>multiprocessing.dummy</code> 模块</li>
</ul>
</li>
<li>编程指导<ul>
<li>所有start方法</li>
<li><em>spawn</em> 和 <em>forkserver</em> 启动方式</li>
</ul>
</li>
<li>例子</li>
</ul>
</li>
<li><code>multiprocessing.shared_memory</code> —- 可从进程直接访问的共享内存</li>
<li><code>concurrent</code> 包</li>
<li><code>concurrent.futures</code> —- 启动并行任务<ul>
<li>Executor 对象</li>
<li>ThreadPoolExecutor<ul>
<li>ThreadPoolExecutor 例子</li>
</ul>
</li>
<li>ProcessPoolExecutor<ul>
<li>ProcessPoolExecutor 例子</li>
</ul>
</li>
<li>Future 对象</li>
<li>模块函数</li>
<li>Exception 类</li>
</ul>
</li>
<li><code>subprocess</code> —- 子进程管理<ul>
<li>使用 <code>subprocess</code> 模块<ul>
<li>常用参数</li>
<li>Popen 构造函数</li>
<li>异常</li>
</ul>
</li>
<li>安全考量</li>
<li>Popen 对象</li>
<li>Windows Popen 助手<ul>
<li>Windows 常数</li>
</ul>
</li>
<li>较旧的高阶 API</li>
<li>使用 <code>subprocess</code> 模块替换旧函数<ul>
<li>替代 <strong>/bin/sh</strong> shell 命令替换</li>
<li>替代 shell 管道</li>
<li>替代 <code>os.system()</code></li>
<li>替代 <code>os.spawn</code> 函数族</li>
<li>替代 <code>os.popen()</code>, <code>os.popen2()</code>, <code>os.popen3()</code></li>
<li>来自 <code>popen2</code> 模块的替代函数</li>
</ul>
</li>
<li>旧式的 Shell 发起函数</li>
<li>备注<ul>
<li>在 Windows 上将参数列表转换为一个字符串</li>
</ul>
</li>
</ul>
</li>
<li><code>sched</code> —- 事件调度器<ul>
<li>调度器对象</li>
</ul>
</li>
<li><code>queue</code> —- 一个同步的队列类<ul>
<li>Queue对象</li>
<li>SimpleQueue 对象</li>
</ul>
</li>
<li><code>contextvars</code> —- 上下文变量<ul>
<li>上下文变量</li>
<li>手动上下文管理</li>
<li>asyncio 支持</li>
</ul>
</li>
</ul>
<p>以下是上述某些服务的支持模块：</p>
<ul>
<li><code>_thread</code> —- 底层多线程 API</li>
</ul>
<h2 id="threading-—-基于线程的并行"><a href="#threading-—-基于线程的并行" class="headerlink" title="threading —- 基于线程的并行"></a><code>threading</code> —- 基于线程的并行</h2><p><strong>源代码:</strong><a href="https://github.com/python/cpython/tree/3.10/Lib/threading.py" target="_blank" rel="noopener">Lib/threading.py</a></p>
<hr>
<p>这个模块在较低级的模块 <code>_thread</code> 基础上建立较高级的线程接口。</p>
<p>在 3.7 版更改: 这个模块曾经为可选项，但现在总是可用。</p>
<p>注解</p>
<p>在 Python 2.x 系列中，此模块包含有某些方法和函数 <code>camelCase</code> 形式的名称。 它们在 Python 3.10 中已弃用，但为了与 Python 2.5 及更旧版本的兼容性而仍受到支持。</p>
<p><strong>CPython implementation detail:</strong> 在 CPython 中，由于存在 全局解释器锁，同一时刻只有一个线程可以执行 Python 代码（虽然某些性能导向的库可能会去除此限制）。 如果你想让你的应用更好地利用多核心计算机的计算资源，推荐你使用 <code>multiprocessing</code> 或 <code>concurrent.futures.ProcessPoolExecutor</code>。 但是，如果你想要同时运行多个 I/O 密集型任务，则多线程仍然是一个合适的模型。</p>
<p>这个模块定义了以下函数：</p>
<p><code>threading.active_count</code>()</p>
<p>返回当前存活的 <code>Thread</code> 对象的数量。 返回值与 <code>enumerate()</code> 所返回的列表长度一致。</p>
<p>函数 <code>activeCount</code> 是此函数的已弃用别名。</p>
<p><code>threading.current_thread</code>()</p>
<p>返回当前对应调用者的控制线程的 <code>Thread</code> 对象。如果调用者的控制线程不是利用 <code>threading</code> 创建，会返回一个功能受限的虚拟线程对象。</p>
<p>函数 <code>currentThread</code> 是此函数的已弃用别名。</p>
<p><code>threading.excepthook</code>(<em>args</em>, <em>/</em>)</p>
<p>处理由 <code>Thread.run()</code> 引发的未捕获异常。</p>
<p><em>args</em> 参数具有以下属性:</p>
<ul>
<li><em>exc_type</em>: 异常类型</li>
<li><em>exc_value</em>: 异常值，可以是 <code>None</code>.</li>
<li><em>exc_traceback</em>: 异常回溯，可以是 <code>None</code>.</li>
<li><em>thread</em>: 引发异常的线程，可以为 <code>None</code>。</li>
</ul>
<p>如果 <em>exc_type</em> 为 <code>SystemExit</code>，则异常会被静默地忽略。 在其他情况下，异常将被打印到 <code>sys.stderr</code>。</p>
<p>如果此函数引发了异常，则会调用 <code>sys.excepthook()</code> 来处理它。</p>
<p><code>threading.excepthook()</code> 可以被重载以控制由 <code>Thread.run()</code> 引发的未捕获异常的处理方式。</p>
<p>使用定制钩子存放 <em>exc_value</em> 可能会创建引用循环。 它应当在不再需要异常时被显式地清空以打破引用循环。</p>
<p>如果一个对象正在被销毁，那么使用自定义的钩子储存 <em>thread</em> 可能会将其复活。请在自定义钩子生效后避免储存 <em>thread</em>，以避免对象的复活。</p>
<p>参见</p>
<p><code>sys.excepthook()</code> 处理未捕获的异常。</p>
<p>3.8 新版功能.</p>
<pre><code>threading.__excepthook__</code></pre><p>保存 <code>threading.excepthook()</code> 的原始值。 它被保存以便在原始值碰巧被已损坏或替代对象所替换的情况下可被恢复。</p>
<p>3.10 新版功能.</p>
<p><code>threading.get_ident</code>()</p>
<p>返回当前线程的 “线程标识符”。它是一个非零的整数。它的值没有直接含义，主要是用作 magic cookie，比如作为含有线程相关数据的字典的索引。线程标识符可能会在线程退出，新线程创建时被复用。</p>
<p>3.3 新版功能.</p>
<p><code>threading.get_native_id</code>()</p>
<p>返回内核分配给当前线程的原生集成线程 ID。 这是一个非负整数。 它的值可被用来在整个系统中唯一地标识这个特定线程（直到线程终结，在那之后该值可能会被 OS 回收再利用）。</p>
<p>可用性: Windows, FreeBSD, Linux, macOS, OpenBSD, NetBSD, AIX。</p>
<p>3.8 新版功能.</p>
<p><code>threading.enumerate</code>()</p>
<p>返回当前所有存活的 <code>Thread</code> 对象的列表。 该列表包括守护线程以及 <code>current_thread()</code> 创建的空线程。 它不包括已终结的和尚未开始的线程。 但是，主线程将总是结果的一部分，即使是在已终结的时候。</p>
<p><code>threading.main_thread</code>()</p>
<p>返回主 <code>Thread</code> 对象。一般情况下，主线程是Python解释器开始时创建的线程。</p>
<p>3.4 新版功能.</p>
<p><code>threading.settrace</code>(<em>func</em>)</p>
<p>为所有 <code>threading</code> 模块开始的线程设置追踪函数。在每个线程的 <code>run()</code> 方法被调用前，<em>func</em> 会被传递给 <code>sys.settrace()</code> 。</p>
<p><code>threading.gettrace</code>()</p>
<p>返回由 <code>settrace()</code> 设置的跟踪函数。</p>
<p>3.10 新版功能.</p>
<p><code>threading.setprofile</code>(<em>func</em>)</p>
<p>为所有 <code>threading</code> 模块开始的线程设置性能测试函数。在每个线程的 <code>run()</code> 方法被调用前，<em>func</em> 会被传递给 <code>sys.setprofile()</code> 。</p>
<p><code>threading.getprofile</code>()</p>
<p>返回由 <code>setprofile()</code> 设置的性能分析函数。</p>
<p>3.10 新版功能.</p>
<p><code>threading.stack_size</code>([<em>size</em>])</p>
<p>返回创建线程时使用的堆栈大小。可选参数 <em>size</em> 指定之后新建的线程的堆栈大小，而且一定要是0（根据平台或者默认配置）或者最小是32,768(32KiB)的一个正整数。如果 <em>size</em> 没有指定，默认是0。如果不支持改变线程堆栈大小，会抛出 <code>RuntimeError</code> 错误。如果指定的堆栈大小不合法，会抛出 <code>ValueError</code> 错误并且不会修改堆栈大小。32KiB是当前最小的能保证解释器有足够堆栈空间的堆栈大小。需要注意的是部分平台对于堆栈大小会有特定的限制，例如要求大于32KiB的堆栈大小或者需要根据系统内存页面的整数倍进行分配 - 应当查阅平台文档有关详细信息（4KiB页面比较普遍，在没有更具体信息的情况下，建议的方法是使用4096的倍数作为堆栈大小）。</p>
<p>适用于: Windows，具有 POSIX 线程的系统。</p>
<p>这个模块同时定义了以下常量：</p>
<pre><code>threading.TIMEOUT_MAX</code></pre><p>阻塞函数（ <code>Lock.acquire()</code>, <code>RLock.acquire()</code>, <code>Condition.wait()</code>, …）中形参 <em>timeout</em> 允许的最大值。传入超过这个值的 timeout 会抛出 <code>OverflowError</code> 异常。</p>
<p>3.2 新版功能.</p>
<p>这个模块定义了许多类，详见以下部分。</p>
<p>该模块的设计基于 Java的线程模型。 但是，在Java里面，锁和条件变量是每个对象的基础特性，而在Python里面，这些被独立成了单独的对象。 Python 的 <code>Thread</code> 类只是 Java 的 Thread 类的一个子集；目前还没有优先级，没有线程组，线程还不能被销毁、停止、暂停、恢复或中断。 Java 的 Thread 类的静态方法在实现时会映射为模块级函数。</p>
<p>下述方法的执行都是原子性的。</p>
<h3 id="线程本地数据"><a href="#线程本地数据" class="headerlink" title="线程本地数据"></a>线程本地数据</h3><p>线程本地数据是特定线程的数据。管理线程本地数据，只需要创建一个 <code>local</code> （或者一个子类型）的实例并在实例中储存属性：</p>
<pre class="line-numbers language-python"><code class="language-python">mydata <span class="token operator">=</span> threading<span class="token punctuation">.</span>local<span class="token punctuation">(</span><span class="token punctuation">)</span>
mydata<span class="token punctuation">.</span>x <span class="token operator">=</span><span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>在不同的线程中，实例的值会不同。</p>
<p><em>class</em><code>threading.local</code></p>
<p>一个代表线程本地数据的类。</p>
<p>更多相关细节和大量示例，参见 <code>_threading_local</code> 模块的文档。</p>
<h3 id="线程对象"><a href="#线程对象" class="headerlink" title="线程对象"></a>线程对象</h3><p>The <code>Thread</code> class represents an activity that is run in a separate thread of control. There are two ways to specify the activity: by passing a callable object to the constructor, or by overriding the <code>run()</code> method in a subclass. No other methods (except for the constructor) should be overridden in a subclass. In other words, <em>only</em> override the <code>__init__()</code> and <code>run()</code> methods of this class.</p>
<p>当线程对象一但被创建，其活动一定会因调用线程的 <code>start()</code> 方法开始。这会在独立的控制线程调用 <code>run()</code> 方法。</p>
<p>一旦线程活动开始，该线程会被认为是 ‘存活的’ 。当它的 <code>run()</code> 方法终结了（不管是正常的还是抛出未被处理的异常），就不是’存活的’。 <code>is_alive()</code> 方法用于检查线程是否存活。</p>
<p>其他线程可以调用一个线程的 <code>join()</code> 方法。这会阻塞调用该方法的线程，直到被调用 <code>join()</code> 方法的线程终结。</p>
<p>线程有名字。名字可以传递给构造函数，也可以通过 <code>name</code> 属性读取或者修改。</p>
<p>如果 <code>run()</code> 方法引发了异常，则会调用 <code>threading.excepthook()</code> 来处理它。 在默认情况下，<code>threading.excepthook()</code> 会静默地忽略 <code>SystemExit</code>。</p>
<p>一个线程可以被标记成一个“守护线程”。 这个标识的意义是，当剩下的线程都是守护线程时，整个 Python 程序将会退出。 初始值继承于创建线程。 这个标识可以通过 <code>daemon</code> 特征属性或者 <em>daemon</em> 构造器参数来设置。</p>
<p>注解</p>
<p>守护线程在程序关闭时会突然关闭。他们的资源（例如已经打开的文档，数据库事务等等）可能没有被正确释放。如果你想你的线程正常停止，设置他们成为非守护模式并且使用合适的信号机制，例如： <code>Event</code>。</p>
<p>有个 “主线程” 对象；这对应Python程序里面初始的控制线程。它不是一个守护线程。</p>
<p>“虚拟线程对象” 是可以被创建的。这些是对应于“外部线程”的线程对象，它们是在线程模块外部启动的控制线程，例如直接来自C代码。虚拟线程对象功能受限；他们总是被认为是存活的和守护模式，不能被 <code>join()</code> 。因为无法检测外来线程的终结，它们永远不会被删除。</p>
<p><em>class<em><code>threading.Thread</code>(</em>group=None</em>, <em>target=None</em>, <em>name=None</em>, <em>args=()</em>, <em>kwargs={}</em>, <em>**,</em> daemon=None*)</p>
<p>调用这个构造函数时，必需带有关键字参数。参数如下：</p>
<p><em>group</em> 应该为 <code>None</code>；为了日后扩展 <code>ThreadGroup</code> 类实现而保留。</p>
<p><em>target</em> 是用于 <code>run()</code> 方法调用的可调用对象。默认是 <code>None</code>，表示不需要调用任何方法。</p>
<p><em>name</em> 是线程名称。 在默认情况下，会以 “Thread-<em>N</em>“ 的形式构造唯一名称，其中 <em>N</em> 为一个较小的十进制数值，或是 “Thread-<em>N</em> (target)” 的形式，其中 “target” 为 <code>target.__name__</code>，如果指定了 <em>target</em> 参数的话。</p>
<p><em>args</em> 是用于调用目标函数的参数元组。默认是 <code>()</code>。</p>
<p><em>kwargs</em> 是用于调用目标函数的关键字参数字典。默认是 <code>{}</code>。</p>
<p>如果不是 <code>None</code>，<em>daemon</em> 参数将显式地设置该线程是否为守护模式。 如果是 <code>None</code> (默认值)，线程将继承当前线程的守护模式属性。</p>
<p>如果子类型重载了构造函数，它一定要确保在做任何事前，先发起调用基类构造器(<code>Thread.__init__()</code>)。</p>
<p>在 3.10 版更改: 使用 <em>target</em> 名称，如果 <em>name</em> 参数被省略的话。</p>
<p>在 3.3 版更改: 加入 <em>daemon</em> 参数。</p>
<ul>
<li><p><code>start</code>()</p>
<p>开始线程活动。</p>
<p>它在一个线程里最多只能被调用一次。它安排对象的 <code>run()</code> 方法在一个独立的控制进程中调用。</p>
<p>如果同一个线程对象中调用这个方法的次数大于一次，会抛出 <code>RuntimeError</code> 。</p>
</li>
<li><p><code>run</code>()</p>
<p>代表线程活动的方法。</p>
<p>你可以在子类型里重载这个方法。 标准的 <code>run()</code> 方法会对作为 <em>target</em> 参数传递给该对象构造器的可调用对象（如果存在）发起调用，并附带从 <em>args</em> 和 <em>kwargs</em> 参数分别获取的位置和关键字参数。</p>
</li>
<li><p><code>join</code>(<em>timeout=None</em>)</p>
<p>等待，直到线程终结。这会阻塞调用这个方法的线程，直到被调用 <code>join()</code> 的线程终结 — 不管是正常终结还是抛出未处理异常 — 或者直到发生超时，超时选项是可选的。</p>
<p>当 <em>timeout</em> 参数存在而且不是 <code>None</code> 时，它应该是一个用于指定操作超时的以秒为单位的浮点数或者分数。因为 <code>join()</code> 总是返回 <code>None</code> ，所以你一定要在 <code>join()</code> 后调用 <code>is_alive()</code> 才能判断是否发生超时 — 如果线程仍然存活，则 <code>join()</code> 超时。</p>
<p>当 <em>timeout</em> 参数不存在或者是 <code>None</code> ，这个操作会阻塞直到线程终结。</p>
<p>一个线程可以被 <code>join()</code> 很多次。</p>
<p>如果尝试加入当前线程会导致死锁， <code>join()</code> 会引起 <code>RuntimeError</code> 异常。如果尝试 <code>join()</code> 一个尚未开始的线程，也会抛出相同的异常。</p>
</li>
<li><p><code>name</code></p>
<p>只用于识别的字符串。它没有语义。多个线程可以赋予相同的名称。 初始名称由构造函数设置。</p>
</li>
<li><p><code>getName</code>()</p>
<p><code>setName</code>()</p>
<p>已被弃用的 <code>name</code> 的取值/设值 API；请改为直接以特征属性方式使用它。</p>
<p>3.10 版后已移除.</p>
</li>
<li><p><code>ident</code></p>
<p>这个线程的 ‘线程标识符’，如果线程尚未开始则为 <code>None</code> 。这是个非零整数。当一个线程退出而另外一个线程被创建，线程标识符会被复用。即使线程退出后，仍可得到标识符。</p>
</li>
<li><p><code>native_id</code></p>
<p>此线程的线程 ID (<code>TID</code>)，由 OS (内核) 分配。 这是一个非负整数，或者如果线程还未启动则为 <code>None</code>。 这个值可被用来在全系统范围内唯一地标识这个特定线程 (直到线程终结，在那之后该值可能会被 OS 回收再利用)。</p>
<p>注解</p>
<p>类似于进程 ID，线程 ID 的有效期（全系统范围内保证唯一）将从线程被创建开始直到线程被终结。</p>
<p>可用性: 需要 <code>get_native_id()</code> 函数。</p>
<p>3.8 新版功能.</p>
</li>
<li><p><code>is_alive</code>()</p>
<p>返回线程是否存活。</p>
<p>当 <code>run()</code> 方法刚开始直到 <code>run()</code> 方法刚结束，这个方法返回 <code>True</code> 。模块函数 <code>enumerate()</code> 返回包含所有存活线程的列表。</p>
</li>
<li><p><code>daemon</code></p>
<p>一个表示这个线程是（True）否（False）守护线程的布尔值。一定要在调用 <code>start()</code> 前设置好，不然会抛出 <code>RuntimeError</code> 。初始值继承于创建线程；主线程不是守护线程，因此主线程创建的所有线程默认都是 <code>daemon</code> = <code>False</code>。</p>
<p>当没有存活的非守护线程时，整个Python程序才会退出。</p>
</li>
<li><p><code>isDaemon</code>()</p>
<p><code>setDaemon</code>()</p>
<p>已被弃用的 <code>daemon</code> 的取值/设值 API；请改为直接以特征属性方式使用它。</p>
<p>3.10 版后已移除.</p>
</li>
</ul>
<h3 id="锁对象"><a href="#锁对象" class="headerlink" title="锁对象"></a>锁对象</h3><p>原始锁是一个在锁定时不属于特定线程的同步基元组件。在Python中，它是能用的最低级的同步基元组件，由 <code>_thread</code> 扩展模块直接实现。</p>
<p>原始锁处于 “锁定” 或者 “非锁定” 两种状态之一。它被创建时为非锁定状态。它有两个基本方法， <code>acquire()</code> 和 <code>release()</code> 。当状态为非锁定时， <code>acquire()</code> 将状态改为 锁定 并立即返回。当状态是锁定时， <code>acquire()</code> 将阻塞至其他线程调用 <code>release()</code> 将其改为非锁定状态，然后 <code>acquire()</code> 调用重置其为锁定状态并返回。 <code>release()</code> 只在锁定状态下调用； 它将状态改为非锁定并立即返回。如果尝试释放一个非锁定的锁，则会引发 <code>RuntimeError</code> 异常。</p>
<p>锁同样支持 上下文管理协议。</p>
<p>当多个线程在 <code>acquire()</code> 等待状态转变为未锁定被阻塞，然后 <code>release()</code> 重置状态为未锁定时，只有一个线程能继续执行；至于哪个等待线程继续执行没有定义，并且会根据实现而不同。</p>
<p>所有方法的执行都是原子性的。</p>
<p><em>class</em><code>threading.Lock</code></p>
<p>实现原始锁对象的类。一旦一个线程获得一个锁，会阻塞随后尝试获得锁的线程，直到它被释放；任何线程都可以释放它。</p>
<p>需要注意的是 <code>Lock</code> 其实是一个工厂函数，返回平台支持的具体锁类中最有效的版本的实例。</p>
<ul>
<li><p><code>acquire</code>(<em>blocking=True</em>, <em>timeout=- 1</em>)</p>
<p>可以阻塞或非阻塞地获得锁。</p>
<p>当调用时参数 <em>blocking</em> 设置为 <code>True</code> （缺省值），阻塞直到锁被释放，然后将锁锁定并返回 <code>True</code> 。</p>
<p>在参数 <em>blocking</em> 被设置为 <code>False</code> 的情况下调用，将不会发生阻塞。如果调用时 <em>blocking</em> 设为 <code>True</code> 会阻塞，并立即返回 <code>False</code> ；否则，将锁锁定并返回 <code>True</code>。</p>
<p>当浮点型 <em>timeout</em> 参数被设置为正值调用时，只要无法获得锁，将最多阻塞 <em>timeout</em> 设定的秒数。<em>timeout</em> 参数被设置为 <code>-1</code> 时将无限等待。当 <em>blocking</em> 为 false 时，<em>timeout</em> 指定的值将被忽略。</p>
<p>如果成功获得锁，则返回 <code>True</code>，否则返回 <code>False</code> (例如发生 <em>超时</em> 的时候)。</p>
<p>在 3.2 版更改: 新的 <em>timeout</em> 形参。</p>
<p>在 3.2 版更改: 现在如果底层线程实现支持，则可以通过POSIX上的信号中断锁的获取。</p>
</li>
<li><p><code>release</code>()</p>
<p>释放一个锁。这个方法可以在任何线程中调用，不单指获得锁的线程。</p>
<p>当锁被锁定，将它重置为未锁定，并返回。如果其他线程正在等待这个锁解锁而被阻塞，只允许其中一个允许。</p>
<p>当在未锁定的锁上发起调用时，会引发 <code>RuntimeError</code>。</p>
<p>没有返回值。</p>
</li>
<li><p><code>locked</code>()</p>
<p>如果获得了锁则返回真值。</p>
</li>
</ul>
<h3 id="递归锁对象"><a href="#递归锁对象" class="headerlink" title="递归锁对象"></a>递归锁对象</h3><p>重入锁是一个可以被同一个线程多次获取的同步基元组件。在内部，它在基元锁的锁定/非锁定状态上附加了 “所属线程” 和 “递归等级” 的概念。在锁定状态下，某些线程拥有锁 ； 在非锁定状态下， 没有线程拥有它。</p>
<p>若要锁定锁，线程调用其 <code>acquire()</code> 方法；一旦线程拥有了锁，方法将返回。若要解锁，线程调用 <code>release()</code> 方法。 <code>acquire()</code>/<code>release()</code> 对可以嵌套；只有最终 <code>release()</code> (最外面一对的 <code>release()</code> ) 将锁解开，才能让其他线程继续处理 <code>acquire()</code> 阻塞。</p>
<p>递归锁也支持 上下文管理协议。</p>
<p><em>class</em><code>threading.RLock</code></p>
<p>此类实现了重入锁对象。重入锁必须由获取它的线程释放。一旦线程获得了重入锁，同一个线程再次获取它将不阻塞；线程必须在每次获取它时释放一次。</p>
<p>需要注意的是 <code>RLock</code> 其实是一个工厂函数，返回平台支持的具体递归锁类中最有效的版本的实例。</p>
<ul>
<li><p><code>acquire</code>(<em>blocking=True</em>, <em>timeout=- 1</em>)</p>
<p>可以阻塞或非阻塞地获得锁。</p>
<p>当无参数调用时： 如果这个线程已经拥有锁，递归级别增加一，并立即返回。否则，如果其他线程拥有该锁，则阻塞至该锁解锁。一旦锁被解锁(不属于任何线程)，则抢夺所有权，设置递归等级为一，并返回。如果多个线程被阻塞，等待锁被解锁，一次只有一个线程能抢到锁的所有权。在这种情况下，没有返回值。</p>
<p>当发起调用时将 <em>blocking</em> 参数设为真值，则执行与无参数调用时一样的操作，然后返回 <code>True</code>。</p>
<p>当发起调用时将 <em>blocking</em> 参数设为假值，则不进行阻塞。 如果一个无参数调用将要阻塞，则立即返回 <code>False</code>；在其他情况下，执行与无参数调用时一样的操作，然后返回 <code>True</code>。</p>
<p>当发起调用时将浮点数的 <em>timeout</em> 参数设为正值时，只要无法获得锁，将最多阻塞 <em>timeout</em> 所指定的秒数。 如果已经获得锁则返回 <code>True</code>，如果超时则返回假值。</p>
<p>在 3.2 版更改: 新的 <em>timeout</em> 形参。</p>
</li>
<li><p><code>release</code>()</p>
<p>释放锁，自减递归等级。如果减到零，则将锁重置为非锁定状态(不被任何线程拥有)，并且，如果其他线程正被阻塞着等待锁被解锁，则仅允许其中一个线程继续。如果自减后，递归等级仍然不是零，则锁保持锁定，仍由调用线程拥有。</p>
<p>只有当前线程拥有锁才能调用这个方法。如果锁被释放后调用这个方法，会引起 <code>RuntimeError</code> 异常。</p>
<p>没有返回值。</p>
</li>
</ul>
<h3 id="条件对象"><a href="#条件对象" class="headerlink" title="条件对象"></a>条件对象</h3><p>条件变量总是与某种类型的锁对象相关联，锁对象可以通过传入获得，或者在缺省的情况下自动创建。当多个条件变量需要共享同一个锁时，传入一个锁很有用。锁是条件对象的一部分，你不必单独地跟踪它。</p>
<p>条件变量遵循 上下文管理协议 ：使用 <code>with</code> 语句会在它包围的代码块内获取关联的锁。 <code>acquire()</code> 和 <code>release()</code> 方法也能调用关联锁的相关方法。</p>
<p>其它方法必须在持有关联的锁的情况下调用。 <code>wait()</code> 方法释放锁，然后阻塞直到其它线程调用 <code>notify()</code> 方法或 <code>notify_all()</code> 方法唤醒它。一旦被唤醒， <code>wait()</code> 方法重新获取锁并返回。它也可以指定超时时间。</p>
<p>The <code>notify()</code> method wakes up one of the threads waiting for the condition variable, if any are waiting. The <code>notify_all()</code> method wakes up all threads waiting for the condition variable.</p>
<p>注意： <code>notify()</code> 方法和 <code>notify_all()</code> 方法并不会释放锁，这意味着被唤醒的线程不会立即从它们的 <code>wait()</code> 方法调用中返回，而是会在调用了 <code>notify()</code> 方法或 <code>notify_all()</code> 方法的线程最终放弃了锁的所有权后返回。</p>
<p>使用条件变量的典型编程风格是将锁用于同步某些共享状态的权限，那些对状态的某些特定改变感兴趣的线程，它们重复调用 <code>wait()</code> 方法，直到看到所期望的改变发生；而对于修改状态的线程，它们将当前状态改变为可能是等待者所期待的新状态后，调用 <code>notify()</code> 方法或者 <code>notify_all()</code> 方法。例如，下面的代码是一个通用的无限缓冲区容量的生产者-消费者情形：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Consume one item</span>
<span class="token keyword">with</span> cv<span class="token punctuation">:</span>
whilenot an_item_is_available<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        cv<span class="token punctuation">.</span>wait<span class="token punctuation">(</span><span class="token punctuation">)</span>
    get_an_available_item<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment" spellcheck="true"># Produce one item</span>
<span class="token keyword">with</span> cv<span class="token punctuation">:</span>
    make_an_item_available<span class="token punctuation">(</span><span class="token punctuation">)</span>
    cv<span class="token punctuation">.</span>notify<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>使用 <code>while</code> 循环检查所要求的条件成立与否是有必要的，因为 <code>wait()</code> 方法可能要经过不确定长度的时间后才会返回，而此时导致 <code>notify()</code> 方法调用的那个条件可能已经不再成立。这是多线程编程所固有的问题。 <code>wait_for()</code> 方法可自动化条件检查，并简化超时计算。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Consume an item</span>
<span class="token keyword">with</span> cv<span class="token punctuation">:</span>
    cv<span class="token punctuation">.</span>wait_for<span class="token punctuation">(</span>an_item_is_available<span class="token punctuation">)</span>
    get_an_available_item<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>选择 <code>notify()</code> 还是 <code>notify_all()</code> ，取决于一次状态改变是只能被一个还是能被多个等待线程所用。例如在一个典型的生产者-消费者情形中，添加一个项目到缓冲区只需唤醒一个消费者线程。</p>
<p><em>class<em><code>threading.Condition</code>(</em>lock=None</em>)</p>
<p>实现条件变量对象的类。一个条件变量对象允许一个或多个线程在被其它线程所通知之前进行等待。</p>
<p>如果给出了非 <code>None</code> 的 <em>lock</em> 参数，则它必须为 <code>Lock</code> 或者 <code>RLock</code> 对象，并且它将被用作底层锁。否则，将会创建新的 <code>RLock</code> 对象，并将其用作底层锁。</p>
<p>在 3.3 版更改: 从工厂函数变为类。</p>
<ul>
<li><p><code>acquire</code>(<em>\</em>args*)</p>
<p>请求底层锁。此方法调用底层锁的相应方法，返回值是底层锁相应方法的返回值。</p>
</li>
<li><p><code>release</code>()</p>
<p>释放底层锁。此方法调用底层锁的相应方法。没有返回值。</p>
</li>
<li><p><code>wait</code>(<em>timeout=None</em>)</p>
<p>等待直到被通知或发生超时。如果线程在调用此方法时没有获得锁，将会引发 <code>RuntimeError</code> 异常。</p>
<p>这个方法释放底层锁，然后阻塞，直到在另外一个线程中调用同一个条件变量的 <code>notify()</code> 或 <code>notify_all()</code> 唤醒它，或者直到可选的超时发生。一旦被唤醒或者超时，它重新获得锁并返回。</p>
<p>当提供了 <em>timeout</em> 参数且不是 <code>None</code> 时，它应该是一个浮点数，代表操作的超时时间，以秒为单位（可以为小数）。</p>
<p>当底层锁是个 <code>RLock</code> ，不会使用它的 <code>release()</code> 方法释放锁，因为当它被递归多次获取时，实际上可能无法解锁。相反，使用了 <code>RLock</code> 类的内部接口，即使多次递归获取它也能解锁它。 然后，在重新获取锁时，使用另一个内部接口来恢复递归级别。</p>
<p>返回 <code>True</code> ，除非提供的 <em>timeout</em> 过期，这种情况下返回 <code>False</code>。</p>
<p>在 3.2 版更改: 很明显，方法总是返回 <code>None</code>。</p>
</li>
<li><p><code>wait_for</code>(<em>predicate</em>, <em>timeout=None</em>)</p>
<p>等待，直到条件计算为真。 <em>predicate</em> 应该是一个可调用对象而且它的返回值可被解释为一个布尔值。可以提供 <em>timeout</em> 参数给出最大等待时间。</p>
<p>这个实用方法会重复地调用 <code>wait()</code> 直到满足判断式或者发生超时。返回值是判断式最后一个返回值，而且如果方法发生超时会返回 <code>False</code> 。</p>
<p>忽略超时功能，调用此方法大致相当于编写:</p>
<pre class="line-numbers language-python"><code class="language-python">whilenot predicate<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    cv<span class="token punctuation">.</span>wait<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>因此，规则同样适用于 <code>wait()</code> ：锁必须在被调用时保持获取，并在返回时重新获取。 随着锁定执行判断式。</p>
<p>3.2 新版功能.</p>
</li>
<li><p><code>notify</code>(<em>n=1</em>)</p>
<p>默认唤醒一个等待这个条件的线程。如果调用线程在没有获得锁的情况下调用这个方法，会引发 <code>RuntimeError</code> 异常。</p>
<p>这个方法唤醒最多 <em>n</em> 个正在等待这个条件变量的线程；如果没有线程在等待，这是一个空操作。</p>
<p>当前实现中，如果至少有 <em>n</em> 个线程正在等待，准确唤醒 <em>n</em> 个线程。但是依赖这个行为并不安全。未来，优化的实现有时会唤醒超过 <em>n</em> 个线程。</p>
<p>注意：被唤醒的线程实际上不会返回它调用的 <code>wait()</code> ，直到它可以重新获得锁。因为 <code>notify()</code> 不会释放锁，只有它的调用者应该这样做。</p>
</li>
<li><p><code>notify_all</code>()</p>
<p>唤醒所有正在等待这个条件的线程。这个方法行为与 <code>notify()</code> 相似，但并不只唤醒单一线程，而是唤醒所有等待线程。如果调用线程在调用这个方法时没有获得锁，会引发 <code>RuntimeError</code> 异常。</p>
<p><code>notifyAll</code> 方法是此方法的已弃用别名。</p>
</li>
</ul>
<h3 id="信号量对象"><a href="#信号量对象" class="headerlink" title="信号量对象"></a>信号量对象</h3><p>这是计算机科学史上最古老的同步原语之一，早期的荷兰科学家 Edsger W. Dijkstra 发明了它。（他使用名称 <code>P()</code> 和 <code>V()</code> 而不是 <code>acquire()</code> 和 <code>release()</code> ）。</p>
<p>一个信号量管理一个内部计数器，该计数器因 <code>acquire()</code> 方法的调用而递减，因 <code>release()</code> 方法的调用而递增。 计数器的值永远不会小于零；当 <code>acquire()</code> 方法发现计数器为零时，将会阻塞，直到其它线程调用 <code>release()</code> 方法。</p>
<p>信号量对象也支持 上下文管理协议 。</p>
<p><em>class<em><code>threading.Semaphore</code>(</em>value=1</em>)</p>
<p>该类实现信号量对象。信号量对象管理一个原子性的计数器，代表 <code>release()</code> 方法的调用次数减去 <code>acquire()</code> 的调用次数再加上一个初始值。如果需要， <code>acquire()</code> 方法将会阻塞直到可以返回而不会使得计数器变成负数。在没有显式给出 <em>value</em> 的值时，默认为1。</p>
<p>可选参数 <em>value</em> 赋予内部计数器初始值，默认值为 <code>1</code> 。如果 <em>value</em> 被赋予小于0的值，将会引发 <code>ValueError</code> 异常。</p>
<p>在 3.3 版更改: 从工厂函数变为类。</p>
<ul>
<li><p><code>acquire</code>(<em>blocking=True</em>, <em>timeout=None</em>)</p>
<p>获取一个信号量。</p>
<p>在不带参数的情况下调用时：</p>
<ul>
<li>如果在进入时内部计数器的值大于零，则将其减一并立即返回 <code>True</code>。</li>
<li>如果在进入时内部计数器的值为零，则将会阻塞直到被对 <code>release()</code> 的调用唤醒。 一旦被唤醒（并且计数器的值大于 0），则将计数器减 1 并返回 <code>True</code>。 每次对 <code>release()</code> 的调用将只唤醒一个线程。 线程被唤醒的次序是不可确定的。</li>
</ul>
<p>当发起调用时将 <em>blocking</em> 设为假值，则不进行阻塞。 如果一个无参数调用将要阻塞，则立即返回 <code>False</code>；在其他情况下，执行与无参数调用时一样的操作，然后返回 <code>True</code>。</p>
<p>当发起调用时如果 <em>timeout</em> 不为 <code>None</code>，则它将阻塞最多 <em>timeout</em> 秒。 请求在此时段时未能成功完成获取则将返回 <code>False</code>。 在其他情况下返回 <code>True</code>。</p>
<p>在 3.2 版更改: 新的 <em>timeout</em> 形参。</p>
</li>
<li><p><code>release</code>(<em>n=1</em>)</p>
<p>释放一个信号量，将内部计数器的值增加 <em>n</em>。 当进入时值为零且有其他线程正在等待它再次变为大于零时，则唤醒那 <em>n</em> 个线程。</p>
<p>在 3.9 版更改: 增加了 <em>n</em> 形参以一次性释放多个等待线程。</p>
</li>
</ul>
<p><em>class<em><code>threading.BoundedSemaphore</code>(</em>value=1</em>)</p>
<p>该类实现有界信号量。有界信号量通过检查以确保它当前的值不会超过初始值。如果超过了初始值，将会引发 <code>ValueError</code> 异常。在大多情况下，信号量用于保护数量有限的资源。如果信号量被释放的次数过多，则表明出现了错误。没有指定时， <em>value</em> 的值默认为1。</p>
<p>在 3.3 版更改: 从工厂函数变为类。</p>
<h4 id="Semaphore-例子"><a href="#Semaphore-例子" class="headerlink" title="Semaphore 例子"></a><code>Semaphore</code> 例子</h4><p>信号量通常用于保护数量有限的资源，例如数据库服务器。在资源数量固定的任何情况下，都应该使用有界信号量。在生成任何工作线程前，应该在主线程中初始化信号量。</p>
<pre class="line-numbers language-python"><code class="language-python">maxconnections <span class="token operator">=</span><span class="token number">5</span>
<span class="token comment" spellcheck="true"># ...</span>
pool_sema <span class="token operator">=</span>BoundedSemaphore<span class="token punctuation">(</span>value<span class="token operator">=</span>maxconnections<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>工作线程生成后，当需要连接服务器时，这些线程将调用信号量的 acquire 和 release 方法：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">with</span> pool_sema<span class="token punctuation">:</span>
    conn <span class="token operator">=</span> connectdb<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">try</span><span class="token punctuation">:</span>
<span class="token comment" spellcheck="true"># ... use connection ...</span>
<span class="token keyword">finally</span><span class="token punctuation">:</span>
        conn<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>使用有界信号量能减少这种编程错误：信号量的释放次数多于其请求次数。</p>
<h3 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h3><p>这是线程之间通信的最简单机制之一：一个线程发出事件信号，而其他线程等待该信号。</p>
<p>一个事件对象管理一个内部标识，调用 <code>set()</code> 方法可将其设置为 true ，调用 <code>clear()</code> 方法可将其设置为 false ，调用 <code>wait()</code> 方法将进入阻塞直到标识为 true 。</p>
<p><em>class</em><code>threading.Event</code></p>
<p>实现事件对象的类。事件对象管理一个内部标识，调用 <code>set()</code> 方法可将其设置为true。调用 <code>clear()</code> 方法可将其设置为 false 。调用 <code>wait()</code> 方法将进入阻塞直到标识为true。这个标识初始时为 false 。</p>
<p>在 3.3 版更改: 从工厂函数变为类。</p>
<ul>
<li><p><code>is_set</code>()</p>
<p>当且仅当内部标识为 true 时返回 <code>True</code> 。</p>
<p><code>isSet</code> 方法是此方法的已弃用别名。</p>
</li>
<li><p><code>set</code>()</p>
<p>将内部标识设置为 true 。所有正在等待这个事件的线程将被唤醒。当标识为 true 时，调用 <code>wait()</code> 方法的线程不会被被阻塞。</p>
</li>
<li><p><code>clear</code>()</p>
<p>将内部标识设置为 false 。之后调用 <code>wait()</code> 方法的线程将会被阻塞，直到调用 <code>set()</code> 方法将内部标识再次设置为 true 。</p>
</li>
<li><p><code>wait</code>(<em>timeout=None</em>)</p>
<p>阻塞线程直到内部变量为 true 。如果调用时内部标识为 true，将立即返回。否则将阻塞线程，直到调用 <code>set()</code> 方法将标识设置为 true 或者发生可选的超时。</p>
<p>当提供了timeout参数且不是 <code>None</code> 时，它应该是一个浮点数，代表操作的超时时间，以秒为单位（可以为小数）。</p>
<p>当且仅当内部旗标在等待调用之前或者等待开始之后被设为真值时此方法将返回 <code>True</code>，也就是说，它将总是返回 <code>True</code> 除非设定了超时且操作发生了超时。</p>
<p>在 3.1 版更改: 很明显，方法总是返回 <code>None</code>。</p>
</li>
</ul>
<h3 id="定时器对象"><a href="#定时器对象" class="headerlink" title="定时器对象"></a>定时器对象</h3><p>此类表示一个操作应该在等待一定的时间之后运行 —- 相当于一个定时器。 <code>Timer</code> 类是 <code>Thread</code> 类的子类，因此可以像一个自定义线程一样工作。</p>
<p>与线程一样，通过调用 <code>start()</code> 方法启动定时器。而 <code>cancel()</code> 方法可以停止计时器（在计时结束前）， 定时器在执行其操作之前等待的时间间隔可能与用户指定的时间间隔不完全相同。</p>
<p>例如：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"hello, world"</span><span class="token punctuation">)</span>
t <span class="token operator">=</span>Timer<span class="token punctuation">(</span><span class="token number">30.0</span><span class="token punctuation">,</span> hello<span class="token punctuation">)</span>
t<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># after 30 seconds, "hello, world" will be printed</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p><em>class<em><code>threading.Timer</code>(</em>interval</em>, <em>function</em>, <em>args=None</em>, <em>kwargs=None</em>)</p>
<p>创建一个定时器，在经过 <em>interval</em> 秒的间隔事件后，将会用参数 <em>args</em> 和关键字参数 <em>kwargs</em> 调用 <em>function*。如果 *args</em> 为 <code>None</code> （默认值），则会使用一个空列表。如果 <em>kwargs</em> 为 <code>None</code> （默认值），则会使用一个空字典。</p>
<p>在 3.3 版更改: 从工厂函数变为类。</p>
<ul>
<li><p><code>cancel</code>()</p>
<p>停止定时器并取消执行计时器将要执行的操作。仅当计时器仍处于等待状态时有效。</p>
</li>
</ul>
<h3 id="栅栏对象"><a href="#栅栏对象" class="headerlink" title="栅栏对象"></a>栅栏对象</h3><p>3.2 新版功能.</p>
<p>栅栏类提供一个简单的同步原语，用于应对固定数量的线程需要彼此相互等待的情况。线程调用 <code>wait()</code> 方法后将阻塞，直到所有线程都调用了 <code>wait()</code> 方法。此时所有线程将被同时释放。</p>
<p>栅栏对象可以被多次使用，但进程的数量不能改变。</p>
<p>这是一个使用简便的方法实现客户端进程与服务端进程同步的例子：</p>
<pre class="line-numbers language-python"><code class="language-python">b <span class="token operator">=</span>Barrier<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> timeout<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">server</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    start_server<span class="token punctuation">(</span><span class="token punctuation">)</span>
    b<span class="token punctuation">.</span>wait<span class="token punctuation">(</span><span class="token punctuation">)</span>
whileTrue<span class="token punctuation">:</span>
        connection <span class="token operator">=</span> accept_connection<span class="token punctuation">(</span><span class="token punctuation">)</span>
        process_server_connection<span class="token punctuation">(</span>connection<span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">client</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    b<span class="token punctuation">.</span>wait<span class="token punctuation">(</span><span class="token punctuation">)</span>
whileTrue<span class="token punctuation">:</span>
        connection <span class="token operator">=</span> make_connection<span class="token punctuation">(</span><span class="token punctuation">)</span>
        process_client_connection<span class="token punctuation">(</span>connection<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><em>class<em><code>threading.Barrier</code>(</em>parties</em>, <em>action=None</em>, <em>timeout=None</em>)</p>
<p>创建一个需要 <em>parties</em> 个线程的栅栏对象。如果提供了可调用的 <em>action</em> 参数，它会在所有线程被释放时在其中一个线程中自动调用。 <em>timeout</em> 是默认的超时时间，如果没有在 <code>wait()</code> 方法中指定超时时间的话。</p>
<ul>
<li><p><code>wait</code>(<em>timeout=None</em>)</p>
<p>冲出栅栏。当栅栏中所有线程都已经调用了这个函数，它们将同时被释放。如果提供了 <em>timeout</em> 参数，这里的 <em>timeout</em> 参数优先于创建栅栏对象时提供的 <em>timeout</em> 参数。</p>
<p>函数返回值是一个整数，取值范围在0到 <em>parties</em> — 1，在每个线程中的返回值不相同。可用于从所有线程中选择唯一的一个线程执行一些特别的工作。例如：</p>
<pre class="line-numbers language-python"><code class="language-python">i <span class="token operator">=</span> barrier<span class="token punctuation">.</span>wait<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">if</span> i <span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>
<span class="token comment" spellcheck="true"># Only one thread needs to print this</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"passed the barrier"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果创建栅栏对象时在构造函数中提供了 <em>action</em> 参数，它将在其中一个线程释放前被调用。如果此调用引发了异常，栅栏对象将进入损坏态。</p>
<p>如果发生了超时，栅栏对象将进入破损态。</p>
<p>如果栅栏对象进入破损态，或重置栅栏时仍有线程等待释放，将会引发 <code>BrokenBarrierError</code> 异常。</p>
</li>
<li><p><code>reset</code>()</p>
<p>重置栅栏为默认的初始态。如果栅栏中仍有线程等待释放，这些线程将会收到 <code>BrokenBarrierError</code> 异常。</p>
<p>请注意使用此函数时，如果存在状态未知的其他线程，则可能需要执行外部同步。 如果栅栏已损坏则最好将其废弃并新建一个。</p>
</li>
<li><p><code>abort</code>()</p>
<p>使栅栏处于损坏状态。 这将导致任何现有和未来对 <code>wait()</code> 的调用失败并引发 <code>BrokenBarrierError</code>。 例如可以在需要中止某个线程时使用此方法，以避免应用程序的死锁。</p>
<p>更好的方式是：创建栅栏时提供一个合理的超时时间，来自动避免某个线程出错。</p>
</li>
<li><p><code>parties</code></p>
<p>冲出栅栏所需要的线程数量。</p>
</li>
<li><p><code>n_waiting</code></p>
<p>当前时刻正在栅栏中阻塞的线程数量。</p>
</li>
<li><p><code>broken</code></p>
<p>一个布尔值，值为 <code>True</code> 表明栅栏为破损态。</p>
</li>
</ul>
<p><em>exception</em><code>threading.BrokenBarrierError</code></p>
<p>异常类，是 <code>RuntimeError</code> 异常的子类，在 <code>Barrier</code> 对象重置时仍有线程阻塞时和对象进入破损态时被引发。</p>
<h3 id="在-with-语句中使用锁、条件和信号量"><a href="#在-with-语句中使用锁、条件和信号量" class="headerlink" title="在 with 语句中使用锁、条件和信号量"></a>在 <code>with</code> 语句中使用锁、条件和信号量</h3><p>这个模块提供的带有 <code>acquire()</code> 和 <code>release()</code> 方法的对象，可以被用作 <code>with</code> 语句的上下文管理器。当进入语句块时 <code>acquire()</code> 方法会被调用，退出语句块时 <code>release()</code> 会被调用。因此，以下片段:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">with</span> some_lock<span class="token punctuation">:</span>
<span class="token comment" spellcheck="true"># do something...</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>相当于:</p>
<pre class="line-numbers language-python"><code class="language-python">some_lock<span class="token punctuation">.</span>acquire<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">try</span><span class="token punctuation">:</span>
<span class="token comment" spellcheck="true"># do something...</span>
<span class="token keyword">finally</span><span class="token punctuation">:</span>
    some_lock<span class="token punctuation">.</span>release<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>现在 <code>Lock</code> 、 <code>RLock</code> 、 <code>Condition</code> 、 <code>Semaphore</code> 和 <code>BoundedSemaphore</code> 对象可以用作 <code>with</code> 语句的上下文管理器。</p>
<h2 id="multiprocessing-—-基于进程的并行"><a href="#multiprocessing-—-基于进程的并行" class="headerlink" title="multiprocessing —- 基于进程的并行"></a><code>multiprocessing</code> —- 基于进程的并行</h2><p><strong>源代码</strong> <a href="https://github.com/python/cpython/tree/3.10/Lib/multiprocessing/" target="_blank" rel="noopener">Lib/multiprocessing/</a></p>
<hr>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><code>multiprocessing</code> 是一个支持使用与 <code>threading</code> 模块类似的 API 来产生进程的包。 <code>multiprocessing</code> 包同时提供了本地和远程并发操作，通过使用子进程而非线程有效地绕过了 全局解释器锁。 因此，<code>multiprocessing</code> 模块允许程序员充分利用给定机器上的多个处理器。 它在 Unix 和 Windows 上均可运行。</p>
<p><code>multiprocessing</code> 模块还引入了在 <code>threading</code> 模块中没有的API。一个主要的例子就是 <code>Pool</code> 对象，它提供了一种快捷的方法，赋予函数并行化处理一系列输入值的能力，可以将输入数据分配给不同进程处理（数据并行）。下面的例子演示了在模块中定义此类函数的常见做法，以便子进程可以成功导入该模块。这个数据并行的基本例子使用了 <code>Pool</code> ，</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> multiprocessing <span class="token keyword">import</span> Pool
<span class="token keyword">def</span> <span class="token function">f</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">return</span> x<span class="token operator">*</span>x
<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>
    <span class="token keyword">with</span> Pool<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span> <span class="token keyword">as</span> p<span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>map<span class="token punctuation">(</span>f<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>将在标准输出中打印</p>
<pre><code>[1, 4, 9]</code></pre><h4 id="Process-类"><a href="#Process-类" class="headerlink" title="Process 类"></a><code>Process</code> 类</h4><p>在 <code>multiprocessing</code> 中，通过创建一个 <code>Process</code> 对象然后调用它的 <code>start()</code> 方法来生成进程。 <code>Process</code> 和 <code>threading.Thread</code> API 相同。 一个简单的多进程程序示例是:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> multiprocessing <span class="token keyword">import</span> Process
<span class="token keyword">def</span> <span class="token function">f</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'hello'</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span>
<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>
    p <span class="token operator">=</span> Process<span class="token punctuation">(</span>target<span class="token operator">=</span>f<span class="token punctuation">,</span> args<span class="token operator">=</span><span class="token punctuation">(</span><span class="token string">'bob'</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    p<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>
    p<span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>要显示所涉及的各个进程ID，这是一个扩展示例:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> multiprocessing <span class="token keyword">import</span> Process
<span class="token keyword">import</span> os
<span class="token keyword">def</span> <span class="token function">info</span><span class="token punctuation">(</span>title<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>title<span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'module name:'</span><span class="token punctuation">,</span> __name__<span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'parent process:'</span><span class="token punctuation">,</span> os<span class="token punctuation">.</span>getppid<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'process id:'</span><span class="token punctuation">,</span> os<span class="token punctuation">.</span>getpid<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">f</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">:</span>
    info<span class="token punctuation">(</span><span class="token string">'function f'</span><span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'hello'</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span>
<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>
    info<span class="token punctuation">(</span><span class="token string">'main line'</span><span class="token punctuation">)</span>
    p <span class="token operator">=</span> Process<span class="token punctuation">(</span>target<span class="token operator">=</span>f<span class="token punctuation">,</span> args<span class="token operator">=</span><span class="token punctuation">(</span><span class="token string">'bob'</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    p<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>
    p<span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>关于为什么 <code>if __name__ == '__main__'</code> 部分是必需的解释。</p>
<h4 id="上下文和启动方法"><a href="#上下文和启动方法" class="headerlink" title="上下文和启动方法"></a>上下文和启动方法</h4><p>根据不同的平台， <code>multiprocessing</code> 支持三种启动进程的方法。这些 <em>启动方法</em> 有</p>
<blockquote>
<p><em>spawn</em></p>
<p>父进程会启动一个全新的 python 解释器进程。 子进程将只继承那些运行进程对象的 <code>run()</code> 方法所必需的资源。 特别地，来自父进程的非必需文件描述符和句柄将不会被继承。 使用此方法启动进程相比使用 <em>fork</em> 或 <em>forkserver</em> 要慢上许多。</p>
<p>可在Unix和Windows上使用。 Windows上的默认设置。</p>
<p><em>fork</em></p>
<p>父进程使用 <code>os.fork()</code> 来产生 Python 解释器分叉。子进程在开始时实际上与父进程相同。父进程的所有资源都由子进程继承。请注意，安全分叉多线程进程是棘手的。</p>
<p>只存在于Unix。Unix中的默认值。</p>
<p><em>forkserver</em></p>
<p>程序启动并选择* forkserver * 启动方法时，将启动服务器进程。从那时起，每当需要一个新进程时，父进程就会连接到服务器并请求它分叉一个新进程。分叉服务器进程是单线程的，因此使用 <code>os.fork()</code> 是安全的。没有不必要的资源被继承。</p>
<p>可在Unix平台上使用，支持通过Unix管道传递文件描述符。</p>
</blockquote>
<p>在 3.8 版更改: 对于 macOS，<em>spawn</em> 启动方式是默认方式。 因为 <em>fork</em> 可能导致subprocess崩溃，被认为是不安全的，查看 <a href="https://bugs.python.org/issue33725" target="_blank" rel="noopener">bpo-33725</a> 。</p>
<p>在 3.4 版更改: 在所有unix平台上添加支持了 <em>spawn</em> ，并且为一些unix平台添加了 <em>forkserver</em> 。在Windows上子进程不再继承所有可继承的父进程句柄。</p>
<p>在 Unix 上通过 <em>spawn</em> 和 <em>forkserver</em> 方式启动多进程会同时启动一个 <em>资源追踪</em> 进程，负责追踪当前程序的进程产生的、并且不再被使用的命名系统资源(如命名信号量以及 <code>SharedMemory</code> 对象)。当所有进程退出后，资源追踪会负责释放这些仍被追踪的的对象。通常情况下是不会有这种对象的，但是假如一个子进程被某个信号杀死，就可能存在这一类资源的“泄露”情况。（泄露的信号量以及共享内存不会被释放，直到下一次系统重启，对于这两类资源来说，这是一个比较大的问题，因为操作系统允许的命名信号量的数量是有限的，而共享内存也会占据主内存的一片空间）</p>
<p>要选择一个启动方法，你应该在主模块的 <code>if __name__ == '__main__'</code> 子句中调用 <code>set_start_method()</code> 。例如：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> multiprocessing <span class="token keyword">as</span> mp
<span class="token keyword">def</span> <span class="token function">foo</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">:</span>
    q<span class="token punctuation">.</span>put<span class="token punctuation">(</span><span class="token string">'hello'</span><span class="token punctuation">)</span>
<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>
    mp<span class="token punctuation">.</span>set_start_method<span class="token punctuation">(</span><span class="token string">'spawn'</span><span class="token punctuation">)</span>
    q <span class="token operator">=</span> mp<span class="token punctuation">.</span>Queue<span class="token punctuation">(</span><span class="token punctuation">)</span>
    p <span class="token operator">=</span> mp<span class="token punctuation">.</span>Process<span class="token punctuation">(</span>target<span class="token operator">=</span>foo<span class="token punctuation">,</span> args<span class="token operator">=</span><span class="token punctuation">(</span>q<span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    p<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>q<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    p<span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在程序中 <code>set_start_method()</code> 不应该被多次调用。</p>
<p>或者，你可以使用 <code>get_context()</code> 来获取上下文对象。上下文对象与 multiprocessing 模块具有相同的API，并允许在同一程序中使用多种启动方法。:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> multiprocessing <span class="token keyword">as</span> mp
<span class="token keyword">def</span> <span class="token function">foo</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">:</span>
    q<span class="token punctuation">.</span>put<span class="token punctuation">(</span><span class="token string">'hello'</span><span class="token punctuation">)</span>
<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>
    ctx <span class="token operator">=</span> mp<span class="token punctuation">.</span>get_context<span class="token punctuation">(</span><span class="token string">'spawn'</span><span class="token punctuation">)</span>
    q <span class="token operator">=</span> ctx<span class="token punctuation">.</span>Queue<span class="token punctuation">(</span><span class="token punctuation">)</span>
    p <span class="token operator">=</span> ctx<span class="token punctuation">.</span>Process<span class="token punctuation">(</span>target<span class="token operator">=</span>foo<span class="token punctuation">,</span> args<span class="token operator">=</span><span class="token punctuation">(</span>q<span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    p<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>q<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    p<span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>请注意，对象在不同上下文创建的进程间可能并不兼容。 特别是，使用 <em>fork</em> 上下文创建的锁不能传递给使用 <em>spawn</em> 或 <em>forkserver</em> 启动方法启动的进程。</p>
<p>想要使用特定启动方法的库应该使用 <code>get_context()</code> 以避免干扰库用户的选择。</p>
<p>警告</p>
<p><code>'spawn'</code> 和 <code>'forkserver'</code> 启动方法当前不能在Unix上和“冻结的”可执行内容一同使用（例如，有类似 <strong>PyInstaller</strong> 和 <strong>cx_Freeze</strong> 的包产生的二进制文件）。 <code>'fork'</code> 启动方法可以使用。</p>
<h4 id="在进程之间交换对象"><a href="#在进程之间交换对象" class="headerlink" title="在进程之间交换对象"></a>在进程之间交换对象</h4><p><code>multiprocessing</code> 支持进程之间的两种通信通道：</p>
<p><strong>队列</strong></p>
<blockquote>
<p><code>Queue</code> 类是一个近似 <code>queue.Queue</code> 的克隆。 例如:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> multiprocessing <span class="token keyword">import</span> Process<span class="token punctuation">,</span> Queue
<span class="token keyword">def</span> <span class="token function">f</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">:</span>
    q<span class="token punctuation">.</span>put<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">42</span><span class="token punctuation">,</span> None<span class="token punctuation">,</span> <span class="token string">'hello'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>
    q <span class="token operator">=</span> Queue<span class="token punctuation">(</span><span class="token punctuation">)</span>
    p <span class="token operator">=</span> Process<span class="token punctuation">(</span>target<span class="token operator">=</span>f<span class="token punctuation">,</span> args<span class="token operator">=</span><span class="token punctuation">(</span>q<span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    p<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>q<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># prints "[42, None, 'hello']"</span>
    p<span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>队列是线程和进程安全的。</p>
</blockquote>
<p><strong>管道</strong></p>
<blockquote>
<p><code>Pipe()</code> 函数返回一个由管道连接的连接对象，默认情况下是双工（双向）。例如:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> multiprocessing <span class="token keyword">import</span> Process<span class="token punctuation">,</span> Pipe
<span class="token keyword">def</span> <span class="token function">f</span><span class="token punctuation">(</span>conn<span class="token punctuation">)</span><span class="token punctuation">:</span>
    conn<span class="token punctuation">.</span>send<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">42</span><span class="token punctuation">,</span> None<span class="token punctuation">,</span> <span class="token string">'hello'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
    conn<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>
    parent_conn<span class="token punctuation">,</span> child_conn <span class="token operator">=</span> Pipe<span class="token punctuation">(</span><span class="token punctuation">)</span>
    p <span class="token operator">=</span> Process<span class="token punctuation">(</span>target<span class="token operator">=</span>f<span class="token punctuation">,</span> args<span class="token operator">=</span><span class="token punctuation">(</span>child_conn<span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    p<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>parent_conn<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true"># prints "[42, None, 'hello']"</span>
    p<span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>返回的两个连接对象 <code>Pipe()</code> 表示管道的两端。每个连接对象都有 <code>send()</code> 和 <code>recv()</code> 方法（相互之间的）。请注意，如果两个进程（或线程）同时尝试读取或写入管道的 <em>同一</em> 端，则管道中的数据可能会损坏。当然，在不同进程中同时使用管道的不同端的情况下不存在损坏的风险。</p>
</blockquote>
<h4 id="进程间同步"><a href="#进程间同步" class="headerlink" title="进程间同步"></a>进程间同步</h4><p><code>multiprocessing</code> 包含来自 <code>threading</code> 的所有同步原语的等价物。例如，可以使用锁来确保一次只有一个进程打印到标准输出:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> multiprocessing <span class="token keyword">import</span> Process<span class="token punctuation">,</span> Lock
<span class="token keyword">def</span> <span class="token function">f</span><span class="token punctuation">(</span>l<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">:</span>
    l<span class="token punctuation">.</span>acquire<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">try</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'hello world'</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span>
    <span class="token keyword">finally</span><span class="token punctuation">:</span>
        l<span class="token punctuation">.</span>release<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>
    lock <span class="token operator">=</span> Lock<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">for</span> num <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        Process<span class="token punctuation">(</span>target<span class="token operator">=</span>f<span class="token punctuation">,</span> args<span class="token operator">=</span><span class="token punctuation">(</span>lock<span class="token punctuation">,</span> num<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>不使用锁的情况下，来自于多进程的输出很容易产生混淆。</p>
<h4 id="进程间共享状态"><a href="#进程间共享状态" class="headerlink" title="进程间共享状态"></a>进程间共享状态</h4><p>如上所述，在进行并发编程时，通常最好尽量避免使用共享状态。使用多个进程时尤其如此。</p>
<p>但是，如果你真的需要使用一些共享数据，那么 <code>multiprocessing</code> 提供了两种方法。</p>
<p><strong>共享内存</strong></p>
<blockquote>
<p>可以使用 <code>Value</code> 或 <code>Array</code> 将数据存储在共享内存映射中。例如，以下代码:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> multiprocessing <span class="token keyword">import</span> Process<span class="token punctuation">,</span> Value<span class="token punctuation">,</span> Array
<span class="token keyword">def</span> <span class="token function">f</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">:</span>
    n<span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token number">3.1415927</span>
    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>
    num <span class="token operator">=</span> Value<span class="token punctuation">(</span><span class="token string">'d'</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">)</span>
    arr <span class="token operator">=</span> Array<span class="token punctuation">(</span><span class="token string">'i'</span><span class="token punctuation">,</span> range<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    p <span class="token operator">=</span> Process<span class="token punctuation">(</span>target<span class="token operator">=</span>f<span class="token punctuation">,</span> args<span class="token operator">=</span><span class="token punctuation">(</span>num<span class="token punctuation">,</span> arr<span class="token punctuation">)</span><span class="token punctuation">)</span>
    p<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>
    p<span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>num<span class="token punctuation">.</span>value<span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>将打印</p>
<pre><code>3.1415927
[0, -1, -2, -3, -4, -5, -6, -7, -8, -9]</code></pre><p>创建 <code>num</code> 和 <code>arr</code> 时使用的 <code>'d'</code> 和 <code>'i'</code> 参数是 <code>array</code> 模块使用的类型的 typecode ： <code>'d'</code> 表示双精度浮点数， <code>'i'</code> 表示有符号整数。这些共享对象将是进程和线程安全的。</p>
<p>为了更灵活地使用共享内存，可以使用 <code>multiprocessing.sharedctypes</code> 模块，该模块支持创建从共享内存分配的任意ctypes对象。</p>
</blockquote>
<p><strong>服务进程</strong></p>
<blockquote>
<p>由 <code>Manager()</code> 返回的管理器对象控制一个服务进程，该进程保存Python对象并允许其他进程使用代理操作它们。</p>
<p><code>Manager()</code> 返回的管理器支持类型： <code>list</code> 、 <code>dict</code> 、 <code>Namespace</code> 、 <code>Lock</code> 、 <code>RLock</code> 、 <code>Semaphore</code> 、 <code>BoundedSemaphore</code> 、 <code>Condition</code> 、 <code>Event</code> 、 <code>Barrier</code> 、 <code>Queue</code> 、 <code>Value</code> 和 <code>Array</code> 。例如</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> multiprocessing <span class="token keyword">import</span> Process<span class="token punctuation">,</span> Manager
<span class="token keyword">def</span> <span class="token function">f</span><span class="token punctuation">(</span>d<span class="token punctuation">,</span> l<span class="token punctuation">)</span><span class="token punctuation">:</span>
    d<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'1'</span>
    d<span class="token punctuation">[</span><span class="token string">'2'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">2</span>
    d<span class="token punctuation">[</span><span class="token number">0.25</span><span class="token punctuation">]</span> <span class="token operator">=</span> None
    l<span class="token punctuation">.</span>reverse<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>
    <span class="token keyword">with</span> Manager<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">as</span> manager<span class="token punctuation">:</span>
        d <span class="token operator">=</span> manager<span class="token punctuation">.</span>dict<span class="token punctuation">(</span><span class="token punctuation">)</span>
        l <span class="token operator">=</span> manager<span class="token punctuation">.</span>list<span class="token punctuation">(</span>range<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        p <span class="token operator">=</span> Process<span class="token punctuation">(</span>target<span class="token operator">=</span>f<span class="token punctuation">,</span> args<span class="token operator">=</span><span class="token punctuation">(</span>d<span class="token punctuation">,</span> l<span class="token punctuation">)</span><span class="token punctuation">)</span>
        p<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>
        p<span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span>l<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>将打印</p>
<pre><code>{0.25: None, 1: '1', '2': 2}
[9, 8, 7, 6, 5, 4, 3, 2, 1, 0]</code></pre><p>使用服务进程的管理器比使用共享内存对象更灵活，因为它们可以支持任意对象类型。此外，单个管理器可以通过网络由不同计算机上的进程共享。但是，它们比使用共享内存慢。</p>
</blockquote>
<h4 id="使用工作进程"><a href="#使用工作进程" class="headerlink" title="使用工作进程"></a>使用工作进程</h4><p><code>Pool</code> 类表示一个工作进程池。它具有允许以几种不同方式将任务分配到工作进程的方法。</p>
<p>例如：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> multiprocessing <span class="token keyword">import</span> Pool<span class="token punctuation">,</span> TimeoutError
<span class="token keyword">import</span> time
<span class="token keyword">import</span> os
<span class="token keyword">def</span> <span class="token function">f</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">return</span> x<span class="token operator">*</span>x
<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>
    <span class="token comment" spellcheck="true"># start 4 worker processes</span>
    <span class="token keyword">with</span> Pool<span class="token punctuation">(</span>processes<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token keyword">as</span> pool<span class="token punctuation">:</span>
        <span class="token comment" spellcheck="true"># print "[0, 1, 4,..., 81]"</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span>pool<span class="token punctuation">.</span>map<span class="token punctuation">(</span>f<span class="token punctuation">,</span> range<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token comment" spellcheck="true"># print same numbers in arbitrary order</span>
        <span class="token keyword">for</span> i <span class="token keyword">in</span> pool<span class="token punctuation">.</span>imap_unordered<span class="token punctuation">(</span>f<span class="token punctuation">,</span> range<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">print</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>
        <span class="token comment" spellcheck="true"># evaluate "f(20)" asynchronously</span>
        res <span class="token operator">=</span> pool<span class="token punctuation">.</span>apply_async<span class="token punctuation">(</span>f<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">)</span>      <span class="token comment" spellcheck="true"># runs in *only* one process</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span>res<span class="token punctuation">.</span>get<span class="token punctuation">(</span>timeout<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>             <span class="token comment" spellcheck="true"># prints "400"</span>
        <span class="token comment" spellcheck="true"># evaluate "os.getpid()" asynchronously</span>
        res <span class="token operator">=</span> pool<span class="token punctuation">.</span>apply_async<span class="token punctuation">(</span>os<span class="token punctuation">.</span>getpid<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># runs in *only* one process</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span>res<span class="token punctuation">.</span>get<span class="token punctuation">(</span>timeout<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>             <span class="token comment" spellcheck="true"># prints the PID of that process</span>
        <span class="token comment" spellcheck="true"># launching multiple evaluations asynchronously *may* use more processes</span>
        multiple_results <span class="token operator">=</span> <span class="token punctuation">[</span>pool<span class="token punctuation">.</span>apply_async<span class="token punctuation">(</span>os<span class="token punctuation">.</span>getpid<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token punctuation">[</span>res<span class="token punctuation">.</span>get<span class="token punctuation">(</span>timeout<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">for</span> res <span class="token keyword">in</span> multiple_results<span class="token punctuation">]</span><span class="token punctuation">)</span>
        <span class="token comment" spellcheck="true"># make a single worker sleep for 10 secs</span>
        res <span class="token operator">=</span> pool<span class="token punctuation">.</span>apply_async<span class="token punctuation">(</span>time<span class="token punctuation">.</span>sleep<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">try</span><span class="token punctuation">:</span>
            <span class="token keyword">print</span><span class="token punctuation">(</span>res<span class="token punctuation">.</span>get<span class="token punctuation">(</span>timeout<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">except</span> TimeoutError<span class="token punctuation">:</span>
            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"We lacked patience and got a multiprocessing.TimeoutError"</span><span class="token punctuation">)</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"For the moment, the pool remains available for more work"</span><span class="token punctuation">)</span>
    <span class="token comment" spellcheck="true"># exiting the 'with'-block has stopped the pool</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Now the pool is closed and no longer available"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>请注意，进程池的方法只能由创建它的进程使用。</p>
<p>注解</p>
<p>这个包中的功能要求子进程可以导入 <code>__main__</code> 模块。虽然这在 编程指导 中有描述，但还是需要提前说明一下。这意味着一些示例在交互式解释器中不起作用，比如 <code>multiprocessing.pool.Pool</code> 示例。例如:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> multiprocessing <span class="token keyword">import</span> Pool
<span class="token operator">>></span><span class="token operator">></span> p <span class="token operator">=</span> Pool<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">def</span> <span class="token function">f</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">return</span> x<span class="token operator">*</span>x
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">with</span> p<span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>   p<span class="token punctuation">.</span>map<span class="token punctuation">(</span>f<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
Process PoolWorker<span class="token number">-1</span><span class="token punctuation">:</span>
Process PoolWorker<span class="token number">-2</span><span class="token punctuation">:</span>
Process PoolWorker<span class="token number">-3</span><span class="token punctuation">:</span>
Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>
AttributeError<span class="token punctuation">:</span> <span class="token string">'module'</span> object has no attribute <span class="token string">'f'</span>
AttributeError<span class="token punctuation">:</span> <span class="token string">'module'</span> object has no attribute <span class="token string">'f'</span>
AttributeError<span class="token punctuation">:</span> <span class="token string">'module'</span> object has no attribute <span class="token string">'f'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>（如果尝试执行上面的代码，它会以一种半随机的方式将三个完整的堆栈内容交替输出，然后你只能以某种方式停止父进程。)</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><code>multiprocessing</code> 包主要复制了 <code>threading</code> 模块的API。</p>
<h4 id="Process-和异常"><a href="#Process-和异常" class="headerlink" title="Process 和异常"></a><code>Process</code> 和异常</h4><p><em>class</em> <code>multiprocessing.Process</code>(<em>group=None</em>, <em>target=None</em>, <em>name=None</em>, <em>args=()</em>, <em>kwargs={}</em>, <em>**,</em> daemon=None*)</p>
<p>进程对象表示在单独进程中运行的活动。 <code>Process</code> 类拥有和 <code>threading.Thread</code> 等价的大部分方法。</p>
<p>应始终使用关键字参数调用构造函数。 <em>group</em> 应该始终是 <code>None</code> ；它仅用于兼容 <code>threading.Thread</code> 。 <em>target</em> 是由 <code>run()</code> 方法调用的可调用对象。它默认为 <code>None</code> ，意味着什么都没有被调用。 <em>name</em> 是进程名称。 <em>args</em> 是目标调用的参数元组。 <em>kwargs</em> 是目标调用的关键字参数字典。如果提供，则键参数 <em>daemon</em> 将进程 <code>daemon</code> 标志设置为 <code>True</code> 或 <code>False</code> 。如果是 <code>None</code> （默认值），则该标志将从创建的进程继承。</p>
<p>默认情况下，不会将任何参数传递给 <em>target</em> 。</p>
<p>如果子类重写构造函数，它必须确保它在对进程执行任何其他操作之前调用基类构造函数（ <code>Process.__init__()</code> ）。</p>
<p>在 3.3 版更改: 加入 <em>daemon</em> 参数。</p>
<ul>
<li><p><code>run</code>()</p>
<p>表示进程活动的方法。</p>
<p>你可以在子类中重载此方法。标准 <code>run()</code> 方法调用传递给对象构造函数的可调用对象作为目标参数（如果有），分别从 <em>args</em> 和 <em>kwargs</em> 参数中获取顺序和关键字参数。</p>
</li>
<li><p><code>start</code>()</p>
<p>启动进程活动。</p>
<p>这个方法每个进程对象最多只能调用一次。它会将对象的 <code>run()</code> 方法安排在一个单独的进程中调用。</p>
</li>
<li><p><code>join</code>([<em>timeout</em>])</p>
<p>如果可选参数 <em>timeout</em> 是 <code>None</code> （默认值），则该方法将阻塞，直到调用 <code>join()</code> 方法的进程终止。如果 <em>timeout</em> 是一个正数，它最多会阻塞 <em>timeout</em> 秒。请注意，如果进程终止或方法超时，则该方法返回 <code>None</code> 。检查进程的 <code>exitcode</code> 以确定它是否终止。</p>
<p>一个进程可以被 join 多次。</p>
<p>进程无法join自身，因为这会导致死锁。尝试在启动进程之前join进程是错误的。</p>
</li>
<li><p><code>name</code></p>
<p>进程的名称。该名称是一个字符串，仅用于识别目的。它没有语义。可以为多个进程指定相同的名称。</p>
<p>初始名称由构造器设定。 如果没有为构造器提供显式名称，则会构造一个形式为 ‘Process-N1:N2:…:Nk’ 的名称，其中每个 Nk 是其父亲的第 N 个孩子。</p>
</li>
<li><p><code>is_alive</code>()</p>
<p>返回进程是否还活着。</p>
<p>粗略地说，从 <code>start()</code> 方法返回到子进程终止之前，进程对象仍处于活动状态。</p>
</li>
<li><p><code>daemon</code></p>
<p>进程的守护标志，一个布尔值。这必须在 <code>start()</code> 被调用之前设置。</p>
<p>初始值继承自创建进程。</p>
<p>当进程退出时，它会尝试终止其所有守护进程子进程。</p>
<p>请注意，不允许在守护进程中创建子进程。这是因为当守护进程由于父进程退出而中断时，其子进程会变成孤儿进程。 另外，这些 <strong>不是</strong> Unix 守护进程或服务，它们是正常进程，如果非守护进程已经退出，它们将被终止（并且不被合并）。</p>
</li>
</ul>
<p>除了 <code>threading.Thread</code> API ，<code>Process</code> 对象还支持以下属性和方法：</p>
<ul>
<li><p><code>pid</code></p>
<p>返回进程ID。在生成该进程之前，这将是 <code>None</code> 。</p>
</li>
<li><p><code>exitcode</code></p>
<p>子进程的退出代码。如果进程尚未终止，这将是 <code>None</code> 。负值 <em>-N</em> 表示子进程被信号 <em>N</em> 终止。</p>
</li>
<li><p><code>authkey</code></p>
<p>进程的身份验证密钥（字节字符串）。</p>
<p>当 <code>multiprocessing</code> 初始化时，主进程使用 <code>os.urandom()</code> 分配一个随机字符串。</p>
<p>当创建 <code>Process</code> 对象时，它将继承其父进程的身份验证密钥，尽管可以通过将 <code>authkey</code> 设置为另一个字节字符串来更改。</p>
</li>
<li><p><code>sentinel</code></p>
<p>系统对象的数字句柄，当进程结束时将变为 “ready” 。</p>
<p>如果要使用 <code>multiprocessing.connection.wait()</code> 一次等待多个事件，可以使用此值。否则调用 <code>join()</code> 更简单。</p>
<p>在Windows上，这是一个操作系统句柄，可以与 <code>WaitForSingleObject</code> 和 <code>WaitForMultipleObjects</code> 系列API调用一起使用。在Unix上，这是一个文件描述符，可以使用来自 <code>select</code> 模块的原语。</p>
<p>3.3 新版功能.</p>
</li>
<li><p><code>terminate</code>()</p>
<p>终止进程。 在Unix上，这是使用 <code>SIGTERM</code> 信号完成的；在Windows上使用 <code>TerminateProcess()</code> 。 请注意，不会执行退出处理程序和finally子句等。</p>
<p>请注意，进程的后代进程将不会被终止 —— 它们将简单地变成孤立的。</p>
<p>警告</p>
<p>如果在关联进程使用管道或队列时使用此方法，则管道或队列可能会损坏，并可能无法被其他进程使用。类似地，如果进程已获得锁或信号量等，则终止它可能导致其他进程死锁。</p>
</li>
<li><p><code>kill</code>()</p>
<p>与 <code>terminate()</code> 相同，但在Unix上使用 <code>SIGKILL</code> 信号。</p>
<p>3.7 新版功能.</p>
</li>
<li><p><code>close</code>()</p>
<p>关闭 <code>Process</code> 对象，释放与之关联的所有资源。如果底层进程仍在运行，则会引发 <code>ValueError</code> 。一旦 <code>close()</code> 成功返回， <code>Process</code> 对象的大多数其他方法和属性将引发 <code>ValueError</code> 。</p>
<p>3.7 新版功能.</p>
</li>
</ul>
<p>注意 <code>start()</code> 、 <code>join()</code> 、 <code>is_alive()</code> 、 <code>terminate()</code> 和 <code>exitcode</code> 方法只能由创建进程对象的进程调用。</p>
<p><code>Process</code> 一些方法的示例用法：</p>
<pre class="line-numbers language-python"><code class="language-python"> <span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> multiprocessing<span class="token punctuation">,</span> time<span class="token punctuation">,</span> signal
 <span class="token operator">>></span><span class="token operator">></span> p <span class="token operator">=</span> multiprocessing<span class="token punctuation">.</span>Process<span class="token punctuation">(</span>target<span class="token operator">=</span>time<span class="token punctuation">.</span>sleep<span class="token punctuation">,</span> args<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
 <span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> p<span class="token punctuation">.</span>is_alive<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
 <span class="token operator">&lt;</span>Process <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> initial<span class="token operator">></span> <span class="token boolean">False</span>
 <span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>
 <span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> p<span class="token punctuation">.</span>is_alive<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
 <span class="token operator">&lt;</span>Process <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> started<span class="token operator">></span> <span class="token boolean">True</span>
 <span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>terminate<span class="token punctuation">(</span><span class="token punctuation">)</span>
 <span class="token operator">>></span><span class="token operator">></span> time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">0.1</span><span class="token punctuation">)</span>
 <span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> p<span class="token punctuation">.</span>is_alive<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
 <span class="token operator">&lt;</span>Process <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> stopped exitcode<span class="token operator">=</span><span class="token operator">-</span>SIGTERM<span class="token operator">></span> <span class="token boolean">False</span>
 <span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>exitcode <span class="token operator">==</span> <span class="token operator">-</span>signal<span class="token punctuation">.</span>SIGTERM
 <span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><em>exception</em> <code>multiprocessing.ProcessError</code></p>
<p>所有 <code>multiprocessing</code> 异常的基类。</p>
<p><em>exception</em> <code>multiprocessing.BufferTooShort</code></p>
<p>当提供的缓冲区对象太小而无法读取消息时， <code>Connection.recv_bytes_into()</code> 引发的异常。</p>
<p>如果 <code>e</code> 是一个 <code>BufferTooShort</code> 实例，那么 <code>e.args[0]</code> 将把消息作为字节字符串给出。</p>
<p><em>exception</em> <code>multiprocessing.AuthenticationError</code></p>
<p>出现身份验证错误时引发。</p>
<p><em>exception</em> <code>multiprocessing.TimeoutError</code></p>
<p>有超时的方法超时时引发。</p>
<h4 id="管道和队列"><a href="#管道和队列" class="headerlink" title="管道和队列"></a>管道和队列</h4><p>使用多进程时，一般使用消息机制实现进程间通信，尽可能避免使用同步原语，例如锁。</p>
<p>消息机制包含： <code>Pipe()</code> (可以用于在两个进程间传递消息)，以及队列(能够在多个生产者和消费者之间通信)。</p>
<p><code>Queue</code>, <code>SimpleQueue</code> 以及 <code>JoinableQueue</code> 都是多生产者，多消费者，并且实现了 FIFO 的队列类型，其表现与标准库中的 <code>queue.Queue</code> 类相似。 不同之处在于 <code>Queue</code> 缺少标准库的 <code>queue.Queue</code> 从 Python 2.5 开始引入的 <code>task_done()</code> 和 <code>join()</code> 方法。</p>
<p>如果你使用了 <code>JoinableQueue</code> ，那么你 <strong>必须</strong> 对每个已经移出队列的任务调用 <code>JoinableQueue.task_done()</code>。 不然的话用于统计未完成任务的信号量最终会溢出并抛出异常。</p>
<p>另外还可以通过使用一个管理器对象创建一个共享队列 。</p>
<p>注解</p>
<p><code>multiprocessing</code> 使用了普通的 <code>queue.Empty</code> 和 <code>queue.Full</code> 异常去表示超时。 你需要从 <code>queue</code> 中导入它们，因为它们并不在 <code>multiprocessing</code> 的命名空间中。</p>
<p>注解</p>
<p>当一个对象被放入一个队列中时，这个对象首先会被一个后台线程用 pickle 序列化，并将序列化后的数据通过一个底层管道的管道传递到队列中。 这种做法会有点让人惊讶，但一般不会出现什么问题。 如果它们确实妨碍了你，你可以使用一个由管理器 manager 创建的队列替换它。</p>
<ol>
<li>将一个对象放入一个空队列后，可能需要极小的延迟，队列的方法 <code>empty()</code> 才会返回 <code>False</code> 。而 <code>get_nowait()</code> 可以不抛出 <code>queue.Empty</code> 直接返回。</li>
<li>如果有多个进程同时将对象放入队列，那么在队列的另一端接受到的对象可能是无序的。但是由同一个进程放入的多个对象的顺序在另一端输出时总是一样的。</li>
</ol>
<p>警告</p>
<p>如果一个进程在尝试使用 <code>Queue</code> 期间被 <code>Process.terminate()</code> 或 <code>os.kill()</code> 调用终止了，那么队列中的数据很可能被破坏。 这可能导致其他进程在尝试使用该队列时发生异常。</p>
<p>警告</p>
<p>正如刚才提到的，如果一个子进程将一些对象放进队列中 (并且它没有用 <code>JoinableQueue.cancel_join_thread</code> 方法)，那么这个进程在所有缓冲区的对象被刷新进管道之前，是不会终止的。</p>
<p>这意味着，除非你确定所有放入队列中的对象都已经被消费了，否则如果你试图等待这个进程，你可能会陷入死锁中。相似地，如果该子进程不是后台进程，那么父进程可能在试图等待所有非后台进程退出时挂起。</p>
<p>注意用管理器创建的队列不存在这个问题。</p>
<p><code>multiprocessing.Pipe</code>([<em>duplex</em>])</p>
<p>返回一对 <code>Connection</code> 对象 <code>(conn1, conn2)</code> ， 分别表示管道的两端。</p>
<p>如果 <em>duplex</em> 被置为 <code>True</code> (默认值)，那么该管道是双向的。如果 <em>duplex</em> 被置为 <code>False</code> ，那么该管道是单向的，即 <code>conn1</code> 只能用于接收消息，而 <code>conn2</code> 仅能用于发送消息。</p>
<p><em>class</em> <code>multiprocessing.Queue</code>([<em>maxsize</em>])</p>
<p>返回一个使用一个管道和少量锁和信号量实现的共享队列实例。当一个进程将一个对象放进队列中时，一个写入线程会启动并将对象从缓冲区写入管道中。</p>
<p>一旦超时，将抛出标准库 <code>queue</code> 模块中常见的异常 <code>queue.Empty</code> 和 <code>queue.Full</code>。</p>
<p>除了 <code>task_done()</code> 和 <code>join()</code> 之外，<code>Queue</code> 实现了标准库类 <code>queue.Queue</code> 中所有的方法。</p>
<ul>
<li><p><code>qsize</code>()</p>
<p>返回队列的大致长度。由于多线程或者多进程的上下文，这个数字是不可靠的。</p>
<p>Note that this may raise <code>NotImplementedError</code> on Unix platforms like macOS where <code>sem_getvalue()</code> is not implemented.</p>
</li>
<li><p><code>empty</code>()</p>
<p>如果队列是空的，返回 <code>True</code> ，反之返回 <code>False</code> 。 由于多线程或多进程的环境，该状态是不可靠的。</p>
</li>
<li><p><code>full</code>()</p>
<p>如果队列是满的，返回 <code>True</code> ，反之返回 <code>False</code> 。 由于多线程或多进程的环境，该状态是不可靠的。</p>
</li>
<li><p><code>put</code>(<em>obj</em>[, <em>block</em>[, <em>timeout</em>]])</p>
<p>将 obj 放入队列。如果可选参数 <em>block</em> 是 <code>True</code> (默认值) 而且 <em>timeout</em> 是 <code>None</code> (默认值), 将会阻塞当前进程，直到有空的缓冲槽。如果 <em>timeout</em> 是正数，将会在阻塞了最多 <em>timeout</em> 秒之后还是没有可用的缓冲槽时抛出 <code>queue.Full</code> 异常。反之 (<em>block</em> 是 <code>False</code> 时)，仅当有可用缓冲槽时才放入对象，否则抛出 <code>queue.Full</code> 异常 (在这种情形下 <em>timeout</em> 参数会被忽略)。</p>
<p>在 3.8 版更改: 如果队列已经关闭，会抛出 <code>ValueError</code> 而不是 <code>AssertionError</code> 。</p>
</li>
<li><p><code>put_nowait</code>(<em>obj</em>)</p>
<p>相当于 <code>put(obj, False)</code>。</p>
</li>
<li><p><code>get</code>([<em>block</em>[, <em>timeout</em>]])</p>
<p>从队列中取出并返回对象。如果可选参数 <em>block</em> 是 <code>True</code> (默认值) 而且 <em>timeout</em> 是 <code>None</code> (默认值), 将会阻塞当前进程，直到队列中出现可用的对象。如果 <em>timeout</em> 是正数，将会在阻塞了最多 <em>timeout</em> 秒之后还是没有可用的对象时抛出 <code>queue.Empty</code> 异常。反之 (<em>block</em> 是 <code>False</code> 时)，仅当有可用对象能够取出时返回，否则抛出 <code>queue.Empty</code> 异常 (在这种情形下 <em>timeout</em> 参数会被忽略)。</p>
<p>在 3.8 版更改: 如果队列已经关闭，会抛出 <code>ValueError</code> 而不是 <code>OSError</code> 。</p>
</li>
<li><p><code>get_nowait</code>()</p>
<p>相当于 <code>get(False)</code> 。</p>
</li>
</ul>
<p><code>multiprocessing.Queue</code> 类有一些在 <code>queue.Queue</code> 类中没有出现的方法。这些方法在大多数情形下并不是必须的。</p>
<ul>
<li><p><code>close</code>()</p>
<p>指示当前进程将不会再往队列中放入对象。一旦所有缓冲区中的数据被写入管道之后，后台的线程会退出。这个方法在队列被gc回收时会自动调用。</p>
</li>
<li><p><code>join_thread</code>()</p>
<p>等待后台线程。这个方法仅在调用了 <code>close()</code> 方法之后可用。这会阻塞当前进程，直到后台线程退出，确保所有缓冲区中的数据都被写入管道中。</p>
<p>默认情况下，如果一个不是队列创建者的进程试图退出，它会尝试等待这个队列的后台线程。这个进程可以使用 <code>cancel_join_thread()</code> 让 <code>join_thread()</code> 方法什么都不做直接跳过。</p>
</li>
<li><p><code>cancel_join_thread</code>()</p>
<p>防止 <code>join_thread()</code> 方法阻塞当前进程。具体而言，这防止进程退出时自动等待后台线程退出。</p>
<p>这个方法更好的名字可能是 <code>allow_exit_without_flush()</code>。 这可能会导致已排入队列的数据丢失，几乎可以肯定你将不需要用到这个方法。 实际上它仅适用于当你需要当前进程立即退出而不必等待将已排入的队列更新到下层管道，并且你不担心丢失数据的时候。</p>
</li>
</ul>
<p>注解</p>
<p>该类的功能依赖于宿主操作系统具有可用的共享信号量实现。否则该类将被禁用，任何试图实例化一个 <code>Queue</code> 对象的操作都会抛出 <code>ImportError</code> 异常 。后续说明的任何专用队列对象亦如此。</p>
<p><em>class</em> <code>multiprocessing.SimpleQueue</code></p>
<p>这是一个简化的 <code>Queue</code> 类的实现，很像带锁的 <code>Pipe</code> 。</p>
<ul>
<li><p><code>close</code>()</p>
<p>关闭队列：释放内部资源。</p>
<p>队列在被关闭后就不可再被使用。 例如不可再调用 <code>get()</code>, <code>put()</code> 和 <code>empty()</code> 等方法。</p>
<p>3.9 新版功能.</p>
</li>
<li><p><code>empty</code>()</p>
<p>如果队列为空返回 <code>True</code> ，否则返回 <code>False</code> 。</p>
</li>
<li><p><code>get</code>()</p>
<p>从队列中移出并返回一个对象。</p>
</li>
<li><p><code>put</code>(<em>item</em>)</p>
<p>将 <em>item</em> 放入队列。</p>
</li>
</ul>
<p><em>class</em> <code>multiprocessing.JoinableQueue</code>([<em>maxsize</em>])</p>
<p><code>JoinableQueue</code> 类是 <code>Queue</code> 的子类，额外添加了 <code>task_done()</code> 和 <code>join()</code> 方法。</p>
<ul>
<li><p><code>task_done</code>()</p>
<p>指出之前进入队列的任务已经完成。由队列的消费者进程使用。对于每次调用 <code>get()</code> 获取的任务，执行完成后调用 <code>task_done()</code> 告诉队列该任务已经处理完成。</p>
<p>如果 <code>join()</code> 方法正在阻塞之中，该方法会在所有对象都被处理完的时候返回 (即对之前使用 <code>put()</code> 放进队列中的所有对象都已经返回了对应的 <code>task_done()</code> ) 。</p>
<p>如果被调用的次数多于放入队列中的项目数量，将引发 <code>ValueError</code> 异常 。</p>
</li>
<li><p><code>join</code>()</p>
<p>阻塞至队列中所有的元素都被接收和处理完毕。</p>
<p>当条目添加到队列的时候，未完成任务的计数就会增加。每当消费者进程调用 <code>task_done()</code> 表示这个条目已经被回收，该条目所有工作已经完成，未完成计数就会减少。当未完成计数降到零的时候， <code>join()</code> 阻塞被解除。</p>
</li>
</ul>
<h4 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h4><p><code>multiprocessing.active_children</code>()</p>
<p>返回当前进程存活的子进程的列表。</p>
<p>调用该方法有“等待”已经结束的进程的副作用。</p>
<p><code>multiprocessing.cpu_count</code>()</p>
<p>返回系统的CPU数量。</p>
<p>该数量不同于当前进程可以使用的CPU数量。可用的CPU数量可以由 <code>len(os.sched_getaffinity(0))</code> 方法获得。</p>
<p>When the number of CPUs cannot be determined a <code>NotImplementedError</code> is raised.</p>
<p>参见</p>
<p><code>os.cpu_count()</code></p>
<p><code>multiprocessing.current_process</code>()</p>
<p>返回与当前进程相对应的 <code>Process</code> 对象。</p>
<p>和 <code>threading.current_thread()</code> 相同。</p>
<p><code>multiprocessing.parent_process</code>()</p>
<p>返回父进程 <code>Process</code> 对象，和父进程调用 <code>current_process()</code> 返回的对象一样。如果一个进程已经是主进程， <code>parent_process</code> 会返回 <code>None</code>.</p>
<p>3.8 新版功能.</p>
<p><code>multiprocessing.freeze_support</code>()</p>
<p>为使用了 <code>multiprocessing</code> 的程序，提供冻结以产生 Windows 可执行文件的支持。(在 <strong>py2exe</strong>, <strong>PyInstaller</strong> 和 <strong>cx_Freeze</strong> 上测试通过)</p>
<p>需要在 main 模块的 <code>if __name__ == '__main__'</code> 该行之后马上调用该函数。例如：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> multiprocessing <span class="token keyword">import</span> Process<span class="token punctuation">,</span> freeze_support
<span class="token keyword">def</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'hello world!'</span><span class="token punctuation">)</span>
<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>
    freeze_support<span class="token punctuation">(</span><span class="token punctuation">)</span>
    Process<span class="token punctuation">(</span>target<span class="token operator">=</span>f<span class="token punctuation">)</span><span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果没有调用 <code>freeze_support()</code> 在尝试运行被冻结的可执行文件时会抛出 <code>RuntimeError</code> 异常。</p>
<p>对 <code>freeze_support()</code> 的调用在非 Windows 平台上是无效的。如果该模块在 Windows 平台的 Python 解释器中正常运行 (该程序没有被冻结)， 调用<code>freeze_support()</code> 也是无效的。</p>
<p><code>multiprocessing.get_all_start_methods</code>()</p>
<p>返回支持的启动方法的列表，该列表的首项即为默认选项。可能的启动方法有 <code>'fork'</code> ， <code>'spawn'</code> 和<code>‘forkserver’</code> 。在 Windows 中，只有 <code>'spawn'</code> 是可用的。 Unix 平台总是支持 <code>'fork'</code> 和 <code>'spawn'</code> ，且 <code>'fork'</code> 是默认值。</p>
<p>3.4 新版功能.</p>
<p><code>multiprocessing.get_context</code>(<em>method=None</em>)</p>
<p>返回一个 Context 对象。该对象具有和 <code>multiprocessing</code> 模块相同的API。</p>
<p>如果 <em>method</em> 设置成 <code>None</code> 那么将返回默认上下文对象。否则 <em>method</em> 应该是 <code>'fork'</code>, <code>'spawn'</code>, <code>'forkserver'</code> 。 如果指定的启动方法不存在，将抛出 <code>ValueError</code> 异常。</p>
<p>3.4 新版功能.</p>
<p><code>multiprocessing.get_start_method</code>(<em>allow_none=False</em>)</p>
<p>返回启动进程时使用的启动方法名。</p>
<p>如果启动方法已经固定，并且 <em>allow_none</em> 被设置成 False ，那么启动方法将被固定为默认的启动方法，并且返回其方法名。如果启动方法没有设定，并且 <em>allow_none</em> 被设置成 True ，那么将返回 <code>None</code> 。</p>
<p>The return value can be <code>'fork'</code>, <code>'spawn'</code>, <code>'forkserver'</code> or <code>None</code>. <code>'fork'</code> is the default on Unix, while <code>'spawn'</code> is the default on Windows and macOS.</p>
<p>在 3.8 版更改: 对于 macOS，<em>spawn</em> 启动方式是默认方式。 因为 <em>fork</em> 可能导致subprocess崩溃，被认为是不安全的，查看 <a href="https://bugs.python.org/issue33725" target="_blank" rel="noopener">bpo-33725</a> 。</p>
<p>3.4 新版功能.</p>
<p><code>multiprocessing.set_executable</code>()</p>
<p>设置在启动子进程时使用的 Python 解释器路径。 ( 默认使用 <code>sys.executable</code> ) 嵌入式编程人员可能需要这样做：</p>
<pre><code>set_executable(os.path.join(sys.exec_prefix, 'pythonw.exe'))</code></pre><p>以使他们可以创建子进程。</p>
<p>在 3.4 版更改: 现在在 Unix 平台上使用 <code>'spawn'</code> 启动方法时支持调用该方法。</p>
<p><code>multiprocessing.set_start_method</code>(<em>method</em>)</p>
<p>设置启动子进程的方法。 <em>method</em> 可以是 <code>'fork'</code> , <code>'spawn'</code> 或者 <code>'forkserver'</code> 。</p>
<p>注意这最多只能调用一次，并且需要藏在 main 模块中，由 <code>if __name__ == '__main__'</code> 保护着。</p>
<p>3.4 新版功能.</p>
<p>注解</p>
<p><code>multiprocessing</code> 并没有包含类似 <code>threading.active_count()</code> , <code>threading.enumerate()</code> , <code>threading.settrace()</code> , <code>threading.setprofile()</code>, <code>threading.Timer</code> , 或者 <code>threading.local</code> 的方法和类。</p>
<h4 id="连接对象（Connection）"><a href="#连接对象（Connection）" class="headerlink" title="连接对象（Connection）"></a>连接对象（Connection）</h4><p>Connection 对象允许收发可以序列化的对象或字符串。它们可以看作面向消息的连接套接字。</p>
<p>通常使用 <code>Pipe</code> 创建 Connection 对象。</p>
<p><em>class</em> <code>multiprocessing.connection.Connection</code></p>
<ul>
<li><p><code>send</code>(<em>obj</em>)</p>
<p>将一个对象发送到连接的另一端，可以用 <code>recv()</code> 读取。</p>
<p>发送的对象必须是可以序列化的，过大的对象 ( 接近 32MiB+ ，这个值取决于操作系统 ) 有可能引发 <code>ValueError</code> 异常。</p>
</li>
<li><p><code>recv</code>()</p>
<p>返回一个由另一端使用 <code>send()</code> 发送的对象。该方法会一直阻塞直到接收到对象。 如果对端关闭了连接或者没有东西可接收，将抛出 <code>EOFError</code> 异常。</p>
</li>
<li><p><code>fileno</code>()</p>
<p>返回由连接对象使用的描述符或者句柄。</p>
</li>
<li><p><code>close</code>()</p>
<p>关闭连接对象。</p>
<p>当连接对象被垃圾回收时会自动调用。</p>
</li>
<li><p><code>poll</code>([<em>timeout</em>])</p>
<p>返回连接对象中是否有可以读取的数据。</p>
<p>如果未指定 <em>timeout</em> ，此方法会马上返回。如果 <em>timeout</em> 是一个数字，则指定了最大阻塞的秒数。如果 <em>timeout</em> 是 <code>None</code>，那么将一直等待，不会超时。</p>
<p>注意通过使用 <code>multiprocessing.connection.wait()</code> 可以一次轮询多个连接对象。</p>
</li>
<li><p><code>send_bytes</code>(<em>buffer</em>[, <em>offset</em>[, <em>size</em>]])</p>
<p>从一个 bytes-like object 对象中取出字节数组并作为一条完整消息发送。</p>
<p>如果由 <em>offset</em> 给定了在 <em>buffer</em> 中读取数据的位置。 如果给定了 <em>size</em> ，那么将会从缓冲区中读取多个字节。 过大的缓冲区 ( 接近 32MiB+ ，此值依赖于操作系统 ) 有可能引发 <code>ValueError</code> 异常。</p>
</li>
<li><p><code>recv_bytes</code>([<em>maxlength</em>])</p>
<p>以字符串形式返回一条从连接对象另一端发送过来的字节数据。此方法在接收到数据前将一直阻塞。 如果连接对象被对端关闭或者没有数据可读取，将抛出 <code>EOFError</code> 异常。</p>
<p>如果给定了 <em>maxlength</em> 并且消息长于 <em>maxlength</em> 那么将抛出 <code>OSError</code> 并且该连接对象将不再可读。</p>
<p>在 3.3 版更改: 曾经该函数抛出 <code>IOError</code> ，现在这是 <code>OSError</code> 的别名。</p>
</li>
<li><p><code>recv_bytes_into</code>(<em>buffer</em>[, <em>offset</em>])</p>
<p>将一条完整的字节数据消息读入 <em>buffer</em> 中并返回消息的字节数。 此方法在接收到数据前将一直阻塞。 如果连接对象被对端关闭或者没有数据可读取，将抛出 <code>EOFError</code> 异常。</p>
<p><em>buffer</em> must be a writable bytes-like object. If <em>offset</em> is given then the message will be written into the buffer from that position. Offset must be a non-negative integer less than the length of <em>buffer</em> (in bytes).</p>
<p>如果缓冲区太小，则将引发 <code>BufferTooShort</code> 异常，并且完整的消息将会存放在异常实例 <code>e</code> 的 <code>e.args[0]</code> 中。</p>
</li>
</ul>
<p>在 3.3 版更改: 现在连接对象自身可以通过 <code>Connection.send()</code> 和 <code>Connection.recv()</code> 在进程之间传递。</p>
<p>3.3 新版功能: 连接对象现已支持上下文管理协议 。 <code>__enter__()</code> 返回连接对象， <code>__exit__()</code> 会调用 <code>close()</code> 。</p>
<p>例如:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> multiprocessing <span class="token keyword">import</span> Pipe
<span class="token operator">>></span><span class="token operator">></span> a<span class="token punctuation">,</span> b <span class="token operator">=</span> Pipe<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> a<span class="token punctuation">.</span>send<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'hello'</span><span class="token punctuation">,</span> None<span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> b<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'hello'</span><span class="token punctuation">,</span> None<span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> b<span class="token punctuation">.</span>send_bytes<span class="token punctuation">(</span>b<span class="token string">'thank you'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> a<span class="token punctuation">.</span>recv_bytes<span class="token punctuation">(</span><span class="token punctuation">)</span>
b<span class="token string">'thank you'</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> array
<span class="token operator">>></span><span class="token operator">></span> arr1 <span class="token operator">=</span> array<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token string">'i'</span><span class="token punctuation">,</span> range<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> arr2 <span class="token operator">=</span> array<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token string">'i'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token number">10</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> a<span class="token punctuation">.</span>send_bytes<span class="token punctuation">(</span>arr1<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> count <span class="token operator">=</span> b<span class="token punctuation">.</span>recv_bytes_into<span class="token punctuation">(</span>arr2<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">assert</span> count <span class="token operator">==</span> len<span class="token punctuation">(</span>arr1<span class="token punctuation">)</span> <span class="token operator">*</span> arr1<span class="token punctuation">.</span>itemsize
<span class="token operator">>></span><span class="token operator">></span> arr2
array<span class="token punctuation">(</span><span class="token string">'i'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>警告</p>
<p><code>Connection.recv()</code> 方法会自动解封它收到的数据，除非你能够信任发送消息的进程，否则此处可能有安全风险。</p>
<p>因此， 除非连接对象是由 <code>Pipe()</code> 产生的，否则你应该仅在使用了某种认证手段之后才使用 <code>recv()</code> 和 <code>send()</code> 方法。 </p>
<p>警告</p>
<p>如果一个进程在试图读写管道时被终止了，那么管道中的数据很可能是不完整的，因为此时可能无法确定消息的边界。</p>
<h4 id="同步原语"><a href="#同步原语" class="headerlink" title="同步原语"></a>同步原语</h4><p>通常来说同步原语在多进程环境中并不像它们在多线程环境中那么必要。</p>
<p>注意可以使用管理器对象创建同步原语。</p>
<p><em>class</em> <code>multiprocessing.Barrier</code>(<em>parties</em>[, <em>action</em>[, <em>timeout</em>]])</p>
<p>类似 <code>threading.Barrier</code> 的栅栏对象。</p>
<p>3.3 新版功能.</p>
<p><em>class</em> <code>multiprocessing.BoundedSemaphore</code>([<em>value</em>])</p>
<p>非常类似 <code>threading.BoundedSemaphore</code> 的有界信号量对象。</p>
<p>一个小小的不同在于，它的 <code>acquire</code> 方法的第一个参数名是和 <code>Lock.acquire()</code> 一样的 <em>block</em> 。</p>
<p>注解</p>
<p>On macOS, this is indistinguishable from <code>Semaphore</code> because <code>sem_getvalue()</code> is not implemented on that platform.</p>
<p><em>class</em> <code>multiprocessing.Condition</code>([<em>lock</em>])</p>
<p>条件变量： <code>threading.Condition</code> 的别名。</p>
<p>指定的 <em>lock</em> 参数应该是 <code>multiprocessing</code> 模块中的 <code>Lock</code> 或者 <code>RLock</code> 对象。</p>
<p>在 3.3 版更改: 新增了 <code>wait_for()</code> 方法。</p>
<p><em>class</em> <code>multiprocessing.Event</code></p>
<p>A clone of <code>threading.Event</code>.</p>
<p><em>class</em> <code>multiprocessing.Lock</code></p>
<p>原始锁（非递归锁）对象，类似于 <code>threading.Lock</code> 。一旦一个进程或者线程拿到了锁，后续的任何其他进程或线程的其他请求都会被阻塞直到锁被释放。任何进程或线程都可以释放锁。除非另有说明，否则 <code>multiprocessing.Lock</code> 用于进程或者线程的概念和行为都和 <code>threading.Lock</code> 一致。</p>
<p>注意 <code>Lock</code> 实际上是一个工厂函数。它返回由默认上下文初始化的 <code>multiprocessing.synchronize.Lock</code> 对象。</p>
<p><code>Lock</code> supports the context manager protocol and thus may be used in <code>with</code> statements.</p>
<ul>
<li><p><code>acquire</code>(<em>block=True</em>, <em>timeout=None</em>)</p>
<p>可以阻塞或非阻塞地获得锁。</p>
<p>如果 <em>block</em> 参数被设为 <code>True</code> ( 默认值 ) ， 对该方法的调用在锁处于释放状态之前都会阻塞，然后将锁设置为锁住状态并返回 <code>True</code> 。需要注意的是第一个参数名与 <code>threading.Lock.acquire()</code> 的不同。</p>
<p>如果 <em>block</em> 参数被设置成 <code>False</code> ，方法的调用将不会阻塞。 如果锁当前处于锁住状态，将返回 <code>False</code> ； 否则将锁设置成锁住状态，并返回 <code>True</code> 。</p>
<p>当 <em>timeout</em> 是一个正浮点数时，会在等待锁的过程中最多阻塞等待 <em>timeout</em> 秒，当 <em>timeout</em> 是负数时，效果和 <em>timeout</em> 为0时一样，当 <em>timeout</em> 是 <code>None</code> （默认值）时，等待时间是无限长。需要注意的是，对于 <em>timeout</em> 参数是负数和 <code>None</code> 的情况, 其行为与 <code>threading.Lock.acquire()</code> 是不一样的。当 <em>block</em> 参数 为 <code>False</code> 时， <em>timeout</em> 并没有实际用处，会直接忽略。否则，函数会在拿到锁后返回 <code>True</code> 或者 超时没拿到锁后返回 <code>False</code> 。</p>
</li>
<li><p><code>release</code>()</p>
<p>释放锁，可以在任何进程、线程使用，并不限于锁的拥有者。</p>
<p>当尝试释放一个没有被持有的锁时，会抛出 <code>ValueError</code> 异常，除此之外其行为与 <code>threading.Lock.release()</code> 一样。</p>
</li>
</ul>
<p><em>class</em> <code>multiprocessing.RLock</code></p>
<p>递归锁对象: 类似于 <code>threading.RLock</code> 。递归锁必须由持有线程、进程亲自释放。如果某个进程或者线程拿到了递归锁，这个进程或者线程可以再次拿到这个锁而不需要等待。但是这个进程或者线程的拿锁操作和释放锁操作的次数必须相同。</p>
<p>注意 <code>RLock</code> 是一个工厂函数，调用后返回一个使用默认 context 初始化的 <code>multiprocessing.synchronize.RLock</code> 实例。</p>
<p><code>RLock</code> 支持 context manager 协议，因此可在 <code>with</code> 语句内使用。</p>
<ul>
<li><p><code>acquire</code>(<em>block=True</em>, <em>timeout=None</em>)</p>
<p>可以阻塞或非阻塞地获得锁。</p>
<p>当 <em>block</em> 参数设置为 <code>True</code> 时，会一直阻塞直到锁处于空闲状态（没有被任何进程、线程拥有），除非当前进程或线程已经拥有了这把锁。然后当前进程/线程会持有这把锁（在锁没有其他持有者的情况下），锁内的递归等级加一，并返回 <code>True</code> . 注意， 这个函数第一个参数的行为和 <code>threading.RLock.acquire()</code> 的实现有几个不同点，包括参数名本身。</p>
<p>当 <em>block</em> 参数是 <code>False</code> , 将不会阻塞，如果此时锁被其他进程或者线程持有，当前进程、线程获取锁操作失败，锁的递归等级也不会改变，函数返回 <code>False</code> , 如果当前锁已经处于释放状态，则当前进程、线程则会拿到锁，并且锁内的递归等级加一，函数返回 <code>True</code> 。</p>
<p><em>timeout</em> 参数的使用方法及行为与 <code>Lock.acquire()</code> 一样。但是要注意 <em>timeout</em> 的其中一些行为和 <code>threading.RLock.acquire()</code> 中实现的行为是不同的。</p>
</li>
<li><p><code>release</code>()</p>
<p>释放锁，使锁内的递归等级减一。如果释放后锁内的递归等级降低为0，则会重置锁的状态为释放状态（即没有被任何进程、线程持有），重置后如果有有其他进程和线程在等待这把锁，他们中的一个会获得这个锁而继续运行。如果释放后锁内的递归等级还没到达0，则这个锁仍将保持未释放状态且当前进程和线程仍然是持有者。</p>
<p>只有当前进程或线程是锁的持有者时，才允许调用这个方法。如果当前进程或线程不是这个锁的拥有者，或者这个锁处于已释放的状态(即没有任何拥有者)，调用这个方法会抛出 <code>AssertionError</code> 异常。注意这里抛出的异常类型和 <code>threading.RLock.release()</code> 中实现的行为不一样。</p>
</li>
</ul>
<p><em>class</em> <code>multiprocessing.Semaphore</code>([<em>value</em>])</p>
<p>一种信号量对象: 类似于 <code>threading.Semaphore</code>.</p>
<p>一个小小的不同在于，它的 <code>acquire</code> 方法的第一个参数名是和 <code>Lock.acquire()</code> 一样的 <em>block</em> 。</p>
<p>注解</p>
<p>On macOS, <code>sem_timedwait</code> is unsupported, so calling <code>acquire()</code> with a timeout will emulate that function’s behavior using a sleeping loop.</p>
<p>注解</p>
<p>假如信号 SIGINT 是来自于 Ctrl-C ，并且主线程被 <code>BoundedSemaphore.acquire()</code>, <code>Lock.acquire()</code>, <code>RLock.acquire()</code>, <code>Semaphore.acquire()</code>, <code>Condition.acquire()</code> 或 <code>Condition.wait()</code> 阻塞，则调用会立即中断同时抛出 <code>KeyboardInterrupt</code> 异常。</p>
<p>这和 <code>threading</code> 的行为不同，此模块中当执行对应的阻塞式调用时，SIGINT 会被忽略。</p>
<p>注解</p>
<p>这个包的某些功能依赖于宿主机系统的共享信号量的实现，如果系统没有这个特性， <code>multiprocessing.synchronize</code> 会被禁用，尝试导入这个模块会引发 <code>ImportError</code> 异常，详细信息请查看 <a href="https://bugs.python.org/issue3770" target="_blank" rel="noopener">bpo-3770</a> 。</p>
<h4 id="共享-ctypes-对象"><a href="#共享-ctypes-对象" class="headerlink" title="共享 ctypes 对象"></a>共享 <code>ctypes</code> 对象</h4><p>在共享内存上创建可被子进程继承的共享对象时是可行的。</p>
<p><code>multiprocessing.Value</code>(<em>typecode_or_type</em>, <em>\</em>args<em>,</em> lock=True*)</p>
<p>返回一个从共享内存上创建的 <code>ctypes</code> 对象。默认情况下返回的对象实际上是经过了同步器包装过的。可以通过 <code>Value</code> 的 <em>value</em> 属性访问这个对象本身。</p>
<p><em>typecode_or_type</em> 指明了返回的对象类型: 它可能是一个 ctypes 类型或者 <code>array</code> 模块中每个类型对应的单字符长度的字符串。 <em>\</em>args* 会透传给这个类的构造函数。</p>
<p>如果 <em>lock</em> 参数是 <code>True</code> （默认值）, 将会新建一个递归锁用于同步对于此值的访问操作。 如果 <em>lock</em> 是 <code>Lock</code> 或者 <code>RLock</code> 对象，那么这个传入的锁将会用于同步对这个值的访问操作，如果 <em>lock</em> 是 <code>False</code> , 那么对这个对象的访问将没有锁保护，也就是说这个变量不是进程安全的。</p>
<p>诸如 <code>+=</code> 这类的操作会引发独立的读操作和写操作，也就是说这类操作符并不具有原子性。所以，如果你想让递增共享变量的操作具有原子性，仅仅以这样的方式并不能达到要求:</p>
<pre><code>counter.value += 1</code></pre><p>共享对象内部关联的锁是递归锁(默认情况下就是)的情况下， 你可以采用这种方式</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">with</span> counter<span class="token punctuation">.</span>get_lock<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    
    counter<span class="token punctuation">.</span>value <span class="token operator">+=</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>注意 <em>lock</em> 只能是命名参数。</p>
<p><code>multiprocessing.Array</code>(<em>typecode_or_type</em>, <em>size_or_initializer</em>, <em>**,</em> lock=True*)</p>
<p>从共享内存中申请并返回一个具有ctypes类型的数组对象。默认情况下返回值实际上是被同步器包装过的数组对象。</p>
<p><em>typecode_or_type</em> 指明了返回的数组中的元素类型: 它可能是一个 ctypes 类型或者 <code>array</code> 模块中每个类型对应的单字符长度的字符串。 如果 <em>size_or_initializer</em> 是一个整数，那就会当做数组的长度，并且整个数组的内存会初始化为0。否则，如果 <em>size_or_initializer</em> 会被当成一个序列用于初始化数组中的每一个元素，并且会根据元素个数自动判断数组的长度。</p>
<p>如果 <em>lock</em> 为 <code>True</code> (默认值) 则将创建一个新的锁对象用于同步对值的访问。 如果 <em>lock</em> 为一个 <code>Lock</code> 或 <code>RLock</code> 对象则该对象将被用于同步对值的访问。 如果 <em>lock</em> 为 <code>False</code> 则对返回对象的访问将不会自动得到锁的保护，也就是说它不是“进程安全的”。</p>
<p>请注意 <em>lock</em> 是一个仅限关键字参数。</p>
<p>请注意 <code>ctypes.c_char</code> 的数组具有 <em>value</em> 和 <em>raw</em> 属性，允许被用来保存和提取字符串。</p>
<h5 id="multiprocessing-sharedctypes-模块"><a href="#multiprocessing-sharedctypes-模块" class="headerlink" title="multiprocessing.sharedctypes 模块"></a><code>multiprocessing.sharedctypes</code> 模块</h5><p><code>multiprocessing.sharedctypes</code> 模块提供了一些函数，用于分配来自共享内存的、可被子进程继承的 <code>ctypes</code> 对象。</p>
<p>注解</p>
<p>虽然可以将指针存储在共享内存中，但请记住它所引用的是特定进程地址空间中的位置。 而且，指针很可能在第二个进程的上下文中无效，尝试从第二个进程对指针进行解引用可能会导致崩溃。</p>
<p><code>multiprocessing.sharedctypes.RawArray</code>(<em>typecode_or_type</em>, <em>size_or_initializer</em>)</p>
<p>从共享内存中申请并返回一个 ctypes 数组。</p>
<p><em>typecode_or_type</em> 指明了返回的数组中的元素类型: 它可能是一个 ctypes 类型或者 <code>array</code> 模块中使用的类型字符。 如果 <em>size_or_initializer</em> 是一个整数，那就会当做数组的长度，并且整个数组的内存会初始化为0。否则，如果 <em>size_or_initializer</em> 会被当成一个序列用于初始化数组中的每一个元素，并且会根据元素个数自动判断数组的长度。</p>
<p>注意对元素的访问、赋值操作可能是非原子操作 - 使用 <code>Array()</code> , 从而借助其中的锁保证操作的原子性。</p>
<p><code>multiprocessing.sharedctypes.RawValue</code>(<em>typecode_or_type</em>, <em>\</em>args*)</p>
<p>从共享内存中申请并返回一个 ctypes 对象。</p>
<p><em>typecode_or_type</em> 指明了返回的对象类型: 它可能是一个 ctypes 类型或者 <code>array</code> 模块中每个类型对应的单字符长度的字符串。 <em>\</em>args* 会透传给这个类的构造函数。</p>
<p>注意对 value 的访问、赋值操作可能是非原子操作 - 使用 <code>Value()</code> ，从而借助其中的锁保证操作的原子性。</p>
<p>请注意 <code>ctypes.c_char</code> 的数组具有 <em>value</em> 和 <em>raw</em> 属性，允许被用来保存和提取字符串 。</p>
<p><code>multiprocessing.sharedctypes.Array</code>(<em>typecode_or_type</em>, <em>size_or_initializer</em>, <em>**,</em> lock=True*)</p>
<p>返回一个纯 ctypes 数组, 或者在此之上经过同步器包装过的进程安全的对象，这取决于 <em>lock</em> 参数的值，除此之外，和 <code>RawArray()</code> 一样。</p>
<p>如果 <em>lock</em> 为 <code>True</code> (默认值) 则将创建一个新的锁对象用于同步对值的访问。 如果 <em>lock</em> 为一个 <code>Lock</code> 或 <code>RLock</code> 对象则该对象将被用于同步对值的访问。 如果 <em>lock</em> 为 <code>False</code> 则对所返回对象的访问将不会自动得到锁的保护，也就是说它将不是“进程安全的”。</p>
<p>注意 <em>lock</em> 只能是命名参数。</p>
<p><code>multiprocessing.sharedctypes.Value</code>(<em>typecode_or_type</em>, <em>\</em>args<em>,</em> lock=True*)</p>
<p>返回一个纯 ctypes 数组, 或者在此之上经过同步器包装过的进程安全的对象，这取决于 <em>lock</em> 参数的值，除此之外，和 <code>RawArray()</code> 一样。</p>
<p>如果 <em>lock</em> 为 <code>True</code> (默认值) 则将创建一个新的锁对象用于同步对值的访问。 如果 <em>lock</em> 为一个 <code>Lock</code> 或 <code>RLock</code> 对象则该对象将被用于同步对值的访问。 如果 <em>lock</em> 为 <code>False</code> 则对所返回对象的访问将不会自动得到锁的保护，也就是说它将不是“进程安全的”。</p>
<p>注意 <em>lock</em> 只能是命名参数。</p>
<p><code>multiprocessing.sharedctypes.copy</code>(<em>obj</em>)</p>
<p>从共享内存中申请一片空间将 ctypes 对象 <em>obj</em> 过来，然后返回一个新的 ctypes 对象。</p>
<p><code>multiprocessing.sharedctypes.synchronized</code>(<em>obj</em>[, <em>lock</em>])</p>
<p>将一个 ctypes 对象包装为进程安全的对象并返回，使用 <em>lock</em> 同步对于它的操作。如果 <em>lock</em> 是 <code>None</code> (默认值) ，则会自动创建一个 <code>multiprocessing.RLock</code> 对象。</p>
<p>同步器包装后的对象会在原有对象基础上额外增加两个方法: <code>get_obj()</code> 返回被包装的对象， <code>get_lock()</code> 返回内部用于同步的锁。</p>
<p>需要注意的是，访问包装后的ctypes对象会比直接访问原来的纯 ctypes 对象慢得多。</p>
<p>在 3.5 版更改: 同步器包装后的对象支持 context manager 协议。</p>
<p>下面的表格对比了创建普通ctypes对象和基于共享内存上创建共享ctypes对象的语法。（表格中的 <code>MyStruct</code> 是 <code>ctypes.Structure</code> 的子类）</p>
<table>
<thead>
<tr>
<th align="left">ctypes</th>
<th align="left">使用类型的共享ctypes</th>
<th align="left">使用 typecode 的共享 ctypes</th>
</tr>
</thead>
<tbody><tr>
<td align="left">c_double(2.4)</td>
<td align="left">RawValue(c_double, 2.4)</td>
<td align="left">RawValue(‘d’, 2.4)</td>
</tr>
<tr>
<td align="left">MyStruct(4, 6)</td>
<td align="left">RawValue(MyStruct, 4, 6)</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">(c_short <em>7)()</em></td>
<td align="left">RawArray(c_short, 7)</td>
<td align="left">RawArray(‘h’, 7)</td>
</tr>
<tr>
<td align="left">(c_int 3)(9, 2, 8)</td>
<td align="left">RawArray(c_int, (9, 2, 8))</td>
<td align="left">RawArray(‘i’, (9, 2, 8))</td>
</tr>
</tbody></table>
<p>下面是一个在子进程中修改多个ctypes对象的例子。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> multiprocessing <span class="token keyword">import</span> Process<span class="token punctuation">,</span> Lock
<span class="token keyword">from</span> multiprocessing<span class="token punctuation">.</span>sharedctypes <span class="token keyword">import</span> Value<span class="token punctuation">,</span> Array
<span class="token keyword">from</span> ctypes <span class="token keyword">import</span> Structure<span class="token punctuation">,</span> c_double
<span class="token keyword">class</span> <span class="token class-name">Point</span><span class="token punctuation">(</span>Structure<span class="token punctuation">)</span><span class="token punctuation">:</span>
    _fields_ <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token string">'x'</span><span class="token punctuation">,</span> c_double<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'y'</span><span class="token punctuation">,</span> c_double<span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token keyword">def</span> <span class="token function">modify</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> x<span class="token punctuation">,</span> s<span class="token punctuation">,</span> A<span class="token punctuation">)</span><span class="token punctuation">:</span>
    n<span class="token punctuation">.</span>value <span class="token operator">**=</span> <span class="token number">2</span>
    x<span class="token punctuation">.</span>value <span class="token operator">**=</span> <span class="token number">2</span>
    s<span class="token punctuation">.</span>value <span class="token operator">=</span> s<span class="token punctuation">.</span>value<span class="token punctuation">.</span>upper<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">for</span> a <span class="token keyword">in</span> A<span class="token punctuation">:</span>
        a<span class="token punctuation">.</span>x <span class="token operator">**=</span> <span class="token number">2</span>
        a<span class="token punctuation">.</span>y <span class="token operator">**=</span> <span class="token number">2</span>
<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>
    lock <span class="token operator">=</span> Lock<span class="token punctuation">(</span><span class="token punctuation">)</span>
    n <span class="token operator">=</span> Value<span class="token punctuation">(</span><span class="token string">'i'</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">)</span>
    x <span class="token operator">=</span> Value<span class="token punctuation">(</span>c_double<span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token operator">/</span><span class="token number">3.0</span><span class="token punctuation">,</span> lock<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span>
    s <span class="token operator">=</span> Array<span class="token punctuation">(</span><span class="token string">'c'</span><span class="token punctuation">,</span> b<span class="token string">'hello world'</span><span class="token punctuation">,</span> lock<span class="token operator">=</span>lock<span class="token punctuation">)</span>
    A <span class="token operator">=</span> Array<span class="token punctuation">(</span>Point<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">1.875</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">6.25</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">5.75</span><span class="token punctuation">,</span><span class="token number">2.0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">2.375</span><span class="token punctuation">,</span><span class="token number">9.5</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">,</span> lock<span class="token operator">=</span>lock<span class="token punctuation">)</span>
    p <span class="token operator">=</span> Process<span class="token punctuation">(</span>target<span class="token operator">=</span>modify<span class="token punctuation">,</span> args<span class="token operator">=</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> x<span class="token punctuation">,</span> s<span class="token punctuation">,</span> A<span class="token punctuation">)</span><span class="token punctuation">)</span>
    p<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>
    p<span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>n<span class="token punctuation">.</span>value<span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>value<span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>value<span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>x<span class="token punctuation">,</span> a<span class="token punctuation">.</span>y<span class="token punctuation">)</span> <span class="token keyword">for</span> a <span class="token keyword">in</span> A<span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>输出如下</p>
<pre><code>49
0.1111111111111111
HELLO WORLD
[(3.515625, 39.0625), (33.0625, 4.0), (5.640625, 90.25)]</code></pre><h4 id="管理器"><a href="#管理器" class="headerlink" title="管理器"></a>管理器</h4><p>管理器提供了一种创建共享数据的方法，从而可以在不同进程中共享，甚至可以通过网络跨机器共享数据。管理器维护一个用于管理 <em>共享对象</em> 的服务。其他进程可以通过代理访问这些共享对象。</p>
<p><code>multiprocessing.Manager</code>()</p>
<p>返回一个已启动的 <code>SyncManager</code> 管理器对象，这个对象可以用于在不同进程中共享数据。返回的管理器对象对应了一个已经启动的子进程，并且拥有一系列方法可以用于创建共享对象、返回对应的代理。</p>
<p>当管理器被垃圾回收或者父进程退出时，管理器进程会立即退出。管理器类定义在 <code>multiprocessing.managers</code> 模块:</p>
<p><em>class</em> <code>multiprocessing.managers.BaseManager</code>([<em>address</em>[, <em>authkey</em>]])</p>
<p>创建一个 BaseManager 对象。</p>
<p>一旦创建，应该及时调用 <code>start()</code> 或者 <code>get_server().serve_forever()</code> 以确保管理器对象对应的管理进程已经启动。</p>
<p><em>address</em> 是管理器服务进程监听的地址。如果 <em>address</em> 是 <code>None</code> ,则允许和任意主机的请求建立连接。</p>
<p><em>authkey</em> 是认证标识，用于检查连接服务进程的请求合法性。如果 <em>authkey</em> 是 <code>None</code>, 则会使用 <code>current_process().authkey</code> , 否则，就使用 <em>authkey</em> , 需要保证它必须是 byte 类型的字符串。</p>
<ul>
<li><p><code>start</code>([<em>initializer</em>[, <em>initargs</em>]])</p>
<p>为管理器开启一个子进程，如果 <em>initializer</em> 不是 <code>None</code> , 子进程在启动时将会调用 <code>initializer(*initargs)</code> 。</p>
</li>
<li><p><code>get_server</code>()</p>
<p>返回一个 <code>Server</code> 对象，它是管理器在后台控制的真实的服务。 <code>Server</code> 对象拥有 <code>serve_forever()</code> 方法。</p>
<pre><code>&gt;&gt;&gt; from multiprocessing.managers import BaseManager
&gt;&gt;&gt; manager = BaseManager(address=('', 50000), authkey=b'abc')
&gt;&gt;&gt; server = manager.get_server()
&gt;&gt;&gt; server.serve_forever()</code></pre><p><code>Server</code> 额外拥有一个 <code>address</code> 属性。</p>
</li>
<li><p><code>connect</code>()</p>
<p>将本地管理器对象连接到一个远程管理器进程:</p>
<pre><code>&gt;&gt;&gt; from multiprocessing.managers import BaseManager
&gt;&gt;&gt; m = BaseManager(address=('127.0.0.1', 50000), authkey=b'abc')
&gt;&gt;&gt; m.connect()</code></pre></li>
<li><p><code>shutdown</code>()</p>
<p>停止管理器的进程。这个方法只能用于已经使用 <code>start()</code> 启动的服务进程。</p>
<p>它可以被多次调用。</p>
</li>
<li><p><code>register</code>(<em>typeid</em>[, <em>callable</em>[, <em>proxytype</em>[, <em>exposed</em>[, <em>method_to_typeid</em>[, <em>create_method</em>]]]]])</p>
<p>一个 classmethod，可以将一个类型或者可调用对象注册到管理器类。</p>
<p><em>typeid</em> 是一种 “类型标识符”，用于唯一表示某种共享对象类型，必须是一个字符串。</p>
<p><em>callable</em> 是一个用来为此类型标识符创建对象的可调用对象。如果一个管理器实例将使用 <code>connect()</code> 方法连接到服务器，或者 <em>create_method</em> 参数为 <code>False</code>，那么这里可留下 <code>None</code>。</p>
<p><em>proxytype</em> 是 <code>BaseProxy</code> 的子类，可以根据 <em>typeid</em> 为共享对象创建一个代理，如果是 <code>None</code> , 则会自动创建一个代理类。</p>
<p><em>exposed</em> 是一个函数名组成的序列，用来指明只有这些方法可以使用 <code>BaseProxy._callmethod()</code> 代理。(如果 <em>exposed</em> 是 <code>None</code>, 则会在 <code>proxytype._exposed_</code> 存在的情况下转而使用它) 当暴露的方法列表没有指定的时候，共享对象的所有 “公共方法” 都会被代理。（这里的“公共方法”是指所有拥有 <code>__call__()</code> 方法并且不是以 <code>'_'</code> 开头的属性）</p>
<p><em>method_to_typeid</em> 是一个映射，用来指定那些应该返回代理对象的暴露方法所返回的类型。（如果 <em>method_to_typeid</em> 是 <code>None</code>, 则 <code>proxytype._method_to_typeid_</code> 会在存在的情况下被使用）如果方法名称不在这个映射中或者映射是 <code>None</code> ,则方法返回的对象会是一个值拷贝。</p>
<p><em>create_method</em> 指明，是否要创建一个以 <em>typeid</em> 命名并返回一个代理对象的方法，这个函数会被服务进程用于创建共享对象，默认为 <code>True</code> 。</p>
</li>
</ul>
<p><code>BaseManager</code> 实例也有一个只读属性。</p>
<ul>
<li><p><code>address</code></p>
<p>管理器所用的地址。</p>
</li>
</ul>
<p>在 3.3 版更改: 管理器对象支持上下文管理协议 。<code>__enter__()</code> 启动服务进程（如果它还没有启动）并且返回管理器对象， <code>__exit__()</code> 会调用 <code>shutdown()</code> 。</p>
<p>在之前的版本中，如果管理器服务进程没有启动， <code>__enter__()</code> 不会负责启动它。</p>
<p><em>class</em> <code>multiprocessing.managers.SyncManager</code></p>
<p><code>BaseManager</code> 的子类，可用于进程的同步。这个类型的对象使用 <code>multiprocessing.Manager()</code> 创建。</p>
<p>它拥有一系列方法，可以为大部分常用数据类型创建并返回 代理对象 代理，用于进程间同步。甚至包括共享列表和字典。</p>
<ul>
<li><p><code>Barrier</code>(<em>parties</em>[, <em>action</em>[, <em>timeout</em>]])</p>
<p>创建一个共享的 <code>threading.Barrier</code> 对象并返回它的代理。</p>
<p>3.3 新版功能.</p>
</li>
<li><p><code>BoundedSemaphore</code>([<em>value</em>])</p>
<p>创建一个共享的 <code>threading.BoundedSemaphore</code> 对象并返回它的代理。</p>
</li>
<li><p><code>Condition</code>([<em>lock</em>])</p>
<p>创建一个共享的 <code>threading.Condition</code> 对象并返回它的代理。</p>
<p>如果提供了 <em>lock</em> 参数，那它必须是 <code>threading.Lock</code> 或 <code>threading.RLock</code> 的代理对象。</p>
<p>在 3.3 版更改: 新增了 <code>wait_for()</code> 方法。</p>
</li>
<li><p><code>Event</code>()</p>
<p>创建一个共享的 <code>threading.Event</code> 对象并返回它的代理。</p>
</li>
<li><p><code>Lock</code>()</p>
<p>创建一个共享的 <code>threading.Lock</code> 对象并返回它的代理。</p>
</li>
<li><p><code>Namespace</code>()</p>
<p>创建一个共享的 <code>Namespace</code> 对象并返回它的代理。</p>
</li>
<li><p><code>Queue</code>([<em>maxsize</em>])</p>
<p>创建一个共享的 <code>queue.Queue</code> 对象并返回它的代理。</p>
</li>
<li><p><code>RLock</code>()</p>
<p>创建一个共享的 <code>threading.RLock</code> 对象并返回它的代理。</p>
</li>
<li><p><code>Semaphore</code>([<em>value</em>])</p>
<p>创建一个共享的 <code>threading.Semaphore</code> 对象并返回它的代理。</p>
</li>
<li><p><code>Array</code>(<em>typecode</em>, <em>sequence</em>)</p>
<p>创建一个数组并返回它的代理。</p>
</li>
<li><p><code>Value</code>(<em>typecode</em>, <em>value</em>)</p>
<p>创建一个具有可写 <code>value</code> 属性的对象并返回它的代理。</p>
</li>
<li><p><code>dict</code>()</p>
<p><code>dict</code>(<em>mapping</em>)</p>
<p><code>dict</code>(<em>sequence</em>)</p>
<p>创建一个共享的 <code>dict</code> 对象并返回它的代理。</p>
</li>
<li><p><code>list</code>()</p>
<p><code>list</code>(<em>sequence</em>)</p>
<p>创建一个共享的 <code>list</code> 对象并返回它的代理。</p>
</li>
</ul>
<p>在 3.6 版更改: 共享对象能够嵌套。例如, 共享的容器对象如共享列表，可以包含另一个共享对象，他们全都会在 <code>SyncManager</code> 中进行管理和同步。</p>
<p><em>class</em> <code>multiprocessing.managers.Namespace</code></p>
<p>一个可以注册到 <code>SyncManager</code> 的类型。</p>
<p>命名空间对象没有公共方法，但是拥有可写的属性。直接print会显示所有属性的值。</p>
<p>值得一提的是，当对命名空间对象使用代理的时候，访问所有名称以 <code>'_'</code> 开头的属性都只是代理器上的属性，而不是命名空间对象的属性。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> manager <span class="token operator">=</span> multiprocessing<span class="token punctuation">.</span>Manager<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> Global <span class="token operator">=</span> manager<span class="token punctuation">.</span>Namespace<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> Global<span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token number">10</span>
<span class="token operator">>></span><span class="token operator">></span> Global<span class="token punctuation">.</span>y <span class="token operator">=</span> <span class="token string">'hello'</span>
<span class="token operator">>></span><span class="token operator">></span> Global<span class="token punctuation">.</span>_z <span class="token operator">=</span> <span class="token number">12.3</span>    <span class="token comment" spellcheck="true"># this is an attribute of the proxy</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>Global<span class="token punctuation">)</span>
Namespace<span class="token punctuation">(</span>x<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">,</span> y<span class="token operator">=</span><span class="token string">'hello'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h5 id="自定义管理器"><a href="#自定义管理器" class="headerlink" title="自定义管理器"></a>自定义管理器</h5><p>要创建一个自定义的管理器，需要新建一个 <code>BaseManager</code> 的子类，然后使用这个管理器类上的 <code>register()</code> 类方法将新类型或者可调用方法注册上去。例如:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> multiprocessing<span class="token punctuation">.</span>managers <span class="token keyword">import</span> BaseManager
<span class="token keyword">class</span> <span class="token class-name">MathsClass</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">add</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> x <span class="token operator">+</span> y
    <span class="token keyword">def</span> <span class="token function">mul</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> x <span class="token operator">*</span> y
<span class="token keyword">class</span> <span class="token class-name">MyManager</span><span class="token punctuation">(</span>BaseManager<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">pass</span>
MyManager<span class="token punctuation">.</span>register<span class="token punctuation">(</span><span class="token string">'Maths'</span><span class="token punctuation">,</span> MathsClass<span class="token punctuation">)</span>
<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>
    <span class="token keyword">with</span> MyManager<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">as</span> manager<span class="token punctuation">:</span>
        maths <span class="token operator">=</span> manager<span class="token punctuation">.</span>Maths<span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span>maths<span class="token punctuation">.</span>add<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span>         <span class="token comment" spellcheck="true"># prints 7</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span>maths<span class="token punctuation">.</span>mul<span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span>         <span class="token comment" spellcheck="true"># prints 56</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h5 id="使用远程管理器"><a href="#使用远程管理器" class="headerlink" title="使用远程管理器"></a>使用远程管理器</h5><p>可以将管理器服务运行在一台机器上，然后使用客户端从其他机器上访问。(假设它们的防火墙允许)</p>
<p>运行下面的代码可以启动一个服务，此付包含了一个共享队列，允许远程客户端访问:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> multiprocessing<span class="token punctuation">.</span>managers <span class="token keyword">import</span> BaseManager
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> queue <span class="token keyword">import</span> Queue
<span class="token operator">>></span><span class="token operator">></span> queue <span class="token operator">=</span> Queue<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">class</span> <span class="token class-name">QueueManager</span><span class="token punctuation">(</span>BaseManager<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">pass</span>
<span class="token operator">>></span><span class="token operator">></span> QueueManager<span class="token punctuation">.</span>register<span class="token punctuation">(</span><span class="token string">'get_queue'</span><span class="token punctuation">,</span> callable<span class="token operator">=</span><span class="token keyword">lambda</span><span class="token punctuation">:</span>queue<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> m <span class="token operator">=</span> QueueManager<span class="token punctuation">(</span>address<span class="token operator">=</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">,</span> <span class="token number">50000</span><span class="token punctuation">)</span><span class="token punctuation">,</span> authkey<span class="token operator">=</span>b<span class="token string">'abracadabra'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> s <span class="token operator">=</span> m<span class="token punctuation">.</span>get_server<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> s<span class="token punctuation">.</span>serve_forever<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>远程客户端可以通过下面的方式访问服务:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> multiprocessing<span class="token punctuation">.</span>managers <span class="token keyword">import</span> BaseManager
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">class</span> <span class="token class-name">QueueManager</span><span class="token punctuation">(</span>BaseManager<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">pass</span>
<span class="token operator">>></span><span class="token operator">></span> QueueManager<span class="token punctuation">.</span>register<span class="token punctuation">(</span><span class="token string">'get_queue'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> m <span class="token operator">=</span> QueueManager<span class="token punctuation">(</span>address<span class="token operator">=</span><span class="token punctuation">(</span><span class="token string">'foo.bar.org'</span><span class="token punctuation">,</span> <span class="token number">50000</span><span class="token punctuation">)</span><span class="token punctuation">,</span> authkey<span class="token operator">=</span>b<span class="token string">'abracadabra'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> m<span class="token punctuation">.</span>connect<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> queue <span class="token operator">=</span> m<span class="token punctuation">.</span>get_queue<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> queue<span class="token punctuation">.</span>put<span class="token punctuation">(</span><span class="token string">'hello'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>也可以通过下面的方式:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> multiprocessing<span class="token punctuation">.</span>managers <span class="token keyword">import</span> BaseManager
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">class</span> <span class="token class-name">QueueManager</span><span class="token punctuation">(</span>BaseManager<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">pass</span>
<span class="token operator">>></span><span class="token operator">></span> QueueManager<span class="token punctuation">.</span>register<span class="token punctuation">(</span><span class="token string">'get_queue'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> m <span class="token operator">=</span> QueueManager<span class="token punctuation">(</span>address<span class="token operator">=</span><span class="token punctuation">(</span><span class="token string">'foo.bar.org'</span><span class="token punctuation">,</span> <span class="token number">50000</span><span class="token punctuation">)</span><span class="token punctuation">,</span> authkey<span class="token operator">=</span>b<span class="token string">'abracadabra'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> m<span class="token punctuation">.</span>connect<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> queue <span class="token operator">=</span> m<span class="token punctuation">.</span>get_queue<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> queue<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token string">'hello'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>本地进程也可以访问这个队列，利用上面的客户端代码通过远程方式访问:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> multiprocessing <span class="token keyword">import</span> Process<span class="token punctuation">,</span> Queue
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> multiprocessing<span class="token punctuation">.</span>managers <span class="token keyword">import</span> BaseManager
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">class</span> <span class="token class-name">Worker</span><span class="token punctuation">(</span>Process<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> q<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         self<span class="token punctuation">.</span>q <span class="token operator">=</span> q
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         super<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">def</span> <span class="token function">run</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         self<span class="token punctuation">.</span>q<span class="token punctuation">.</span>put<span class="token punctuation">(</span><span class="token string">'local hello'</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> queue <span class="token operator">=</span> Queue<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> w <span class="token operator">=</span> Worker<span class="token punctuation">(</span>queue<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> w<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">class</span> <span class="token class-name">QueueManager</span><span class="token punctuation">(</span>BaseManager<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">pass</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> QueueManager<span class="token punctuation">.</span>register<span class="token punctuation">(</span><span class="token string">'get_queue'</span><span class="token punctuation">,</span> callable<span class="token operator">=</span><span class="token keyword">lambda</span><span class="token punctuation">:</span> queue<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> m <span class="token operator">=</span> QueueManager<span class="token punctuation">(</span>address<span class="token operator">=</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">,</span> <span class="token number">50000</span><span class="token punctuation">)</span><span class="token punctuation">,</span> authkey<span class="token operator">=</span>b<span class="token string">'abracadabra'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> s <span class="token operator">=</span> m<span class="token punctuation">.</span>get_server<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> s<span class="token punctuation">.</span>serve_forever<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="代理对象"><a href="#代理对象" class="headerlink" title="代理对象"></a>代理对象</h4><p>代理是一个 <em>指向</em> 其他共享对象的对象，这个对象(很可能)在另外一个进程中。共享对象也可以说是代理 <em>指涉</em> 的对象。多个代理对象可能指向同一个指涉对象。</p>
<p>代理对象代理了指涉对象的一系列方法调用(虽然并不是指涉对象的每个方法都有必要被代理)。通过这种方式，代理的使用方法可以和它的指涉对象一样:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> multiprocessing <span class="token keyword">import</span> Manager
<span class="token operator">>></span><span class="token operator">></span> manager <span class="token operator">=</span> Manager<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> l <span class="token operator">=</span> manager<span class="token punctuation">.</span>list<span class="token punctuation">(</span><span class="token punctuation">[</span>i<span class="token operator">*</span>i <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>l<span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">,</span> <span class="token number">25</span><span class="token punctuation">,</span> <span class="token number">36</span><span class="token punctuation">,</span> <span class="token number">49</span><span class="token punctuation">,</span> <span class="token number">64</span><span class="token punctuation">,</span> <span class="token number">81</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>repr<span class="token punctuation">(</span>l<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token operator">&lt;</span>ListProxy object<span class="token punctuation">,</span> typeid <span class="token string">'list'</span> at 0x<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">></span>
<span class="token operator">>></span><span class="token operator">></span> l<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span>
<span class="token number">16</span>
<span class="token operator">>></span><span class="token operator">></span> l<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token number">5</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>注意，对代理使用 <code>str()</code> 函数会返回指涉对象的字符串表示，但是 <code>repr()</code> 却会返回代理本身的内部字符串表示。</p>
<p>被代理的对象很重要的一点是必须可以被序列化，这样才能允许他们在进程间传递。因此，指涉对象可以包含 代理对象 。这允许管理器中列表、字典或者其他 代理对象 对象之间的嵌套。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> a <span class="token operator">=</span> manager<span class="token punctuation">.</span>list<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> b <span class="token operator">=</span> manager<span class="token punctuation">.</span>list<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> a<span class="token punctuation">.</span>append<span class="token punctuation">(</span>b<span class="token punctuation">)</span>         <span class="token comment" spellcheck="true"># referent of a now contains referent of b</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token operator">&lt;</span>ListProxy object<span class="token punctuation">,</span> typeid <span class="token string">'list'</span> at <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">></span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> b<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token string">'hello'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> b<span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token string">'hello'</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token string">'hello'</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>类似地，字典和列表代理也可以相互嵌套:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> l_outer <span class="token operator">=</span> manager<span class="token punctuation">.</span>list<span class="token punctuation">(</span><span class="token punctuation">[</span> manager<span class="token punctuation">.</span>dict<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> d_first_inner <span class="token operator">=</span> l_outer<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> d_first_inner<span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>
<span class="token operator">>></span><span class="token operator">></span> d_first_inner<span class="token punctuation">[</span><span class="token string">'b'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">2</span>
<span class="token operator">>></span><span class="token operator">></span> l_outer<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">'c'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">3</span>
<span class="token operator">>></span><span class="token operator">></span> l_outer<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">'z'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">26</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>l_outer<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span><span class="token string">'a'</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">}</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>l_outer<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span><span class="token string">'c'</span><span class="token punctuation">:</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">'z'</span><span class="token punctuation">:</span> <span class="token number">26</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果指涉对象包含了普通 <code>list</code> 或 <code>dict</code> 对象，对这些内部可变对象的修改不会通过管理器传播，因为代理无法得知被包含的值什么时候被修改了。但是把存放在容器代理中的值本身是会通过管理器传播的（会触发代理对象中的 <code>__setitem__</code> ）从而有效修改这些对象，所以可以把修改过的值重新赋值给容器代理:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># create a list proxy and append a mutable object (a dictionary)</span>
lproxy <span class="token operator">=</span> manager<span class="token punctuation">.</span>list<span class="token punctuation">(</span><span class="token punctuation">)</span>
lproxy<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token comment" spellcheck="true"># now mutate the dictionary</span>
d <span class="token operator">=</span> lproxy<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
d<span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>
d<span class="token punctuation">[</span><span class="token string">'b'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">2</span>
<span class="token comment" spellcheck="true"># at this point, the changes to d are not yet synced, but by</span>
<span class="token comment" spellcheck="true"># updating the dictionary, the proxy is notified of the change</span>
lproxy<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> d<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在大多是使用情形下，这种实现方式并不比嵌套 代理对象 方便，但是依然演示了对于同步的一种控制级别。</p>
<p>注解</p>
<p><code>multiprocessing</code> 中的代理类并没有提供任何对于代理值比较的支持。所以，我们会得到如下结果:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> manager<span class="token punctuation">.</span>list<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span>
<span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>当需要比较值的时候，应该替换为使用指涉对象的拷贝。</p>
<p><em>class</em> <code>multiprocessing.managers.BaseProxy</code></p>
<p>代理对象是 <code>BaseProxy</code> 派生类的实例。</p>
<ul>
<li><p><code>_callmethod</code>(<em>methodname</em>[, <em>args</em>[, <em>kwds</em>]])</p>
<p>调用指涉对象的方法并返回结果。</p>
<p>如果 <code>proxy</code> 是一个代理且其指涉的是 <code>obj</code> , 那么下面的表达式:</p>
<pre><code>proxy._callmethod(methodname, args, kwds)</code></pre><p>相当于求取以下表达式的值:</p>
<pre><code>getattr(obj, methodname)(*args, **kwds)</code></pre><p>于管理器进程。</p>
<p>返回结果会是一个值拷贝或者一个新的共享对象的代理 - 见函数 <code>BaseManager.register()</code> 中关于参数 <em>method_to_typeid</em> 的文档。</p>
<p>如果这个调用熬出了异常，则这个异常会被 <code>_callmethod()</code> 透传出来。如果是管理器进程本身抛出的一些其他异常，则会被 <code>_callmethod()</code> 转换为 <code>RemoteError</code> 异常重新抛出。</p>
<p>特别注意，如果 <em>methodname</em> 没有 <em>暴露</em> 出来，将会引发一个异常。</p>
<p><code>_callmethod()</code> 的一个使用示例:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> l <span class="token operator">=</span> manager<span class="token punctuation">.</span>list<span class="token punctuation">(</span>range<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> l<span class="token punctuation">.</span>_callmethod<span class="token punctuation">(</span><span class="token string">'__len__'</span><span class="token punctuation">)</span>
<span class="token number">10</span>
<span class="token operator">>></span><span class="token operator">></span> l<span class="token punctuation">.</span>_callmethod<span class="token punctuation">(</span><span class="token string">'__getitem__'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>slice<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># equivalent to l[2:7]</span>
<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> l<span class="token punctuation">.</span>_callmethod<span class="token punctuation">(</span><span class="token string">'__getitem__'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">)</span>          <span class="token comment" spellcheck="true"># equivalent to l[20]</span>
Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
IndexError<span class="token punctuation">:</span> list index out of range<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><code>_getvalue</code>()</p>
<p>返回指涉对象的一份拷贝。</p>
<p>如果指涉对象无法序列化，则会抛出一个异常。</p>
</li>
<li><p><code>__repr__</code>()</p>
<p>返回代理对象的内部字符串表示。</p>
</li>
<li><p><code>__str__</code>()</p>
<p>返回指涉对象的内部字符串表示。</p>
</li>
</ul>
<h5 id="清理"><a href="#清理" class="headerlink" title="清理"></a>清理</h5><p>代理对象使用了一个弱引用回调函数，当它被垃圾回收时，会将自己从拥有此指涉对象的管理器上反注册，</p>
<p>当共享对象没有被任何代理器引用时，会被管理器进程删除。</p>
<h4 id="进程池"><a href="#进程池" class="headerlink" title="进程池"></a>进程池</h4><p>可以创建一个进程池，它将使用 <code>Pool</code> 类执行提交给它的任务。</p>
<p><em>class</em> <code>multiprocessing.pool.Pool</code>([<em>processes</em>[, <em>initializer</em>[, <em>initargs</em>[, <em>maxtasksperchild</em>[, <em>context</em>]]]]])</p>
<p>一个进程池对象，它控制可以提交作业的工作进程池。它支持带有超时和回调的异步结果，以及一个并行的 map 实现。</p>
<p><em>processes</em> 是要使用的工作进程数目。如果 <em>processes</em> 为 <code>None</code>，则使用 <code>os.cpu_count()</code> 返回的值。</p>
<p>如果 <em>initializer</em> 不为 <code>None</code>，则每个工作进程将会在启动时调用 <code>initializer(*initargs)</code>。</p>
<p><em>maxtasksperchild</em> 是一个工作进程在它退出或被一个新的工作进程代替之前能完成的任务数量，为了释放未使用的资源。默认的 <em>maxtasksperchild</em> 是 <code>None</code>，意味着工作进程寿与池齐。</p>
<p><em>context</em> 可被用于指定启动的工作进程的上下文。通常一个进程池是使用函数 <code>multiprocessing.Pool()</code> 或者一个上下文对象的 <code>Pool()</code> 方法创建的。在这两种情况下， <em>context</em> 都是适当设置的。</p>
<p>注意，进程池对象的方法只有创建它的进程能够调用。</p>
<p>警告</p>
<p><code>multiprocessing.pool</code> 对象具有需要正确管理的内部资源 （像任何其他资源一样），具体方式是将进程池用作上下文管理器，或者手动调用 <code>close()</code> 和 <code>terminate()</code>。 未做此类操作将导致进程在终结阶段挂起。</p>
<p>请注意依赖垃圾回收器来销毁进程池是 <strong>不正确的</strong> 做法，因为 CPython 并不保证进程池终结器会被调用</p>
<p>3.2 新版功能: <em>maxtasksperchild</em></p>
<p>3.4 新版功能: <em>context</em></p>
<p>注解</p>
<p>通常来说，<code>Pool</code> 中的 Worker 进程的生命周期和进程池的工作队列一样长。一些其他系统中（如 Apache, mod_wsgi 等）也可以发现另一种模式，他们会让工作进程在完成一些任务后退出，清理、释放资源，然后启动一个新的进程代替旧的工作进程。 <code>Pool</code> 的 <em>maxtasksperchild</em> 参数给用户提供了这种能力。</p>
<ul>
<li><p><code>apply</code>(<em>func</em>[, <em>args</em>[, <em>kwds</em>]])</p>
<p>使用 <em>args</em> 参数以及 <em>kwds</em> 命名参数调用 <em>func</em> , 它会返回结果前阻塞。这种情况下，<code>apply_async()</code> 更适合并行化工作。另外 <em>func</em> 只会在一个进程池中的一个工作进程中执行。</p>
</li>
<li><p><code>apply_async</code>(<em>func</em>[, <em>args</em>[, <em>kwds</em>[, <em>callback</em>[, <em>error_callback</em>]]]])</p>
<p><code>apply()</code> 方法的一个变种，返回一个 <code>AsyncResult</code> 对象。</p>
<p>如果指定了 <em>callback</em> , 它必须是一个接受单个参数的可调用对象。当执行成功时， <em>callback</em> 会被用于处理执行后的返回结果，否则，调用 <em>error_callback</em> 。</p>
<p>如果指定了 <em>error_callback</em> , 它必须是一个接受单个参数的可调用对象。当目标函数执行失败时， 会将抛出的异常对象作为参数传递给 <em>error_callback</em> 执行。</p>
<p>回调函数应该立即执行完成，否则会阻塞负责处理结果的线程。</p>
</li>
<li><p><code>map</code>(<em>func</em>, <em>iterable</em>[, <em>chunksize</em>])</p>
<p>内置 <code>map()</code> 函数的并行版本 (但它只支持一个 <em>iterable</em> 参数，对于多个可迭代对象请参阅 <code>starmap()</code>)。 它会保持阻塞直到获得结果。</p>
<p>这个方法会将可迭代对象分割为许多块，然后提交给进程池。可以将 <em>chunksize</em> 设置为一个正整数从而（近似）指定每个块的大小可以。</p>
<p>注意对于很长的迭代对象，可能消耗很多内存。可以考虑使用 <code>imap()</code> 或 <code>imap_unordered()</code> 并且显示指定 <em>chunksize</em> 以提升效率。</p>
</li>
<li><p><code>map_async</code>(<em>func</em>, <em>iterable</em>[, <em>chunksize</em>[, <em>callback</em>[, <em>error_callback</em>]]])</p>
<p><code>map()</code> 方法的一个变种，返回一个 <code>AsyncResult</code> 对象。</p>
<p>如果指定了 <em>callback</em> , 它必须是一个接受单个参数的可调用对象。当执行成功时， <em>callback</em> 会被用于处理执行后的返回结果，否则，调用 <em>error_callback</em> 。</p>
<p>如果指定了 <em>error_callback</em> , 它必须是一个接受单个参数的可调用对象。当目标函数执行失败时， 会将抛出的异常对象作为参数传递给 <em>error_callback</em> 执行。</p>
<p>回调函数应该立即执行完成，否则会阻塞负责处理结果的线程。</p>
</li>
<li><p><code>imap</code>(<em>func</em>, <em>iterable</em>[, <em>chunksize</em>])</p>
<p><code>map()</code> 的延迟执行版本。</p>
<p><em>chunksize</em> 参数的作用和 <code>map()</code> 方法的一样。对于很长的迭代器，给 <em>chunksize</em> 设置一个很大的值会比默认值 <code>1</code> <strong>极大</strong> 地加快执行速度。</p>
<p>同样，如果 <em>chunksize</em> 是 <code>1</code> , 那么 <code>imap()</code> 方法所返回的迭代器的 <code>next()</code> 方法拥有一个可选的 <em>timeout</em> 参数： 如果无法在 <em>timeout</em> 秒内执行得到结果，则<code>next(timeout)</code> 会抛出 <code>multiprocessing.TimeoutError</code> 异常。</p>
</li>
<li><p><code>imap_unordered</code>(<em>func</em>, <em>iterable</em>[, <em>chunksize</em>])</p>
<p>和 <code>imap()</code> 相同，只不过通过迭代器返回的结果是任意的。（当进程池中只有一个工作进程的时候，返回结果的顺序才能认为是”有序”的）</p>
</li>
<li><p><code>starmap</code>(<em>func</em>, <em>iterable</em>[, <em>chunksize</em>])</p>
<p>和 <code>map()</code> 类似，不过 <em>iterable</em> 中的每一项会被解包再作为函数参数。</p>
<p>比如可迭代对象 <code>[(1,2), (3, 4)]</code> 会转化为等价于 <code>[func(1,2), func(3,4)]</code> 的调用。</p>
<p>3.3 新版功能.</p>
</li>
<li><p><code>starmap_async</code>(<em>func</em>, <em>iterable</em>[, <em>chunksize</em>[, <em>callback</em>[, <em>error_callback</em>]]])</p>
<p>相当于 <code>starmap()</code> 与 <code>map_async()</code> 的结合，迭代 <em>iterable</em> 的每一项，解包作为 <em>func</em> 的参数并执行，返回用于获取结果的对象。</p>
<p>3.3 新版功能.</p>
</li>
<li><p><code>close</code>()</p>
<p>阻止后续任务提交到进程池，当所有任务执行完成后，工作进程会退出。</p>
</li>
<li><p><code>terminate</code>()</p>
<p>不必等待未完成的任务，立即停止工作进程。当进程池对象被垃圾回收时，会立即调用 <code>terminate()</code>。</p>
</li>
<li><p><code>join</code>()</p>
<p>等待工作进程结束。调用 <code>join()</code> 前必须先调用 <code>close()</code> 或者 <code>terminate()</code> 。</p>
</li>
</ul>
<p>3.3 新版功能: 进程池对象现在支持上下文管理器协议。<code>__enter__()</code> 返回进程池对象, <code>__exit__()</code> 会调用 <code>terminate()</code> 。</p>
<p><em>class</em> <code>multiprocessing.pool.AsyncResult</code></p>
<p><code>Pool.apply_async()</code> 和 <code>Pool.map_async()</code> 返回对象所属的类。</p>
<ul>
<li><p><code>get</code>([<em>timeout</em>])</p>
<p>用于获取执行结果。如果 <em>timeout</em> 不是 <code>None</code> 并且在 <em>timeout</em> 秒内仍然没有执行完得到结果，则抛出 <code>multiprocessing.TimeoutError</code> 异常。如果远程调用发生异常，这个异常会通过 <code>get()</code> 重新抛出。</p>
</li>
<li><p><code>wait</code>([<em>timeout</em>])</p>
<p>阻塞，直到返回结果，或者 <em>timeout</em> 秒后超时。</p>
</li>
<li><p><code>ready</code>()</p>
<p>返回执行状态，是否已经完成。</p>
</li>
<li><p><code>successful</code>()</p>
<p>判断调用是否已经完成并且未引发异常。 如果还未获得结果则将引发 <code>ValueError</code>。</p>
<p>在 3.7 版更改: 如果没有执行完，会抛出 <code>ValueError</code> 异常而不是 <code>AssertionError</code> 。</p>
</li>
</ul>
<p>下面的例子演示了进程池的用法:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> multiprocessing <span class="token keyword">import</span> Pool
<span class="token keyword">import</span> time
<span class="token keyword">def</span> <span class="token function">f</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">return</span> x<span class="token operator">*</span>x
<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>
    <span class="token keyword">with</span> Pool<span class="token punctuation">(</span>processes<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token keyword">as</span> pool<span class="token punctuation">:</span>         <span class="token comment" spellcheck="true"># start 4 worker processes</span>
        result <span class="token operator">=</span> pool<span class="token punctuation">.</span>apply_async<span class="token punctuation">(</span>f<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># evaluate "f(10)" asynchronously in a single process</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span>result<span class="token punctuation">.</span>get<span class="token punctuation">(</span>timeout<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># prints "100" unless your computer is *very* slow</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span>pool<span class="token punctuation">.</span>map<span class="token punctuation">(</span>f<span class="token punctuation">,</span> range<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>       <span class="token comment" spellcheck="true"># prints "[0, 1, 4,..., 81]"</span>
        it <span class="token operator">=</span> pool<span class="token punctuation">.</span>imap<span class="token punctuation">(</span>f<span class="token punctuation">,</span> range<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span>next<span class="token punctuation">(</span>it<span class="token punctuation">)</span><span class="token punctuation">)</span>                     <span class="token comment" spellcheck="true"># prints "0"</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span>next<span class="token punctuation">(</span>it<span class="token punctuation">)</span><span class="token punctuation">)</span>                     <span class="token comment" spellcheck="true"># prints "1"</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span>it<span class="token punctuation">.</span>next<span class="token punctuation">(</span>timeout<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>           <span class="token comment" spellcheck="true"># prints "4" unless your computer is *very* slow</span>
        result <span class="token operator">=</span> pool<span class="token punctuation">.</span>apply_async<span class="token punctuation">(</span>time<span class="token punctuation">.</span>sleep<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span>result<span class="token punctuation">.</span>get<span class="token punctuation">(</span>timeout<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># raises multiprocessing.TimeoutError</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="监听器及客户端"><a href="#监听器及客户端" class="headerlink" title="监听器及客户端"></a>监听器及客户端</h4><p>通常情况下，进程间通过队列或者 <code>Pipe()</code> 返回的 <code>Connection</code> 传递消息。</p>
<p>不过，<code>multiprocessing.connection</code> 模块其实提供了一些更灵活的特性。最基础的用法是通过它抽象出来的高级API来操作socket或者Windows命名管道。也提供一些高级用法，如通过 <code>hmac</code> 模块来支持 <em>摘要认证</em>，以及同时监听多个管道连接。</p>
<p><code>multiprocessing.connection.deliver_challenge</code>(<em>connection</em>, <em>authkey</em>)</p>
<p>发送一个随机生成的消息到另一端，并等待回复。</p>
<p>如果收到的回复与使用 <em>authkey</em> 作为键生成的信息摘要匹配成功，就会发送一个欢迎信息给管道另一端。否则抛出 <code>AuthenticationError</code> 异常。</p>
<p><code>multiprocessing.connection.answer_challenge</code>(<em>connection</em>, <em>authkey</em>)</p>
<p>接收一条信息，使用 <em>authkey</em> 作为键计算信息摘要，然后将摘要发送回去。</p>
<p>如果没有收到欢迎消息，就抛出 <code>AuthenticationError</code> 异常。</p>
<p><code>multiprocessing.connection.Client</code>(<em>address</em>[, <em>family</em>[, <em>authkey</em>]])</p>
<p>尝试使用 <em>address</em> 地址上的监听器建立一个连接，返回 <code>Connection</code> 。</p>
<p>连接的类型取决于 <em>family</em> 参数，但是通常可以省略，因为可以通过 <em>address</em> 的格式推导出来。</p>
<p>如果提供了 <em>authkey</em> 参数并且不是 None，那它必须是一个字符串并且会被当做基于 HMAC 认证的密钥。如果 <em>authkey</em> 是None 则不会有认证行为。认证失败抛出 <code>AuthenticationError</code> 异常，请查看 See 认证密码 。</p>
<p><em>class</em> <code>multiprocessing.connection.Listener</code>([<em>address</em>[, <em>family</em>[, <em>backlog</em>[, <em>authkey</em>]]]])</p>
<p>可以监听连接请求，是对于绑定套接字或者 Windows 命名管道的封装。</p>
<p><em>address</em> 是监听器对象中的绑定套接字或命名管道使用的地址。</p>
<p>注解</p>
<p>如果使用 ‘0.0.0.0’ 作为监听地址，那么在Windows上这个地址无法建立连接。想要建立一个可连接的端点，应该使用 ‘127.0.0.1’ 。</p>
<p><em>family</em> 是套接字(或者命名管道)使用的类型。它可以是以下一种: <code>'AF_INET'</code> ( TCP 套接字类型), <code>'AF_UNIX'</code> ( Unix 域套接字) 或者 <code>'AF_PIPE'</code> ( Windows 命名管道)。其中只有第一个保证各平台可用。如果 <em>family</em> 是 <code>None</code> ,那么 family 会根据 <em>address</em> 的格式自动推导出来。如果 <em>address</em> 也是 <code>None</code> , 则取默认值。默认值为可用类型中速度最快的。注意，如果 <em>family</em> 是 <code>'AF_UNIX'</code> 而address是<code>None</code> ,套接字会在一个 <code>tempfile.mkstemp()</code> 创建的私有临时目录中创建。</p>
<p>如果监听器对象使用了套接字，<em>backlog</em> (默认值为1) 会在套接字绑定后传递给它的 <code>listen()</code> 方法。</p>
<p>如果提供了 <em>authkey</em> 参数并且不是 None，那它必须是一个字符串并且会被当做基于 HMAC 认证的密钥。如果 <em>authkey</em> 是None 则不会有认证行为。认证失败抛出 <code>AuthenticationError</code> 异常。</p>
<ul>
<li><p><code>accept</code>()</p>
<p>接受一个连接并返回一个 <code>Connection</code> 对象，其连接到的监听器对象已绑定套接字或者命名管道。如果已经尝试过认证并且失败了，则会抛出 <code>AuthenticationError</code> 异常。</p>
</li>
<li><p><code>close</code>()</p>
<p>关闭监听器对象上的绑定套接字或者命名管道。此函数会在监听器被垃圾回收后自动调用。不过仍然建议显式调用函数关闭。</p>
</li>
</ul>
<p>监听器对象拥有下列只读属性:</p>
<ul>
<li><p><code>address</code></p>
<p>监听器对象使用的地址。</p>
</li>
<li><p><code>last_accepted</code></p>
<p>最后一个连接所使用的地址。如果没有的话就是 <code>None</code> 。</p>
</li>
</ul>
<p>3.3 新版功能: 监听器对象现在支持了上下文管理协议 。 <code>__enter__()</code> 返回一个监听器对象, <code>__exit__()</code> 会调用 <code>close()</code> 。</p>
<p><code>multiprocessing.connection.wait</code>(<em>object_list</em>, <em>timeout=None</em>)</p>
<p>一直等待直到 <em>object_list</em> 中某个对象处于就绪状态。返回 <em>object_list</em> 中处于就绪状态的对象。如果 <em>timeout</em> 是一个浮点型，该方法会最多阻塞这么多秒。如果 <em>timeout</em> 是 <code>None</code> ，则会允许阻塞的事件没有限制。timeout为负数的情况下和为0的情况相同。</p>
<p>对于 Unix 和 Windows ，满足下列条件的对象可以出现在 <em>object_list</em> 中</p>
<ul>
<li>可读的 <code>Connection</code> 对象；</li>
<li>一个已连接并且可读的 <code>socket.socket</code> 对象；或者</li>
<li><code>Process</code> 对象中的 <code>sentinel</code> 属性。</li>
</ul>
<p>当一个连接或者套接字对象拥有有效的数据可被读取的时候，或者另一端关闭后，这个对象就处于就绪状态。</p>
<p><strong>Unix</strong>: <code>wait(object_list, timeout)</code> 和 <code>select.select(object_list, [], [], timeout)</code> 几乎相同。差别在于，如果 <code>select.select()</code> 被信号中断，它会抛出一个附带错误号为 <code>EINTR</code> 的 <code>OSError</code> 异常，而 <code>wait()</code> 不会。</p>
<p><strong>Windows</strong>: <em>object_list</em> 中的元素必须是一个表示为整数的可等待的句柄(按照 Win32 函数 <code>WaitForMultipleObjects()</code> 的文档中所定义) 或者一个拥有 <code>fileno()</code> 方法的对象，这个对象返回一个套接字句柄或者管道句柄。（注意管道和套接字两种句柄 <strong>不是</strong> 可等待的句柄）</p>
<p>3.3 新版功能.</p>
<p><strong>示例</strong></p>
<p>下面的服务代码创建了一个使用 <code>'secret password'</code> 作为认证密码的监听器。它会等待连接然后发送一些数据给客户端:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> multiprocessing<span class="token punctuation">.</span>connection <span class="token keyword">import</span> Listener
<span class="token keyword">from</span> array <span class="token keyword">import</span> array
address <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token string">'localhost'</span><span class="token punctuation">,</span> <span class="token number">6000</span><span class="token punctuation">)</span>     <span class="token comment" spellcheck="true"># family is deduced to be 'AF_INET'</span>
<span class="token keyword">with</span> Listener<span class="token punctuation">(</span>address<span class="token punctuation">,</span> authkey<span class="token operator">=</span>b<span class="token string">'secret password'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> listener<span class="token punctuation">:</span>
    <span class="token keyword">with</span> listener<span class="token punctuation">.</span>accept<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">as</span> conn<span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'connection accepted from'</span><span class="token punctuation">,</span> listener<span class="token punctuation">.</span>last_accepted<span class="token punctuation">)</span>
        conn<span class="token punctuation">.</span>send<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">2.25</span><span class="token punctuation">,</span> None<span class="token punctuation">,</span> <span class="token string">'junk'</span><span class="token punctuation">,</span> float<span class="token punctuation">]</span><span class="token punctuation">)</span>
        conn<span class="token punctuation">.</span>send_bytes<span class="token punctuation">(</span>b<span class="token string">'hello'</span><span class="token punctuation">)</span>
        conn<span class="token punctuation">.</span>send_bytes<span class="token punctuation">(</span>array<span class="token punctuation">(</span><span class="token string">'i'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">42</span><span class="token punctuation">,</span> <span class="token number">1729</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>下面的代码连接到服务然后从服务器上j接收一些数据:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> multiprocessing<span class="token punctuation">.</span>connection <span class="token keyword">import</span> Client
<span class="token keyword">from</span> array <span class="token keyword">import</span> array
address <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token string">'localhost'</span><span class="token punctuation">,</span> <span class="token number">6000</span><span class="token punctuation">)</span>
<span class="token keyword">with</span> Client<span class="token punctuation">(</span>address<span class="token punctuation">,</span> authkey<span class="token operator">=</span>b<span class="token string">'secret password'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> conn<span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>conn<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                  <span class="token comment" spellcheck="true"># => [2.25, None, 'junk', float]</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>conn<span class="token punctuation">.</span>recv_bytes<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token comment" spellcheck="true"># => 'hello'</span>
    arr <span class="token operator">=</span> array<span class="token punctuation">(</span><span class="token string">'i'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>conn<span class="token punctuation">.</span>recv_bytes_into<span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># => 8</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span>                          <span class="token comment" spellcheck="true"># => array('i', [42, 1729, 0, 0, 0])</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>下面的代码使用了 <code>wait()</code> ，以便在同时等待多个进程发来消息。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> time<span class="token punctuation">,</span> random
<span class="token keyword">from</span> multiprocessing <span class="token keyword">import</span> Process<span class="token punctuation">,</span> Pipe<span class="token punctuation">,</span> current_process
<span class="token keyword">from</span> multiprocessing<span class="token punctuation">.</span>connection <span class="token keyword">import</span> wait
<span class="token keyword">def</span> <span class="token function">foo</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        w<span class="token punctuation">.</span>send<span class="token punctuation">(</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> current_process<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span>
    w<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>
    readers <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        r<span class="token punctuation">,</span> w <span class="token operator">=</span> Pipe<span class="token punctuation">(</span>duplex<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span>
        readers<span class="token punctuation">.</span>append<span class="token punctuation">(</span>r<span class="token punctuation">)</span>
        p <span class="token operator">=</span> Process<span class="token punctuation">(</span>target<span class="token operator">=</span>foo<span class="token punctuation">,</span> args<span class="token operator">=</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        p<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token comment" spellcheck="true"># We close the writable end of the pipe now to be sure that</span>
        <span class="token comment" spellcheck="true"># p is the only process which owns a handle for it.  This</span>
        <span class="token comment" spellcheck="true"># ensures that when p closes its handle for the writable end,</span>
        <span class="token comment" spellcheck="true"># wait() will promptly report the readable end as being ready.</span>
        w<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">while</span> readers<span class="token punctuation">:</span>
        <span class="token keyword">for</span> r <span class="token keyword">in</span> wait<span class="token punctuation">(</span>readers<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">try</span><span class="token punctuation">:</span>
                msg <span class="token operator">=</span> r<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token keyword">except</span> EOFError<span class="token punctuation">:</span>
                readers<span class="token punctuation">.</span>remove<span class="token punctuation">(</span>r<span class="token punctuation">)</span>
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                <span class="token keyword">print</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h5 id="地址格式"><a href="#地址格式" class="headerlink" title="地址格式"></a>地址格式</h5><ul>
<li><code>'AF_INET'</code> 地址是 <code>(hostname, port)</code> 形式的元组类型，其中 <em>hostname</em> 是一个字符串，<em>port</em> 是整数。</li>
<li><code>'AF_UNIX'</code> 地址是文件系统上文件名的字符串。</li>
<li><code>'AF_PIPE'</code> 地址是一个 <code>r'\.\pipe{PipeName}'</code> 形式的字符串。 要使用 <code>Client()</code> 来连接到远程计算机上一个名为 <em>ServerName</em> 的命名管道，则应当改用 <code>r'\*ServerName*\pipe{PipeName}'</code> 形式的地址。</li>
</ul>
<p>注意，使用两个反斜线开头的字符串默认被当做 <code>'AF_PIPE'</code> 地址而不是 <code>'AF_UNIX'</code> 。</p>
<h4 id="认证密码"><a href="#认证密码" class="headerlink" title="认证密码"></a>认证密码</h4><p>当使用 <code>Connection.recv</code> 接收数据时，数据会自动被反序列化。不幸的是，对于一个不可信的数据源发来的数据，反序列化是存在安全风险的。所以 <code>Listener</code> 和 <code>Client()</code> 之间使用 <code>hmac</code> 模块进行摘要认证。</p>
<p>认证密钥是一个 byte 类型的字符串，可以认为是和密码一样的东西，连接建立好后，双方都会要求另一方证明知道认证密钥。（这个证明过程不会通过连接发送密钥）</p>
<p>如果要求认证但是没有指定认证密钥，则会使用 <code>current_process().authkey</code> 的返回值。 这个值将被当前进程所创建的任何 <code>Process</code> 对象自动继承。 这意味着 (在默认情况下) 一个包含多进程的程序中的所有进程会在相互间建立连接的时候共享单个认证密钥。</p>
<p><code>os.urandom()</code> 也可以用来生成合适的认证密钥。</p>
<h4 id="日志记录"><a href="#日志记录" class="headerlink" title="日志记录"></a>日志记录</h4><p>当前模块也提供了一些对 logging 的支持。注意， <code>logging</code> 模块本身并没有使用进程间共享的锁，所以来自于多个进程的日志可能（具体取决于使用的日志 handler 类型）相互覆盖或者混杂。</p>
<p><code>multiprocessing.get_logger</code>()</p>
<p>返回 <code>multiprocessing</code> 使用的 logger，必要的话会创建一个新的。</p>
<p>如果创建的首个 logger 日志级别为 <code>logging.NOTSET</code> 并且没有默认 handler。通过这个 logger 打印的消息不会传递到根 logger。</p>
<p>注意在 Windows 上，子进程只会继承父进程 logger 的日志级别 - 对于logger的其他自定义项不会继承。</p>
<p><code>multiprocessing.log_to_stderr</code>()</p>
<p>此函数会调用 <code>get_logger()</code> 但是会在返回的 logger 上增加一个 handler，将所有输出都使用 <code>'[%(levelname)s/%(processName)s] %(message)s'</code> 的格式发送到 <code>sys.stderr</code> 。</p>
<p>下面是一个在交互式解释器中打开日志功能的例子:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> multiprocessing<span class="token punctuation">,</span> logging
<span class="token operator">>></span><span class="token operator">></span> logger <span class="token operator">=</span> multiprocessing<span class="token punctuation">.</span>log_to_stderr<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> logger<span class="token punctuation">.</span>setLevel<span class="token punctuation">(</span>logging<span class="token punctuation">.</span>INFO<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> logger<span class="token punctuation">.</span>warning<span class="token punctuation">(</span><span class="token string">'doomed'</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span>WARNING<span class="token operator">/</span>MainProcess<span class="token punctuation">]</span> doomed
<span class="token operator">>></span><span class="token operator">></span> m <span class="token operator">=</span> multiprocessing<span class="token punctuation">.</span>Manager<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span>INFO<span class="token operator">/</span>SyncManager<span class="token operator">-</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span> child process calling self<span class="token punctuation">.</span>run<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span>INFO<span class="token operator">/</span>SyncManager<span class="token operator">-</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span> created temp directory <span class="token operator">/</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">/</span>pymp<span class="token operator">-</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">[</span>INFO<span class="token operator">/</span>SyncManager<span class="token operator">-</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span> manager serving at <span class="token string">'/.../listener-...'</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">del</span> m
<span class="token punctuation">[</span>INFO<span class="token operator">/</span>MainProcess<span class="token punctuation">]</span> sending shutdown message to manager
<span class="token punctuation">[</span>INFO<span class="token operator">/</span>SyncManager<span class="token operator">-</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span> manager exiting <span class="token keyword">with</span> exitcode <span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="multiprocessing-dummy-模块"><a href="#multiprocessing-dummy-模块" class="headerlink" title="multiprocessing.dummy 模块"></a><code>multiprocessing.dummy</code> 模块</h4><p><code>multiprocessing.dummy</code> 复制了 <code>multiprocessing</code> 的 API，不过是在 <code>threading</code> 模块之上包装了一层。</p>
<p>特别地，<code>multiprocessing.dummy</code> 所提供的 <code>Pool</code> 函数会返回一个 <code>ThreadPool</code> 的实例，该类是 <code>Pool</code> 的子类，它支持所有相同的方法调用但会使用一个工作线程池而非工作进程池。</p>
<p><em>class</em> <code>multiprocessing.pool.ThreadPool</code>([<em>processes</em>[, <em>initializer</em>[, <em>initargs</em>]]])</p>
<p>一个线程池对象，用来控制可向其提交任务的工作线程池。 <code>ThreadPool</code> 实例与 <code>Pool</code> 实例是完全接口兼容的，并且它们的资源也必须被正确地管理，或者是将线程池作为上下文管理器来使用，或者是通过手动调用 <code>close()</code> 和 <code>terminate()</code>。</p>
<p><em>processes</em> 是要使用的工作线程数目。 如果 <em>processes</em> 为 <code>None</code>，则使用 <code>os.cpu_count()</code> 返回的值。</p>
<p>如果 <em>initializer</em> 不为 <code>None</code>，则每个工作进程将会在启动时调用 <code>initializer(*initargs)</code>。</p>
<p>不同于 <code>Pool</code>，<em>maxtasksperchild</em> 和 <em>context</em> 不可被提供。</p>
<blockquote>
<p>注解</p>
<p><code>ThreadPool</code> 具有与 <code>Pool</code> 相同的接口，它围绕一个进程池进行设计并且先于 <code>concurrent.futures</code> 模块的引入。 因此，它继承了一些对于基于线程的池来说没有意义的操作，并且它具有自己的用于表示异步任务状态的类型 <code>AsyncResult</code>，该类型不为任何其他库所知。</p>
<p>用户通常应该倾向于使用 <code>concurrent.futures.ThreadPoolExecutor</code>，它拥有从一开始就围绕线程进行设计的更简单接口，并且返回与许多其他库相兼容的 <code>concurrent.futures.Future</code> 实例，包括 <code>asyncio</code> 库。</p>
</blockquote>
<h3 id="编程指导"><a href="#编程指导" class="headerlink" title="编程指导"></a>编程指导</h3><p>使用 <code>multiprocessing</code> 时，应遵循一些指导原则和习惯用法。</p>
<h4 id="所有start方法"><a href="#所有start方法" class="headerlink" title="所有start方法"></a>所有start方法</h4><p>下面这些适用于所有start方法。</p>
<p>避免共享状态</p>
<blockquote>
<p>应该尽可能避免在进程间传递大量数据，越少越好。</p>
<p>最好坚持使用队列或者管道进行进程间通信，而不是底层的同步原语。</p>
</blockquote>
<p>可序列化</p>
<blockquote>
<p>保证所代理的方法的参数是可以序列化的。</p>
</blockquote>
<p>代理的线程安全性</p>
<blockquote>
<p>不要在多线程中同时使用一个代理对象，除非你用锁保护它。</p>
<p>（而在不同进程中使用 <em>相同</em> 的代理对象却没有问题。）</p>
</blockquote>
<p>使用 Join 避免僵尸进程</p>
<blockquote>
<p>在 Unix 上，如果一个进程执行完成但是没有被 join，就会变成僵尸进程。一般来说，僵尸进程不会很多，因为每次新启动进程（或者 <code>active_children()</code> 被调用）时，所有已执行完成且没有被 join 的进程都会自动被 join，而且对一个执行完的进程调用 <code>Process.is_alive</code> 也会 join 这个进程。尽管如此，对自己启动的进程显式调用 join 依然是最佳实践。</p>
</blockquote>
<p>继承优于序列化、反序列化</p>
<blockquote>
<p>当使用 <em>spawn</em> 或者 <em>forkserver</em> 的启动方式时，<code>multiprocessing</code> 中的许多类型都必须是可序列化的，这样子进程才能使用它们。但是通常我们都应该避免使用管道和队列发送共享对象到另外一个进程，而是重新组织代码，对于其他进程创建出来的共享对象，让那些需要访问这些对象的子进程可以直接将这些对象从父进程继承过来。</p>
</blockquote>
<p>避免杀死进程</p>
<blockquote>
<p>听过 <code>Process.terminate</code> 停止一个进程很容易导致这个进程正在使用的共享资源（如锁、信号量、管道和队列）损坏或者变得不可用，无法在其他进程中继续使用。</p>
<p>所以，最好只对那些从来不使用共享资源的进程调用 <code>Process.terminate</code> 。</p>
</blockquote>
<p>Join 使用队列的进程</p>
<blockquote>
<p>记住，往队列放入数据的进程会一直等待直到队列中所有项被”feeder” 线程传给底层管道。（子进程可以调用队列的 <code>Queue.cancel_join_thread</code> 方法禁止这种行为）</p>
<p>这意味着，任何使用队列的时候，你都要确保在进程join之前，所有存放到队列中的项将会被其他进程、线程完全消费。否则不能保证这个写过队列的进程可以正常终止。记住非精灵进程会自动 join 。</p>
<p>下面是一个会导致死锁的例子:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> multiprocessing <span class="token keyword">import</span> Process<span class="token punctuation">,</span> Queue
<span class="token keyword">def</span> <span class="token function">f</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">:</span>
    q<span class="token punctuation">.</span>put<span class="token punctuation">(</span><span class="token string">'X'</span> <span class="token operator">*</span> <span class="token number">1000000</span><span class="token punctuation">)</span>
<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>
    queue <span class="token operator">=</span> Queue<span class="token punctuation">(</span><span class="token punctuation">)</span>
    p <span class="token operator">=</span> Process<span class="token punctuation">(</span>target<span class="token operator">=</span>f<span class="token punctuation">,</span> args<span class="token operator">=</span><span class="token punctuation">(</span>queue<span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    p<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>
    p<span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token punctuation">)</span>                    <span class="token comment" spellcheck="true"># this deadlocks</span>
    obj <span class="token operator">=</span> queue<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>交换最后两行可以修复这个问题（或者直接删掉 <code>p.join()</code>）。</p>
</blockquote>
<p>显式传递资源给子进程</p>
<blockquote>
<p>在Unix上，使用 <em>fork</em> 方式启动的子进程可以使用父进程中全局创建的共享资源。不过，最好是显式将资源对象通过参数的形式传递给子进程。</p>
<p>除了（部分原因）让代码兼容 Windows 以及其他的进程启动方式外，这种形式还保证了在子进程生命期这个对象是不会被父进程垃圾回收的。如果父进程中的某些对象被垃圾回收会导致资源释放，这就变得很重要。</p>
<p>所以对于实例：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> multiprocessing <span class="token keyword">import</span> Process<span class="token punctuation">,</span> Lock
<span class="token keyword">def</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> do something using <span class="token string">"lock"</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>
    lock <span class="token operator">=</span> Lock<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        Process<span class="token punctuation">(</span>target<span class="token operator">=</span>f<span class="token punctuation">)</span><span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>应当重写成这样：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> multiprocessing <span class="token keyword">import</span> Process<span class="token punctuation">,</span> Lock
<span class="token keyword">def</span> <span class="token function">f</span><span class="token punctuation">(</span>l<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> do something using <span class="token string">"l"</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>
    lock <span class="token operator">=</span> Lock<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        Process<span class="token punctuation">(</span>target<span class="token operator">=</span>f<span class="token punctuation">,</span> args<span class="token operator">=</span><span class="token punctuation">(</span>lock<span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</blockquote>
<p>谨防将 <code>sys.stdin</code> 数据替换为 “类似文件的对象”</p>
<blockquote>
<p><code>multiprocessing</code> 原本会无条件地这样调用:</p>
<pre class="line-numbers language-python"><code class="language-python">os<span class="token punctuation">.</span>close<span class="token punctuation">(</span>sys<span class="token punctuation">.</span>stdin<span class="token punctuation">.</span>fileno<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>在 <code>multiprocessing.Process._bootstrap()</code> 方法中 —— 这会导致与”进程中的进程”相关的一些问题。这已经被修改成了:</p>
<pre class="line-numbers language-python"><code class="language-python">sys<span class="token punctuation">.</span>stdin<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>
sys<span class="token punctuation">.</span>stdin <span class="token operator">=</span> open<span class="token punctuation">(</span>os<span class="token punctuation">.</span>open<span class="token punctuation">(</span>os<span class="token punctuation">.</span>devnull<span class="token punctuation">,</span> os<span class="token punctuation">.</span>O_RDONLY<span class="token punctuation">)</span><span class="token punctuation">,</span> closefd<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>它解决了进程相互冲突导致文件描述符错误的根本问题，但是对使用带缓冲的“文件类对象”替换 <code>sys.stdin()</code> 作为输出的应用程序造成了潜在的危险。如果多个进程调用了此文件类对象的 <code>close()</code> 方法，会导致相同的数据多次刷写到此对象，损坏数据。</p>
<p>如果你写入文件类对象并实现了自己的缓存，可以在每次追加缓存数据时记录当前进程id，从而将其变成 fork 安全的，当发现进程id变化后舍弃之前的缓存，例如:</p>
<pre class="line-numbers language-python"><code class="language-python">@property
<span class="token keyword">def</span> <span class="token function">cache</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
    pid <span class="token operator">=</span> os<span class="token punctuation">.</span>getpid<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> pid <span class="token operator">!=</span> self<span class="token punctuation">.</span>_pid<span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>_pid <span class="token operator">=</span> pid
        self<span class="token punctuation">.</span>_cache <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    <span class="token keyword">return</span> self<span class="token punctuation">.</span>_cache<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>需要更多信息，请查看 <a href="https://bugs.python.org/issue5155" target="_blank" rel="noopener">bpo-5155</a>, <a href="https://bugs.python.org/issue5313" target="_blank" rel="noopener">bpo-5313</a> 以及 <a href="https://bugs.python.org/issue5331" target="_blank" rel="noopener">bpo-5331</a></p>
</blockquote>
<h4 id="spawn-和-forkserver-启动方式"><a href="#spawn-和-forkserver-启动方式" class="headerlink" title="spawn 和 forkserver 启动方式"></a><em>spawn</em> 和 <em>forkserver</em> 启动方式</h4><p>相对于 <em>fork</em> 启动方式，有一些额外的限制。</p>
<p>更依赖序列化</p>
<blockquote>
<p><code>Process.__init__()</code> 的所有参数都必须可序列化。同样的，当你继承 <code>Process</code> 时，需要保证当调用 <code>Process.start</code> 方法时，实例可以被序列化。</p>
</blockquote>
<p>全局变量</p>
<blockquote>
<p>记住，如果子进程中的代码尝试访问一个全局变量，它所看到的值（如果有）可能和父进程中执行 <code>Process.start</code> 那一刻的值不一样。</p>
<p>当全局变量知识模块级别的常量时，是不会有问题的。</p>
</blockquote>
<p>安全导入主模块</p>
<blockquote>
<p>确保主模块可以被新启动的Python解释器安全导入而不会引发什么副作用（比如又启动了一个子进程）</p>
<p>例如，使用 <em>spawn</em> 或 <em>forkserver</em> 启动方式执行下面的模块，会引发 <code>RuntimeError</code> 异常而失败。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> multiprocessing <span class="token keyword">import</span> Process
<span class="token keyword">def</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'hello'</span><span class="token punctuation">)</span>
p <span class="token operator">=</span> Process<span class="token punctuation">(</span>target<span class="token operator">=</span>foo<span class="token punctuation">)</span>
p<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>应该通过下面的方法使用 <code>if __name__ == '__main__':</code> ，从而保护程序”入口点”:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> multiprocessing <span class="token keyword">import</span> Process<span class="token punctuation">,</span> freeze_support<span class="token punctuation">,</span> set_start_method
<span class="token keyword">def</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'hello'</span><span class="token punctuation">)</span>
<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>
    freeze_support<span class="token punctuation">(</span><span class="token punctuation">)</span>
    set_start_method<span class="token punctuation">(</span><span class="token string">'spawn'</span><span class="token punctuation">)</span>
    p <span class="token operator">=</span> Process<span class="token punctuation">(</span>target<span class="token operator">=</span>foo<span class="token punctuation">)</span>
    p<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>（如果程序将正常运行而不是冻结，则可以省略 <code>freeze_support()</code> 行）</p>
<p>这允许新启动的 Python 解释器安全导入模块然后运行模块中的 <code>foo()</code> 函数。</p>
<p>如果主模块中创建了进程池或者管理器，这个规则也适用。</p>
</blockquote>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>创建和使用自定义管理器、代理的示例:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> multiprocessing <span class="token keyword">import</span> freeze_support
<span class="token keyword">from</span> multiprocessing<span class="token punctuation">.</span>managers <span class="token keyword">import</span> BaseManager<span class="token punctuation">,</span> BaseProxy
<span class="token keyword">import</span> operator
<span class="token comment" spellcheck="true">##</span>
<span class="token keyword">class</span> <span class="token class-name">Foo</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">f</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'you called Foo.f()'</span><span class="token punctuation">)</span>
    <span class="token keyword">def</span> <span class="token function">g</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'you called Foo.g()'</span><span class="token punctuation">)</span>
    <span class="token keyword">def</span> <span class="token function">_h</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'you called Foo._h()'</span><span class="token punctuation">)</span>
<span class="token comment" spellcheck="true"># A simple generator function</span>
<span class="token keyword">def</span> <span class="token function">baz</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">yield</span> i<span class="token operator">*</span>i
<span class="token comment" spellcheck="true"># Proxy type for generator objects</span>
<span class="token keyword">class</span> <span class="token class-name">GeneratorProxy</span><span class="token punctuation">(</span>BaseProxy<span class="token punctuation">)</span><span class="token punctuation">:</span>
    _exposed_ <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'__next__'</span><span class="token punctuation">]</span>
    <span class="token keyword">def</span> <span class="token function">__iter__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> self
    <span class="token keyword">def</span> <span class="token function">__next__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> self<span class="token punctuation">.</span>_callmethod<span class="token punctuation">(</span><span class="token string">'__next__'</span><span class="token punctuation">)</span>
<span class="token comment" spellcheck="true"># Function to return the operator module</span>
<span class="token keyword">def</span> <span class="token function">get_operator_module</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">return</span> operator
<span class="token comment" spellcheck="true">##</span>
<span class="token keyword">class</span> <span class="token class-name">MyManager</span><span class="token punctuation">(</span>BaseManager<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">pass</span>
<span class="token comment" spellcheck="true"># register the Foo class; make `f()` and `g()` accessible via proxy</span>
MyManager<span class="token punctuation">.</span>register<span class="token punctuation">(</span><span class="token string">'Foo1'</span><span class="token punctuation">,</span> Foo<span class="token punctuation">)</span>
<span class="token comment" spellcheck="true"># register the Foo class; make `g()` and `_h()` accessible via proxy</span>
MyManager<span class="token punctuation">.</span>register<span class="token punctuation">(</span><span class="token string">'Foo2'</span><span class="token punctuation">,</span> Foo<span class="token punctuation">,</span> exposed<span class="token operator">=</span><span class="token punctuation">(</span><span class="token string">'g'</span><span class="token punctuation">,</span> <span class="token string">'_h'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment" spellcheck="true"># register the generator function baz; use `GeneratorProxy` to make proxies</span>
MyManager<span class="token punctuation">.</span>register<span class="token punctuation">(</span><span class="token string">'baz'</span><span class="token punctuation">,</span> baz<span class="token punctuation">,</span> proxytype<span class="token operator">=</span>GeneratorProxy<span class="token punctuation">)</span>
<span class="token comment" spellcheck="true"># register get_operator_module(); make public functions accessible via proxy</span>
MyManager<span class="token punctuation">.</span>register<span class="token punctuation">(</span><span class="token string">'operator'</span><span class="token punctuation">,</span> get_operator_module<span class="token punctuation">)</span>
<span class="token comment" spellcheck="true">##</span>
<span class="token keyword">def</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    manager <span class="token operator">=</span> MyManager<span class="token punctuation">(</span><span class="token punctuation">)</span>
    manager<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'-'</span> <span class="token operator">*</span> <span class="token number">20</span><span class="token punctuation">)</span>
    f1 <span class="token operator">=</span> manager<span class="token punctuation">.</span>Foo1<span class="token punctuation">(</span><span class="token punctuation">)</span>
    f1<span class="token punctuation">.</span>f<span class="token punctuation">(</span><span class="token punctuation">)</span>
    f1<span class="token punctuation">.</span>g<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">assert</span> <span class="token operator">not</span> hasattr<span class="token punctuation">(</span>f1<span class="token punctuation">,</span> <span class="token string">'_h'</span><span class="token punctuation">)</span>
    <span class="token keyword">assert</span> sorted<span class="token punctuation">(</span>f1<span class="token punctuation">.</span>_exposed_<span class="token punctuation">)</span> <span class="token operator">==</span> sorted<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'f'</span><span class="token punctuation">,</span> <span class="token string">'g'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'-'</span> <span class="token operator">*</span> <span class="token number">20</span><span class="token punctuation">)</span>
    f2 <span class="token operator">=</span> manager<span class="token punctuation">.</span>Foo2<span class="token punctuation">(</span><span class="token punctuation">)</span>
    f2<span class="token punctuation">.</span>g<span class="token punctuation">(</span><span class="token punctuation">)</span>
    f2<span class="token punctuation">.</span>_h<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">assert</span> <span class="token operator">not</span> hasattr<span class="token punctuation">(</span>f2<span class="token punctuation">,</span> <span class="token string">'f'</span><span class="token punctuation">)</span>
    <span class="token keyword">assert</span> sorted<span class="token punctuation">(</span>f2<span class="token punctuation">.</span>_exposed_<span class="token punctuation">)</span> <span class="token operator">==</span> sorted<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'g'</span><span class="token punctuation">,</span> <span class="token string">'_h'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'-'</span> <span class="token operator">*</span> <span class="token number">20</span><span class="token punctuation">)</span>
    it <span class="token operator">=</span> manager<span class="token punctuation">.</span>baz<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">for</span> i <span class="token keyword">in</span> it<span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'&lt;%d>'</span> <span class="token operator">%</span> i<span class="token punctuation">,</span> end<span class="token operator">=</span><span class="token string">' '</span><span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'-'</span> <span class="token operator">*</span> <span class="token number">20</span><span class="token punctuation">)</span>
    op <span class="token operator">=</span> manager<span class="token punctuation">.</span>operator<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'op.add(23, 45) ='</span><span class="token punctuation">,</span> op<span class="token punctuation">.</span>add<span class="token punctuation">(</span><span class="token number">23</span><span class="token punctuation">,</span> <span class="token number">45</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'op.pow(2, 94) ='</span><span class="token punctuation">,</span> op<span class="token punctuation">.</span>pow<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">94</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'op._exposed_ ='</span><span class="token punctuation">,</span> op<span class="token punctuation">.</span>_exposed_<span class="token punctuation">)</span>
<span class="token comment" spellcheck="true">##</span>
<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>
    freeze_support<span class="token punctuation">(</span><span class="token punctuation">)</span>
    test<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>使用 <code>Pool</code>:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> multiprocessing
<span class="token keyword">import</span> time
<span class="token keyword">import</span> random
<span class="token keyword">import</span> sys
<span class="token comment" spellcheck="true">#</span>
<span class="token comment" spellcheck="true"># Functions used by test code</span>
<span class="token comment" spellcheck="true">#</span>
<span class="token keyword">def</span> <span class="token function">calculate</span><span class="token punctuation">(</span>func<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">:</span>
    result <span class="token operator">=</span> func<span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token string">'%s says that %s%s = %s'</span> <span class="token operator">%</span> <span class="token punctuation">(</span>
        multiprocessing<span class="token punctuation">.</span>current_process<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>name<span class="token punctuation">,</span>
        func<span class="token punctuation">.</span>__name__<span class="token punctuation">,</span> args<span class="token punctuation">,</span> result
        <span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">calculatestar</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">return</span> calculate<span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">mul</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">:</span>
    time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">0.5</span> <span class="token operator">*</span> random<span class="token punctuation">.</span>random<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> a <span class="token operator">*</span> b
<span class="token keyword">def</span> <span class="token function">plus</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">:</span>
    time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">0.5</span> <span class="token operator">*</span> random<span class="token punctuation">.</span>random<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> a <span class="token operator">+</span> b
<span class="token keyword">def</span> <span class="token function">f</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">return</span> <span class="token number">1.0</span> <span class="token operator">/</span> <span class="token punctuation">(</span>x <span class="token operator">-</span> <span class="token number">5.0</span><span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">pow3</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">return</span> x <span class="token operator">**</span> <span class="token number">3</span>
<span class="token keyword">def</span> <span class="token function">noop</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">pass</span>
<span class="token comment" spellcheck="true">#</span>
<span class="token comment" spellcheck="true"># Test code</span>
<span class="token comment" spellcheck="true">#</span>
<span class="token keyword">def</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    PROCESSES <span class="token operator">=</span> <span class="token number">4</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Creating pool with %d processes\n'</span> <span class="token operator">%</span> PROCESSES<span class="token punctuation">)</span>
    <span class="token keyword">with</span> multiprocessing<span class="token punctuation">.</span>Pool<span class="token punctuation">(</span>PROCESSES<span class="token punctuation">)</span> <span class="token keyword">as</span> pool<span class="token punctuation">:</span>
        <span class="token comment" spellcheck="true">#</span>
        <span class="token comment" spellcheck="true"># Tests</span>
        <span class="token comment" spellcheck="true">#</span>
        TASKS <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">(</span>mul<span class="token punctuation">,</span> <span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">+</span> \
                <span class="token punctuation">[</span><span class="token punctuation">(</span>plus<span class="token punctuation">,</span> <span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
        results <span class="token operator">=</span> <span class="token punctuation">[</span>pool<span class="token punctuation">.</span>apply_async<span class="token punctuation">(</span>calculate<span class="token punctuation">,</span> t<span class="token punctuation">)</span> <span class="token keyword">for</span> t <span class="token keyword">in</span> TASKS<span class="token punctuation">]</span>
        imap_it <span class="token operator">=</span> pool<span class="token punctuation">.</span>imap<span class="token punctuation">(</span>calculatestar<span class="token punctuation">,</span> TASKS<span class="token punctuation">)</span>
        imap_unordered_it <span class="token operator">=</span> pool<span class="token punctuation">.</span>imap_unordered<span class="token punctuation">(</span>calculatestar<span class="token punctuation">,</span> TASKS<span class="token punctuation">)</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Ordered results using pool.apply_async():'</span><span class="token punctuation">)</span>
        <span class="token keyword">for</span> r <span class="token keyword">in</span> results<span class="token punctuation">:</span>
            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'\t'</span><span class="token punctuation">,</span> r<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Ordered results using pool.imap():'</span><span class="token punctuation">)</span>
        <span class="token keyword">for</span> x <span class="token keyword">in</span> imap_it<span class="token punctuation">:</span>
            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'\t'</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Unordered results using pool.imap_unordered():'</span><span class="token punctuation">)</span>
        <span class="token keyword">for</span> x <span class="token keyword">in</span> imap_unordered_it<span class="token punctuation">:</span>
            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'\t'</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Ordered results using pool.map() --- will block till complete:'</span><span class="token punctuation">)</span>
        <span class="token keyword">for</span> x <span class="token keyword">in</span> pool<span class="token punctuation">.</span>map<span class="token punctuation">(</span>calculatestar<span class="token punctuation">,</span> TASKS<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'\t'</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token comment" spellcheck="true">#</span>
        <span class="token comment" spellcheck="true"># Test error handling</span>
        <span class="token comment" spellcheck="true">#</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Testing error handling:'</span><span class="token punctuation">)</span>
        <span class="token keyword">try</span><span class="token punctuation">:</span>
            <span class="token keyword">print</span><span class="token punctuation">(</span>pool<span class="token punctuation">.</span>apply<span class="token punctuation">(</span>f<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">except</span> ZeroDivisionError<span class="token punctuation">:</span>
            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'\tGot ZeroDivisionError as expected from pool.apply()'</span><span class="token punctuation">)</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            <span class="token keyword">raise</span> AssertionError<span class="token punctuation">(</span><span class="token string">'expected ZeroDivisionError'</span><span class="token punctuation">)</span>
        <span class="token keyword">try</span><span class="token punctuation">:</span>
            <span class="token keyword">print</span><span class="token punctuation">(</span>pool<span class="token punctuation">.</span>map<span class="token punctuation">(</span>f<span class="token punctuation">,</span> list<span class="token punctuation">(</span>range<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">except</span> ZeroDivisionError<span class="token punctuation">:</span>
            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'\tGot ZeroDivisionError as expected from pool.map()'</span><span class="token punctuation">)</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            <span class="token keyword">raise</span> AssertionError<span class="token punctuation">(</span><span class="token string">'expected ZeroDivisionError'</span><span class="token punctuation">)</span>
        <span class="token keyword">try</span><span class="token punctuation">:</span>
            <span class="token keyword">print</span><span class="token punctuation">(</span>list<span class="token punctuation">(</span>pool<span class="token punctuation">.</span>imap<span class="token punctuation">(</span>f<span class="token punctuation">,</span> list<span class="token punctuation">(</span>range<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">except</span> ZeroDivisionError<span class="token punctuation">:</span>
            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'\tGot ZeroDivisionError as expected from list(pool.imap())'</span><span class="token punctuation">)</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            <span class="token keyword">raise</span> AssertionError<span class="token punctuation">(</span><span class="token string">'expected ZeroDivisionError'</span><span class="token punctuation">)</span>
        it <span class="token operator">=</span> pool<span class="token punctuation">.</span>imap<span class="token punctuation">(</span>f<span class="token punctuation">,</span> list<span class="token punctuation">(</span>range<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">try</span><span class="token punctuation">:</span>
                x <span class="token operator">=</span> next<span class="token punctuation">(</span>it<span class="token punctuation">)</span>
            <span class="token keyword">except</span> ZeroDivisionError<span class="token punctuation">:</span>
                <span class="token keyword">if</span> i <span class="token operator">==</span> <span class="token number">5</span><span class="token punctuation">:</span>
                    <span class="token keyword">pass</span>
            <span class="token keyword">except</span> StopIteration<span class="token punctuation">:</span>
                <span class="token keyword">break</span>
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                <span class="token keyword">if</span> i <span class="token operator">==</span> <span class="token number">5</span><span class="token punctuation">:</span>
                    <span class="token keyword">raise</span> AssertionError<span class="token punctuation">(</span><span class="token string">'expected ZeroDivisionError'</span><span class="token punctuation">)</span>
        <span class="token keyword">assert</span> i <span class="token operator">==</span> <span class="token number">9</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'\tGot ZeroDivisionError as expected from IMapIterator.next()'</span><span class="token punctuation">)</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token comment" spellcheck="true">#</span>
        <span class="token comment" spellcheck="true"># Testing timeouts</span>
        <span class="token comment" spellcheck="true">#</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Testing ApplyResult.get() with timeout:'</span><span class="token punctuation">,</span> end<span class="token operator">=</span><span class="token string">' '</span><span class="token punctuation">)</span>
        res <span class="token operator">=</span> pool<span class="token punctuation">.</span>apply_async<span class="token punctuation">(</span>calculate<span class="token punctuation">,</span> TASKS<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
        <span class="token keyword">while</span> <span class="token number">1</span><span class="token punctuation">:</span>
            sys<span class="token punctuation">.</span>stdout<span class="token punctuation">.</span>flush<span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token keyword">try</span><span class="token punctuation">:</span>
                sys<span class="token punctuation">.</span>stdout<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">'\n\t%s'</span> <span class="token operator">%</span> res<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token number">0.02</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token keyword">break</span>
            <span class="token keyword">except</span> multiprocessing<span class="token punctuation">.</span>TimeoutError<span class="token punctuation">:</span>
                sys<span class="token punctuation">.</span>stdout<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">'.'</span><span class="token punctuation">)</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Testing IMapIterator.next() with timeout:'</span><span class="token punctuation">,</span> end<span class="token operator">=</span><span class="token string">' '</span><span class="token punctuation">)</span>
        it <span class="token operator">=</span> pool<span class="token punctuation">.</span>imap<span class="token punctuation">(</span>calculatestar<span class="token punctuation">,</span> TASKS<span class="token punctuation">)</span>
        <span class="token keyword">while</span> <span class="token number">1</span><span class="token punctuation">:</span>
            sys<span class="token punctuation">.</span>stdout<span class="token punctuation">.</span>flush<span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token keyword">try</span><span class="token punctuation">:</span>
                sys<span class="token punctuation">.</span>stdout<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">'\n\t%s'</span> <span class="token operator">%</span> it<span class="token punctuation">.</span>next<span class="token punctuation">(</span><span class="token number">0.02</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token keyword">except</span> StopIteration<span class="token punctuation">:</span>
                <span class="token keyword">break</span>
            <span class="token keyword">except</span> multiprocessing<span class="token punctuation">.</span>TimeoutError<span class="token punctuation">:</span>
                sys<span class="token punctuation">.</span>stdout<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">'.'</span><span class="token punctuation">)</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>
    multiprocessing<span class="token punctuation">.</span>freeze_support<span class="token punctuation">(</span><span class="token punctuation">)</span>
    test<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>一个演示如何使用队列来向一组工作进程提供任务并收集结果的例子：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> time
<span class="token keyword">import</span> random
<span class="token keyword">from</span> multiprocessing <span class="token keyword">import</span> Process<span class="token punctuation">,</span> Queue<span class="token punctuation">,</span> current_process<span class="token punctuation">,</span> freeze_support
<span class="token comment" spellcheck="true">#</span>
<span class="token comment" spellcheck="true"># Function run by worker processes</span>
<span class="token comment" spellcheck="true">#</span>
<span class="token keyword">def</span> <span class="token function">worker</span><span class="token punctuation">(</span>input<span class="token punctuation">,</span> output<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">for</span> func<span class="token punctuation">,</span> args <span class="token keyword">in</span> iter<span class="token punctuation">(</span>input<span class="token punctuation">.</span>get<span class="token punctuation">,</span> <span class="token string">'STOP'</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        result <span class="token operator">=</span> calculate<span class="token punctuation">(</span>func<span class="token punctuation">,</span> args<span class="token punctuation">)</span>
        output<span class="token punctuation">.</span>put<span class="token punctuation">(</span>result<span class="token punctuation">)</span>
<span class="token comment" spellcheck="true">#</span>
<span class="token comment" spellcheck="true"># Function used to calculate result</span>
<span class="token comment" spellcheck="true">#</span>
<span class="token keyword">def</span> <span class="token function">calculate</span><span class="token punctuation">(</span>func<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">:</span>
    result <span class="token operator">=</span> func<span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token string">'%s says that %s%s = %s'</span> <span class="token operator">%</span> \
        <span class="token punctuation">(</span>current_process<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>name<span class="token punctuation">,</span> func<span class="token punctuation">.</span>__name__<span class="token punctuation">,</span> args<span class="token punctuation">,</span> result<span class="token punctuation">)</span>
<span class="token comment" spellcheck="true">#</span>
<span class="token comment" spellcheck="true"># Functions referenced by tasks</span>
<span class="token comment" spellcheck="true">#</span>
<span class="token keyword">def</span> <span class="token function">mul</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">:</span>
    time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">0.5</span><span class="token operator">*</span>random<span class="token punctuation">.</span>random<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> a <span class="token operator">*</span> b
<span class="token keyword">def</span> <span class="token function">plus</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">:</span>
    time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">0.5</span><span class="token operator">*</span>random<span class="token punctuation">.</span>random<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> a <span class="token operator">+</span> b
<span class="token comment" spellcheck="true">#</span>
<span class="token comment" spellcheck="true">#</span>
<span class="token comment" spellcheck="true">#</span>
<span class="token keyword">def</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    NUMBER_OF_PROCESSES <span class="token operator">=</span> <span class="token number">4</span>
    TASKS1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">(</span>mul<span class="token punctuation">,</span> <span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
    TASKS2 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">(</span>plus<span class="token punctuation">,</span> <span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
    <span class="token comment" spellcheck="true"># Create queues</span>
    task_queue <span class="token operator">=</span> Queue<span class="token punctuation">(</span><span class="token punctuation">)</span>
    done_queue <span class="token operator">=</span> Queue<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment" spellcheck="true"># Submit tasks</span>
    <span class="token keyword">for</span> task <span class="token keyword">in</span> TASKS1<span class="token punctuation">:</span>
        task_queue<span class="token punctuation">.</span>put<span class="token punctuation">(</span>task<span class="token punctuation">)</span>
    <span class="token comment" spellcheck="true"># Start worker processes</span>
    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>NUMBER_OF_PROCESSES<span class="token punctuation">)</span><span class="token punctuation">:</span>
        Process<span class="token punctuation">(</span>target<span class="token operator">=</span>worker<span class="token punctuation">,</span> args<span class="token operator">=</span><span class="token punctuation">(</span>task_queue<span class="token punctuation">,</span> done_queue<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment" spellcheck="true"># Get and print results</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Unordered results:'</span><span class="token punctuation">)</span>
    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>TASKS1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'\t'</span><span class="token punctuation">,</span> done_queue<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token comment" spellcheck="true"># Add more tasks using `put()`</span>
    <span class="token keyword">for</span> task <span class="token keyword">in</span> TASKS2<span class="token punctuation">:</span>
        task_queue<span class="token punctuation">.</span>put<span class="token punctuation">(</span>task<span class="token punctuation">)</span>
    <span class="token comment" spellcheck="true"># Get and print some more results</span>
    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>TASKS2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'\t'</span><span class="token punctuation">,</span> done_queue<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token comment" spellcheck="true"># Tell child processes to stop</span>
    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>NUMBER_OF_PROCESSES<span class="token punctuation">)</span><span class="token punctuation">:</span>
        task_queue<span class="token punctuation">.</span>put<span class="token punctuation">(</span><span class="token string">'STOP'</span><span class="token punctuation">)</span>
<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>
    freeze_support<span class="token punctuation">(</span><span class="token punctuation">)</span>
    test<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="multiprocessing-shared-memory-—-可从进程直接访问的共享内存"><a href="#multiprocessing-shared-memory-—-可从进程直接访问的共享内存" class="headerlink" title="multiprocessing.shared_memory —- 可从进程直接访问的共享内存"></a><code>multiprocessing.shared_memory</code> —- 可从进程直接访问的共享内存</h2><p><strong>源代码:</strong> <a href="https://github.com/python/cpython/tree/3.10/Lib/multiprocessing/shared_memory.py" target="_blank" rel="noopener">Lib/multiprocessing/shared_memory.py</a></p>
<p>3.8 新版功能.</p>
<hr>
<p>该模块提供了一个 <code>SharedMemory</code> 类，用于分配和管理多核或对称多处理器（SMP）机器上进程间的共享内存。为了协助管理不同进程间的共享内存生命周期，<code>multiprocessing.managers</code> 模块也提供了一个 <code>BaseManager</code> 的子类： <code>SharedMemoryManager</code>。</p>
<p>本模块中，共享内存是指 “System V 类型” 的共享内存块（虽然可能和它实现方式不完全一致）而不是 “分布式共享内存”。这种类型的的共享内存允许不同进程读写一片公共（或者共享）的易失性存储区域。一般来说，进程被限制只能访问属于自己进程空间的内存，但是共享内存允许跨进程共享数据，从而避免通过进程间发送消息的形式传递数据。相比通过磁盘、套接字或者其他要求序列化、反序列化和复制数据的共享形式，直接通过内存共享数据拥有更出色性能。</p>
<p><em>class</em> <code>multiprocessing.shared_memory.SharedMemory</code>(<em>name=None</em>, <em>create=False</em>, <em>size=0</em>)</p>
<p>创建一个新的共享内存块或者连接到一片已经存在的共享内存块。每个共享内存块都被指定了一个全局唯一的名称。通过这种方式，进程可以使用一个特定的名字创建共享内存区块，然后其他进程使用同样的名字连接到这个共享内存块。</p>
<p>作为一种跨进程共享数据的方式，共享内存块的寿命可能超过创建它的原始进程。一个共享内存块可能同时被多个进程使用，当一个进程不再需要访问这个共享内存块的时候，应该调用 <code>close()</code> 方法。当一个共享内存块不被任何进程使用的时候，应该调用 <code>unlink()</code> 方法以执行必要的清理。</p>
<p><em>name</em> 是共享内存的唯一名称，字符串类型。如果创建一个新共享内存块的时候，名称指定为 <code>None</code> (默认值)，将会随机产生一个新名称。</p>
<p><em>create</em> 指定创建一个新的共享内存块 (<code>True</code>) 还是连接到已存在的共享内存块 (<code>False</code>) 。</p>
<p>如果是新创建共享内存块则 <em>size</em> 用于指定块的大小为多少字节。由于某些平台是以内存页大小为最小单位来分配内存的，最终得到的内存块大小可能大于或等于要求的大小。如果是连接到已经存在的共享内存块， <code>size</code> 参数会被忽略。</p>
<ul>
<li><p><code>close</code>()</p>
<p>关闭实例对于共享内存的访问连接。所有实例确认自己不再需要使用共享内存的时候都应该调用 <code>close()</code> ，以保证必要的资源清理。调用 <code>close()</code> 并不会销毁共享内存区域。</p>
</li>
<li><p><code>unlink</code>()</p>
<p>请求销毁底层的共享内存块。为了执行必要的资源清理， 在所有使用这个共享内存块的进程中， <code>unlink()</code> 应该调用一次(且只能调用一次) 。发出此销毁请求后，共享内存块可能会、也可能不会立即销毁，且此行为在不同操作系统之间可能不同。调用 <code>unlink()</code> 后再尝试方位其中的数据可能导致内存错误。注意: 最后一个关闭共享内存访问权限的进程可以以任意顺序调用 <code>unlink()</code> 和 <code>close()</code> 。</p>
</li>
<li><p><code>buf</code></p>
<p>共享内存块内容的 memoryview 。</p>
</li>
<li><p><code>name</code></p>
<p>共享内存块的唯一标识，只读属性。</p>
</li>
<li><p><code>size</code></p>
<p>共享内存块的字节大小，只读属性。</p>
</li>
</ul>
<p>以下示例展示了 <code>SharedMemory</code> 底层的用法:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> multiprocessing <span class="token keyword">import</span> shared_memory
<span class="token operator">>></span><span class="token operator">></span> shm_a <span class="token operator">=</span> shared_memory<span class="token punctuation">.</span>SharedMemory<span class="token punctuation">(</span>create<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span> size<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> type<span class="token punctuation">(</span>shm_a<span class="token punctuation">.</span>buf<span class="token punctuation">)</span>
<span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token string">'memoryview'</span><span class="token operator">></span>
<span class="token operator">>></span><span class="token operator">></span> buffer <span class="token operator">=</span> shm_a<span class="token punctuation">.</span>buf
<span class="token operator">>></span><span class="token operator">></span> len<span class="token punctuation">(</span>buffer<span class="token punctuation">)</span>
<span class="token number">10</span>
<span class="token operator">>></span><span class="token operator">></span> buffer<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> bytearray<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">22</span><span class="token punctuation">,</span> <span class="token number">33</span><span class="token punctuation">,</span> <span class="token number">44</span><span class="token punctuation">,</span> <span class="token number">55</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># Modify multiple at once</span>
<span class="token operator">>></span><span class="token operator">></span> buffer<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">100</span>                           <span class="token comment" spellcheck="true"># Modify single byte at a time</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token comment" spellcheck="true"># Attach to an existing shared memory block</span>
<span class="token operator">>></span><span class="token operator">></span> shm_b <span class="token operator">=</span> shared_memory<span class="token punctuation">.</span>SharedMemory<span class="token punctuation">(</span>shm_a<span class="token punctuation">.</span>name<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> array
<span class="token operator">>></span><span class="token operator">></span> array<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token string">'b'</span><span class="token punctuation">,</span> shm_b<span class="token punctuation">.</span>buf<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># Copy the data into a new array.array</span>
array<span class="token punctuation">(</span><span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">22</span><span class="token punctuation">,</span> <span class="token number">33</span><span class="token punctuation">,</span> <span class="token number">44</span><span class="token punctuation">,</span> <span class="token number">55</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> shm_b<span class="token punctuation">.</span>buf<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> b<span class="token string">'howdy'</span>  <span class="token comment" spellcheck="true"># Modify via shm_b using bytes</span>
<span class="token operator">>></span><span class="token operator">></span> bytes<span class="token punctuation">(</span>shm_a<span class="token punctuation">.</span>buf<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span>      <span class="token comment" spellcheck="true"># Access via shm_a</span>
b<span class="token string">'howdy'</span>
<span class="token operator">>></span><span class="token operator">></span> shm_b<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true"># Close each SharedMemory instance</span>
<span class="token operator">>></span><span class="token operator">></span> shm_a<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> shm_a<span class="token punctuation">.</span>unlink<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># Call unlink only once to release the shared memory</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>以下示例展示了一个现实中的例子，使用 <code>SharedMemory</code> 类和 NumPy arrays 结合, 从两个 Python shell 中访问同一个 <code>numpy.ndarray</code> :</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token comment" spellcheck="true"># In the first Python interactive shell</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> numpy <span class="token keyword">as</span> np
<span class="token operator">>></span><span class="token operator">></span> a <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># Start with an existing NumPy array</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> multiprocessing <span class="token keyword">import</span> shared_memory
<span class="token operator">>></span><span class="token operator">></span> shm <span class="token operator">=</span> shared_memory<span class="token punctuation">.</span>SharedMemory<span class="token punctuation">(</span>create<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span> size<span class="token operator">=</span>a<span class="token punctuation">.</span>nbytes<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token comment" spellcheck="true"># Now create a NumPy array backed by shared memory</span>
<span class="token operator">>></span><span class="token operator">></span> b <span class="token operator">=</span> np<span class="token punctuation">.</span>ndarray<span class="token punctuation">(</span>a<span class="token punctuation">.</span>shape<span class="token punctuation">,</span> dtype<span class="token operator">=</span>a<span class="token punctuation">.</span>dtype<span class="token punctuation">,</span> buffer<span class="token operator">=</span>shm<span class="token punctuation">.</span>buf<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> b<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">]</span>  <span class="token comment" spellcheck="true"># Copy the original data into shared memory</span>
<span class="token operator">>></span><span class="token operator">></span> b
array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> type<span class="token punctuation">(</span>b<span class="token punctuation">)</span>
<span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token string">'numpy.ndarray'</span><span class="token operator">></span>
<span class="token operator">>></span><span class="token operator">></span> type<span class="token punctuation">(</span>a<span class="token punctuation">)</span>
<span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token string">'numpy.ndarray'</span><span class="token operator">></span>
<span class="token operator">>></span><span class="token operator">></span> shm<span class="token punctuation">.</span>name  <span class="token comment" spellcheck="true"># We did not specify a name so one was chosen for us</span>
<span class="token string">'psm_21467_46075'</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token comment" spellcheck="true"># In either the same shell or a new Python shell on the same machine</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> numpy <span class="token keyword">as</span> np
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> multiprocessing <span class="token keyword">import</span> shared_memory
<span class="token operator">>></span><span class="token operator">></span> <span class="token comment" spellcheck="true"># Attach to the existing shared memory block</span>
<span class="token operator">>></span><span class="token operator">></span> existing_shm <span class="token operator">=</span> shared_memory<span class="token punctuation">.</span>SharedMemory<span class="token punctuation">(</span>name<span class="token operator">=</span><span class="token string">'psm_21467_46075'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token comment" spellcheck="true"># Note that a.shape is (6,) and a.dtype is np.int64 in this example</span>
<span class="token operator">>></span><span class="token operator">></span> c <span class="token operator">=</span> np<span class="token punctuation">.</span>ndarray<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">,</span> dtype<span class="token operator">=</span>np<span class="token punctuation">.</span>int64<span class="token punctuation">,</span> buffer<span class="token operator">=</span>existing_shm<span class="token punctuation">.</span>buf<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> c
array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> c<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">888</span>
<span class="token operator">>></span><span class="token operator">></span> c
array<span class="token punctuation">(</span><span class="token punctuation">[</span>  <span class="token number">1</span><span class="token punctuation">,</span>   <span class="token number">1</span><span class="token punctuation">,</span>   <span class="token number">2</span><span class="token punctuation">,</span>   <span class="token number">3</span><span class="token punctuation">,</span>   <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">888</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token comment" spellcheck="true"># Back in the first Python interactive shell, b reflects this change</span>
<span class="token operator">>></span><span class="token operator">></span> b
array<span class="token punctuation">(</span><span class="token punctuation">[</span>  <span class="token number">1</span><span class="token punctuation">,</span>   <span class="token number">1</span><span class="token punctuation">,</span>   <span class="token number">2</span><span class="token punctuation">,</span>   <span class="token number">3</span><span class="token punctuation">,</span>   <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">888</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token comment" spellcheck="true"># Clean up from within the second Python shell</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">del</span> c  <span class="token comment" spellcheck="true"># Unnecessary; merely emphasizing the array is no longer used</span>
<span class="token operator">>></span><span class="token operator">></span> existing_shm<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token comment" spellcheck="true"># Clean up from within the first Python shell</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">del</span> b  <span class="token comment" spellcheck="true"># Unnecessary; merely emphasizing the array is no longer used</span>
<span class="token operator">>></span><span class="token operator">></span> shm<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> shm<span class="token punctuation">.</span>unlink<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># Free and release the shared memory block at the very end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><em>class</em> <code>multiprocessing.managers.SharedMemoryManager</code>([<em>address</em>[, <em>authkey</em>]])</p>
<p><code>BaseManager</code> 的子类，可用于管理跨进程的共享内存块。</p>
<p>调用 <code>SharedMemoryManager</code> 实例上的 <code>start()</code> 方法会启动一个新进程。这个新进程的唯一目的就是管理所有由它创建的共享内存块的生命周期。想要释放此进程管理的所有共享内存块，可以调用实例的 <code>shutdown()</code> 方法。这会触发执行它管理的所有 <code>SharedMemory</code> 对象的 <code>SharedMemory.unlink()</code> 方法，然后停止这个进程。通过 <code>SharedMemoryManager</code> 创建 <code>SharedMemory</code> 实例，我们可以避免手动跟踪和释放共享内存资源。</p>
<p>这个类提供了创建和返回 <code>SharedMemory</code> 实例的方法，以及以共享内存为基础创建一个列表类对象 (<code>ShareableList</code>) 的方法。</p>
<p>有关继承的可选输入参数 <em>address</em> 和 <em>authkey</em> 以及他们如何用于从进程连接已经存在的 <code>SharedMemoryManager</code> 服务，参见 <code>multiprocessing.managers.BaseManager</code> 。</p>
<ul>
<li><p><code>SharedMemory</code>(<em>size</em>)</p>
<p>使用 <code>size</code> 参数，创建一个新的指定字节大小的 <code>SharedMemory</code> 对象并返回。</p>
</li>
<li><p><code>ShareableList</code>(<em>sequence</em>)</p>
<p>创建并返回一个新的 <code>ShareableList</code> 对象，通过输入参数 <code>sequence</code> 初始化。</p>
</li>
</ul>
<p>下面的案例展示了 <code>SharedMemoryManager</code> 的基本机制:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> multiprocessing<span class="token punctuation">.</span>managers <span class="token keyword">import</span> SharedMemoryManager
<span class="token operator">>></span><span class="token operator">></span> smm <span class="token operator">=</span> SharedMemoryManager<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> smm<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># Start the process that manages the shared memory blocks</span>
<span class="token operator">>></span><span class="token operator">></span> sl <span class="token operator">=</span> smm<span class="token punctuation">.</span>ShareableList<span class="token punctuation">(</span>range<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> sl
ShareableList<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> name<span class="token operator">=</span><span class="token string">'psm_6572_7512'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> raw_shm <span class="token operator">=</span> smm<span class="token punctuation">.</span>SharedMemory<span class="token punctuation">(</span>size<span class="token operator">=</span><span class="token number">128</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> another_sl <span class="token operator">=</span> smm<span class="token punctuation">.</span>ShareableList<span class="token punctuation">(</span><span class="token string">'alpha'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> another_sl
ShareableList<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'l'</span><span class="token punctuation">,</span> <span class="token string">'p'</span><span class="token punctuation">,</span> <span class="token string">'h'</span><span class="token punctuation">,</span> <span class="token string">'a'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> name<span class="token operator">=</span><span class="token string">'psm_6572_12221'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> smm<span class="token punctuation">.</span>shutdown<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># Calls unlink() on sl, raw_shm, and another_sl</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>以下案例展示了 <code>SharedMemoryManager</code> 对象的一种可能更方便的使用方式，通过 <code>with</code> 语句来保证所有共享内存块在使用完后被释放。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">with</span> SharedMemoryManager<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">as</span> smm<span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     sl <span class="token operator">=</span> smm<span class="token punctuation">.</span>ShareableList<span class="token punctuation">(</span>range<span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token comment" spellcheck="true"># Divide the work among two processes, storing partial results in sl</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     p1 <span class="token operator">=</span> Process<span class="token punctuation">(</span>target<span class="token operator">=</span>do_work<span class="token punctuation">,</span> args<span class="token operator">=</span><span class="token punctuation">(</span>sl<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     p2 <span class="token operator">=</span> Process<span class="token punctuation">(</span>target<span class="token operator">=</span>do_work<span class="token punctuation">,</span> args<span class="token operator">=</span><span class="token punctuation">(</span>sl<span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     p1<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     p2<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># A multiprocessing.Pool might be more efficient</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     p1<span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     p2<span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true"># Wait for all work to complete in both processes</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     total_result <span class="token operator">=</span> sum<span class="token punctuation">(</span>sl<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># Consolidate the partial results now in sl</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在 <code>with</code> 语句中使用 <code>SharedMemoryManager</code> 对象的时候，使用这个管理器创建的共享内存块会在 <code>with</code> 语句代码块结束后被释放。</p>
<p><em>class</em> <code>multiprocessing.shared_memory.ShareableList</code>(<em>sequence=None</em>, <em>**,</em> name=None*)</p>
<p>提供一个可修改的类 list 对象，其中所有值都存放在共享内存块中。这限制了可被存储在其中的值只能是 <code>int</code>, <code>float</code>, <code>bool</code>, <code>str</code> （每条数据小于10M）, <code>bytes</code> （每条数据小于10M）以及 <code>None</code> 这些内置类型。它另一个显著区别于内置 <code>list</code> 类型的地方在于它的长度无法修改（比如，没有 append, insert 等操作）且不支持通过切片操作动态创建新的 <code>ShareableList</code> 实例。</p>
<p><em>sequence</em> 会被用来为一个新的 <code>ShareableList</code> 填充值。 设为 <code>None</code> 则会基于唯一的共享内存名称关联到已经存在的 <code>ShareableList</code>。</p>
<p><em>name</em> 是所请求的共享内存的唯一名称，与 <code>SharedMemory</code> 的定义中所描述的一致。 当关联到现有的 <code>ShareableList</code> 时，则指明其共享内存块的唯一名称并将 <code>sequence</code> 设为 <code>None</code>。</p>
<ul>
<li><p><code>count</code>(<em>value</em>)</p>
<p>返回 <code>value</code> 出现的次数。</p>
</li>
<li><p><code>index</code>(<em>value</em>)</p>
<p>返回 <code>value</code> 首次出现的位置，如果 <code>value</code> 不存在, 则抛出 <code>ValueError</code> 异常。</p>
</li>
<li><p><code>format</code></p>
<p>包含由所有当前存储值所使用的 <code>struct</code> 打包格式的只读属性。</p>
</li>
<li><p><code>shm</code></p>
<p>存储了值的 <code>SharedMemory</code> 实例。</p>
</li>
</ul>
<p>下面的例子演示了 <code>ShareableList</code> 实例的基本用法:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> multiprocessing <span class="token keyword">import</span> shared_memory
<span class="token operator">>></span><span class="token operator">></span> a <span class="token operator">=</span> shared_memory<span class="token punctuation">.</span>ShareableList<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'howdy'</span><span class="token punctuation">,</span> b<span class="token string">'HoWdY'</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">273.154</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">,</span> None<span class="token punctuation">,</span> <span class="token boolean">True</span><span class="token punctuation">,</span> <span class="token number">42</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token punctuation">[</span> type<span class="token punctuation">(</span>entry<span class="token punctuation">)</span> <span class="token keyword">for</span> entry <span class="token keyword">in</span> a <span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token string">'str'</span><span class="token operator">></span><span class="token punctuation">,</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token string">'bytes'</span><span class="token operator">></span><span class="token punctuation">,</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token string">'float'</span><span class="token operator">></span><span class="token punctuation">,</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token string">'int'</span><span class="token operator">></span><span class="token punctuation">,</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token string">'NoneType'</span><span class="token operator">></span><span class="token punctuation">,</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token string">'bool'</span><span class="token operator">></span><span class="token punctuation">,</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token string">'int'</span><span class="token operator">></span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> a<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span>
<span class="token operator">-</span><span class="token number">273.154</span>
<span class="token operator">>></span><span class="token operator">></span> a<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">78.5</span>
<span class="token operator">>></span><span class="token operator">></span> a<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span>
<span class="token operator">-</span><span class="token number">78.5</span>
<span class="token operator">>></span><span class="token operator">></span> a<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'dry ice'</span>  <span class="token comment" spellcheck="true"># Changing data types is supported as well</span>
<span class="token operator">>></span><span class="token operator">></span> a<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span>
<span class="token string">'dry ice'</span>
<span class="token operator">>></span><span class="token operator">></span> a<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'larger than previously allocated storage space'</span>
Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
ValueError<span class="token punctuation">:</span> exceeds available storage <span class="token keyword">for</span> existing str
<span class="token operator">>></span><span class="token operator">></span> a<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span>
<span class="token string">'dry ice'</span>
<span class="token operator">>></span><span class="token operator">></span> len<span class="token punctuation">(</span>a<span class="token punctuation">)</span>
<span class="token number">7</span>
<span class="token operator">>></span><span class="token operator">></span> a<span class="token punctuation">.</span>index<span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span>
<span class="token number">6</span>
<span class="token operator">>></span><span class="token operator">></span> a<span class="token punctuation">.</span>count<span class="token punctuation">(</span>b<span class="token string">'howdy'</span><span class="token punctuation">)</span>
<span class="token number">0</span>
<span class="token operator">>></span><span class="token operator">></span> a<span class="token punctuation">.</span>count<span class="token punctuation">(</span>b<span class="token string">'HoWdY'</span><span class="token punctuation">)</span>
<span class="token number">1</span>
<span class="token operator">>></span><span class="token operator">></span> a<span class="token punctuation">.</span>shm<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> a<span class="token punctuation">.</span>shm<span class="token punctuation">.</span>unlink<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">del</span> a  <span class="token comment" spellcheck="true"># Use of a ShareableList after call to unlink() is unsupported</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>下面的例子演示了一个、两个或多个进程如何通过提供下层的共享内存块名称来访问同一个 <code>ShareableList</code>:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> b <span class="token operator">=</span> shared_memory<span class="token punctuation">.</span>ShareableList<span class="token punctuation">(</span>range<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span>         <span class="token comment" spellcheck="true"># In a first process</span>
<span class="token operator">>></span><span class="token operator">></span> c <span class="token operator">=</span> shared_memory<span class="token punctuation">.</span>ShareableList<span class="token punctuation">(</span>name<span class="token operator">=</span>b<span class="token punctuation">.</span>shm<span class="token punctuation">.</span>name<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># In a second process</span>
<span class="token operator">>></span><span class="token operator">></span> c
ShareableList<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span> name<span class="token operator">=</span><span class="token string">'...'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> c<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">999</span>
<span class="token operator">>></span><span class="token operator">></span> b<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>
<span class="token operator">-</span><span class="token number">999</span>
<span class="token operator">>></span><span class="token operator">></span> b<span class="token punctuation">.</span>shm<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> c<span class="token punctuation">.</span>shm<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> c<span class="token punctuation">.</span>shm<span class="token punctuation">.</span>unlink<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>The following examples demonstrates that <code>ShareableList</code> (and underlying <code>SharedMemory</code>) objects can be pickled and unpickled if needed. Note, that it will still be the same shared object. This happens, because the deserialized object has the same unique name and is just attached to an existing object with the same name (if the object is still alive):</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> pickle
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> multiprocessing <span class="token keyword">import</span> shared_memory
<span class="token operator">>></span><span class="token operator">></span> sl <span class="token operator">=</span> shared_memory<span class="token punctuation">.</span>ShareableList<span class="token punctuation">(</span>range<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> list<span class="token punctuation">(</span>sl<span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">]</span>

<span class="token operator">>></span><span class="token operator">></span> deserialized_sl <span class="token operator">=</span> pickle<span class="token punctuation">.</span>loads<span class="token punctuation">(</span>pickle<span class="token punctuation">.</span>dumps<span class="token punctuation">(</span>sl<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> list<span class="token punctuation">(</span>deserialized_sl<span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">]</span>

<span class="token operator">>></span><span class="token operator">></span> sl<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span>
<span class="token operator">>></span><span class="token operator">></span> deserialized_sl<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">2</span>
<span class="token operator">>></span><span class="token operator">></span> list<span class="token punctuation">(</span>sl<span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> list<span class="token punctuation">(</span>deserialized_sl<span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">]</span>

<span class="token operator">>></span><span class="token operator">></span> sl<span class="token punctuation">.</span>shm<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> sl<span class="token punctuation">.</span>shm<span class="token punctuation">.</span>unlink<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="concurrent-包"><a href="#concurrent-包" class="headerlink" title="concurrent 包"></a><code>concurrent</code> 包</h2><p>目前，此包中只有一个模块：</p>
<ul>
<li><code>concurrent.futures</code> —— 启动并行任务</li>
</ul>
<h2 id="concurrent-futures-—-启动并行任务"><a href="#concurrent-futures-—-启动并行任务" class="headerlink" title="concurrent.futures —- 启动并行任务"></a><code>concurrent.futures</code> —- 启动并行任务</h2><p>3.2 新版功能.</p>
<p><strong>源码:</strong> <a href="https://github.com/python/cpython/tree/3.10/Lib/concurrent/futures/thread.py" target="_blank" rel="noopener">Lib/concurrent/futures/thread.py</a> 和 <a href="https://github.com/python/cpython/tree/3.10/Lib/concurrent/futures/process.py" target="_blank" rel="noopener">Lib/concurrent/futures/process.py</a></p>
<hr>
<p><code>concurrent.futures</code> 模块提供异步执行可调用对象高层接口。</p>
<p>异步执行可以由 <code>ThreadPoolExecutor</code> 使用线程或由 <code>ProcessPoolExecutor</code> 使用单独的进程来实现。 两者都是实现抽像类 <code>Executor</code> 定义的接口。</p>
<h3 id="Executor-对象"><a href="#Executor-对象" class="headerlink" title="Executor 对象"></a>Executor 对象</h3><p><em>class</em> <code>concurrent.futures.Executor</code></p>
<p>抽象类提供异步执行调用方法。要通过它的子类调用，而不是直接调用。</p>
<blockquote>
<ul>
<li><p><code>submit</code>(<em>fn</em>, <em>/</em>, <em>\</em>args<em>,</em> <em>*kwargs</em>)</p>
<p>调度可调用对象 <em>fn</em>，以 <code>fn(*args **kwargs)</code> 方式执行并返回 <code>Future</code> 对象代表可调用对象的执行。:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">with</span> ThreadPoolExecutor<span class="token punctuation">(</span>max_workers<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">as</span> executor<span class="token punctuation">:</span>
    future <span class="token operator">=</span> executor<span class="token punctuation">.</span>submit<span class="token punctuation">(</span>pow<span class="token punctuation">,</span> <span class="token number">323</span><span class="token punctuation">,</span> <span class="token number">1235</span><span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>future<span class="token punctuation">.</span>result<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><code>map</code>(<em>func</em>, <em>\</em>iterables<em>,</em> timeout=None<em>,</em> chunksize=1*)</p>
<p>类似于 <code>map(func, *iterables)</code> 函数，除了以下两点：</p>
<ul>
<li><p><em>iterables</em> 是立即执行而不是延迟执行的；</p>
</li>
<li><p><em>func</em> 是异步执行的，对 <em>func</em> 的多个调用可以并发执行。</p>
<p>如果从原始调用到 <code>Executor.map()</code> 经过 <em>timeout</em> 秒后， <code>__next__()</code> 已被调用且返回的结果还不可用，那么已返回的迭代器将触发 <code>concurrent.futures.TimeoutError</code> 。 <em>timeout</em> 可以是整数或浮点数。如果 <em>timeout</em> 没有指定或为 <code>None</code> ，则没有超时限制。<br>如果 <em>func</em> 调用引发一个异常，当从迭代器中取回它的值时这个异常将被引发。<br>使用 <code>ProcessPoolExecutor</code> 时，这个方法会将 <em>iterables</em> 分割任务块并作为独立的任务并提交到执行池中。这些块的大概数量可以由 <em>chunksize</em> 指定正整数设置。 对很长的迭代器来说，使用大的 <em>chunksize</em> 值比默认值 1 能显著地提高性能。 <em>chunksize</em> 对 <code>ThreadPoolExecutor</code> 没有效果。<br>在 3.5 版更改: 加入 <em>chunksize</em> 参数。</p>
</li>
</ul>
</li>
<li><p><code>shutdown</code>(<em>wait=True</em>, <em>**,</em> cancel_futures=False*)</p>
<p>当待执行的 future 对象完成执行后向执行者发送信号，它就会释放正在使用的任何资源。 在关闭后调用 <code>Executor.submit()</code> 和 <code>Executor.map()</code> 将会引发 <code>RuntimeError</code>。</p>
<p>如果 <em>wait</em> 为 <code>True</code> 则此方法只有在所有待执行的 future 对象完成执行且释放已分配的资源后才会返回。 如果 <em>wait</em> 为 <code>False</code>，方法立即返回，所有待执行的 future 对象完成执行后会释放已分配的资源。 不管 <em>wait</em> 的值是什么，整个 Python 程序将等到所有待执行的 future 对象完成执行后才退出。</p>
<p>如果 <em>cancel_futures</em> 为 <code>True</code>，此方法将取消所有执行器还未开始运行的挂起的 Future。 任何已完成或正在运行的 Future 将不会被取消，无论 <em>cancel_futures</em> 的值是什么？</p>
<p>如果 <em>cancel_futures</em> 和 <em>wait</em> 均为 <code>True</code>，则执行器已开始运行的所有 Future 将在此方法返回之前完成。 其余的 Future 会被取消。</p>
<p>如果使用 <code>with</code> 语句，你就可以避免显式调用这个方法，它将会停止 <code>Executor</code> (就好像 <code>Executor.shutdown()</code> 调用时 <em>wait</em> 设为 <code>True</code> 一样等待):</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> shutil
<span class="token keyword">with</span> ThreadPoolExecutor<span class="token punctuation">(</span>max_workers<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token keyword">as</span> e<span class="token punctuation">:</span>
    e<span class="token punctuation">.</span>submit<span class="token punctuation">(</span>shutil<span class="token punctuation">.</span>copy<span class="token punctuation">,</span> <span class="token string">'src1.txt'</span><span class="token punctuation">,</span> <span class="token string">'dest1.txt'</span><span class="token punctuation">)</span>
    e<span class="token punctuation">.</span>submit<span class="token punctuation">(</span>shutil<span class="token punctuation">.</span>copy<span class="token punctuation">,</span> <span class="token string">'src2.txt'</span><span class="token punctuation">,</span> <span class="token string">'dest2.txt'</span><span class="token punctuation">)</span>
    e<span class="token punctuation">.</span>submit<span class="token punctuation">(</span>shutil<span class="token punctuation">.</span>copy<span class="token punctuation">,</span> <span class="token string">'src3.txt'</span><span class="token punctuation">,</span> <span class="token string">'dest3.txt'</span><span class="token punctuation">)</span>
    e<span class="token punctuation">.</span>submit<span class="token punctuation">(</span>shutil<span class="token punctuation">.</span>copy<span class="token punctuation">,</span> <span class="token string">'src4.txt'</span><span class="token punctuation">,</span> <span class="token string">'dest4.txt'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在 3.9 版更改: 增加了 <em>cancel_futures</em>。</p>
</li>
</ul>
</blockquote>
<h3 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h3><p><code>ThreadPoolExecutor</code> 是 <code>Executor</code> 的子类，它使用线程池来异步执行调用。</p>
<p>当回调已关联了一个 <code>Future</code> 然后再等待另一个 <code>Future</code> 的结果时就会发产死锁情况。例如:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> time
<span class="token keyword">def</span> <span class="token function">wait_on_b</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span>result<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># b will never complete because it is waiting on a.</span>
    <span class="token keyword">return</span> <span class="token number">5</span>
<span class="token keyword">def</span> <span class="token function">wait_on_a</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>result<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># a will never complete because it is waiting on b.</span>
    <span class="token keyword">return</span> <span class="token number">6</span>
executor <span class="token operator">=</span> ThreadPoolExecutor<span class="token punctuation">(</span>max_workers<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span>
a <span class="token operator">=</span> executor<span class="token punctuation">.</span>submit<span class="token punctuation">(</span>wait_on_b<span class="token punctuation">)</span>
b <span class="token operator">=</span> executor<span class="token punctuation">.</span>submit<span class="token punctuation">(</span>wait_on_a<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>与:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">wait_on_future</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    f <span class="token operator">=</span> executor<span class="token punctuation">.</span>submit<span class="token punctuation">(</span>pow<span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>
    <span class="token comment" spellcheck="true"># This will never complete because there is only one worker thread and</span>
    <span class="token comment" spellcheck="true"># it is executing this function.</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token punctuation">.</span>result<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
executor <span class="token operator">=</span> ThreadPoolExecutor<span class="token punctuation">(</span>max_workers<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>
executor<span class="token punctuation">.</span>submit<span class="token punctuation">(</span>wait_on_future<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><em>class</em> <code>concurrent.futures.ThreadPoolExecutor</code>(<em>max_workers=None</em>, <em>thread_name_prefix=’’</em>, <em>initializer=None</em>, <em>initargs=()</em>)</p>
<p><code>Executor</code> 子类使用最多 <em>max_workers</em> 个线程的线程池来异步执行调用。</p>
<p><em>initializer</em> 是在每个工作者线程开始处调用的一个可选可调用对象。 <em>initargs</em> 是传递给初始化器的元组参数。任何向池提交更多工作的尝试， <em>initializer</em> 都将引发一个异常，当前所有等待的工作都会引发一个 <code>BrokenThreadPool</code>。</p>
<p>在 3.5 版更改: 如果 <em>max_workers</em> 为 <code>None</code> 或没有指定，将默认为机器处理器的个数，假如 <code>ThreadPoolExecutor</code> 则重于I/O操作而不是CPU运算，那么可以乘以 <code>5</code> ，同时工作线程的数量可以比 <code>ProcessPoolExecutor</code> 的数量高。</p>
<p>3.6 新版功能: 添加 <em>thread_name_prefix</em> 参数允许用户控制由线程池创建的 <code>threading.Thread</code> 工作线程名称以方便调试。</p>
<p>在 3.7 版更改: 加入 <em>initializer</em> 和<em>initargs</em> 参数。</p>
<p>在 3.8 版更改: <em>max_workers</em> 的默认值已改为 <code>min(32, os.cpu_count() + 4)</code>。 这个默认值会保留至少 5 个工作线程用于 I/O 密集型任务。 对于那些释放了 GIL 的 CPU 密集型任务，它最多会使用 32 个 CPU 核心。这样能够避免在多核机器上不知不觉地使用大量资源。</p>
<p>现在 ThreadPoolExecutor 在启动 <em>max_workers</em> 个工作线程之前也会重用空闲的工作线程。</p>
<h4 id="ThreadPoolExecutor-例子"><a href="#ThreadPoolExecutor-例子" class="headerlink" title="ThreadPoolExecutor 例子"></a>ThreadPoolExecutor 例子</h4><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> concurrent<span class="token punctuation">.</span>futures
<span class="token keyword">import</span> urllib<span class="token punctuation">.</span>request
URLS <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'http://www.foxnews.com/'</span><span class="token punctuation">,</span>
        <span class="token string">'http://www.cnn.com/'</span><span class="token punctuation">,</span>
        <span class="token string">'http://europe.wsj.com/'</span><span class="token punctuation">,</span>
        <span class="token string">'http://www.bbc.co.uk/'</span><span class="token punctuation">,</span>
        <span class="token string">'http://some-made-up-domain.com/'</span><span class="token punctuation">]</span>
<span class="token comment" spellcheck="true"># Retrieve a single page and report the URL and contents</span>
<span class="token keyword">def</span> <span class="token function">load_url</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span> timeout<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">with</span> urllib<span class="token punctuation">.</span>request<span class="token punctuation">.</span>urlopen<span class="token punctuation">(</span>url<span class="token punctuation">,</span> timeout<span class="token operator">=</span>timeout<span class="token punctuation">)</span> <span class="token keyword">as</span> conn<span class="token punctuation">:</span>
        <span class="token keyword">return</span> conn<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment" spellcheck="true"># We can use a with statement to ensure threads are cleaned up promptly</span>
<span class="token keyword">with</span> concurrent<span class="token punctuation">.</span>futures<span class="token punctuation">.</span>ThreadPoolExecutor<span class="token punctuation">(</span>max_workers<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">)</span> <span class="token keyword">as</span> executor<span class="token punctuation">:</span>
    <span class="token comment" spellcheck="true"># Start the load operations and mark each future with its URL</span>
    future_to_url <span class="token operator">=</span> <span class="token punctuation">{</span>executor<span class="token punctuation">.</span>submit<span class="token punctuation">(</span>load_url<span class="token punctuation">,</span> url<span class="token punctuation">,</span> <span class="token number">60</span><span class="token punctuation">)</span><span class="token punctuation">:</span> url <span class="token keyword">for</span> url <span class="token keyword">in</span> URLS<span class="token punctuation">}</span>
    <span class="token keyword">for</span> future <span class="token keyword">in</span> concurrent<span class="token punctuation">.</span>futures<span class="token punctuation">.</span>as_completed<span class="token punctuation">(</span>future_to_url<span class="token punctuation">)</span><span class="token punctuation">:</span>
        url <span class="token operator">=</span> future_to_url<span class="token punctuation">[</span>future<span class="token punctuation">]</span>
        <span class="token keyword">try</span><span class="token punctuation">:</span>
            data <span class="token operator">=</span> future<span class="token punctuation">.</span>result<span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">except</span> Exception <span class="token keyword">as</span> exc<span class="token punctuation">:</span>
            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'%r generated an exception: %s'</span> <span class="token operator">%</span> <span class="token punctuation">(</span>url<span class="token punctuation">,</span> exc<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'%r page is %d bytes'</span> <span class="token operator">%</span> <span class="token punctuation">(</span>url<span class="token punctuation">,</span> len<span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="ProcessPoolExecutor"><a href="#ProcessPoolExecutor" class="headerlink" title="ProcessPoolExecutor"></a>ProcessPoolExecutor</h3><p><code>ProcessPoolExecutor</code> 类是 <code>Executor</code> 的子类，它使用进程池来异步地执行调用。 <code>ProcessPoolExecutor</code> 会使用 <code>multiprocessing</code> 模块，这允许它绕过 全局解释器锁 但也意味着只可以处理和返回可封存的对象。</p>
<p><code>__main__</code> 模块必须可以被工作者子进程导入。这意味着 <code>ProcessPoolExecutor</code> 不可以工作在交互式解释器中。</p>
<p>从可调用对象中调用 <code>Executor</code> 或 <code>Future</code> 的方法提交给 <code>ProcessPoolExecutor</code> 会导致死锁。</p>
<p><em>class</em> <code>concurrent.futures.ProcessPoolExecutor</code>(<em>max_workers=None</em>, <em>mp_context=None</em>, <em>initializer=None</em>, <em>initargs=()</em>)</p>
<p>异步地执行调用的 <code>Executor</code> 子类使用最多具有 <em>max_workers</em> 个进程的进程池。 如果 <em>max_workers</em> 为 <code>None</code> 或未给出，它将默认为机器的处理器个数。 如果 <em>max_workers</em> 小于等于 <code>0</code>，则将引发 <code>ValueError</code>。 在 Windows 上，<em>max_workers</em> 必须小于等于 <code>61</code>，否则将引发 <code>ValueError</code>。 如果 <em>max_workers</em> 为 <code>None</code>，则所选择的默认值最多为 <code>61</code>，即使存在更多的处理器。 <em>mp_context</em> 可以是一个多进程上下文或是 None。 它将被用来启动工作进程。 如果 <em>mp_context</em> 为 <code>None</code> 或未给出，则将使用默认的多进程上下文。</p>
<p><em>initializer</em> 是一个可选的可调用对象，它会在每个工作进程启动时被调用；<em>initargs</em> 是传给 initializer 的参数元组。 如果 <em>initializer</em> 引发了异常，则所有当前在等待的任务以及任何向进程池提交更多任务的尝试都将引发 <code>BrokenProcessPool</code>。</p>
<p>在 3.3 版更改: 如果其中一个工作进程被突然终止，<code>BrokenProcessPool</code> 就会马上触发。 可预计的行为没有定义，但执行器上的操作或它的 future 对象会被冻结或死锁。</p>
<p>在 3.7 版更改: 添加 <em>mp_context</em> 参数允许用户控制由进程池创建给工作者进程的开始方法 。</p>
<p>加入 <em>initializer</em> 和<em>initargs</em> 参数。</p>
<h4 id="ProcessPoolExecutor-例子"><a href="#ProcessPoolExecutor-例子" class="headerlink" title="ProcessPoolExecutor 例子"></a>ProcessPoolExecutor 例子</h4><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> concurrent<span class="token punctuation">.</span>futures
<span class="token keyword">import</span> math
PRIMES <span class="token operator">=</span> <span class="token punctuation">[</span>
    <span class="token number">112272535095293</span><span class="token punctuation">,</span>
    <span class="token number">112582705942171</span><span class="token punctuation">,</span>
    <span class="token number">112272535095293</span><span class="token punctuation">,</span>
    <span class="token number">115280095190773</span><span class="token punctuation">,</span>
    <span class="token number">115797848077099</span><span class="token punctuation">,</span>
    <span class="token number">1099726899285419</span><span class="token punctuation">]</span>
<span class="token keyword">def</span> <span class="token function">is_prime</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> n <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token boolean">False</span>
    <span class="token keyword">if</span> n <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token boolean">True</span>
    <span class="token keyword">if</span> n <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token boolean">False</span>
    sqrt_n <span class="token operator">=</span> int<span class="token punctuation">(</span>math<span class="token punctuation">.</span>floor<span class="token punctuation">(</span>math<span class="token punctuation">.</span>sqrt<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> sqrt_n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> n <span class="token operator">%</span> i <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token boolean">False</span>
    <span class="token keyword">return</span> <span class="token boolean">True</span>
<span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">with</span> concurrent<span class="token punctuation">.</span>futures<span class="token punctuation">.</span>ProcessPoolExecutor<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">as</span> executor<span class="token punctuation">:</span>
        <span class="token keyword">for</span> number<span class="token punctuation">,</span> prime <span class="token keyword">in</span> zip<span class="token punctuation">(</span>PRIMES<span class="token punctuation">,</span> executor<span class="token punctuation">.</span>map<span class="token punctuation">(</span>is_prime<span class="token punctuation">,</span> PRIMES<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'%d is prime: %s'</span> <span class="token operator">%</span> <span class="token punctuation">(</span>number<span class="token punctuation">,</span> prime<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>
    main<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="Future-对象"><a href="#Future-对象" class="headerlink" title="Future 对象"></a>Future 对象</h3><p><code>Future</code> 类将可调用对象封装为异步执行。<code>Future</code> 实例由 <code>Executor.submit()</code> 创建。</p>
<p><em>class</em> <code>concurrent.futures.Future</code></p>
<p>将可调用对象封装为异步执行。<code>Future</code> 实例由 <code>Executor.submit()</code> 创建，除非测试，不应直接创建。</p>
<blockquote>
<ul>
<li><p><code>cancel</code>()</p>
<p>尝试取消调用。 如果调用正在执行或已结束运行不能被取消则该方法将返回 <code>False</code>，否则调用会被取消并且该方法将返回 <code>True</code>。</p>
</li>
<li><p><code>cancelled</code>()</p>
<p>如果调用成功取消返回 <code>True</code>。</p>
</li>
<li><p><code>running</code>()</p>
<p>如果调用正在执行而且不能被取消那么返回 <code>True</code> 。</p>
</li>
<li><p><code>done</code>()</p>
<p>如果调用已被取消或正常结束那么返回 <code>True</code>。</p>
</li>
<li><p><code>result</code>(<em>timeout=None</em>)</p>
<p>返回调用返回的值。如果调用还没完成那么这个方法将等待 <em>timeout</em> 秒。如果在 <em>timeout</em> 秒内没有执行完成，<code>concurrent.futures.TimeoutError</code> 将会被触发。<em>timeout</em> 可以是整数或浮点数。如果 <em>timeout</em> 没有指定或为 <code>None</code>，那么等待时间就没有限制。</p>
<p>如果 futrue 在完成前被取消则 <code>CancelledError</code> 将被触发。</p>
<p>如果调用引发了一个异常，这个方法也会引发同样的异常。</p>
</li>
<li><p><code>exception</code>(<em>timeout=None</em>)</p>
<p>返回由调用引发的异常。如果调用还没完成那么这个方法将等待 <em>timeout</em> 秒。如果在 <em>timeout</em> 秒内没有执行完成，<code>concurrent.futures.TimeoutError</code> 将会被触发。<em>timeout</em> 可以是整数或浮点数。如果 <em>timeout</em> 没有指定或为 <code>None</code>，那么等待时间就没有限制。</p>
<p>如果 futrue 在完成前被取消则 <code>CancelledError</code> 将被触发。</p>
<p>如果调用正常完成那么返回 <code>None</code>。</p>
</li>
<li><p><code>add_done_callback</code>(<em>fn</em>)</p>
<p>附加可调用 <em>fn</em> 到 future 对象。当 future 对象被取消或完成运行时，将会调用 <em>fn</em>，而这个 future 对象将作为它唯一的参数。</p>
<p>加入的可调用对象总被属于添加它们的进程中的线程按加入的顺序调用。如果可调用对象引发一个 <code>Exception</code> 子类，它会被记录下来并被忽略掉。如果可调用对象引发一个 <code>BaseException</code> 子类，这个行为没有定义。</p>
<p>如果 future 对象已经完成或已取消，<em>fn</em> 会被立即调用。</p>
</li>
</ul>
</blockquote>
<p>下面这些 <code>Future</code> 方法用于单元测试和 <code>Executor</code> 实现。</p>
<blockquote>
<ul>
<li><p><code>set_running_or_notify_cancel</code>()</p>
<p>这个方法只可以在执行关联 <code>Future</code> 工作之前由 <code>Executor</code> 实现调用或由单测试调用。</p>
<p>如果这个方法返回 <code>False</code> 那么 <code>Future</code> 已被取消，即 <code>Future.cancel()</code> 已被调用并返回 <code>True</code> 。等待 <code>Future</code> 完成 (即通过 <code>as_completed()</code> 或 <code>wait()</code>) 的线程将被唤醒。</p>
<p>如果这个方法返回 <code>True</code> 那么 <code>Future</code> 不会被取消并已将它变为正在运行状态，也就是说调用 <code>Future.running()</code> 时将返回 True。</p>
<p>这个方法只可以被调用一次并且不能在调用 <code>Future.set_result()</code> 或 <code>Future.set_exception()</code> 之后再调用。</p>
</li>
<li><p><code>set_result</code>(<em>result</em>)</p>
<p>设置将 <code>Future</code> 关联工作的结果给 <em>result</em> 。</p>
<p>这个方法只可以由 <code>Executor</code> 实现和单元测试使用。</p>
<p>在 3.8 版更改: 如果 <code>Future</code> 已经完成则此方法会引发 <code>concurrent.futures.InvalidStateError</code>。</p>
</li>
<li><p><code>set_exception</code>(<em>exception</em>)</p>
<p>设置 <code>Future</code> 关联工作的结果给 <code>Exception</code> <em>exception</em> 。</p>
<p>这个方法只可以由 <code>Executor</code> 实现和单元测试使用。</p>
<p>在 3.8 版更改: 如果 <code>Future</code> 已经完成则此方法会引发 <code>concurrent.futures.InvalidStateError</code>。</p>
</li>
</ul>
</blockquote>
<h3 id="模块函数"><a href="#模块函数" class="headerlink" title="模块函数"></a>模块函数</h3><p><code>concurrent.futures.wait</code>(<em>fs</em>, <em>timeout=None</em>, <em>return_when=ALL_COMPLETED</em>)</p>
<p>等待 <em>fs</em> 指定的 <code>Future</code> 实例（可能由不同的 <code>Executor</code> 实例创建）完成。 返回一个由集合构成的具名 2 元组。 第一个集合名称为 <code>done</code>，包含在等待完成之前已完成的期程（包括正常结束或被取消的 future 对象）。 第二个集合名称为 <code>not_done</code>，包含未完成的 future 对象（包括挂起的或正在运行的 future 对象）。</p>
<p><em>timeout</em> 可以用来控制返回前最大的等待秒数。 <em>timeout</em> 可以为 int 或 float 类型。 如果 <em>timeout</em> 未指定或为 <code>None</code> ，则不限制等待时间。</p>
<p><em>return_when</em> 指定此函数应在何时返回。它必须为以下常数之一:</p>
<table>
<thead>
<tr>
<th align="left">常量</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>FIRST_COMPLETED</code></td>
<td align="left">函数将在任意可等待对象结束或取消时返回。</td>
</tr>
<tr>
<td align="left"><code>FIRST_EXCEPTION</code></td>
<td align="left">函数将在任意可等待对象因引发异常而结束时返回。当没有引发任何异常时它就相当于 <code>ALL_COMPLETED</code>。</td>
</tr>
<tr>
<td align="left"><code>ALL_COMPLETED</code></td>
<td align="left">函数将在所有可等待对象结束或取消时返回。</td>
</tr>
</tbody></table>
<p><code>concurrent.futures.as_completed</code>(<em>fs</em>, <em>timeout=None</em>)</p>
<p>返回一个包含 <em>fs</em> 所指定的 <code>Future</code> 实例（可能由不同的 <code>Executor</code> 实例创建）的迭代器，这些实例会在完成时生成 future 对象（包括正常结束或被取消的 future 对象）。 任何由 <em>fs</em> 所指定的重复 future 对象将只被返回一次。 任何在 <code>as_completed()</code> 被调用之前完成的 future 对象将优先被生成。 如果 <code>__next__()</code> 被调用并且在对 <code>as_completed()</code> 的原始调用 <em>timeout</em> 秒之后结果仍不可用，则返回的迭代器将引发 <code>concurrent.futures.TimeoutError</code>。 <em>timeout</em> 可以为整数或浮点数。 如果 <em>timeout</em> 未指定或为 <code>None</code>，则不限制等待时间。</p>
<p>参见</p>
<p><a href="https://www.python.org/dev/peps/pep-3148" target="_blank" rel="noopener"><strong>PEP 3148</strong></a> — future 对象 - 异步执行指令。</p>
<p>该提案描述了Python标准库中包含的这个特性。</p>
<h3 id="Exception-类"><a href="#Exception-类" class="headerlink" title="Exception 类"></a>Exception 类</h3><p><em>exception</em> <code>concurrent.futures.CancelledError</code></p>
<p>future 对象被取消时会触发。</p>
<p><em>exception</em> <code>concurrent.futures.TimeoutError</code></p>
<p>future 对象执行超出给定的超时数值时引发。</p>
<p><em>exception</em> <code>concurrent.futures.BrokenExecutor</code></p>
<p>当执行器被某些原因中断而且不能用来提交或执行新任务时就会被引发派生于 <code>RuntimeError</code> 的异常类。</p>
<p>3.7 新版功能.</p>
<p><em>exception</em> <code>concurrent.futures.InvalidStateError</code></p>
<p>当某个操作在一个当前状态所不允许的 future 上执行时将被引发。</p>
<p>3.8 新版功能.</p>
<p><em>exception</em> <code>concurrent.futures.thread.BrokenThreadPool</code></p>
<p>当 <code>ThreadPoolExecutor</code> 中的其中一个工作者初始化失败时会引发派生于 <code>BrokenExecutor</code> 的异常类。</p>
<p>3.7 新版功能.</p>
<p><em>exception</em> <code>concurrent.futures.process.BrokenProcessPool</code></p>
<p>当 <code>ThreadPoolExecutor</code> 中的其中一个工作者不完整终止时(比如，被外部杀死)会引发派生于 <code>BrokenExecutor</code> ( 原名 <code>RuntimeError</code> ) 的异常类。</p>
<p>3.3 新版功能.</p>
<h2 id="sched-—-事件调度器"><a href="#sched-—-事件调度器" class="headerlink" title="sched —- 事件调度器"></a><code>sched</code> —- 事件调度器</h2><p><strong>源码：</strong> <a href="https://github.com/python/cpython/tree/3.10/Lib/sched.py" target="_blank" rel="noopener">Lib/sched.py</a></p>
<hr>
<p><code>sched</code> 模块定义了一个实现通用事件调度程序的类：</p>
<p><em>class</em> <code>sched.scheduler</code>(<em>timefunc=time.monotonic</em>, <em>delayfunc=time.sleep</em>)</p>
<p><code>scheduler</code> 类定义了一个调度事件的通用接口。 它需要两个函数来实际处理“外部世界” —— <em>timefunc</em> 应当不带参数地调用，并返回一个数字（“时间”，可以为任意单位）。 <em>delayfunc</em> 函数应当带一个参数调用，与 <em>timefunc</em> 的输出相兼容，并且应当延迟其所指定的时间单位。 每个事件运行后还将调用 <em>delayfunc</em> 并传入参数 <code>0</code> 以允许其他线程有机会在多线程应用中运行。</p>
<p>在 3.3 版更改: <em>timefunc</em> 和 <em>delayfunc</em> 参数是可选的。</p>
<p>在 3.3 版更改: <code>scheduler</code> 类可以安全的在多线程环境中使用。</p>
<p>示例:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> sched<span class="token punctuation">,</span> time
<span class="token operator">>></span><span class="token operator">></span> s <span class="token operator">=</span> sched<span class="token punctuation">.</span>scheduler<span class="token punctuation">(</span>time<span class="token punctuation">.</span>time<span class="token punctuation">,</span> time<span class="token punctuation">.</span>sleep<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">def</span> <span class="token function">print_time</span><span class="token punctuation">(</span>a<span class="token operator">=</span><span class="token string">'default'</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"From print_time"</span><span class="token punctuation">,</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">def</span> <span class="token function">print_some_times</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">print</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     s<span class="token punctuation">.</span>enter<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> print_time<span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     s<span class="token punctuation">.</span>enter<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> print_time<span class="token punctuation">,</span> argument<span class="token operator">=</span><span class="token punctuation">(</span><span class="token string">'positional'</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     s<span class="token punctuation">.</span>enter<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> print_time<span class="token punctuation">,</span> kwargs<span class="token operator">=</span><span class="token punctuation">{</span><span class="token string">'a'</span><span class="token punctuation">:</span> <span class="token string">'keyword'</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     s<span class="token punctuation">.</span>run<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">print</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> print_some_times<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token number">930343690.257</span>
From print_time <span class="token number">930343695.274</span> positional
From print_time <span class="token number">930343695.275</span> keyword
From print_time <span class="token number">930343700.273</span> default
<span class="token number">930343700.276</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="调度器对象"><a href="#调度器对象" class="headerlink" title="调度器对象"></a>调度器对象</h3><p><code>scheduler</code> 实例拥有以下方法和属性：</p>
<p><code>scheduler.enterabs</code>(<em>time</em>, <em>priority</em>, <em>action</em>, <em>argument=()</em>, <em>kwargs={}</em>)</p>
<p>安排一个新事件。 <em>time</em> 参数应该有一个数字类型兼容的返回值，与传递给构造函数的 <em>timefunc</em> 函数的返回值兼容。 计划在相同 <em>time</em> 的事件将按其 <em>priority</em> 的顺序执行。 数字越小表示优先级越高。</p>
<p>执行事件意为执行 <code>action(*argument, **kwargs)</code>。 <em>argument</em> 是包含有 <em>action</em> 的位置参数的序列。 <em>kwargs</em> 是包含 <em>action</em> 的关键字参数的字典。</p>
<p>返回值是一个事件，可用于以后取消事件。</p>
<p>在 3.3 版更改: <em>argument</em> 参数是可选的。</p>
<p>在 3.3 版更改: 添加了 <em>kwargs</em> 形参。</p>
<p><code>scheduler.enter</code>(<em>delay</em>, <em>priority</em>, <em>action</em>, <em>argument=()</em>, <em>kwargs={}</em>)</p>
<p>安排延后 <em>delay</em> 时间单位的事件。 除了相对时间，其他参数、效果和返回值与 <code>enterabs()</code> 的相同。</p>
<p>在 3.3 版更改: <em>argument</em> 参数是可选的。</p>
<p>在 3.3 版更改: 添加了 <em>kwargs</em> 形参。</p>
<p><code>scheduler.cancel</code>(<em>event</em>)</p>
<p>从队列中删除事件。 如果 <em>event</em> 不是当前队列中的事件，则此方法将引发 <code>ValueError</code>。</p>
<p><code>scheduler.empty</code>()</p>
<p>如果事件队列为空则返回 <code>True</code>。</p>
<p><code>scheduler.run</code>(<em>blocking=True</em>)</p>
<p>运行所有预定事件。 此方法将等待（使用传递给构造函数的 <code>delayfunc()</code> 函数）进行下一个事件，然后执行它，依此类推，直到没有更多的计划事件。</p>
<p>如果 <em>blocking</em> 为false，则执行由于最快到期（如果有）的预定事件，然后在调度程序中返回下一个预定调用的截止时间（如果有）。</p>
<p><em>action</em> 或 <em>delayfunc</em> 都可以引发异常。 在任何一种情况下，调度程序都将保持一致状态并传播异常。 如果 <em>action</em> 引发异常，则在将来调用 <code>run()</code> 时不会尝试该事件。</p>
<p>如果一系列事件的运行时间比下一个事件之前的可用时间长，那么调度程序将完全落后。 不会发生任何事件；调用代码负责取消不再相关的事件。</p>
<p>在 3.3 版更改: 添加了 <em>blocking</em> 形参。</p>
<pre><code>scheduler.queue</code></pre><p>只读属性按照将要运行的顺序返回即将发生的事件列表。 每个事件都显示为 named tuple ，包含以下字段：time、priority、action、argument、kwargs。</p>
<h2 id="queue-—-一个同步的队列类"><a href="#queue-—-一个同步的队列类" class="headerlink" title="queue —- 一个同步的队列类"></a><code>queue</code> —- 一个同步的队列类</h2><p><strong>源代码:</strong> <a href="https://github.com/python/cpython/tree/3.10/Lib/queue.py" target="_blank" rel="noopener">Lib/queue.py</a></p>
<hr>
<p><code>queue</code> 模块实现了多生产者、多消费者队列。这特别适用于消息必须安全地在多线程间交换的线程编程。模块中的 <code>Queue</code> 类实现了所有所需的锁定语义。</p>
<p>模块实现了三种类型的队列，它们的区别仅仅是条目取回的顺序。在 FIFO 队列中，先添加的任务先取回。在 LIFO 队列中，最近被添加的条目先取回(操作类似一个堆栈)。优先级队列中，条目将保持排序( 使用 <code>heapq</code> 模块 ) 并且最小值的条目第一个返回。</p>
<p>在内部，这三个类型的队列使用锁来临时阻塞竞争线程；然而，它们并未被设计用于线程的重入性处理。</p>
<p>此外，模块实现了一个 “简单的” FIFO 队列类型， <code>SimpleQueue</code> ，这个特殊实现为小功能在交换中提供额外的保障。</p>
<p><code>queue</code> 模块定义了下列类和异常：</p>
<p><em>class</em> <code>queue.Queue</code>(<em>maxsize=0</em>)</p>
<p>Constructor for a FIFO queue. <em>maxsize</em> is an integer that sets the upperbound limit on the number of items that can be placed in the queue. Insertion will block once this size has been reached, until queue items are consumed. If <em>maxsize</em> is less than or equal to zero, the queue size is infinite.</p>
<p><em>class</em> <code>queue.LifoQueue</code>(<em>maxsize=0</em>)</p>
<p>LIFO 队列构造函数。 <em>maxsize</em> 是个整数，用于设置可以放入队列中的项目数的上限。当达到这个大小的时候，插入操作将阻塞至队列中的项目被消费掉。如果 <em>maxsize</em> 小于等于零，队列尺寸为无限大。</p>
<p><em>class</em> <code>queue.PriorityQueue</code>(<em>maxsize=0</em>)</p>
<p>优先级队列构造函数。 <em>maxsize</em> 是个整数，用于设置可以放入队列中的项目数的上限。当达到这个大小的时候，插入操作将阻塞至队列中的项目被消费掉。如果 <em>maxsize</em> 小于等于零，队列尺寸为无限大。</p>
<p>最小值先被取出( 最小值条目是由 <code>sorted(list(entries))[0]</code> 返回的条目)。条目的典型模式是一个以下形式的元组： <code>(priority_number, data)</code> 。</p>
<p>如果 <em>data</em> 元素没有可比性，数据将被包装在一个类中，忽略数据值，仅仅比较优先级数字 ：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> dataclasses <span class="token keyword">import</span> dataclass<span class="token punctuation">,</span> field
<span class="token keyword">from</span> typing <span class="token keyword">import</span> Any
@dataclass<span class="token punctuation">(</span>order<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>
<span class="token keyword">class</span> <span class="token class-name">PrioritizedItem</span><span class="token punctuation">:</span>
    priority<span class="token punctuation">:</span> int
    item<span class="token punctuation">:</span> Any<span class="token operator">=</span>field<span class="token punctuation">(</span>compare<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><em>class</em> <code>queue.SimpleQueue</code></p>
<p>无界的 FIFO 队列构造函数。简单的队列，缺少任务跟踪等高级功能。</p>
<p>3.7 新版功能.</p>
<p><em>exception</em> <code>queue.Empty</code></p>
<p>对空的 <code>Queue</code> 对象，调用非阻塞的 <code>get()</code> (or <code>get_nowait()</code>) 时，引发的异常。</p>
<p><em>exception</em> <code>queue.Full</code></p>
<p>对满的 <code>Queue</code> 对象，调用非阻塞的 <code>put()</code> (or <code>put_nowait()</code>) 时，引发的异常。</p>
<h3 id="Queue对象"><a href="#Queue对象" class="headerlink" title="Queue对象"></a>Queue对象</h3><p>队列对象 (<code>Queue</code>, <code>LifoQueue</code>, 或者 <code>PriorityQueue</code>) 提供下列描述的公共方法。</p>
<p><code>Queue.qsize</code>()</p>
<p>返回队列的大致大小。注意，qsize() &gt; 0 不保证后续的 get() 不被阻塞，qsize() &lt; maxsize 也不保证 put() 不被阻塞。</p>
<p><code>Queue.empty</code>()</p>
<p>如果队列为空，返回 <code>True</code> ，否则返回 <code>False</code> 。如果 empty() 返回 <code>True</code> ，不保证后续调用的 put() 不被阻塞。类似的，如果 empty() 返回 <code>False</code> ，也不保证后续调用的 get() 不被阻塞。</p>
<p><code>Queue.full</code>()</p>
<p>如果队列是满的返回 <code>True</code> ，否则返回 <code>False</code> 。如果 full() 返回 <code>True</code> 不保证后续调用的 get() 不被阻塞。类似的，如果 full() 返回 <code>False</code> 也不保证后续调用的 put() 不被阻塞。</p>
<p><code>Queue.put</code>(<em>item</em>, <em>block=True</em>, <em>timeout=None</em>)</p>
<p>将 <em>item</em> 放入队列。如果可选参数 <em>block</em> 是 true 并且 <em>timeout</em> 是 <code>None</code> (默认)，则在必要时阻塞至有空闲插槽可用。如果 <em>timeout</em> 是个正数，将最多阻塞 <em>timeout</em> 秒，如果在这段时间没有可用的空闲插槽，将引发 <code>Full</code> 异常。反之 (<em>block</em> 是 false)，如果空闲插槽立即可用，则把 <em>item</em> 放入队列，否则引发 <code>Full</code> 异常 ( 在这种情况下，<em>timeout</em> 将被忽略)。</p>
<p><code>Queue.put_nowait</code>(<em>item</em>)</p>
<p>相当于 <code>put(item, False)</code> 。</p>
<p><code>Queue.get</code>(<em>block=True</em>, <em>timeout=None</em>)</p>
<p>从队列中移除并返回一个项目。如果可选参数 <em>block</em> 是 true 并且 <em>timeout</em> 是 <code>None</code> (默认值)，则在必要时阻塞至项目可得到。如果 <em>timeout</em> 是个正数，将最多阻塞 <em>timeout</em> 秒，如果在这段时间内项目不能得到，将引发 <code>Empty</code> 异常。反之 (<em>block</em> 是 false) , 如果一个项目立即可得到，则返回一个项目，否则引发 <code>Empty</code> 异常 (这种情况下，<em>timeout</em> 将被忽略)。</p>
<p>POSIX系统3.0之前，以及所有版本的Windows系统中，如果 <em>block</em> 是 true 并且 <em>timeout</em> 是 <code>None</code> ， 这个操作将进入基础锁的不间断等待。这意味着，没有异常能发生，尤其是 SIGINT 将不会触发 <code>KeyboardInterrupt</code> 异常。</p>
<p><code>Queue.get_nowait</code>()</p>
<p>相当于 <code>get(False)</code> 。</p>
<p>提供了两个方法，用于支持跟踪 排队的任务 是否 被守护的消费者线程 完整的处理。</p>
<p><code>Queue.task_done</code>()</p>
<p>表示前面排队的任务已经被完成。被队列的消费者线程使用。每个 <code>get()</code> 被用于获取一个任务， 后续调用 <code>task_done()</code> 告诉队列，该任务的处理已经完成。</p>
<p>如果 <code>join()</code> 当前正在阻塞，在所有条目都被处理后，将解除阻塞(意味着每个 <code>put()</code> 进队列的条目的 <code>task_done()</code> 都被收到)。</p>
<p>如果被调用的次数多于放入队列中的项目数量，将引发 <code>ValueError</code> 异常 。</p>
<p><code>Queue.join</code>()</p>
<p>阻塞至队列中所有的元素都被接收和处理完毕。</p>
<p>当条目添加到队列的时候，未完成任务的计数就会增加。每当消费者线程调用 <code>task_done()</code> 表示这个条目已经被回收，该条目所有工作已经完成，未完成计数就会减少。当未完成计数降到零的时候， <code>join()</code> 阻塞被解除。</p>
<p>如何等待排队的任务被完成的示例：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> threading<span class="token punctuation">,</span> queue
q <span class="token operator">=</span> queue<span class="token punctuation">.</span>Queue<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">worker</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>
        item <span class="token operator">=</span> q<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">'Working on {item}'</span><span class="token punctuation">)</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">'Finished {item}'</span><span class="token punctuation">)</span>
        q<span class="token punctuation">.</span>task_done<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment" spellcheck="true"># turn-on the worker thread</span>
threading<span class="token punctuation">.</span>Thread<span class="token punctuation">(</span>target<span class="token operator">=</span>worker<span class="token punctuation">,</span> daemon<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment" spellcheck="true"># send thirty task requests to the worker</span>
<span class="token keyword">for</span> item <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    q<span class="token punctuation">.</span>put<span class="token punctuation">(</span>item<span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'All task requests sent\n'</span><span class="token punctuation">,</span> end<span class="token operator">=</span><span class="token string">''</span><span class="token punctuation">)</span>
<span class="token comment" spellcheck="true"># block until all tasks are done</span>
q<span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'All work completed'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="SimpleQueue-对象"><a href="#SimpleQueue-对象" class="headerlink" title="SimpleQueue 对象"></a>SimpleQueue 对象</h3><p><code>SimpleQueue</code> 对象提供下列描述的公共方法。</p>
<p><code>SimpleQueue.qsize</code>()</p>
<p>返回队列的大致大小。注意，qsize() &gt; 0 不保证后续的 get() 不被阻塞。</p>
<p><code>SimpleQueue.empty</code>()</p>
<p>如果队列为空，返回 <code>True</code> ，否则返回 <code>False</code> 。如果 empty() 返回 <code>False</code> ，不保证后续调用的 get() 不被阻塞。</p>
<p><code>SimpleQueue.put</code>(<em>item</em>, <em>block=True</em>, <em>timeout=None</em>)</p>
<p>将 <em>item</em> 放入队列。此方法永不阻塞，始终成功（除了潜在的低级错误，例如内存分配失败）。可选参数 <em>block</em> 和 <em>timeout</em> 仅仅是为了保持 <code>Queue.put()</code> 的兼容性而提供，其值被忽略。</p>
<p><strong>CPython implementation detail:</strong> This method has a C implementation which is reentrant. That is, a <code>put()</code> or <code>get()</code> call can be interrupted by another <code>put()</code> call in the same thread without deadlocking or corrupting internal state inside the queue. This makes it appropriate for use in destructors such as <code>__del__</code> methods or <code>weakref</code> callbacks.</p>
<p><code>SimpleQueue.put_nowait</code>(<em>item</em>)</p>
<p>相当于 <code>put(item)</code> ，仅为保持 <code>Queue.put_nowait()</code> 兼容性而提供。</p>
<p><code>SimpleQueue.get</code>(<em>block=True</em>, <em>timeout=None</em>)</p>
<p>从队列中移除并返回一个项目。如果可选参数 <em>block</em> 是 true 并且 <em>timeout</em> 是 <code>None</code> (默认值)，则在必要时阻塞至项目可得到。如果 <em>timeout</em> 是个正数，将最多阻塞 <em>timeout</em> 秒，如果在这段时间内项目不能得到，将引发 <code>Empty</code> 异常。反之 (<em>block</em> 是 false) , 如果一个项目立即可得到，则返回一个项目，否则引发 <code>Empty</code> 异常 (这种情况下，<em>timeout</em> 将被忽略)。</p>
<p><code>SimpleQueue.get_nowait</code>()</p>
<p>相当于 <code>get(False)</code> 。</p>
<h2 id="contextvars-—-上下文变量"><a href="#contextvars-—-上下文变量" class="headerlink" title="contextvars —- 上下文变量"></a><code>contextvars</code> —- 上下文变量</h2><p>本模块提供了相关API用于管理、存储和访问上下文相关的状态。 <code>ContextVar</code> 类用于声明 <em>上下文变量</em> 并与其一起使用。函数 <code>copy_context()</code> 和类 <code>Context</code> 用于管理当前上下文和异步框架中。</p>
<p>在多并发环境中，有状态上下文管理器应该使用上下文变量，而不是 <code>threading.local()</code> 来防止他们的状态意外泄露到其他代码。</p>
<p>更多信息参见 <a href="https://www.python.org/dev/peps/pep-0567" target="_blank" rel="noopener"><strong>PEP 567</strong></a> 。</p>
<p>3.7 新版功能.</p>
<h3 id="上下文变量"><a href="#上下文变量" class="headerlink" title="上下文变量"></a>上下文变量</h3><p><em>class</em> <code>contextvars.ContextVar</code>(<em>name</em>[, <em>**,</em> default*])</p>
<p>此类用于声明一个新的上下文变量，如:</p>
<pre class="line-numbers language-python"><code class="language-python">var<span class="token punctuation">:</span> ContextVar<span class="token punctuation">[</span>int<span class="token punctuation">]</span> <span class="token operator">=</span> ContextVar<span class="token punctuation">(</span><span class="token string">'var'</span><span class="token punctuation">,</span> default<span class="token operator">=</span><span class="token number">42</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><em>name</em> 参数用于内省和调试，必需。</p>
<p>调用 <code>ContextVar.get()</code> 时，如果上下文中没有找到此变量的值，则返回可选的仅命名参数 <em>default</em> 。</p>
<p><strong>重要：</strong> 上下文变量应该在顶级模块中创建，且永远不要在闭包中创建。 <code>Context</code> 对象拥有对上下文变量的强引用，这可以让上下文变量被垃圾收集器正确回收。</p>
<ul>
<li><p><code>name</code></p>
<p>上下文变量的名称，只读属性。</p>
<p>3.7.1 新版功能.</p>
</li>
<li><p><code>get</code>([<em>default</em>])</p>
<p>返回当前上下文中此上下文变量的值。</p>
<p>如果当前上下文中此变量没有值，则此方法会:</p>
<ul>
<li>如果提供了得 话，返回传入的 <em>default</em> 值；或者</li>
<li>返回上下文变量本身的默认值， 如果创建此上下文变量时提供了默认值；或者</li>
<li>抛出 <code>LookupError</code> 异常。</li>
</ul>
</li>
<li><p><code>set</code>(<em>value</em>)</p>
<p>调用此方法设置上下文变量在当前上下文中的值。</p>
<p>必选参数 <em>value</em> 是上下文变量的新值。</p>
<p>返回一个 <code>Token</code> 对象，可通过 <code>ContextVar.reset()</code> 方法将上下文变量还原为之前某个状态。</p>
</li>
<li><p><code>reset</code>(<em>token</em>)</p>
<p>将上下文变量重置为调用 <code>ContextVar.set()</code> 之前、创建 <em>token</em> 时候的状态。</p>
<p>例如：</p>
<pre class="line-numbers language-python"><code class="language-python">var <span class="token operator">=</span> ContextVar<span class="token punctuation">(</span><span class="token string">'var'</span><span class="token punctuation">)</span>
token <span class="token operator">=</span> var<span class="token punctuation">.</span>set<span class="token punctuation">(</span><span class="token string">'new value'</span><span class="token punctuation">)</span>
<span class="token comment" spellcheck="true"># code that uses 'var'; var.get() returns 'new value'.</span>
var<span class="token punctuation">.</span>reset<span class="token punctuation">(</span>token<span class="token punctuation">)</span>
<span class="token comment" spellcheck="true"># After the reset call the var has no value again, so</span>
<span class="token comment" spellcheck="true"># var.get() would raise a LookupError.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
<p><em>class</em> <code>contextvars.Token</code></p>
<p><code>ContextVar.set()</code> 方法返回 <em>Token</em> 对象。此对象可以传递给 <code>ContextVar.reset()</code> 方法用于将上下文变量还原为调用 <em>set</em> 前的状态。</p>
<ul>
<li><p><code>Token.var</code></p>
<p>只读属性。指向创建此 token 的 <code>ContextVar</code> 对象。</p>
</li>
<li><p><code>Token.old_value</code></p>
<p>一个只读属性。 会被设为在创建此令牌的 <code>ContextVar.set()</code> 方法调用之前该变量所具有的值。 如果调用之前变量没有设置值，则它指向 <code>Token.MISSING</code> 。</p>
</li>
<li><p><code>Token.MISSING</code></p>
<p><code>Token.old_value</code> 会用到的一个标记对象。</p>
</li>
</ul>
<h3 id="手动上下文管理"><a href="#手动上下文管理" class="headerlink" title="手动上下文管理"></a>手动上下文管理</h3><p><code>contextvars.copy_context</code>()</p>
<p>返回当前上下文中 <code>Context</code> 对象的拷贝。</p>
<p>以下代码片段会获取当前上下文的拷贝并打印设置到其中的所有变量及其值:</p>
<pre class="line-numbers language-python"><code class="language-python">ctx<span class="token punctuation">:</span> Context <span class="token operator">=</span> copy_context<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>list<span class="token punctuation">(</span>ctx<span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>此函数复杂度为 O(1) ，也就是说对于只包含几个上下文变量和很多上下文变量的情况，他们是一样快的。</p>
<p><em>class</em> <code>contextvars.Context</code></p>
<p><code>ContextVars</code> 中所有值的映射。</p>
<p><code>Context()</code> 创建一个不包含任何值的空上下文。如果要获取当前上下文的拷贝，使用 <code>copy_context()</code> 函数。</p>
<p>Context 实现了 <code>collections.abc.Mapping</code> 接口。</p>
<ul>
<li><p><code>run</code>(<em>callable</em>, <em>\</em>args<em>,</em> <em>*kwargs</em>)</p>
<p>按照 <em>run</em> 方法中的参数在上下文对象中执行 <code>callable(*args, **kwargs)</code> 代码。返回执行结果，如果发生异常，则将异常透传出来。</p>
<p><em>callable</em> 中队上下文变量做出的任何修改会保留在上下文对象中:</p>
<pre class="line-numbers language-python"><code class="language-python">var <span class="token operator">=</span> ContextVar<span class="token punctuation">(</span><span class="token string">'var'</span><span class="token punctuation">)</span>
var<span class="token punctuation">.</span>set<span class="token punctuation">(</span><span class="token string">'spam'</span><span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token comment" spellcheck="true"># 'var' was set to 'spam' before</span>
    <span class="token comment" spellcheck="true"># calling 'copy_context()' and 'ctx.run(main)', so:</span>
    <span class="token comment" spellcheck="true"># var.get() == ctx[var] == 'spam'</span>
    var<span class="token punctuation">.</span>set<span class="token punctuation">(</span><span class="token string">'ham'</span><span class="token punctuation">)</span>
    <span class="token comment" spellcheck="true"># Now, after setting 'var' to 'ham':</span>
    <span class="token comment" spellcheck="true"># var.get() == ctx[var] == 'ham'</span>
ctx <span class="token operator">=</span> copy_context<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment" spellcheck="true"># Any changes that the 'main' function makes to 'var'</span>
<span class="token comment" spellcheck="true"># will be contained in 'ctx'.</span>
ctx<span class="token punctuation">.</span>run<span class="token punctuation">(</span>main<span class="token punctuation">)</span>
<span class="token comment" spellcheck="true"># The 'main()' function was run in the 'ctx' context,</span>
<span class="token comment" spellcheck="true"># so changes to 'var' are contained in it:</span>
<span class="token comment" spellcheck="true"># ctx[var] == 'ham'</span>
<span class="token comment" spellcheck="true"># However, outside of 'ctx', 'var' is still set to 'spam':</span>
<span class="token comment" spellcheck="true"># var.get() == 'spam'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>当在多个系统线程或者递归调用同一个上下文对象的此方法，抛出 <code>RuntimeError</code> 异常。</p>
</li>
<li><p><code>copy</code>()</p>
<p>返回此上下文对象的浅拷贝。</p>
</li>
<li><p><code>var in context</code></p>
<p>如果<em>context</em> 中含有名称为 <em>var</em> 的变量，返回 <code>True</code> ， 否则返回 <code>False</code> 。</p>
</li>
<li><p><code>context[var]</code></p>
<p>返回名称为 <em>var</em> 的 <code>ContextVar</code> 变量。如果上下文对象中不包含这个变量，则抛出 <code>KeyError</code> 异常。</p>
</li>
<li><p><code>get</code>(<em>var</em>[, <em>default</em>])</p>
<p>如果 <em>var</em> 在上下文对象中具有值则返回 <em>var</em> 的值。 在其他情况下返回 <em>default*。 如果未给出 *default</em> 则返回 <code>None</code>。</p>
</li>
<li><p><code>iter(context)</code></p>
<p>返回一个存储在上下文对象中的变量的迭代器。</p>
</li>
<li><p><code>len(proxy)</code></p>
<p>返回上下文对象中所设的变量的数量。</p>
</li>
<li><p><code>keys</code>()</p>
<p>返回上下文对象中的所有变量的列表。</p>
</li>
<li><p><code>values</code>()</p>
<p>返回上下文对象中所有变量值的列表。</p>
</li>
<li><p><code>items</code>()</p>
<p>返回包含上下文对象中所有变量及其值的 2 元组的列表。</p>
</li>
</ul>
<h3 id="asyncio-支持"><a href="#asyncio-支持" class="headerlink" title="asyncio 支持"></a>asyncio 支持</h3><p>上下文变量在 <code>asyncio</code> 中有原生的支持并且无需任何额外配置即可被使用。 例如，以下是一个简单的回显服务器，它使用上下文变量来让远程客户端的地址在处理该客户端的 Task 中可用:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> asyncio
<span class="token keyword">import</span> contextvars
client_addr_var <span class="token operator">=</span> contextvars<span class="token punctuation">.</span>ContextVar<span class="token punctuation">(</span><span class="token string">'client_addr'</span><span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">render_goodbye</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token comment" spellcheck="true"># The address of the currently handled client can be accessed</span>
    <span class="token comment" spellcheck="true"># without passing it explicitly to this function.</span>
    client_addr <span class="token operator">=</span> client_addr_var<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> f<span class="token string">'Good bye, client @ {client_addr}\n'</span><span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">handle_request</span><span class="token punctuation">(</span>reader<span class="token punctuation">,</span> writer<span class="token punctuation">)</span><span class="token punctuation">:</span>
    addr <span class="token operator">=</span> writer<span class="token punctuation">.</span>transport<span class="token punctuation">.</span>get_extra_info<span class="token punctuation">(</span><span class="token string">'socket'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>getpeername<span class="token punctuation">(</span><span class="token punctuation">)</span>
    client_addr_var<span class="token punctuation">.</span>set<span class="token punctuation">(</span>addr<span class="token punctuation">)</span>
    <span class="token comment" spellcheck="true"># In any code that we call is now possible to get</span>
    <span class="token comment" spellcheck="true"># client's address by calling 'client_addr_var.get()'.</span>
    <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>
        line <span class="token operator">=</span> <span class="token keyword">await</span> reader<span class="token punctuation">.</span>readline<span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span>line<span class="token punctuation">)</span>
        <span class="token keyword">if</span> <span class="token operator">not</span> line<span class="token punctuation">.</span>strip<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">break</span>
        writer<span class="token punctuation">.</span>write<span class="token punctuation">(</span>line<span class="token punctuation">)</span>
    writer<span class="token punctuation">.</span>write<span class="token punctuation">(</span>render_goodbye<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    writer<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    srv <span class="token operator">=</span> <span class="token keyword">await</span> asyncio<span class="token punctuation">.</span>start_server<span class="token punctuation">(</span>
        handle_request<span class="token punctuation">,</span> <span class="token string">'127.0.0.1'</span><span class="token punctuation">,</span> <span class="token number">8081</span><span class="token punctuation">)</span>
    <span class="token keyword">async</span> <span class="token keyword">with</span> srv<span class="token punctuation">:</span>
        <span class="token keyword">await</span> srv<span class="token punctuation">.</span>serve_forever<span class="token punctuation">(</span><span class="token punctuation">)</span>
asyncio<span class="token punctuation">.</span>run<span class="token punctuation">(</span>main<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment" spellcheck="true"># To test it you can use telnet:</span>
<span class="token comment" spellcheck="true">#     telnet 127.0.0.1 8081</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="thread-—-底层多线程-API"><a href="#thread-—-底层多线程-API" class="headerlink" title="_thread —- 底层多线程 API"></a><code>_thread</code> —- 底层多线程 API</h2><p>该模块提供了操作多个线程（也被称为 <em>轻量级进程</em> 或 <em>任务*）的底层原语 —— 多个控制线程共享全局数据空间。为了处理同步问题，也提供了简单的锁机制（也称为 *互斥锁</em> 或 <em>二进制信号</em>）。<code>threading</code> 模块基于该模块提供了更易用的高级多线程 API。</p>
<p>在 3.7 版更改: 这个模块曾经为可选项，但现在总是可用。</p>
<p>这个模块定义了以下常量和函数：</p>
<p><em>exception</em> <code>_thread.error</code></p>
<p>发生线程相关错误时抛出。</p>
<p>在 3.3 版更改: 现在是内建异常 <code>RuntimeError</code> 的别名。</p>
<pre><code>_thread.LockType</code></pre><p>锁对象的类型。</p>
<p><code>_thread.start_new_thread</code>(<em>function</em>, <em>args</em>[, <em>kwargs</em>])</p>
<p>开启一个新线程并返回其标识。 线程执行函数 <em>function</em> 并附带参数列表 <em>args</em> (必须是元组)。 可选的 <em>kwargs</em> 参数指定一个关键字参数字典。</p>
<p>当函数返回时，线程会静默地退出。</p>
<p>当函数因某个未处理异常而终结时，<code>sys.unraisablehook()</code> 会被调用以处理异常。 钩子参数的 <em>object</em> 属性为 <em>function</em>。 在默认情况下，会打印堆栈回溯然后该线程将退出（但其他线程会继续运行）。</p>
<p>当函数引发 <code>SystemExit</code> 异常时，它会被静默地忽略。</p>
<p>在 3.8 版更改: 现在会使用 <code>sys.unraisablehook()</code> 来处理未处理的异常。</p>
<p><code>_thread.interrupt_main</code>(<em>signum=signal.SIGINT</em>, <em>/</em>)</p>
<p>模拟一个信号到达主线程的效果。 线程可使用此函数来打断主线程，虽然并不保证打断将立即发生。</p>
<p>如果给出 <em>signum</em>，则表示要模拟的信号的编号。 如果未给出 <em>signum</em>，则将模拟 <code>signal.SIGINT</code>。</p>
<p>如果 Python 没有处理给定的信号 (它被设为 <code>signal.SIG_DFL</code> 或 <code>signal.SIG_IGN</code>)，此函数将不做任何操作。</p>
<p>在 3.10 版更改: 添加了 <em>signum</em> 参数来定制信号的编号。</p>
<p>注解</p>
<p>这并不会发出对应的信号而是将一个调用排入关联处理句柄的计划任务（如果句柄存在的话）。 如果你想要真的发出信号，请使用 <code>signal.raise_signal()</code>。</p>
<p><code>_thread.exit</code>()</p>
<p>抛出 <code>SystemExit</code> 异常。如果没有捕获的话，这个异常会使线程退出。</p>
<p><code>_thread.allocate_lock</code>()</p>
<p>返回一个新的锁对象。锁中的方法在后面描述。初始情况下锁处于解锁状态。</p>
<p><code>_thread.get_ident</code>()</p>
<p>返回当前线程的 “线程标识符”。它是一个非零的整数。它的值没有直接含义，主要是用作 magic cookie，比如作为含有线程相关数据的字典的索引。线程标识符可能会在线程退出，新线程创建时被复用。</p>
<p><code>_thread.get_native_id</code>()</p>
<p>返回内核分配给当前线程的原生集成线程 ID。 这是一个非负整数。 它的值可被用来在整个系统中唯一地标识这个特定线程（直到线程终结，在那之后该值可能会被 OS 回收再利用）。</p>
<p>可用性: Windows, FreeBSD, Linux, macOS, OpenBSD, NetBSD, AIX。</p>
<p>3.8 新版功能.</p>
<p><code>_thread.stack_size</code>([<em>size</em>])</p>
<p>返回创建线程时使用的堆栈大小。可选参数 <em>size</em> 指定之后新建的线程的堆栈大小，而且一定要是0（根据平台或者默认配置）或者最小是32,768(32KiB)的一个正整数。如果 <em>size</em> 没有指定，默认是0。如果不支持改变线程堆栈大小，会抛出 <code>RuntimeError</code> 错误。如果指定的堆栈大小不合法，会抛出 <code>ValueError</code> 错误并且不会修改堆栈大小。32KiB是当前最小的能保证解释器有足够堆栈空间的堆栈大小。需要注意的是部分平台对于堆栈大小会有特定的限制，例如要求大于32KiB的堆栈大小或者需要根据系统内存页面的整数倍进行分配 - 应当查阅平台文档有关详细信息（4KiB页面比较普遍，在没有更具体信息的情况下，建议的方法是使用4096的倍数作为堆栈大小）。</p>
<p>适用于: Windows，具有 POSIX 线程的系统。</p>
<pre><code>_thread.TIMEOUT_MAX</code></pre><p><code>Lock.acquire()</code> 方法中 <em>timeout</em> 参数允许的最大值。传入超过这个值的 timeout 会抛出 <code>OverflowError</code> 异常。</p>
<p>3.2 新版功能.</p>
<p>锁对象有以下方法：</p>
<p><code>lock.acquire</code>(<em>waitflag=1</em>, <em>timeout=- 1</em>)</p>
<p>没有任何可选参数时，该方法无条件申请获得锁，有必要的话会等待其他线程释放锁（同时只有一个线程能获得锁 —— 这正是锁存在的原因）。</p>
<p>如果传入了整型参数 <em>waitflag</em>，具体的行为取决于传入的值：如果是 0 的话，只会在能够立刻获取到锁时才获取，不会等待，如果是非零的话，会像之前提到的一样，无条件获取锁。</p>
<p>如果传入正浮点数参数 <em>timeout<em>，相当于指定了返回之前等待得最大秒数。如果传入负的 *timeout</em>，相当于无限期等待。如果 *waitflag</em> 是 0 的话，不能指定 <em>timeout</em>。</p>
<p>如果成功获取到所会返回 <code>True</code>，否则返回 <code>False</code>。</p>
<p>在 3.2 版更改: 新的 <em>timeout</em> 形参。</p>
<p>在 3.2 版更改: 现在获取锁的操作可以被 POSIX 信号中断。</p>
<p><code>lock.release</code>()</p>
<p>释放锁。锁必须已经被获取过，但不一定是同一个线程获取的。</p>
<p><code>lock.locked</code>()</p>
<p>返回锁的状态：如果已被某个线程获取，返回 <code>True</code>，否则返回 <code>False</code>。</p>
<p>除了这些方法之外，锁对象也可以通过 <code>with</code> 语句使用，例如：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> _thread
a_lock <span class="token operator">=</span> _thread<span class="token punctuation">.</span>allocate_lock<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">with</span> a_lock<span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"a_lock is locked while this executes"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>注意事项：</strong></p>
<ul>
<li>线程与中断奇怪地交互：<code>KeyboardInterrupt</code> 异常可能会被任意一个线程捕获。（如果 <code>signal</code> 模块可用的话，中断总是会进入主线程。）</li>
<li>调用 <code>sys.exit()</code> 或是抛出 <code>SystemExit</code> 异常等效于调用 <code>_thread.exit()</code>。</li>
<li>不可能中断锁的 <code>acquire()</code> 方法 —— <code>KeyboardInterrupt</code> 一场会在锁获取到之后发生。</li>
<li>当主线程退出时，由系统决定其他线程是否存活。在大多数系统中，这些线程会直接被杀掉，不会执行 <code>try</code> … <code>finally</code> 语句，也不会执行对象析构函数。</li>
<li>当主线程退出时，不会进行正常的清理工作（除非使用了 <code>try</code> … <code>finally</code> 语句），标准 I/O 文件也不会刷新。</li>
</ul>
<h2 id="subprocess-—-子进程管理"><a href="#subprocess-—-子进程管理" class="headerlink" title="subprocess —- 子进程管理"></a><code>subprocess</code> —- 子进程管理</h2><p><strong>源代码:</strong><a href="https://github.com/python/cpython/tree/3.10/Lib/subprocess.py" target="_blank" rel="noopener">Lib/subprocess.py</a></p>
<hr>
<p><code>subprocess</code> 模块允许你生成新的进程，连接它们的输入、输出、错误管道，并且获取它们的返回码。此模块打算代替一些老旧的模块与功能：</p>
<pre><code>os.system
os.spawn*</code></pre><p>在下面的段落中，你可以找到关于 <code>subprocess</code> 模块如何代替这些模块和功能的相关信息。</p>
<p>参见</p>
<p><a href="https://www.python.org/dev/peps/pep-0324" target="_blank" rel="noopener"><strong>PEP 324</strong></a> — 提出 subprocess 模块的 PEP</p>
<h3 id="使用-subprocess-模块"><a href="#使用-subprocess-模块" class="headerlink" title="使用 subprocess 模块"></a>使用 <code>subprocess</code> 模块</h3><p>推荐的调用子进程的方式是在任何它支持的用例中使用 <code>run()</code> 函数。对于更进阶的用例，也可以使用底层的 <code>Popen</code> 接口。</p>
<p><code>run()</code> 函数是在 Python 3.5 被添加的。</p>
<p><code>subprocess.run</code>(<em>args</em>, **<em>,</em> stdin=None<em>,</em> input=None<em>,</em> stdout=None<em>,</em> stderr=None<em>,</em> capture_output=False<em>,</em> shell=False<em>,</em> cwd=None<em>,</em> timeout=None<em>,</em> check=False<em>,</em> encoding=None<em>,</em> errors=None<em>,</em> text=None<em>,</em> env=None<em>,</em> universal_newlines=None<em>,</em> <em>*other_popen_kwargs</em>)</p>
<p>运行被 <em>arg</em> 描述的指令. 等待指令完成, 然后返回一个 <code>CompletedProcess</code> 实例.</p>
<p>以上显示的参数仅仅是最简单的一些，下面 常用参数 描述（因此在缩写签名中使用仅关键字标示）。完整的函数头和 <code>Popen</code> 的构造函数一样，此函数接受的大多数参数都被传递给该接口。（<em>timeout</em>, <em>input</em>, <em>check</em> 和 <em>capture_output</em> 除外）。</p>
<p>如果 <em>capture_output</em> 设为 true，stdout 和 stderr 将会被捕获。在使用时，内置的 <code>Popen</code> 对象将自动用 <code>stdout=PIPE</code> 和 <code>stderr=PIPE</code> 创建。<em>stdout</em> 和 <em>stderr</em> 参数不应当与 <em>capture_output</em> 同时提供。如果你希望捕获并将两个流合并在一起，使用 <code>stdout=PIPE</code> 和 <code>stderr=STDOUT</code> 来代替 <em>capture_output</em>。</p>
<p><em>timeout</em> 参数将被传递给 <code>Popen.communicate()</code>。如果发生超时，子进程将被杀死并等待。 <code>TimeoutExpired</code> 异常将在子进程中断后被抛出。</p>
<p><em>input</em> 参数将被传递给 <code>Popen.communicate()</code> 以及子进程的 stdin。 如果使用此参数，它必须是一个字节序列。 如果指定了 <em>encoding</em> 或 <em>errors</em> 或者将 <em>text</em> 设置为 <code>True</code>，那么也可以是一个字符串。 当使用此参数时，在创建内部 <code>Popen</code> 对象时将自动带上 <code>stdin=PIPE</code>，并且不能再手动指定 <em>stdin</em> 参数。</p>
<p>如果 <em>check</em> 设为 True, 并且进程以非零状态码退出, 一个 <code>CalledProcessError</code> 异常将被抛出. 这个异常的属性将设置为参数, 退出码, 以及标准输出和标准错误, 如果被捕获到.</p>
<p>如果 <em>encoding</em> 或者 <em>error</em> 被指定, 或者 <em>text</em> 被设为 True, 标准输入, 标准输出和标准错误的文件对象将通过指定的 <em>encoding</em> 和 <em>errors</em> 以文本模式打开, 否则以默认的 <code>io.TextIOWrapper</code> 打开. <em>universal_newline</em> 参数等同于 <em>text</em> 并且提供了向后兼容性. 默认情况下, 文件对象是以二进制模式打开的.</p>
<p>如果 <em>env</em> 不是 <code>None</code>, 它必须是一个字典, 为新的进程设置环境变量; 它用于替换继承的当前进程的环境的默认行为. 它将直接被传递给 <code>Popen</code>.</p>
<p>示例:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> subprocess<span class="token punctuation">.</span>run<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">"ls"</span><span class="token punctuation">,</span><span class="token string">"-l"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># doesn't capture output</span>
CompletedProcess<span class="token punctuation">(</span>args<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">'ls'</span><span class="token punctuation">,</span><span class="token string">'-l'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> returncode<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> subprocess<span class="token punctuation">.</span>run<span class="token punctuation">(</span><span class="token string">"exit 1"</span><span class="token punctuation">,</span> shell<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span> check<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>
Traceback<span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
subprocess<span class="token punctuation">.</span>CalledProcessError<span class="token punctuation">:</span>Command<span class="token string">'exit 1'</span> returned non<span class="token operator">-</span>zero exit status <span class="token number">1</span>
<span class="token operator">>></span><span class="token operator">></span> subprocess<span class="token punctuation">.</span>run<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">"ls"</span><span class="token punctuation">,</span><span class="token string">"-l"</span><span class="token punctuation">,</span><span class="token string">"/dev/null"</span><span class="token punctuation">]</span><span class="token punctuation">,</span> capture_output<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>
CompletedProcess<span class="token punctuation">(</span>args<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">'ls'</span><span class="token punctuation">,</span><span class="token string">'-l'</span><span class="token punctuation">,</span><span class="token string">'/dev/null'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> returncode<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>
stdout<span class="token operator">=</span>b<span class="token string">'crw-rw-rw- 1 root root 1, 3 Jan 23 16:23 /dev/null\n'</span><span class="token punctuation">,</span> stderr<span class="token operator">=</span>b<span class="token string">''</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>3.5 新版功能.</p>
<p>在 3.6 版更改: 添加了 <em>encoding</em> 和 <em>errors</em> 形参.</p>
<p>在 3.7 版更改: 添加了 <em>text</em> 形参, 作为 <em>universal_newlines</em> 的一个更好理解的别名. 添加了 <em>capture_output</em> 形参.</p>
<p><em>class</em><code>subprocess.CompletedProcess</code></p>
<p><code>run()</code> 的返回值, 代表一个进程已经结束.</p>
<ul>
<li><p><code>args</code></p>
<p>被用作启动进程的参数. 可能是一个列表或字符串.</p>
</li>
<li><p><code>returncode</code></p>
<p>子进程的退出状态码. 通常来说, 一个为 0 的退出码表示进程运行正常.</p>
<p>一个负值 <code>-N</code> 表示子进程被信号 <code>N</code> 中断 (仅 POSIX).</p>
</li>
<li><p><code>stdout</code></p>
<p>从子进程捕获到的标准输出. 一个字节序列, 或一个字符串, 如果 <code>run()</code> 是设置了 <em>encoding</em>, <em>errors</em> 或者 <code>text=True</code> 来运行的. 如果未有捕获, 则为 <code>None</code>.</p>
<p>如果你通过 <code>stderr=subprocess.STDOUT</code> 运行进程，标准输入和标准错误将被组合在这个属性中，并且 <code>stderr</code> 将为 <code>None</code>。</p>
</li>
<li><p><code>stderr</code></p>
<p>捕获到的子进程的标准错误. 一个字节序列, 或者一个字符串, 如果 <code>run()</code> 是设置了参数 <em>encoding</em>, <em>errors</em> 或者 <code>text=True</code> 运行的. 如果未有捕获, 则为 <code>None</code>.</p>
</li>
<li><p><code>check_returncode</code>()</p>
<p>如果 <code>returncode</code> 非零, 抛出 <code>CalledProcessError</code>.</p>
</li>
</ul>
<p>3.5 新版功能.</p>
<pre><code>subprocess.DEVNULL</code></pre><p>可被 <code>Popen</code> 的 <em>stdin</em>, <em>stdout</em> 或者 <em>stderr</em> 参数使用的特殊值, 表示使用特殊文件 <code>os.devnull</code>.</p>
<p>3.3 新版功能.</p>
<pre><code>subprocess.PIPE</code></pre><p>可被 <code>Popen</code> 的 <em>stdin</em>, <em>stdout</em> 或者 <em>stderr</em> 参数使用的特殊值, 表示打开标准流的管道. 常用于 <code>Popen.communicate()</code>.</p>
<pre><code>subprocess.STDOUT</code></pre><p>可被 <code>Popen</code> 的 <em>stdin</em> ， <em>stdout</em> 或者 <em>stderr</em> 参数使用的特殊值， 表示标准错误与标准输出使用同一句柄。</p>
<p><em>exception</em><code>subprocess.SubprocessError</code></p>
<p>此模块的其他异常的基类。</p>
<p>3.3 新版功能.</p>
<p><em>exception</em><code>subprocess.TimeoutExpired</code></p>
<p><code>SubprocessError</code> 的子类，等待子进程的过程中发生超时时被抛出。</p>
<ul>
<li><p><code>cmd</code></p>
<p>用于创建子进程的指令。</p>
</li>
<li><p><code>timeout</code></p>
<p>超时秒数。</p>
</li>
<li><p><code>output</code></p>
<p>子进程的输出， 如果被 <code>run()</code> 或 <code>check_output()</code> 捕获。否则为 <code>None</code>。</p>
</li>
<li><p><code>stdout</code></p>
<p>对 output 的别名，对应的有 <code>stderr</code>。</p>
</li>
<li><p><code>stderr</code></p>
<p>子进程的标准错误输出，如果被 <code>run()</code> 捕获。 否则为 <code>None</code>。</p>
</li>
</ul>
<p>3.3 新版功能.</p>
<p>在 3.5 版更改: 添加了 <em>stdout</em> 和 <em>stderr</em> 属性。</p>
<p><em>exception</em><code>subprocess.CalledProcessError</code></p>
<p><code>SubprocessError</code> 的子类，当一个被 <code>check_call()</code> 或 <code>check_output()</code> 函数运行的子进程返回了非零退出码时被抛出。</p>
<ul>
<li><p><code>returncode</code></p>
<p>子进程的退出状态。如果程序由一个信号终止，这将会被设为一个负的信号码。</p>
</li>
<li><p><code>cmd</code></p>
<p>用于创建子进程的指令。</p>
</li>
<li><p><code>output</code></p>
<p>子进程的输出， 如果被 <code>run()</code> 或 <code>check_output()</code> 捕获。否则为 <code>None</code>。</p>
</li>
<li><p><code>stdout</code></p>
<p>对 output 的别名，对应的有 <code>stderr</code>。</p>
</li>
<li><p><code>stderr</code></p>
<p>子进程的标准错误输出，如果被 <code>run()</code> 捕获。 否则为 <code>None</code>。</p>
</li>
</ul>
<p>在 3.5 版更改: 添加了 <em>stdout</em> 和 <em>stderr</em> 属性。</p>
<h4 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h4><p>为了支持丰富的使用案例， <code>Popen</code> 的构造函数（以及方便的函数）接受大量可选的参数。对于大多数典型的用例，许多参数可以被安全地留以它们的默认值。通常需要的参数有：</p>
<blockquote>
<p><em>args</em> 被所有调用需要，应当为一个字符串，或者一个程序参数序列。提供一个参数序列通常更好，它可以更小心地使用参数中的转义字符以及引用（例如允许文件名中的空格）。如果传递一个简单的字符串，则 <em>shell</em> 参数必须为 <code>True</code> （见下文）或者该字符串中将被运行的程序名必须用简单的命名而不指定任何参数。</p>
<p><em>stdin*， *stdout</em> 和 <em>stderr</em> 分别指定了执行的程序的标准输入、输出和标准错误文件句柄。合法的值有 <code>PIPE</code> 、 <code>DEVNULL</code> 、 一个现存的文件描述符（一个正整数）、一个现存的文件对象以及 <code>None</code>。 <code>PIPE</code> 表示应该新建一个对子进程的管道。 <code>DEVNULL</code> 表示使用特殊的文件 <code>os.devnull</code>。当使用默认设置 <code>None</code> 时，将不会进行重定向，子进程的文件流将继承自父进程。另外， <em>stderr</em> 可能为 <code>STDOUT</code>，表示来自于子进程的标准错误数据应该被 <em>stdout</em> 相同的句柄捕获。</p>
<p>如果 <em>encoding</em> 或 <em>errors</em> 被指定，或者 <em>text</em> （也名为 <em>universal_newlines*）为真，则文件对象 *stdin</em> 、 <em>stdout</em> 与 <em>stderr</em> 将会使用在此次调用中指定的 <em>encoding</em> 和 <em>errors</em> 以文本模式打开或者为默认的 <code>io.TextIOWrapper</code>。</p>
<p>当构造函数的 <em>newline</em> 参数为 <code>None</code> 时。对于 <em>stdin*， 输入的换行符 <code>'\n'</code> 将被转换为默认的换行符 <code>os.linesep</code>。对于 *stdout</em> 和 <em>stderr</em>， 所有输出的换行符都被转换为 <code>'\n'</code>。更多信息。</p>
<p>如果文本模式未被使用， <em>stdin*， *stdout</em> 和 <em>stderr</em> 将会以二进制流模式打开。没有编码与换行符转换发生。</p>
<p>3.6 新版功能: 添加了 <em>encoding</em> 和 <em>errors</em> 形参。</p>
<p>3.7 新版功能: 添加了 <em>text</em> 形参作为 <em>universal_newlines</em> 的别名。</p>
<p>注解</p>
<p>文件对象 <code>Popen.stdin</code> 、 <code>Popen.stdout</code> 和 <code>Popen.stderr</code> 的换行符属性不会被 <code>Popen.communicate()</code> 方法更新。</p>
<p>如果 <em>shell</em> 设为 <code>True</code>,，则使用 shell 执行指定的指令。如果您主要使用 Python 增强的控制流（它比大多数系统 shell 提供的强大），并且仍然希望方便地使用其他 shell 功能，如 shell 管道、文件通配符、环境变量展开以及 <code>~</code> 展开到用户家目录，这将非常有用。但是，注意 Python 自己也实现了许多类似 shell 的特性（例如 <code>glob</code>, <code>fnmatch</code>, <code>os.walk()</code>, <code>os.path.expandvars()</code>, <code>os.path.expanduser()</code> 和 <code>shutil</code>）。</p>
<p>在 3.3 版更改: 当 <em>universal_newline</em> 被设为 <code>True</code>，则类使用 <code>locale.getpreferredencoding(False)</code> 编码来代替 <code>locale.getpreferredencoding()</code>。</p>
</blockquote>
<p>这些选项以及所有其他选项在 <code>Popen</code> 构造函数文档中有更详细的描述。</p>
<h4 id="Popen-构造函数"><a href="#Popen-构造函数" class="headerlink" title="Popen 构造函数"></a>Popen 构造函数</h4><p>此模块的底层的进程创建与管理由 <code>Popen</code> 类处理。它提供了很大的灵活性，因此开发者能够处理未被便利函数覆盖的不常见用例。</p>
<p><em>class<em><code>subprocess.Popen</code>(</em>args</em>, <em>bufsize=- 1</em>, <em>executable=None</em>, <em>stdin=None</em>, <em>stdout=None</em>, <em>stderr=None</em>, <em>preexec_fn=None</em>, <em>close_fds=True</em>, <em>shell=False</em>, <em>cwd=None</em>, <em>env=None</em>, <em>universal_newlines=None</em>, <em>startupinfo=None</em>, <em>creationflags=0</em>, <em>restore_signals=True</em>, <em>start_new_session=False</em>, <em>pass_fds=()</em>, <em>**,</em> group=None<em>,</em> extra_groups=None<em>,</em> user=None<em>,</em> umask=- 1<em>,</em> encoding=None<em>,</em> errors=None<em>,</em> text=None<em>,</em> pipesize=- 1*)</p>
<p>在一个新的进程中执行子程序。 在 POSIX 上，该类会使用类似于 <code>os.execvpe()</code> 的行为来执行子程序。 在 Windows 上，该类会使用 Windows <code>CreateProcess()</code> 函数。 <code>Popen</code> 的参数如下。</p>
<p><em>args</em> 应当是一个程序参数的序列或者是一个单独的字符串或 path-like object。 默认情况下，如果 <em>args</em> 是序列则要运行的程序为 <em>args</em> 中的第一项。 如果 <em>args</em> 是字符串，则其解读依赖于具体平台，如下所述。 请查看 <em>shell</em> 和 <em>executable</em> 参数了解其与默认行为的其他差异。 除非另有说明，否则推荐以序列形式传入 <em>args</em>。</p>
<p>警告</p>
<p>为了最大化可靠性，请使用可执行文件的完整限定路径。 要在 <code>PATH</code> 中搜索一个未限定名称，请使用 <code>shutil.which()</code>。 在所有平台上，传入 <code>sys.executable</code> 是再次启动当前 Python 解释器的推荐方式，并请使用 <code>-m</code> 命令行格式来启动已安装的模块。</p>
<p>对 <em>executable</em> (或 <em>args</em> 的第一项) 路径的解析方式依赖于具体平台。 并要注意当解析或搜索可执行文件路径时，<em>cwd</em> 会覆盖当前工作目录而 <em>env</em> 可以覆盖 <code>PATH</code> 环境变量。 对于 Windows，请参阅 <code>lpApplicationName</code> 的文档以及 <code>lpCommandLine</code> 形参 (传给 WinAPI <code>CreateProcess</code>)，并要注意当解析或搜索可执行文件路径时如果传入 <code>shell=False</code>，则 <em>cwd</em> 不会覆盖当前工作目录而 <em>env</em> 无法覆盖 <code>PATH</code> 环境变量。 使用完整路径可避免所有这些变化情况。</p>
<p>向外部函数传入序列形式参数的一个例子如下:</p>
<pre class="line-numbers language-python"><code class="language-python">Popen<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">"/usr/bin/git"</span><span class="token punctuation">,</span><span class="token string">"commit"</span><span class="token punctuation">,</span><span class="token string">"-m"</span><span class="token punctuation">,</span><span class="token string">"Fixes a bug."</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>在 POSIX，如果 <em>args</em> 是一个字符串，此字符串被作为将被执行的程序的命名或路径解释。但是，只有在不传递任何参数给程序的情况下才能这么做。</p>
<p>注解</p>
<p>将 shell 命令拆分为参数序列的方式可能并不很直观，特别是在复杂的情况下。 <code>shlex.split()</code> 可以演示如何确定 <em>args</em> 适当的拆分形式:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span><span class="token keyword">import</span> shlex<span class="token punctuation">,</span> subprocess
<span class="token operator">>></span><span class="token operator">></span> command_line <span class="token operator">=</span> input<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">/</span>bin<span class="token operator">/</span>vikings <span class="token operator">-</span>input eggs<span class="token punctuation">.</span>txt <span class="token operator">-</span>output <span class="token string">"spam spam.txt"</span><span class="token operator">-</span>cmd <span class="token string">"echo '$MONEY'"</span>
<span class="token operator">>></span><span class="token operator">></span> args <span class="token operator">=</span> shlex<span class="token punctuation">.</span>split<span class="token punctuation">(</span>command_line<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span><span class="token keyword">print</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token string">'/bin/vikings'</span><span class="token punctuation">,</span><span class="token string">'-input'</span><span class="token punctuation">,</span><span class="token string">'eggs.txt'</span><span class="token punctuation">,</span><span class="token string">'-output'</span><span class="token punctuation">,</span><span class="token string">'spam spam.txt'</span><span class="token punctuation">,</span><span class="token string">'-cmd'</span><span class="token punctuation">,</span><span class="token string">"echo '$MONEY'"</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> p <span class="token operator">=</span> subprocess<span class="token punctuation">.</span>Popen<span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># Success!</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>特别注意，由 shell 中的空格分隔的选项（例如 <em>-input*）和参数（例如 *eggs.txt</em> ）位于分开的列表元素中，而在需要时使用引号或反斜杠转义的参数在 shell （例如包含空格的文件名或上面显示的 <em>echo</em> 命令）是单独的列表元素。</p>
<p>在 Windows，如果 <em>args</em> 是一个序列，他将通过一个在 在 Windows 上将参数列表转换为一个字符串 描述的方式被转换为一个字符串。这是因为底层的 <code>CreateProcess()</code> 只处理字符串。</p>
<p>在 3.6 版更改: 在 POSIX 上如果 <em>shell</em> 为 <code>False</code> 并且序列包含路径类对象则 <em>args</em> 形参可以接受一个 path-like object。</p>
<p>在 3.8 版更改: 如果在Windows 上 <em>shell</em> 为 <code>False</code> 并且序列包含字节串和路径类对象则 <em>args</em> 形参可以接受一个 path-like object。</p>
<p>参数 <em>shell</em> （默认为 <code>False</code>）指定是否使用 shell 执行程序。如果 <em>shell</em> 为 <code>True</code>，更推荐将 <em>args</em> 作为字符串传递而非序列。</p>
<p>在 POSIX，当 <code>shell=True</code>， shell 默认为 <code>/bin/sh</code>。如果 <em>args</em> 是一个字符串，此字符串指定将通过 shell 执行的命令。这意味着字符串的格式必须和在命令提示符中所输入的完全相同。这包括，例如，引号和反斜杠转义包含空格的文件名。如果 <em>args</em> 是一个序列，第一项指定了命令，另外的项目将作为传递给 shell （而非命令） 的参数对待。也就是说， <code>Popen</code> 等同于:</p>
<pre class="line-numbers language-python"><code class="language-python">Popen<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'/bin/sh'</span><span class="token punctuation">,</span><span class="token string">'-c'</span><span class="token punctuation">,</span> args<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> args<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>在 Windows，使用 <code>shell=True</code>，环境变量 <code>COMSPEC</code> 指定了默认 shell。在 Windows 你唯一需要指定 <code>shell=True</code> 的情况是你想要执行内置在 shell 中的命令（例如 <strong>dir</strong> 或者 <strong>copy</strong>）。在运行一个批处理文件或者基于控制台的可执行文件时，不需要 <code>shell=True</code>。</p>
<p><em>bufsize</em> 将在 <code>open()</code> 函数创建了 stdin/stdout/stderr 管道文件对象时作为对应的参数供应:</p>
<ul>
<li><code>0</code> 表示不使用缓冲区 （读取与写入是一个系统调用并且可以返回短内容）</li>
<li><code>1</code> 表示行缓冲（只有 <code>universal_newlines=True</code> 时才有用，例如，在文本模式中）</li>
<li>任何其他正值表示使用一个约为对应大小的缓冲区</li>
<li>负的 <em>bufsize</em> （默认）表示使用系统默认的 io.DEFAULT_BUFFER_SIZE。</li>
</ul>
<p>在 3.3.1 版更改: <em>bufsize</em> 现在默认为 -1 来启用缓冲，以符合大多数代码所期望的行为。在 Python 3.2.4 和 3.3.1 之前的版本中，它错误地将默认值设为了为 <code>0</code>，这是无缓冲的并且允许短读取。这是无意的，并且与大多数代码所期望的 Python 2 的行为不一致。</p>
<p><em>executable</em> 参数指定一个要执行的替换程序。这很少需要。当 <code>shell=True</code>， <em>executable</em> 替换 <em>args</em> 指定运行的程序。但是，原始的 <em>args</em> 仍然被传递给程序。大多数程序将被 <em>args</em> 指定的程序作为命令名对待，这可以与实际运行的程序不同。在 POSIX， <em>args</em> 名作为实际调用程序中可执行文件的显示名称，例如 <strong>ps</strong>。如果 <code>shell=True</code>，在 POSIX， <em>executable</em> 参数指定用于替换默认 shell <code>/bin/sh</code> 的 shell。</p>
<p>在 3.6 版更改: 在POSIX 上 <em>executable</em> 形参可以接受一个 path-like object。</p>
<p>在 3.8 版更改: 在Windows 上 <em>executable</em> 形参可以接受一个字节串和 path-like object。</p>
<p><em>stdin</em>, <em>stdout</em> 和 <em>stderr</em> 分别指定被运行的程序的标准输入、输出和标准错误的文件句柄。合法的值有 <code>PIPE</code> ， <code>DEVNULL</code> ， 一个存在的文件描述符（一个正整数），一个存在的 文件对象 以及 <code>None</code>。 <code>PIPE</code> 表示应创建一个新的对子进程的管道。 <code>DEVNULL</code> 表示使用特殊的 <code>os.devnull</code> 文件。使用默认的 <code>None</code>，则不进行成定向；子进程的文件流将继承自父进程。另外， <em>stderr</em> 可设为 <code>STDOUT</code>，表示应用程序的标准错误数据应和标准输出一同捕获。</p>
<p>如果 <em>preexec_fn</em> 被设为一个可调用对象，此对象将在子进程刚创建时被调用。（仅 POSIX）</p>
<p>警告</p>
<p><em>preexec_fn</em> 形参在应用程序中存在多线程时是不安全的。子进程在调用前可能死锁。如果你必须使用它，保持警惕！最小化你调用的库的数量。</p>
<p>注解</p>
<p>如果你需要修改子进程环境，使用 <em>env</em> 形参而非在 <em>preexec_fn</em> 中进行。 <em>start_new_session</em> 形参可以代替之前常用的 <em>preexec_fn</em> 来在子进程中调用 os.setsid()。</p>
<p>在 3.8 版更改: <em>preexec_fn</em> 形参在子解释器中已不再受支持。 在子解释器中使用此形参将引发 <code>RuntimeError</code>。 这个新限制可能会影响部署在 mod_wsgi, uWSGI 和其他嵌入式环境中的应用。</p>
<p>如果 <em>close_fds</em> 为真，所有文件描述符除了 <code>0</code>, <code>1</code>, <code>2</code> 之外都会在子进程执行前关闭。而当 <em>close_fds</em> 为假时，文件描述符遵守它们继承的标志，如 文件描述符的继承 所述。</p>
<p>在 Windows，如果 <em>close_fds</em> 为真， 则子进程不会继承任何句柄，除非在 <code>STARTUPINFO.IpAttributeList</code> 的 <code>handle_list</code> 的键中显式传递，或者通过标准句柄重定向传递。</p>
<p>在 3.2 版更改: <em>close_fds</em> 的默认值已经从 <code>False</code> 修改为上述值。</p>
<p>在 3.7 版更改: 在 Windows，当重定向标准句柄时 <em>close_fds</em> 的默认值从 <code>False</code> 变为 <code>True</code>。现在重定向标准句柄时有可能设置 <em>close_fds</em> 为 <code>True</code>。（标准句柄指三个 stdio 的句柄）</p>
<p><em>pass_fds</em> 是一个可选的在父子进程间保持打开的文件描述符序列。提供任何 <em>pass_fds</em> 将强制 <em>close_fds</em> 为 <code>True</code>。（仅 POSIX）</p>
<p>在 3.2 版更改: 加入了 <em>pass_fds</em> 形参。</p>
<p>如果 <em>cwd</em> 不为 <code>None</code>，此函数在执行子进程前会将当前工作目录改为 <em>cwd*。 *cwd</em> 可以是一个字符串、字节串或 路径类对象。 在 POSIX 上，如果可执行文件路径为相对路径则此函数会相对于 <em>cwd</em> 来查找 <em>executable</em> (或 <em>args</em> 的第一项)。</p>
<p>在 3.6 版更改: 在 POSIX 上 <em>cwd</em> 形参接受一个 path-like object。</p>
<p>在 3.7 版更改: 在 Windows 上 <em>cwd</em> 形参接受一个 path-like object。</p>
<p>在 3.8 版更改: 在 Windows 上 <em>cwd</em> 形参接受一个字节串对象。</p>
<p>如果 <em>restore_signals</em> 为 true（默认值），则 Python 设置为 SIG_IGN 的所有信号将在 exec 之前的子进程中恢复为 SIG_DFL。目前，这包括 SIGPIPE ，SIGXFZ 和 SIGXFSZ 信号。 （仅 POSIX）</p>
<p>在 3.2 版更改: <em>restore_signals</em> 被加入。</p>
<p>如果 <em>start_new_session</em> 为 true，则 setsid() 系统调用将在子进程执行之前被执行。（仅 POSIX）</p>
<p>在 3.2 版更改: <em>start_new_session</em> 被添加。</p>
<p>如果 <em>group</em> 不为 <code>None</code>，则 setregid() 系统调用将于子进程执行之前在下级进程中进行。 如果所提供的值为一个字符串，将通过 <code>grp.getgrnam()</code> 来查找它，并将使用 <code>gr_gid</code> 中的值。 如果该值为一个整数，它将被原样传递。 （POSIX 专属）</p>
<p>可用性: POSIX</p>
<p>3.9 新版功能.</p>
<p>如果 <em>extra_groups</em> 不为 <code>None</code>，则 setgroups() 系统调用将于子进程之前在下级进程中进行。 在 <em>extra_groups</em> 中提供的字符串将通过 <code>grp.getgrnam()</code> 来查找，并将使用 <code>gr_gid</code> 中的值。 整数值将被原样传递。 （POSIX 专属）</p>
<p>可用性: POSIX</p>
<p>3.9 新版功能.</p>
<p>如果 <em>user</em> 不为 <code>None</code>，则 setreuid() 系统调用将于子进程执行之前在下级进程中进行。 如果所提供的值为一个字符串，将通过 <code>pwd.getpwnam()</code> 来查找它，并将使用 <code>pw_uid</code> 中的值。 如果该值为一个整数，它将被原样传递。 （POSIX 专属）</p>
<p>可用性: POSIX</p>
<p>3.9 新版功能.</p>
<p>如果 <em>umask</em> 不为负值，则 umask() 系统调用将在子进程执行之前在下级进程中进行。</p>
<p>可用性: POSIX</p>
<p>3.9 新版功能.</p>
<p>如果 <em>env</em> 不为 <code>None</code>，则必须为一个为新进程定义了环境变量的字典；这些用于替换继承的当前进程环境的默认行为。</p>
<p>注解</p>
<p>如果指定， <em>env</em> 必须提供所有被子进程需求的变量。在 Windows，为了运行一个 side-by-side assembly ，指定的 <em>env**</em>必须** 包含一个有效的 <code>SystemRoot</code>。</p>
<p>如果 <em>encoding</em> 或 <em>errors</em> 被指定，或者 <em>text</em> 为 true，则文件对象 <em>stdin</em>, <em>stdout</em> 和 <em>stderr</em> 将会以指定的编码和 <em>errors</em> 以文本模式打开，如同 常用参数 所述。 <em>universal_newlines</em> 参数等同于 <em>text</em> 并且提供向后兼容性。默认情况下，文件对象都以二进制模式打开。</p>
<p>3.6 新版功能: <em>encoding</em> 和 <em>errors</em> 被添加。</p>
<p>3.7 新版功能: <em>text</em> 作为 <em>universal_newlines</em> 的一个更具可读性的别名被添加。</p>
<p>如果给出， <em>startupinfo</em> 将是一个将被传递给底层的 <code>CreateProcess</code> 函数的 <code>STARTUPINFO</code> 对象。 <em>creationflags</em>，如果给出，可以是一个或多个以下标志之一：</p>
<blockquote>
<ul>
<li><code>CREATE_NEW_CONSOLE</code></li>
<li><code>CREATE_NEW_PROCESS_GROUP</code></li>
<li><code>ABOVE_NORMAL_PRIORITY_CLASS</code></li>
<li><code>BELOW_NORMAL_PRIORITY_CLASS</code></li>
<li><code>HIGH_PRIORITY_CLASS</code></li>
<li><code>IDLE_PRIORITY_CLASS</code></li>
<li><code>NORMAL_PRIORITY_CLASS</code></li>
<li><code>REALTIME_PRIORITY_CLASS</code></li>
<li><code>CREATE_NO_WINDOW</code></li>
<li><code>DETACHED_PROCESS</code></li>
<li><code>CREATE_DEFAULT_ERROR_MODE</code></li>
<li><code>CREATE_BREAKAWAY_FROM_JOB</code></li>
</ul>
</blockquote>
<p>当 <code>PIPE</code> 被用作 <em>stdin</em>, <em>stdout</em> 或 <em>stderr</em> 时 <em>pipesize</em> 可被用于改变管道的大小。 管道的大小仅会在受支持的平台上被改变（当撰写本文档时只有 Linux 支持）。 其他平台将忽略此形参。</p>
<p>3.10 新版功能: 增加了 <code>pipesize</code> 形参。</p>
<p>Popen 对象支持通过 <code>with</code> 语句作为上下文管理器，在退出时关闭文件描述符并等待进程:</p>
<pre class="line-numbers language-python"><code class="language-python">withPopen<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">"ifconfig"</span><span class="token punctuation">]</span><span class="token punctuation">,</span> stdout<span class="token operator">=</span>PIPE<span class="token punctuation">)</span><span class="token keyword">as</span> proc<span class="token punctuation">:</span>
    log<span class="token punctuation">.</span>write<span class="token punctuation">(</span>proc<span class="token punctuation">.</span>stdout<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>引发一个 审计事件<code>subprocess.Popen</code>，附带参数 <code>executable</code>, <code>args</code>, <code>cwd</code>, <code>env</code>。</p>
<p>在 3.2 版更改: 添加了上下文管理器支持。</p>
<p>在 3.6 版更改: 现在，如果 Popen 析构时子进程仍然在运行，则析构器会发送一个 <code>ResourceWarning</code> 警告。</p>
<p>在 3.8 版更改: 在某些情况下 Popen 可以使用 <code>os.posix_spawn()</code> 以获得更好的性能。在适用于 Linux 的 Windows 子系统和 QEMU 用户模拟器上，使用 <code>os.posix_spawn()</code> 的 Popen 构造器不再会因找不到程序等错误而引发异常，而是上下级进程失败并返回一个非零的 <code>returncode</code>。</p>
<h4 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h4><p>在子进程中抛出的异常，在新的进程开始执行前，将会被再次在父进程中抛出。</p>
<p>被引发的最一般异常是 <code>OSError</code>。 例如这会在尝试执行一个不存在的文件时发生。 应用程序应当为 <code>OSError</code> 异常做好准备。 请注意，如果 <code>shell=True</code>，则 <code>OSError</code> 仅会在未找到选定的 shell 本身时被引发。 要确定 shell 是否未找到所请求的应用程序，必须检查来自子进程的返回码或输出。</p>
<p>如果 <code>Popen</code> 调用时有无效的参数，则一个 <code>ValueError</code> 将被抛出。</p>
<p><code>check_call()</code> 与 <code>check_output()</code> 在调用的进程返回非零退出码时将抛出 <code>CalledProcessError</code>。</p>
<p>所有接受 <em>timeout</em> 形参的函数与方法，例如 <code>call()</code> 和 <code>Popen.communicate()</code> 将会在进程退出前超时到期时抛出 <code>TimeoutExpired</code>。</p>
<p>此模块中定义的异常都继承自 <code>SubprocessError</code>。</p>
<blockquote>
<p>3.3 新版功能: 基类 <code>SubprocessError</code> 被添加。</p>
</blockquote>
<h3 id="安全考量"><a href="#安全考量" class="headerlink" title="安全考量"></a>安全考量</h3><p>不同于某些其他的 popen 函数，这个实现绝不会隐式地调用系统 shell。 这意味着所有字符，包括 shell 元字符，都可以安全地被传递给子进程。 如果 shell 通过 <code>shell=True</code> 被显式地发起调用，则应用程序有责任确保所有空白符和元字符被适当地转义以避免 shell 注入 漏洞。 在 某些平台 上，可以使用 <code>shlex.quote()</code> 来执行这样的转义。</p>
<h3 id="Popen-对象"><a href="#Popen-对象" class="headerlink" title="Popen 对象"></a>Popen 对象</h3><p><code>Popen</code> 类的实例拥有以下方法：</p>
<p><code>Popen.poll</code>()</p>
<p>检查子进程是否已被终止。设置并返回 <code>returncode</code> 属性。否则返回 <code>None</code>。</p>
<p><code>Popen.wait</code>(<em>timeout=None</em>)</p>
<p>等待子进程被终止。设置并返回 <code>returncode</code> 属性。</p>
<p>如果进程在 <em>timeout</em> 秒后未中断，抛出一个 <code>TimeoutExpired</code> 异常，可以安全地捕获此异常并重新等待。</p>
<p>注解</p>
<p>当 <code>stdout=PIPE</code> 或者 <code>stderr=PIPE</code> 并且子进程产生了足以阻塞 OS 管道缓冲区接收更多数据的输出到管道时，将会发生死锁。当使用管道时用 <code>Popen.communicate()</code> 来规避它。</p>
<p>注解</p>
<p>此函数使用了一个 busy loop （非阻塞调用以及短睡眠） 实现。使用 <code>asyncio</code> 模块进行异步等待： 参阅 <code>asyncio.create_subprocess_exec</code>。</p>
<p>在 3.3 版更改: <em>timeout</em> 被添加</p>
<p><code>Popen.communicate</code>(<em>input=None</em>, <em>timeout=None</em>)</p>
<p>与进程交互：将数据发送到 stdin。 从 stdout 和 stderr 读取数据，直到抵达文件结尾。 等待进程终止并设置 <code>returncode</code> 属性。 可选的 <em>input</em> 参数应为要发送到下级进程的数据，或者如果没有要发送到下级进程的数据则为 <code>None</code>。 如果流是以文本模式打开的，则 <em>input</em> 必须为字符串。 在其他情况下，它必须为字节串。</p>
<p><code>communicate()</code> 返回一个 <code>(stdout_data, stderr_data)</code> 元组。如果文件以文本模式打开则为字符串；否则字节。</p>
<p>注意如果你想要向进程的 stdin 传输数据，你需要通过 <code>stdin=PIPE</code> 创建此 Popen 对象。类似的，要从结果元组获取任何非 <code>None</code> 值，你同样需要设置 <code>stdout=PIPE</code> 或者 <code>stderr=PIPE</code>。</p>
<p>如果进程在 <em>timeout</em> 秒后未终止，一个 <code>TimeoutExpired</code> 异常将被抛出。捕获此异常并重新等待将不会丢失任何输出。</p>
<p>如果超时到期，子进程不会被杀死，所以为了正确清理一个行为良好的应用程序应该杀死子进程并完成通讯。</p>
<pre class="line-numbers language-python"><code class="language-python">proc <span class="token operator">=</span> subprocess<span class="token punctuation">.</span>Popen<span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>
<span class="token keyword">try</span><span class="token punctuation">:</span>
    outs<span class="token punctuation">,</span> errs <span class="token operator">=</span> proc<span class="token punctuation">.</span>communicate<span class="token punctuation">(</span>timeout<span class="token operator">=</span><span class="token number">15</span><span class="token punctuation">)</span>
exceptTimeoutExpired<span class="token punctuation">:</span>
    proc<span class="token punctuation">.</span>kill<span class="token punctuation">(</span><span class="token punctuation">)</span>
    outs<span class="token punctuation">,</span> errs <span class="token operator">=</span> proc<span class="token punctuation">.</span>communicate<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>注解</p>
<p>内存里数据读取是缓冲的，所以如果数据尺寸过大或无限，不要使用此方法。</p>
<p>在 3.3 版更改: <em>timeout</em> 被添加</p>
<p><code>Popen.send_signal</code>(<em>signal</em>)</p>
<p>将信号 <em>signal</em> 发送给子进程。</p>
<p>如果进程已完成则不做任何操作。</p>
<p>注解</p>
<p>在 Windows， SIGTERM 是一个 <code>terminate()</code> 的别名。 CTRL_C_EVENT 和 CTRL_BREAK_EVENT 可以被发送给以包含 <code>CREATE_NEW_PROCESS</code> 的 <em>creationflags</em> 形参启动的进程。</p>
<p><code>Popen.terminate</code>()</p>
<p>停止子进程。 在 POSIX 操作系统上，此方法会发送 SIGTERM 给子进程。 在 Windows 上则会调用 Win32 API 函数 <code>TerminateProcess()</code> 来停止子进程。</p>
<p><code>Popen.kill</code>()</p>
<p>杀死子进程。 在 POSIX 操作系统上，此函数会发送 SIGKILL 给子进程。 在 Windows 上 <code>kill()</code> 则是 <code>terminate()</code> 的别名。</p>
<p>以下属性也是可用的：</p>
<pre><code>Popen.args</code></pre><p><em>args</em> 参数传递给 <code>Popen</code> — 一个程序参数的序列或者一个简单字符串。</p>
<p>3.3 新版功能.</p>
<pre><code>Popen.stdin</code></pre><p>如果 <em>stdin</em> 参数为 <code>PIPE</code>，此属性是一个类似 <code>open()</code> 返回的可写的流对象。如果 <em>encoding</em> 或 <em>errors</em> 参数被指定或者 <em>universal_newlines</em> 参数为 <code>True</code>，则此流是一个文本流，否则是字节流。如果 <em>stdin</em> 参数非 <code>PIPE</code>， 此属性为 <code>None</code>。</p>
<pre><code>Popen.stdout</code></pre><p>如果 <em>stdout</em> 参数是 <code>PIPE</code>，此属性是一个类似 <code>open()</code> 返回的可读流。从流中读取子进程提供的输出。如果 <em>encoding</em> 或 <em>errors</em> 参数被指定或者 <em>universal_newlines</em> 参数为 <code>True</code>，此流为文本流，否则为字节流。如果 <em>stdout</em> 参数非 <code>PIPE</code>，此属性为 <code>None</code>。</p>
<pre><code>Popen.stderr</code></pre><p>如果 <em>stderr</em> 参数是 <code>PIPE</code>，此属性是一个类似 <code>open()</code> 返回的可读流。从流中读取子进程提供的输出。如果 <em>encoding</em> 或 <em>errors</em> 参数被指定或者 <em>universal_newlines</em> 参数为 <code>True</code>，此流为文本流，否则为字节流。如果 <em>stderr</em> 参数非 <code>PIPE</code>，此属性为 <code>None</code>。</p>
<p>警告</p>
<p>使用 <code>communicate()</code> 而非 <code>.stdin.write</code>， <code>.stdout.read</code> 或者 <code>.stderr.read</code> 来避免由于任意其他 OS 管道缓冲区被子进程填满阻塞而导致的死锁。</p>
<pre><code>Popen.pid</code></pre><p>子进程的进程号。</p>
<p>注意如果你设置了 <em>shell</em> 参数为 <code>True</code>，则这是生成的子 shell 的进程号。</p>
<pre><code>Popen.returncode</code></pre><p>此进程的退出码，由 <code>poll()</code> 和 <code>wait()</code> 设置（以及直接由 <code>communicate()</code> 设置）。一个 <code>None</code> 值 表示此进程仍未结束。</p>
<p>一个负值 <code>-N</code> 表示子进程被信号 <code>N</code> 中断 (仅 POSIX).</p>
<h3 id="Windows-Popen-助手"><a href="#Windows-Popen-助手" class="headerlink" title="Windows Popen 助手"></a>Windows Popen 助手</h3><p><code>STARTUPINFO</code> 类和以下常数仅在 Windows 有效。</p>
<p><em>class<em><code>subprocess.STARTUPINFO</code>(**</em>,</em> dwFlags=0<em>,</em> hStdInput=None<em>,</em> hStdOutput=None<em>,</em> hStdError=None<em>,</em> wShowWindow=0<em>,</em> lpAttributeList=None*)</p>
<p>在 <code>Popen</code> 创建时部分支持 Windows 的 STARTUPINFO 结构。接下来的属性仅能通过关键词参数设置。</p>
<p>在 3.7 版更改: 仅关键词参数支持被加入。</p>
<ul>
<li><p><code>dwFlags</code></p>
<p>一个位字段，用于确定进程在创建窗口时是否使用某些 <code>STARTUPINFO</code> 属性。</p>
<pre class="line-numbers language-python"><code class="language-python">si <span class="token operator">=</span> subprocess<span class="token punctuation">.</span>STARTUPINFO<span class="token punctuation">(</span><span class="token punctuation">)</span>
si<span class="token punctuation">.</span>dwFlags <span class="token operator">=</span> subprocess<span class="token punctuation">.</span>STARTF_USESTDHANDLES <span class="token operator">|</span> subprocess<span class="token punctuation">.</span>STARTF_USESHOWWINDOW<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li><p><code>hStdInput</code></p>
<p>如果 <code>dwFlags</code> 被指定为 <code>STARTF_USESTDHANDLES</code>，则此属性是进程的标准输入句柄，如果 <code>STARTF_USESTDHANDLES</code> 未指定，则默认的标准输入是键盘缓冲区。</p>
</li>
<li><p><code>hStdOutput</code></p>
<p>如果 <code>dwFlags</code> 被指定为 <code>STARTF_USESTDHANDLES</code>，则此属性是进程的标准输出句柄。除此之外，此此属性将被忽略并且默认标准输出是控制台窗口缓冲区。</p>
</li>
<li><p><code>hStdError</code></p>
<p>如果 <code>dwFlags</code> 被指定为 <code>STARTF_USESTDHANDLES</code>，则此属性是进程的标准错误句柄。除此之外，此属性将被忽略并且默认标准错误为控制台窗口的缓冲区。</p>
</li>
<li><p><code>wShowWindow</code></p>
<p>如果 <code>dwFlags</code> 指定了 <code>STARTF_USESHOWWINDOW</code>，此属性可为能被指定为 函数 ShowWindow 的nCmdShow 的形参的任意值，除了 <code>SW_SHOWDEFAULT</code>。如此之外，此属性被忽略。</p>
<p><code>SW_HIDE</code> 被提供给此属性。它在 <code>Popen</code> 由 <code>shell=True</code> 调用时使用。</p>
</li>
<li><p><code>lpAttributeList</code></p>
<p><code>STARTUPINFOEX</code> 给出的用于进程创建的额外属性字典。</p>
<p>支持的属性：</p>
<ul>
<li><p><strong>handle_list</strong></p>
<p>将被继承的句柄的序列。如果非空， <em>close_fds</em> 必须为 true。</p>
<p>当传递给 <code>Popen</code> 构造函数时，这些句柄必须暂时地能被 <code>os.set_handle_inheritable()</code> 继承，否则 <code>OSError</code> 将以 Windows error <code>ERROR_INVALID_PARAMETER</code> (87) 抛出。</p>
<p>警告</p>
<p>在多线程进程中，请谨慎使用，以便在将此功能与对继承所有句柄的其他进程创建函数——例如 <code>os.system()</code> 的并发调用——相结合时，避免泄漏标记为可继承的句柄。这也应用于临时性创建可继承句柄的标准句柄重定向。</p>
</li>
</ul>
<p>3.7 新版功能.</p>
</li>
</ul>
<h4 id="Windows-常数"><a href="#Windows-常数" class="headerlink" title="Windows 常数"></a>Windows 常数</h4><p><code>subprocess</code> 模块曝出以下常数。</p>
<pre><code>subprocess.STD_INPUT_HANDLE</code></pre><p>标准输入设备，这是控制台输入缓冲区 <code>CONIN$</code>。</p>
<pre><code>subprocess.STD_OUTPUT_HANDLE</code></pre><p>标准输出设备。最初，这是活动控制台屏幕缓冲区 <code>CONOUT$</code>。</p>
<pre><code>subprocess.STD_ERROR_HANDLE</code></pre><p>标准错误设备。最初，这是活动控制台屏幕缓冲区 <code>CONOUT$</code>。</p>
<pre><code>subprocess.SW_HIDE</code></pre><p>隐藏窗口。另一个窗口将被激活。</p>
<pre><code>subprocess.STARTF_USESTDHANDLES</code></pre><p>指明 <code>STARTUPINFO.hStdInput</code>, <code>STARTUPINFO.hStdOutput</code> 和 <code>STARTUPINFO.hStdError</code> 属性包含额外的信息。</p>
<pre><code>subprocess.STARTF_USESHOWWINDOW</code></pre><p>指明 <code>STARTUPINFO.wShowWindow</code> 属性包含额外的信息。</p>
<pre><code>subprocess.CREATE_NEW_CONSOLE</code></pre><p>新的进程将有新的控制台，而不是继承父进程的（默认）控制台。</p>
<pre><code>subprocess.CREATE_NEW_PROCESS_GROUP</code></pre><p>用于指明将创建一个新的进程组的 <code>Popen``creationflags</code> 形参。 这个旗标对于在子进程上使用 <code>os.kill()</code> 来说是必须的。</p>
<p>如果指定了 <code>CREATE_NEW_CONSOLE</code> 则这个旗标会被忽略。</p>
<pre><code>subprocess.ABOVE_NORMAL_PRIORITY_CLASS</code></pre><p>用于指明一个新进程将具有高于平均的优先级的 <code>Popen``creationflags</code> 形参。</p>
<p>3.7 新版功能.</p>
<pre><code>subprocess.BELOW_NORMAL_PRIORITY_CLASS</code></pre><p>用于指明一个新进程将具有低于平均的优先级的 <code>Popen``creationflags</code> 形参。</p>
<p>3.7 新版功能.</p>
<pre><code>subprocess.HIGH_PRIORITY_CLASS</code></pre><p>用于指明一个新进程将具有高优先级的 <code>Popen``creationflags</code> 形参。</p>
<p>3.7 新版功能.</p>
<pre><code>subprocess.IDLE_PRIORITY_CLASS</code></pre><p>用于指明一个新进程将具有空闲（最低）优先级的 <code>Popen``creationflags</code> 形参。</p>
<p>3.7 新版功能.</p>
<pre><code>subprocess.NORMAL_PRIORITY_CLASS</code></pre><p>用于指明一个新进程将具有正常（默认）优先级的 <code>Popen``creationflags</code> 形参。</p>
<p>3.7 新版功能.</p>
<pre><code>subprocess.REALTIME_PRIORITY_CLASS</code></pre><p>用于指明一个新进程将具有实时优先级的 <code>Popen``creationflags</code> 形参。 你应当几乎永远不使用 REALTIME_PRIORITY_CLASS，因为这会中断管理鼠标输入、键盘输入以及后台磁盘刷新的系统线程。 这个类只适用于直接与硬件“对话”，或者执行短暂任务具有受限中断的应用。</p>
<p>3.7 新版功能.</p>
<pre><code>subprocess.CREATE_NO_WINDOW</code></pre><p>指明一个新进程将不会创建窗口的 <code>Popen``creationflags</code> 形参。</p>
<p>3.7 新版功能.</p>
<pre><code>subprocess.DETACHED_PROCESS</code></pre><p>指明一个新进程将不会继承其父控制台的 <code>Popen``creationflags</code> 形参。 这个值不能与 CREATE_NEW_CONSOLE 一同使用。</p>
<p>3.7 新版功能.</p>
<pre><code>subprocess.CREATE_DEFAULT_ERROR_MODE</code></pre><p>指明一个新进程不会继承调用方进程的错误模式的 <code>Popen``creationflags</code> 形参。 新进程会转为采用默认的错误模式。 这个特性特别适用于运行时禁用硬错误的多线程 shell 应用。</p>
<p>3.7 新版功能.</p>
<pre><code>subprocess.CREATE_BREAKAWAY_FROM_JOB</code></pre><p>指明一个新进程不会关联到任务的 <code>Popen</code> <code>creationflags</code> 形参。</p>
<p>3.7 新版功能.</p>
<h3 id="较旧的高阶-API"><a href="#较旧的高阶-API" class="headerlink" title="较旧的高阶 API"></a>较旧的高阶 API</h3><p>在 Python 3.5 之前，这三个函数组成了 subprocess 的高阶 API。 现在你可以在许多情况下使用 <code>run()</code>，但有大量现在代码仍会调用这些函数。</p>
<p><code>subprocess.call</code>(<em>args</em>, **<em>,</em> stdin=None<em>,</em> stdout=None<em>,</em> stderr=None<em>,</em> shell=False<em>,</em> cwd=None<em>,</em> timeout=None<em>,</em> <em>*other_popen_kwargs</em>)</p>
<p>运行由 <em>args</em> 所描述的命令。 等待命令完成，然后返回 <code>returncode</code> 属性。</p>
<p>需要捕获 stdout 或 stderr 的代码应当改用 <code>run()</code>:</p>
<pre><code>run(...).returncode</code></pre><p>要屏蔽 stdout 或 stderr，可提供 <code>DEVNULL</code> 这个值。</p>
<p>上面显示的参数只是常见的一些。 完整的函数签名与 <code>Popen</code> 构造器的相同 —— 此函数会将所提供的 <em>timeout</em> 之外的全部参数直接传递给目标接口。</p>
<p>注解</p>
<p>请不要在此函数中使用 <code>stdout=PIPE</code> 或 <code>stderr=PIPE</code>。 如果子进程向管道生成了足以填满 OS 管理缓冲区的输出而管道还未被读取时它将会阻塞。</p>
<p>在 3.3 版更改: <em>timeout</em> 被添加</p>
<p><code>subprocess.check_call</code>(<em>args</em>, **<em>,</em> stdin=None<em>,</em> stdout=None<em>,</em> stderr=None<em>,</em> shell=False<em>,</em> cwd=None<em>,</em> timeout=None<em>,</em> <em>*other_popen_kwargs</em>)</p>
<p>Run command with arguments. Wait for command to complete. If the return code was zero then return, otherwise raise <code>CalledProcessError</code>. The <code>CalledProcessError</code> object will have the return code in the <code>returncode</code> attribute. If <code>check_call()</code> was unable to start the process it will propagate the exception that was raised.</p>
<p>需要捕获 stdout 或 stderr 的代码应当改用 <code>run()</code>:</p>
<pre><code>run(..., check=True)</code></pre><p>要屏蔽 stdout 或 stderr，可提供 <code>DEVNULL</code> 这个值。</p>
<p>上面显示的参数只是常见的一些。 完整的函数签名与 <code>Popen</code> 构造器的相同 —— 此函数会将所提供的 <em>timeout</em> 之外的全部参数直接传递给目标接口。</p>
<p>注解</p>
<p>请不要在此函数中使用 <code>stdout=PIPE</code> 或 <code>stderr=PIPE</code>。 如果子进程向管道生成了足以填满 OS 管理缓冲区的输出而管道还未被读取时它将会阻塞。</p>
<p>在 3.3 版更改: <em>timeout</em> 被添加</p>
<p><code>subprocess.check_output</code>(<em>args</em>, **<em>,</em> stdin=None<em>,</em> stderr=None<em>,</em> shell=False<em>,</em> cwd=None<em>,</em> encoding=None<em>,</em> errors=None<em>,</em> universal_newlines=None<em>,</em> timeout=None<em>,</em> text=None<em>,</em> <em>*other_popen_kwargs</em>)</p>
<p>附带参数运行命令并返回其输出。</p>
<p>如果返回码非零则会引发 <code>CalledProcessError</code>。 <code>CalledProcessError</code> 对象将在 <code>returncode</code> 属性中保存返回码并在 <code>output</code> 属性中保存所有输出。</p>
<p>这相当于：</p>
<pre><code>run(..., check=True, stdout=PIPE).stdout</code></pre><p>上面显示的参数只是常见的一些。 完整的函数签名与 <code>run()</code> 的大致相同 —— 大部分参数会通过该接口直接传递。 存在一个与 <code>run()</code> 行为不同的 API 差异：传递 <code>input=None</code> 的行为将与 <code>input=b''</code> (或 <code>input=''</code>，具体取决于其他参数) 一样而不是使用父对象的标准输入文件处理。</p>
<p>默认情况下，此函数将把数据返回为已编码的字节串。 输出数据的实际编码格式将取决于发起调用的命令，因此解码为文本的操作往往需要在应用程序层级上进行处理。</p>
<p>此行为可以通过设置 <em>text</em>, <em>encoding</em>, <em>errors</em> 或将 <em>universal_newlines</em> 设为 <code>True</code> 来重载。</p>
<p>要在结果中同时捕获标准错误，请使用 <code>stderr=subprocess.STDOUT</code>:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> subprocess<span class="token punctuation">.</span>check_output<span class="token punctuation">(</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token string">"ls non_existent_file; exit 0"</span><span class="token punctuation">,</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     stderr<span class="token operator">=</span>subprocess<span class="token punctuation">.</span>STDOUT<span class="token punctuation">,</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     shell<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>
<span class="token string">'ls: non_existent_file: No such file or directory\n'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>3.1 新版功能.</p>
<p>在 3.3 版更改: <em>timeout</em> 被添加</p>
<p>在 3.4 版更改: 增加了对 <em>input</em> 关键字参数的支持。</p>
<p>在 3.6 版更改: 增加了 <em>encoding</em> 和 <em>errors</em>。 </p>
<p>3.7 新版功能: <em>text</em> 作为 <em>universal_newlines</em> 的一个更具可读性的别名被添加。</p>
<h3 id="使用-subprocess-模块替换旧函数"><a href="#使用-subprocess-模块替换旧函数" class="headerlink" title="使用 subprocess 模块替换旧函数"></a>使用 <code>subprocess</code> 模块替换旧函数</h3><p>在这一节中，”a 改为 b” 意味着 b 可以被用作 a 的替代。</p>
<p>注解</p>
<p>在这一节中的所有 “a” 函数会在找不到被执行的程序时（差不多）静默地失败；”b” 替代函数则会改为引发 <code>OSError</code>。</p>
<p>此外，在使用 <code>check_output()</code> 时如果替代函数所请求的操作产生了非零返回值则将失败并引发 <code>CalledProcessError</code>。 操作的输出仍能以所引发异常的 <code>output</code> 属性的方式被访问。</p>
<p>在下列例子中，我们假定相关的函数都已从 <code>subprocess</code> 模块中导入了。</p>
<h4 id="替代-bin-sh-shell-命令替换"><a href="#替代-bin-sh-shell-命令替换" class="headerlink" title="替代 /bin/sh shell 命令替换"></a>替代 <strong>/bin/sh</strong> shell 命令替换</h4><pre><code>output=$(mycmd myarg)</code></pre><p>改为:</p>
<pre class="line-numbers language-python"><code class="language-python">output <span class="token operator">=</span> check_output<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">"mycmd"</span><span class="token punctuation">,</span><span class="token string">"myarg"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h4 id="替代-shell-管道"><a href="#替代-shell-管道" class="headerlink" title="替代 shell 管道"></a>替代 shell 管道</h4><pre><code>output=$(dmesg | grep hda)</code></pre><p>改为:</p>
<pre class="line-numbers language-python"><code class="language-python">p1 <span class="token operator">=</span>Popen<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">"dmesg"</span><span class="token punctuation">]</span><span class="token punctuation">,</span> stdout<span class="token operator">=</span>PIPE<span class="token punctuation">)</span>
p2 <span class="token operator">=</span>Popen<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">"grep"</span><span class="token punctuation">,</span><span class="token string">"hda"</span><span class="token punctuation">]</span><span class="token punctuation">,</span> stdin<span class="token operator">=</span>p1<span class="token punctuation">.</span>stdout<span class="token punctuation">,</span> stdout<span class="token operator">=</span>PIPE<span class="token punctuation">)</span>
p1<span class="token punctuation">.</span>stdout<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># Allow p1 to receive a SIGPIPE if p2 exits.</span>
output <span class="token operator">=</span> p2<span class="token punctuation">.</span>communicate<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>启动 p2 之后再执行 <code>p1.stdout.close()</code> 调用很重要，这是为了让 p1 能在 p2 先于 p1 退出时接收到 SIGPIPE。</p>
<p>另外，对于受信任的输入，shell 本身的管道支持仍然可被直接使用:</p>
<pre><code>output=$(dmesg | grep hda)</code></pre><p>改为:</p>
<pre class="line-numbers language-python"><code class="language-python">output <span class="token operator">=</span> check_output<span class="token punctuation">(</span><span class="token string">"dmesg | grep hda"</span><span class="token punctuation">,</span> shell<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h4 id="替代-os-system"><a href="#替代-os-system" class="headerlink" title="替代 os.system()"></a>替代 <code>os.system()</code></h4><pre class="line-numbers language-python"><code class="language-python">sts <span class="token operator">=</span> os<span class="token punctuation">.</span>system<span class="token punctuation">(</span><span class="token string">"mycmd"</span><span class="token operator">+</span><span class="token string">" myarg"</span><span class="token punctuation">)</span>
<span class="token comment" spellcheck="true"># becomes</span>
retcode <span class="token operator">=</span> call<span class="token punctuation">(</span><span class="token string">"mycmd"</span><span class="token operator">+</span><span class="token string">" myarg"</span><span class="token punctuation">,</span> shell<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>注释：</p>
<ul>
<li>通过 shell 来调用程序通常是不必要的。</li>
<li><code>call()</code> 返回值的编码方式与 <code>os.system()</code> 的不同。</li>
<li><code>os.system()</code> 函数在命令运行期间会忽略 SIGINT 和 SIGQUIT 信号，但调用方必须在使用 <code>subprocess</code> 模块时分别执行此操作。</li>
</ul>
<p>一个更现实的例子如下所示:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">try</span><span class="token punctuation">:</span>
    retcode <span class="token operator">=</span> call<span class="token punctuation">(</span><span class="token string">"mycmd"</span><span class="token operator">+</span><span class="token string">" myarg"</span><span class="token punctuation">,</span> shell<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>
<span class="token keyword">if</span> retcode <span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">:</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Child was terminated by signal"</span><span class="token punctuation">,</span><span class="token operator">-</span>retcode<span class="token punctuation">,</span> file<span class="token operator">=</span>sys<span class="token punctuation">.</span>stderr<span class="token punctuation">)</span>
<span class="token keyword">else</span><span class="token punctuation">:</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Child returned"</span><span class="token punctuation">,</span> retcode<span class="token punctuation">,</span> file<span class="token operator">=</span>sys<span class="token punctuation">.</span>stderr<span class="token punctuation">)</span>
exceptOSErroras e<span class="token punctuation">:</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Execution failed:"</span><span class="token punctuation">,</span> e<span class="token punctuation">,</span> file<span class="token operator">=</span>sys<span class="token punctuation">.</span>stderr<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="替代-os-spawn-函数族"><a href="#替代-os-spawn-函数族" class="headerlink" title="替代 os.spawn 函数族"></a>替代 <code>os.spawn</code> 函数族</h4><p>P_NOWAIT 示例:</p>
<pre class="line-numbers language-python"><code class="language-python">pid <span class="token operator">=</span> os<span class="token punctuation">.</span>spawnlp<span class="token punctuation">(</span>os<span class="token punctuation">.</span>P_NOWAIT<span class="token punctuation">,</span><span class="token string">"/bin/mycmd"</span><span class="token punctuation">,</span><span class="token string">"mycmd"</span><span class="token punctuation">,</span><span class="token string">"myarg"</span><span class="token punctuation">)</span>
<span class="token operator">==</span><span class="token operator">></span>
pid <span class="token operator">=</span>Popen<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">"/bin/mycmd"</span><span class="token punctuation">,</span><span class="token string">"myarg"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span>pid<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>P_WAIT 示例:</p>
<pre class="line-numbers language-python"><code class="language-python">retcode <span class="token operator">=</span> os<span class="token punctuation">.</span>spawnlp<span class="token punctuation">(</span>os<span class="token punctuation">.</span>P_WAIT<span class="token punctuation">,</span><span class="token string">"/bin/mycmd"</span><span class="token punctuation">,</span><span class="token string">"mycmd"</span><span class="token punctuation">,</span><span class="token string">"myarg"</span><span class="token punctuation">)</span>
<span class="token operator">==</span><span class="token operator">></span>
retcode <span class="token operator">=</span> call<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">"/bin/mycmd"</span><span class="token punctuation">,</span><span class="token string">"myarg"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>Vector 示例:</p>
<pre class="line-numbers language-python"><code class="language-python">os<span class="token punctuation">.</span>spawnvp<span class="token punctuation">(</span>os<span class="token punctuation">.</span>P_NOWAIT<span class="token punctuation">,</span> path<span class="token punctuation">,</span> args<span class="token punctuation">)</span>
<span class="token operator">==</span><span class="token operator">></span>
Popen<span class="token punctuation">(</span><span class="token punctuation">[</span>path<span class="token punctuation">]</span><span class="token operator">+</span> args<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>Environment 示例:</p>
<pre class="line-numbers language-python"><code class="language-python">os<span class="token punctuation">.</span>spawnlpe<span class="token punctuation">(</span>os<span class="token punctuation">.</span>P_NOWAIT<span class="token punctuation">,</span><span class="token string">"/bin/mycmd"</span><span class="token punctuation">,</span><span class="token string">"mycmd"</span><span class="token punctuation">,</span><span class="token string">"myarg"</span><span class="token punctuation">,</span> env<span class="token punctuation">)</span>
<span class="token operator">==</span><span class="token operator">></span>
Popen<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">"/bin/mycmd"</span><span class="token punctuation">,</span><span class="token string">"myarg"</span><span class="token punctuation">]</span><span class="token punctuation">,</span> env<span class="token operator">=</span><span class="token punctuation">{</span><span class="token string">"PATH"</span><span class="token punctuation">:</span><span class="token string">"/usr/bin"</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h4 id="替代-os-popen-os-popen2-os-popen3"><a href="#替代-os-popen-os-popen2-os-popen3" class="headerlink" title="替代 os.popen(), os.popen2(), os.popen3()"></a>替代 <code>os.popen()</code>, <code>os.popen2()</code>, <code>os.popen3()</code></h4><pre class="line-numbers language-python"><code class="language-python"><span class="token punctuation">(</span>child_stdin<span class="token punctuation">,</span> child_stdout<span class="token punctuation">)</span><span class="token operator">=</span> os<span class="token punctuation">.</span>popen2<span class="token punctuation">(</span>cmd<span class="token punctuation">,</span> mode<span class="token punctuation">,</span> bufsize<span class="token punctuation">)</span>
<span class="token operator">==</span><span class="token operator">></span>
p <span class="token operator">=</span>Popen<span class="token punctuation">(</span>cmd<span class="token punctuation">,</span> shell<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span> bufsize<span class="token operator">=</span>bufsize<span class="token punctuation">,</span>
          stdin<span class="token operator">=</span>PIPE<span class="token punctuation">,</span> stdout<span class="token operator">=</span>PIPE<span class="token punctuation">,</span> close_fds<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span>child_stdin<span class="token punctuation">,</span> child_stdout<span class="token punctuation">)</span><span class="token operator">=</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>stdin<span class="token punctuation">,</span> p<span class="token punctuation">.</span>stdout<span class="token punctuation">)</span>

<span class="token punctuation">(</span>child_stdin<span class="token punctuation">,</span>
 child_stdout<span class="token punctuation">,</span>
 child_stderr<span class="token punctuation">)</span><span class="token operator">=</span> os<span class="token punctuation">.</span>popen3<span class="token punctuation">(</span>cmd<span class="token punctuation">,</span> mode<span class="token punctuation">,</span> bufsize<span class="token punctuation">)</span>
<span class="token operator">==</span><span class="token operator">></span>
p <span class="token operator">=</span>Popen<span class="token punctuation">(</span>cmd<span class="token punctuation">,</span> shell<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span> bufsize<span class="token operator">=</span>bufsize<span class="token punctuation">,</span>
          stdin<span class="token operator">=</span>PIPE<span class="token punctuation">,</span> stdout<span class="token operator">=</span>PIPE<span class="token punctuation">,</span> stderr<span class="token operator">=</span>PIPE<span class="token punctuation">,</span> close_fds<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span>child_stdin<span class="token punctuation">,</span>
 child_stdout<span class="token punctuation">,</span>
 child_stderr<span class="token punctuation">)</span><span class="token operator">=</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>stdin<span class="token punctuation">,</span> p<span class="token punctuation">.</span>stdout<span class="token punctuation">,</span> p<span class="token punctuation">.</span>stderr<span class="token punctuation">)</span>

 <span class="token punctuation">(</span>child_stdin<span class="token punctuation">,</span> child_stdout_and_stderr<span class="token punctuation">)</span><span class="token operator">=</span> os<span class="token punctuation">.</span>popen4<span class="token punctuation">(</span>cmd<span class="token punctuation">,</span> mode<span class="token punctuation">,</span> bufsize<span class="token punctuation">)</span>
<span class="token operator">==</span><span class="token operator">></span>
p <span class="token operator">=</span>Popen<span class="token punctuation">(</span>cmd<span class="token punctuation">,</span> shell<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span> bufsize<span class="token operator">=</span>bufsize<span class="token punctuation">,</span>
          stdin<span class="token operator">=</span>PIPE<span class="token punctuation">,</span> stdout<span class="token operator">=</span>PIPE<span class="token punctuation">,</span> stderr<span class="token operator">=</span>STDOUT<span class="token punctuation">,</span> close_fds<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span>child_stdin<span class="token punctuation">,</span> child_stdout_and_stderr<span class="token punctuation">)</span><span class="token operator">=</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>stdin<span class="token punctuation">,</span> p<span class="token punctuation">.</span>stdout<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>返回码以如下方式处理转写:</p>
<pre class="line-numbers language-python"><code class="language-python">pipe <span class="token operator">=</span> os<span class="token punctuation">.</span>popen<span class="token punctuation">(</span>cmd<span class="token punctuation">,</span><span class="token string">'w'</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
rc <span class="token operator">=</span> pipe<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">if</span> rc isnotNoneand rc <span class="token operator">>></span><span class="token number">8</span><span class="token punctuation">:</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"There were some errors"</span><span class="token punctuation">)</span>
<span class="token operator">==</span><span class="token operator">></span>
process <span class="token operator">=</span>Popen<span class="token punctuation">(</span>cmd<span class="token punctuation">,</span> stdin<span class="token operator">=</span>PIPE<span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
process<span class="token punctuation">.</span>stdin<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">if</span> process<span class="token punctuation">.</span>wait<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">:</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"There were some errors"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="来自-popen2-模块的替代函数"><a href="#来自-popen2-模块的替代函数" class="headerlink" title="来自 popen2 模块的替代函数"></a>来自 <code>popen2</code> 模块的替代函数</h4><p>注解</p>
<p>如果 popen2 函数的 cmd 参数是一个字符串，命令会通过 /bin/sh 来执行。 如果是一个列表，命令会被直接执行。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token punctuation">(</span>child_stdout<span class="token punctuation">,</span> child_stdin<span class="token punctuation">)</span><span class="token operator">=</span> popen2<span class="token punctuation">.</span>popen2<span class="token punctuation">(</span><span class="token string">"somestring"</span><span class="token punctuation">,</span> bufsize<span class="token punctuation">,</span> mode<span class="token punctuation">)</span>
<span class="token operator">==</span><span class="token operator">></span>
p <span class="token operator">=</span>Popen<span class="token punctuation">(</span><span class="token string">"somestring"</span><span class="token punctuation">,</span> shell<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span> bufsize<span class="token operator">=</span>bufsize<span class="token punctuation">,</span>
          stdin<span class="token operator">=</span>PIPE<span class="token punctuation">,</span> stdout<span class="token operator">=</span>PIPE<span class="token punctuation">,</span> close_fds<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span>child_stdout<span class="token punctuation">,</span> child_stdin<span class="token punctuation">)</span><span class="token operator">=</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>stdout<span class="token punctuation">,</span> p<span class="token punctuation">.</span>stdin<span class="token punctuation">)</span>

<span class="token punctuation">(</span>child_stdout<span class="token punctuation">,</span> child_stdin<span class="token punctuation">)</span><span class="token operator">=</span> popen2<span class="token punctuation">.</span>popen2<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">"mycmd"</span><span class="token punctuation">,</span><span class="token string">"myarg"</span><span class="token punctuation">]</span><span class="token punctuation">,</span> bufsize<span class="token punctuation">,</span> mode<span class="token punctuation">)</span>
<span class="token operator">==</span><span class="token operator">></span>
p <span class="token operator">=</span>Popen<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">"mycmd"</span><span class="token punctuation">,</span><span class="token string">"myarg"</span><span class="token punctuation">]</span><span class="token punctuation">,</span> bufsize<span class="token operator">=</span>bufsize<span class="token punctuation">,</span>
          stdin<span class="token operator">=</span>PIPE<span class="token punctuation">,</span> stdout<span class="token operator">=</span>PIPE<span class="token punctuation">,</span> close_fds<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span>child_stdout<span class="token punctuation">,</span> child_stdin<span class="token punctuation">)</span><span class="token operator">=</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>stdout<span class="token punctuation">,</span> p<span class="token punctuation">.</span>stdin<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>popen2.Popen3</code> 和 <code>popen2.Popen4</code> 基本上类似于 <code>subprocess.Popen</code>，不同之处在于:</p>
<ul>
<li><code>Popen</code> 如果执行失败会引发一个异常。</li>
<li><em>capturestderr</em> 参数被替换为 <em>stderr</em> 参数。</li>
<li>必须指定 <code>stdin=PIPE</code> 和 <code>stdout=PIPE</code>。</li>
<li>popen2 默认会关闭所有文件描述符，但对于 <code>Popen</code> 你必须指明 <code>close_fds=True</code> 以才能在所有平台或较旧的 Python 版本中确保此行为。</li>
</ul>
<h3 id="旧式的-Shell-发起函数"><a href="#旧式的-Shell-发起函数" class="headerlink" title="旧式的 Shell 发起函数"></a>旧式的 Shell 发起函数</h3><p>此模块还提供了以下来自 2.x <code>commands</code> 模块的旧版函数。 这些操作会隐式地发起调用系统 shell 并且上文所描述的有关安全与异常处理一致性保证都不适用于这些函数。</p>
<p><code>subprocess.getstatusoutput</code>(<em>cmd</em>)</p>
<p>返回在 shell 中执行 <em>cmd</em> 产生的 <code>(exitcode, output)</code>。</p>
<p>在 shell 中以 <code>Popen.check_output()</code> 执行字符串 <em>cmd</em> 并返回一个 2 元组 <code>(exitcode, output)</code>。 会使用当前区域设置的编码格式；</p>
<p>末尾的一个换行符会从输出中被去除。 命令的退出码可被解读为子进程的返回码。 例如:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> subprocess<span class="token punctuation">.</span>getstatusoutput<span class="token punctuation">(</span><span class="token string">'ls /bin/ls'</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token string">'/bin/ls'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> subprocess<span class="token punctuation">.</span>getstatusoutput<span class="token punctuation">(</span><span class="token string">'cat /bin/junk'</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">'cat: /bin/junk: No such file or directory'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> subprocess<span class="token punctuation">.</span>getstatusoutput<span class="token punctuation">(</span><span class="token string">'/bin/junk'</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token number">127</span><span class="token punctuation">,</span><span class="token string">'sh: /bin/junk: not found'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> subprocess<span class="token punctuation">.</span>getstatusoutput<span class="token punctuation">(</span><span class="token string">'/bin/kill $$'</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">15</span><span class="token punctuation">,</span><span class="token string">''</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可用性: POSIX 和 Windows。</p>
<p>在 3.3.4 版更改: 添加了 Windows 支持。</p>
<p>此函数现在返回 (exitcode, output) 而不是像 Python 3.3.3 及更早的版本那样返回 (status, output)。 exitcode 的值与 <code>returncode</code> 相同。</p>
<p><code>subprocess.getoutput</code>(<em>cmd</em>)</p>
<p>返回在 shell 中执行 <em>cmd</em> 产生的输出（stdout 和 stderr）。</p>
<p>类似于 <code>getstatusoutput()</code>，但退出码会被忽略并且返回值为包含命令输出的字符串。 例如:</p>
<pre><code>&gt;&gt;&gt; subprocess.getoutput('ls /bin/ls')
'/bin/ls'</code></pre><p>可用性: POSIX 和 Windows。</p>
<p>在 3.3.4 版更改: 添加了 Windows 支持</p>
<h3 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h3><h4 id="在-Windows-上将参数列表转换为一个字符串"><a href="#在-Windows-上将参数列表转换为一个字符串" class="headerlink" title="在 Windows 上将参数列表转换为一个字符串"></a>在 Windows 上将参数列表转换为一个字符串</h4><p>在 Windows 上，<em>args</em> 序列会被转换为可使用以下规则来解析的字符串（对应于 MS C 运行时所使用的规则）:</p>
<ol>
<li>参数以空白符分隔，即空格符或制表符。</li>
<li>用双引号标示的字符串会被解读为单个参数，而不再考虑其中的空白符。 一个参数可以嵌套用引号标示的字符串。</li>
<li>带有一个反斜杠前缀的双引号会被解读为双引号字面值。</li>
<li>反斜杠会按字面值解读，除非它是作为双引号的前缀。</li>
<li>如果反斜杠被作为双引号的前缀，则每个反斜杠对会被解读为一个反斜杠字面值。 如果反斜杠数量为奇数，则最后一个反斜杠会如规则 3 所描述的那样转义下一个双引号。</li>
</ol>
<h1 id="网络和进程间通信"><a href="#网络和进程间通信" class="headerlink" title="网络和进程间通信"></a>网络和进程间通信</h1><p>本章介绍的模块提供了网络和进程间通信的机制。</p>
<p>某些模块仅适用于同一台机器上的两个进程，例如 <code>signal</code> 和 <code>mmap</code> 。 其他模块支持两个或多个进程可用于跨机器通信的网络协议。</p>
<p>本章中描述的模块列表是：</p>
<ul>
<li><code>asyncio</code> —- 异步 I/O</li>
<li><code>socket</code> —- 底层网络接口</li>
<li><code>ssl</code> —- 套接字对象的 TLS/SSL 包装器</li>
<li><code>select</code> —- 等待 I/O 完成</li>
<li><code>selectors</code> —- 高级 I/O 复用库</li>
<li><code>asyncore</code> —- 异步套接字处理器</li>
<li><code>asynchat</code> —- 异步套接字指令/响应处理程序</li>
<li><code>signal</code> —- 设置异步事件处理程序</li>
<li><code>mmap</code> —- 内存映射文件支持</li>
</ul>
<h2 id="asyncio-—-异步-I-O"><a href="#asyncio-—-异步-I-O" class="headerlink" title="asyncio —- 异步 I/O"></a><code>asyncio</code> —- 异步 I/O</h2><p>Hello World!</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> asyncio
<span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Hello ...'</span><span class="token punctuation">)</span>
    <span class="token keyword">await</span> asyncio<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'... World!'</span><span class="token punctuation">)</span>
<span class="token comment" spellcheck="true"># Python 3.7+</span>
asyncio<span class="token punctuation">.</span>run<span class="token punctuation">(</span>main<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>asyncio 是用来编写 <strong>并发</strong> 代码的库，使用 <strong>async/await</strong> 语法。</p>
<p>asyncio 被用作多个提供高性能 Python 异步框架的基础，包括网络和网站服务，数据库连接库，分布式任务队列等等。</p>
<p>asyncio 往往是构建 IO 密集型和高层级 <strong>结构化</strong> 网络代码的最佳选择。</p>
<p>asyncio 提供一组 <strong>高层级</strong> API 用于:</p>
<ul>
<li>并发地 运行 Python 协程 并对其执行过程实现完全控制;</li>
<li>执行 网络 IO 和 IPC;</li>
<li>控制 子进程;</li>
<li>通过 队列 实现分布式任务;</li>
<li>同步 并发代码;</li>
</ul>
<p>此外，还有一些 <strong>低层级</strong> API 以支持 <em>库和框架的开发者</em> 实现:</p>
<ul>
<li>创建和管理 事件循环，以提供异步 API 用于 <code>网络化</code>, 运行 <code>子进程</code>，处理 <code>OS 信号</code> 等等;</li>
<li>使用 transports 实现高效率协议;</li>
<li>通过 async/await 语法 桥接 基于回调的库和代码。</li>
</ul>
<p>参考</p>
<ul>
<li><p>高层级 API</p>
<ul>
<li><a href="https://docs.python.org/zh-cn/3.10/library/asyncio-task.html" target="_blank" rel="noopener">协程与任务</a></li>
<li><a href="https://docs.python.org/zh-cn/3.10/library/asyncio-stream.html" target="_blank" rel="noopener">流</a></li>
<li><a href="https://docs.python.org/zh-cn/3.10/library/asyncio-sync.html" target="_blank" rel="noopener">同步原语</a></li>
<li><a href="https://docs.python.org/zh-cn/3.10/library/asyncio-subprocess.html" target="_blank" rel="noopener">子进程集</a></li>
<li><a href="https://docs.python.org/zh-cn/3.10/library/asyncio-queue.html" target="_blank" rel="noopener">队列集</a></li>
<li><a href="https://docs.python.org/zh-cn/3.10/library/asyncio-exceptions.html" target="_blank" rel="noopener">异常</a></li>
</ul>
<p>低层级 API</p>
<ul>
<li><a href="https://docs.python.org/zh-cn/3.10/library/asyncio-eventloop.html" target="_blank" rel="noopener">事件循环</a></li>
<li><a href="https://docs.python.org/zh-cn/3.10/library/asyncio-future.html" target="_blank" rel="noopener">Futures</a></li>
<li><a href="https://docs.python.org/zh-cn/3.10/library/asyncio-protocol.html" target="_blank" rel="noopener">传输和协议</a></li>
<li><a href="https://docs.python.org/zh-cn/3.10/library/asyncio-policy.html" target="_blank" rel="noopener">策略</a></li>
<li><a href="https://docs.python.org/zh-cn/3.10/library/asyncio-platforms.html" target="_blank" rel="noopener">平台支持</a></li>
</ul>
<p>指南与教程</p>
<ul>
<li><a href="https://docs.python.org/zh-cn/3.10/library/asyncio-api-index.html" target="_blank" rel="noopener">高层级 API 索引</a></li>
<li><a href="https://docs.python.org/zh-cn/3.10/library/asyncio-llapi-index.html" target="_blank" rel="noopener">低层级 API 索引</a></li>
<li><a href="https://docs.python.org/zh-cn/3.10/library/asyncio-dev.html" target="_blank" rel="noopener">用 asyncio 开发</a></li>
</ul>
</li>
</ul>
<p>注解</p>
<p>asyncio 的源代码可以在 <a href="https://github.com/python/cpython/tree/3.10/Lib/asyncio/" target="_blank" rel="noopener">Lib/asyncio/</a> 中找到。</p>
<h2 id="socket-—-底层网络接口"><a href="#socket-—-底层网络接口" class="headerlink" title="socket —- 底层网络接口"></a><code>socket</code> —- 底层网络接口</h2><p><strong>源代码:</strong> <a href="https://github.com/python/cpython/tree/3.10/Lib/socket.py" target="_blank" rel="noopener">Lib/socket.py</a></p>
<hr>
<p>这个模块提供了访问 BSD <em>套接字</em> 的接口。在所有现代 Unix 系统、Windows、macOS 和其他一些平台上可用。</p>
<p>注解</p>
<p>一些行为可能因平台不同而异，因为调用的是操作系统的套接字API。</p>
<p>这个Python接口是用Python的面向对象风格对Unix系统调用和套接字库接口的直译：函数 <code>socket()</code> 返回一个 <em>套接字对象</em> ，其方法是对各种套接字系统调用的实现。形参类型一般与C接口相比更高级：例如在Python文件 <code>read()</code> 和 <code>write()</code> 操作中，接收操作的缓冲区分配是自动的，发送操作的缓冲区长度是隐式的。</p>
<h3 id="套接字协议族"><a href="#套接字协议族" class="headerlink" title="套接字协议族"></a>套接字协议族</h3><p>根据系统以及构建选项，此模块提供了各种套接字协议簇。</p>
<p>特定的套接字对象需要的地址格式将根据此套接字对象被创建时指定的地址族被自动选择。套接字地址表示如下：</p>
<ul>
<li><p>一个绑定在文件系统节点上的 <code>AF_UNIX</code> 套接字的地址表示为一个字符串，使用文件系统字符编码和 <code>'surrogateescape'</code> 错误回调方法（see <a href="https://www.python.org/dev/peps/pep-0383" target="_blank" rel="noopener"><strong>PEP 383</strong></a>）。一个地址在 Linux 的抽象命名空间被返回为带有初始的 null 字节的 字节类对象 ；注意在这个命名空间种的套接字可能与普通文件系统套接字通信，所以打算运行在 Linux 上的程序可能需要解决两种地址类型。当传递为参数时，一个字符串或字节类对象可以用于任一类型的地址。</p>
<p>在 3.3 版更改: 之前，<code>AF_UNIX</code> 套接字路径被假设使用 UTF-8 编码。</p>
<p>在 3.5 版更改: 现在接受可写的 字节类对象。</p>
</li>
<li><p>一对 <code>(host, port)</code> 被用作 <code>AF_INET</code> 地址族，其中 <em>host</em> 是一个表示互联网域名标记形式的主机名例如 <code>'daring.cwi.nl'</code> 或者 IPv4 地址例如 <code>'100.50.200.5'</code> 的字符串，而 <em>port</em> 是一个整数值。</p>
<ul>
<li>对于 IPv4 地址，有两种可接受的特殊形式被用来代替一个主机地址： <code>''</code> 代表 <code>INADDR_ANY</code>，用来绑定到所有接口；字符串 <code>'&lt;broadcast&gt;'</code> 代表 <code>INADDR_BROADCAST</code>。此行为不兼容 IPv6，因此，如果你的 Python 程序打算支持 IPv6，则可能需要避开这些。</li>
</ul>
</li>
<li><p>对于 <code>AF_INET6</code> 地址族，使用一个四元组 <code>(host, port, flowinfo, scope_id)</code>，其中 <em>flowinfo</em> 和 <em>scope_id</em> 代表了 C 库 <code>struct sockaddr_in6</code> 中的 <code>sin6_flowinfo</code> 和 <code>sin6_scope_id</code> 成员。对于 <code>socket</code> 模块中的方法， <em>flowinfo</em> 和 <em>scope_id</em> 可以被省略，只为了向后兼容。注意，省略 <em>scope_id</em> 可能会导致操作带有领域 (Scope) 的 IPv6 地址时出错。</p>
<p>在 3.7 版更改: 对于多播地址（其 <em>scope_id</em> 起作用），<em>地址</em> 中可以不包含 <code>%scope_id</code> （或 <code>zone id</code> ）部分，这部分是多余的，可以放心省略（推荐）。</p>
</li>
<li><p><code>AF_NETLINK</code> 套接字由一对 <code>(pid, groups)</code> 表示。</p>
</li>
<li><p>指定 <code>AF_TIPC</code> 地址族可以使用仅 Linux 支持的 TIPC 协议。TIPC 是一种开放的、非基于 IP 的网络协议，旨在用于集群计算环境。其地址用元组表示，其中的字段取决于地址类型。一般元组形式为 <code>(addr_type, v1, v2, v3 [, scope])</code>，其中：</p>
<ul>
<li><p><em>addr_type</em> 取 <code>TIPC_ADDR_NAMESEQ</code>、<code>TIPC_ADDR_NAME</code> 或 <code>TIPC_ADDR_ID</code> 中的一个。</p>
</li>
<li><p><em>scope</em> 取 <code>TIPC_ZONE_SCOPE</code>、<code>TIPC_CLUSTER_SCOPE</code> 和 <code>TIPC_NODE_SCOPE</code> 中的一个。</p>
</li>
<li><p>如果 <em>addr_type</em> 为 <code>TIPC_ADDR_NAME</code>，那么 <em>v1</em> 是服务器类型，<em>v2</em> 是端口标识符，<em>v3</em> 应为 0。</p>
<p>如果 <em>addr_type</em> 为 <code>TIPC_ADDR_NAMESEQ</code>，那么 <em>v1</em> 是服务器类型，<em>v2</em> 是端口号下限，而 <em>v3</em> 是端口号上限。</p>
<p>如果 <em>addr_type</em> 为 <code>TIPC_ADDR_ID</code>，那么 <em>v1</em> 是节点 (node)，<em>v2</em> 是 ref，<em>v3</em> 应为 0。</p>
</li>
</ul>
</li>
<li><p><code>AF_CAN</code> 地址族使用元组 <code>(interface, )</code>，其中 <em>interface</em> 是表示网络接口名称的字符串，如 <code>'can0'</code>。网络接口名 <code>''</code> 可以用于接收本族所有网络接口的数据包。</p>
<ul>
<li><code>CAN_ISOTP</code> 协议接受一个元组 <code>(interface, rx_addr, tx_addr)</code>，其中两个额外参数都是无符号长整数，都表示 CAN 标识符（标准或扩展标识符）。</li>
<li><code>CAN_J1939</code> 协议接受一个元组 <code>(interface, name, pgn, addr)</code>，其中额外参数有：表示 ECU 名称的 64 位无符号整数，表示参数组号 (Parameter Group Number, PGN) 的 32 位无符号整数，以及表示地址的 8 位整数。</li>
</ul>
</li>
<li><p><code>PF_SYSTEM</code> 协议簇的 <code>SYSPROTO_CONTROL</code> 协议接受一个字符串或元组 <code>(id, unit)</code>。其中字符串是内核控件的名称，该控件使用动态分配的 ID。而如果 ID 和内核控件的单元 (unit) 编号都已知，或使用了已注册的 ID，可以采用元组。</p>
<p>3.3 新版功能.</p>
</li>
<li><p><code>AF_BLUETOOTH</code> 支持以下协议和地址格式：</p>
<ul>
<li><p><code>BTPROTO_L2CAP</code> 接受 <code>(bdaddr, psm)</code>，其中 <code>bdaddr</code> 为字符串格式的蓝牙地址，<code>psm</code> 是一个整数。</p>
</li>
<li><p><code>BTPROTO_RFCOMM</code> 接受 <code>(bdaddr, channel)</code>，其中 <code>bdaddr</code> 为字符串格式的蓝牙地址，<code>channel</code> 是一个整数。</p>
</li>
<li><p><code>BTPROTO_HCI</code> 接受 <code>(device_id,)</code>，其中 <code>device_id</code> 为整数或字符串，它表示接口对应的蓝牙地址（具体取决于你的系统，NetBSD 和 DragonFlyBSD 需要蓝牙地址字符串，其他系统需要整数）。</p>
<p>在 3.2 版更改: 添加了对 NetBSD 和 DragonFlyBSD 的支持。</p>
</li>
<li><p><code>BTPROTO_SCO</code> 接受 <code>bdaddr</code>，其中 <code>bdaddr</code> 是 <code>bytes</code> 对象，其中含有字符串格式的蓝牙地址（如 <code>b'12:23:34:45:56:67'</code> ），FreeBSD 不支持此协议。</p>
</li>
</ul>
</li>
<li><p><code>AF_ALG</code> 是一个仅 Linux 可用的、基于套接字的接口，用于连接内核加密算法。算法套接字可用包括 2 至 4 个元素的元组来配置 <code>(type, name [, feat [, mask]])</code>，其中：</p>
<ul>
<li><em>type</em> 是表示算法类型的字符串，如 <code>aead</code>、<code>hash</code>、<code>skcipher</code> 或 <code>rng</code>。</li>
<li><em>name</em> 是表示算法类型和操作模式的字符串，如 <code>sha256</code>、<code>hmac(sha256)</code>、<code>cbc(aes)</code> 或 <code>drbg_nopr_ctr_aes256</code>。</li>
<li><em>feat</em> 和 <em>mask</em> 是无符号 32 位整数。</li>
</ul>
<p>Availability: Linux 2.6.38, some algorithm types require more recent Kernels.</p>
<p>3.6 新版功能.</p>
</li>
<li><p><code>AF_VSOCK</code> 用于支持虚拟机与宿主机之间的通讯。该套接字用 <code>(CID, port)</code> 元组表示，其中 Context ID (CID) 和 port 都是整数。</p>
<p>Availability: Linux &gt;= 4.8 QEMU &gt;= 2.8 ESX &gt;= 4.0 ESX Workstation &gt;= 6.5.</p>
<p>3.7 新版功能.</p>
</li>
<li><p><code>AF_PACKET</code> 是一个底层接口，直接连接至网卡。数据包使用元组 <code>(ifname, proto[, pkttype[, hatype[, addr]]])</code> 表示，其中：</p>
<ul>
<li><em>ifname</em> - 指定设备名称的字符串。</li>
<li><em>proto</em> - 一个用网络字节序表示的整数，指定以太网协议版本号。</li>
<li><em>pkttype</em> - 指定数据包类型的整数（可选）：<ul>
<li><code>PACKET_HOST</code> （默认） - 寻址到本地主机的数据包。</li>
<li><code>PACKET_BROADCAST</code> - 物理层广播的数据包。</li>
<li><code>PACKET_MULTIHOST</code> - 发送到物理层多播地址的数据包。</li>
<li><code>PACKET_OTHERHOST</code> - 被（处于混杂模式的）网卡驱动捕获的、发送到其他主机的数据包。</li>
<li><code>PACKET_OUTGOING</code> - 来自本地主机的、回环到一个套接字的数据包。</li>
</ul>
</li>
<li><em>hatype</em> - 可选整数，指定 ARP 硬件地址类型。</li>
<li><em>addr</em> - 可选的类字节串对象，用于指定硬件物理地址，其解释取决于各设备。</li>
</ul>
</li>
<li><p><code>AF_QIPCRTR</code> 是一个仅 Linux 可用的、基于套接字的接口，用于与高通平台中协处理器上运行的服务进行通信。该地址簇用一个 <code>(node, port)</code> 元组表示，其中 <em>node</em> 和 <em>port</em> 为非负整数。</p>
<p>3.8 新版功能.</p>
</li>
<li><p><code>IPPROTO_UDPLITE</code> 是一种 UDP 的变体，允许指定数据包的哪一部分计算入校验码内。它添加了两个可以修改的套接字选项。<code>self.setsockopt(IPPROTO_UDPLITE, UDPLITE_SEND_CSCOV, length)</code> 修改传出数据包的哪一部分计算入校验码内，而 <code>self.setsockopt(IPPROTO_UDPLITE, UDPLITE_RECV_CSCOV, length)</code> 将过滤掉计算入校验码的数据太少的数据包。在这两种情况下，<code>length</code> 都应在 <code>range(8, 2**16, 8)</code> 范围内。</p>
<p>对于 IPv4，应使用 <code>socket(AF_INET, SOCK_DGRAM, IPPROTO_UDPLITE)</code> 来构造这样的套接字；对于 IPv6，应使用 <code>socket(AF_INET6, SOCK_DGRAM, IPPROTO_UDPLITE)</code> 来构造这样的套接字。</p>
<p>Availability: Linux &gt;= 2.6.20, FreeBSD &gt;= 10.1-RELEASE</p>
<p>3.9 新版功能.</p>
</li>
</ul>
<p>如果你在 IPv4/v6 套接字地址的 <em>host</em> 部分中使用了一个主机名，此程序可能会表现不确定行为，因为 Python 使用 DNS 解析返回的第一个地址。套接字地址在实际的 IPv4/v6 中以不同方式解析，根据 DNS 解析和/或 host 配置。为了确定行为，在 <em>host</em> 部分中使用数字的地址。</p>
<p>所有的错误都抛出异常。对于无效的参数类型和内存溢出异常情况可能抛出普通异常；从 Python 3.3 开始，与套接字或地址语义有关的错误抛出 <code>OSError</code> 或它的子类之一（常用 <code>socket.error</code>）。</p>
<p>可以用 <code>setblocking()</code> 设置非阻塞模式。一个基于超时的 generalization 通过 <code>settimeout()</code> 支持。</p>
<h3 id="模块内容"><a href="#模块内容" class="headerlink" title="模块内容"></a>模块内容</h3><p><code>socket</code> 模块包含下列元素。</p>
<h4 id="异常-1"><a href="#异常-1" class="headerlink" title="异常"></a>异常</h4><p><em>exception</em> <code>socket.error</code></p>
<p>一个被弃用的 <code>OSError</code> 的别名。</p>
<p>在 3.3 版更改: 根据 <a href="https://www.python.org/dev/peps/pep-3151" target="_blank" rel="noopener"><strong>PEP 3151</strong></a>，这个类是 <code>OSError</code> 的别名。</p>
<p><em>exception</em> <code>socket.herror</code></p>
<p><code>OSError</code> 的子类，本异常通常表示与地址相关的错误，比如那些在 POSIX C API 中使用了 <em>h_errno</em> 的函数，包括 <code>gethostbyname_ex()</code> 和 <code>gethostbyaddr()</code>。附带的值是一对 <code>(h_errno, string)</code>，代表库调用返回的错误。<em>h_errno</em> 是一个数字，而 <em>string</em> 表示 <em>h_errno</em> 的描述，它们由 C 函数 <code>hstrerror()</code> 返回。</p>
<p>在 3.3 版更改: 此类是 <code>OSError</code> 的子类。</p>
<p><em>exception</em> <code>socket.gaierror</code></p>
<p><code>OSError</code> 的子类，本异常来自 <code>getaddrinfo()</code> 和 <code>getnameinfo()</code>，表示与地址相关的错误。附带的值是一对 <code>(error, string)</code>，代表库调用返回的错误。<em>string</em> 表示 <em>error</em> 的描述，它由 C 函数 <code>gai_strerror()</code> 返回。数字值 <em>error</em> 与本模块中定义的 <code>EAI_*</code> 常量之一匹配。</p>
<p>在 3.3 版更改: 此类是 <code>OSError</code> 的子类。</p>
<p><em>exception</em> <code>socket.timeout</code></p>
<p><code>TimeoutError</code> 的已被弃用的别名。</p>
<p><code>OSError</code> 的子类，当套接字发生超时，且事先已调用过 <code>settimeout()</code> （或隐式地通过 <code>setdefaulttimeout()</code> ）启用了超时，则会抛出此异常。附带的值是一个字符串，其值总是 “timed out”。</p>
<p>在 3.3 版更改: 此类是 <code>OSError</code> 的子类。</p>
<p>在 3.10 版更改: 这个类是 <code>TimeoutError</code> 的别名。</p>
<h4 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h4><blockquote>
<p>AF_* 和 SOCK_* 常量现在都在 <code>AddressFamily</code> 和 <code>SocketKind</code> 这两个 <code>IntEnum</code> 集合内。</p>
<p>3.4 新版功能.</p>
</blockquote>
<pre><code>socket.AF_UNIX
socket.AF_INET
socket.AF_INET6</code></pre><p>这些常量表示地址（和协议）簇，用于 <code>socket()</code> 的第一个参数。如果 <code>AF_UNIX</code> 常量未定义，即表示不支持该协议。不同系统可能会有更多其他常量可用。</p>
<pre><code>socket.SOCK_STREAM
socket.SOCK_DGRAM
socket.SOCK_RAW
socket.SOCK_RDM
socket.SOCK_SEQPACKET</code></pre><p>这些常量表示套接字类型，用于 <code>socket()</code> 的第二个参数。不同系统可能会有更多其他常量可用。（一般只有 <code>SOCK_STREAM</code> 和 <code>SOCK_DGRAM</code> 可用）</p>
<pre><code>socket.SOCK_CLOEXEC
socket.SOCK_NONBLOCK</code></pre><p>这两个常量（如果已定义）可以与上述套接字类型结合使用，允许你设置这些原子性相关的 flags （从而避免可能的竞争条件和单独调用的需要）。</p>
<p>参见</p>
<p><a href="http://udrepper.livejournal.com/20407.html" target="_blank" rel="noopener">Secure File Descriptor Handling （安全地处理文件描述符）</a> 提供了更详尽的解释。</p>
<p>可用性： Linux &gt;= 2.6.27。</p>
<p>3.2 新版功能.</p>
<pre><code>SO_*
socket.SOMAXCONN
MSG_*
SOL_*
SCM_*
IPPROTO_*
IPPORT_*
INADDR_*
IP_*
IPV6_*
EAI_*
AI_*
NI_*
TCP_*</code></pre><p>此列表内的许多常量，记载在 Unix 文档中的套接字和/或 IP 协议部分，同时也定义在本 socket 模块中。它们通常用于套接字对象的 <code>setsockopt()</code> 和 <code>getsockopt()</code> 方法的参数中。在大多数情况下，仅那些在 Unix 头文件中有定义的符号会在本模块中定义，部分符号提供了默认值。</p>
<p>在 3.6 版更改: 添加了 <code>SO_DOMAIN</code>, <code>SO_PROTOCOL</code>, <code>SO_PEERSEC</code>, <code>SO_PASSSEC</code>, <code>TCP_USER_TIMEOUT</code>, <code>TCP_CONGESTION</code>。</p>
<p>在 3.6.5 版更改: 在 Windows 上，如果 Windows 运行时支持，则 <code>TCP_FASTOPEN</code>、<code>TCP_KEEPCNT</code> 可用。</p>
<p>在 3.7 版更改: 添加了 <code>TCP_NOTSENT_LOWAT</code>。</p>
<p>在 Windows 上，如果 Windows 运行时支持，则 <code>TCP_KEEPIDLE</code>、<code>TCP_KEEPINTVL</code> 可用。</p>
<p>在 3.10 版更改: 添加了 <code>IP_RECVTOS</code>。 还添加了 <code>TCP_KEEPALIVE</code>。 这个常量在 MacOS 上可以与在 Linux 上使用 <code>TCP_KEEPIDLE</code> 的相同方式被使用。</p>
<pre><code>socket.AF_CAN
socket.PF_CAN
SOL_CAN_*
CAN_*</code></pre><p>此列表内的许多常量，记载在 Linux 文档中，同时也定义在本 socket 模块中。</p>
<p>可用性： Linux &gt;= 2.6.25。</p>
<p>3.3 新版功能.</p>
<pre><code>socket.CAN_BCM
CAN_BCM_*</code></pre><p>CAN 协议簇内的 CAN_BCM 是广播管理器（Bbroadcast Manager — BCM）协议，广播管理器常量在 Linux 文档中有所记载，在本 socket 模块中也有定义。</p>
<p>可用性： Linux &gt;= 2.6.25。</p>
<p>注解</p>
<p><code>CAN_BCM_CAN_FD_FRAME</code> 旗标仅在 Linux &gt;= 4.8 时可用。</p>
<p>3.4 新版功能.</p>
<pre><code>socket.CAN_RAW_FD_FRAMES</code></pre><p>在 CAN_RAW 套接字中启用 CAN FD 支持，默认是禁用的。它使应用程序可以发送 CAN 和 CAN FD 帧。但是，从套接字读取时，也必须同时接受 CAN 和 CAN FD 帧。</p>
<p>此常量在 Linux 文档中有所记载。</p>
<p>可用性： Linux &gt;= 3.6。</p>
<p>3.5 新版功能.</p>
<pre><code>socket.CAN_RAW_JOIN_FILTERS</code></pre><p>加入已应用的 CAN 过滤器，这样只有与所有 CAN 过滤器匹配的 CAN 帧才能传递到用户空间。</p>
<p>此常量在 Linux 文档中有所记载。</p>
<p>可用性： Linux &gt;= 4.1。</p>
<p>3.9 新版功能.</p>
<pre><code>socket.CAN_ISOTP</code></pre><p>CAN 协议簇中的 CAN_ISOTP 就是 ISO-TP (ISO 15765-2) 协议。ISO-TP 常量在 Linux 文档中有所记载。</p>
<p>可用性： Linux &gt;= 2.6.25。</p>
<p>3.7 新版功能.</p>
<pre><code>socket.CAN_J1939</code></pre><p>CAN 协议族中的 CAN_J1939 即 SAE J1939 协议。 J1939 常量记录在 Linux 文档中。</p>
<p>可用性： Linux &gt;= 5.4。</p>
<p>3.9 新版功能.</p>
<pre><code>socket.AF_PACKET
socket.PF_PACKET
PACKET_*</code></pre><p>此列表内的许多常量，记载在 Linux 文档中，同时也定义在本 socket 模块中。</p>
<p>可用性： Linux &gt;= 2.2。</p>
<pre><code>socket.AF_RDS
socket.PF_RDS
socket.SOL_RDS
RDS_*</code></pre><p>此列表内的许多常量，记载在 Linux 文档中，同时也定义在本 socket 模块中。</p>
<p>可用性： Linux &gt;= 2.6.30。</p>
<p>3.3 新版功能.</p>
<pre><code>socket.SIO_RCVALL
socket.SIO_KEEPALIVE_VALS
socket.SIO_LOOPBACK_FAST_PATH
RCVALL_*</code></pre><p>Windows 的 WSAIoctl() 的常量。这些常量用于套接字对象的 <code>ioctl()</code> 方法的参数。</p>
<p>在 3.6 版更改: 添加了 <code>SIO_LOOPBACK_FAST_PATH</code>。</p>
<pre><code>TIPC_*</code></pre><p>TIPC 相关常量，与 C socket API 导出的常量一致。更多信息请参阅 TIPC 文档。</p>
<pre><code>socket.AF_ALG
socket.SOL_ALG
ALG_*</code></pre><p>用于 Linux 内核加密算法的常量。</p>
<p>可用性： Linux &gt;= 2.6.38。</p>
<p>3.6 新版功能.</p>
<pre><code>socket.AF_VSOCK
socket.IOCTL_VM_SOCKETS_GET_LOCAL_CID
VMADDR*
SO_VM*</code></pre><p>用于 Linux 宿主机/虚拟机通讯的常量。</p>
<p>可用性： Linux &gt;= 4.8。</p>
<p>3.7 新版功能.</p>
<pre><code>socket.AF_LINK</code></pre><p>Availability: BSD, macOS.</p>
<p>3.4 新版功能.</p>
<pre><code>socket.has_ipv6</code></pre><p>本常量为一个布尔值，该值指示当前平台是否支持 IPv6。</p>
<pre><code>socket.BDADDR_ANY
socket.BDADDR_LOCAL</code></pre><p>这些是字符串常量，包含蓝牙地址，这些地址具有特殊含义。例如，当用 <code>BTPROTO_RFCOMM</code> 指定绑定套接字时， <code>BDADDR_ANY</code> 表示“任何地址”。</p>
<pre><code>socket.HCI_FILTER
socket.HCI_TIME_STAMP
socket.HCI_DATA_DIR</code></pre><p>与 <code>BTPROTO_HCI</code> 一起使用。 <code>HCI_FILTER</code> 在 NetBSD 或 DragonFlyBSD 上不可用。 <code>HCI_TIME_STAMP</code> 和 <code>HCI_DATA_DIR</code> 在 FreeBSD、NetBSD 或 DragonFlyBSD 上不可用。</p>
<pre><code>socket.AF_QIPCRTR</code></pre><p>高通 IPC 路由协议的常数，用于与提供远程处理器的服务进行通信。</p>
<p>可用性： Linux &gt;= 4.7。</p>
<h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><h5 id="创建套接字"><a href="#创建套接字" class="headerlink" title="创建套接字"></a>创建套接字</h5><p>下列函数都能创建 套接字对象.</p>
<p><code>socket.socket</code>(<em>family=AF_INET</em>, <em>type=SOCK_STREAM</em>, <em>proto=0</em>, <em>fileno=None</em>)</p>
<p>使用给定的地址族、套接字类型和协议号创建一个新的套接字。 地址族应为 <code>AF_INET</code> (默认值), <code>AF_INET6</code>, <code>AF_UNIX</code>, <code>AF_CAN</code>, <code>AF_PACKET</code> 或 <code>AF_RDS</code> 之一。 套接字类型应为 <code>SOCK_STREAM</code> (默认值), <code>SOCK_DGRAM</code>, <code>SOCK_RAW</code> 或其他可能的 <code>SOCK_</code> 常量之一。 协议号通常为零并且可以省略，或在协议族为 <code>AF_CAN</code> 的情况下，协议应为 <code>CAN_RAW</code>, <code>CAN_BCM</code>, <code>CAN_ISOTP</code> 或 <code>CAN_J1939</code> 之一。</p>
<p>如果指定了 <em>fileno<em>，那么将从这一指定的文件描述符中自动检测 *family</em>、*type</em> 和 <em>proto</em> 的值。如果调用本函数时显式指定了 <em>family<em>、</em>type</em> 或 <em>proto</em> 参数，可以覆盖自动检测的值。这只会影响 Python 表示诸如 <code>socket.getpeername()</code> 一类函数的返回值的方式，而不影响实际的操作系统资源。与 <code>socket.fromfd()</code> 不同，<em>fileno</em> 将返回原先的套接字，而不是复制出新的套接字。这有助于在分离的套接字上调用 <code>socket.close()</code> 来关闭它。</p>
<p>新创建的套接字是 不可继承的。</p>
<p>引发一个 审计事件 <code>socket.__new__</code> 附带参数 <code>self</code>、<code>family</code>、<code>type</code>、<code>protocol</code>。</p>
<p>在 3.3 版更改: 添加了 AF_CAN 簇。添加了 AF_RDS 簇。</p>
<p>在 3.4 版更改: 添加了 CAN_BCM 协议。</p>
<p>在 3.4 版更改: 返回的套接字现在是不可继承的。</p>
<p>在 3.7 版更改: 添加了 CAN_ISOTP 协议。</p>
<p>在 3.7 版更改: 当将 <code>SOCK_NONBLOCK</code> 或 <code>SOCK_CLOEXEC</code> 标志位应用于 <em>type</em> 上时，它们会被清除，且 <code>socket.type</code> 反映不出它们。但它们仍将传递给底层系统的 socket() 调用。因此，</p>
<pre class="line-numbers language-python"><code class="language-python">sock <span class="token operator">=</span> socket<span class="token punctuation">.</span>socket<span class="token punctuation">(</span>
    socket<span class="token punctuation">.</span>AF_INET<span class="token punctuation">,</span>
    socket<span class="token punctuation">.</span>SOCK_STREAM <span class="token operator">|</span> socket<span class="token punctuation">.</span>SOCK_NONBLOCK<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>仍将在支持 <code>SOCK_NONBLOCK</code> 的系统上创建一个非阻塞的套接字，但是 <code>sock.type</code> 会被置为 <code>socket.SOCK_STREAM</code>。</p>
<p>在 3.9 版更改: 添加了 CAN_J1939 协议。</p>
<p>在 3.10 版更改: 添加了 IPPROTO_MPTCP 协议。</p>
<p><code>socket.socketpair</code>([<em>family</em>[, <em>type</em>[, <em>proto</em>]]])</p>
<p>构建一对已连接的套接字对象，使用给定的地址簇、套接字类型和协议号。地址簇、套接字类型和协议号与上述 <code>socket()</code> 函数相同。默认地址簇为 <code>AF_UNIX</code> （需要当前平台支持，不支持则默认为 <code>AF_INET</code> ）。</p>
<p>新创建的套接字都是 不可继承的。</p>
<p>在 3.2 版更改: 现在，返回的套接字对象支持全部套接字 API，而不是全部 API 的一个子集。</p>
<p>在 3.4 版更改: 返回的套接字现在都是不可继承的。</p>
<p>在 3.5 版更改: 添加了 Windows 支持。</p>
<p><code>socket.create_connection</code>(<em>address</em>[, <em>timeout</em>[, <em>source_address</em>]])</p>
<p>连接到一个在互联网 <em>address</em> (以 <code>(host, port)</code> 2 元组表示) 上侦听的 TCP 服务，并返回套接字对象。 这是一个相比 <code>socket.connect()</code> 层级更高的函数：如果 <em>host</em> 是非数字的主机名，它将尝试将其解析为 <code>AF_INET</code> 和 <code>AF_INET6</code>，然后依次尝试连接到所有可能的地址直到连接成功。 这使编写兼容 IPv4 和 IPv6 的客户端变得很容易。</p>
<p>传入可选参数 <em>timeout</em> 可以在套接字实例上设置超时（在尝试连接前）。如果未提供 <em>timeout</em>，则使用由 <code>getdefaulttimeout()</code> 返回的全局默认超时设置。</p>
<p>如果提供了 <em>source_address</em>，它必须为二元组 <code>(host, port)</code>，以便套接字在连接之前绑定为其源地址。如果 host 或 port 分别为 ‘’ 或 0，则使用操作系统默认行为。</p>
<p>在 3.2 版更改: 添加了<em>source_address</em> 参数</p>
<p><code>socket.create_server</code>(<em>address</em>, <em>**,</em> family=AF_INET<em>,</em> backlog=None<em>,</em> reuse_port=False<em>,</em> dualstack_ipv6=False*)</p>
<p>便捷函数，创建绑定到 <em>address</em> （二元组 <code>(host, port)</code> ）的 TCP 套接字，返回套接字对象。</p>
<p><em>family</em> 应设置为 <code>AF_INET</code> 或 <code>AF_INET6</code>。<em>backlog</em> 是传递给 <code>socket.listen()</code> 的队列大小，当它为 <code>0</code> 则表示默认的合理值。<em>reuse_port</em> 表示是否设置 <code>SO_REUSEPORT</code> 套接字选项。</p>
<p>如果 <em>dualstack_ipv6</em> 为 true 且平台支持，则套接字能接受 IPv4 和 IPv6 连接，否则将抛出 <code>ValueError</code> 异常。大多数 POSIX 平台和 Windows 应该支持此功能。启用此功能后，<code>socket.getpeername()</code> 在进行 IPv4 连接时返回的地址将是一个（映射到 IPv4 的）IPv6 地址。在默认启用该功能的平台上（如 Linux），如果 <em>dualstack_ipv6</em> 为 false，即显式禁用此功能。该参数可以与 <code>has_dualstack_ipv6()</code> 结合使用：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> socket
addr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">,</span> <span class="token number">8080</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># all interfaces, port 8080</span>
<span class="token keyword">if</span> socket<span class="token punctuation">.</span>has_dualstack_ipv6<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    s <span class="token operator">=</span> socket<span class="token punctuation">.</span>create_server<span class="token punctuation">(</span>addr<span class="token punctuation">,</span> family<span class="token operator">=</span>socket<span class="token punctuation">.</span>AF_INET6<span class="token punctuation">,</span> dualstack_ipv6<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>
<span class="token keyword">else</span><span class="token punctuation">:</span>
    s <span class="token operator">=</span> socket<span class="token punctuation">.</span>create_server<span class="token punctuation">(</span>addr<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>注解</p>
<p>在 POSIX 平台上，设置 <code>SO_REUSEADDR</code> 套接字选项是为了立即重用以前绑定在同一 <em>address</em> 上并保持 TIME_WAIT 状态的套接字。</p>
<p>3.8 新版功能.</p>
<p><code>socket.has_dualstack_ipv6</code>()</p>
<p>如果平台支持创建 IPv4 和 IPv6 连接都可以处理的 TCP 套接字，则返回 <code>True</code>。</p>
<p>3.8 新版功能.</p>
<p><code>socket.fromfd</code>(<em>fd</em>, <em>family</em>, <em>type</em>, <em>proto=0</em>)</p>
<p>复制文件描述符 <em>fd</em> （一个由文件对象的 <code>fileno()</code> 方法返回的整数），然后从结果中构建一个套接字对象。地址簇、套接字类型和协议号与上述 <code>socket()</code> 函数相同。文件描述符应指向一个套接字，但不会专门去检查——如果文件描述符是无效的，则对该对象的后续操作可能会失败。本函数很少用到，但是在将套接字作为标准输入或输出传递给程序（如 Unix inet 守护程序启动的服务器）时，可以使用本函数获取或设置套接字选项。套接字将处于阻塞模式。</p>
<p>新创建的套接字是 不可继承的。</p>
<p>在 3.4 版更改: 返回的套接字现在是不可继承的。</p>
<p><code>socket.fromshare</code>(<em>data</em>)</p>
<p>根据 <code>socket.share()</code> 方法获得的数据实例化套接字。套接字将处于阻塞模式。</p>
<p>可用性: Windows。</p>
<p>3.3 新版功能.</p>
<pre><code>socket.SocketType</code></pre><p>这是一个 Python 类型对象，表示套接字对象的类型。它等同于 <code>type(socket(...))</code>。</p>
<h4 id="其他功能"><a href="#其他功能" class="headerlink" title="其他功能"></a>其他功能</h4><p><code>socket</code> 模块还提供多种网络相关服务：</p>
<p><code>socket.close</code>(<em>fd</em>)</p>
<p>关闭一个套接字文件描述符。它类似于 <code>os.close()</code>，但专用于套接字。在某些平台上（特别是在 Windows 上），<code>os.close()</code> 对套接字文件描述符无效。</p>
<p>3.7 新版功能.</p>
<p><code>socket.getaddrinfo</code>(<em>host</em>, <em>port</em>, <em>family=0</em>, <em>type=0</em>, <em>proto=0</em>, <em>flags=0</em>)</p>
<p>将 <em>host</em>/<em>port</em> 参数转换为 5 元组的序列，其中包含创建（连接到某服务的）套接字所需的所有参数。<em>host</em> 是域名，是字符串格式的 IPv4/v6 地址或 <code>None</code>。<em>port</em> 是字符串格式的服务名称，如 <code>'http'</code> 、端口号（数字）或 <code>None</code>。传入 <code>None</code> 作为 <em>host</em> 和 <em>port</em> 的值，相当于将 <code>NULL</code> 传递给底层 C API。</p>
<p>可以指定 <em>family<em>、</em>type</em> 和 <em>proto</em> 参数，以缩小返回的地址列表。向这些参数分别传入 0 表示保留全部结果范围。<em>flags</em> 参数可以是 <code>AI_*</code> 常量中的一个或多个，它会影响结果的计算和返回。例如，<code>AI_NUMERICHOST</code> 会禁用域名解析，此时如果 <em>host</em> 是域名，则会抛出错误。</p>
<p>本函数返回一个列表，其中的 5 元组具有以下结构：</p>
<pre><code>(family, type, proto, canonname, sockaddr)</code></pre><p>在这些元组中，<em>family</em>, <em>type</em>, <em>proto</em> 都是整数且其作用是被传入 <code>socket()</code> 函数。 如果 <code>AI_CANONNAME</code> 是 <em>flags</em> 参数的一部分则 <em>canonname</em> 将是表示 <em>host</em> 规范名称的字符串；否则 <em>canonname</em> 将为空。 <em>sockaddr</em> 是一个描述套接字地址的元组，其具体格式取决于返回的 <em>family</em> (对于 <code>AF_INET</code> 为 <code>(address, port)</code> 2 元组，对于 <code>AF_INET6</code> 则为 <code>(address, port, flowinfo, scope_id)</code> 4 元组)，其作用是被传入 <code>socket.connect()</code> 方法。</p>
<p>引发一个 审计事件 <code>socket.getaddrinfo</code> 附带参数 <code>host</code>、<code>port</code>、<code>family</code>、<code>type</code>、<code>protocol</code>。</p>
<p>下面的示例获取了 TCP 连接地址信息，假设该连接通过 80 端口连接至 <code>example.org</code> （如果系统未启用 IPv6，则结果可能会不同）:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> socket<span class="token punctuation">.</span>getaddrinfo<span class="token punctuation">(</span><span class="token string">"example.org"</span><span class="token punctuation">,</span> <span class="token number">80</span><span class="token punctuation">,</span> proto<span class="token operator">=</span>socket<span class="token punctuation">.</span>IPPROTO_TCP<span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>AddressFamily<span class="token punctuation">.</span>AF_INET6<span class="token punctuation">:</span> <span class="token number">10</span><span class="token operator">></span><span class="token punctuation">,</span> <span class="token operator">&lt;</span>AddressFamily<span class="token punctuation">.</span>SOCK_STREAM<span class="token punctuation">:</span> <span class="token number">1</span><span class="token operator">></span><span class="token punctuation">,</span>
 <span class="token number">6</span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'2606:2800:220:1:248:1893:25c8:1946'</span><span class="token punctuation">,</span> <span class="token number">80</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
 <span class="token punctuation">(</span><span class="token operator">&lt;</span>AddressFamily<span class="token punctuation">.</span>AF_INET<span class="token punctuation">:</span> <span class="token number">2</span><span class="token operator">></span><span class="token punctuation">,</span> <span class="token operator">&lt;</span>AddressFamily<span class="token punctuation">.</span>SOCK_STREAM<span class="token punctuation">:</span> <span class="token number">1</span><span class="token operator">></span><span class="token punctuation">,</span>
 <span class="token number">6</span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'93.184.216.34'</span><span class="token punctuation">,</span> <span class="token number">80</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在 3.2 版更改: 现在可以使用关键字参数的形式来传递参数。</p>
<p>在 3.7 版更改: 对于 IPv6 多播地址，表示地址的字符串将不包含 <code>%scope_id</code> 部分。</p>
<p><code>socket.getfqdn</code>([<em>name</em>])</p>
<p>Return a fully qualified domain name for <em>name</em>. If <em>name</em> is omitted or empty, it is interpreted as the local host. To find the fully qualified name, the hostname returned by <code>gethostbyaddr()</code> is checked, followed by aliases for the host, if available. The first name which includes a period is selected. In case no fully qualified domain name is available and <em>name</em> was provided, it is returned unchanged. If <em>name</em> was empty or equal to <code>'0.0.0.0'</code>, the hostname from <code>gethostname()</code> is returned.</p>
<p><code>socket.gethostbyname</code>(<em>hostname</em>)</p>
<p>将主机名转换为 IPv4 地址格式。IPv4 地址以字符串格式返回，如 <code>'100.50.200.5'</code>。如果主机名本身是 IPv4 地址，则原样返回。更完整的接口请参考 <code>gethostbyname_ex()</code>。 <code>gethostbyname()</code> 不支持 IPv6 名称解析，应使用 <code>getaddrinfo()</code> 来支持 IPv4/v6 双协议栈。</p>
<p>引发一个 审计事件 <code>socket.gethostbyname</code>，附带参数 <code>hostname</code>。</p>
<p><code>socket.gethostbyname_ex</code>(<em>hostname</em>)</p>
<p>Translate a host name to IPv4 address format, extended interface. Return a triple <code>(hostname, aliaslist, ipaddrlist)</code> where <em>hostname</em> is the host’s primary host name, <em>aliaslist</em> is a (possibly empty) list of alternative host names for the same address, and <em>ipaddrlist</em> is a list of IPv4 addresses for the same interface on the same host (often but not always a single address). <code>gethostbyname_ex()</code> does not support IPv6 name resolution, and <code>getaddrinfo()</code> should be used instead for IPv4/v6 dual stack support.</p>
<p>引发一个 审计事件 <code>socket.gethostbyname</code>，附带参数 <code>hostname</code>。</p>
<p><code>socket.gethostname</code>()</p>
<p>返回一个字符串，包含当前正在运行 Python 解释器的机器的主机名。</p>
<p>引发一个 审计事件 <code>socket.gethostname</code>，没有附带参数。</p>
<p>注意： <code>gethostname()</code> 并不总是返回全限定域名，必要的话请使用 <code>getfqdn()</code>。</p>
<p><code>socket.gethostbyaddr</code>(<em>ip_address</em>)</p>
<p>返回三元组 <code>(hostname, aliaslist, ipaddrlist)</code>，其中 <em>hostname</em> 是响应给定 <em>ip_address</em> 的主要主机名，<em>aliaslist</em> 是相同地址的其他可用主机名的列表（可能为空），而 <em>ipaddrlist</em> 是 IPv4/v6 地址列表，包含相同主机名、相同接口的不同地址（很可能仅包含一个地址）。要查询全限定域名，请使用函数 <code>getfqdn()</code>。<code>gethostbyaddr()</code> 支持 IPv4 和 IPv6。</p>
<p>引发一个 审计事件 <code>socket.gethostbyaddr</code>，附带参数 <code>ip_address</code>。</p>
<p><code>socket.getnameinfo</code>(<em>sockaddr</em>, <em>flags</em>)</p>
<p>将套接字地址 <em>sockaddr</em> 转换为二元组 <code>(host, port)</code>。<em>host</em> 的形式可能是全限定域名，或是由数字表示的地址，具体取决于 <em>flags</em> 的设置。同样，<em>port</em> 可以包含字符串格式的端口名称或数字格式的端口号。</p>
<p>对于 IPv6 地址，如果 <em>sockaddr</em> 包含有意义的 <em>scope_id</em>，则 <code>%scope_id</code> 会被附加到主机部分。 这种情况通常发生在多播地址上。</p>
<p>引发一个 审计事件 <code>socket.getnameinfo</code>，附带参数 <code>sockaddr</code>。</p>
<p><code>socket.getprotobyname</code>(<em>protocolname</em>)</p>
<p>将一个互联网协议名称 (如 <code>'icmp'</code>) 转换为能被作为 (可选的) 第三个参数传给 <code>socket()</code> 函数的常量。 这通常仅对以 “raw” 模式 (<code>SOCK_RAW</code>) 打开的套接字来说是必要的；对于正常的套接字模式，当该协议名称被省略或为零时会自动选择正确的协议。</p>
<p><code>socket.getservbyname</code>(<em>servicename</em>[, <em>protocolname</em>])</p>
<p>将一个互联网服务名称和协议名称转换为该服务的端口号。 如果给出了可选的协议名称，它应为 <code>'tcp'</code> 或 <code>'udp'</code>，否则将匹配任意的协议。</p>
<p>引发一个 审计事件 <code>socket.getservbyname</code>，附带参数 <code>servicename</code>、<code>protocolname</code>。</p>
<p><code>socket.getservbyport</code>(<em>port</em>[, <em>protocolname</em>])</p>
<p>将一个互联网端口号和协议名称转换为该服务的服务名称。 如果给出了可选的协议名称，它应为 <code>'tcp'</code> 或 <code>'udp'</code>，否则将匹配任意的协议。</p>
<p>引发一个 审计事件 <code>socket.getservbyport</code>，附带参数 <code>port</code>、<code>protocolname</code>。</p>
<p><code>socket.ntohl</code>(<em>x</em>)</p>
<p>将 32 位正整数从网络字节序转换为主机字节序。在主机字节序与网络字节序相同的计算机上，这是一个空操作。字节序不同将执行 4 字节交换操作。</p>
<p><code>socket.ntohs</code>(<em>x</em>)</p>
<p>将 16 位正整数从网络字节序转换为主机字节序。在主机字节序与网络字节序相同的计算机上，这是一个空操作。字节序不同将执行 2 字节交换操作。</p>
<p>在 3.10 版更改: 如果 <em>x</em> 不能转为 16 位无符号整数则会引发 <code>OverflowError</code>。</p>
<p><code>socket.htonl</code>(<em>x</em>)</p>
<p>将 32 位正整数从主机字节序转换为网络字节序。在主机字节序与网络字节序相同的计算机上，这是一个空操作。字节序不同将执行 4 字节交换操作。</p>
<p><code>socket.htons</code>(<em>x</em>)</p>
<p>将 16 位正整数从主机字节序转换为网络字节序。在主机字节序与网络字节序相同的计算机上，这是一个空操作。字节序不同将执行 2 字节交换操作。</p>
<p>在 3.10 版更改: 如果 <em>x</em> 不能转为 16 位无符号整数则会引发 <code>OverflowError</code>。</p>
<p><code>socket.inet_aton</code>(<em>ip_string</em>)</p>
<p>将 IPv4 地址从点分十进制字符串格式（如 ‘123.45.67.89’ ）转换为 32 位压缩二进制格式，转换后为字节对象，长度为四个字符。与那些使用标准 C 库，且需要 <em>struct</em> in_addr 类型的对象的程序交换信息时，此功能很有用。 该类型即此函数返回的 32 位压缩二进制的 C 类型。</p>
<p><code>inet_aton()</code> 也接受句点数少于三的字符串</p>
<p>如果传入本函数的 IPv4 地址字符串无效，则抛出 <code>OSError</code>。注意，具体什么样的地址有效取决于 <code>inet_aton()</code> 的底层 C 实现。</p>
<p><code>inet_aton()</code> 不支持 IPv6，在 IPv4/v6 双协议栈下应使用 <code>inet_pton()</code> 来代替。</p>
<p><code>socket.inet_ntoa</code>(<em>packed_ip</em>)</p>
<p>将 32 位压缩 IPv4 地址（一个 类字节对象，长 4 个字节）转换为标准的点分十进制字符串形式（如 ‘123.45.67.89’ ）。与那些使用标准 C 库，且需要 <em>struct</em> in_addr 类型的对象的程序交换信息时，本函数很有用。 该类型即是本函数参数中的 32 位压缩二进制数据的 C 类型。</p>
<p>如果传入本函数的字节序列长度不是 4 个字节，则抛出 <code>OSError</code>。<code>inet_ntoa()</code> 不支持 IPv6，在 IPv4/v6 双协议栈下应使用 <code>inet_ntop()</code> 来代替。</p>
<p>在 3.5 版更改: 现在接受可写的 字节类对象。</p>
<p><code>socket.inet_pton</code>(<em>address_family</em>, <em>ip_string</em>)</p>
<p>将特定地址簇的 IP 地址（字符串）转换为压缩二进制格式。当库或网络协议需要接受 <em>struct</em> in_addr 类型的对象（类似 <code>inet_aton()</code> ）或 <em>struct</em> in6_addr 类型的对象时，<code>inet_pton()</code> 很有用。</p>
<p>目前 <em>address_family</em> 支持 <code>AF_INET</code> 和 <code>AF_INET6</code>。如果 IP 地址字符串 <em>ip_string</em> 无效，则抛出 <code>OSError</code>。注意，具体什么地址有效取决于 <em>address_family</em> 的值和 <code>inet_pton()</code> 的底层实现。</p>
<p>可用性： Unix（可能非所有平台都可用）、Windows。</p>
<p>在 3.4 版更改: 添加了 Windows 支持</p>
<p><code>socket.inet_ntop</code>(<em>address_family</em>, <em>packed_ip</em>)</p>
<p>将压缩 IP 地址（一个 类字节对象，数个字节长）转换为标准的、特定地址簇的字符串形式（如 <code>'7.10.0.5'</code> 或 <code>'5aef:2b::8'</code> ）。当库或网络协议返回 <em>struct</em> in_addr 类型的对象（类似 <code>inet_ntoa()</code> ）或 <em>struct</em> in6_addr 类型的对象时，<code>inet_ntop()</code> 很有用。</p>
<p>目前 <em>address_family</em> 支持 <code>AF_INET</code> 和 <code>AF_INET6</code>。如果字节对象 <em>packed_ip</em> 与指定的地址簇长度不符，则抛出 <code>ValueError</code>。针对 <code>inet_ntop()</code> 调用的错误则抛出 <code>OSError</code>。</p>
<p>可用性： Unix（可能非所有平台都可用）、Windows。</p>
<p>在 3.4 版更改: 添加了 Windows 支持</p>
<p>在 3.5 版更改: 现在接受可写的 字节类对象。</p>
<p><code>socket.CMSG_LEN</code>(<em>length</em>)</p>
<p>返回给定 <em>length</em> 所关联数据的辅助数据项的总长度（不带尾部填充）。此值通常用作 <code>recvmsg()</code> 接收一个辅助数据项的缓冲区大小，但是 <a href="https://tools.ietf.org/html/rfc3542.html" target="_blank" rel="noopener"><strong>RFC 3542</strong></a> 要求可移植应用程序使用 <code>CMSG_SPACE()</code>，以此将尾部填充的空间计入，即使该项在缓冲区的最后。如果 <em>length</em> 超出允许范围，则抛出 <code>OverflowError</code>。</p>
<p>可用性： 大多数 Unix 平台，其他平台也可能可用。</p>
<p>3.3 新版功能.</p>
<p><code>socket.CMSG_SPACE</code>(<em>length</em>)</p>
<p>返回 <code>recvmsg()</code> 所需的缓冲区大小，以接收给定 <em>length</em> 所关联数据的辅助数据项，带有尾部填充。接收多个项目所需的缓冲区空间是关联数据长度的 <code>CMSG_SPACE()</code> 值的总和。如果 <em>length</em> 超出允许范围，则抛出 <code>OverflowError</code>。</p>
<p>请注意，某些系统可能支持辅助数据，但不提供本函数。还需注意，如果使用本函数的结果来设置缓冲区大小，可能无法精确限制可接收的辅助数据量，因为可能会有其他数据写入尾部填充区域。</p>
<p>可用性： 大多数 Unix 平台，其他平台也可能可用。</p>
<p>3.3 新版功能.</p>
<p><code>socket.getdefaulttimeout</code>()</p>
<p>返回用于新套接字对象的默认超时（以秒为单位的浮点数）。值 <code>None</code> 表示新套接字对象没有超时。首次导入 socket 模块时，默认值为 <code>None</code>。</p>
<p><code>socket.setdefaulttimeout</code>(<em>timeout</em>)</p>
<p>设置用于新套接字对象的默认超时（以秒为单位的浮点数）。首次导入 socket 模块时，默认值为 <code>None</code>。可能的取值及其各自的含义请参阅 <code>settimeout()</code>。</p>
<p><code>socket.sethostname</code>(<em>name</em>)</p>
<p>将计算机的主机名设置为 <em>name</em>。如果权限不足将抛出 <code>OSError</code>。</p>
<p>引发一个 审计事件 <code>socket.sethostname</code>，附带参数 <code>name</code>。</p>
<p>可用性: Unix。</p>
<p>3.3 新版功能.</p>
<p><code>socket.if_nameindex</code>()</p>
<p>返回一个列表，包含网络接口（网卡）信息二元组（整数索引，名称字符串）。系统调用失败则抛出 <code>OSError</code>。</p>
<p>可用性: Unix, Windows。</p>
<p>3.3 新版功能.</p>
<p>在 3.8 版更改: 添加了 Windows 支持。</p>
<p>注解</p>
<p>在 Windows 中网络接口在不同上下文中具有不同的名称（所有名称见对应示例）:</p>
<ul>
<li>UUID: <code>{FB605B73-AAC2-49A6-9A2F-25416AEA0573}</code></li>
<li>名称: <code>ethernet_32770</code></li>
<li>友好名称: <code>vEthernet (nat)</code></li>
<li>描述: <code>Hyper-V Virtual Ethernet Adapter</code></li>
</ul>
<p>此函数返回列表中第二种形式的名称，在此示例中为 <code>ethernet_32770</code>。</p>
<p><code>socket.if_nametoindex</code>(<em>if_name</em>)</p>
<p>返回网络接口名称相对应的索引号。如果没有所给名称的接口，则抛出 <code>OSError</code>。</p>
<p>可用性: Unix, Windows。</p>
<p>3.3 新版功能.</p>
<p>在 3.8 版更改: 添加了 Windows 支持。</p>
<p>参见</p>
<p>“Interface name” 为 <code>if_nameindex()</code> 中所描述的名称。</p>
<p><code>socket.if_indextoname</code>(<em>if_index</em>)</p>
<p>返回网络接口索引号相对应的接口名称。如果没有所给索引号的接口，则抛出 <code>OSError</code>。</p>
<p>可用性: Unix, Windows。</p>
<p>3.3 新版功能.</p>
<p>在 3.8 版更改: 添加了 Windows 支持。</p>
<p>参见</p>
<p>“Interface name” 为 <code>if_nameindex()</code> 中所描述的名称。</p>
<p><code>socket.send_fds</code>(<em>sock</em>, <em>buffers</em>, <em>fds</em>[, <em>flags</em>[, <em>address</em>]])</p>
<p>将文件描述符列表 <em>fds</em> 通过一个 <code>AF_UNIX</code> 套接字 <em>sock</em> 进行发送。 <em>fds</em> 形参是由文件描述符构成的序列。 请查看 <code>sendmsg()</code> 获取这些形参的文档。</p>
<p>可用性: 支持 <code>sendmsg()</code> 和 <code>SCM_RIGHTS</code> 机制的 Unix 系统。</p>
<p>3.9 新版功能.</p>
<p><code>socket.recv_fds</code>(<em>sock</em>, <em>bufsize</em>, <em>maxfds</em>[, <em>flags</em>])</p>
<p>接收至多 <em>maxfds</em> 个来自 <code>AF_UNIX</code> 套接字 <em>sock</em> 的文件描述符。 返回 <code>(msg, list(fds), flags, addr)</code>。 请查看 <code>recvmsg()</code> 获取有些形参的文档。</p>
<p>可用性: 支持 <code>recvmsg()</code> 和 <code>SCM_RIGHTS</code> 机制的 Unix 系统。</p>
<p>3.9 新版功能.</p>
<p>注解</p>
<p>位于文件描述符列表末尾的任何被截断整数。</p>
<h3 id="套接字对象"><a href="#套接字对象" class="headerlink" title="套接字对象"></a>套接字对象</h3><p>套接字对象具有以下方法。除了 <code>makefile()</code>，其他都与套接字专用的 Unix 系统调用相对应。</p>
<p>在 3.2 版更改: 添加了对 上下文管理器 协议的支持。退出上下文管理器与调用 <code>close()</code> 等效。</p>
<p><code>socket.accept</code>()</p>
<p>接受一个连接。此 socket 必须绑定到一个地址上并且监听连接。返回值是一个 <code>(conn, address)</code> 对，其中 <em>conn</em> 是一个 <em>新</em> 的套接字对象，用于在此连接上收发数据，<em>address</em> 是连接另一端的套接字所绑定的地址。</p>
<p>新创建的套接字是 不可继承的。</p>
<p>在 3.4 版更改: 该套接字现在是不可继承的。</p>
<p>在 3.5 版更改: 如果系统调用被中断，但信号处理程序没有触发异常，此方法现在会重试系统调用，而不是触发 <code>InterruptedError</code> 异常 (原因详见 <a href="https://www.python.org/dev/peps/pep-0475" target="_blank" rel="noopener"><strong>PEP 475</strong></a>)。</p>
<p><code>socket.bind</code>(<em>address</em>)</p>
<p>将套接字绑定到 <em>address*。套接字必须尚未绑定。（ *address</em> 的格式取决于地址簇 —— 参见上文）</p>
<p>引发一个 审计事件 <code>socket.bind</code>，附带参数 <code>self</code>、<code>address</code>。</p>
<p><code>socket.close</code>()</p>
<p>将套接字标记为关闭。当 <code>makefile()</code> 创建的所有文件对象都关闭时，底层系统资源（如文件描述符）也将关闭。一旦上述情况发生，将来对套接字对象的所有操作都会失败。对端将接收不到任何数据（清空队列数据后）。</p>
<p>垃圾回收时，套接字会自动关闭，但建议显式 <code>close()</code> 它们，或在它们周围使用 <code>with</code> 语句。</p>
<p>在 3.6 版更改: 现在，如果底层的 <code>close()</code> 调用出错，会抛出 <code>OSError</code>。</p>
<p>注解</p>
<p><code>close()</code> 释放与连接相关联的资源，但不一定立即关闭连接。如果需要及时关闭连接，请在调用 <code>close()</code> 之前调用 <code>shutdown()</code>。</p>
<p><code>socket.connect</code>(<em>address</em>)</p>
<p>连接到 <em>address</em> 处的远程套接字。（ <em>address</em> 的格式取决于地址簇 —— 参见上文）</p>
<p>如果连接被信号中断，则本方法将等待直至连接完成，或者如果信号处理句柄未引发异常并且套接字被阻塞或已超时则会在超时后引发 <code>TimeoutError</code>。 对于非阻塞型套接字，如果连接被信号中断则本方法将引发 <code>InterruptedError</code> 异常（或信号处理句柄所引发的异常）。</p>
<p>引发一个 审计事件 <code>socket.connect</code>，附带参数 <code>self</code>、<code>address</code>。</p>
<p>在 3.5 版更改: 本方法现在将等待，直到连接完成，而不是在以下情况抛出 <code>InterruptedError</code> 异常。该情况为，连接被信号中断，信号处理程序未抛出异常，且套接字阻塞中或已超时（具体解释请参阅 <a href="https://www.python.org/dev/peps/pep-0475" target="_blank" rel="noopener"><strong>PEP 475</strong></a> ）。</p>
<p><code>socket.connect_ex</code>(<em>address</em>)</p>
<p>类似于 <code>connect(address)</code>，但是对于 C 级别的 <code>connect()</code> 调用返回的错误，本函数将返回错误指示器，而不是抛出异常（对于其他问题，如“找不到主机”，仍然可以抛出异常）。如果操作成功，则错误指示器为 <code>0</code>，否则为 <code>errno</code> 变量的值。这对支持如异步连接很有用。</p>
<p>引发一个 审计事件 <code>socket.connect</code>，附带参数 <code>self</code>、<code>address</code>。</p>
<p><code>socket.detach</code>()</p>
<p>将套接字对象置于关闭状态，而底层的文件描述符实际并不关闭。返回该文件描述符，使其可以重新用于其他目的。</p>
<p>3.2 新版功能.</p>
<p><code>socket.dup</code>()</p>
<p>创建套接字的副本。</p>
<p>新创建的套接字是 不可继承的。</p>
<p>在 3.4 版更改: 该套接字现在是不可继承的。</p>
<p><code>socket.fileno</code>()</p>
<p>返回套接字的文件描述符（一个小整数），失败返回 -1。配合 <code>select.select()</code> 使用很有用。</p>
<p>在 Windows 下，此方法返回的小整数在允许使用文件描述符的地方无法使用（如 <code>os.fdopen()</code> ）。Unix 无此限制。</p>
<p><code>socket.get_inheritable</code>()</p>
<p>获取套接字文件描述符或套接字句柄的 可继承标志 ：如果子进程可以继承套接字则为 <code>True</code>，否则为 <code>False</code>。</p>
<p>3.4 新版功能.</p>
<p><code>socket.getpeername</code>()</p>
<p>返回套接字连接到的远程地址。举例而言，这可以用于查找远程 IPv4/v6 套接字的端口号。（返回的地址格式取决于地址簇 —— 参见上文。）部分系统不支持此函数。</p>
<p><code>socket.getsockname</code>()</p>
<p>返回套接字本身的地址。举例而言，这可以用于查找 IPv4/v6 套接字的端口号。（返回的地址格式取决于地址簇 —— 参见上文。）</p>
<p><code>socket.getsockopt</code>(<em>level</em>, <em>optname</em>[, <em>buflen</em>])</p>
<p>返回指定套接字选项的值（参阅 Unix 手册页 <em><a href="https://manpages.debian.org/getsockopt(2)" target="_blank" rel="noopener">getsockopt(2)</a></em> ）。所需的符号常量（ <code>SO_*</code> 等）已定义在本模块中。如果未指定 <em>buflen</em>，则认为该选项值为整数，由本函数返回该整数值。如果指定 <em>buflen</em>，则它定义了用于存放选项值的缓冲区的最大长度，且该缓冲区将作为字节对象返回。对缓冲区的解码工作由调用者自行完成（针对编码为字节串的 C 结构，其解码方法请参阅可选的内置模块 <code>struct</code> ）。</p>
<p><code>socket.getblocking</code>()</p>
<p>如果套接字处于阻塞模式，返回 <code>True</code>，非阻塞模式返回 <code>False</code>。</p>
<p>这相当于检测 <code>socket.gettimeout() == 0</code>。</p>
<p>3.7 新版功能.</p>
<p><code>socket.gettimeout</code>()</p>
<p>返回套接字操作相关的超时秒数（浮点数），未设置超时则返回 <code>None</code>。它反映最后一次调用 <code>setblocking()</code> 或 <code>settimeout()</code> 后的设置。</p>
<p><code>socket.ioctl</code>(<em>control</em>, <em>option</em>)</p>
<ul>
<li><p>平台</p>
<p>Windows</p>
</li>
</ul>
<p><code>ioctl()</code> 方法是 WSAIoctl 系统接口的有限接口。请参考 <a href="https://msdn.microsoft.com/en-us/library/ms741621(VS.85).aspx" target="_blank" rel="noopener">Win32 文档</a> 以获取更多信息。</p>
<p>在其他平台上，可以使用通用的 <code>fcntl.fcntl()</code> 和 <code>fcntl.ioctl()</code> 函数，它们接受套接字对象作为第一个参数。</p>
<p>当前仅支持以下控制码： <code>SIO_RCVALL</code>、<code>SIO_KEEPALIVE_VALS</code> 和 <code>SIO_LOOPBACK_FAST_PATH</code>。</p>
<p>在 3.6 版更改: 添加了 <code>SIO_LOOPBACK_FAST_PATH</code>。</p>
<p><code>socket.listen</code>([<em>backlog</em>])</p>
<p>启动一个服务器用于接受连接。如果指定 <em>backlog</em>，则它最低为 0（小于 0 会被置为 0），它指定系统允许暂未 accept 的连接数，超过后将拒绝新连接。未指定则自动设为合理的默认值。</p>
<p>在 3.5 版更改: <em>backlog</em> 参数现在是可选的。</p>
<p><code>socket.makefile</code>(<em>mode=’r’</em>, <em>buffering=None</em>, <em>**,</em> encoding=None<em>,</em> errors=None<em>,</em> newline=None*)</p>
<p>返回与套接字关联的 文件对象。返回的对象的具体类型取决于 <code>makefile()</code> 的参数。这些参数的解释方式与内置的 <code>open()</code> 函数相同，其中 <em>mode</em> 的值仅支持 <code>'r'</code> （默认），<code>'w'</code> 和 <code>'b'</code>。</p>
<p>套接字必须处于阻塞模式，它可以有超时，但是如果发生超时，文件对象的内部缓冲区可能会以不一致的状态结尾。</p>
<p>关闭 <code>makefile()</code> 返回的文件对象不会关闭原始套接字，除非所有其他文件对象都已关闭且在套接字对象上调用了 <code>socket.close()</code>。</p>
<p>注解</p>
<p>在 Windows 上，由 <code>makefile()</code> 创建的文件类对象无法作为带文件描述符的文件对象使用，如无法作为 <code>subprocess.Popen()</code> 的流参数。</p>
<p><code>socket.recv</code>(<em>bufsize</em>[, <em>flags</em>])</p>
<p>从套接字接收数据。返回值是一个字节对象，表示接收到的数据。<em>bufsize</em> 指定一次接收的最大数据量。可选参数 <em>flags</em> 的含义请参阅 Unix 手册页 *<a href="https://manpages.debian.org/recv(2)" target="_blank" rel="noopener">recv(2)</a>*，它默认为零。</p>
<p>注解</p>
<p>为了最佳匹配硬件和网络的实际情况，<em>bufsize</em> 的值应为 2 的相对较小的幂，如 4096。</p>
<p>在 3.5 版更改: 如果系统调用被中断，但信号处理程序没有触发异常，此方法现在会重试系统调用，而不是触发 <code>InterruptedError</code> 异常 (原因详见 <a href="https://www.python.org/dev/peps/pep-0475" target="_blank" rel="noopener"><strong>PEP 475</strong></a>)。</p>
<p><code>socket.recvfrom</code>(<em>bufsize</em>[, <em>flags</em>])</p>
<p>从套接字接收数据。返回值是一对 <code>(bytes, address)</code>，其中 <em>bytes</em> 是字节对象，表示接收到的数据，<em>address</em> 是发送端套接字的地址。可选参数 <em>flags</em> 的含义请参阅 Unix 手册页 <em><a href="https://manpages.debian.org/recv(2)" target="_blank" rel="noopener">recv(2)</a>*，它默认为零。（ *address</em> 的格式取决于地址簇 —— 参见上文）</p>
<p>在 3.5 版更改: 如果系统调用被中断，但信号处理程序没有触发异常，此方法现在会重试系统调用，而不是触发 <code>InterruptedError</code> 异常 (原因详见 <a href="https://www.python.org/dev/peps/pep-0475" target="_blank" rel="noopener"><strong>PEP 475</strong></a>)。</p>
<p>在 3.7 版更改: 对于多播 IPv6 地址，<em>address</em> 的第一项不会再包含 <code>%scope_id</code> 部分。 要获得完整的 IPv6 地址请使用 <code>getnameinfo()</code>。</p>
<p><code>socket.recvmsg</code>(<em>bufsize</em>[, <em>ancbufsize</em>[, <em>flags</em>]])</p>
<p>从套接字接收普通数据（至多 <em>bufsize</em> 字节）和辅助数据。<em>ancbufsize</em> 参数设置用于接收辅助数据的内部缓冲区的大小（以字节为单位），默认为 0，表示不接收辅助数据。可以使用 <code>CMSG_SPACE()</code> 或 <code>CMSG_LEN()</code> 计算辅助数据缓冲区的合适大小，无法放入缓冲区的项目可能会被截断或丢弃。<em>flags</em> 参数默认为 0，其含义与 <code>recv()</code> 中的相同。</p>
<p>返回值是一个四元组： <code>(data, ancdata, msg_flags, address)</code>。<em>data</em> 项是一个 <code>bytes</code> 对象，用于保存接收到的非辅助数据。<em>ancdata</em> 项是零个或多个元组 <code>(cmsg_level, cmsg_type, cmsg_data)</code> 组成的列表，表示接收到的辅助数据（控制消息）：<em>cmsg_level</em> 和 <em>cmsg_type</em> 是分别表示协议级别和协议类型的整数，而 <em>cmsg_data</em> 是保存相关数据的 <code>bytes</code> 对象。<em>msg_flags</em> 项由各种标志按位或组成，表示接收消息的情况，详细信息请参阅系统文档。如果接收端套接字断开连接，则 <em>address</em> 是发送端套接字的地址（如果有），否则该值无指定。</p>
<p>某些系统上可以利用 <code>AF_UNIX</code> 套接字通过 <code>sendmsg()</code> 和 <code>recvmsg()</code> 在进程之间传递文件描述符。使用此功能时（通常仅限于 <code>SOCK_STREAM</code> 套接字），<code>recvmsg()</code> 将在其辅助数据中返回以下格式的项 <code>(socket.SOL_SOCKET, socket.SCM_RIGHTS, fds)</code>，其中 <em>fds</em> 是一个 <code>bytes</code> 对象，是新文件描述符表示为原生 C int 类型的二进制数组。如果 <code>recvmsg()</code> 在系统调用返回后抛出异常，它将首先关闭此机制接收到的所有文件描述符。</p>
<p>对于仅接收到一部分的辅助数据项，一些系统没有指示其截断长度。如果某个项目可能超出了缓冲区的末尾，<code>recvmsg()</code> 将发出 <code>RuntimeWarning</code>，并返回其在缓冲区内的部分，前提是该对象被截断于关联数据开始后。</p>
<p>在支持 <code>SCM_RIGHTS</code> 机制的系统上，下方的函数将最多接收 <em>maxfds</em> 个文件描述符，返回消息数据和包含描述符的列表（同时忽略意外情况，如接收到无关的控制消息）。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> socket<span class="token punctuation">,</span> array
<span class="token keyword">def</span> <span class="token function">recv_fds</span><span class="token punctuation">(</span>sock<span class="token punctuation">,</span> msglen<span class="token punctuation">,</span> maxfds<span class="token punctuation">)</span><span class="token punctuation">:</span>
    fds <span class="token operator">=</span> array<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token string">"i"</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true"># Array of ints</span>
    msg<span class="token punctuation">,</span> ancdata<span class="token punctuation">,</span> flags<span class="token punctuation">,</span> addr <span class="token operator">=</span> sock<span class="token punctuation">.</span>recvmsg<span class="token punctuation">(</span>msglen<span class="token punctuation">,</span> socket<span class="token punctuation">.</span>CMSG_LEN<span class="token punctuation">(</span>maxfds <span class="token operator">*</span> fds<span class="token punctuation">.</span>itemsize<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">for</span> cmsg_level<span class="token punctuation">,</span> cmsg_type<span class="token punctuation">,</span> cmsg_data <span class="token keyword">in</span> ancdata<span class="token punctuation">:</span>
        <span class="token keyword">if</span> cmsg_level <span class="token operator">==</span> socket<span class="token punctuation">.</span>SOL_SOCKET <span class="token operator">and</span> cmsg_type <span class="token operator">==</span> socket<span class="token punctuation">.</span>SCM_RIGHTS<span class="token punctuation">:</span>
            <span class="token comment" spellcheck="true"># Append data, ignoring any truncated integers at the end.</span>
            fds<span class="token punctuation">.</span>frombytes<span class="token punctuation">(</span>cmsg_data<span class="token punctuation">[</span><span class="token punctuation">:</span>len<span class="token punctuation">(</span>cmsg_data<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token punctuation">(</span>len<span class="token punctuation">(</span>cmsg_data<span class="token punctuation">)</span> <span class="token operator">%</span> fds<span class="token punctuation">.</span>itemsize<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> msg<span class="token punctuation">,</span> list<span class="token punctuation">(</span>fds<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可用性： 大多数 Unix 平台，其他平台也可能可用。</p>
<p>3.3 新版功能.</p>
<p>在 3.5 版更改: 如果系统调用被中断，但信号处理程序没有触发异常，此方法现在会重试系统调用，而不是触发 <code>InterruptedError</code> 异常 (原因详见 <a href="https://www.python.org/dev/peps/pep-0475" target="_blank" rel="noopener"><strong>PEP 475</strong></a>)。</p>
<p><code>socket.recvmsg_into</code>(<em>buffers</em>[, <em>ancbufsize</em>[, <em>flags</em>]])</p>
<p>从套接字接收普通数据和辅助数据，其行为与 <code>recvmsg()</code> 相同，但将非辅助数据分散到一系列缓冲区中，而不是返回新的字节对象。<em>buffers</em> 参数必须是可迭代对象，它迭代出可供写入的缓冲区（如 <code>bytearray</code> 对象），这些缓冲区将被连续的非辅助数据块填充，直到数据全部写完或缓冲区用完为止。在允许使用的缓冲区数量上，操作系统可能会有限制（ <code>sysconf()</code> 的 <code>SC_IOV_MAX</code> 值）。<em>ancbufsize</em> 和 <em>flags</em> 参数的含义与 <code>recvmsg()</code> 中的相同。</p>
<p>返回值为四元组： <code>(nbytes, ancdata, msg_flags, address)</code>，其中 <em>nbytes</em> 是写入缓冲区的非辅助数据的字节总数，而 <em>ancdata<em>、</em>msg_flags</em> 和 <em>address</em> 与 <code>recvmsg()</code> 中的相同。</p>
<p>示例:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> socket
<span class="token operator">>></span><span class="token operator">></span> s1<span class="token punctuation">,</span> s2 <span class="token operator">=</span> socket<span class="token punctuation">.</span>socketpair<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> b1 <span class="token operator">=</span> bytearray<span class="token punctuation">(</span>b<span class="token string">'----'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> b2 <span class="token operator">=</span> bytearray<span class="token punctuation">(</span>b<span class="token string">'0123456789'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> b3 <span class="token operator">=</span> bytearray<span class="token punctuation">(</span>b<span class="token string">'--------------'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> s1<span class="token punctuation">.</span>send<span class="token punctuation">(</span>b<span class="token string">'Mary had a little lamb'</span><span class="token punctuation">)</span>
<span class="token number">22</span>
<span class="token operator">>></span><span class="token operator">></span> s2<span class="token punctuation">.</span>recvmsg_into<span class="token punctuation">(</span><span class="token punctuation">[</span>b1<span class="token punctuation">,</span> memoryview<span class="token punctuation">(</span>b2<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">,</span> b3<span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token number">22</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> None<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token punctuation">[</span>b1<span class="token punctuation">,</span> b2<span class="token punctuation">,</span> b3<span class="token punctuation">]</span>
<span class="token punctuation">[</span>bytearray<span class="token punctuation">(</span>b<span class="token string">'Mary'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> bytearray<span class="token punctuation">(</span>b<span class="token string">'01 had a 9'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> bytearray<span class="token punctuation">(</span>b<span class="token string">'little lamb---'</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可用性： 大多数 Unix 平台，其他平台也可能可用。</p>
<p>3.3 新版功能.</p>
<p><code>socket.recvfrom_into</code>(<em>buffer</em>[, <em>nbytes</em>[, <em>flags</em>]])</p>
<p>从套接字接收数据，将其写入 <em>buffer</em> 而不是创建新的字节串。返回值是一对 <code>(nbytes, address)</code>，其中 <em>nbytes</em> 是收到的字节数，<em>address</em> 是发送端套接字的地址。可选参数 <em>flags</em> 的含义请参阅 Unix 手册页 <em><a href="https://manpages.debian.org/recv(2)" target="_blank" rel="noopener">recv(2)</a>*，它默认为零。（ *address</em> 的格式取决于地址簇 —— 参见上文）</p>
<p><code>socket.recv_into</code>(<em>buffer</em>[, <em>nbytes</em>[, <em>flags</em>]])</p>
<p>从套接字接收至多 <em>nbytes</em> 个字节，将其写入缓冲区而不是创建新的字节串。如果 <em>nbytes</em> 未指定（或指定为 0），则接收至所给缓冲区的最大可用大小。返回接收到的字节数。可选参数 <em>flags</em> 的含义请参阅 Unix 手册页 *<a href="https://manpages.debian.org/recv(2)" target="_blank" rel="noopener">recv(2)</a>*，它默认为零。</p>
<p><code>socket.send</code>(<em>bytes</em>[, <em>flags</em>])</p>
<p>发送数据给套接字。本套接字必须已连接到远程套接字。可选参数 <em>flags</em> 的含义与上述 <code>recv()</code> 中的相同。本方法返回已发送的字节数。应用程序要负责检查所有数据是否已发送，如果仅传输了部分数据，程序需要自行尝试传输其余数据。</p>
<p>在 3.5 版更改: 如果系统调用被中断，但信号处理程序没有触发异常，此方法现在会重试系统调用，而不是触发 <code>InterruptedError</code> 异常 (原因详见 <a href="https://www.python.org/dev/peps/pep-0475" target="_blank" rel="noopener"><strong>PEP 475</strong></a>)。</p>
<p><code>socket.sendall</code>(<em>bytes</em>[, <em>flags</em>])</p>
<p>发送数据给套接字。本套接字必须已连接到远程套接字。可选参数 <em>flags</em> 的含义与上述 <code>recv()</code> 中的相同。与 <code>send()</code> 不同，本方法持续从 <em>bytes</em> 发送数据，直到所有数据都已发送或发生错误为止。成功后会返回 <code>None</code>。出错后会抛出一个异常，此时并没有办法确定成功发送了多少数据。</p>
<p>在 3.5 版更改: 每次成功发送数据后，套接字超时不再重置。现在，套接字超时是发送所有数据的最大总持续时间。</p>
<p>在 3.5 版更改: 如果系统调用被中断，但信号处理程序没有触发异常，此方法现在会重试系统调用，而不是触发 <code>InterruptedError</code> 异常 (原因详见 <a href="https://www.python.org/dev/peps/pep-0475" target="_blank" rel="noopener"><strong>PEP 475</strong></a>)。</p>
<p><code>socket.sendto</code>(<em>bytes</em>, <em>address</em>)</p>
<p><code>socket.sendto</code>(<em>bytes</em>, <em>flags</em>, <em>address</em>)</p>
<p>发送数据给套接字。本套接字不应连接到远程套接字，而应由 <em>address</em> 指定目标套接字。可选参数 <em>flags</em> 的含义与上述 <code>recv()</code> 中的相同。本方法返回已发送的字节数。（ <em>address</em> 的格式取决于地址簇 —— 参见上文。）</p>
<p>引发一个 审计事件 <code>socket.sendto</code>，附带参数 <code>self</code>、<code>address</code>。</p>
<p>在 3.5 版更改: 如果系统调用被中断，但信号处理程序没有触发异常，此方法现在会重试系统调用，而不是触发 <code>InterruptedError</code> 异常 (原因详见 <a href="https://www.python.org/dev/peps/pep-0475" target="_blank" rel="noopener"><strong>PEP 475</strong></a>)。</p>
<p><code>socket.sendmsg</code>(<em>buffers</em>[, <em>ancdata</em>[, <em>flags</em>[, <em>address</em>]]])</p>
<p>将普通数据和辅助数据发送给套接字，将从一系列缓冲区中收集非辅助数据，并将其拼接为一条消息。<em>buffers</em> 参数指定的非辅助数据应为可迭代的 字节类对象 （如 <code>bytes</code> 对象），在允许使用的缓冲区数量上，操作系统可能会有限制（ <code>sysconf()</code> 的 <code>SC_IOV_MAX</code> 值）。<em>ancdata</em> 参数指定的辅助数据（控制消息）应为可迭代对象，迭代出零个或多个 <code>(cmsg_level, cmsg_type, cmsg_data)</code> 元组，其中 <em>cmsg_level</em> 和 <em>cmsg_type</em> 是分别指定协议级别和协议类型的整数，而 <em>cmsg_data</em> 是保存相关数据的字节类对象。请注意，某些系统（特别是没有 <code>CMSG_SPACE()</code> 的系统）可能每次调用仅支持发送一条控制消息。<em>flags</em> 参数默认为 0，与 <code>send()</code> 中的含义相同。如果 <em>address</em> 指定为除 <code>None</code> 以外的值，它将作为消息的目标地址。返回值是已发送的非辅助数据的字节数。</p>
<p>在支持 <code>SCM_RIGHTS</code> 机制的系统上，下方的函数通过一个 <code>AF_UNIX</code> 套接字来发送文件描述符列表 <em>fds</em>。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> socket<span class="token punctuation">,</span> array
<span class="token keyword">def</span> <span class="token function">send_fds</span><span class="token punctuation">(</span>sock<span class="token punctuation">,</span> msg<span class="token punctuation">,</span> fds<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">return</span> sock<span class="token punctuation">.</span>sendmsg<span class="token punctuation">(</span><span class="token punctuation">[</span>msg<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">(</span>socket<span class="token punctuation">.</span>SOL_SOCKET<span class="token punctuation">,</span> socket<span class="token punctuation">.</span>SCM_RIGHTS<span class="token punctuation">,</span> array<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token string">"i"</span><span class="token punctuation">,</span> fds<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>可用性： 大多数 Unix 平台，其他平台也可能可用。</p>
<p>引发一个 审计事件 <code>socket.sendmsg</code>，附带参数 <code>self</code>、<code>address</code>。</p>
<p>3.3 新版功能.</p>
<p>在 3.5 版更改: 如果系统调用被中断，但信号处理程序没有触发异常，此方法现在会重试系统调用，而不是触发 <code>InterruptedError</code> 异常 (原因详见 <a href="https://www.python.org/dev/peps/pep-0475" target="_blank" rel="noopener"><strong>PEP 475</strong></a>)。</p>
<p><code>socket.sendmsg_afalg</code>([<em>msg</em>, ]<em>**,</em> op<em>[,</em> iv<em>[,</em> assoclen<em>[,</em> flags*]]])</p>
<p>为 <code>AF_ALG</code> 套接字定制的 <code>sendmsg()</code> 版本。可为 <code>AF_ALG</code> 套接字设置模式、IV、AEAD 关联数据的长度和标志位。</p>
<p>可用性： Linux &gt;= 2.6.38。</p>
<p>3.6 新版功能.</p>
<p><code>socket.sendfile</code>(<em>file</em>, <em>offset=0</em>, <em>count=None</em>)</p>
<p>使用高性能的 <code>os.sendfile</code> 发送文件，直到达到文件的 EOF 为止，返回已发送的字节总数。<em>file</em> 必须是一个以二进制模式打开的常规文件对象。如果 <code>os.sendfile</code> 不可用（如 Windows）或 <em>file</em> 不是常规文件，将使用 <code>send()</code> 代替。<em>offset</em> 指示从哪里开始读取文件。如果指定了 <em>count</em>，它确定了要发送的字节总数，而不会持续发送直到达到文件的 EOF。返回时或发生错误时，文件位置将更新，在这种情况下，<code>file.tell()</code> 可用于确定已发送的字节数。套接字必须为 <code>SOCK_STREAM</code> 类型。不支持非阻塞的套接字。</p>
<p>3.5 新版功能.</p>
<p><code>socket.set_inheritable</code>(<em>inheritable</em>)</p>
<p>设置套接字文件描述符或套接字句柄的 可继承标志。</p>
<p>3.4 新版功能.</p>
<p><code>socket.setblocking</code>(<em>flag</em>)</p>
<p>设置套接字为阻塞或非阻塞模式：如果 <em>flag</em> 为 false，则将套接字设置为非阻塞，否则设置为阻塞。</p>
<p>本方法是某些 <code>settimeout()</code> 调用的简写：</p>
<ul>
<li><code>sock.setblocking(True)</code> 相当于 <code>sock.settimeout(None)</code></li>
<li><code>sock.setblocking(False)</code> 相当于 <code>sock.settimeout(0.0)</code></li>
</ul>
<p>在 3.7 版更改: 本方法不再对 <code>socket.type</code> 属性设置 <code>SOCK_NONBLOCK</code> 标志。</p>
<p><code>socket.settimeout</code>(<em>value</em>)</p>
<p>为阻塞套接字的操作设置超时。<em>value</em> 参数可以是非负浮点数，表示秒，也可以是 <code>None</code>。如果赋为一个非零值，那么如果在操作完成前超过了超时时间 <em>value</em>，后续的套接字操作将抛出 <code>timeout</code> 异常。如果赋为 0，则套接字将处于非阻塞模式。如果指定为 <code>None</code>，则套接字将处于阻塞模式。</p>
<p>在 3.7 版更改: 本方法不再修改 <code>socket.type</code> 属性的 <code>SOCK_NONBLOCK</code> 标志。</p>
<p><code>socket.setsockopt</code>(<em>level</em>, <em>optname</em>, <em>value: int</em>)</p>
<p><code>socket.setsockopt</code>(<em>level</em>, <em>optname</em>, <em>value: buffer</em>)</p>
<p><code>socket.setsockopt</code>(<em>level</em>, <em>optname</em>, <em>None</em>, <em>optlen: int</em>)</p>
<p>设置给定套接字选项的值（参阅 Unix 手册页 <em><a href="https://manpages.debian.org/setsockopt(2)" target="_blank" rel="noopener">setsockopt(2)</a></em> ）。所需的符号常量（ <code>SO_*</code> 等）已定义在本 <code>socket</code> 模块中。该值可以是整数、<code>None</code> 或表示缓冲区的 字节类对象。在后一种情况下，由调用者确保字节串中包含正确的数据位（关于将 C 结构体编码为字节串的方法，请参阅可选的内置模块 <code>struct</code> ）。当 <em>value</em> 设置为 <code>None</code> 时，必须设置 <em>optlen</em> 参数。这相当于调用 <code>setsockopt()</code> C 函数时使用了 <code>optval=NULL</code> 和 <code>optlen=optlen</code> 参数。</p>
<p>在 3.5 版更改: 现在接受可写的 字节类对象。</p>
<p>在 3.6 版更改: 添加了 setsockopt(level, optname, None, optlen: int) 调用形式。</p>
<p><code>socket.shutdown</code>(<em>how</em>)</p>
<p>关闭一半或全部的连接。如果 <em>how</em> 为 <code>SHUT_RD</code>，则后续不再允许接收。如果 <em>how</em> 为 <code>SHUT_WR</code>，则后续不再允许发送。如果 <em>how</em> 为 <code>SHUT_RDWR</code>，则后续的发送和接收都不允许。</p>
<p><code>socket.share</code>(<em>process_id</em>)</p>
<p>复制套接字，并准备将其与目标进程共享。目标进程必须以 <em>process_id</em> 形式提供。然后可以利用某种形式的进程间通信，将返回的字节对象传递给目标进程，还可以使用 <code>fromshare()</code> 在新进程中重新创建套接字。一旦本方法调用完毕，就可以安全地将套接字关闭，因为操作系统已经为目标进程复制了该套接字。</p>
<p>可用性: Windows。</p>
<p>3.3 新版功能.</p>
<p>注意此处没有 <code>read()</code> 或 <code>write()</code> 方法，请使用不带 <em>flags</em> 参数的 <code>recv()</code> 和 <code>send()</code> 来替代。</p>
<p>套接字对象还具有以下（只读）属性，这些属性与传入 <code>socket</code> 构造函数的值相对应。</p>
<pre><code>socket.family</code></pre><p>套接字的协议簇。</p>
<pre><code>socket.type</code></pre><p>套接字的类型。</p>
<pre><code>socket.proto</code></pre><p>套接字的协议。</p>
<h3 id="关于套接字超时的说明"><a href="#关于套接字超时的说明" class="headerlink" title="关于套接字超时的说明"></a>关于套接字超时的说明</h3><p>一个套接字对象可以处于以下三种模式之一：阻塞、非阻塞或超时。套接字默认以阻塞模式创建，但是可以调用 <code>setdefaulttimeout()</code> 来更改。</p>
<ul>
<li>在 <em>blocking mode</em> （阻塞模式）中，操作将阻塞，直到操作完成或系统返回错误（如连接超时）。</li>
<li>在 <em>non-blocking mode</em> （非阻塞模式）中，如果操作无法立即完成，则操作将失败（不幸的是，不同系统返回的错误不同）：位于 <code>select</code> 中的函数可用于了解套接字何时以及是否可以读取或写入。</li>
<li>在 <em>timeout mode</em> （超时模式）下，如果无法在指定的超时内完成操作（抛出 <code>timeout</code> 异常），或如果系统返回错误，则操作将失败。</li>
</ul>
<p>注解</p>
<p>在操作系统层面上，<em>超时模式</em> 下的套接字在内部都设置为非阻塞模式。同时，阻塞和超时模式在文件描述符和套接字对象之间共享，这些描述符和对象均应指向同一个网络端点。如果，比如你决定使用套接字的 <code>fileno()</code>，这一实现细节可能导致明显的结果。</p>
<h4 id="超时与-connect-方法"><a href="#超时与-connect-方法" class="headerlink" title="超时与 connect 方法"></a>超时与 <code>connect</code> 方法</h4><p><code>connect()</code> 操作也受超时设置的约束，通常建议在调用 <code>connect()</code> 之前调用 <code>settimeout()</code>，或将超时参数直接传递给 <code>create_connection()</code>。但是，无论 Python 套接字超时设置如何，系统网络栈都有可能返回自带的连接超时错误。</p>
<h4 id="超时与-accept-方法"><a href="#超时与-accept-方法" class="headerlink" title="超时与 accept 方法"></a>超时与 <code>accept</code> 方法</h4><p>如果 <code>getdefaulttimeout()</code> 的值不是 <code>None</code>，则 <code>accept()</code> 方法返回的套接字将继承该超时值。若是 None，返回的套接字行为取决于侦听套接字的设置：</p>
<ul>
<li>如果侦听套接字处于 <em>阻塞模式</em> 或 <em>超时模式</em>，则 <code>accept()</code> 返回的套接字处于 <em>阻塞模式</em>；</li>
<li>如果侦听套接字处于 <em>非阻塞模式</em>，那么 <code>accept()</code> 返回的套接字是阻塞还是非阻塞取决于操作系统。如果要确保跨平台时的正确行为，建议手动覆盖此设置。</li>
</ul>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>以下是 4 个使用 TCP/IP 协议的最小示例程序：一台服务器，它将收到的所有数据原样返回（仅服务于一个客户端），还有一个使用该服务器的客户端。注意，服务器必须按序执行 <code>socket()</code>, <code>bind()</code>, <code>listen()</code>, <code>accept()</code> （可能需要重复执行 <code>accept()</code> 以服务多个客户端），而客户端仅需要按序执行 <code>socket()</code>, <code>connect()</code>。还须注意，服务器不在侦听套接字上发送 <code>sendall()</code>/<code>recv()</code>，而是在 <code>accept()</code> 返回的新套接字上发送。</p>
<p>前两个示例仅支持 IPv4。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Echo server program</span>
<span class="token keyword">import</span> socket
HOST <span class="token operator">=</span> <span class="token string">''</span>                 <span class="token comment" spellcheck="true"># Symbolic name meaning all available interfaces</span>
PORT <span class="token operator">=</span> <span class="token number">50007</span>              <span class="token comment" spellcheck="true"># Arbitrary non-privileged port</span>
<span class="token keyword">with</span> socket<span class="token punctuation">.</span>socket<span class="token punctuation">(</span>socket<span class="token punctuation">.</span>AF_INET<span class="token punctuation">,</span> socket<span class="token punctuation">.</span>SOCK_STREAM<span class="token punctuation">)</span> <span class="token keyword">as</span> s<span class="token punctuation">:</span>
    s<span class="token punctuation">.</span>bind<span class="token punctuation">(</span><span class="token punctuation">(</span>HOST<span class="token punctuation">,</span> PORT<span class="token punctuation">)</span><span class="token punctuation">)</span>
    s<span class="token punctuation">.</span>listen<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
    conn<span class="token punctuation">,</span> addr <span class="token operator">=</span> s<span class="token punctuation">.</span>accept<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">with</span> conn<span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Connected by'</span><span class="token punctuation">,</span> addr<span class="token punctuation">)</span>
        <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>
            data <span class="token operator">=</span> conn<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span>
            <span class="token keyword">if</span> <span class="token operator">not</span> data<span class="token punctuation">:</span> <span class="token keyword">break</span>
            conn<span class="token punctuation">.</span>sendall<span class="token punctuation">(</span>data<span class="token punctuation">)</span>

<span class="token comment" spellcheck="true"># Echo client program</span>
<span class="token keyword">import</span> socket
HOST <span class="token operator">=</span> <span class="token string">'daring.cwi.nl'</span>    <span class="token comment" spellcheck="true"># The remote host</span>
PORT <span class="token operator">=</span> <span class="token number">50007</span>              <span class="token comment" spellcheck="true"># The same port as used by the server</span>
<span class="token keyword">with</span> socket<span class="token punctuation">.</span>socket<span class="token punctuation">(</span>socket<span class="token punctuation">.</span>AF_INET<span class="token punctuation">,</span> socket<span class="token punctuation">.</span>SOCK_STREAM<span class="token punctuation">)</span> <span class="token keyword">as</span> s<span class="token punctuation">:</span>
    s<span class="token punctuation">.</span>connect<span class="token punctuation">(</span><span class="token punctuation">(</span>HOST<span class="token punctuation">,</span> PORT<span class="token punctuation">)</span><span class="token punctuation">)</span>
    s<span class="token punctuation">.</span>sendall<span class="token punctuation">(</span>b<span class="token string">'Hello, world'</span><span class="token punctuation">)</span>
    data <span class="token operator">=</span> s<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Received'</span><span class="token punctuation">,</span> repr<span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>下两个例子与上两个很像，但是同时支持 IPv4 和 IPv6。 服务端将监听第一个可用的地址族（它本应同时监听两个）。 在大多数支持 IPv6 的系统上，IPv6 将有优先权并且服务端可能不会接受 IPv4 流量。 客户端将尝试连接到作为名称解析结果被返回的所有地址，并将流量发送给连接成功的第一个地址。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Echo server program</span>
<span class="token keyword">import</span> socket
<span class="token keyword">import</span> sys
HOST <span class="token operator">=</span> None               <span class="token comment" spellcheck="true"># Symbolic name meaning all available interfaces</span>
PORT <span class="token operator">=</span> <span class="token number">50007</span>              <span class="token comment" spellcheck="true"># Arbitrary non-privileged port</span>
s <span class="token operator">=</span> None
<span class="token keyword">for</span> res <span class="token keyword">in</span> socket<span class="token punctuation">.</span>getaddrinfo<span class="token punctuation">(</span>HOST<span class="token punctuation">,</span> PORT<span class="token punctuation">,</span> socket<span class="token punctuation">.</span>AF_UNSPEC<span class="token punctuation">,</span>
                              socket<span class="token punctuation">.</span>SOCK_STREAM<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> socket<span class="token punctuation">.</span>AI_PASSIVE<span class="token punctuation">)</span><span class="token punctuation">:</span>
    af<span class="token punctuation">,</span> socktype<span class="token punctuation">,</span> proto<span class="token punctuation">,</span> canonname<span class="token punctuation">,</span> sa <span class="token operator">=</span> res
    <span class="token keyword">try</span><span class="token punctuation">:</span>
        s <span class="token operator">=</span> socket<span class="token punctuation">.</span>socket<span class="token punctuation">(</span>af<span class="token punctuation">,</span> socktype<span class="token punctuation">,</span> proto<span class="token punctuation">)</span>
    <span class="token keyword">except</span> OSError <span class="token keyword">as</span> msg<span class="token punctuation">:</span>
        s <span class="token operator">=</span> None
        <span class="token keyword">continue</span>
    <span class="token keyword">try</span><span class="token punctuation">:</span>
        s<span class="token punctuation">.</span>bind<span class="token punctuation">(</span>sa<span class="token punctuation">)</span>
        s<span class="token punctuation">.</span>listen<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token keyword">except</span> OSError <span class="token keyword">as</span> msg<span class="token punctuation">:</span>
        s<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>
        s <span class="token operator">=</span> None
        <span class="token keyword">continue</span>
    <span class="token keyword">break</span>
<span class="token keyword">if</span> s <span class="token keyword">is</span> None<span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'could not open socket'</span><span class="token punctuation">)</span>
    sys<span class="token punctuation">.</span>exit<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
conn<span class="token punctuation">,</span> addr <span class="token operator">=</span> s<span class="token punctuation">.</span>accept<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">with</span> conn<span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Connected by'</span><span class="token punctuation">,</span> addr<span class="token punctuation">)</span>
    <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>
        data <span class="token operator">=</span> conn<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span>
        <span class="token keyword">if</span> <span class="token operator">not</span> data<span class="token punctuation">:</span> <span class="token keyword">break</span>
        conn<span class="token punctuation">.</span>send<span class="token punctuation">(</span>data<span class="token punctuation">)</span>


<span class="token comment" spellcheck="true"># Echo client program</span>
<span class="token keyword">import</span> socket
<span class="token keyword">import</span> sys
HOST <span class="token operator">=</span> <span class="token string">'daring.cwi.nl'</span>    <span class="token comment" spellcheck="true"># The remote host</span>
PORT <span class="token operator">=</span> <span class="token number">50007</span>              <span class="token comment" spellcheck="true"># The same port as used by the server</span>
s <span class="token operator">=</span> None
<span class="token keyword">for</span> res <span class="token keyword">in</span> socket<span class="token punctuation">.</span>getaddrinfo<span class="token punctuation">(</span>HOST<span class="token punctuation">,</span> PORT<span class="token punctuation">,</span> socket<span class="token punctuation">.</span>AF_UNSPEC<span class="token punctuation">,</span> socket<span class="token punctuation">.</span>SOCK_STREAM<span class="token punctuation">)</span><span class="token punctuation">:</span>
    af<span class="token punctuation">,</span> socktype<span class="token punctuation">,</span> proto<span class="token punctuation">,</span> canonname<span class="token punctuation">,</span> sa <span class="token operator">=</span> res
    <span class="token keyword">try</span><span class="token punctuation">:</span>
        s <span class="token operator">=</span> socket<span class="token punctuation">.</span>socket<span class="token punctuation">(</span>af<span class="token punctuation">,</span> socktype<span class="token punctuation">,</span> proto<span class="token punctuation">)</span>
    <span class="token keyword">except</span> OSError <span class="token keyword">as</span> msg<span class="token punctuation">:</span>
        s <span class="token operator">=</span> None
        <span class="token keyword">continue</span>
    <span class="token keyword">try</span><span class="token punctuation">:</span>
        s<span class="token punctuation">.</span>connect<span class="token punctuation">(</span>sa<span class="token punctuation">)</span>
    <span class="token keyword">except</span> OSError <span class="token keyword">as</span> msg<span class="token punctuation">:</span>
        s<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>
        s <span class="token operator">=</span> None
        <span class="token keyword">continue</span>
    <span class="token keyword">break</span>
<span class="token keyword">if</span> s <span class="token keyword">is</span> None<span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'could not open socket'</span><span class="token punctuation">)</span>
    sys<span class="token punctuation">.</span>exit<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token keyword">with</span> s<span class="token punctuation">:</span>
    s<span class="token punctuation">.</span>sendall<span class="token punctuation">(</span>b<span class="token string">'Hello, world'</span><span class="token punctuation">)</span>
    data <span class="token operator">=</span> s<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Received'</span><span class="token punctuation">,</span> repr<span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>下面的例子演示了如何在 Windows 上使用原始套接字编写一个非常简单的网络嗅探器。 这个例子需要管理员权限来修改接口:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> socket
<span class="token comment" spellcheck="true"># the public network interface</span>
HOST <span class="token operator">=</span> socket<span class="token punctuation">.</span>gethostbyname<span class="token punctuation">(</span>socket<span class="token punctuation">.</span>gethostname<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment" spellcheck="true"># create a raw socket and bind it to the public interface</span>
s <span class="token operator">=</span> socket<span class="token punctuation">.</span>socket<span class="token punctuation">(</span>socket<span class="token punctuation">.</span>AF_INET<span class="token punctuation">,</span> socket<span class="token punctuation">.</span>SOCK_RAW<span class="token punctuation">,</span> socket<span class="token punctuation">.</span>IPPROTO_IP<span class="token punctuation">)</span>
s<span class="token punctuation">.</span>bind<span class="token punctuation">(</span><span class="token punctuation">(</span>HOST<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment" spellcheck="true"># Include IP headers</span>
s<span class="token punctuation">.</span>setsockopt<span class="token punctuation">(</span>socket<span class="token punctuation">.</span>IPPROTO_IP<span class="token punctuation">,</span> socket<span class="token punctuation">.</span>IP_HDRINCL<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>
<span class="token comment" spellcheck="true"># receive all packages</span>
s<span class="token punctuation">.</span>ioctl<span class="token punctuation">(</span>socket<span class="token punctuation">.</span>SIO_RCVALL<span class="token punctuation">,</span> socket<span class="token punctuation">.</span>RCVALL_ON<span class="token punctuation">)</span>
<span class="token comment" spellcheck="true"># receive a package</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>recvfrom<span class="token punctuation">(</span><span class="token number">65565</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment" spellcheck="true"># disabled promiscuous mode</span>
s<span class="token punctuation">.</span>ioctl<span class="token punctuation">(</span>socket<span class="token punctuation">.</span>SIO_RCVALL<span class="token punctuation">,</span> socket<span class="token punctuation">.</span>RCVALL_OFF<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>下面的例子演示了如何使用 socket 接口与采用原始套接字协议的 CAN 网络进行通信。 要改为通过广播管理器协议来使用 CAN，则要用以下方式打开一个 socket:</p>
<pre class="line-numbers language-python"><code class="language-python">socket<span class="token punctuation">.</span>socket<span class="token punctuation">(</span>socket<span class="token punctuation">.</span>AF_CAN<span class="token punctuation">,</span> socket<span class="token punctuation">.</span>SOCK_DGRAM<span class="token punctuation">,</span> socket<span class="token punctuation">.</span>CAN_BCM<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>在绑定 (<code>CAN_RAW</code>) 或连接 (<code>CAN_BCM</code>) socket 之后，你将可以在 socket 对象上正常使用 <code>socket.send()</code> 以及 <code>socket.recv()</code> 操作（及同类操作）。</p>
<p>最后一个例子可能需要特别的权限:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> socket
<span class="token keyword">import</span> struct
<span class="token comment" spellcheck="true"># CAN frame packing/unpacking (see 'struct can_frame' in &lt;linux/can.h>)</span>
can_frame_fmt <span class="token operator">=</span> <span class="token string">"=IB3x8s"</span>
can_frame_size <span class="token operator">=</span> struct<span class="token punctuation">.</span>calcsize<span class="token punctuation">(</span>can_frame_fmt<span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">build_can_frame</span><span class="token punctuation">(</span>can_id<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">:</span>
    can_dlc <span class="token operator">=</span> len<span class="token punctuation">(</span>data<span class="token punctuation">)</span>
    data <span class="token operator">=</span> data<span class="token punctuation">.</span>ljust<span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span> b<span class="token string">'\x00'</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> struct<span class="token punctuation">.</span>pack<span class="token punctuation">(</span>can_frame_fmt<span class="token punctuation">,</span> can_id<span class="token punctuation">,</span> can_dlc<span class="token punctuation">,</span> data<span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">dissect_can_frame</span><span class="token punctuation">(</span>frame<span class="token punctuation">)</span><span class="token punctuation">:</span>
    can_id<span class="token punctuation">,</span> can_dlc<span class="token punctuation">,</span> data <span class="token operator">=</span> struct<span class="token punctuation">.</span>unpack<span class="token punctuation">(</span>can_frame_fmt<span class="token punctuation">,</span> frame<span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>can_id<span class="token punctuation">,</span> can_dlc<span class="token punctuation">,</span> data<span class="token punctuation">[</span><span class="token punctuation">:</span>can_dlc<span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token comment" spellcheck="true"># create a raw socket and bind it to the 'vcan0' interface</span>
s <span class="token operator">=</span> socket<span class="token punctuation">.</span>socket<span class="token punctuation">(</span>socket<span class="token punctuation">.</span>AF_CAN<span class="token punctuation">,</span> socket<span class="token punctuation">.</span>SOCK_RAW<span class="token punctuation">,</span> socket<span class="token punctuation">.</span>CAN_RAW<span class="token punctuation">)</span>
s<span class="token punctuation">.</span>bind<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">'vcan0'</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>
    cf<span class="token punctuation">,</span> addr <span class="token operator">=</span> s<span class="token punctuation">.</span>recvfrom<span class="token punctuation">(</span>can_frame_size<span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Received: can_id=%x, can_dlc=%x, data=%s'</span> <span class="token operator">%</span> dissect_can_frame<span class="token punctuation">(</span>cf<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">try</span><span class="token punctuation">:</span>
        s<span class="token punctuation">.</span>send<span class="token punctuation">(</span>cf<span class="token punctuation">)</span>
    <span class="token keyword">except</span> OSError<span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Error sending CAN frame'</span><span class="token punctuation">)</span>
    <span class="token keyword">try</span><span class="token punctuation">:</span>
        s<span class="token punctuation">.</span>send<span class="token punctuation">(</span>build_can_frame<span class="token punctuation">(</span><span class="token number">0x01</span><span class="token punctuation">,</span> b<span class="token string">'\x01\x02\x03'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">except</span> OSError<span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Error sending CAN frame'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>多次运行一个示例，且每次执行之间等待时间过短，可能导致这个错误:</p>
<pre><code>OSError: [Errno 98] Address already in use</code></pre><p>这是因为前一次运行使套接字处于 <code>TIME_WAIT</code> 状态，无法立即重用。</p>
<p>要防止这种情况，需要设置一个 <code>socket</code> 标志 <code>socket.SO_REUSEADDR</code>:</p>
<pre class="line-numbers language-python"><code class="language-python">s <span class="token operator">=</span> socket<span class="token punctuation">.</span>socket<span class="token punctuation">(</span>socket<span class="token punctuation">.</span>AF_INET<span class="token punctuation">,</span> socket<span class="token punctuation">.</span>SOCK_STREAM<span class="token punctuation">)</span>
s<span class="token punctuation">.</span>setsockopt<span class="token punctuation">(</span>socket<span class="token punctuation">.</span>SOL_SOCKET<span class="token punctuation">,</span> socket<span class="token punctuation">.</span>SO_REUSEADDR<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>
s<span class="token punctuation">.</span>bind<span class="token punctuation">(</span><span class="token punctuation">(</span>HOST<span class="token punctuation">,</span> PORT<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p><code>SO_REUSEADDR</code> 标志告诉内核将处于 <code>TIME_WAIT</code> 状态的本地套接字重新使用，而不必等到固有的超时到期。</p>
<p>参见</p>
<p>关于套接字编程（C 语言）的介绍，请参阅以下文章：</p>
<ul>
<li><em>An Introductory 4.3BSD Interprocess Communication Tutorial</em>，作者 Stuart Sechrest</li>
<li><em>An Advanced 4.3BSD Interprocess Communication Tutorial</em>，作者 Samuel J. Leffler et al,</li>
</ul>
<p>两篇文章都在 UNIX 开发者手册，补充文档 1（第 PS1:7 和 PS1:8 节）中。那些特定于平台的参考资料，它们包含与套接字有关的各种系统调用，也是套接字语义细节的宝贵信息来源。对于 Unix，请参考手册页。对于 Windows，请参阅 WinSock（或 Winsock 2）规范。如果需要支持 IPv6 的 API，读者可能希望参考 <a href="https://tools.ietf.org/html/rfc3493.html" target="_blank" rel="noopener"><strong>RFC 3493</strong></a>，标题为 Basic Socket Interface Extensions for IPv6。</p>
<h2 id="ssl-—-套接字对象的-TLS-SSL-包装器"><a href="#ssl-—-套接字对象的-TLS-SSL-包装器" class="headerlink" title="ssl —- 套接字对象的 TLS/SSL 包装器"></a><code>ssl</code> —- 套接字对象的 TLS/SSL 包装器</h2><p><strong>源代码:</strong> <a href="https://github.com/python/cpython/tree/3.10/Lib/ssl.py" target="_blank" rel="noopener">Lib/ssl.py</a></p>
<hr>
<p>This module provides access to Transport Layer Security (often known as “Secure Sockets Layer”) encryption and peer authentication facilities for network sockets, both client-side and server-side. This module uses the OpenSSL library. It is available on all modern Unix systems, Windows, macOS, and probably additional platforms, as long as OpenSSL is installed on that platform.</p>
<p>注解</p>
<p>某些行为可能与平台相关，因为调用了操作系统的套接字 API。已安装的OpenSSL 版本也可能会导致不同的行为。比如 TLSv 1.3 与 Open SSL 1.1.1 就不一样。</p>
<p>警告</p>
<p>在阅读 安全考量 前不要使用此模块。 这样做可能会导致虚假的安全感，因为ssl模块的默认设置不一定适合你的应用程序。</p>
<p>文档本文档记录<code>ssl</code> 模块的对象和函数；更多关于TLS,SSL,和证书的信息，请参阅下方的“详情”选项</p>
<p>本模块提供了一个类 <code>ssl.SSLSocket</code>，它派生自 <code>socket.socket</code> 类型，并提供类似套接字的包装器，也能够对通过带 SSL 套接字的数据进行加密和解密。 它支持一些额外方法例如 <code>getpeercert()</code>，该方法可从连接的另一端获取证书，还有 <code>cipher()</code>，该方法可获取安全连接所使用的密码。</p>
<p>对于更复杂的应用程序，<code>ssl.SSLContext</code> 类有助于管理设置项和证书，进而可以被使用 <code>SSLContext.wrap_socket()</code> 方法创建的 SSL 套接字继承。</p>
<p>在 3.5.3 版更改: 更新以支持和 OpenSSL 1.1.0 的链接</p>
<p>在 3.6 版更改: OpenSSL 0.9.8、1.0.0 和 1.0.1 已过时，将不再被支持。在 ssl 模块未来的版本中，最低需要 OpenSSL 1.0.2 或 1.1.0。</p>
<p>在 3.10 版更改: <a href="https://www.python.org/dev/peps/pep-0644" target="_blank" rel="noopener"><strong>PEP 644</strong></a> 已经实现。ssl 模块需要 OpenSSL 1.1.1 以上版本的支持。</p>
<p>使用废弃的常量和函数会导致废弃警告。</p>
<h3 id="方法、常量和异常处理"><a href="#方法、常量和异常处理" class="headerlink" title="方法、常量和异常处理"></a>方法、常量和异常处理</h3><h4 id="套接字创建"><a href="#套接字创建" class="headerlink" title="套接字创建"></a>套接字创建</h4><p>从 Python 3.2 和 2.7.9 开始，建议使用 <code>SSLContext</code> 实例的 <code>SSLContext.wrap_socket()</code> 来将套接字包装为 <code>SSLSocket</code> 对象。 辅助函数 <code>create_default_context()</code> 会返回一个新的带有安全默认设置的上下文。 旧的 <code>wrap_socket()</code> 函数已被弃用，因为它效率较差并且不支持服务器名称提示（SNI）和主机匹配。</p>
<p>客户端套接字实例，采用默认上下文和IPv4/IPv6双栈:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> socket
<span class="token keyword">import</span> ssl
hostname <span class="token operator">=</span> <span class="token string">'www.python.org'</span>
context <span class="token operator">=</span> ssl<span class="token punctuation">.</span>create_default_context<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">with</span> socket<span class="token punctuation">.</span>create_connection<span class="token punctuation">(</span><span class="token punctuation">(</span>hostname<span class="token punctuation">,</span> <span class="token number">443</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">as</span> sock<span class="token punctuation">:</span>
    <span class="token keyword">with</span> context<span class="token punctuation">.</span>wrap_socket<span class="token punctuation">(</span>sock<span class="token punctuation">,</span> server_hostname<span class="token operator">=</span>hostname<span class="token punctuation">)</span> <span class="token keyword">as</span> ssock<span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span>ssock<span class="token punctuation">.</span>version<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>客户端套接字示例，带有自定义上下文和IPv4:</p>
<pre class="line-numbers language-python"><code class="language-python">hostname <span class="token operator">=</span> <span class="token string">'www.python.org'</span>
<span class="token comment" spellcheck="true"># PROTOCOL_TLS_CLIENT requires valid cert chain and hostname</span>
context <span class="token operator">=</span> ssl<span class="token punctuation">.</span>SSLContext<span class="token punctuation">(</span>ssl<span class="token punctuation">.</span>PROTOCOL_TLS_CLIENT<span class="token punctuation">)</span>
context<span class="token punctuation">.</span>load_verify_locations<span class="token punctuation">(</span><span class="token string">'path/to/cabundle.pem'</span><span class="token punctuation">)</span>
<span class="token keyword">with</span> socket<span class="token punctuation">.</span>socket<span class="token punctuation">(</span>socket<span class="token punctuation">.</span>AF_INET<span class="token punctuation">,</span> socket<span class="token punctuation">.</span>SOCK_STREAM<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">as</span> sock<span class="token punctuation">:</span>
    <span class="token keyword">with</span> context<span class="token punctuation">.</span>wrap_socket<span class="token punctuation">(</span>sock<span class="token punctuation">,</span> server_hostname<span class="token operator">=</span>hostname<span class="token punctuation">)</span> <span class="token keyword">as</span> ssock<span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span>ssock<span class="token punctuation">.</span>version<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>服务器套接字实例，在localhost上监听IPv4:</p>
<pre class="line-numbers language-python"><code class="language-python">context <span class="token operator">=</span> ssl<span class="token punctuation">.</span>SSLContext<span class="token punctuation">(</span>ssl<span class="token punctuation">.</span>PROTOCOL_TLS_SERVER<span class="token punctuation">)</span>
context<span class="token punctuation">.</span>load_cert_chain<span class="token punctuation">(</span><span class="token string">'/path/to/certchain.pem'</span><span class="token punctuation">,</span> <span class="token string">'/path/to/private.key'</span><span class="token punctuation">)</span>
<span class="token keyword">with</span> socket<span class="token punctuation">.</span>socket<span class="token punctuation">(</span>socket<span class="token punctuation">.</span>AF_INET<span class="token punctuation">,</span> socket<span class="token punctuation">.</span>SOCK_STREAM<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">as</span> sock<span class="token punctuation">:</span>
    sock<span class="token punctuation">.</span>bind<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">'127.0.0.1'</span><span class="token punctuation">,</span> <span class="token number">8443</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    sock<span class="token punctuation">.</span>listen<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>
    <span class="token keyword">with</span> context<span class="token punctuation">.</span>wrap_socket<span class="token punctuation">(</span>sock<span class="token punctuation">,</span> server_side<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span> <span class="token keyword">as</span> ssock<span class="token punctuation">:</span>
        conn<span class="token punctuation">,</span> addr <span class="token operator">=</span> ssock<span class="token punctuation">.</span>accept<span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="上下文创建"><a href="#上下文创建" class="headerlink" title="上下文创建"></a>上下文创建</h4><p>便捷函数，可以帮助创建 <code>SSLContext</code> 对象，用于常见的目的。</p>
<p><code>ssl.create_default_context</code>(<em>purpose=Purpose.SERVER_AUTH</em>, <em>cafile=None</em>, <em>capath=None</em>, <em>cadata=None</em>)</p>
<p>返回一个新的 <code>SSLContext</code> 对象，使用给定 <em>purpose</em> 的默认设置。 该设置由 <code>ssl</code> 模块选择，并且通常是代表一个比直接调用 <code>SSLContext</code> 构造器时更高的安全等级。</p>
<p><em>cafile</em>, <em>capath</em>, <em>cadata</em> 代表用于进行证书核验的可选受信任 CA 证书，与 <code>SSLContext.load_verify_locations()</code> 的一致。 如果三个参数均为 <code>None</code>，此函数可以转而选择信任系统的默认 CA 证书。</p>
<p>设置为： <code>PROTOCOL_TLS_CLIENT</code> 或 <code>PROTOCOL_TLS_SERVER</code>、 <code>OP_NO_SSLv2</code> 和 <code>OP_NO_SSLv3</code>，带有不含 RC4 及未认证的高强度加密密码套件。 传入 <code>SERVER_AUTH</code> 作为 <em>purpose<em>，会将 <code>verify_mode</code> 设为 <code>CERT_REQUIRED</code>，并加载 CA 证书（若给出 *cafile</em>、*capath</em> 或 <em>cadata</em> 之一）或用 <code>SSLContext.load_default_certs()</code> 加载默认CA证书。</p>
<p>当 <code>keylog_filename</code> 受支持并且设置了环境变量 <code>SSLKEYLOGFILE</code> 时，<code>create_default_context()</code> 会启用密钥日志记录。</p>
<p>注解</p>
<p>协议、选项、密码和其他设置可随时更改为更具约束性的值而无须事先弃用。 这些值代表了兼容性和安全性之间的合理平衡。</p>
<p>如果你的应用需要特定的设置，你应当创建一个 <code>SSLContext</code> 并自行应用设置。</p>
<p>注解</p>
<p>如果你发现当某些较旧的客户端或服务器尝试与用此函数创建的 <code>SSLContext</code> 进行连接时收到了报错提示 “Protocol or cipher suite mismatch”，这可能是因为它们只支持 SSL3.0 而它被此函数用 <code>OP_NO_SSLv3</code> 排除掉了。 SSL3.0 被广泛认为 完全不可用。 如果你仍希望继续使用此函数但仍允许 SSL 3.0 连接，你可以使用以下代码重新启用它们:</p>
<pre class="line-numbers language-python"><code class="language-python">ctx <span class="token operator">=</span> ssl<span class="token punctuation">.</span>create_default_context<span class="token punctuation">(</span>Purpose<span class="token punctuation">.</span>CLIENT_AUTH<span class="token punctuation">)</span>
ctx<span class="token punctuation">.</span>options <span class="token operator">&amp;</span><span class="token operator">=</span> <span class="token operator">~</span>ssl<span class="token punctuation">.</span>OP_NO_SSLv3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>3.4 新版功能.</p>
<p>在 3.4.4 版更改: RC4 被从默认密码字符串中丢弃。</p>
<p>在 3.6 版更改: ChaCha20/Poly1305 被添加到默认密码字符串中。</p>
<p>3DES 被从默认密码字符串中丢弃。</p>
<p>在 3.8 版更改: 增加了对密钥日志记录至 <code>SSLKEYLOGFILE</code> 的支持。</p>
<p>在 3.10 版更改: 当前上下文使用 <code>PROTOCOL_TLS_CLIENT</code> 或 <code>PROTOCOL_TLS_SERVER</code> 协议而非通用的 <code>PROTOCOL_TLS</code>。</p>
<h4 id="异常-2"><a href="#异常-2" class="headerlink" title="异常"></a>异常</h4><p><em>exception</em> <code>ssl.SSLError</code></p>
<p>引发此异常以提示来自下层 SSL 实现（目前由 OpenSSL 库提供）的错误。 它表示在下层网络连接之上叠加的高层级加密和验证层存在某种问题。 此错误是 <code>OSError</code> 的一个子类型。 <code>SSLError</code> 实例的错误和消息是由 OpenSSL 库提供的。</p>
<p>在 3.3 版更改: <code>SSLError</code> 曾经是 <code>socket.error</code> 的一个子类型。</p>
<ul>
<li><p><code>library</code></p>
<p>一个字符串形式的助记符，用来指明发生错误的 OpenSSL 子模块，例如 <code>SSL</code>, <code>PEM</code> 或 <code>X509</code>。 可能的取值范围依赖于 OpenSSL 的版本。</p>
<p>3.3 新版功能.</p>
</li>
<li><p><code>reason</code></p>
<p>一个字符串形式的助记符，用来指明发生错误的原因，例如 <code>CERTIFICATE_VERIFY_FAILED</code>。 可能的取值范围依赖于 OpenSSL 的版本。</p>
<p>3.3 新版功能.</p>
</li>
</ul>
<p><em>exception</em> <code>ssl.SSLZeroReturnError</code></p>
<p><code>SSLError</code> 的子类，当尝试读取或写入且 SSL 连接已被完全关闭时会被引发。 请注意这并不意味着下层的传输（读取 TCP）已被关闭。</p>
<p>3.3 新版功能.</p>
<p><em>exception</em> <code>ssl.SSLWantReadError</code></p>
<p><code>SSLError</code> 的子类，当尝试读取或写入数据，但在请求被满足之前还需要在下层的 TCP 传输上接收更多数据时会被 非阻塞型 SSL 套接字 引发。</p>
<p>3.3 新版功能.</p>
<p><em>exception</em> <code>ssl.SSLWantWriteError</code></p>
<p><code>SSLError</code> 的子类，当尝试读取或写入数据，但在请求被满足之前还需要在下层的 TCP 传输上发送更多数据时会被 非阻塞型 SSL 套接字 引发。</p>
<p>3.3 新版功能.</p>
<p><em>exception</em> <code>ssl.SSLSyscallError</code></p>
<p><code>SSLError</code> 的子类，当尝试在 SSL 套接字上执行操作时遇到系统错误时会被引发。 不幸的是，没有简单的方式能检查原始 errno 编号。</p>
<p>3.3 新版功能.</p>
<p><em>exception</em> <code>ssl.SSLEOFError</code></p>
<p><code>SSLError</code> 的子类，当 SSL 连接被突然终止时会被引发。 通常，当遇到此错误时你不应再尝试重用下层的传输。</p>
<p>3.3 新版功能.</p>
<p><em>exception</em> <code>ssl.SSLCertVerificationError</code></p>
<p><code>SSLError</code> 的子类，当证书验证失败时会被引发。</p>
<p>3.7 新版功能.</p>
<ul>
<li><p><code>verify_code</code></p>
<p>一个数字形式的错误编号，用于表示验证错误。</p>
</li>
<li><p><code>verify_message</code></p>
<p>用于表示验证错误的人类可读的字符串。</p>
</li>
</ul>
<p><em>exception</em> <code>ssl.CertificateError</code></p>
<p><code>SSLCertVerificationError</code> 的别名。</p>
<p>在 3.7 版更改: 此异常现在是 <code>SSLCertVerificationError</code> 的别名。</p>
<h4 id="随机生成"><a href="#随机生成" class="headerlink" title="随机生成"></a>随机生成</h4><p><code>ssl.RAND_bytes</code>(<em>num</em>)</p>
<p>返回 <em>num</em> 个高加密强度伪随机字节数据。 如果 PRNG 未使用足够的数据作为随机种子或者如果当前 RAND 方法不支持该操作则会引发 <code>SSLError</code>。 <code>RAND_status()</code> 可被用来检查 PRNG 的状态而 <code>RAND_add()</code> 可被用来为 PRNG 设置随机种子。</p>
<p>对于几乎所有应用程序都更推荐使用 <code>os.urandom()</code>。</p>
<p>请阅读维基百科文章 <a href="https://en.wikipedia.org/wiki/Cryptographically_secure_pseudorandom_number_generator" target="_blank" rel="noopener">Cryptographically secure pseudorandom number generator (CSPRNG)</a> 以了解对于高加密强度生成器的具体要求。</p>
<p>3.3 新版功能.</p>
<p><code>ssl.RAND_pseudo_bytes</code>(<em>num</em>)</p>
<p>返回 (bytes, is_cryptographic): bytes 是 <em>num</em> 个伪随机字节数据，如果所生成的字节数据为高加密强度则 is_cryptographic 为 <code>True</code>。 如果当前 RAND 方法不支持此操作则会引发 <code>SSLError</code>。</p>
<p>所生成的伪随机字节序列如果具有足够的长度则将会具有唯一性，并是并非不可预测。 它们可被用于非加密目的以及加密协议中的特定目的，但通常不可被用于密钥生成等目的。</p>
<p>对于几乎所有应用程序都更推荐使用 <code>os.urandom()</code>。</p>
<p>3.3 新版功能.</p>
<p>3.6 版后已移除: OpenSSL 已弃用了 <code>ssl.RAND_pseudo_bytes()</code>，请改用 <code>ssl.RAND_bytes()</code>。</p>
<p><code>ssl.RAND_status</code>()</p>
<p>如果 SSL 伪随机数生成器已使用‘足够的’随机性作为种子则返回 <code>True</code>，否则返回 <code>False</code>。 你可以使用 <code>ssl.RAND_egd()</code> 和 <code>ssl.RAND_add()</code> 来增加伪随机数生成器的随机性。</p>
<p><code>ssl.RAND_add</code>(<em>bytes</em>, <em>entropy</em>)</p>
<p>将给定的 <em>bytes</em> 混合到 SSL 伪随机数生成器中。 形参 <em>entropy</em> (float 类型) 是数据所包含的熵的下界 (因此你可以总是使用 <code>0.0</code>)。 请查看 <a href="https://tools.ietf.org/html/rfc1750.html" target="_blank" rel="noopener"><strong>RFC 1750</strong></a> 了解有关熵源的更多信息。</p>
<p>在 3.5 版更改: 现在接受可写的 字节类对象。</p>
<h4 id="证书处理"><a href="#证书处理" class="headerlink" title="证书处理"></a>证书处理</h4><p><code>ssl.match_hostname</code>(<em>cert</em>, <em>hostname</em>)</p>
<p>验证 <em>cert</em> (使用 <code>SSLSocket.getpeercert()</code> 所返回的已解码格式) 是否匹配给定的 <em>hostname</em>。 所应用的规则是在 <a href="https://tools.ietf.org/html/rfc2818.html" target="_blank" rel="noopener"><strong>RFC 2818</strong></a>, <a href="https://tools.ietf.org/html/rfc5280.html" target="_blank" rel="noopener"><strong>RFC 5280</strong></a> 和 <a href="https://tools.ietf.org/html/rfc6125.html" target="_blank" rel="noopener"><strong>RFC 6125</strong></a> 中描述的检查 HTTPS 服务器身份的规则。 除了 HTTPS，此函数还应当适用于各种基于 SSL 协议的服务器身份检查操作，例如 FTPS, IMAPS, POPS 等等。</p>
<p>失败时引发 <code>CertificateError</code>。 成功时此函数无返回值:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> cert <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'subject'</span><span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">'commonName'</span><span class="token punctuation">,</span> <span class="token string">'example.com'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">}</span>
<span class="token operator">>></span><span class="token operator">></span> ssl<span class="token punctuation">.</span>match_hostname<span class="token punctuation">(</span>cert<span class="token punctuation">,</span> <span class="token string">"example.com"</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> ssl<span class="token punctuation">.</span>match_hostname<span class="token punctuation">(</span>cert<span class="token punctuation">,</span> <span class="token string">"example.org"</span><span class="token punctuation">)</span>
Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>
  File <span class="token string">"&lt;stdin>"</span><span class="token punctuation">,</span> line <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">></span>
  File <span class="token string">"/home/py3k/Lib/ssl.py"</span><span class="token punctuation">,</span> line <span class="token number">130</span><span class="token punctuation">,</span> <span class="token keyword">in</span> match_hostname
ssl<span class="token punctuation">.</span>CertificateError<span class="token punctuation">:</span> hostname <span class="token string">'example.org'</span> doesn<span class="token string">'t match '</span>example<span class="token punctuation">.</span>com'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>3.2 新版功能.</p>
<p>在 3.3.3 版更改: 此函数现在遵循 <a href="https://tools.ietf.org/html/rfc6125.html" target="_blank" rel="noopener"><strong>RFC 6125</strong></a>, 6.4.3 小节，它不会匹配多个通配符 (例如 <code>*.*.com</code> 或 <code>*a*.example.org</code>) 也不匹配国际化域名 (IDN) 片段内部的通配符。 IDN A 标签例如 <code>www*.xn--pthon-kva.org</code> 仍然受支持，但 <code>x*.python.org</code> 不再能匹配 <code>xn--tda.python.org</code>。</p>
<p>在 3.5 版更改: 现在支持匹配存在于证书的 subjectAltName 字段中的 IP 地址。</p>
<p>在 3.7 版更改: 此函数不再被用于 TLS 连接。 主机匹配现在是由 OpenSSL 执行的。</p>
<p>允许位于段的最左端且为唯一字符的通配符。 部分通配符例如 <code>www*.example.com</code> 已不再受支持。</p>
<p>3.7 版后已移除.</p>
<p><code>ssl.cert_time_to_seconds</code>(<em>cert_time</em>)</p>
<p>返回距离 Unix 纪元零时的秒数，给定的 <code>cert_time</code> 字符串代表来自证书的 “notBefore” 或 “notAfter” 日期值，采用 <code>"%b %d %H:%M:%S %Y %Z"</code> strptime 格式（C 区域）。</p>
<p>以下为示例代码:</p>
<pre><code>&gt;&gt;&gt; import ssl
&gt;&gt;&gt; timestamp = ssl.cert_time_to_seconds("Jan  5 09:34:43 2018 GMT")
&gt;&gt;&gt; timestamp  
1515144883
&gt;&gt;&gt; from datetime import datetime
&gt;&gt;&gt; print(datetime.utcfromtimestamp(timestamp))  
2018-01-05 09:34:43</code></pre><p>“notBefore” 或 “notAfter” 日期值必须使用 GMT (<a href="https://tools.ietf.org/html/rfc5280.html" target="_blank" rel="noopener"><strong>RFC 5280</strong></a>)。</p>
<p>在 3.5 版更改: 将输入时间解读为 UTC 时间，基于输入字符串中指明的 ‘GMT’ 时区。 在之前使用的是本地时区。 返回一个整数（不带输入格式中秒的分数部分）</p>
<p><code>ssl.get_server_certificate</code>(<em>addr</em>, <em>ssl_version=PROTOCOL_TLS_CLIENT</em>, <em>ca_certs=None</em>[, <em>timeout</em>])</p>
<p>给出一个受 SSL 保护的服务器的地址 <code>addr</code>，形式为 (<em>hostname</em>, <em>port-number</em>) ，获取该服务器的证书，并以 PEM 编码的字符串返回。如果指定了 <code>ssl_version</code>，则使用该版本的 SSL 协议尝试连接服务器。如果指定了 <code>ca_certs</code>，它应该是一个包含根证书列表的文件，与 <code>SSLContext.wrap_socket()</code> 中同名参数的格式相同。该调用将尝试根据该根证书集来验证服务器的证书，如果验证失败则调用失败。参数 <code>timeout</code> 可用于指定超时时间。</p>
<p>在 3.3 版更改: 此函数现在是 IPv6 兼容的。-compatible.</p>
<p>在 3.5 版更改: 默认的 <em>ssl_version</em> 从 <code>PROTOCOL_SSLv3</code> 改为 <code>PROTOCOL_TLS</code> 以保证与现代服务器的最大兼容性。</p>
<p>在 3.10 版更改: 加入 <em>timeout</em> 参数。</p>
<p><code>ssl.DER_cert_to_PEM_cert</code>(<em>DER_cert_bytes</em>)</p>
<p>根据给定的 DER 编码字节块形式的证书，返回同一证书的 PEM 编码字符串版本。</p>
<p><code>ssl.PEM_cert_to_DER_cert</code>(<em>PEM_cert_string</em>)</p>
<p>根据给定的 ASCII PEM 字符串形式的证书，返回同一证书的 DER 编码字节序列。</p>
<p><code>ssl.get_default_verify_paths</code>()</p>
<p>返回包含 OpenSSL 的默认 cafile 和 capath 的路径的命名元组。 此路径与 <code>SSLContext.set_default_verify_paths()</code> 所使用的相同。 返回值是一个 named tuple <code>DefaultVerifyPaths</code>:</p>
<ul>
<li><code>cafile</code> - 解析出的 cafile 路径或者如果文件不存在则为 <code>None</code>,</li>
<li><code>capath</code> - 解析出的 capath 路径或者如果目录不存在则为 <code>None</code>,</li>
<li><code>openssl_cafile_env</code> - 指向一个 cafile 的 OpenSSL 环境键,</li>
<li><code>openssl_cafile</code> - 一个 cafile 的硬编码路径,</li>
<li><code>openssl_capath_env</code> - 指向一个 capath 的 OpenSSL 环境键,</li>
<li><code>openssl_capath</code> - 一个 capath 目录的硬编码路径</li>
</ul>
<p>可用性: LibreSSL 会忽略环境变量 <code>openssl_cafile_env</code> 和 <code>openssl_capath_env</code>。</p>
<p>3.4 新版功能.</p>
<p><code>ssl.enum_certificates</code>(<em>store_name</em>)</p>
<p>从 Windows 的系统证书库中检索证书。 <em>store_name</em> 可以是 <code>CA</code>, <code>ROOT</code> 或 <code>MY</code> 中的一个。 Windows 也可能会提供额外的证书库。</p>
<p>此函数返回一个包含 (cert_bytes, encoding_type, trust) 元组的列表。 encoding_type 指明 cert_bytes 的编码格式。 它可以为 <code>x509_asn</code> 以表示 X.509 ASN.1 数据或是 <code>pkcs_7_asn</code> 以表示 PKCS#7 ASN.1 数据。 trust 以 OIDS 集合的形式指明证书的目的，或者如果证书对于所有目的都可以信任则为 <code>True</code>。</p>
<p>示例:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> ssl<span class="token punctuation">.</span>enum_certificates<span class="token punctuation">(</span><span class="token string">"CA"</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token punctuation">(</span>b<span class="token string">'data...'</span><span class="token punctuation">,</span> <span class="token string">'x509_asn'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token string">'1.3.6.1.5.5.7.3.1'</span><span class="token punctuation">,</span> <span class="token string">'1.3.6.1.5.5.7.3.2'</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
 <span class="token punctuation">(</span>b<span class="token string">'data...'</span><span class="token punctuation">,</span> <span class="token string">'x509_asn'</span><span class="token punctuation">,</span> <span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>可用性: Windows。</p>
<p>3.4 新版功能.</p>
<p><code>ssl.enum_crls</code>(<em>store_name</em>)</p>
<p>Windows 的系统证书库中检索 CRL。 <em>store_name</em> 可以是 <code>CA</code>, <code>ROOT</code> 或 <code>MY</code> 中的一个。 Windows 也可能会提供额外的证书库。</p>
<p>此函数返回一个包含 (cert_bytes, encoding_type, trust) 元组的列表。 encoding_type 指明 cert_bytes 的编码格式。 它可以为 <code>x509_asn</code> 以表示 X.509 ASN.1 数据或是 <code>pkcs_7_asn</code> 以表示 PKCS#7 ASN.1 数据。</p>
<p>可用性: Windows。</p>
<p>3.4 新版功能.</p>
<p><code>ssl.wrap_socket</code>(<em>sock</em>, <em>keyfile=None</em>, <em>certfile=None</em>, <em>server_side=False</em>, <em>cert_reqs=CERT_NONE</em>, <em>ssl_version=PROTOCOL_TLS</em>, <em>ca_certs=None</em>, <em>do_handshake_on_connect=True</em>, <em>suppress_ragged_eofs=True</em>, <em>ciphers=None</em>)</p>
<p>接受一个 <code>socket.socket</code> 的实例 <code>sock</code>，并返回一个 <code>ssl.SSLSocket</code> 的实例，该类型是 <code>socket.socket</code> 的子类型，它将下层的套接字包装在一个 SSL 上下文中。 <code>sock</code> 必须是一个 <code>SOCK_STREAM</code> 套接字；其他套接字类型不被支持。</p>
<p>在内部，该函数会创建一个 <code>SSLContext</code>，其协议版本为 <em>ssl_version</em> 且 <code>SSLContext.options</code> 设为 <em>cert_reqs*。 如果设置了 *keyfile</em>, <em>certfile</em>, <em>ca_certs</em> 或 <em>ciphers</em> 等形参，则参数值会被传给 <code>SSLContext.load_cert_chain()</code>, <code>SSLContext.load_verify_locations()</code> 以及 <code>SSLContext.set_ciphers()</code>。</p>
<p>参数 <em>server_side</em>, <em>do_handshake_on_connect</em> 和 <em>suppress_ragged_eofs</em> 具有与 <code>SSLContext.wrap_socket()</code> 相同的含义。</p>
<p>3.7 版后已移除: 从 Python 3.2 和 2.7.9 开始，建议使用 <code>SSLContext.wrap_socket()</code> 来代替 <code>wrap_socket()</code>。 模块级函数的功能受限并且将创建不安全的客户端套接字，不带服务器名称提示或主机名匹配。</p>
<h4 id="常量-1"><a href="#常量-1" class="headerlink" title="常量"></a>常量</h4><blockquote>
<p>所有常量现在都是 <code>enum.IntEnum</code> 或 <code>enum.IntFlag</code> 多项集的成员。</p>
<p>3.6 新版功能.</p>
</blockquote>
<pre><code>ssl.CERT_NONE</code></pre><p><code>SSLContext.verify_mode</code> 或 <code>wrap_socket()</code> 的 <code>cert_reqs</code> 形参可能的取值。 <code>PROTOCOL_TLS_CLIENT</code> 除外，这是默认的模式。 对于客户端套接字，几乎任何证书都是可接受的。 验证错误例如不受信任或过期的证书错误会被忽略并且不会中止 TLS/SSL 握手。</p>
<p>在服务器模式下，不会从客户端请求任何证书，因此客户端不会发送任何用于客户端证书身份验证的证书。</p>
<p>参见下文对于 安全考量 的讨论。</p>
<pre><code>ssl.CERT_OPTIONAL</code></pre><p><code>SSLContext.verify_mode</code> 或 <code>wrap_socket()</code> 的 <code>cert_reqs</code> 形参可能的取值。 <code>CERT_OPTIONAL</code> 具有与 <code>CERT_REQUIRED</code> 相同的含义。 对于客户端套接字推荐改用 <code>CERT_REQUIRED</code>。</p>
<p>在服务器模式下，客户端证书请求会被发送给客户端。 客户端可以忽略请求也可以发送一个证书以执行 TLS 客户端证书身份验证。 如果客户端选择发送证书，则将对其执行验证。 任何验证错误都将立即中止 TLS 握手。</p>
<p>使用此设置要求将一组有效的 CA 证书传递给 <code>SSLContext.load_verify_locations()</code> 或是作为 <code>wrap_socket()</code> 的 <code>ca_certs</code> 形参值。</p>
<pre><code>ssl.CERT_REQUIRED</code></pre><p><code>SSLContext.verify_mode</code> 或 <code>wrap_socket()</code> 的 <code>cert_reqs</code> 形参可能的取值。 在此模式下，需要从套接字连接的另一端获取证书；如果未提供证书或验证失败则将引发 <code>SSLError</code>。 此模式 <strong>不能</strong> 在客户端模式下对证书进行验证，因为它不会匹配主机名。 <code>check_hostname</code> 也必须被启用以验证证书的真实性。 <code>PROTOCOL_TLS_CLIENT</code> 会使用 <code>CERT_REQUIRED</code> 并默认启用 <code>check_hostname</code>。</p>
<p>对于服务器套接字，此模式会提供强制性的 TLS 客户端证书验证。 客户端证书请求会被发送给客户端并且客户端必须提供有效且受信任的证书。</p>
<p>使用此设置要求将一组有效的 CA 证书传递给 <code>SSLContext.load_verify_locations()</code> 或是作为 <code>wrap_socket()</code> 的 <code>ca_certs</code> 形参值。</p>
<p><em>class</em> <code>ssl.VerifyMode</code></p>
<p>CERT_* 常量的 <code>enum.IntEnum</code> 多项集。</p>
<p>3.6 新版功能.</p>
<pre><code>ssl.VERIFY_DEFAULT</code></pre><p><code>SSLContext.verify_flags</code> 可能的取值。 在此模式下，证书吊销列表（CRL）并不会被检查。 OpenSSL 默认不要求也不验证 CRL。</p>
<p>3.4 新版功能.</p>
<pre><code>ssl.VERIFY_CRL_CHECK_LEAF</code></pre><p><code>SSLContext.verify_flags</code> 可能的取值。 在此模式下， 只会检查对等证书而不检查任何中间 CA 证书。 此模式要求提供由对等证书颁发者（其直接上级 CA）签名的有效 CRL。 如果未使用 <code>SSLContext.load_verify_locations</code> 加载正确的 CRL，则验证将失败。</p>
<p>3.4 新版功能.</p>
<pre><code>ssl.VERIFY_CRL_CHECK_CHAIN</code></pre><p><code>SSLContext.verify_flags</code> 可能的取值。 在此模式下，会检查对等证书链中所有证书的 CRL。</p>
<p>3.4 新版功能.</p>
<pre><code>ssl.VERIFY_X509_STRICT</code></pre><p><code>SSLContext.verify_flags</code> 可能的取值，用于禁用已损坏 X.509 证书的绕过操作。</p>
<p>3.4 新版功能.</p>
<pre><code>ssl.VERIFY_ALLOW_PROXY_CERTS</code></pre><p><code>SSLContext.verify_flags</code> 的可能取值，启用代理证书验证。</p>
<p>3.10 新版功能.</p>
<pre><code>ssl.VERIFY_X509_TRUSTED_FIRST</code></pre><p><code>SSLContext.verify_flags</code> 可能的取值。 它指示 OpenSSL 在构建用于验证某个证书的信任链时首选受信任的证书。 此旗标将默认被启用。</p>
<p>3.4.4 新版功能.</p>
<pre><code>ssl.VERIFY_X509_PARTIAL_CHAIN</code></pre><p><code>SSLContext.verify_flags</code> 的可能取值。它指示 OpenSSL 接受信任存储中的中间 CA 作为信任锚，与自我签名的根 CA 证书的方式相同。这样就能信任中间 CA 颁发的证书，而不一定非要去信任其祖先的根 CA。</p>
<p>3.10 新版功能.</p>
<p><em>class</em> <code>ssl.VerifyFlags</code></p>
<p>VERIFY_* 常量的 <code>enum.IntFlag</code> 多项集。</p>
<p>3.6 新版功能.</p>
<pre><code>ssl.PROTOCOL_TLS</code></pre><p>选择客户端和服务器均支持的最高协议版本。 此选项名称并不准确，实际上 “SSL” 和 “TLS” 协议均可被选择。</p>
<p>3.6 新版功能.</p>
<p>3.10 版后已移除: TLS 客户端和服务器需要不同的默认设置来实现安全通信。通用的 TLS 协议常量已废弃，而采用 <code>PROTOCOL_TLS_CLIENT</code> 和 <code>PROTOCOL_TLS_SERVER</code>。</p>
<pre><code>ssl.PROTOCOL_TLS_CLIENT</code></pre><p>自动协商为客户端和服务器都支持的最高版本协议，并配置当前上下文客户端的连接。该协议默认启用 <code>CERT_REQUIRED</code> 和 <code>check_hostname</code>。</p>
<p>3.6 新版功能.</p>
<pre><code>ssl.PROTOCOL_TLS_SERVER</code></pre><p>自动协商为客户端和服务器都支持的最高版本协议，并配置上下文服务器端的连接。</p>
<p>3.6 新版功能.</p>
<pre><code>ssl.PROTOCOL_SSLv23</code></pre><p><code>PROTOCOL_TLS</code> 的别名。</p>
<p>3.6 版后已移除: 请改用 <code>PROTOCOL_TLS</code>。</p>
<pre><code>ssl.PROTOCOL_SSLv2</code></pre><p>选择 SSL 版本 2 作为通道加密协议。</p>
<p>如果 OpenSSL 编译时使用了 <code>OPENSSL_NO_SSL2</code> 旗标则此协议将不可用。</p>
<p>警告</p>
<p>SSL 版本 2 并不安全。 极不建议使用它。</p>
<p>3.6 版后已移除: OpenSSL 已经移除了对 SSLv2 的支持。</p>
<pre><code>ssl.PROTOCOL_SSLv3</code></pre><p>选择 SSL 版本 3 作为通道加密协议。</p>
<p>如果 OpenSSL 编译时使用了 <code>OPENSSL_NO_SSLv3</code> 旗标则此协议将不可用。</p>
<p>警告</p>
<p>SSL 版本 3 并不安全。 极不建议使用它。</p>
<p>3.6 版后已移除: OpenSSL 已经废弃了所有特定于版本的协议。请换用带有 <code>SSLContext.minimum_version</code> 和 <code>SSLContext.maximum_version</code> 的默认协议 <code>PROTOCOL_TLS_SERVER</code> 或 <code>PROTOCOL_TLS_CLIENT</code> 。</p>
<pre><code>ssl.PROTOCOL_TLSv1</code></pre><p>选择 TLS 版本 1.0 作为通道加密协议。</p>
<p>3.6 版后已移除: OpenSSL 已经废弃了所有特定于版本的协议。</p>
<pre><code>ssl.PROTOCOL_TLSv1_1</code></pre><p>选择 TLS 版本 1.1 作为通道加密协议。 仅适用于 openssl 版本 1.0.1+。</p>
<p>3.4 新版功能.</p>
<p>3.6 版后已移除: OpenSSL 已经废弃了所有特定于版本的协议。</p>
<pre><code>ssl.PROTOCOL_TLSv1_2</code></pre><p>选用 TLS 1.2 版本作为隧道加密协议。只适用于 openssl 1.0.1 以上版本。</p>
<p>3.4 新版功能.</p>
<p>3.6 版后已移除: OpenSSL 已经废弃了所有特定于版本的协议。</p>
<pre><code>ssl.OP_ALL</code></pre><p>对存在于其他 SSL 实现中的各种缺陷启用绕过操作。 默认会设置此选项。 没有必要设置与 OpenSSL 的 <code>SSL_OP_ALL</code> 常量同名的旗标。</p>
<p>3.2 新版功能.</p>
<pre><code>ssl.OP_NO_SSLv2</code></pre><p>阻止 SSLv2 连接。 此选项仅可与 <code>PROTOCOL_TLS</code> 结合使用。 它会阻止对等方选择 SSLv2 作为协议版本。</p>
<p>3.2 新版功能.</p>
<p>3.6 版后已移除: SSLv2 已被弃用</p>
<pre><code>ssl.OP_NO_SSLv3</code></pre><p>阻止 SSLv3 连接。 此选项仅可与 <code>PROTOCOL_TLS</code> 结合使用。 它会阻止对等方选择 SSLv3 作为协议版本。</p>
<p>3.2 新版功能.</p>
<p>3.6 版后已移除: SSLv3 已被弃用</p>
<pre><code>ssl.OP_NO_TLSv1</code></pre><p>阻止 TLSv1 连接。 此选项仅可与 <code>PROTOCOL_TLS</code> 结合使用。 它会阻止对等方选择 TLSv1 作为协议版本。</p>
<p>3.2 新版功能.</p>
<p>3.7 版后已移除: 此选项自 OpenSSL 1.1.0 起已被弃用，请改用新的 <code>SSLContext.minimum_version</code> 和 <code>SSLContext.maximum_version</code>。</p>
<pre><code>ssl.OP_NO_TLSv1_1</code></pre><p>阻止 TLSv1.1 连接。 此选项仅可与 <code>PROTOCOL_TLS</code> 结合使用。 它会阻止对等方选择 TLSv1.1 作为协议版本。 仅适用于 openssl 版本 1.0.1+。</p>
<p>3.4 新版功能.</p>
<p>3.7 版后已移除: 此选项自 OpenSSL 1.1.0 起已被弃用。</p>
<pre><code>ssl.OP_NO_TLSv1_2</code></pre><p>阻止 TLSv1.2 连接。 此选项仅可与 <code>PROTOCOL_TLS</code> 结合使用。 它会阻止对等方选择 TLSv1.2 作为协议版本。 仅适用于 openssl 版本 1.0.1+。</p>
<p>3.4 新版功能.</p>
<p>3.7 版后已移除: 此选项自 OpenSSL 1.1.0 起已被弃用。</p>
<pre><code>ssl.OP_NO_TLSv1_3</code></pre><p>阻止 TLSv1.3 连接。 此选项仅可与 <code>PROTOCOL_TLS</code> 结合使用。 它会阻止对等方选择 TLSv1.3 作为协议版本。 TLS 1.3 适用于 OpenSSL 1.1.1 或更新的版本。 当 Python 编译是基于较旧版本的 OpenSSL 时，该旗标默认为 <em>0</em>。</p>
<p>3.7 新版功能.</p>
<p>3.7 版后已移除: 此选项自 OpenSSL 1.1.0 起已被弃用。 它被添加到 2.7.15, 3.6.3 和 3.7.0 是为了向下兼容 OpenSSL 1.0.2。</p>
<pre><code>ssl.OP_NO_RENEGOTIATION</code></pre><p>禁用所有 TLSv1.2 和更早版本的重协商操作。 不发送 HelloRequest 消息，并忽略通过 ClientHello 发起的重协商请求。</p>
<p>此选项仅适用于 OpenSSL 1.1.0h 及更新的版本。</p>
<p>3.7 新版功能.</p>
<pre><code>ssl.OP_CIPHER_SERVER_PREFERENCE</code></pre><p>使用服务器的密码顺序首选项，而不是客户端的首选项。 此选项在客户端套接字和 SSLv2 服务器套接字上无效。</p>
<p>3.3 新版功能.</p>
<pre><code>ssl.OP_SINGLE_DH_USE</code></pre><p>阻止对于单独的 SSL 会话重用相同的 DH 密钥。 这会提升前向保密性但需要更多的计算资源。 此选项仅适用于服务器套接字。</p>
<p>3.3 新版功能.</p>
<pre><code>ssl.OP_SINGLE_ECDH_USE</code></pre><p>阻止对于单独的 SSL 会话重用相同的 ECDH 密钥。 这会提升前向保密性但需要更多的计算资源。 此选项仅适用于服务器套接字。</p>
<p>3.3 新版功能.</p>
<pre><code>ssl.OP_ENABLE_MIDDLEBOX_COMPAT</code></pre><p>在 TLS 1.3 握手中发送虚拟更改密码规格（CCS）消息以使得 TLS 1.3 连接看起来更像是 TLS 1.2 连接。</p>
<p>此选项仅适用于 OpenSSL 1.1.1 及更新的版本。</p>
<p>3.8 新版功能.</p>
<pre><code>ssl.OP_NO_COMPRESSION</code></pre><p>在 SSL 通道上禁用压缩。 这适用于应用协议支持自己的压缩方案的情况。</p>
<p>3.3 新版功能.</p>
<p><em>class</em> <code>ssl.Options</code></p>
<p>OP_* 常量的 <code>enum.IntFlag</code> 多项集。</p>
<pre><code>ssl.OP_NO_TICKET</code></pre><p>阻止客户端请求会话凭据。</p>
<p>3.6 新版功能.</p>
<pre><code>ssl.OP_IGNORE_UNEXPECTED_EOF</code></pre><p>忽略 TLS 连接的意外关闭。</p>
<p>此选项仅适用于 OpenSSL 3.0.0 及更新的版本。</p>
<p>3.10 新版功能.</p>
<pre><code>ssl.HAS_ALPN</code></pre><p>OpenSSL 库是否具有对 <a href="https://tools.ietf.org/html/rfc7301.html" target="_blank" rel="noopener"><strong>RFC 7301</strong></a> 中描述的 <em>应用层协议协商</em> TLS 扩展的内置支持。</p>
<p>3.5 新版功能.</p>
<pre><code>ssl.HAS_NEVER_CHECK_COMMON_NAME</code></pre><p>OpenSSL 库是否具有对不检测目标通用名称的内置支持且 <code>SSLContext.hostname_checks_common_name</code> 为可写状态。</p>
<p>3.7 新版功能.</p>
<pre><code>ssl.HAS_ECDH</code></pre><p>OpenSSL 库是否具有对基于椭圆曲线的 Diffie-Hellman 密钥交换的内置支持。 此常量应当为真值，除非发布者明确地禁用了此功能。</p>
<p>3.3 新版功能.</p>
<pre><code>ssl.HAS_SNI</code></pre><p>OpenSSL 库是否具有对 <em>服务器名称提示</em> 扩展（在 <a href="https://tools.ietf.org/html/rfc6066.html" target="_blank" rel="noopener"><strong>RFC 6066</strong></a> 中定义）的内置支持。</p>
<p>3.2 新版功能.</p>
<pre><code>ssl.HAS_NPN</code></pre><p>OpenSSL 库是否具有对 <a href="https://en.wikipedia.org/wiki/Application-Layer_Protocol_Negotiation" target="_blank" rel="noopener">应用层协议协商</a> 中描述的 <em>下一协议协商</em> 的内置支持。 当此常量为真值时，你可以使用 <code>SSLContext.set_npn_protocols()</code> 方法来公告你想要支持的协议。</p>
<p>3.3 新版功能.</p>
<pre><code>ssl.HAS_SSLv2</code></pre><p>OpenSSL 库是否具有对 SSL 2.0 协议的内置支持。</p>
<p>3.7 新版功能.</p>
<pre><code>ssl.HAS_SSLv3</code></pre><p>OpenSSL 库是否具有对 SSL 3.0 协议的内置支持。</p>
<p>3.7 新版功能.</p>
<pre><code>ssl.HAS_TLSv1</code></pre><p>OpenSSL 库是否具有对 TLS 1.0 协议的内置支持。</p>
<p>3.7 新版功能.</p>
<pre><code>ssl.HAS_TLSv1_1</code></pre><p>OpenSSL 库是否具有对 TLS 1.1 协议的内置支持。</p>
<p>3.7 新版功能.</p>
<pre><code>ssl.HAS_TLSv1_2</code></pre><p>OpenSSL 库是否具有对 TLS 1.2 协议的内置支持。</p>
<p>3.7 新版功能.</p>
<pre><code>ssl.HAS_TLSv1_3</code></pre><p>OpenSSL 库是否具有对 TLS 1.3 协议的内置支持。</p>
<p>3.7 新版功能.</p>
<pre><code>ssl.CHANNEL_BINDING_TYPES</code></pre><p>受支持的 TLS 通道绑定类型组成的列表。 此列表中的字符串可被用作传给 <code>SSLSocket.get_channel_binding()</code> 的参数。</p>
<p>3.3 新版功能.</p>
<pre><code>ssl.OPENSSL_VERSION</code></pre><p>解释器所加载的 OpenSSL 库的版本字符串:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> ssl<span class="token punctuation">.</span>OPENSSL_VERSION
<span class="token string">'OpenSSL 1.0.2k  26 Jan 2017'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>3.2 新版功能.</p>
<pre><code>ssl.OPENSSL_VERSION_INFO</code></pre><p>代表 OpenSSL 库的版本信息的五个整数所组成的元组:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> ssl<span class="token punctuation">.</span>OPENSSL_VERSION_INFO
<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>3.2 新版功能.</p>
<pre><code>ssl.OPENSSL_VERSION_NUMBER</code></pre><p>OpenSSL 库的原始版本号，以单个整数表示:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> ssl<span class="token punctuation">.</span>OPENSSL_VERSION_NUMBER
<span class="token number">268443839</span>
<span class="token operator">>></span><span class="token operator">></span> hex<span class="token punctuation">(</span>ssl<span class="token punctuation">.</span>OPENSSL_VERSION_NUMBER<span class="token punctuation">)</span>
<span class="token string">'0x100020bf'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>3.2 新版功能.</p>
<pre class="line-numbers language-python"><code class="language-python">ssl<span class="token punctuation">.</span>ALERT_DESCRIPTION_HANDSHAKE_FAILURE
ssl<span class="token punctuation">.</span>ALERT_DESCRIPTION_INTERNAL_ERROR
ALERT_DESCRIPTION_<span class="token operator">*</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>来自 <a href="https://tools.ietf.org/html/rfc5246.html" target="_blank" rel="noopener"><strong>RFC 5246</strong></a> 等文档的警报描述。 IANA TLS Alert Registry 中包含了这个列表及对定义其含义的 RFC 引用。</p>
<p>被用作 <code>SSLContext.set_servername_callback()</code> 中的回调函数的返回值。</p>
<p>3.4 新版功能.</p>
<p><em>class</em> <code>ssl.AlertDescription</code></p>
<p>ALERT_DESCRIPTION_* 常量的 <code>enum.IntEnum</code> 多项集。</p>
<p>3.6 新版功能.</p>
<pre><code>Purpose.SERVER_AUTH</code></pre><p>用于 <code>create_default_context()</code> 和 <code>SSLContext.load_default_certs()</code> 的参数。表示上下文可用于验证网络服务器（因此，它将被用于创建客户端套接字）。</p>
<p>3.4 新版功能.</p>
<pre><code>Purpose.CLIENT_AUTH</code></pre><p>用于 <code>create_default_context()</code> 和 <code>SSLContext.load_default_certs()</code> 的参数。 表示上下文可用于验证网络客户（因此，它将被用于创建服务器端套接字）。</p>
<p>3.4 新版功能.</p>
<p><em>class</em> <code>ssl.SSLErrorNumber</code></p>
<p>SSL_ERROR_* 常量的 <code>enum.IntEnum</code> 多项集。</p>
<p>3.6 新版功能.</p>
<p><em>class</em> <code>ssl.TLSVersion</code></p>
<p><code>SSLContext.maximum_version</code> 和 <code>SSLContext.minimum_version</code> 中的 SSL 和 TLS 版本的 <code>enum.IntEnum</code> 多项集。</p>
<p>3.7 新版功能.</p>
<pre><code>TLSVersion.MINIMUM_SUPPORTED
TLSVersion.MAXIMUM_SUPPORTED</code></pre><p>受支持的最低和最高 SSL 或 TLS 版本。 这些常量被称为魔术常量。 它们的值并不反映可用的最低和最高 TLS/SSL 版本。</p>
<pre><code>TLSVersion.SSLv3
TLSVersion.TLSv1
TLSVersion.TLSv1_1
TLSVersion.TLSv1_2
TLSVersion.TLSv1_3</code></pre><p>SSL 3.0 至 TLS 1.3。</p>
<p>3.10 版后已移除: 所有 <code>TLSVersion</code> 成员，除 <code>TLSVersion.TLSv1_2</code> 和 <code>TLSVersion.TLSv1_3</code> 之外均已废弃。</p>
<h3 id="SSL-套接字"><a href="#SSL-套接字" class="headerlink" title="SSL 套接字"></a>SSL 套接字</h3><p><em>class</em> <code>ssl.SSLSocket</code>(<em>socket.socket</em>)</p>
<p>SSL 套接字提供了 套接字对象 的下列方法:</p>
<ul>
<li><code>accept()</code></li>
<li><code>bind()</code></li>
<li><code>close()</code></li>
<li><code>connect()</code></li>
<li><code>detach()</code></li>
<li><code>fileno()</code></li>
<li><code>getpeername()</code>, <code>getsockname()</code></li>
<li><code>getsockopt()</code>, <code>setsockopt()</code></li>
<li><code>gettimeout()</code>, <code>settimeout()</code>, <code>setblocking()</code></li>
<li><code>listen()</code></li>
<li><code>makefile()</code></li>
<li><code>recv()</code>, <code>recv_into()</code> (but passing a non-zero <code>flags</code> argument is not allowed)</li>
<li><code>send()</code>, <code>sendall()</code> (with the same limitation)</li>
<li><code>sendfile()</code> (but <code>os.sendfile</code> will be used for plain-text sockets only, else <code>send()</code> will be used)</li>
<li><code>shutdown()</code></li>
</ul>
<p>但是，由于 SSL（和 TLS）协议在 TCP 之上具有自己的框架，因此 SSL 套接字抽象在某些方面可能与常规的 OS 层级套接字存在差异。 </p>
<p><code>SSLSocket</code> 的实例必须使用 <code>SSLContext.wrap_socket()</code> 方法来创建。</p>
<p>在 3.5 版更改: 新增了 <code>sendfile()</code> 方法。</p>
<p>在 3.5 版更改: <code>shutdown()</code> 不会在每次接收或发送字节数据后重置套接字超时。 现在套接字超时为关闭的最大总持续时间。</p>
<p>3.6 版后已移除: 直接创建 <code>SSLSocket</code> 实例的做法已被弃用，请使用 <code>SSLContext.wrap_socket()</code> 来包装套接字。</p>
<p>在 3.7 版更改: <code>SSLSocket</code> 的实例必须使用 <code>wrap_socket()</code> 来创建。 在较早的版本中，直接创建实例是可能的。 但这从未被记入文档或是被正式支持。</p>
<p>在 3.10 版更改: Python 内部现在使用 <code>SSL_read_ex</code> 和 <code>SSL_write_ex</code>。这些函数支持读取和写入大于 2GB 的数据。写入零长数据不再出现违反协议的错误。</p>
<p>SSL 套接字还具有下列方法和属性:</p>
<p><code>SSLSocket.read</code>(<em>len=1024</em>, <em>buffer=None</em>)</p>
<p>从 SSL 套接字读取至多 <em>len</em> 个字节的数据并将结果作为 <code>bytes</code> 实例返回。 如果指定了 <em>buffer</em>，则改为读取到缓冲区，并返回所读取的字节数。</p>
<p>如果套接字为 非阻塞型 则会引发 <code>SSLWantReadError</code> 或 <code>SSLWantWriteError</code> 且读取将阻塞。</p>
<p>由于在任何时候重新协商都是可能的，因此调用 <code>read()</code> 也可能导致写入操作。</p>
<p>在 3.5 版更改: 套接字超时在每次接收或发送字节数据后不会再被重置。 现在套接字超时为读取至多 <em>len</em> 个字节数据的最大总持续时间。</p>
<p>3.6 版后已移除: 请使用 <code>recv()</code> 来代替 <code>read()</code>。</p>
<p><code>SSLSocket.write</code>(<em>buf</em>)</p>
<p>将 <em>buf</em> 写入到 SSL 套接字并返回所写入的字节数。 <em>buf</em> 参数必须为支持缓冲区接口的对象。</p>
<p>如果套接字为 非阻塞型 则会引发 <code>SSLWantReadError</code> 或 <code>SSLWantWriteError</code> 且读取将阻塞。</p>
<p>由于在任何时候重新协商都是可能的，因此调用 <code>write()</code> 也可能导致读取操作。</p>
<p>在 3.5 版更改: 套接字超时在每次接收或发送字节数据后不会再被重置。 现在套接字超时为写入 <em>buf</em> 的最大总持续时间。</p>
<p>3.6 版后已移除: 请使用 <code>send()</code> 来代替 <code>write()</code>。</p>
<p>注解</p>
<p><code>read()</code> 和 <code>write()</code> 方法是读写未加密的应用级数据，并将其解密/加密为带加密的线路级数据的低层级方法。 这些方法需要有激活的 SSL 连接，即握手已完成而 <code>SSLSocket.unwrap()</code> 尚未被调用。</p>
<p>通常你应当使用套接字 API 方法例如 <code>recv()</code> 和 <code>send()</code> 来代替这些方法。</p>
<p><code>SSLSocket.do_handshake</code>()</p>
<p>执行 SSL 设置握手。</p>
<p>在 3.4 版更改: 当套接字的 <code>context</code> 的 <code>check_hostname</code> 属性为真值时此握手方法还会执行 <code>match_hostname()</code>。</p>
<p>在 3.5 版更改: 套接字超时在每次接收或发送字节数据时不会再被重置。 现在套接字超时为握手的最大总持续时间。</p>
<p>在 3.7 版更改: 主机名或 IP 地址会在握手期间由 OpenSSL 进行匹配。 函数 <code>match_hostname()</code> 将不再被使用。 在 OpenSSL 拒绝主机名和 IP 地址的情况下，握手将提前被中止并向对等方发送 TLS 警告消息。</p>
<p><code>SSLSocket.getpeercert</code>(<em>binary_form=False</em>)</p>
<p>如果连接另一端的对等方没有证书，则返回 <code>None</code>。 如果 SSL 握手还未完成，则会引发 <code>ValueError</code>。</p>
<p>如果 <code>binary_form</code> 形参为 <code>False</code>，并且从对等方接收到了证书，此方法将返回一个 <code>dict</code> 实例。 如果证书未通过验证，则字典将为空。 如果证书通过验证，它将返回由多个密钥组成的字典，其中包括 <code>subject</code> (证书颁发给的主体) 和 <code>issuer</code> (颁发证书的主体)。 如果证书包含一个 <em>Subject Alternative Name</em> 扩展的实例 (see <a href="https://tools.ietf.org/html/rfc3280.html" target="_blank" rel="noopener"><strong>RFC 3280</strong></a>)，则字典中还将有一个 <code>subjectAltName</code> 键。</p>
<p><code>subject</code> 和 <code>issuer</code> 字段都是包含在证书中相应字段的数据结构中给出的相对专有名称（RDN）序列的元组，每个 RDN 均为 name-value 对的序列。 这里是一个实际的示例:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token punctuation">{</span><span class="token string">'issuer'</span><span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">'countryName'</span><span class="token punctuation">,</span> <span class="token string">'IL'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
            <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">'organizationName'</span><span class="token punctuation">,</span> <span class="token string">'StartCom Ltd.'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
            <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">'organizationalUnitName'</span><span class="token punctuation">,</span>
              <span class="token string">'Secure Digital Certificate Signing'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
            <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">'commonName'</span><span class="token punctuation">,</span>
              <span class="token string">'StartCom Class 2 Primary Intermediate Server CA'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
 <span class="token string">'notAfter'</span><span class="token punctuation">:</span> <span class="token string">'Nov 22 08:15:19 2013 GMT'</span><span class="token punctuation">,</span>
 <span class="token string">'notBefore'</span><span class="token punctuation">:</span> <span class="token string">'Nov 21 03:09:52 2011 GMT'</span><span class="token punctuation">,</span>
 <span class="token string">'serialNumber'</span><span class="token punctuation">:</span> <span class="token string">'95F0'</span><span class="token punctuation">,</span>
 <span class="token string">'subject'</span><span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">'description'</span><span class="token punctuation">,</span> <span class="token string">'571208-SLe257oHY9fVQ07Z'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
             <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">'countryName'</span><span class="token punctuation">,</span> <span class="token string">'US'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
             <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">'stateOrProvinceName'</span><span class="token punctuation">,</span> <span class="token string">'California'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
             <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">'localityName'</span><span class="token punctuation">,</span> <span class="token string">'San Francisco'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
             <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">'organizationName'</span><span class="token punctuation">,</span> <span class="token string">'Electronic Frontier Foundation, Inc.'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
             <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">'commonName'</span><span class="token punctuation">,</span> <span class="token string">'*.eff.org'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
             <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">'emailAddress'</span><span class="token punctuation">,</span> <span class="token string">'hostmaster@eff.org'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
 <span class="token string">'subjectAltName'</span><span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">'DNS'</span><span class="token punctuation">,</span> <span class="token string">'*.eff.org'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'DNS'</span><span class="token punctuation">,</span> <span class="token string">'eff.org'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
 <span class="token string">'version'</span><span class="token punctuation">:</span> <span class="token number">3</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>注解</p>
<p>要验证特定服务的证书，你可以使用 <code>match_hostname()</code> 函数。</p>
<p>如果 <code>binary_form</code> 形参为 <code>True</code>，并且提供了证书，此方法会将整个证书的 DER 编码形式作为字节序列返回，或者如果对等方未提供证书则返回 <code>None</code>。 对等方是否提供证书取决于 SSL 套接字的角色:</p>
<ul>
<li>对于客户端 SSL 套接字，服务器将总是提供证书，无论是否需要进行验证;</li>
<li>对于服务器 SSL 套接字，客户端将仅在服务器要求时才提供证书；因此如果你使用了 <code>CERT_NONE</code> (而不是 <code>CERT_OPTIONAL</code> 或 <code>CERT_REQUIRED</code>) 则 <code>getpeercert()</code> 将返回 <code>None</code>。</li>
</ul>
<p>在 3.2 版更改: 返回的字典包括额外的条目例如 <code>issuer</code> 和 <code>notBefore</code>。</p>
<p>在 3.4 版更改: 如果握手未完成则会引发 <code>ValueError</code>。 返回的字典包括额外的 X509v3 扩展条目例如 <code>crlDistributionPoints</code>, <code>caIssuers</code> 和 <code>OCSP</code> URI。</p>
<p>在 3.9 版更改: IPv6 地址字符串不再附带末尾换行符。</p>
<p><code>SSLSocket.cipher</code>()</p>
<p>返回由三个值组成的元组，其中包含所使用的密码名称，定义其使用方式的 SSL 协议版本，以及所使用的加密比特位数。 如果尚未建立连接，则返回 <code>None</code>。</p>
<p><code>SSLSocket.shared_ciphers</code>()</p>
<p>返回在握手期间由客户端共享的密码列表。 所返回列表的每个条目都是由三个值组成的元组，其中包括密码名称，定义其使用方式的 SSL 协议版本，以及密码所使用的加密比特位数。 如果尚未建立连接或套接字为客户端套接字则 <code>shared_ciphers()</code> 将返回 <code>None</code>。</p>
<p>3.5 新版功能.</p>
<p><code>SSLSocket.compression</code>()</p>
<p>以字符串形式返回所使用的压缩算法，或者如果连接没有使用压缩则返回 <code>None</code>。</p>
<p>如果高层级的协议支持自己的压缩机制，你可以使用 <code>OP_NO_COMPRESSION</code> 来禁用 SSL 层级的压缩。</p>
<p>3.3 新版功能.</p>
<p><code>SSLSocket.get_channel_binding</code>(<em>cb_type=’tls-unique’</em>)</p>
<p>为当前连接获取字节串形式的通道绑定数据。 如果尚未连接或握手尚未完成则返回 <code>None</code>。</p>
<p><em>cb_type</em> 形参允许选择需要的通道绑定类型。 有效的通道绑定类型在 <code>CHANNEL_BINDING_TYPES</code> 列表中列出。 目前只支持由 <a href="https://tools.ietf.org/html/rfc5929.html" target="_blank" rel="noopener"><strong>RFC 5929</strong></a> 所定义的 ‘tls-unique’ 通道绑定。 如果请求了一个不受支持的通道绑定类型则将引发 <code>ValueError</code>。</p>
<p>3.3 新版功能.</p>
<p><code>SSLSocket.selected_alpn_protocol</code>()</p>
<p>返回在 TLS 握手期间所选择的协议。 如果 <code>SSLContext.set_alpn_protocols()</code> 未被调用，如果另一方不支持 ALPN，如果此套接字不支持任何客户端所用的协议，或者如果握手尚未发生，则将返回 <code>None</code>。</p>
<p>3.5 新版功能.</p>
<p><code>SSLSocket.selected_npn_protocol</code>()</p>
<p>返回在Return the higher-level protocol that was selected during the TLS/SSL 握手期间所选择的高层级协议。 如果 <code>SSLContext.set_npn_protocols()</code> 未被调用，或者如果另一方不支持 NPN，或者如果握手尚未发生，则将返回 <code>None</code>。</p>
<p>3.3 新版功能.</p>
<p>3.10 版后已移除: NPN 已被 ALPN 取代。</p>
<p><code>SSLSocket.unwrap</code>()</p>
<p>执行 SSL 关闭握手，这会从下层的套接字中移除 TLS 层，并返回下层的套接字对象。 这可被用来通过一个连接将加密操作转为非加密。 返回的套接字应当总是被用于同连接另一方的进一步通信，而不是原始的套接字。</p>
<p><code>SSLSocket.verify_client_post_handshake</code>()</p>
<p>向一个 TLS 1.3 客户端请求握手后身份验证（PHA）。 只有在初始 TLS 握手之后且双方都启用了 PHA 的情况下才能为服务器端套接字的 TLS 1.3 连接启用 PHA。</p>
<p>此方法不会立即执行证书交换。 服务器端会在下一次写入事件期间发送 CertificateRequest 并期待客户端在下一次读取事件期间附带证书进行响应。</p>
<p>如果有任何前置条件未被满足（例如非 TLS 1.3，PHA 未启用），则会引发 <code>SSLError</code>。</p>
<p>注解</p>
<p>仅在 OpenSSL 1.1.1 且 TLS 1.3 被启用时可用。 没有 TLS 1.3 支持，此方法将引发 <code>NotImplementedError</code>。</p>
<p>3.8 新版功能.</p>
<p><code>SSLSocket.version</code>()</p>
<p>以字符串形式返回由连接协商确定的实际 SSL 协议版本，或者如果未建立安全连接则返回 <code>None</code>。 在撰写本文档时，可能的返回值包括 <code>"SSLv2"</code>, <code>"SSLv3"</code>, <code>"TLSv1"</code>, <code>"TLSv1.1"</code> 和 <code>"TLSv1.2"</code>。 最新的 OpenSSL 版本可能会定义更多的返回值。</p>
<p>3.5 新版功能.</p>
<p><code>SSLSocket.pending</code>()</p>
<p>返回在连接上等待被读取的已解密字节数。</p>
<pre><code>SSLSocket.context</code></pre><p>此 SSL 套接字所联结的 <code>SSLContext</code> 对象。 如果 SSL 套接字是使用已弃用的 <code>wrap_socket()</code> 函数 (而非 <code>SSLContext.wrap_socket()</code>) 创建的，则这将是为此 SSL 套接字创建的自定义上下文对象。</p>
<p>3.2 新版功能.</p>
<pre><code>SSLSocket.server_side</code></pre><p>一个布尔值，对于服务器端套接字为 <code>True</code> 而对于客户端套接字则为 <code>False</code>。</p>
<p>3.2 新版功能.</p>
<pre><code>SSLSocket.server_hostname</code></pre><p>服务器的主机名: <code>str</code> 类型，对于服务器端套接字或者如果构造器中未指定主机名则为 <code>None</code>。</p>
<p>3.2 新版功能.</p>
<p>在 3.7 版更改: 现在该属性将始终为 ASCII 文本。 当 <code>server_hostname</code> 为一个国际化域名（IDN）时，该属性现在会保存为 A 标签形式 (<code>"xn--pythn-mua.org"</code>) 而非 U 标签形式 (<code>"pythön.org"</code>)。</p>
<pre><code>SSLSocket.session</code></pre><p>用于 SSL 连接的 <code>SSLSession</code>。 该会话将在执行 TLS 握手后对客户端和服务器端套接字可用。 对于客户端套接字该会话可以在调用 <code>do_handshake()</code> 之前被设置以重用一个会话。</p>
<p>3.6 新版功能.</p>
<pre><code>SSLSocket.session_reused</code></pre><p>3.6 新版功能.</p>
<h3 id="SSL-上下文"><a href="#SSL-上下文" class="headerlink" title="SSL 上下文"></a>SSL 上下文</h3><p>3.2 新版功能.</p>
<p>SSL 上下文可保存各种比单独 SSL 连接寿命更长的数据，例如 SSL 配置选项，证书和私钥等。 它还可为服务器端套接字管理缓存，以加快来自相同客户端的重复连接。</p>
<p><em>class</em> <code>ssl.SSLContext</code>(<em>protocol=None</em>)</p>
<p>创建一个新的 SSL 上下文。 你可以传入 <em>protocol</em>，它必须为此模块中定义的 <code>PROTOCOL_*</code> 常量之一。 该形参指定要使用哪个 SSL 协议版本。 通常，服务器会选择一个特定的协议版本，而客户端必须适应服务器的选择。 大多数版本都不能与其他版本互操作。 如果未指定，则默认值为 <code>PROTOCOL_TLS</code>；它提供了与其他版本的最大兼容性。</p>
<p>这个表显示了客户端（横向）的哪个版本能够连接服务器（纵向）的哪个版本。</p>
<blockquote>
<table>
<thead>
<tr>
<th><em>客户端</em> / <strong>服务器</strong></th>
<th><strong>SSLv2</strong></th>
<th><strong>SSLv3</strong></th>
<th><strong>TLS</strong></th>
<th><strong>TLSv1</strong></th>
<th><strong>TLSv1.1</strong></th>
<th><strong>TLSv1.2</strong></th>
</tr>
</thead>
<tbody><tr>
<td><em>SSLv2</em></td>
<td>是</td>
<td>否</td>
<td>否</td>
<td>否</td>
<td>否</td>
<td>否</td>
</tr>
<tr>
<td><em>SSLv3</em></td>
<td>否</td>
<td>是</td>
<td>否</td>
<td>否</td>
<td>否</td>
<td>否</td>
</tr>
<tr>
<td><em>TLS</em> (<em>SSLv23</em>)</td>
<td>否</td>
<td>否</td>
<td>是</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td><em>TLSv1</em></td>
<td>否</td>
<td>否</td>
<td>是</td>
<td>是</td>
<td>否</td>
<td>否</td>
</tr>
<tr>
<td><em>TLSv1.1</em></td>
<td>否</td>
<td>否</td>
<td>是</td>
<td>否</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td><em>TLSv1.2</em></td>
<td>否</td>
<td>否</td>
<td>是</td>
<td>否</td>
<td>否</td>
<td>是</td>
</tr>
</tbody></table>
</blockquote>
<p>参见</p>
<p><code>create_default_context()</code> 让 <code>ssl</code> 为特定目标选择安全设置。</p>
<p>在 3.6 版更改: 上下文会使用安全默认值来创建。 默认设置的选项有 <code>OP_NO_COMPRESSION</code>, <code>OP_CIPHER_SERVER_PREFERENCE</code>, <code>OP_SINGLE_DH_USE</code>, <code>OP_SINGLE_ECDH_USE</code>, <code>OP_NO_SSLv2</code> (except for <code>PROTOCOL_SSLv2</code>) 和 <code>OP_NO_SSLv3</code> (except for <code>PROTOCOL_SSLv3</code>)。 初始密码集列表只包含 <code>HIGH</code> 密码，不包含 <code>NULL</code> 密码和 <code>MD5</code> 密码 (<code>PROTOCOL_SSLv2</code> 除外)。</p>
<p>3.10 版后已移除: 不带协议参数的 <code>SSLContext</code> 已废弃。将来，上下文类会要求使用 <code>PROTOCOL_TLS_CLIENT</code> 或 <code>PROTOCOL_TLS_SERVER</code> 协议。</p>
<p>在 3.10 版更改: 现在默认的密码套件只包含安全的 AES 和 ChaCha20 密码，具有前向保密性和安全级别2。禁止使用少于 2048 位的 RSA 和 DH 密钥以及少于 224 位的ECC密钥。 <code>PROTOCOL_TLS</code> 、 <code>PROTOCOL_TLS_CLIENT</code> 和 <code>PROTOCOL_TLS_SERVER</code> 至少使用 TLS 1.2 版本。</p>
<p><code>SSLContext</code> 对象具有以下方法和属性:</p>
<p><code>SSLContext.cert_store_stats</code>()</p>
<p>获取以字典表示的有关已加载的 X.509 证书数量，被标记为 CA 证书的 X.509 证书数量以及证书吊销列表的统计信息。</p>
<p>具有一个 CA 证书和一个其他证书的上下文示例:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> context<span class="token punctuation">.</span>cert_store_stats<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span><span class="token string">'crl'</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">'x509_ca'</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'x509'</span><span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>3.4 新版功能.</p>
<p><code>SSLContext.load_cert_chain</code>(<em>certfile</em>, <em>keyfile=None</em>, <em>password=None</em>)</p>
<p>加载一个私钥及对应的证书。 <em>certfile</em> 字符串必须为以 PEM 格式表示的单个文件路径，该文件中包含证书以及确立证书真实性所需的任意数量的 CA 证书。 如果存在 <em>keyfile</em> 字符串，它必须指向一个包含私钥的文件。 否则私钥也将从 <em>certfile</em> 中提取。 </p>
<p><em>password</em> 参数可以是一个函数，调用时将得到用于解密私钥的密码。 它在私钥被加密且需要密码时才会被调用。 它调用时将不带任何参数，并且应当返回一个字符串、字节串或字节数组。 如果返回值是一个字符串，在用它解密私钥之前它将以 UTF-8 进行编码。 或者也可以直接将字符串、字节串或字节数组值作为 <em>password</em> 参数提供。 如果私钥未被加密且不需要密码则它将被忽略。</p>
<p>如果未指定 <em>password</em> 参数且需要一个密码，将会使用 OpenSSL 内置的密码提示机制来交互式地提示用户输入密码。</p>
<p>如果私钥不能匹配证书则会引发 <code>SSLError</code>。</p>
<p>在 3.3 版更改: 新增可选参数 <em>password</em>。</p>
<p><code>SSLContext.load_default_certs</code>(<em>purpose=Purpose.SERVER_AUTH</em>)</p>
<p>从默认位置加载一组默认的 “证书颁发机构” (CA) 证书。 在 Windows 上它将从 <code>CA</code> 和 <code>ROOT</code> 系统存储中加载 CA 证书。 在其他系统上它会调用 <code>SSLContext.set_default_verify_paths()</code>。 将来该方法也可能会从其他位置加载 CA 证书。</p>
<p><em>purpose</em> 旗标指明要加载哪一类 CA 证书。 默认设置 <code>Purpose.SERVER_AUTH</code> 加载被标记且被信任用于 TLS Web 服务器验证（客户端套接字）的证书。 <code>Purpose.CLIENT_AUTH</code> 则加载用于在服务器端进行客户端证书验证的 CA 证书。</p>
<p>3.4 新版功能.</p>
<p><code>SSLContext.load_verify_locations</code>(<em>cafile=None</em>, <em>capath=None</em>, <em>cadata=None</em>)</p>
<p>当 <code>verify_mode</code> 不为 <code>CERT_NONE</code> 时加载一组用于验证其他对等方证书的 “证书颁发机构” (CA) 证书。 必须至少指定 <em>cafile</em> 或 <em>capath</em> 中的一个。</p>
<p>此方法还可加载 PEM 或 DER 格式的证书吊销列表 (CRL)，为此必须正确配置 <code>SSLContext.verify_flags</code>。</p>
<p>如果存在 <em>cafile</em> 字符串，它应为 PEM 格式的级联 CA 证书文件的路径。 </p>
<p>如果存在 <em>capath</em> 字符串，它应为包含多个 PEM 格式的 CA 证书的目录的路径，并遵循 <a href="https://www.openssl.org/docs/manmaster/man3/SSL_CTX_load_verify_locations.html" target="_blank" rel="noopener">OpenSSL 专属布局</a>。</p>
<p>如果存在 <em>cadata</em> 对象，它应为一个或多个 PEM 编码的证书的 ASCII 字符串或者 DER 编码的证书的 bytes-like object。 与 <em>capath</em> 一样 PEM 编码的证书之外的多余行会被忽略，但至少要有一个证书。</p>
<p>在 3.4 版更改: 新增可选参数 <em>cadata</em></p>
<p><code>SSLContext.get_ca_certs</code>(<em>binary_form=False</em>)</p>
<p>获取已离开法人 “证书颁发机构” (CA) 证书列表。 如果 <code>binary_form</code> 形参为 <code>False</code> 则每个列表条目都是一个类似于 <code>SSLSocket.getpeercert()</code> 输出的字典。 在其他情况下此方法将返回一个 DER 编码的证书的列表。 返回的列表不包含来自 <em>capath</em> 的证书，除非 SSL 连接请求并加载了一个证书。</p>
<p>注解</p>
<p>capath 目录中的证书不会被加载，除非它们已至少被使用过一次。</p>
<p>3.4 新版功能.</p>
<p><code>SSLContext.get_ciphers</code>()</p>
<p>获取已启用密码的列表。 该列表将按密码的优先级排序。 </p>
<p>示例:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> ctx <span class="token operator">=</span> ssl<span class="token punctuation">.</span>SSLContext<span class="token punctuation">(</span>ssl<span class="token punctuation">.</span>PROTOCOL_SSLv23<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> ctx<span class="token punctuation">.</span>set_ciphers<span class="token punctuation">(</span><span class="token string">'ECDHE+AESGCM:!ECDSA'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> ctx<span class="token punctuation">.</span>get_ciphers<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token string">'aead'</span><span class="token punctuation">:</span> <span class="token boolean">True</span><span class="token punctuation">,</span>
  <span class="token string">'alg_bits'</span><span class="token punctuation">:</span> <span class="token number">256</span><span class="token punctuation">,</span>
  <span class="token string">'auth'</span><span class="token punctuation">:</span> <span class="token string">'auth-rsa'</span><span class="token punctuation">,</span>
  <span class="token string">'description'</span><span class="token punctuation">:</span> <span class="token string">'ECDHE-RSA-AES256-GCM-SHA384 TLSv1.2 Kx=ECDH     Au=RSA  '</span>
                 <span class="token string">'Enc=AESGCM(256) Mac=AEAD'</span><span class="token punctuation">,</span>
  <span class="token string">'digest'</span><span class="token punctuation">:</span> None<span class="token punctuation">,</span>
  <span class="token string">'id'</span><span class="token punctuation">:</span> <span class="token number">50380848</span><span class="token punctuation">,</span>
  <span class="token string">'kea'</span><span class="token punctuation">:</span> <span class="token string">'kx-ecdhe'</span><span class="token punctuation">,</span>
  <span class="token string">'name'</span><span class="token punctuation">:</span> <span class="token string">'ECDHE-RSA-AES256-GCM-SHA384'</span><span class="token punctuation">,</span>
  <span class="token string">'protocol'</span><span class="token punctuation">:</span> <span class="token string">'TLSv1.2'</span><span class="token punctuation">,</span>
  <span class="token string">'strength_bits'</span><span class="token punctuation">:</span> <span class="token number">256</span><span class="token punctuation">,</span>
  <span class="token string">'symmetric'</span><span class="token punctuation">:</span> <span class="token string">'aes-256-gcm'</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
 <span class="token punctuation">{</span><span class="token string">'aead'</span><span class="token punctuation">:</span> <span class="token boolean">True</span><span class="token punctuation">,</span>
  <span class="token string">'alg_bits'</span><span class="token punctuation">:</span> <span class="token number">128</span><span class="token punctuation">,</span>
  <span class="token string">'auth'</span><span class="token punctuation">:</span> <span class="token string">'auth-rsa'</span><span class="token punctuation">,</span>
  <span class="token string">'description'</span><span class="token punctuation">:</span> <span class="token string">'ECDHE-RSA-AES128-GCM-SHA256 TLSv1.2 Kx=ECDH     Au=RSA  '</span>
                 <span class="token string">'Enc=AESGCM(128) Mac=AEAD'</span><span class="token punctuation">,</span>
  <span class="token string">'digest'</span><span class="token punctuation">:</span> None<span class="token punctuation">,</span>
  <span class="token string">'id'</span><span class="token punctuation">:</span> <span class="token number">50380847</span><span class="token punctuation">,</span>
  <span class="token string">'kea'</span><span class="token punctuation">:</span> <span class="token string">'kx-ecdhe'</span><span class="token punctuation">,</span>
  <span class="token string">'name'</span><span class="token punctuation">:</span> <span class="token string">'ECDHE-RSA-AES128-GCM-SHA256'</span><span class="token punctuation">,</span>
  <span class="token string">'protocol'</span><span class="token punctuation">:</span> <span class="token string">'TLSv1.2'</span><span class="token punctuation">,</span>
  <span class="token string">'strength_bits'</span><span class="token punctuation">:</span> <span class="token number">128</span><span class="token punctuation">,</span>
  <span class="token string">'symmetric'</span><span class="token punctuation">:</span> <span class="token string">'aes-128-gcm'</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>3.6 新版功能.</p>
<p><code>SSLContext.set_default_verify_paths</code>()</p>
<p>从构建 OpenSSL 库时定义的文件系统路径中加载一组默认的 “证书颁发机构” (CA) 证书。 不幸的是，没有一种简单的方式能知道此方法是否执行成功：如果未找到任何证书也不会返回错误。 不过，当 OpenSSL 库是作为操作系统的一部分被提供时，它的配置应当是正确的。</p>
<p><code>SSLContext.set_ciphers</code>(<em>ciphers</em>)</p>
<p>为使用此上下文创建的套接字设置可用密码。 它应当为 <a href="https://www.openssl.org/docs/manmaster/man1/ciphers.html" target="_blank" rel="noopener">OpenSSL 密码列表格式</a> 的字符串。 如果没有可被选择的密码（由于编译时选项或其他配置禁止使用所指定的任何密码），则将引发 <code>SSLError</code>。</p>
<p>注解</p>
<p>在连接后，SSL 套接字的 <code>SSLSocket.cipher()</code> 方法将给出当前所选择的密码。</p>
<p>TLS 1.3 密码套件不能通过 <code>set_ciphers()</code> 禁用。</p>
<p><code>SSLContext.set_alpn_protocols</code>(<em>protocols</em>)</p>
<p>指定在 SSL/TLS 握手期间套接字应当通告的协议。 它应为由 ASCII 字符串组成的列表，例如 <code>['http/1.1', 'spdy/2']</code>，按首选顺序排列。 协议的选择将在握手期间发生，并依据 <a href="https://tools.ietf.org/html/rfc7301.html" target="_blank" rel="noopener"><strong>RFC 7301</strong></a> 来执行。 在握手成功后，<code>SSLSocket.selected_alpn_protocol()</code> 方法将返回已达成一致的协议。</p>
<p>如果 <code>HAS_ALPN</code> 为 <code>False</code> 则此方法将引发 <code>NotImplementedError</code>。</p>
<p>3.5 新版功能.</p>
<p><code>SSLContext.set_npn_protocols</code>(<em>protocols</em>)</p>
<p>指定在Specify which protocols the socket should advertise during the SSL/TLS 握手期间套接字应当通告的协议。 它应为由字符串组成的列表，例如 <code>['http/1.1', 'spdy/2']</code>，按首选顺序排列。 协议的选择将在握手期间发生，并将依据 <a href="https://en.wikipedia.org/wiki/Application-Layer_Protocol_Negotiation" target="_blank" rel="noopener">应用层协议协商</a> 来执行。 在握手成功后，<code>SSLSocket.selected_npn_protocol()</code> 方法将返回已达成一致的协议。</p>
<p>如果 <code>HAS_NPN</code> 为 <code>False</code> 则此方法将引发 <code>NotImplementedError</code>。</p>
<p>3.3 新版功能.</p>
<p>3.10 版后已移除: NPN 已被 ALPN 取代。</p>
<pre><code>SSLContext.sni_callback</code></pre><p>注册一个回调函数，当 TLS 客户端指定了一个服务器名称提示时，该回调函数将在 SSL/TLS 服务器接收到 TLS Client Hello 握手消息后被调用。 服务器名称提示机制的定义见 <a href="https://tools.ietf.org/html/rfc6066.html" target="_blank" rel="noopener"><strong>RFC 6066</strong></a> section 3 - Server Name Indication。</p>
<p>每个 <code>SSLContext</code> 只能设置一个回调。 如果 <em>sni_callback</em> 被设置为 <code>None</code> 则会禁用回调。 对该函数的后续调用将禁用之前注册的回调。</p>
<p>此回调函数将附带三个参数来调用；第一个参数是 <code>ssl.SSLSocket</code>，第二个参数是代表客户端准备与之通信的服务器的字符串 (或者如果 TLS Client Hello 不包含服务器名称则为 <code>None</code>) 而第三个参数是原来的 <code>SSLContext</code>。 服务器名称参数为文本形式。 对于国际化域名，服务器名称是一个 IDN A 标签 (<code>"xn--pythn-mua.org"</code>)。</p>
<p>此回调的一个典型用法是将 <code>ssl.SSLSocket</code> 的 <code>SSLSocket.context</code> 属性修改为一个 <code>SSLContext</code> 类型的新对象，该对象代表与服务器相匹配的证书链。</p>
<p>由于 TLS 连接处于早期协商阶段，因此仅能使用有限的方法和属性例如 <code>SSLSocket.selected_alpn_protocol()</code> 和 <code>SSLSocket.context</code>。 <code>SSLSocket.getpeercert()</code>, <code>SSLSocket.getpeercert()</code>, <code>SSLSocket.cipher()</code> 和 <code>SSLSocket.compress()</code> 方法要求 TLS 连接已经过 TLS Client Hello 因而将既不包含返回有意义的值，也不能安全地调用它们。</p>
<p><em>sni_callback</em> 函数必须返回 <code>None</code> 以允许 TLS 协商继续进行。 如果想要 TLS 失败，则可以返回常量 <code>ALERT_DESCRIPTION_*</code>。 其他返回值将导致 TLS 的致命错误 <code>ALERT_DESCRIPTION_INTERNAL_ERROR</code>。</p>
<p>如果从 <em>sni_callback</em> 函数引发了异常，则 TLS 连接将终止并发出 TLS 致命警告消息 <code>ALERT_DESCRIPTION_HANDSHAKE_FAILURE</code>。</p>
<p>如果 OpenSSL library 库在构建时定义了 OPENSSL_NO_TLSEXT 则此方法将返回 <code>NotImplementedError</code>。</p>
<p>3.7 新版功能.</p>
<p><code>SSLContext.set_servername_callback</code>(<em>server_name_callback</em>)</p>
<p>这是被保留用于向下兼容的旧式 API。 在可能的情况下，你应当改用 <code>sni_callback</code>。 给出的 <em>server_name_callback</em> 类似于 <em>sni_callback<em>，不同之处在于当服务器主机名是 IDN 编码的国际化域名时，</em>server_name_callback</em> 会接收到一个已编码的 U 标签 (<code>"pythön.org"</code>)。</p>
<p>如果发生了服务器名称解码错误。 TLS 连接将终止并向客户端发出 <code>ALERT_DESCRIPTION_INTERNAL_ERROR</code> 最严重 TLS 警告消息。</p>
<p>3.4 新版功能.</p>
<p><code>SSLContext.load_dh_params</code>(<em>dhfile</em>)</p>
<p>加载密钥生成参数用于 Diffie-Hellman (DH) 密钥交换。 使用 DH 密钥交换能以消耗（服务器和客户端的）计算资源为代价提升前向保密性。 <em>dhfile</em> 参数应当为指向一个包含 PEM 格式的 DH 形参的文件的路径。</p>
<p>此设置不会应用于客户端套接字。 你还可以使用 <code>OP_SINGLE_DH_USE</code> 选项来进一步提升安全性。</p>
<p>3.3 新版功能.</p>
<p><code>SSLContext.set_ecdh_curve</code>(<em>curve_name</em>)</p>
<p>为基于椭圆曲线的 Elliptic Curve-based Diffie-Hellman (ECDH) 密钥交换设置曲线名称。 ECDH 显著快于常规 DH 同时据信同样安全。 <em>curve_name</em> 形参应为描述某个知名椭圆曲线的字符串，例如受到广泛支持的曲线 <code>prime256v1</code>。</p>
<p>此设置不会应用于客户端套接字。 你还可以使用 <code>OP_SINGLE_ECDH_USE</code> 选项来进一步提升安全性。</p>
<p>如果 <code>HAS_ECDH</code> 为 <code>False</code> 则此方法将不可用。</p>
<p>3.3 新版功能.</p>
<p>参见</p>
<ul>
<li><p><a href="https://vincent.bernat.im/en/blog/2011-ssl-perfect-forward-secrecy" target="_blank" rel="noopener">SSL/TLS 与完美的前向保密性</a></p>
<p>Vincent Bernat。</p>
</li>
</ul>
<p><code>SSLContext.wrap_socket</code>(<em>sock</em>, <em>server_side=False</em>, <em>do_handshake_on_connect=True</em>, <em>suppress_ragged_eofs=True</em>, <em>server_hostname=None</em>, <em>session=None</em>)</p>
<p>包装一个现有的 Python 套接字 <em>sock</em> 并返回一个 <code>SSLContext.sslsocket_class</code> 的实例 (默认为 <code>SSLSocket</code>)。 返回的 SSL 套接字会绑定上下文、设置以及证书。 <em>sock</em> 必须是一个 <code>SOCK_STREAM</code> 套接字；其他套接字类型不被支持。</p>
<p>形参 <code>server_side</code> 是一个布尔值，它标明希望从该套接字获得服务器端行为还是客户端行为。</p>
<p>对于客户端套接字，上下文的构造会延迟执行；如果下层的套接字尚未连接，上下文的构造将在对套接字调用 <code>connect()</code> 之后执行。 对于服务器端套接字，如果套接字没有远端对等方，它会被视为一个监听套接字，并且服务器端 SSL 包装操作会在通过 <code>accept()</code> 方法所接受的客户端连接上自动执行。 此方法可能会引发 <code>SSLError</code>。</p>
<p>在客户端连接上，可选形参 <em>server_hostname</em> 指定所要连接的服务的主机名。 这允许单个服务器托管具有单独证书的多个基于 SSL 的服务，很类似于 HTTP 虚拟主机。 如果 <em>server_side</em> 为真值则指定 <em>server_hostname</em> 将引发 <code>ValueError</code>。</p>
<p>形参 <code>do_handshake_on_connect</code> 指明是否要在调用 <code>socket.connect()</code> 之后自动执行 SSL 握手，还是要通过发起调用 <code>SSLSocket.do_handshake()</code> 方法让应用程序显式地调用它。 显式地调用 <code>SSLSocket.do_handshake()</code> 可给予程序对握手中所涉及的套接字 I/O 阻塞行为的控制。</p>
<p>形参 <code>suppress_ragged_eofs</code> 指明 <code>SSLSocket.recv()</code> 方法应当如何从连接的另一端发送非预期的 EOF 信号。 如果指定为 <code>True</code> (默认值)，它将返回正常的 EOF (空字节串对象) 来响应从下层套接字引发的非预期的 EOF 错误；如果指定为 <code>False</code>，它将向调用方引发异常。</p>
<p><em>session</em>，参见 <code>session</code>。</p>
<p>在 3.5 版更改: 总是允许传送 server_hostname，即使 OpenSSL 没有 SNI。</p>
<p>在 3.6 版更改: 增加了 <em>session</em> 参数。</p>
<p>在 3.7 版更改: 此方法返回 <code>SSLContext.sslsocket_class</code> 的实例而非硬编码的 <code>SSLSocket</code>。</p>
<pre><code>SSLContext.sslsocket_class</code></pre><p><code>SSLContext.wrap_socket()</code> 的返回类型，默认为 <code>SSLSocket</code>。 该属性可以在类实例上被重载以便返回自定义的 <code>SSLSocket</code> 的子类。</p>
<p>3.7 新版功能.</p>
<p><code>SSLContext.wrap_bio</code>(<em>incoming</em>, <em>outgoing</em>, <em>server_side=False</em>, <em>server_hostname=None</em>, <em>session=None</em>)</p>
<p>包装 BIO 对象 <em>incoming</em> 和 <em>outgoing</em> 并返回一个 <code>SSLContext.sslobject_class</code> (默认为 <code>SSLObject</code>) 的实例。 SSL 例程将从 BIO 中读取输入数据并将数据写入到 outgoing BIO。</p>
<p><em>server_side</em>, <em>server_hostname</em> 和 <em>session</em> 形参具有与 <code>SSLContext.wrap_socket()</code> 中相同的含义。</p>
<p>在 3.6 版更改: 增加了 <em>session</em> 参数。</p>
<p>在 3.7 版更改: 此方法返回 <code>SSLContext.sslobject_class</code> 的实例则非硬编码的 <code>SSLObject</code>。</p>
<pre><code>SSLContext.sslobject_class</code></pre><p><code>SSLContext.wrap_bio()</code> 的返回类型，默认为 <code>SSLObject</code>。 该属性可以在类实例上被重载以便返回自定义的 <code>SSLObject</code> 的子类。</p>
<p>3.7 新版功能.</p>
<p><code>SSLContext.session_stats</code>()</p>
<p>获取该上下文创建或管理的 SSL 会话的统计数据。返回一个字典，将每<code>块信息 &lt;https://www.openssl.org/docs/man1.1.1/ssl/SSL_CTX_sess_number.html&gt;</code>_ 映射到数字值。例如，下面是自该上下文创建以来会话缓存中的总点击率和失误率：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> stats <span class="token operator">=</span> context<span class="token punctuation">.</span>session_stats<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> stats<span class="token punctuation">[</span><span class="token string">'hits'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> stats<span class="token punctuation">[</span><span class="token string">'misses'</span><span class="token punctuation">]</span>
<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>是否要将匹配 <code>SSLSocket.do_handshake()</code> 中对等方证书的主机名。 该上下文的 <code>verify_mode</code> 必须被设为 <code>CERT_OPTIONAL</code> 或 <code>CERT_REQUIRED</code>，并且你必须将 <em>server_hostname</em> 传给 <code>wrap_socket()</code> 以便匹配主机名。 启用主机名检查会自动将 <code>verify_mode</code> 从 <code>CERT_NONE</code> 设为 <code>CERT_REQUIRED</code>。 只要启用了主机名检查就无法将其设回 <code>CERT_NONE</code>。 <code>PROTOCOL_TLS_CLIENT</code> 协议默认启用主机名检查。 对于其他协议，则必须显式地启用主机名检查。</p>
<p>示例:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> socket<span class="token punctuation">,</span> ssl
context <span class="token operator">=</span> ssl<span class="token punctuation">.</span>SSLContext<span class="token punctuation">(</span>ssl<span class="token punctuation">.</span>PROTOCOL_TLSv1_2<span class="token punctuation">)</span>
context<span class="token punctuation">.</span>verify_mode <span class="token operator">=</span> ssl<span class="token punctuation">.</span>CERT_REQUIRED
context<span class="token punctuation">.</span>check_hostname <span class="token operator">=</span> <span class="token boolean">True</span>
context<span class="token punctuation">.</span>load_default_certs<span class="token punctuation">(</span><span class="token punctuation">)</span>
s <span class="token operator">=</span> socket<span class="token punctuation">.</span>socket<span class="token punctuation">(</span>socket<span class="token punctuation">.</span>AF_INET<span class="token punctuation">,</span> socket<span class="token punctuation">.</span>SOCK_STREAM<span class="token punctuation">)</span>
ssl_sock <span class="token operator">=</span> context<span class="token punctuation">.</span>wrap_socket<span class="token punctuation">(</span>s<span class="token punctuation">,</span> server_hostname<span class="token operator">=</span><span class="token string">'www.verisign.com'</span><span class="token punctuation">)</span>
ssl_sock<span class="token punctuation">.</span>connect<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">'www.verisign.com'</span><span class="token punctuation">,</span> <span class="token number">443</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>3.4 新版功能.</p>
<p>在 3.7 版更改: 现在当主机名检查被启用且 <code>verify_mode</code> 为 <code>CERT_NONE</code> 时 <code>verify_mode</code> 会自动更改为 <code>CERT_REQUIRED</code>。 在之前版本中同样的操作将失败并引发 <code>ValueError</code>。</p>
<pre><code>SSLContext.keylog_filename</code></pre><p>每当生成或接收到密钥时，将 TLS 密钥写入到一个密钥日志文件。 密钥日志文件的设计仅适用于调试目的。 文件的格式由 NSS 指明并为许多流量分析工具例如 Wireshark 所使用。 日志文件会以追加模式打开。 写入操作会在线程之间同步，但不会在进程之间同步。</p>
<p>3.8 新版功能.</p>
<pre><code>SSLContext.maximum_version</code></pre><p>一个代表所支持的最高 TLS 版本的 <code>TLSVersion</code> 枚举成员。 该值默认为 <code>TLSVersion.MAXIMUM_SUPPORTED</code>。 这个属性对于 <code>PROTOCOL_TLS</code>, <code>PROTOCOL_TLS_CLIENT</code> 和 <code>PROTOCOL_TLS_SERVER</code> 以外的其他协议来说都是只读的。</p>
<p><code>maximum_version</code>, <code>minimum_version</code> 和 <code>SSLContext.options</code> 等属性都会影响上下文所支持的 SSL 和 TLS 版本。 这个实现不会阻止无效的组合。 例如一个 <code>options</code> 为 <code>OP_NO_TLSv1_2</code> 而 <code>maximum_version</code> 设为 <code>TLSVersion.TLSv1_2</code> 的上下文将无法建立 TLS 1.2 连接。</p>
<p>3.7 新版功能.</p>
<pre><code>SSLContext.minimum_version</code></pre><p>与 <code>SSLContext.maximum_version</code> 类似，区别在于它是所支持的最低版本或为 <code>TLSVersion.MINIMUM_SUPPORTED</code>。</p>
<p>3.7 新版功能.</p>
<pre><code>SSLContext.num_tickets</code></pre><p>控制 <code>TLS_PROTOCOL_SERVER</code> 上下文的 TLS 1.3 会话凭据数量。这个设置不会影响 TLS 1.0 - 1.2 的连接。</p>
<p>3.8 新版功能.</p>
<pre><code>SSLContext.options</code></pre><p>一个代表此上下文中所启用的 SSL 选项集的整数。 默认值为 <code>OP_ALL</code>，但你也可以通过在选项间进行 OR 运算来指定其他选项例如 <code>OP_NO_SSLv2</code>。</p>
<p>在 3.6 版更改: <code>SSLContext.options</code> 返回 <code>Options</code> 旗标:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> ssl<span class="token punctuation">.</span>create_default_context<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>options  
<span class="token operator">&lt;</span>Options<span class="token punctuation">.</span>OP_ALL<span class="token operator">|</span>OP_NO_SSLv3<span class="token operator">|</span>OP_NO_SSLv2<span class="token operator">|</span>OP_NO_COMPRESSION<span class="token punctuation">:</span> <span class="token number">2197947391</span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>3.7 版后已移除: 自 OpenSSL 1.1.0 起，所有 <code>OP_NO_SSL*</code> 和 <code>OP_NO_TLS*</code> 选项已被弃用，请改用新的 <code>SSLContext.minimum_version</code> 和 <code>SSLContext.maximum_version</code>。</p>
<pre><code>SSLContext.post_handshake_auth</code></pre><p>启用 TLS 1.3 握手后客户端身份验证。 握手后验证默认是被禁用的，服务器只能在初始握手期间请求 TLS 客户端证书。 当启用时，服务器可以在握手之后的任何时候请求 TLS 客户端证书。</p>
<p>当在客户端套接字上启用时，客户端会向服务器发信号说明它支持握手后身份验证。</p>
<p>当在服务器端套接字上启用时，<code>SSLContext.verify_mode</code> 也必须被设为 <code>CERT_OPTIONAL</code> 或 <code>CERT_REQUIRED</code>。 实际的客户端证书交换会被延迟直至 <code>SSLSocket.verify_client_post_handshake()</code> 被调用并执行了一些 I/O 操作后再进行。</p>
<p>3.8 新版功能.</p>
<pre><code>SSLContext.protocol</code></pre><p>构造上下文时所选择的协议版本。 这个属性是只读的。</p>
<pre><code>SSLContext.hostname_checks_common_name</code></pre><p>在没有目标替代名称扩展的情况下 <code>check_hostname</code> 是否要回退为验证证书的通用名称（默认为真值）。</p>
<p>3.7 新版功能.</p>
<p>在 3.10 版更改: 此旗标在 OpenSSL 1.1.1k 之前的版本上不起作用。 Python 3.8.9, 3.9.3, 和 3.10 包含了针对之前版本的变通处理。</p>
<pre><code>SSLContext.security_level</code></pre><p>整数值，代表上下文的 <a href="https://www.openssl.org/docs/manmaster/man3/SSL_CTX_get_security_level.html" target="_blank" rel="noopener">安全级别</a>。 本属性只读。</p>
<p>3.10 新版功能.</p>
<pre><code>SSLContext.verify_flags</code></pre><p>证书验证操作的标志位。可以用“或”的方式组合在一起设置 <code>VERIFY_CRL_CHECK_LEAF</code> 这类标志。默认情况下，OpenSSL 既不需要也不验证证书吊销列表（CRL）。</p>
<p>3.4 新版功能.</p>
<p>在 3.6 版更改: <code>SSLContext.verify_flags</code> 返回 <code>VerifyFlags</code> 旗标:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> ssl<span class="token punctuation">.</span>create_default_context<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>verify_flags  
<span class="token operator">&lt;</span>VerifyFlags<span class="token punctuation">.</span>VERIFY_X509_TRUSTED_FIRST<span class="token punctuation">:</span> <span class="token number">32768</span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>是否要尝试验证其他对等方的证书以及如果验证失败应采取何种行为。 该属性值必须为 <code>CERT_NONE</code>, <code>CERT_OPTIONAL</code> 或 <code>CERT_REQUIRED</code> 之一。</p>
<p>在 3.6 版更改: <code>SSLContext.verify_mode</code> 返回 <code>VerifyMode</code> 枚举:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> ssl<span class="token punctuation">.</span>create_default_context<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>verify_mode
<span class="token operator">&lt;</span>VerifyMode<span class="token punctuation">.</span>CERT_REQUIRED<span class="token punctuation">:</span> <span class="token number">2</span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h3 id="证书"><a href="#证书" class="headerlink" title="证书"></a>证书</h3><p>总的来说证书是公钥/私钥系统的一个组成部分。 在这个系统中，每 个 <em>主体</em> (可能是一台机器、一个人或者一个组织) 都会分配到唯一的包含两部分的加密密钥。 一部分密钥是公开的，称为 <em>公钥</em>；另一部分密钥是保密的，称为 <em>私钥</em>。 这两个部分是互相关联的，就是说如果你用其中一个部分来加密一条消息，你将能用并且 <strong>只能</strong> 用另一个部分来解密它。</p>
<p>在一个证书中包含有两个主体的相关信息。 它包含 <em>目标方</em> 的名称和目标方的公钥。 它还包含由第二个主体 <em>颁发方</em> 所发布的声明：目标方的身份与他们所宣称的一致，包含的公钥也确实是目标方的公钥。 颁发方的声明使用颁发方的私钥进行签名，该私钥的内容只有颁发方自己才知道。 但是，任何人都可以找到颁发方的公钥，用它来解密这个声明，并将其与证书中的其他信息进行比较来验证颁发方声明的真实性。 证书还包含有关其有效期限的信息。 这被表示为两个字段，即 “notBefore” 和 “notAfter”。</p>
<p>在 Python 中应用证书时，客户端或服务器可以用证书来证明自己的身份。 还可以要求网络连接的另一方提供证书，提供的证书可以用于验证以满足客户端或服务器的验证要求。 如果验证失败，连接尝试可被设置为引发一个异常。 验证是由下层的 OpenSSL 框架来自动执行的；应用程序本身不必关注其内部的机制。 但是应用程序通常需要提供一组证书以允许此过程的发生。</p>
<p>Python 使用文件来包含证书。 它们应当采用 “PEM” 格式 (参见 <a href="https://tools.ietf.org/html/rfc1422.html" target="_blank" rel="noopener"><strong>RFC 1422</strong></a>)，这是一种带有头部行和尾部行的 base-64 编码包装形式:</p>
<pre><code>-----BEGIN CERTIFICATE-----
... (certificate in base64 PEM encoding) ...
-----END CERTIFICATE-----</code></pre><h4 id="证书链"><a href="#证书链" class="headerlink" title="证书链"></a>证书链</h4><p>包含证书的 Python 文件可以包含一系列的证书，有时被称为 <em>证书链*。 这个证书链应当以 “作为” 客户端或服务器的主体的专属证书打头，然后是证书颁发方的证书，然后是 *上述</em> 证书的颁发方的证书，证书链就这样不断上溯直到你得到一个 <em>自签名</em> 的证书，即具有相同目标方和颁发方的证书，有时也称为 <em>根证书</em>。 在证书文件中这些证书应当被拼接为一体。 例如，假设我们有一个包含三个证书的证书链，以我们的服务器证书打头，然后是为我们的服务器证书签名的证书颁发机构的证书，最后是为证书颁发机构的证书颁发证书的机构的根证书:</p>
<pre><code>-----BEGIN CERTIFICATE-----
... (certificate for your server)...
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
... (the certificate for the CA)...
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
... (the root certificate for the CA's issuer)...
-----END CERTIFICATE-----</code></pre><h4 id="CA-证书"><a href="#CA-证书" class="headerlink" title="CA 证书"></a>CA 证书</h4><p>如果你想要求对连接的另一方的证书进行验证，你必须提供一个 “CA 证书” 文件，其中包含了你愿意信任的每个颁发方的证书链。 同样地，这个文件的内容就是这些证书链拼接在一起的结果。 为了进行验证，Python 将使用它在文件中找到的第一个匹配的证书链。 可以通过调用 <code>SSLContext.load_default_certs()</code> 来使用系统平台的证书文件，这可以由 <code>create_default_context()</code> 自动完成。</p>
<h4 id="合并的密钥和证书"><a href="#合并的密钥和证书" class="headerlink" title="合并的密钥和证书"></a>合并的密钥和证书</h4><p>私钥往往与证书存储在相同的文件中；在此情况下，只需要将 <code>certfile</code> 形参传给 <code>SSLContext.load_cert_chain()</code> 和 <code>wrap_socket()</code>。 如果私钥是与证书一起存储的，则它应当放在证书链的第一个证书之前:</p>
<pre><code>-----BEGIN RSA PRIVATE KEY-----
... (private key in base64 encoding) ...
-----END RSA PRIVATE KEY-----
-----BEGIN CERTIFICATE-----
... (certificate in base64 PEM encoding) ...
-----END CERTIFICATE-----</code></pre><h4 id="自签名证书"><a href="#自签名证书" class="headerlink" title="自签名证书"></a>自签名证书</h4><p>如果你准备创建一个提供 SSL 加密连接服务的服务器，你需要为该服务获取一份证书。 有许多方式可以获取合适的证书，例如从证书颁发机构购买。 另一种常见做法是生成自签名证书。 生成自签名证书的最简单方式是使用 OpenSSL 软件包，代码如下所示:</p>
<pre><code>% openssl req -new -x509 -days 365 -nodes -out cert.pem -keyout cert.pem
Generating a 1024 bit RSA private key
.......++++++
.............................++++++
writing new private key to 'cert.pem'
-----
You are about to be asked to enter information that will be incorporated
into your certificate request.
What you are about to enter is what is called a Distinguished Name or a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter '.', the field will be left blank.
-----
Country Name (2 letter code) [AU]:US
State or Province Name (full name) [Some-State]:MyState
Locality Name (eg, city) []:Some City
Organization Name (eg, company) [Internet Widgits Pty Ltd]:My Organization, Inc.
Organizational Unit Name (eg, section) []:My Group
Common Name (eg, YOUR name) []:myserver.mygroup.myorganization.com
Email Address []:ops@myserver.mygroup.myorganization.com
%</code></pre><p>自签名证书的缺点在于它是它自身的根证书，因此不会存在于别人的已知（且信任的）根证书缓存当中。</p>
<h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h3><h4 id="检测-SSL-支持"><a href="#检测-SSL-支持" class="headerlink" title="检测 SSL 支持"></a>检测 SSL 支持</h4><p>要检测一个 Python 安装版中是否带有 SSL 支持，用户代码应当使用以下例程:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">try</span><span class="token punctuation">:</span>
    <span class="token keyword">import</span> ssl
<span class="token keyword">except</span> ImportError<span class="token punctuation">:</span>
    <span class="token keyword">pass</span>
<span class="token keyword">else</span><span class="token punctuation">:</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  <span class="token comment" spellcheck="true"># do something that requires SSL support</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="客户端操作"><a href="#客户端操作" class="headerlink" title="客户端操作"></a>客户端操作</h4><p>这个例子创建了一个 SSL 上下文并使用客户端套接字的推荐安全设置，包括自动证书验证:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> context <span class="token operator">=</span> ssl<span class="token punctuation">.</span>create_default_context<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>如果你喜欢自行调整安全设置，你可能需要从头创建一个上下文（但是请请注意避免不正确的设置）:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> context <span class="token operator">=</span> ssl<span class="token punctuation">.</span>SSLContext<span class="token punctuation">(</span>ssl<span class="token punctuation">.</span>PROTOCOL_TLS_CLIENT<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> context<span class="token punctuation">.</span>load_verify_locations<span class="token punctuation">(</span><span class="token string">"/etc/ssl/certs/ca-bundle.crt"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>(这段代码假定你的操作系统将所有 CA 证书打包存放于 <code>/etc/ssl/certs/ca-bundle.crt</code>；如果不是这样，你将收到报错信息，必须修改此位置)</p>
<p><code>PROTOCOL_TLS_CLIENT</code> 协议配置用于证书验证和主机名验证的上下文。 <code>verify_mode</code> 设为 <code>CERT_REQUIRED</code> 而 <code>check_hostname</code> 设为 <code>True</code>。 所有其他协议都会使用不安全的默认值创建 SSL 上下文。</p>
<p>当你使用此上下文去连接服务器时，<code>CERT_REQUIRED</code> 和 <code>check_hostname</code> 会验证服务器证书；它将确认服务器证书使用了某个 CA 证书进行签名，检查签名是否正确，并验证其他属性例如主机名的有效性和身份真实性:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> conn <span class="token operator">=</span> context<span class="token punctuation">.</span>wrap_socket<span class="token punctuation">(</span>socket<span class="token punctuation">.</span>socket<span class="token punctuation">(</span>socket<span class="token punctuation">.</span>AF_INET<span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                            server_hostname<span class="token operator">=</span><span class="token string">"www.python.org"</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> conn<span class="token punctuation">.</span>connect<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">"www.python.org"</span><span class="token punctuation">,</span> <span class="token number">443</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>你可以随后获取该证书:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> cert <span class="token operator">=</span> conn<span class="token punctuation">.</span>getpeercert<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>可视化检查显示证书能够证明目标服务 (即 HTTPS 主机 <code>www.python.org</code>) 的身份:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> pprint<span class="token punctuation">.</span>pprint<span class="token punctuation">(</span>cert<span class="token punctuation">)</span>
<span class="token punctuation">{</span><span class="token string">'OCSP'</span><span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token string">'http://ocsp.digicert.com'</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
 <span class="token string">'caIssuers'</span><span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token string">'http://cacerts.digicert.com/DigiCertSHA2ExtendedValidationServerCA.crt'</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
 <span class="token string">'crlDistributionPoints'</span><span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token string">'http://crl3.digicert.com/sha2-ev-server-g1.crl'</span><span class="token punctuation">,</span>
                           <span class="token string">'http://crl4.digicert.com/sha2-ev-server-g1.crl'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
 <span class="token string">'issuer'</span><span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">'countryName'</span><span class="token punctuation">,</span> <span class="token string">'US'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
            <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">'organizationName'</span><span class="token punctuation">,</span> <span class="token string">'DigiCert Inc'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
            <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">'organizationalUnitName'</span><span class="token punctuation">,</span> <span class="token string">'www.digicert.com'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
            <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">'commonName'</span><span class="token punctuation">,</span> <span class="token string">'DigiCert SHA2 Extended Validation Server CA'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
 <span class="token string">'notAfter'</span><span class="token punctuation">:</span> <span class="token string">'Sep  9 12:00:00 2016 GMT'</span><span class="token punctuation">,</span>
 <span class="token string">'notBefore'</span><span class="token punctuation">:</span> <span class="token string">'Sep  5 00:00:00 2014 GMT'</span><span class="token punctuation">,</span>
 <span class="token string">'serialNumber'</span><span class="token punctuation">:</span> <span class="token string">'01BB6F00122B177F36CAB49CEA8B6B26'</span><span class="token punctuation">,</span>
 <span class="token string">'subject'</span><span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">'businessCategory'</span><span class="token punctuation">,</span> <span class="token string">'Private Organization'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
             <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">'1.3.6.1.4.1.311.60.2.1.3'</span><span class="token punctuation">,</span> <span class="token string">'US'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
             <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">'1.3.6.1.4.1.311.60.2.1.2'</span><span class="token punctuation">,</span> <span class="token string">'Delaware'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
             <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">'serialNumber'</span><span class="token punctuation">,</span> <span class="token string">'3359300'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
             <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">'streetAddress'</span><span class="token punctuation">,</span> <span class="token string">'16 Allen Rd'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
             <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">'postalCode'</span><span class="token punctuation">,</span> <span class="token string">'03894-4801'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
             <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">'countryName'</span><span class="token punctuation">,</span> <span class="token string">'US'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
             <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">'stateOrProvinceName'</span><span class="token punctuation">,</span> <span class="token string">'NH'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
             <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">'localityName'</span><span class="token punctuation">,</span> <span class="token string">'Wolfeboro'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
             <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">'organizationName'</span><span class="token punctuation">,</span> <span class="token string">'Python Software Foundation'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
             <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">'commonName'</span><span class="token punctuation">,</span> <span class="token string">'www.python.org'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
 <span class="token string">'subjectAltName'</span><span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">'DNS'</span><span class="token punctuation">,</span> <span class="token string">'www.python.org'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                    <span class="token punctuation">(</span><span class="token string">'DNS'</span><span class="token punctuation">,</span> <span class="token string">'python.org'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                    <span class="token punctuation">(</span><span class="token string">'DNS'</span><span class="token punctuation">,</span> <span class="token string">'pypi.org'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                    <span class="token punctuation">(</span><span class="token string">'DNS'</span><span class="token punctuation">,</span> <span class="token string">'docs.python.org'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                    <span class="token punctuation">(</span><span class="token string">'DNS'</span><span class="token punctuation">,</span> <span class="token string">'testpypi.org'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                    <span class="token punctuation">(</span><span class="token string">'DNS'</span><span class="token punctuation">,</span> <span class="token string">'bugs.python.org'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                    <span class="token punctuation">(</span><span class="token string">'DNS'</span><span class="token punctuation">,</span> <span class="token string">'wiki.python.org'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                    <span class="token punctuation">(</span><span class="token string">'DNS'</span><span class="token punctuation">,</span> <span class="token string">'hg.python.org'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                    <span class="token punctuation">(</span><span class="token string">'DNS'</span><span class="token punctuation">,</span> <span class="token string">'mail.python.org'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                    <span class="token punctuation">(</span><span class="token string">'DNS'</span><span class="token punctuation">,</span> <span class="token string">'packaging.python.org'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                    <span class="token punctuation">(</span><span class="token string">'DNS'</span><span class="token punctuation">,</span> <span class="token string">'pythonhosted.org'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                    <span class="token punctuation">(</span><span class="token string">'DNS'</span><span class="token punctuation">,</span> <span class="token string">'www.pythonhosted.org'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                    <span class="token punctuation">(</span><span class="token string">'DNS'</span><span class="token punctuation">,</span> <span class="token string">'test.pythonhosted.org'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                    <span class="token punctuation">(</span><span class="token string">'DNS'</span><span class="token punctuation">,</span> <span class="token string">'us.pycon.org'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                    <span class="token punctuation">(</span><span class="token string">'DNS'</span><span class="token punctuation">,</span> <span class="token string">'id.python.org'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
 <span class="token string">'version'</span><span class="token punctuation">:</span> <span class="token number">3</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>现在 SSL 通道已建立并已验证了证书，你可以继续与服务器对话了:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> conn<span class="token punctuation">.</span>sendall<span class="token punctuation">(</span>b<span class="token string">"HEAD / HTTP/1.0\r\nHost: linuxfr.org\r\n\r\n"</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> pprint<span class="token punctuation">.</span>pprint<span class="token punctuation">(</span>conn<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span>b<span class="token string">"\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span>b<span class="token string">'HTTP/1.1 200 OK'</span><span class="token punctuation">,</span>
 b<span class="token string">'Date: Sat, 18 Oct 2014 18:27:20 GMT'</span><span class="token punctuation">,</span>
 b<span class="token string">'Server: nginx'</span><span class="token punctuation">,</span>
 b<span class="token string">'Content-Type: text/html; charset=utf-8'</span><span class="token punctuation">,</span>
 b<span class="token string">'X-Frame-Options: SAMEORIGIN'</span><span class="token punctuation">,</span>
 b<span class="token string">'Content-Length: 45679'</span><span class="token punctuation">,</span>
 b<span class="token string">'Accept-Ranges: bytes'</span><span class="token punctuation">,</span>
 b<span class="token string">'Via: 1.1 varnish'</span><span class="token punctuation">,</span>
 b<span class="token string">'Age: 2188'</span><span class="token punctuation">,</span>
 b<span class="token string">'X-Served-By: cache-lcy1134-LCY'</span><span class="token punctuation">,</span>
 b<span class="token string">'X-Cache: HIT'</span><span class="token punctuation">,</span>
 b<span class="token string">'X-Cache-Hits: 11'</span><span class="token punctuation">,</span>
 b<span class="token string">'Vary: Cookie'</span><span class="token punctuation">,</span>
 b<span class="token string">'Strict-Transport-Security: max-age=63072000; includeSubDomains'</span><span class="token punctuation">,</span>
 b<span class="token string">'Connection: close'</span><span class="token punctuation">,</span>
 b<span class="token string">''</span><span class="token punctuation">,</span>
 b<span class="token string">''</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="服务器端操作"><a href="#服务器端操作" class="headerlink" title="服务器端操作"></a>服务器端操作</h4><p>对于服务器操作，通常你需要在文件中存放服务器证书和私钥各一份。 你将首先创建一个包含密钥和证书的上下文，这样客户端就能检查你的身份真实性。 然后你将打开一个套接字，将其绑定到一个端口，在其上调用 <code>listen()</code>，并开始等待客户端连接:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> socket<span class="token punctuation">,</span> ssl
context <span class="token operator">=</span> ssl<span class="token punctuation">.</span>create_default_context<span class="token punctuation">(</span>ssl<span class="token punctuation">.</span>Purpose<span class="token punctuation">.</span>CLIENT_AUTH<span class="token punctuation">)</span>
context<span class="token punctuation">.</span>load_cert_chain<span class="token punctuation">(</span>certfile<span class="token operator">=</span><span class="token string">"mycertfile"</span><span class="token punctuation">,</span> keyfile<span class="token operator">=</span><span class="token string">"mykeyfile"</span><span class="token punctuation">)</span>
bindsocket <span class="token operator">=</span> socket<span class="token punctuation">.</span>socket<span class="token punctuation">(</span><span class="token punctuation">)</span>
bindsocket<span class="token punctuation">.</span>bind<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">'myaddr.mydomain.com'</span><span class="token punctuation">,</span> <span class="token number">10023</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
bindsocket<span class="token punctuation">.</span>listen<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>当有客户端连接时，你将在套接字上调用 <code>accept()</code> 以从另一端获取新的套接字，并使用上下文的 <code>SSLContext.wrap_socket()</code> 方法来为连接创建一个服务器端 SSL 套接字:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>
    newsocket<span class="token punctuation">,</span> fromaddr <span class="token operator">=</span> bindsocket<span class="token punctuation">.</span>accept<span class="token punctuation">(</span><span class="token punctuation">)</span>
    connstream <span class="token operator">=</span> context<span class="token punctuation">.</span>wrap_socket<span class="token punctuation">(</span>newsocket<span class="token punctuation">,</span> server_side<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>
    <span class="token keyword">try</span><span class="token punctuation">:</span>
        deal_with_client<span class="token punctuation">(</span>connstream<span class="token punctuation">)</span>
    <span class="token keyword">finally</span><span class="token punctuation">:</span>
        connstream<span class="token punctuation">.</span>shutdown<span class="token punctuation">(</span>socket<span class="token punctuation">.</span>SHUT_RDWR<span class="token punctuation">)</span>
        connstream<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>随后你将从 <code>connstream</code> 读取数据并对其进行处理，直至你结束与客户端的会话（或客户端结束与你的会话）:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">deal_with_client</span><span class="token punctuation">(</span>connstream<span class="token punctuation">)</span><span class="token punctuation">:</span>
    data <span class="token operator">=</span> connstream<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span>
    <span class="token comment" spellcheck="true"># empty data means the client is finished with us</span>
    <span class="token keyword">while</span> data<span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token operator">not</span> do_something<span class="token punctuation">(</span>connstream<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token comment" spellcheck="true"># we'll assume do_something returns False</span>
            <span class="token comment" spellcheck="true"># when we're finished with client</span>
            <span class="token keyword">break</span>
        data <span class="token operator">=</span> connstream<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span>
    <span class="token comment" spellcheck="true"># finished with client</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>并返回至监听新的客户端连接（当然，真正的服务器应当会在单独的线程中处理每个客户端连接，或者将套接字设为 非阻塞模式 并使用事件循环）。</p>
<h3 id="关于非阻塞套接字的说明"><a href="#关于非阻塞套接字的说明" class="headerlink" title="关于非阻塞套接字的说明"></a>关于非阻塞套接字的说明</h3><p>在非阻塞模式下 SSL 套接字的行为与常规套接字略有不同。 当使用非阻塞模式时，你需要注意下面这些事情:</p>
<ul>
<li><p>如果一个 I/O 操作会阻塞，大多数 <code>SSLSocket</code> 方法都将引发 <code>SSLWantWriteError</code> 或 <code>SSLWantReadError</code> 而非 <code>BlockingIOError</code>。 如果有必要在下层套接字上执行读取操作将引发 <code>SSLWantReadError</code>，在下层套接字上执行写入操作则将引发 <code>SSLWantWriteError</code>。 请注意尝试 <em>写入</em> 到 SSL 套接字可能需要先从下层套接字 <em>读取*，而尝试从 SSL 套接字 *读取</em> 则可能需要先向下层套接字 <em>写入</em>。</p>
<p>在 3.5 版更改: 在较早的 Python 版本中，<code>SSLSocket.send()</code> 方法会返回零值而非引发 <code>SSLWantWriteError</code> 或 <code>SSLWantReadError</code>。</p>
</li>
<li><p>调用 <code>select()</code> 将告诉你可以从 OS 层级的套接字读取（或向其写入），但这并不意味着在上面的 SSL 层有足够的数据。 例如，可能只有部分 SSL 帧已经到达。 因此，你必须准备好处理 <code>SSLSocket.recv()</code> 和 <code>SSLSocket.send()</code> 失败的情况，并在再次调用 <code>select()</code> 之后重新尝试。</p>
</li>
<li><p>相反地，由于 SSL 层具有自己的帧机制，一个 SSL 套接字可能仍有可读取的数据而 <code>select()</code> 并不知道这一点。 因此，你应当先调用 <code>SSLSocket.recv()</code> 取走所有潜在的可用数据，然后只在必要时对 <code>select()</code> 调用执行阻塞。</p>
<p>(当然，类似的保留规则在使用其他原语例如 <code>poll()</code>，或 <code>selectors</code> 模块中的原语时也适用)</p>
</li>
<li><p>SSL 握手本身将是非阻塞的: <code>SSLSocket.do_handshake()</code> 方法必须不断重试直至其成功返回。 下面是一个使用 <code>select()</code> 来等待套接字就绪的简短例子:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>
    <span class="token keyword">try</span><span class="token punctuation">:</span>
        sock<span class="token punctuation">.</span>do_handshake<span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">break</span>
    <span class="token keyword">except</span> ssl<span class="token punctuation">.</span>SSLWantReadError<span class="token punctuation">:</span>
        select<span class="token punctuation">.</span>select<span class="token punctuation">(</span><span class="token punctuation">[</span>sock<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token keyword">except</span> ssl<span class="token punctuation">.</span>SSLWantWriteError<span class="token punctuation">:</span>
        select<span class="token punctuation">.</span>select<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>sock<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
<p>参见</p>
<p><code>asyncio</code> 模块支持 非阻塞 SSL 套接字 并提供了更高层级的 API。 它会使用 <code>selectors</code> 模块来轮询事件并处理 <code>SSLWantWriteError</code>, <code>SSLWantReadError</code> 和 <code>BlockingIOError</code> 等异常。 它还会异步地执行 SSL 握手。</p>
<h3 id="内存-BIO-支持"><a href="#内存-BIO-支持" class="headerlink" title="内存 BIO 支持"></a>内存 BIO 支持</h3><p>3.5 新版功能.</p>
<p>自从 SSL 模块在 Python 2.6 起被引入之后，<code>SSLSocket</code> 类提供了两个互相关联但彼此独立的功能分块:</p>
<ul>
<li>SSL 协议处理</li>
<li>网络 IO</li>
</ul>
<p>网络 IO API 与 <code>socket.socket</code> 所提供的功能一致，<code>SSLSocket</code> 也是从那里继承而来的。 这允许 SSL 套接字被用作常规套接字的替代，使得向现有应用程序添加 SSL 支持变得非常容易。</p>
<p>将 SSL 协议处理与网络 IO 结合使用通常都能运行良好，但在某些情况下则不能。 此情况的一个例子是 async IO 框架，该框架要使用不同的 IO 多路复用模型而非 (基于就绪状态的) “在文件描述器上执行选择/轮询” 模型，该模型是 <code>socket.socket</code> 和内部 OpenSSL 套接字 IO 例程正常运行的假设前提。 这种情况在该模型效率不高的 Windows 平台上最为常见。 为此还提供了一个 <code>SSLSocket</code> 的简化形式，称为 <code>SSLObject</code>。</p>
<p><em>class</em> <code>ssl.SSLObject</code></p>
<p><code>SSLSocket</code> 的简化形式，表示一个不包含任何网络 IO 方法的 SSL 协议实例。 这个类通常由想要通过内存缓冲区为 SSL 实现异步 IO 的框架作者来使用。</p>
<p>这个类在低层级 SSL 对象上实现了一个接口，与 OpenSSL 所实现的类似。 此对象会捕获 SSL 连接的状态但其本身不提供任何网络 IO。 IO 需要通过单独的 “BIO” 对象来执行，该对象是 OpenSSL 的 IO 抽象层。</p>
<p>这个类没有公有构造器。 <code>SSLObject</code> 实例必须使用 <code>wrap_bio()</code> 方法来创建。 此方法将创建 <code>SSLObject</code> 实例并将其绑定到一个 BIO 对。 其中 <em>incoming</em> BIO 用来将数据从 Python 传递到 SSL 协议实例，而 <em>outgoing</em> BIO 用来进行数据反向传递。</p>
<p>可以使用以下方法：</p>
<ul>
<li><code>context</code></li>
<li><code>server_side</code></li>
<li><code>server_hostname</code></li>
<li><code>session</code></li>
<li><code>session_reused</code></li>
<li><code>read()</code></li>
<li><code>write()</code></li>
<li><code>getpeercert()</code></li>
<li><code>selected_alpn_protocol()</code></li>
<li><code>selected_npn_protocol()</code></li>
<li><code>cipher()</code></li>
<li><code>shared_ciphers()</code></li>
<li><code>compression()</code></li>
<li><code>pending()</code></li>
<li><code>do_handshake()</code></li>
<li><code>verify_client_post_handshake()</code></li>
<li><code>unwrap()</code></li>
<li><code>get_channel_binding()</code></li>
<li><code>version()</code></li>
</ul>
<p>与 <code>SSLSocket</code> 相比，此对象缺少下列特性:</p>
<ul>
<li>任何形式的网络 IO; <code>recv()</code> 和 <code>send()</code> 仅对下层的 <code>MemoryBIO</code> 缓冲区执行读取和写入。</li>
<li>不存在 <em>do_handshake_on_connect</em> 机制。 你必须总是手动调用 <code>do_handshake()</code> 来开始握手操作。</li>
<li>不存在对 <em>suppress_ragged_eofs</em> 的处理。 所有违反协议的文件结束条件将通过 <code>SSLEOFError</code> 异常来报告。</li>
<li>方法 <code>unwrap()</code> 的调用不返回任何东西，不会如 SSL 套接字那样返回下层的套接字。</li>
<li><em>server_name_callback</em> 回调被传给 <code>SSLContext.set_servername_callback()</code> 时将获得一个 <code>SSLObject</code> 实例而非 <code>SSLSocket</code> 实例作为其第一个形参。</li>
</ul>
<p>有关 <code>SSLObject</code> 用法的一些说明:</p>
<ul>
<li>在 <code>SSLObject</code> 上的所有 IO 都是 非阻塞的。 这意味着例如 <code>read()</code> 在其需要比 incoming BIO 可用的更多数据时将会引发 <code>SSLWantReadError</code>。</li>
<li>不存在模块层级的 <code>wrap_bio()</code> 调用，就像 <code>wrap_socket()</code> 那样。 <code>SSLObject</code> 总是通过 <code>SSLContext</code> 来创建。</li>
</ul>
<p>在 3.7 版更改: <code>SSLObject</code> 的实例必须使用 <code>wrap_bio()</code> 来创建。 在较早的版本中，直接创建实例是可能的。 但这从未被记入文档或是被正式支持。</p>
<p>SSLObject 会使用内存缓冲区与外部世界通信。 <code>MemoryBIO</code> 类提供了可被用于此目的的内存缓冲区。 它包装了一个 OpenSSL 内存 BIO (Basic IO) 对象:</p>
<p><em>class</em> <code>ssl.MemoryBIO</code></p>
<p>一个可被用来在 Python 和 SSL 协议实例之间传递数据的内存缓冲区。</p>
<ul>
<li><p><code>pending</code></p>
<p>返回当前存在于内存缓冲区的字节数。</p>
</li>
<li><p><code>eof</code></p>
<p>一个表明内存 BIO 目前是否位于文件末尾的布尔值。</p>
</li>
<li><p><code>read</code>(<em>n=- 1</em>)</p>
<p>从内存缓冲区读取至多 <em>n</em> 个字节。 如果 <em>n</em> 未指定或为负值，则返回全部字节数据。</p>
</li>
<li><p><code>write</code>(<em>buf</em>)</p>
<p>将字节数据从 <em>buf</em> 写入到内存 BIO。 <em>buf</em> 参数必须为支持缓冲区协议的对象。</p>
<p>返回值为写入的字节数，它总是与 <em>buf</em> 的长度相等。</p>
</li>
<li><p><code>write_eof</code>()</p>
<p>将一个 EOF 标记写入到内存 BIO。 在此方法被调用以后，再调用 <code>write()</code> 将是非法的。 属性 <code>eof</code> will 在缓冲区当前的所有数据都被读取之后将变为真值。</p>
</li>
</ul>
<h3 id="SSL-会话"><a href="#SSL-会话" class="headerlink" title="SSL 会话"></a>SSL 会话</h3><p>3.6 新版功能.</p>
<p><em>class</em> <code>ssl.SSLSession</code></p>
<p><code>session</code> 所使用的会话对象。</p>
<ul>
<li><code>id</code></li>
<li><code>time</code></li>
<li><code>timeout</code></li>
<li><code>ticket_lifetime_hint</code></li>
<li><code>has_ticket</code></li>
</ul>
<h3 id="安全考量-1"><a href="#安全考量-1" class="headerlink" title="安全考量"></a>安全考量</h3><h4 id="最佳默认值"><a href="#最佳默认值" class="headerlink" title="最佳默认值"></a>最佳默认值</h4><p>针对 <strong>客户端使用</strong>，如果你对于安全策略没有任何特殊要求，则强烈推荐你使用 <code>create_default_context()</code> 函数来创建你的 SSL 上下文。 它将加载系统的受信任 CA 证书，启用证书验证和主机名检查，并尝试合理地选择安全的协议和密码设置。</p>
<p>例如，以下演示了你应当如何使用 <code>smtplib.SMTP</code> 类来创建指向一个 SMTP 服务器的受信任且安全的连接:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> ssl<span class="token punctuation">,</span> smtplib
<span class="token operator">>></span><span class="token operator">></span> smtp <span class="token operator">=</span> smtplib<span class="token punctuation">.</span>SMTP<span class="token punctuation">(</span><span class="token string">"mail.python.org"</span><span class="token punctuation">,</span> port<span class="token operator">=</span><span class="token number">587</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> context <span class="token operator">=</span> ssl<span class="token punctuation">.</span>create_default_context<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> smtp<span class="token punctuation">.</span>starttls<span class="token punctuation">(</span>context<span class="token operator">=</span>context<span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token number">220</span><span class="token punctuation">,</span> b<span class="token string">'2.0.0 Ready to start TLS'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果连接需要客户端证书，可使用 <code>SSLContext.load_cert_chain()</code> 来添加。</p>
<p>作为对比，如果你通过自行调用 <code>SSLContext</code> 构造器来创建 SSL 上下文，它默认将不会启用证书验证和主机名检查。 如果你这样做，请阅读下面的段落以达到良好的安全级别。</p>
<h4 id="手动设置"><a href="#手动设置" class="headerlink" title="手动设置"></a>手动设置</h4><h5 id="验证证书"><a href="#验证证书" class="headerlink" title="验证证书"></a>验证证书</h5><p>当直接调用 <code>SSLContext</code> 构造器时，默认会使用 <code>CERT_NONE</code>。 由于它不会验证对等方的身份真实性，因此是不安全的，特别是在客户端模式下，大多数时候你都希望能保证你所连接的服务器的身份真实性。 因此，当处于客户端模式时，强烈推荐使用 <code>CERT_REQUIRED</code>。 但是，光这样还不够；你还必须检查服务器证书，这可以通过调用 <code>SSLSocket.getpeercert()</code> 来获取并匹配目标服务。 对于许多协议和应用来说，服务可通过主机名来标识；在此情况下，可以使用 <code>match_hostname()</code> 函数。 这种通用检测会在 <code>SSLContext.check_hostname</code> 被启用时自动执行。</p>
<p>在 3.7 版更改: 主机名匹配现在是由 OpenSSL 来执行的。 Python 不会再使用 <code>match_hostname()</code>。</p>
<p>在服务器模式下，如果你想要使用 SSL 层来验证客户端（而不是使用更高层级的验证机制），你也必须要指定 <code>CERT_REQUIRED</code> 并以类似方式检查客户端证书。</p>
<h4 id="协议版本"><a href="#协议版本" class="headerlink" title="协议版本"></a>协议版本</h4><p>SSL 版本 2 和 3 被认为是不安全的因而使用它们会有风险。 如果你想要客户端和服务器之间有最大的兼容性，推荐使用 <code>PROTOCOL_TLS_CLIENT</code> 或 <code>PROTOCOL_TLS_SERVER</code> 作为协议版本。 SSLv2 和 SSLv3 默认会被禁用。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> client_context <span class="token operator">=</span> ssl<span class="token punctuation">.</span>SSLContext<span class="token punctuation">(</span>ssl<span class="token punctuation">.</span>PROTOCOL_TLS_CLIENT<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> client_context<span class="token punctuation">.</span>minimum_version <span class="token operator">=</span> ssl<span class="token punctuation">.</span>TLSVersion<span class="token punctuation">.</span>TLSv1_3
<span class="token operator">>></span><span class="token operator">></span> client_context<span class="token punctuation">.</span>maximum_version <span class="token operator">=</span> ssl<span class="token punctuation">.</span>TLSVersion<span class="token punctuation">.</span>TLSv1_3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>前面创建的 SSL 上下文将只允许 TLSv1.2 及更新版本（如果你的系统支持）的服务器连接。 <code>PROTOCOL_TLS_CLIENT</code> 默认会使用证书验证和主机名检查。 你必须将证书加载到上下文中。</p>
<h4 id="密码选择"><a href="#密码选择" class="headerlink" title="密码选择"></a>密码选择</h4><p>如果你有更高级的安全要求，也可以通过 <code>SSLContext.set_ciphers()</code> 方法在协商 SSL 会话时对所启用的加密进行微调。 从 Python 3.2.3 开始，ssl 默认会禁用某些较弱的加密，但你还可能希望进一步限制加密选项。 请确保仔细阅读 OpenSSL 文档中有关 <a href="https://www.openssl.org/docs/manmaster/man1/ciphers.html#CIPHER-LIST-FORMAT" target="_blank" rel="noopener">加密列表格式</a> 的部分。 如果你想要检查给定的加密列表启用了哪些加密，可以使用 <code>SSLContext.get_ciphers()</code> 或所在系统的 <code>openssl ciphers</code> 命令。</p>
<h4 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h4><p>如果使用此模块作为多进程应用的一部分（例如使用 <code>multiprocessing</code> 或 <code>concurrent.futures</code> 模块），请注意 OpenSSL 的内部随机数字生成器并不能正确处理分支进程。 应用程序必须修改父进程的 PRNG 状态，如果它们要使用任何包含 <code>os.fork()</code> 的 SSL 特性的话。 任何对 <code>RAND_add()</code>, <code>RAND_bytes()</code> 或 <code>RAND_pseudo_bytes()</code> 都可以 做到这一点。</p>
<h3 id="TLS-1-3"><a href="#TLS-1-3" class="headerlink" title="TLS 1.3"></a>TLS 1.3</h3><p>3.7 新版功能.</p>
<p>TLS 1.3 协议的行为与低版本的 TLS/SSL 略有不同。某些 TLS 1.3 新特性还不可用。</p>
<ul>
<li>TLS 1.3 使用一组不同的加密套件集。 默认情况下所有 AES-GCM 和 ChaCha20 加密套件都会被启用。 <code>SSLContext.set_ciphers()</code> 方法还不能启用或禁用任何 TLS 1.3 加密，但 <code>SSLContext.get_ciphers()</code> 会返回它们。</li>
<li>会话凭据不再会作为初始握手的组成部分被发送而是以不同的方式来处理。 <code>SSLSocket.session</code> 和 <code>SSLSession</code> 与 TLS 1.3 不兼容。</li>
<li>客户端证书在初始握手期间也不会再被验证。 服务器可以在任何时候请求证书。 客户端会在它们从服务器发送或接收应用数据时处理证书请求。</li>
<li>早期数据、延迟的 TLS 客户端证书请求、签名算法配置和密钥重生成等 TLS 1.3 特性尚未被支持。</li>
</ul>
<p>参见</p>
<p>Class <code>socket.socket</code></p>
<p>下层 <code>socket</code> 类的文档</p>
<p><a href="https://httpd.apache.org/docs/trunk/en/ssl/ssl_intro.html" target="_blank" rel="noopener">SSL/TLS 高强度加密：概述</a></p>
<p>Apache HTTP Server文档介绍</p>
<p><a href="https://tools.ietf.org/html/rfc1422.html" target="_blank" rel="noopener"><strong>RFC 1422: 因特网电子邮件的隐私加强：第二部分：基于证书的密钥管理</strong></a></p>
<p>Steve Kent</p>
<p><a href="https://tools.ietf.org/html/rfc4086.html" target="_blank" rel="noopener"><strong>RFC 4086: 确保安全的随机性要求</strong></a></p>
<p>Donald E., Jeffrey I. Schiller</p>
<p><a href="https://tools.ietf.org/html/rfc5280.html" target="_blank" rel="noopener"><strong>RFC 5280: 互联网 X.509 公钥基础架构证书和证书吊销列表 (CRL) 配置文件</strong></a></p>
<p>D. Cooper</p>
<p><a href="https://tools.ietf.org/html/rfc5246.html" target="_blank" rel="noopener"><strong>RFC 5246: 传输层安全性 (TLS) 协议版本 1.2</strong></a></p>
<p>T. Dierks et. al.</p>
<p><a href="https://tools.ietf.org/html/rfc6066.html" target="_blank" rel="noopener"><strong>RFC 6066: 传输层安全性 (TLS) 的扩展</strong></a></p>
<p>D. Eastlake</p>
<p><a href="https://www.iana.org/assignments/tls-parameters/tls-parameters.xml" target="_blank" rel="noopener">IANA TLS: 传输层安全性 (TLS) 的参数</a></p>
<p>IANA</p>
<p><a href="https://tools.ietf.org/html/rfc7525.html" target="_blank" rel="noopener"><strong>RFC 7525: 传输层安全性 (TLS) 和数据报传输层安全性 (DTLS) 的安全使用建议</strong></a></p>
<p>IETF</p>
<p><a href="https://wiki.mozilla.org/Security/Server_Side_TLS" target="_blank" rel="noopener">Mozilla 的服务器端 TLS 建议</a></p>
<p>Mozilla</p>
<h2 id="select-—-等待-I-O-完成"><a href="#select-—-等待-I-O-完成" class="headerlink" title="select —- 等待 I/O 完成"></a><code>select</code> —- 等待 I/O 完成</h2><p>该模块提供了对 <code>select()</code> 和 <code>poll()</code> 函数的访问，这些函数在大多数操作系统中是可用的。在 Solaris 及其衍生版本上可用 <code>devpoll()</code>，在 Linux 2.5+ 上可用 <code>epoll()</code>，在大多数 BSD 上可用 <code>kqueue()</code>。注意，在 Windows 上，本模块仅适用于套接字；在其他操作系统上，本模块也适用于其他文件类型（特别地，在 Unix 上也适用于管道）。本模块不能用于常规文件，不能检测出（自上次读取文件后）文件是否有新数据写入。</p>
<p>注解</p>
<p><code>selectors</code> 模块是在 <code>select</code> 模块原型的基础上进行高级且高效的 I/O 复用。推荐用户改用 <code>selectors</code> 模块，除非用户希望对 OS 级的函数原型进行精确控制。</p>
<p>该模块定义以下内容：</p>
<p><em>exception</em> <code>select.error</code></p>
<p>一个被弃用的 <code>OSError</code> 的别名。</p>
<p>在 3.3 版更改: 根据 <a href="https://www.python.org/dev/peps/pep-3151" target="_blank" rel="noopener"><strong>PEP 3151</strong></a>，这个类是 <code>OSError</code> 的别名。</p>
<p><code>select.devpoll</code>()</p>
<p>（仅支持 Solaris 及其衍生版本）返回一个 <code>/dev/poll</code> 轮询对象，</p>
<p><code>devpoll()</code> 对象与实例化时允许的文件描述符数量有关，如果在程序中降低了此数值，<code>devpoll()</code> 调用将失败。如果程序提高了此数值，<code>devpoll()</code> 可能会返回一个不完整的活动文件描述符列表。</p>
<p>新的文件描述符是 不可继承的。</p>
<p>3.3 新版功能.</p>
<p>在 3.4 版更改: 新的文件描述符现在是不可继承的。</p>
<p><code>select.epoll</code>(<em>sizehint=- 1</em>, <em>flags=0</em>)</p>
<p>（仅支持 Linux 2.5.44 或更高版本）返回一个 edge poll 对象，该对象可作为 I/O 事件的边缘触发或水平触发接口。</p>
<p><em>sizehint</em> 指示 epoll 预计需要注册的事件数。它必须为正数，或为 -1 以使用默认值。它仅在 <code>epoll_create1()</code> 不可用的旧系统上会被用到，其他情况下它没有任何作用（尽管仍会检查其值）。</p>
<p><em>flags</em> 已经弃用且完全被忽略。但是，如果提供该值，则它必须是 <code>0</code> 或 <code>select.EPOLL_CLOEXEC</code>，否则会抛出 <code>OSError</code> 异常。</p>
<p><code>epoll</code> 对象支持上下文管理器：当在 <code>with</code> 语句中使用时，新建的文件描述符会在运行至语句块结束时自动关闭。</p>
<p>新的文件描述符是 不可继承的。</p>
<p>在 3.3 版更改: 增加了 <em>flags</em> 参数。</p>
<p>在 3.4 版更改: 增加了对 <code>with</code> 语句的支持。新的文件描述符现在是不可继承的。</p>
<p>3.4 版后已移除: <em>flags</em> 参数。现在默认采用 <code>select.EPOLL_CLOEXEC</code> 标志。使用 <code>os.set_inheritable()</code> 来让文件描述符可继承。</p>
<p><code>select.poll</code>()</p>
<p>（部分操作系统不支持）返回一个 poll 对象，该对象支持注册和注销文件描述符，支持对描述符进行轮询以获取 I/O 事件。请参阅下方 Poll 对象 获取 poll 对象所支持的方法。</p>
<p><code>select.kqueue</code>()</p>
<p>（仅支持 BSD）返回一个内核队列对象，请参阅下方 Kqueue 对象 获取 kqueue 对象所支持的方法。</p>
<p>新的文件描述符是 不可继承的。</p>
<p>在 3.4 版更改: 新的文件描述符现在是不可继承的。</p>
<p><code>select.kevent</code>(<em>ident</em>, <em>filter=KQ_FILTER_READ</em>, <em>flags=KQ_EV_ADD</em>, <em>fflags=0</em>, <em>data=0</em>, <em>udata=0</em>)</p>
<p>（仅支持 BSD）返回一个内核事件对象，请参阅下方 Kevent 对象 获取 kevent 对象所支持的方法。</p>
<p><code>select.select</code>(<em>rlist</em>, <em>wlist</em>, <em>xlist</em>[, <em>timeout</em>])</p>
<p>这是一个明白直观的 Unix <code>select()</code> 系统调用接口。 前三个参数是由‘可等待对象’组成的序列：可以是代表文件描述符的整数，或是带有名为 <code>fileno()</code> 的返回这样的整数的无形参方法的对象:</p>
<ul>
<li><em>rlist</em>：等待，直到可以开始读取</li>
<li><em>wlist</em>：等待，直到可以开始写入</li>
<li><em>xlist</em>：等待“异常情况”（请参阅当前系统的手册，以获取哪些情况称为异常情况）</li>
</ul>
<p>允许空的可迭代对象，但是否接受三个空的可迭代对象则取决于具体平台。 （已知在 Unix 上可行但在 Windows 上不可行。） 可选的 <em>timeout</em> 参数以一个浮点数表示超时秒数。 当省略 <em>timeout</em> 参数时该函数将阻塞直到至少有一个文件描述符准备就绪。 超时值为零表示执行轮询且永不阻塞。</p>
<p>返回值是三个列表，包含已就绪对象，返回的三个列表是前三个参数的子集。当超时时间已到且没有文件描述符就绪时，返回三个空列表。</p>
<p>可迭代对象中可接受的对象类型有 Python 文件对象 (例如 <code>sys.stdin</code> 以及 <code>open()</code> 或 <code>os.popen()</code> 所返回的对象)，由 <code>socket.socket()</code> 返回的套接字对象等。 你也可以自定义一个 <em>wrapper</em> 类，只要它具有适当的 <code>fileno()</code> 方法（该方法要确实返回一个文件描述符，而不能只是一个随机整数）。</p>
<p>注解</p>
<p>Windows 上不接受文件对象，但接受套接字。在 Windows 上，底层的 <code>select()</code> 函数由 WinSock 库提供，且不处理不是源自 WinSock 的文件描述符。</p>
<p>在 3.5 版更改: 现在，当本函数被信号中断时，重试超时将从头开始计时，不会抛出 <code>InterruptedError</code> 异常。除非信号处理程序抛出异常（相关原理请参阅 <a href="https://www.python.org/dev/peps/pep-0475" target="_blank" rel="noopener"><strong>PEP 475</strong></a>）。</p>
<pre><code>select.PIPE_BUF</code></pre><p>当一个管道已经被 <code>select()</code>、<code>poll()</code> 或本模块中的某个接口报告为可写入时，可以在不阻塞该管道的情况下写入的最小字节数。它不适用于套接字等其他类型的文件类对象。</p>
<p>POSIX 上须保证该值不小于 512。</p>
<p>可用性: Unix</p>
<p>3.2 新版功能.</p>
<h3 id="dev-poll-轮询对象"><a href="#dev-poll-轮询对象" class="headerlink" title="/dev/poll 轮询对象"></a><code>/dev/poll</code> 轮询对象</h3><p>Solaris 及其衍生版本具备 <code>/dev/poll</code>。<code>select()</code> 复杂度为 O（最高文件描述符），<code>poll()</code> 为 O（文件描述符数量），而 <code>/dev/poll</code> 为 O（活动的文件描述符）。</p>
<p><code>/dev/poll</code> 的行为与标准 <code>poll()</code> 对象十分类似。</p>
<p><code>devpoll.close</code>()</p>
<p>关闭轮询对象的文件描述符。</p>
<p>3.4 新版功能.</p>
<pre><code>devpoll.closed</code></pre><p>如果轮询对象已关闭，则返回 <code>True</code>。</p>
<p>3.4 新版功能.</p>
<p><code>devpoll.fileno</code>()</p>
<p>返回轮询对象的文件描述符对应的数字。</p>
<p>3.4 新版功能.</p>
<p><code>devpoll.register</code>(<em>fd</em>[, <em>eventmask</em>])</p>
<p>在轮询对象中注册文件描述符。这样，将来调用 <code>poll()</code> 方法时将检查文件描述符是否有未处理的 I/O 事件。<em>fd</em> 可以是整数，也可以是带有 <code>fileno()</code> 方法的对象（该方法返回一个整数）。文件对象已经实现了 <code>fileno()</code>，因此它们也可以用作参数。</p>
<p><em>eventmask</em> 是可选的位掩码，用于指定要检查的事件类型。这些常量与 <code>poll()</code> 对象所用的相同。本参数的默认值是常量 <code>POLLIN</code>、<code>POLLPRI</code> 和 <code>POLLOUT</code> 的组合。</p>
<p>警告</p>
<p>注册已注册过的文件描述符不会报错，但是结果是不确定的。正确的操作是先注销或直接修改它。与 <code>poll()</code> 相比，这是一个重要的区别。</p>
<p><code>devpoll.modify</code>(<em>fd</em>[, <em>eventmask</em>])</p>
<p>此方法先执行 <code>unregister()</code> 后执行 <code>register()</code>。直接执行此操作效率（稍微）高一些。</p>
<p><code>devpoll.unregister</code>(<em>fd</em>)</p>
<p>删除轮询对象正在跟踪的某个文件描述符。与 <code>register()</code> 方法类似，<em>fd</em> 可以是整数，也可以是带有 <code>fileno()</code> 方法的对象（该方法返回一个整数）。</p>
<p>尝试删除从未注册过的文件描述符将被安全地忽略。</p>
<p><code>devpoll.poll</code>([<em>timeout</em>])</p>
<p>轮询已注册的文件描述符的集合，并返回一个列表，列表可能为空，也可能有多个 <code>(fd, event)</code> 二元组，其中包含了要报告事件或错误的描述符。<em>fd</em> 是文件描述符，<em>event</em> 是一个位掩码，表示该描述符所报告的事件 —- <code>POLLIN</code> 表示可以读取，<code>POLLOUT</code> 表示该描述符可以写入，依此类推。空列表表示调用超时，没有任何文件描述符报告事件。如果指定了 <em>timeout*，它将指定系统等待事件时，等待多长时间后返回（以毫秒为单位）。如果 *timeout</em> 为空，-1 或 <code>None</code>，则本调用将阻塞，直到轮询对象发生事件为止。</p>
<p>在 3.5 版更改: 现在，当本函数被信号中断时，重试超时将从头开始计时，不会抛出 <code>InterruptedError</code> 异常。除非信号处理程序抛出异常（相关原理请参阅 <a href="https://www.python.org/dev/peps/pep-0475" target="_blank" rel="noopener"><strong>PEP 475</strong></a>）。</p>
<h3 id="边缘触发和水平触发的轮询-epoll-对象"><a href="#边缘触发和水平触发的轮询-epoll-对象" class="headerlink" title="边缘触发和水平触发的轮询 (epoll) 对象"></a>边缘触发和水平触发的轮询 (epoll) 对象</h3><blockquote>
<p><a href="https://linux.die.net/man/4/epoll" target="_blank" rel="noopener">https://linux.die.net/man/4/epoll</a></p>
<p><em>eventmask</em></p>
<table>
<thead>
<tr>
<th align="left">常量</th>
<th align="left">含意</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>EPOLLIN</code></td>
<td align="left">可读</td>
</tr>
<tr>
<td align="left"><code>EPOLLOUT</code></td>
<td align="left">可写</td>
</tr>
<tr>
<td align="left"><code>EPOLLPRI</code></td>
<td align="left">紧急数据读取</td>
</tr>
<tr>
<td align="left"><code>EPOLLERR</code></td>
<td align="left">在关联的文件描述符上有错误情况发生</td>
</tr>
<tr>
<td align="left"><code>EPOLLHUP</code></td>
<td align="left">关联的文件描述符已挂起</td>
</tr>
<tr>
<td align="left"><code>EPOLLET</code></td>
<td align="left">设置触发方式为边缘触发，默认为水平触发</td>
</tr>
<tr>
<td align="left"><code>EPOLLONESHOT</code></td>
<td align="left">设置 one-shot 模式。触发一次事件后，该描述符会在轮询对象内部被禁用。</td>
</tr>
<tr>
<td align="left"><code>EPOLLEXCLUSIVE</code></td>
<td align="left">当已关联的描述符发生事件时，仅唤醒一个 epoll 对象。默认（如果未设置此标志）是唤醒所有轮询该描述符的 epoll 对象。</td>
</tr>
<tr>
<td align="left"><code>EPOLLRDHUP</code></td>
<td align="left">流套接字的对侧关闭了连接或关闭了写入到一半的连接。</td>
</tr>
<tr>
<td align="left"><code>EPOLLRDNORM</code></td>
<td align="left">等同于 <code>EPOLLIN</code></td>
</tr>
<tr>
<td align="left"><code>EPOLLRDBAND</code></td>
<td align="left">可以读取优先数据带。</td>
</tr>
<tr>
<td align="left"><code>EPOLLWRNORM</code></td>
<td align="left">等同于 <code>EPOLLOUT</code></td>
</tr>
<tr>
<td align="left"><code>EPOLLWRBAND</code></td>
<td align="left">可以写入优先级数据。</td>
</tr>
<tr>
<td align="left"><code>EPOLLMSG</code></td>
<td align="left">忽略</td>
</tr>
</tbody></table>
<p>3.6 新版功能: 增加了 <code>EPOLLEXCLUSIVE</code>。仅支持 Linux Kernel 4.5 或更高版本。</p>
</blockquote>
<p><code>epoll.close</code>()</p>
<p>关闭用于控制 epoll 对象的文件描述符。</p>
<pre><code>epoll.closed</code></pre><p>如果 epoll 对象已关闭，则返回 <code>True</code>。</p>
<p><code>epoll.fileno</code>()</p>
<p>返回文件描述符对应的数字，该描述符用于控制 epoll 对象。</p>
<p><code>epoll.fromfd</code>(<em>fd</em>)</p>
<p>根据给定的文件描述符创建 epoll 对象。</p>
<p><code>epoll.register</code>(<em>fd</em>[, <em>eventmask</em>])</p>
<p>在 epoll 对象中注册一个文件描述符。</p>
<p><code>epoll.modify</code>(<em>fd</em>, <em>eventmask</em>)</p>
<p>修改一个已注册的文件描述符。</p>
<p><code>epoll.unregister</code>(<em>fd</em>)</p>
<p>从 epoll 对象中删除一个已注册的文件描述符。</p>
<p>在 3.9 版更改: 此方法不会再忽略 <code>EBADF</code> 错误。</p>
<p><code>epoll.poll</code>(<em>timeout=None</em>, <em>maxevents=- 1</em>)</p>
<p>等待事件发生，timeout 是浮点数，单位为秒。</p>
<p>在 3.5 版更改: 现在，当本函数被信号中断时，重试超时将从头开始计时，不会抛出 <code>InterruptedError</code> 异常。除非信号处理程序抛出异常（相关原理请参阅 <a href="https://www.python.org/dev/peps/pep-0475" target="_blank" rel="noopener"><strong>PEP 475</strong></a>）。</p>
<h3 id="Poll-对象"><a href="#Poll-对象" class="headerlink" title="Poll 对象"></a>Poll 对象</h3><p>大多数 Unix 系统支持 <code>poll()</code> 系统调用，为服务器提供了更好的可伸缩性，使服务器可以同时服务于大量客户端。<code>poll()</code> 的伸缩性更好，因为该调用内部仅列出所关注的文件描述符，而 <code>select()</code> 会构造一个 bitmap，在其中将所关注的描述符所对应的 bit 打开，然后重新遍历整个 bitmap。因此 <code>select()</code> 复杂度是 O（最高文件描述符），而 <code>poll()</code> 是 O（文件描述符数量）。</p>
<p><code>poll.register</code>(<em>fd</em>[, <em>eventmask</em>])</p>
<p>在轮询对象中注册文件描述符。这样，将来调用 <code>poll()</code> 方法时将检查文件描述符是否有未处理的 I/O 事件。<em>fd</em> 可以是整数，也可以是带有 <code>fileno()</code> 方法的对象（该方法返回一个整数）。文件对象已经实现了 <code>fileno()</code>，因此它们也可以用作参数。</p>
<p><em>eventmask</em> 是可选的位掩码，用于指定要检查的事件类型，它可以是常量 <code>POLLIN</code>、<code>POLLPRI</code> 和 <code>POLLOUT</code> 的组合，如下表所述。如果未指定本参数，默认将会检查所有 3 种类型的事件。</p>
<table>
<thead>
<tr>
<th align="left">常量</th>
<th align="left">含意</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>POLLIN</code></td>
<td align="left">有要读取的数据</td>
</tr>
<tr>
<td align="left"><code>POLLPRI</code></td>
<td align="left">有紧急数据需要读取</td>
</tr>
<tr>
<td align="left"><code>POLLOUT</code></td>
<td align="left">准备输出：写不会阻塞</td>
</tr>
<tr>
<td align="left"><code>POLLERR</code></td>
<td align="left">某种错误条件</td>
</tr>
<tr>
<td align="left"><code>POLLHUP</code></td>
<td align="left">挂起</td>
</tr>
<tr>
<td align="left"><code>POLLRDHUP</code></td>
<td align="left">流套接字的对侧关闭了连接，或关闭了写入到一半的连接</td>
</tr>
<tr>
<td align="left"><code>POLLNVAL</code></td>
<td align="left">无效的请求：描述符未打开</td>
</tr>
</tbody></table>
<p>注册已注册过的文件描述符不会报错，且等同于只注册一次该描述符。</p>
<p><code>poll.modify</code>(<em>fd</em>, <em>eventmask</em>)</p>
<p>修改一个已注册的文件描述符，等同于 <code>register(fd, eventmask)</code>。尝试修改未注册的文件描述符会抛出 <code>OSError</code> 异常，错误码为 <code>ENOENT</code>。</p>
<p><code>poll.unregister</code>(<em>fd</em>)</p>
<p>删除轮询对象正在跟踪的某个文件描述符。与 <code>register()</code> 方法类似，<em>fd</em> 可以是整数，也可以是带有 <code>fileno()</code> 方法的对象（该方法返回一个整数）。</p>
<p>尝试删除从未注册过的文件描述符会抛出 <code>KeyError</code> 异常。</p>
<p><code>poll.poll</code>([<em>timeout</em>])</p>
<p>轮询已注册的文件描述符的集合，并返回一个列表，列表可能为空，也可能有多个 <code>(fd, event)</code> 二元组，其中包含了要报告事件或错误的描述符。<em>fd</em> 是文件描述符，<em>event</em> 是一个位掩码，表示该描述符所报告的事件 —- <code>POLLIN</code> 表示可以读取，<code>POLLOUT</code> 表示该描述符可以写入，依此类推。空列表表示调用超时，没有任何文件描述符报告事件。如果指定了 <em>timeout*，它将指定系统等待事件时，等待多长时间后返回（以毫秒为单位）。如果 *timeout</em> 为空、负数 或 <code>None</code>，则本调用将阻塞，直到轮询对象发生事件为止。</p>
<p>在 3.5 版更改: 现在，当本函数被信号中断时，重试超时将从头开始计时，不会抛出 <code>InterruptedError</code> 异常。除非信号处理程序抛出异常（相关原理请参阅 <a href="https://www.python.org/dev/peps/pep-0475" target="_blank" rel="noopener"><strong>PEP 475</strong></a>）。</p>
<h3 id="Kqueue-对象"><a href="#Kqueue-对象" class="headerlink" title="Kqueue 对象"></a>Kqueue 对象</h3><p><code>kqueue.close</code>()</p>
<p>关闭用于控制 kqueue 对象的文件描述符。</p>
<pre><code>kqueue.closed</code></pre><p>如果 kqueue 对象已关闭，则返回 <code>True</code>。</p>
<p><code>kqueue.fileno</code>()</p>
<p>返回文件描述符对应的数字，该描述符用于控制 epoll 对象。</p>
<p><code>kqueue.fromfd</code>(<em>fd</em>)</p>
<p>根据给定的文件描述符创建 kqueue 对象。</p>
<p><code>kqueue.control</code>(<em>changelist</em>, <em>max_events</em>[, <em>timeout</em>]) → eventlist</p>
<p>Kevent 的低级接口</p>
<ul>
<li>changelist 必须是一个可迭代对象，迭代出 kevent 对象，否则置为 <code>None</code>。</li>
<li>max_events 必须是 0 或一个正整数。</li>
<li>timeout 单位为秒（一般为浮点数），默认为 <code>None</code>，即永不超时。</li>
</ul>
<p>在 3.5 版更改: 现在，当本函数被信号中断时，重试超时将从头开始计时，不会抛出 <code>InterruptedError</code> 异常。除非信号处理程序抛出异常（相关原理请参阅 <a href="https://www.python.org/dev/peps/pep-0475" target="_blank" rel="noopener"><strong>PEP 475</strong></a>）。</p>
<h3 id="Kevent-对象"><a href="#Kevent-对象" class="headerlink" title="Kevent 对象"></a>Kevent 对象</h3><p><a href="https://www.freebsd.org/cgi/man.cgi?query=kqueue&amp;sektion=2" target="_blank" rel="noopener">https://www.freebsd.org/cgi/man.cgi?query=kqueue&amp;sektion=2</a></p>
<pre><code>kevent.ident</code></pre><p>用于区分事件的标识值。其解释取决于筛选器，但该值通常是文件描述符。在构造函数中，该标识值可以是整数或带有 <a href="https://www.bookstack.cn/read/python-3.10.0-zh/30550efc10d3e98c.md#io.IOBase.fileno" target="_blank" rel="noopener"><code>fileno()</code></a> 方法的对象。kevent 在内部存储整数。</p>
<pre><code>kevent.filter</code></pre><p>内核筛选器的名称。</p>
<table>
<thead>
<tr>
<th align="left">常量</th>
<th align="left">含意</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>KQ_FILTER_READ</code></td>
<td align="left">获取描述符，并在有数据可读时返回</td>
</tr>
<tr>
<td align="left"><code>KQ_FILTER_WRITE</code></td>
<td align="left">获取描述符，并在有数据可写时返回</td>
</tr>
<tr>
<td align="left"><code>KQ_FILTER_AIO</code></td>
<td align="left">AIO 请求</td>
</tr>
<tr>
<td align="left"><code>KQ_FILTER_VNODE</code></td>
<td align="left">当在 <em>fflag</em> 中监视的一个或多个请求事件发生时返回</td>
</tr>
<tr>
<td align="left"><code>KQ_FILTER_PROC</code></td>
<td align="left">监视进程ID上的事件</td>
</tr>
<tr>
<td align="left"><code>KQ_FILTER_NETDEV</code></td>
<td align="left">Watch for events on a network device [not available on macOS]</td>
</tr>
<tr>
<td align="left"><code>KQ_FILTER_SIGNAL</code></td>
<td align="left">每当监视的信号传递到进程时返回</td>
</tr>
<tr>
<td align="left"><code>KQ_FILTER_TIMER</code></td>
<td align="left">建立一个任意的计时器</td>
</tr>
</tbody></table>
<pre><code>kevent.flags</code></pre><p>筛选器操作。</p>
<table>
<thead>
<tr>
<th align="left">常量</th>
<th align="left">含意</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>KQ_EV_ADD</code></td>
<td align="left">添加或修改事件</td>
</tr>
<tr>
<td align="left"><code>KQ_EV_DELETE</code></td>
<td align="left">从队列中删除事件</td>
</tr>
<tr>
<td align="left"><code>KQ_EV_ENABLE</code></td>
<td align="left">Permitscontrol() 返回事件</td>
</tr>
<tr>
<td align="left"><code>KQ_EV_DISABLE</code></td>
<td align="left">禁用事件</td>
</tr>
<tr>
<td align="left"><code>KQ_EV_ONESHOT</code></td>
<td align="left">在第一次发生后删除事件</td>
</tr>
<tr>
<td align="left"><code>KQ_EV_CLEAR</code></td>
<td align="left">检索事件后重置状态</td>
</tr>
<tr>
<td align="left"><code>KQ_EV_SYSFLAGS</code></td>
<td align="left">内部事件</td>
</tr>
<tr>
<td align="left"><code>KQ_EV_FLAG1</code></td>
<td align="left">内部事件</td>
</tr>
<tr>
<td align="left"><code>KQ_EV_EOF</code></td>
<td align="left">筛选特定EOF条件</td>
</tr>
<tr>
<td align="left"><code>KQ_EV_ERROR</code></td>
<td align="left">请参阅返回值</td>
</tr>
</tbody></table>
<pre><code>kevent.fflags</code></pre><p>筛选特定标志。</p>
<p><code>KQ_FILTER_READ</code> 和 <code>KQ_FILTER_WRITE</code> 筛选标志：</p>
<table>
<thead>
<tr>
<th align="left">常量</th>
<th align="left">含意</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>KQ_NOTE_LOWAT</code></td>
<td align="left">套接字缓冲区的低水线</td>
</tr>
</tbody></table>
<p><code>KQ_FILTER_VNODE</code> 筛选标志：</p>
<table>
<thead>
<tr>
<th align="left">常量</th>
<th align="left">含意</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>KQ_NOTE_DELETE</code></td>
<td align="left">已调用 <em>unlink()</em></td>
</tr>
<tr>
<td align="left"><code>KQ_NOTE_WRITE</code></td>
<td align="left">发生写入</td>
</tr>
<tr>
<td align="left"><code>KQ_NOTE_EXTEND</code></td>
<td align="left">文件已扩展</td>
</tr>
<tr>
<td align="left"><code>KQ_NOTE_ATTRIB</code></td>
<td align="left">属性已更改</td>
</tr>
<tr>
<td align="left"><code>KQ_NOTE_LINK</code></td>
<td align="left">链接计数已更改</td>
</tr>
<tr>
<td align="left"><code>KQ_NOTE_RENAME</code></td>
<td align="left">文件已重命名</td>
</tr>
<tr>
<td align="left"><code>KQ_NOTE_REVOKE</code></td>
<td align="left">对文件的访问权限已被撤销</td>
</tr>
</tbody></table>
<p><code>KQ_FILTER_PROC</code> filter flags:</p>
<table>
<thead>
<tr>
<th align="left">常量</th>
<th align="left">含意</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>KQ_NOTE_EXIT</code></td>
<td align="left">进程已退出</td>
</tr>
<tr>
<td align="left"><code>KQ_NOTE_FORK</code></td>
<td align="left">该进程调用了 <em>fork()</em></td>
</tr>
<tr>
<td align="left"><code>KQ_NOTE_EXEC</code></td>
<td align="left">进程已执行新进程</td>
</tr>
<tr>
<td align="left"><code>KQ_NOTE_PCTRLMASK</code></td>
<td align="left">内部筛选器标志</td>
</tr>
<tr>
<td align="left"><code>KQ_NOTE_PDATAMASK</code></td>
<td align="left">内部筛选器标志</td>
</tr>
<tr>
<td align="left"><code>KQ_NOTE_TRACK</code></td>
<td align="left">跨 <em>fork()</em> 执行进程</td>
</tr>
<tr>
<td align="left"><code>KQ_NOTE_CHILD</code></td>
<td align="left">在 <em>NOTE_TRACK</em> 的子进程上返回</td>
</tr>
<tr>
<td align="left"><code>KQ_NOTE_TRACKERR</code></td>
<td align="left">无法附加到子对象</td>
</tr>
</tbody></table>
<p><code>KQ_FILTER_NETDEV</code> filter flags (not available on macOS):</p>
<table>
<thead>
<tr>
<th align="left">常量</th>
<th align="left">含意</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>KQ_NOTE_LINKUP</code></td>
<td align="left">链接已建立</td>
</tr>
<tr>
<td align="left"><code>KQ_NOTE_LINKDOWN</code></td>
<td align="left">链接已断开</td>
</tr>
<tr>
<td align="left"><code>KQ_NOTE_LINKINV</code></td>
<td align="left">链接状态无效</td>
</tr>
</tbody></table>
<pre><code>kevent.data</code></pre><p>筛选特定数据。</p>
<pre><code>kevent.udata</code></pre><p>用户自定义值。</p>
<h2 id="selectors-—-高级-I-O-复用库"><a href="#selectors-—-高级-I-O-复用库" class="headerlink" title="selectors —- 高级 I/O 复用库"></a><code>selectors</code> —- 高级 I/O 复用库</h2><p>3.4 新版功能.</p>
<p><strong>源码:</strong> <a href="https://github.com/python/cpython/tree/3.10/Lib/selectors.py" target="_blank" rel="noopener">Lib/selectors.py</a></p>
<hr>
<h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>此模块允许高层级且高效率的 I/O 复用，它建立在 <code>select</code> 模块原型的基础之上。 推荐用户改用此模块，除非他们希望对所使用的 OS 层级原型进行精确控制。</p>
<p>它定义了一个 <code>BaseSelector</code> 抽象基类，以及多个实际的实现 (<code>KqueueSelector</code>, <code>EpollSelector</code>…)，它们可被用于在多个文件对象上等待 I/O 就绪通知。 在下文中，”文件对象” 是指任何具有 <code>fileno()</code> 方法的对象，或是一个原始文件描述器。 </p>
<p><code>DefaultSelector</code> 是一个指向当前平台上可用的最高效实现的别名：这应为大多数用户的默认选择。</p>
<p>注解</p>
<p>受支持的文件对象类型取决于具体平台：在 Windows 上，支持套接字但不支持管道，而在 Unix 上两者均受支持（某些其他类型也可能受支持，例如 fifo 或特殊文件设备等）。</p>
<h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>类的层次结构:</p>
<pre><code>BaseSelector
+-- SelectSelector
+-- PollSelector
+-- EpollSelector
+-- DevpollSelector
+-- KqueueSelector</code></pre><p>下文中，<em>events</em> 一个位掩码，指明哪些 I/O 事件要在给定的文件对象上执行等待。 它可以是以下模块级常量的组合:</p>
<blockquote>
<table>
<thead>
<tr>
<th align="left">常量</th>
<th align="left">含意</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>EVENT_READ</code></td>
<td align="left">可读</td>
</tr>
<tr>
<td align="left"><code>EVENT_WRITE</code></td>
<td align="left">可写</td>
</tr>
</tbody></table>
</blockquote>
<p><em>class</em> <code>selectors.SelectorKey</code></p>
<p><code>SelectorKey</code> 是一个 <code>namedtuple</code>，用来将文件对象关联到其下层的文件描述器、选定事件掩码和附加数据等。 它会被某些 <code>BaseSelector</code> 方法返回。</p>
<ul>
<li><p><code>fileobj</code></p>
<p>已注册的文件对象。</p>
</li>
<li><p><code>fd</code></p>
<p>下层的文件描述器。</p>
</li>
<li><p><code>events</code></p>
<p>必须在此文件对象上被等待的事件。</p>
</li>
<li><p><code>data</code></p>
<p>可选的关联到此文件对象的不透明数据：例如，这可被用来存储各个客户端的会话 ID。</p>
</li>
</ul>
<p><em>class</em> <code>selectors.BaseSelector</code></p>
<p>一个 <code>BaseSelector</code>，用来在多个文件对象上等待 I/O 事件就绪。 它支持文件流注册、注销，以及在这些流上等待 I/O 事件的方法。 它是一个抽象基类，因此不能被实例化。 请改用 <code>DefaultSelector</code>，或者 <code>SelectSelector</code>, <code>KqueueSelector</code> 等。 如果你想要指明使用某个实现，并且你的平台支持它的话。 <code>BaseSelector</code> 及其具体实现支持 context manager 协议。</p>
<ul>
<li><p><em>abstractmethod</em> <code>register</code>(<em>fileobj</em>, <em>events</em>, <em>data=None</em>)</p>
<p>注册一个用于选择的文件对象，在其上监视 I/O 事件。</p>
<p><em>fileobj</em> 是要监视的文件对象。 它可以是整数形式的文件描述符或者具有 <code>fileno()</code> 方法的对象。 <em>events</em> 是要监视的事件的位掩码。 <em>data</em> 是一个不透明对象。</p>
<p>这将返回一个新的 <code>SelectorKey</code> 实例，或在出现无效事件掩码或文件描述符时引发 <code>ValueError</code>，或在文件对象已被注册时引发 <code>KeyError</code>。</p>
</li>
<li><p><em>abstractmethod</em> <code>unregister</code>(<em>fileobj</em>)</p>
<p>注销对一个文件对象的选择，移除对它的监视。 在文件对象被关闭之前应当先将其注销。</p>
<p><em>fileobj</em> 必须是之前已注册的文件对象。</p>
<p>这将返回已关联的 <code>SelectorKey</code> 实例，或者如果 <em>fileobj</em> 未注册则会引发 <code>KeyError</code>。 It will raise <code>ValueError</code> 如果 <em>fileobj</em> 无效（例如它没有 <code>fileno()</code> 方法或其 <code>fileno()</code> 方法返回无效值）。</p>
</li>
<li><p><code>modify</code>(<em>fileobj</em>, <em>events</em>, <em>data=None</em>)</p>
<p>更改已注册文件对象所监视的事件或所附带的数据。</p>
<p>这等价于 <code>BaseSelector.unregister(fileobj)()</code> 加 <code>BaseSelector.register(fileobj, events, data)()</code>，区别在于它可以被更高效地实现。</p>
<p>这将返回一个新的 <code>SelectorKey</code> 实例，或在出现无效事件掩码或文件描述符时引发 <code>ValueError</code>，或在文件对象未被注册时引发 <code>KeyError</code>。</p>
</li>
<li><p><em>abstractmethod</em> <code>select</code>(<em>timeout=None</em>)</p>
<p>等待直到有已注册的文件对象就绪，或是超过时限。</p>
<p>如果 <code>timeout &gt; 0</code>，这指定以秒数表示的最大等待时间。 如果 <code>timeout &lt;= 0</code>，调用将不会阻塞，并将报告当前就绪的文件对象。 如果 <em>timeout</em> 为 <code>None</code>，调用将阻塞直到某个被监视的文件对象就绪。</p>
<p>这将返回由 <code>(key, events)</code> 元组构成的列表，每项各表示一个就绪的文件对象。</p>
<p><em>key</em> 是对应于就绪文件对象的 <code>SelectorKey</code> 实例。 <em>events</em> 是在此文件对象上等待的事件位掩码。</p>
<p>注解</p>
<p>如果当前进程收到一个信号，此方法可在任何文件对象就绪之前或超出时限时返回：在此情况下，将返回一个空列表。</p>
<p>在 3.5 版更改: 现在当被某个信号中断时，如果信号处理程序没有引发异常，选择器会用重新计算的超时值进行重试（请查看 <a href="https://www.python.org/dev/peps/pep-0475" target="_blank" rel="noopener"><strong>PEP 475</strong></a> 其理由），而不是在超时之前返回空的事件列表。</p>
</li>
<li><p><code>close</code>()</p>
<p>关闭选择器。</p>
<p>必须调用这个方法以确保下层资源会被释放。 选择器被关闭后将不可再使用。</p>
</li>
<li><p><code>get_key</code>(<em>fileobj</em>)</p>
<p>返回关联到某个已注册文件对象的键。</p>
<p>此方法将返回关联到文件对象的 <code>SelectorKey</code> 实例，或在文件对象未注册时引发 <code>KeyError</code>。</p>
</li>
<li><p><em>abstractmethod</em> <code>get_map</code>()</p>
<p>返回从文件对象到选择器键的映射。</p>
<p>这将返回一个将已注册文件对象映射到与其相关联的 <code>SelectorKey</code> 实例的 <code>Mapping</code> 实例。</p>
</li>
</ul>
<p><em>class</em> <code>selectors.DefaultSelector</code></p>
<p>默认的选择器类，使用当前平台上可用的最高效实现。 这应为大多数用户的默认选择。</p>
<p><em>class</em> <code>selectors.SelectSelector</code></p>
<p>基于 <code>select.select()</code> 的选择器。</p>
<p><em>class</em> <code>selectors.PollSelector</code></p>
<p>基于 <code>select.poll()</code> 的选择器。</p>
<p><em>class</em> <code>selectors.EpollSelector</code></p>
<p>基于 <code>select.epoll()</code> 的选择器。</p>
<ul>
<li><p><code>fileno</code>()</p>
<p>此方法将返回由下层 <code>select.epoll()</code> 对象所使用的文件描述符。</p>
</li>
</ul>
<p><em>class</em> <code>selectors.DevpollSelector</code></p>
<p>基于 <code>select.devpoll()</code> 的选择器。</p>
<ul>
<li><p><code>fileno</code>()</p>
<p>此方法将返回由下层 <code>select.devpoll()</code> 对象所使用的文件描述符。</p>
</li>
</ul>
<p>3.5 新版功能.</p>
<p><em>class</em> <code>selectors.KqueueSelector</code></p>
<p>基于 <code>select.kqueue()</code> 的选择器。</p>
<ul>
<li><p><code>fileno</code>()</p>
<p>此方法将返回由下层 <code>select.kqueue()</code> 对象所使用的文件描述符。</p>
</li>
</ul>
<h3 id="例子-2"><a href="#例子-2" class="headerlink" title="例子"></a>例子</h3><p>下面是一个简单的回显服务器实现:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> selectors
<span class="token keyword">import</span> socket
sel <span class="token operator">=</span> selectors<span class="token punctuation">.</span>DefaultSelector<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">accept</span><span class="token punctuation">(</span>sock<span class="token punctuation">,</span> mask<span class="token punctuation">)</span><span class="token punctuation">:</span>
    conn<span class="token punctuation">,</span> addr <span class="token operator">=</span> sock<span class="token punctuation">.</span>accept<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># Should be ready</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'accepted'</span><span class="token punctuation">,</span> conn<span class="token punctuation">,</span> <span class="token string">'from'</span><span class="token punctuation">,</span> addr<span class="token punctuation">)</span>
    conn<span class="token punctuation">.</span>setblocking<span class="token punctuation">(</span><span class="token boolean">False</span><span class="token punctuation">)</span>
    sel<span class="token punctuation">.</span>register<span class="token punctuation">(</span>conn<span class="token punctuation">,</span> selectors<span class="token punctuation">.</span>EVENT_READ<span class="token punctuation">,</span> read<span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">read</span><span class="token punctuation">(</span>conn<span class="token punctuation">,</span> mask<span class="token punctuation">)</span><span class="token punctuation">:</span>
    data <span class="token operator">=</span> conn<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># Should be ready</span>
    <span class="token keyword">if</span> data<span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'echoing'</span><span class="token punctuation">,</span> repr<span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">'to'</span><span class="token punctuation">,</span> conn<span class="token punctuation">)</span>
        conn<span class="token punctuation">.</span>send<span class="token punctuation">(</span>data<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># Hope it won't block</span>
    <span class="token keyword">else</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'closing'</span><span class="token punctuation">,</span> conn<span class="token punctuation">)</span>
        sel<span class="token punctuation">.</span>unregister<span class="token punctuation">(</span>conn<span class="token punctuation">)</span>
        conn<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>
sock <span class="token operator">=</span> socket<span class="token punctuation">.</span>socket<span class="token punctuation">(</span><span class="token punctuation">)</span>
sock<span class="token punctuation">.</span>bind<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">'localhost'</span><span class="token punctuation">,</span> <span class="token number">1234</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
sock<span class="token punctuation">.</span>listen<span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span>
sock<span class="token punctuation">.</span>setblocking<span class="token punctuation">(</span><span class="token boolean">False</span><span class="token punctuation">)</span>
sel<span class="token punctuation">.</span>register<span class="token punctuation">(</span>sock<span class="token punctuation">,</span> selectors<span class="token punctuation">.</span>EVENT_READ<span class="token punctuation">,</span> accept<span class="token punctuation">)</span>
<span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>
    events <span class="token operator">=</span> sel<span class="token punctuation">.</span>select<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">for</span> key<span class="token punctuation">,</span> mask <span class="token keyword">in</span> events<span class="token punctuation">:</span>
        callback <span class="token operator">=</span> key<span class="token punctuation">.</span>data
        callback<span class="token punctuation">(</span>key<span class="token punctuation">.</span>fileobj<span class="token punctuation">,</span> mask<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="asyncore-—-异步套接字处理器"><a href="#asyncore-—-异步套接字处理器" class="headerlink" title="asyncore —- 异步套接字处理器"></a><code>asyncore</code> —- 异步套接字处理器</h2><p><strong>源码：</strong> <a href="https://github.com/python/cpython/tree/3.10/Lib/asyncore.py" target="_blank" rel="noopener">Lib/asyncore.py</a></p>
<p>3.6 版后已移除: 请使用 <code>asyncio</code> 替代。</p>
<hr>
<p>注解</p>
<p>该模块仅为提供向后兼容。我们推荐在新代码中使用 <code>asyncio</code> 。</p>
<p>该模块提供用于编写异步套接字服务客户端与服务端的基础构件。</p>
<p>只有两种方法让单个处理器上的程序“同一时间完成不止一件事”。 多线程编程是最简单和最流行的方法，但是还有另一种非常不同的技术，它可以让你拥有多线程的几乎所有优点，而无需实际使用多线程。 它仅仅在你的程序主要受 I/O 限制时有用，那么。 如果你的程序受处理器限制，那么先发制人的预定线程可能就是你真正需要的。 但是，网络服务器很少受处理器限制。</p>
<p>如果你的操作系统在其 I/O 库中支持 <code>select()</code> 系统调用（几乎所有操作系统），那么你可以使用它来同时处理多个通信通道；在 I/O 正在“后台”时进行其他工作。 虽然这种策略看起来很奇怪和复杂，特别是起初，它在很多方面比多线程编程更容易理解和控制。 <code>asyncore</code> 模块为您解决了许多难题，使得构建复杂的高性能网络服务器和客户端的任务变得轻而易举。 对于“会话”应用程序和协议，伴侣 <code>asynchat</code> 模块是非常宝贵的。</p>
<p>这两个模块背后的基本思想是创建一个或多个网络 <em>通道</em> ，类的实例 <code>asyncore.dispatcher</code> 和 <code>asynchat.async_chat</code> 。 创建通道会将它们添加到全局映射中，如果你不为它提供自己的 <em>映射</em> ，则由 <code>loop()</code> 函数使用。</p>
<p>一旦创建了初始通道，调用 <code>loop()</code> 函数将激活通道服务，该服务将一直持续到最后一个通道（包括在异步服务期间已添加到映射中的任何通道）关闭。</p>
<p><code>asyncore.loop</code>([<em>timeout</em>[, <em>use_poll</em>[, <em>map</em>[, <em>count</em>]]]])</p>
<p>进入一个轮询循环，其在循环计数超出或所有打开的通道关闭后终止。 所有参数都是可选的。 <em>count</em> 形参默认为 <code>None</code> ，导致循环仅在所有通道关闭时终止。 <em>timeout</em> 形参为适当的 <code>select()</code> 或 <code>poll()</code> 调用设置超时参数，以秒为单位; 默认值为30秒。 <em>use_poll</em> 形参，如果为 True ，则表示 <code>poll()</code> 应优先使用 <code>select()</code> (默认为<code>False</code>)。</p>
<p><em>map</em> 形参是一个条目为所监视通道的字典。 当通道关闭时它们会被从映射中删除。 如果省略 <em>map</em>，则会使用一个全局映射。 通道 (<code>asyncore.dispatcher</code>, <code>asynchat.async_chat</code> 及其子类的实例) 可以在映射中任意混合。</p>
<p><em>class</em> <code>asyncore.dispatcher</code></p>
<p><code>dispatcher</code> 类是对低层级套接字对象的轻量包装器。 要让它更有用处，可以从异步循环调用一些事件处理方法。 在其他方面，它可以被当作是普通的非阻塞型套接字对象。</p>
<p>在特定时间或特定连接状态下触发的低层级事件可通知异步循环发生了特定的高层级事件。 例如，如果我们请求了一个套接字以连接到另一台主机，我们会在套接字首次变得可写时得知连接已建立（在此刻你将知道可以向其写入并预期能够成功）。 包含的高层级事件有:</p>
<table>
<thead>
<tr>
<th align="left">事件</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>handle_connect()</code></td>
<td align="left">由首个读取或写入事件引起</td>
</tr>
<tr>
<td align="left"><code>handle_close()</code></td>
<td align="left">由不带可用数据的读取事件引起</td>
</tr>
<tr>
<td align="left"><code>handle_accepted()</code></td>
<td align="left">由在监听套接字上的读取事件引起</td>
</tr>
</tbody></table>
<p>在异步处理过程中，每个已映射通道的 <code>readable()</code> 和 <code>writable()</code> 方法会被用来确定是否要将通道的套接字添加到已执行 <code>select()</code> 或 <code>poll()</code> 用于读取和写入事件的通道列表中。</p>
<p>因此，通道事件的集合要大于基本套接字事件。 可以在你的子类中被重载的全部方法集合如下:</p>
<ul>
<li><p><code>handle_read</code>()</p>
<p>当异步循环检测到通道的套接字上的 <code>read()</code> 调用将要成功时会被调用。</p>
</li>
<li><p><code>handle_write</code>()</p>
<p>当异步循环检测到一个可写套接字可以被写入时会被调用。 通常此方法将实现必要的缓冲机制以保证运行效率。 例如:</p>
<pre><code>def handle_write(self):
    sent = self.send(self.buffer)
    self.buffer = self.buffer[sent:]</code></pre></li>
<li><p><code>handle_expt</code>()</p>
<p>当一个套接字连接存在带外（OOB）数据时会被调用。 这几乎从来不会发生，因为 OOB 虽然受支持但很少被使用。</p>
</li>
<li><p><code>handle_connect</code>()</p>
<p>当活动打开方的套接字实际建立连接时会被调用。 可能会发送一条“欢迎”消息，或者向远程端点发起协议协商等。</p>
</li>
<li><p><code>handle_close</code>()</p>
<p>当套接字关闭时会被调用。</p>
</li>
<li><p><code>handle_error</code>()</p>
<p>当一个异常被引发并且未获得其他处理时会被调用。 默认版本将打印精简的回溯信息。</p>
</li>
<li><p><code>handle_accept</code>()</p>
<p>当可以与发起对本地端点的 <code>connect()</code> 调用的新远程端点建立连接时会在侦听通道（被动打开方）上被调用。 在 3.2 版中已被弃用；请改用 <code>handle_accepted()</code>。</p>
<p>3.2 版后已移除.</p>
</li>
<li><p><code>handle_accepted</code>(<em>sock</em>, <em>addr</em>)</p>
<p>当与发起对本地端点的 <code>connect()</code> 调用的新远程端点已建立连接时会在侦听通道（被动打开方）上被调用。 <em>sock</em> 是可被用于在连接上发送和接收数据的 <em>新建</em> 套接字对象，而 <em>addr</em> 是绑定到连接另一端的套接字的地址。</p>
<p>3.2 新版功能.</p>
</li>
<li><p><code>readable</code>()</p>
<p>每次在异步循环之外被调用以确定是否应当将一个通道的套接字添加到可能在其上发生读取事件的列表中。 默认方法会简单地返回 <code>True</code>，表示在默认情况下，所有通道都希望能读取事件。</p>
</li>
<li><p><code>writable</code>()</p>
<p>每次在异步循环之外被调用以确定是否应当将一个通道的套接字添加到可能在其上发生写入事件的列表中。 默认方法会简单地返回 <code>True</code>，表示在默认情况下，所有通道都希望能写入事件。</p>
</li>
</ul>
<p>此外，每个通道都委托或扩展了许多套接字方法。 它们大部分都与其套接字的对应方法几乎一样。</p>
<ul>
<li><p><code>create_socket</code>(<em>family=socket.AF_INET</em>, <em>type=socket.SOCK_STREAM</em>)</p>
<p>这与普通套接字的创建相同，并会使用同样的创建选项。</p>
<p>在 3.3 版更改: <em>family</em> 和 <em>type</em> 参数可以被省略。</p>
</li>
<li><p><code>connect</code>(<em>address</em>)</p>
<p>与普通套接字对象一样，<em>address</em> 是一个元组，它的第一个元素是要连接的主机，第二个元素是端口号。</p>
</li>
<li><p><code>send</code>(<em>data</em>)</p>
<p>将 <em>data</em> 发送到套接字的远程端点。</p>
</li>
<li><p><code>recv</code>(<em>buffer_size</em>)</p>
<p>从套接字的远程端点读取至多 <em>buffer_size</em> 个字节。 读到空字节串表明通道已从另一端被关闭。</p>
<p>请注意 <code>recv()</code> 可能会引发 <code>BlockingIOError</code>，即使 <code>select.select()</code> 或 <code>select.poll()</code> 报告套接字已准备好被读取。</p>
</li>
<li><p><code>listen</code>(<em>backlog</em>)</p>
<p>侦听与套接字的连接。 <em>backlog</em> 参数指明排入连接队列的最大数量且至少应为 1；最大值取决于具体系统（通常为 5）。</p>
</li>
<li><p><code>bind</code>(<em>address</em>)</p>
<p>将套接字绑定到 <em>address</em>。 套接字必须尚未被绑定。 要将套接字标记为可重用的 (设置 <code>SO_REUSEADDR</code> 选项)，请调用 <code>dispatcher</code> 对象的 <code>set_reuse_addr()</code> 方法。</p>
</li>
<li><p><code>accept</code>()</p>
<p>接受一个连接。 此套接字必须绑定到一个地址上并且侦听连接。 返回值可以是 <code>None</code> 或一个 <code>(conn, address)</code> 对，其中 <em>conn</em> 是一个可用来在此连接上发送和接收数据的 <em>新的</em> 套接字对象，而 <em>address</em> 是绑定到连接另一端套接字的地址。 当返回 <code>None</code> 时意味着连接没有建立，在此情况下服务器应当忽略此事件并继续侦听后续的入站连接。</p>
</li>
<li><p><code>close</code>()</p>
<p>关闭套接字。 在此套接字对象上的后续操作都将失败。 远程端点将不再接收任何数据（在排入队列的数据被清空之后）。 当套接字被垃圾回收时会自动关闭。</p>
</li>
</ul>
<p><em>class</em> <code>asyncore.dispatcher_with_send</code></p>
<p><code>dispatcher</code> 的一个添加了简单缓冲输出功能的子类，适用于简单客户端。 对于更复杂的用法请使用 <code>asynchat.async_chat</code>。</p>
<p><em>class</em> <code>asyncore.file_dispatcher</code></p>
<p>file_dispatcher 接受一个文件描述符或 file object 以及一个可选的 map 参数，并对其进行包装以配合 <code>poll()</code> 或 <code>loop()</code> 函数使用。 如果提供一个文件对象或任何具有 <code>fileno()</code> 方法的对象，其方法将被调用并传递给 <code>file_wrapper</code> 构造器。</p>
<p>可用性: Unix。</p>
<p><em>class</em> <code>asyncore.file_wrapper</code></p>
<p>file_wrapper 接受一个整数形式的文件描述符并调用 <code>os.dup()</code> 来复制其句柄，以便原始句柄可以独立于 file_wrapper 被关闭。 这个类实现了足够的方法来模拟套接字以供 <code>file_dispatcher</code> 类使用。</p>
<p>可用性: Unix。</p>
<h3 id="asyncore-示例基本-HTTP-客户端"><a href="#asyncore-示例基本-HTTP-客户端" class="headerlink" title="asyncore 示例基本 HTTP 客户端"></a>asyncore 示例基本 HTTP 客户端</h3><p>下面是一个非常基本的 HTTP 客户端，它使用了 <code>dispatcher</code> 类来实现套接字处理:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> asyncore
<span class="token keyword">class</span> <span class="token class-name">HTTPClient</span><span class="token punctuation">(</span>asyncore<span class="token punctuation">.</span>dispatcher<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> host<span class="token punctuation">,</span> path<span class="token punctuation">)</span><span class="token punctuation">:</span>
        asyncore<span class="token punctuation">.</span>dispatcher<span class="token punctuation">.</span>__init__<span class="token punctuation">(</span>self<span class="token punctuation">)</span>
        self<span class="token punctuation">.</span>create_socket<span class="token punctuation">(</span><span class="token punctuation">)</span>
        self<span class="token punctuation">.</span>connect<span class="token punctuation">(</span> <span class="token punctuation">(</span>host<span class="token punctuation">,</span> <span class="token number">80</span><span class="token punctuation">)</span> <span class="token punctuation">)</span>
        self<span class="token punctuation">.</span>buffer <span class="token operator">=</span> bytes<span class="token punctuation">(</span><span class="token string">'GET %s HTTP/1.0\r\nHost: %s\r\n\r\n'</span> <span class="token operator">%</span>
                            <span class="token punctuation">(</span>path<span class="token punctuation">,</span> host<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">'ascii'</span><span class="token punctuation">)</span>
    <span class="token keyword">def</span> <span class="token function">handle_connect</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">pass</span>
    <span class="token keyword">def</span> <span class="token function">handle_close</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">def</span> <span class="token function">handle_read</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">8192</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">def</span> <span class="token function">writable</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token punctuation">(</span>len<span class="token punctuation">(</span>self<span class="token punctuation">.</span>buffer<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token keyword">def</span> <span class="token function">handle_write</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        sent <span class="token operator">=</span> self<span class="token punctuation">.</span>send<span class="token punctuation">(</span>self<span class="token punctuation">.</span>buffer<span class="token punctuation">)</span>
        self<span class="token punctuation">.</span>buffer <span class="token operator">=</span> self<span class="token punctuation">.</span>buffer<span class="token punctuation">[</span>sent<span class="token punctuation">:</span><span class="token punctuation">]</span>
client <span class="token operator">=</span> HTTPClient<span class="token punctuation">(</span><span class="token string">'www.python.org'</span><span class="token punctuation">,</span> <span class="token string">'/'</span><span class="token punctuation">)</span>
asyncore<span class="token punctuation">.</span>loop<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="asyncore-示例基本回显服务器"><a href="#asyncore-示例基本回显服务器" class="headerlink" title="asyncore 示例基本回显服务器"></a>asyncore 示例基本回显服务器</h3><p>下面是一个基本的回显服务器，它使用了 <code>dispatcher</code> 类来接受连接并将入站连接发送给处理程序:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> asyncore
<span class="token keyword">class</span> <span class="token class-name">EchoHandler</span><span class="token punctuation">(</span>asyncore<span class="token punctuation">.</span>dispatcher_with_send<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">handle_read</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        data <span class="token operator">=</span> self<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">8192</span><span class="token punctuation">)</span>
        <span class="token keyword">if</span> data<span class="token punctuation">:</span>
            self<span class="token punctuation">.</span>send<span class="token punctuation">(</span>data<span class="token punctuation">)</span>
<span class="token keyword">class</span> <span class="token class-name">EchoServer</span><span class="token punctuation">(</span>asyncore<span class="token punctuation">.</span>dispatcher<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> host<span class="token punctuation">,</span> port<span class="token punctuation">)</span><span class="token punctuation">:</span>
        asyncore<span class="token punctuation">.</span>dispatcher<span class="token punctuation">.</span>__init__<span class="token punctuation">(</span>self<span class="token punctuation">)</span>
        self<span class="token punctuation">.</span>create_socket<span class="token punctuation">(</span><span class="token punctuation">)</span>
        self<span class="token punctuation">.</span>set_reuse_addr<span class="token punctuation">(</span><span class="token punctuation">)</span>
        self<span class="token punctuation">.</span>bind<span class="token punctuation">(</span><span class="token punctuation">(</span>host<span class="token punctuation">,</span> port<span class="token punctuation">)</span><span class="token punctuation">)</span>
        self<span class="token punctuation">.</span>listen<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>
    <span class="token keyword">def</span> <span class="token function">handle_accepted</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> sock<span class="token punctuation">,</span> addr<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Incoming connection from %s'</span> <span class="token operator">%</span> repr<span class="token punctuation">(</span>addr<span class="token punctuation">)</span><span class="token punctuation">)</span>
        handler <span class="token operator">=</span> EchoHandler<span class="token punctuation">(</span>sock<span class="token punctuation">)</span>
server <span class="token operator">=</span> EchoServer<span class="token punctuation">(</span><span class="token string">'localhost'</span><span class="token punctuation">,</span> <span class="token number">8080</span><span class="token punctuation">)</span>
asyncore<span class="token punctuation">.</span>loop<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="asynchat-—-异步套接字指令-响应处理程序"><a href="#asynchat-—-异步套接字指令-响应处理程序" class="headerlink" title="asynchat —- 异步套接字指令/响应处理程序"></a><code>asynchat</code> —- 异步套接字指令/响应处理程序</h2><p><strong>源代码:</strong> <a href="https://github.com/python/cpython/tree/3.10/Lib/asynchat.py" target="_blank" rel="noopener">Lib/asynchat.py</a></p>
<p>3.6 版后已移除: 请使用 <code>asyncio</code> 替代。</p>
<hr>
<p>注解</p>
<p>该模块仅为提供向后兼容。我们推荐在新代码中使用 <code>asyncio</code> 。</p>
<p>此模块在 <code>asyncore</code> 框架之上构建，简化了异步客户端和服务器并使得处理元素为以任意字符串结束或者为可变长度的协议更加容易。 <code>asynchat</code> 定义了一个可以由你来子类化的抽象类 <code>async_chat</code>，提供了 <code>collect_incoming_data()</code> 和 <code>found_terminator()</code> 等方法的实现。 它使用与 <code>asyncore</code> 相同的异步循环，并且可以在通道映射中自由地混合 <code>asyncore.dispatcher</code> 和 <code>asynchat.async_chat</code> 这两种类型的通道。 一般来说 <code>asyncore.dispatcher</code> 服务器通道在接收到传入的连接请求时会生成新的 <code>asynchat.async_chat</code> 通道对象。</p>
<p><em>class</em> <code>asynchat.async_chat</code></p>
<p>这个类是 <code>asyncore.dispatcher</code> 的抽象子类。 对于实际使用的代码你必须子类化 <code>async_chat</code>，提供有意义的 <code>collect_incoming_data()</code> 和 <code>found_terminator()</code> 方法。 <code>asyncore.dispatcher</code> 的方法也可以被使用，但它们在消息/响应上下文中并不是全都有意义。</p>
<p>与 <code>asyncore.dispatcher</code> 类似，<code>async_chat</code> 也定义了一组通过对 <code>select()</code> 调用之后的套接字条件进行分析所生成的事件。 一旦启动轮询循环 <code>async_chat</code> 对象的方法就会被事件处理框架调用而无须程序员方面做任何操作。</p>
<p>两个可被修改的类属性，用以提升性能，甚至也可能会节省内存。</p>
<ul>
<li><p><code>ac_in_buffer_size</code></p>
<p>异步输入缓冲区大小 (默认为 <code>4096</code>)。</p>
</li>
<li><p><code>ac_out_buffer_size</code></p>
<p>异步输出缓冲区大小 (默认为 <code>4096</code>)。</p>
</li>
</ul>
<p>与 <code>asyncore.dispatcher</code> 不同，<code>async_chat</code> 允许你定义一个 FIFO 队列 <em>producers<em>。 其中的生产者只需要一个方法 <code>more()</code>，该方法应当返回要在通道上传输的数据。 生产者通过让其 <code>more()</code> 方法返回空字节串对象来表明其处于耗尽状态 (</em>意即</em> 它已不再包含数据)。 此时 <code>async_chat</code> 对象会将该生产者从队列中移除并开始使用下一个生产者，如果有下一个的话。 当生产者队列为空时 <code>handle_write()</code> 方法将不执行任何操作。 你要使用通道对象的 <code>set_terminator()</code> 方法来描述如何识别来自远程端点的入站传输的结束或是重要的中断点。</p>
<p>要构建一个可用的 <code>async_chat</code> 子类，你的输入方法 <code>collect_incoming_data()</code> 和 <code>found_terminator()</code> 必须要处理通道异步接收的数据。 这些参数的描述见下文。</p>
<p><code>async_chat.close_when_done</code>()</p>
<p>将 <code>None</code> 推入生产者队列。 当此生产者被弹出队列时它将导致通道被关闭。</p>
<p><code>async_chat.collect_incoming_data</code>(<em>data</em>)</p>
<p>调用时附带 <em>data</em>，其中包含任意数量的已接收数据。 必须被重载的默认方法将引发一个 <code>NotImplementedError</code> 异常。</p>
<p><code>async_chat.discard_buffers</code>()</p>
<p>在紧急情况下此方法将丢弃输入和/或输出缓冲区以及生产者队列中的任何数据。</p>
<p><code>async_chat.found_terminator</code>()</p>
<p>当输入数据流能匹配 <code>set_terminator()</code> 所设定的终结条件时会被调用。 必须被重载的默认方法将引发一个 <code>NotImplementedError</code> 异常。 被缓冲的输入数据应当可以通过实例属性来获取。</p>
<p><code>async_chat.get_terminator</code>()</p>
<p>返回通道的当前终结器。</p>
<p><code>async_chat.push</code>(<em>data</em>)</p>
<p>将数据推入通道的队列以确保其被传输。 要让通道将数据写到网络中你只需要这样做就足够了，虽然以更复杂的方式使用你自己的生产者也是有可能的，例如为了实现加密和分块。</p>
<p><code>async_chat.push_with_producer</code>(<em>producer</em>)</p>
<p>获取一个生产者对象并将其加入到与通道相关联的生产者队列中。 当所有当前已推入的生产者都已被耗尽时通道将通过调用其 <code>more()</code> 方法来耗用此生产者的数据并将数据发送至远程端点。</p>
<p><code>async_chat.set_terminator</code>(<em>term</em>)</p>
<p>设置可在通道上被识别的终结条件。 <code>term</code> 可以是三种类型值中的任意一种 ，对应于处理入站协议数据的三种不同方式。</p>
<table>
<thead>
<tr>
<th align="left">term</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><em>string</em></td>
<td align="left">当在输入流中发现该字符串时将会调用 <code>found_terminator()</code></td>
</tr>
<tr>
<td align="left"><em>integer</em></td>
<td align="left">当接收到指定数量的字符时将会调用 <code>found_terminator()</code></td>
</tr>
<tr>
<td align="left"><code>None</code></td>
<td align="left">通道会不断地持续收集数据</td>
</tr>
</tbody></table>
<p>请注意终结器之后的任何数据将可在 <code>found_terminator()</code> 被调用后由通道来读取。</p>
<h3 id="asynchat-示例"><a href="#asynchat-示例" class="headerlink" title="asynchat 示例"></a>asynchat 示例</h3><p>下面的例子片段显示了如何通过 <code>async_chat</code> 来读取 HTTP 请求。 Web 服务器可以为每个入站的客户端连接创建 <code>http_request_handler</code> 对象。 请注意在初始时通道终结器会被设置为匹配 HTTP 标头末尾的空行，并且会用一个旗标来指明标头正在被读取。</p>
<p>一旦完成了标头的读取，如果请求类型为 POST (表明输入流中存在更多的数据) 则会使用 <code>Content-Length:</code> 标头来设置一个数值终结器以从通道读取适当数量的数据。</p>
<p>一旦完成了对所有相关输入的处理，将会在设置通道终结器为 <code>None</code> 以确保忽略掉 Web 客户端所发送的任何无关数据之后调用 <code>handle_request()</code> 方法。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> asynchat
<span class="token keyword">class</span> <span class="token class-name">http_request_handler</span><span class="token punctuation">(</span>asynchat<span class="token punctuation">.</span>async_chat<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> sock<span class="token punctuation">,</span> addr<span class="token punctuation">,</span> sessions<span class="token punctuation">,</span> log<span class="token punctuation">)</span><span class="token punctuation">:</span>
        asynchat<span class="token punctuation">.</span>async_chat<span class="token punctuation">.</span>__init__<span class="token punctuation">(</span>self<span class="token punctuation">,</span> sock<span class="token operator">=</span>sock<span class="token punctuation">)</span>
        self<span class="token punctuation">.</span>addr <span class="token operator">=</span> addr
        self<span class="token punctuation">.</span>sessions <span class="token operator">=</span> sessions
        self<span class="token punctuation">.</span>ibuffer <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        self<span class="token punctuation">.</span>obuffer <span class="token operator">=</span> b<span class="token string">""</span>
        self<span class="token punctuation">.</span>set_terminator<span class="token punctuation">(</span>b<span class="token string">"\r\n\r\n"</span><span class="token punctuation">)</span>
        self<span class="token punctuation">.</span>reading_headers <span class="token operator">=</span> <span class="token boolean">True</span>
        self<span class="token punctuation">.</span>handling <span class="token operator">=</span> <span class="token boolean">False</span>
        self<span class="token punctuation">.</span>cgi_data <span class="token operator">=</span> None
        self<span class="token punctuation">.</span>log <span class="token operator">=</span> log
    <span class="token keyword">def</span> <span class="token function">collect_incoming_data</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token triple-quoted-string string">"""Buffer the data"""</span>
        self<span class="token punctuation">.</span>ibuffer<span class="token punctuation">.</span>append<span class="token punctuation">(</span>data<span class="token punctuation">)</span>
    <span class="token keyword">def</span> <span class="token function">found_terminator</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> self<span class="token punctuation">.</span>reading_headers<span class="token punctuation">:</span>
            self<span class="token punctuation">.</span>reading_headers <span class="token operator">=</span> <span class="token boolean">False</span>
            self<span class="token punctuation">.</span>parse_headers<span class="token punctuation">(</span>b<span class="token string">""</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>self<span class="token punctuation">.</span>ibuffer<span class="token punctuation">)</span><span class="token punctuation">)</span>
            self<span class="token punctuation">.</span>ibuffer <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
            <span class="token keyword">if</span> self<span class="token punctuation">.</span>op<span class="token punctuation">.</span>upper<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> b<span class="token string">"POST"</span><span class="token punctuation">:</span>
                clen <span class="token operator">=</span> self<span class="token punctuation">.</span>headers<span class="token punctuation">.</span>getheader<span class="token punctuation">(</span><span class="token string">"content-length"</span><span class="token punctuation">)</span>
                self<span class="token punctuation">.</span>set_terminator<span class="token punctuation">(</span>int<span class="token punctuation">(</span>clen<span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                self<span class="token punctuation">.</span>handling <span class="token operator">=</span> <span class="token boolean">True</span>
                self<span class="token punctuation">.</span>set_terminator<span class="token punctuation">(</span>None<span class="token punctuation">)</span>
                self<span class="token punctuation">.</span>handle_request<span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">elif</span> <span class="token operator">not</span> self<span class="token punctuation">.</span>handling<span class="token punctuation">:</span>
            self<span class="token punctuation">.</span>set_terminator<span class="token punctuation">(</span>None<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># browsers sometimes over-send</span>
            self<span class="token punctuation">.</span>cgi_data <span class="token operator">=</span> parse<span class="token punctuation">(</span>self<span class="token punctuation">.</span>headers<span class="token punctuation">,</span> b<span class="token string">""</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>self<span class="token punctuation">.</span>ibuffer<span class="token punctuation">)</span><span class="token punctuation">)</span>
            self<span class="token punctuation">.</span>handling <span class="token operator">=</span> <span class="token boolean">True</span>
            self<span class="token punctuation">.</span>ibuffer <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
            self<span class="token punctuation">.</span>handle_request<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="signal-—-设置异步事件处理程序"><a href="#signal-—-设置异步事件处理程序" class="headerlink" title="signal —- 设置异步事件处理程序"></a><code>signal</code> —- 设置异步事件处理程序</h2><p>该模块提供了在 Python 中使用信号处理程序的机制。</p>
<h3 id="一般规则"><a href="#一般规则" class="headerlink" title="一般规则"></a>一般规则</h3><p><code>signal.signal()</code> 函数允许定义在接收到信号时执行的自定义处理程序。少量的默认处理程序已经设置： <code>SIGPIPE</code> 被忽略（因此管道和套接字上的写入错误可以报告为普通的 Python 异常）以及如果父进程没有更改 <code>SIGINT</code> ，则其会被翻译成 <code>KeyboardInterrupt</code> 异常。</p>
<p>一旦设置，特定信号的处理程序将保持安装，直到它被显式重置（ Python 模拟 BSD 样式接口而不管底层实现），但 <code>SIGCHLD</code> 的处理程序除外，它遵循底层实现。</p>
<h4 id="执行-Python-信号处理程序"><a href="#执行-Python-信号处理程序" class="headerlink" title="执行 Python 信号处理程序"></a>执行 Python 信号处理程序</h4><p>Python 信号处理程序不会在低级（ C ）信号处理程序中执行。相反，低级信号处理程序设置一个标志，告诉 virtual machine 稍后执行相应的 Python 信号处理程序（例如在下一个 bytecode 指令）。这会导致：</p>
<ul>
<li>捕获同步错误是没有意义的，例如 <code>SIGFPE</code> 或 <code>SIGSEGV</code> ，它们是由 C 代码中的无效操作引起的。Python 将从信号处理程序返回到 C 代码，这可能会再次引发相同的信号，导致 Python 显然的挂起。 从Python 3.3开始，你可以使用 <code>faulthandler</code> 模块来报告同步错误。</li>
<li>纯 C 中实现的长时间运行的计算（例如在大量文本上的正则表达式匹配）可以在任意时间内不间断地运行，而不管接收到任何信号。计算完成后将调用 Python 信号处理程序。</li>
</ul>
<h4 id="信号与线程"><a href="#信号与线程" class="headerlink" title="信号与线程"></a>信号与线程</h4><p>Python 信号处理程序总是会在主 Python 主解释器的主线程中执行，即使信号是在另一个线程中接收的。 这意味着信号不能被用作线程间通信的手段。 你可以改用 <code>threading</code> 模块中的同步原语。</p>
<p>此外，只有主解释器的主线程才被允许设置新的信号处理程序。</p>
<h3 id="模块内容-1"><a href="#模块内容-1" class="headerlink" title="模块内容"></a>模块内容</h3><p>在 3.5 版更改: 信号（ SIG* ），处理程序（ <code>SIG_DFL</code> ， <code>SIG_IGN</code>）和 sigmask（ <code>SIG_BLOCK</code> ， <code>SIG_UNBLOCK</code> ， <code>SIG_SETMASK</code> ）下面列出的相关常量变成了 <code>enums</code> 。 <code>getsignal()</code> ， <code>pthread_sigmask()</code> ， <code>sigpending()</code> 和 <code>sigwait()</code> 函数返回人类可读的 <code>enums</code> 。</p>
<p>在 <code>signal</code> 模块中定义的变量是：</p>
<pre><code>signal.SIG_DFL</code></pre><p>这是两种标准信号处理选项之一；它只会执行信号的默认函数。 例如，在大多数系统上，对于 <code>SIGQUIT</code> 的默认操作是转储核心并退出，而对于 <code>SIGCHLD</code> 的默认操作是简单地忽略它。</p>
<pre><code>signal.SIG_IGN</code></pre><p>这是另一个标准信号处理程序，它将简单地忽略给定的信号。</p>
<pre><code>signal.SIGABRT</code></pre><p>来自 <em><a href="https://manpages.debian.org/abort(3)" target="_blank" rel="noopener">abort(3)</a></em> 的中止信号。</p>
<pre><code>signal.SIGALRM</code></pre><p>来自 <em><a href="https://manpages.debian.org/alarm(2)" target="_blank" rel="noopener">alarm(2)</a></em> 的计时器信号。</p>
<p>可用性: Unix。</p>
<pre><code>signal.SIGBREAK</code></pre><p>来自键盘的中断 (CTRL + BREAK)。</p>
<p>可用性: Windows。</p>
<pre><code>signal.SIGBUS</code></pre><p>总线错误 (非法的内存访问)。</p>
<p>可用性: Unix。</p>
<pre><code>signal.SIGCHLD</code></pre><p>子进程被停止或终结。</p>
<p>可用性: Unix。</p>
<pre><code>signal.SIGCLD</code></pre><p><code>SIGCHLD</code> 的别名。</p>
<pre><code>signal.SIGCONT</code></pre><p>如果进程当前已停止则继续执行它</p>
<p>可用性: Unix。</p>
<pre><code>signal.SIGFPE</code></pre><p>浮点异常。 例如除以零。</p>
<p>参见</p>
<p>当除法或求余运算的第二个参数为零时会引发 <code>ZeroDivisionError</code> 。</p>
<pre><code>signal.SIGHUP</code></pre><p>在控制终端上检测到挂起或控制进程的终止。</p>
<p>可用性: Unix。</p>
<pre><code>signal.SIGILL</code></pre><p>非法指令。</p>
<pre><code>signal.SIGINT</code></pre><p>来自键盘的中断 (CTRL + C)。</p>
<p>默认的动作是引发 <code>KeyboardInterrupt</code>。</p>
<pre><code>signal.SIGKILL</code></pre><p>终止信号。</p>
<p>它不能被捕获、阻塞或忽略。</p>
<p>可用性: Unix。</p>
<pre><code>signal.SIGPIPE</code></pre><p>损坏的管道：写入到没有读取器的管道。</p>
<p>默认的动作是忽略此信号。</p>
<p>可用性: Unix。</p>
<pre><code>signal.SIGSEGV</code></pre><p>段错误：无效的内存引用。</p>
<pre><code>signal.SIGTERM</code></pre><p>终结信号。</p>
<pre><code>signal.SIGUSR1</code></pre><p>用户自定义信号 1。</p>
<p>可用性: Unix。</p>
<pre><code>signal.SIGUSR2</code></pre><p>用户自定义信号 2。</p>
<p>可用性: Unix。</p>
<pre><code>signal.SIGWINCH</code></pre><p>窗口调整大小信号。</p>
<p>可用性: Unix。</p>
<pre><code>SIG*</code></pre><p>所有信号编号都是符号化定义的。 例如，挂起信号被定义为 <code>signal.SIGHUP</code>；变量的名称与 C 程序中使用的名称相同，具体见 <code>&lt;signal.h&gt;</code>。 ‘<code>signal()</code>‘ 的 Unix 手册页面列出了现有的信号 (在某些系统上这是 <em><a href="https://manpages.debian.org/signal(2)" target="_blank" rel="noopener">signal(2)</a>*，在其他系统中此列表则是在 *<a href="https://manpages.debian.org/signal(7)" target="_blank" rel="noopener">signal(7)</a></em> 中)。 请注意并非所有系统都会定义相同的信号名称集；只有系统所定义的名称才会由此模块来定义。</p>
<pre><code>signal.CTRL_C_EVENT</code></pre><p>对应于 Ctrl+C 击键事件的信号。此信号只能用于 <code>os.kill()</code> 。</p>
<p>可用性: Windows。</p>
<p>3.2 新版功能.</p>
<pre><code>signal.CTRL_BREAK_EVENT</code></pre><p>对应于 Ctrl+Break 击键事件的信号。此信号只能用于 <code>os.kill()</code> 。</p>
<p>可用性: Windows。</p>
<p>3.2 新版功能.</p>
<pre><code>signal.NSIG</code></pre><p>比最高信号数多一。</p>
<pre><code>signal.ITIMER_REAL</code></pre><p>实时递减间隔计时器，并在到期时发送 <code>SIGALRM</code> 。</p>
<pre><code>signal.ITIMER_VIRTUAL</code></pre><p>仅在进程执行时递减间隔计时器，并在到期时发送 SIGVTALRM 。</p>
<pre><code>signal.ITIMER_PROF</code></pre><p>当进程执行时以及当系统替进程执行时都会减小间隔计时器。 这个计时器与 ITIMER_VIRTUAL 相配结，通常被用于分析应用程序在用户和内核空间中花费的时间。 SIGPROF 会在超期时被发送。</p>
<pre><code>signal.SIG_BLOCK</code></pre><p><code>pthread_sigmask()</code> 的 <em>how</em> 形参的一个可能的值，表明信号将会被阻塞。</p>
<p>3.3 新版功能.</p>
<pre><code>signal.SIG_UNBLOCK</code></pre><p><code>pthread_sigmask()</code> 的 <em>how</em> 形参的是个可能的值，表明信号将被解除阻塞。</p>
<p>3.3 新版功能.</p>
<pre><code>signal.SIG_SETMASK</code></pre><p><code>pthread_sigmask()</code> 的 <em>how</em> 形参的一个可能的值，表明信号掩码将要被替换。</p>
<p>3.3 新版功能.</p>
<p><code>signal</code> 模块定义了一个异常:</p>
<p><em>exception</em> <code>signal.ItimerError</code></p>
<p>作为来自下层 <code>setitimer()</code> 或 <code>getitimer()</code> 实现错误的信号被引发。 如果将无效的定时器或负的时间值传给 <code>setitimer()</code> 就导致这个错误。 此错误是 <code>OSError</code> 的子类型。</p>
<p>3.3 新版功能: 此错误是 <code>IOError</code> 的子类型，现在则是 <code>OSError</code> 的别名。</p>
<p><code>signal</code> 模块定义了以下函数:</p>
<p><code>signal.alarm</code>(<em>time</em>)</p>
<p>如果 <em>time</em> 值非零，则此函数将要求将一个 <code>SIGALRM</code> 信号在 <em>time</em> 秒内发往进程。 任何在之前排入计划的警报都会被取消（在任何时刻都只能有一个警报被排入计划）。 后续的返回值将是任何之前设置的警报被传入之前的秒数。 如果 <em>time</em> 值为零，则不会将任何警报排入计划，并且任何已排入计划的警报都会被取消。 如果返回值为零，则目前没有任何警报被排入计划。</p>
<p>可用性: Unix。 更多信息请参见手册页面 *<a href="https://manpages.debian.org/alarm(2)" target="_blank" rel="noopener">alarm(2)</a>*。</p>
<p><code>signal.getsignal</code>(<em>signalnum</em>)</p>
<p>返回当前用于信号 <em>signalnum</em> 的信号处理程序。 返回值可以是一个 Python 可调用对象，或是特殊值 <code>signal.SIG_IGN</code>, <code>signal.SIG_DFL</code> 或 <code>None</code> 之一。 在这里，<code>signal.SIG_IGN</code> 表示信号在之前被忽略，<code>signal.SIG_DFL</code> 表示之前在使用默认的信号处理方式，而 <code>None</code> 表示之前的信号处理程序未由 Python 安装。</p>
<p><code>signal.strsignal</code>(<em>signalnum</em>)</p>
<p>返回信号 <em>signalnum</em> 的系统描述，例如 “Interrupt”, “Segmentation fault” 等等。 如果信号无法被识别则返回 <code>None</code>。</p>
<p>3.8 新版功能.</p>
<p><code>signal.valid_signals</code>()</p>
<p>返回本平台上的有效信号编号集。 这可能会少于 <code>range(1, NSIG)</code>，如果某些信号被系统保留作为内部使用的话。</p>
<p>3.8 新版功能.</p>
<p><code>signal.pause</code>()</p>
<p>使进程休眠直至接收到一个信号；然后将会调用适当的处理程序。 返回空值。</p>
<p>可用性: Unix。 更多信息请参见手册页面 *<a href="https://manpages.debian.org/signal(2)" target="_blank" rel="noopener">signal(2)</a>*。</p>
<p><code>signal.raise_signal</code>(<em>signum</em>)</p>
<p>向调用方进程发送一个信号。 返回空值。</p>
<p>3.8 新版功能.</p>
<p><code>signal.pidfd_send_signal</code>(<em>pidfd</em>, <em>sig</em>, <em>siginfo=None</em>, <em>flags=0</em>)</p>
<p>发送信号 <em>sig</em> 到文件描述符 <em>pidfd</em> 所指向的进程。 Python 目前不支持 <em>siginfo</em> 形参；它必须为 <code>None</code>。 提供 <em>flags</em> 参数是为了将来扩展；当前未定义旗标值。</p>
<p>更多信息请参阅 <em><a href="https://manpages.debian.org/pidfd_send_signal(2)" target="_blank" rel="noopener">pidfd_send_signal(2)</a></em> 手册页面。</p>
<p>可用性: Linux 5.1+</p>
<p>3.9 新版功能.</p>
<p><code>signal.pthread_kill</code>(<em>thread_id</em>, <em>signalnum</em>)</p>
<p>将信号 <em>signalnum</em> 发送至与调用者在同一进程中另一线程 <em>thread_id</em>。 目标线程可被用于执行任何代码（Python或其它）。 但是，如果目标线程是在执行 Python 解释器，则 Python 信号处理程序将 由主解释器的主线程来执行。 因此，将信号发送给特定 Python 线程的唯一作用在于强制让一个正在运行的系统调用失败并抛出 <code>InterruptedError</code>。</p>
<p>使用 <code>threading.get_ident()</code> 或 <code>threading.Thread</code> 对象的 <code>ident</code> 属性为 <em>thread_id</em> 获取合适的值。</p>
<p>如果 <em>signalnum</em> 为 0，则不会发送信号，但仍然会执行错误检测；这可被用来检测目标线程是否仍在运行。</p>
<p>引发一个 审计事件 <code>signal.pthread_kill</code>，附带参数 <code>thread_id</code>, <code>signalnum</code>。</p>
<p>可用性: Unix。 更多信息请参见手册页面 *<a href="https://manpages.debian.org/pthread_kill(3)" target="_blank" rel="noopener">pthread_kill(3)</a>*。</p>
<p>3.3 新版功能.</p>
<p><code>signal.pthread_sigmask</code>(<em>how</em>, <em>mask</em>)</p>
<p>获取和/或修改调用方线程的信号掩码。 信号掩码是一组传送过程目前为调用者而阻塞的信号集。 返回旧的信号掩码作为一组信号。</p>
<p>该调用的行为取决于 <em>how</em> 的值，具体见下。</p>
<ul>
<li><code>SIG_BLOCK</code>: 被阻塞信号集是当前集与 <em>mask</em> 参数的并集。</li>
<li><code>SIG_UNBLOCK</code>: <em>mask</em> 中的信号会从当前已阻塞信号集中被移除。 允许尝试取消对一个非阻塞信号的阻塞。</li>
<li><code>SIG_SETMASK</code>: 已阻塞信号集会被设为 <em>mask</em> 参数的值。</li>
</ul>
<p><em>mask</em> 是一个信号编号集合 (例如 {<code>signal.SIGINT</code>, <code>signal.SIGTERM</code>})。 请使用 <code>valid_signals()</code> 表示包含所有信号的完全掩码。</p>
<p>例如，<code>signal.pthread_sigmask(signal.SIG_BLOCK, [])</code> 会读取调用方线程的信号掩码。</p>
<p><code>SIGKILL</code> 和 <code>SIGSTOP</code> 不能被阻塞。</p>
<p>可用性: Unix。 更多信息请参见手册页面 <em><a href="https://manpages.debian.org/sigprocmask(2)" target="_blank" rel="noopener">sigprocmask(2)</a></em> 和 *<a href="https://manpages.debian.org/pthread_sigmask(3)" target="_blank" rel="noopener">pthread_sigmask(3)</a>*。</p>
<p>3.3 新版功能.</p>
<p><code>signal.setitimer</code>(<em>which</em>, <em>seconds</em>, <em>interval=0.0</em>)</p>
<p>设置由 <em>which</em> 指明的给定间隔计时器 (<code>signal.ITIMER_REAL</code>, <code>signal.ITIMER_VIRTUAL</code> 或 <code>signal.ITIMER_PROF</code> 之一) 在 <em>seconds</em> 秒 (接受浮点数值，为与 <code>alarm()</code> 之差) 之后开始并在每 <em>interval</em> 秒间隔时 (如果 <em>interval</em> 不为零) 启动。 由 <em>which</em> 指明的间隔计时器可通过将 <em>seconds</em> 设为零来清空。</p>
<p>当一个间隔计时器启动时，会有信号发送至进程。 所发送的具体信号取决于所使用的计时器；<code>signal.ITIMER_REAL</code> 将发送 <code>SIGALRM</code>, <code>signal.ITIMER_VIRTUAL</code> 将发送 <code>SIGVTALRM</code>, 而 <code>signal.ITIMER_PROF</code> 将发送 <code>SIGPROF</code>.</p>
<p>原有的值会以元组: (delay, interval) 的形式被返回。</p>
<p>尝试传入无效的计时器将导致 <code>ItimerError</code>。</p>
<p>可用性: Unix。</p>
<p><code>signal.getitimer</code>(<em>which</em>)</p>
<p>返回由 <em>which</em> 指明的给定间隔计时器当前的值。</p>
<p>可用性: Unix。</p>
<p><code>signal.set_wakeup_fd</code>(<em>fd</em>, <em>**,</em> warn_on_full_buffer=True*)</p>
<p>将唤醒文件描述符设为 <em>fd</em>。 当接收到信号时，会将信号编号以单个字节的形式写入 fd。 这可被其它库用来唤醒一次 poll 或 select 调用，以允许该信号被完全地处理。</p>
<p>原有的唤醒 fd 会被返回（或者如果未启用文件描述符唤醒则返回 -1）。 如果 <em>fd</em> 为 -1，文件描述符唤醒会被禁用。 如果不为 -1，则 <em>fd</em> 必须为非阻塞型。 需要由库来负责在重新调用 poll 或 select 之前从 <em>fd</em> 移除任何字节数据。</p>
<p>当启用线程用时，此函数只能从 主解释器的主线程 被调用；尝试从另一线程调用它将导致 <code>ValueError</code> 异常被引发。</p>
<p>使用此函数有两种通常的方式。 在两种方式下，当有信号到达时你都是用 fd 来唤醒，但之后它们在确定达到的一个或多个信号 <em>which</em> 时存在差异。</p>
<p>在第一种方式下，我们从 fd 的缓冲区读取数据，这些字节值会给你信号编号。 这种方式很简单，但在少数情况下会发生问题：通常 fd 将有缓冲区空间大小限制，如果信号到达得太多且太快，缓冲区可能会爆满，有些信号可能丢失。 如果你使用此方式，则你应当设置 <code>warn_on_full_buffer=True</code>，当信号丢失时这至少能将警告消息打印到 stderr。</p>
<p>在第二种方式下，我们 <em>只会</em> 将唤醒 fd 用于唤醒，而忽略实际的字节值。 在此情况下，我们所关心的只有 fd 的缓冲区为空还是不为空；爆满的缓冲区完全不会导致问题。 如果你使用此方式，则你应当设置 <code>warn_on_full_buffer=False</code>，这样你的用户就不会被虚假的警告消息所迷惑。</p>
<p>在 3.5 版更改: 在 Windows 上，此函数现在也支持套接字处理。</p>
<p>在 3.7 版更改: 添加了 <code>warn_on_full_buffer</code> 形参。</p>
<p><code>signal.siginterrupt</code>(<em>signalnum</em>, <em>flag</em>)</p>
<p>更改系统调用重启行为：如果 <em>flag</em> 为 <code>False</code>，系统调用将在被信号 <em>signalnum</em> 中断时重启，否则系统调用将被中断。 返回空值。</p>
<p>可用性: Unix。 更多信息请参见手册页面 *<a href="https://manpages.debian.org/siginterrupt(3)" target="_blank" rel="noopener">siginterrupt(3)</a>*。</p>
<p>请注意用 <code>signal()</code> 安装信号处理程序将重启行为重置为可通过显式调用 <code>siginterrupt()</code> 并为给定信号的 <em>flag</em> 设置真值来实现中断。</p>
<p><code>signal.signal</code>(<em>signalnum</em>, <em>handler</em>)</p>
<p>将信号 <em>signalnum</em> 的处理程序设为函数 <em>handler*。 *handler</em> 可以为接受两个参数（见下）的 Python 可调用对象，或者为特殊值 <code>signal.SIG_IGN</code> 或 <code>signal.SIG_DFL</code> 之一。 之前的信号处理程序将被返回。 （更多信息请参阅 Unix 手册页面 *<a href="https://manpages.debian.org/signal(2)" target="_blank" rel="noopener">signal(2)</a>*。）</p>
<p>当启用线程用时，此函数只能从 主解释器的主线程 被调用；尝试从另一线程调用它将导致 <code>ValueError</code> 异常被引发。</p>
<p><em>handler</em> 将附带两个参数调用：信号编号和当前堆栈帧 (<code>None</code> 或一个帧对象；有关帧对象的描述请参阅 类型层级结构描述 或者参阅 <code>inspect</code> 模块中的属性描述)。</p>
<p>在 Windows 上，<code>signal()</code> 调用只能附带 <code>SIGABRT</code>, <code>SIGFPE</code>, <code>SIGILL</code>, <code>SIGINT</code>, <code>SIGSEGV</code>, <code>SIGTERM</code> 或 <code>SIGBREAK</code>。 任何其他值都将引发 <code>ValueError</code>。 请注意不是所有系统都定义了同样的信号名称集合；如果一个信号名称未被定义为 <code>SIG*</code> 模块层级常量则将引发 <code>AttributeError</code>。</p>
<p><code>signal.sigpending</code>()</p>
<p>检查正在等待传送给调用方线程的信号集合（即在阻塞期间被引发的信号）。 返回正在等待的信号集合。</p>
<p>可用性: Unix。 更多信息请参见手册页面 *<a href="https://manpages.debian.org/sigpending(2)" target="_blank" rel="noopener">sigpending(2)</a>*。</p>
<p>3.3 新版功能.</p>
<p><code>signal.sigwait</code>(<em>sigset</em>)</p>
<p>挂起调用方线程的执行直到信号集合 <em>sigset</em> 中指定的信号之一被传送。 此函数会接受该信号（将其从等待信号列表中移除），并返回信号编号。</p>
<p>可用性: Unix。 更多信息请参见手册页面 *<a href="https://manpages.debian.org/sigwait(3)" target="_blank" rel="noopener">sigwait(3)</a>*。</p>
<p>3.3 新版功能.</p>
<p><code>signal.sigwaitinfo</code>(<em>sigset</em>)</p>
<p>挂起调用方线程的执行直到信号集合 <em>sigset</em> 中指定的信号之一被传送。 此函数会接受该信号并将其从等待信号列表中移除。 如果 <em>sigset</em> 中的信号之一已经在等待调用方线程，此函数将立即返回并附带有关该信号的信息。 被传送信号的信号处理程序不会被调用。 如果该函数被某个不在 <em>sigset</em> 中的信号中断则会引发 <code>InterruptedError</code>。</p>
<p>返回值是一个代表 <code>siginfo_t</code> 结构体所包含数据的对象，具体为: <code>si_signo</code>, <code>si_code</code>, <code>si_errno</code>, <code>si_pid</code>, <code>si_uid</code>, <code>si_status</code>, <code>si_band</code>。</p>
<p>可用性: Unix。 更多信息请参见手册页面 *<a href="https://manpages.debian.org/sigwaitinfo(2)" target="_blank" rel="noopener">sigwaitinfo(2)</a>*。</p>
<p>3.3 新版功能.</p>
<p>在 3.5 版更改: 当被某个 不在 <em>sigset</em> 中的信号中断时本函数将进行重试并且信号处理程序不会引发异常（请参阅 <a href="https://www.python.org/dev/peps/pep-0475" target="_blank" rel="noopener"><strong>PEP 475</strong></a> 了解其理由）。</p>
<p><code>signal.sigtimedwait</code>(<em>sigset</em>, <em>timeout</em>)</p>
<p>类似于 <code>sigwaitinfo()</code>，但会接受一个额外的 <em>timeout</em> 参数来指定超时限制。 如果将 <em>timeout</em> 指定为 <code>0</code>，则会执行轮询。 如果发生超时则返回 <code>None</code>。</p>
<p>可用性: Unix。 更多信息请参见手册页面 *<a href="https://manpages.debian.org/sigtimedwait(2)" target="_blank" rel="noopener">sigtimedwait(2)</a>*。</p>
<p>3.3 新版功能.</p>
<p>在 3.5 版更改: 现在当此函数被某个不在 <em>sigset</em> 中的信号中断时将以计算出的 <em>timeout</em> 进行重试并且信号处理程序不会引发异常（请参阅 <a href="https://www.python.org/dev/peps/pep-0475" target="_blank" rel="noopener"><strong>PEP 475</strong></a> 了解其理由）。</p>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><p>这是一个最小示例程序。 它使用 <code>alarm()</code> 函数来限制等待打开一个文件所花费的时间；这在文件为无法开启的串行设备时会很有用处，此情况通常会导致 <code>os.open()</code> 无限期地挂起。 解决办法是在打开文件之前设置 5 秒钟的 alarm；如果操作耗时过长，将会发送 alarm 信号，并且处理程序会引发一个异常。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> signal<span class="token punctuation">,</span> os
<span class="token keyword">def</span> <span class="token function">handler</span><span class="token punctuation">(</span>signum<span class="token punctuation">,</span> frame<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Signal handler called with signal'</span><span class="token punctuation">,</span> signum<span class="token punctuation">)</span>
    <span class="token keyword">raise</span> OSError<span class="token punctuation">(</span><span class="token string">"Couldn't open device!"</span><span class="token punctuation">)</span>
<span class="token comment" spellcheck="true"># Set the signal handler and a 5-second alarm</span>
signal<span class="token punctuation">.</span>signal<span class="token punctuation">(</span>signal<span class="token punctuation">.</span>SIGALRM<span class="token punctuation">,</span> handler<span class="token punctuation">)</span>
signal<span class="token punctuation">.</span>alarm<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>
<span class="token comment" spellcheck="true"># This open() may hang indefinitely</span>
fd <span class="token operator">=</span> os<span class="token punctuation">.</span>open<span class="token punctuation">(</span><span class="token string">'/dev/ttyS0'</span><span class="token punctuation">,</span> os<span class="token punctuation">.</span>O_RDWR<span class="token punctuation">)</span>
signal<span class="token punctuation">.</span>alarm<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>          <span class="token comment" spellcheck="true"># Disable the alarm</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="对于-SIGPIPE-的说明"><a href="#对于-SIGPIPE-的说明" class="headerlink" title="对于 SIGPIPE 的说明"></a>对于 SIGPIPE 的说明</h3><p>将你的程序用管道输出到工具例如 <em><a href="https://manpages.debian.org/head(1)" target="_blank" rel="noopener">head(1)</a></em> 将会导致 <code>SIGPIPE</code> 信号在其标准输出的接收方提前关闭时被发送到你的进程。 这将引发一个异常例如 <code>BrokenPipeError: [Errno 32] Broken pipe</code>。 要处理这种情况，请对你的入口点进行包装以捕获此异常，如下所示:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> os
<span class="token keyword">import</span> sys
<span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">try</span><span class="token punctuation">:</span>
        <span class="token comment" spellcheck="true"># simulate large output (your code replaces this loop)</span>
        <span class="token keyword">for</span> x <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">10000</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"y"</span><span class="token punctuation">)</span>
        <span class="token comment" spellcheck="true"># flush output here to force SIGPIPE to be triggered</span>
        <span class="token comment" spellcheck="true"># while inside this try block.</span>
        sys<span class="token punctuation">.</span>stdout<span class="token punctuation">.</span>flush<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">except</span> BrokenPipeError<span class="token punctuation">:</span>
        <span class="token comment" spellcheck="true"># Python flushes standard streams on exit; redirect remaining output</span>
        <span class="token comment" spellcheck="true"># to devnull to avoid another BrokenPipeError at shutdown</span>
        devnull <span class="token operator">=</span> os<span class="token punctuation">.</span>open<span class="token punctuation">(</span>os<span class="token punctuation">.</span>devnull<span class="token punctuation">,</span> os<span class="token punctuation">.</span>O_WRONLY<span class="token punctuation">)</span>
        os<span class="token punctuation">.</span>dup2<span class="token punctuation">(</span>devnull<span class="token punctuation">,</span> sys<span class="token punctuation">.</span>stdout<span class="token punctuation">.</span>fileno<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        sys<span class="token punctuation">.</span>exit<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># Python exits with error code 1 on EPIPE</span>
<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>
    main<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>不要将 <code>SIGPIPE</code> 的处置方式设为 <code>SIG_DFL</code> 以避免 <code>BrokenPipeError</code>。 这样做还会在你的程序所写入的任何套接字连接中断时导致你的程序异常退出。</p>
<h2 id="mmap-—-内存映射文件支持"><a href="#mmap-—-内存映射文件支持" class="headerlink" title="mmap —- 内存映射文件支持"></a><code>mmap</code> —- 内存映射文件支持</h2><p>内存映射文件对象的行为既像 <code>bytearray</code> 又像 文件对象。 你可以在大部分接受 <code>bytearray</code> 的地方使用 mmap 对象；例如，你可以使用 <code>re</code> 模块来搜索一个内存映射文件。 你也可以通过执行 <code>obj[index] = 97</code> 来修改单个字节，或者通过对切片赋值来修改一个子序列: <code>obj[i1:i2] = b'...'</code>。 你还可以在文件的当前位置开始读取和写入数据，并使用 <code>seek()</code> 前往另一个位置。</p>
<p>内存映射文件是由 <code>mmap</code> 构造函数创建的，其在 Unix 和 Windows 上是不同的。 无论哪种情况，你都必须为一个打开的文件提供文件描述符以进行更新。 如果你希望映射一个已有的 Python 文件对象，请使用该对象的 <code>fileno()</code> 方法来获取 <em>fileno</em> 参数的正确值。 否则，你可以使用 <code>os.open()</code> 函数来打开这个文件，这会直接返回一个文件描述符（结束时仍然需要关闭该文件）。</p>
<p>注解</p>
<p>如果要为可写的缓冲文件创建内存映射，则应当首先 <code>flush()</code> 该文件。 这确保了对缓冲区的本地修改在内存映射中可用。</p>
<p>对于 Unix 和 Windows 版本的构造函数，可以将 <em>access</em> 指定为可选的关键字参数。 <em>access</em> 接受以下四个值之一： <code>ACCESS_READ</code> ， <code>ACCESS_WRITE</code> 或 <code>ACCESS_COPY</code> 分别指定只读，直写或写时复制内存，或 <code>ACCESS_DEFAULT</code> 推迟到 <em>prot</em> 。 <em>access</em> 可以在 Unix 和 Windows 上使用。如果未指定 <em>access</em> ，则 Windows mmap 返回直写映射。这三种访问类型的初始内存值均取自指定的文件。向 <code>ACCESS_READ</code> 内存映射赋值会引发 <code>TypeError</code> 异常。 向 <code>ACCESS_WRITE</code> 内存映射赋值会影响内存和底层的文件。 向 <code>ACCESS_COPY</code> 内存映射赋值会影响内存，但不会更新底层的文件。</p>
<p>在 3.7 版更改: 添加了 <code>ACCESS_DEFAULT</code> 常量。</p>
<p>要映射匿名内存，应将 -1 作为 fileno 和 length 一起传递。</p>
<p><em>class</em> <code>mmap.mmap</code>(<em>fileno</em>, <em>length</em>, <em>tagname=None</em>, <em>access=ACCESS_DEFAULT</em>[, <em>offset</em>])</p>
<p><strong>（ Windows 版本）</strong> 映射被文件句柄 <em>fileno</em> 指定的文件的 <em>length</em> 个字节，并创建一个 mmap 对象。如果 <em>length</em> 大于当前文件大小，则文件将扩展为包含 <em>length</em> 个字节。如果 <em>length</em> 为 <code>0</code>，则映射的最大长度为当前文件大小。如果文件为空， Windows 会引发异常（你无法在Windows上创建空映射）。</p>
<p>如果 <em>tagname</em> 被指定且不是 <code>None</code> ，则是为映射提供标签名称的字符串。 Windows 允许你对同一文件拥有许多不同的映射。如果指定现有标签的名称，则会打开该标签，否则将创建该名称的新标签。如果省略此参数或设置为 <code>None</code> ，则创建的映射不带名称。避免使用 tag 参数将有助于使代码在Unix和Windows之间可移植。</p>
<p><em>offset</em> 可以被指定为非负整数偏移量。 mmap 引用将相对于从文件开头的偏移。 <em>offset</em> 默认为0。 <em>offeset</em> 必须是 <code>ALLOCATIONGRANULARITY</code> 的倍数。</p>
<p>引发一个 审计事件 <code>mmap.__new__</code> 附带参数 <code>fileno</code>, <code>length</code>, <code>access</code>, <code>offset</code>。</p>
<p><em>class</em> <code>mmap.mmap</code>(<em>fileno</em>, <em>length</em>, <em>flags=MAP_SHARED</em>, <em>prot=PROT_WRITE|PROT_READ</em>, <em>access=ACCESS_DEFAULT</em>[, <em>offset</em>])</p>
<p><strong>(Unix 版本)</strong> 映射文件描述符 <em>fileno</em> 指定的文件的 <em>length</em> 个字节，并返回一个 mmap 对象。如果 <em>length</em> 为 <code>0</code> ，则当调用 <code>mmap</code> 时，映射的最大长度将为文件的当前大小。</p>
<p><em>flags</em> 指明映射的性质。 <code>MAP_PRIVATE</code> 会创建私有的写入时拷贝映射，因此对 mmap 对象内容的修改将为该进程所私有。 而 <code>MAP_SHARED</code> 会创建与其他映射同一文件区域的进程所共享的映射。 默认值为 <code>MAP_SHARED</code>。 某些系统还具有额外的可用旗标，完整列表会在 MAP_* 常量 中指明。</p>
<p>如果指明了 <em>prot*，它将给出所需的内存保护方式；最有用的两个值是 <code>PROT_READ</code> 和 <code>PROT_WRITE</code>，分别指明页面为可读或可写。 *prot</em> 默认为 <code>PROT_READ | PROT_WRITE</code>。</p>
<p>可以指定 <em>access</em> 作为替代 <em>flags</em> 和 <em>prot</em> 的可选关键字形参。 同时指定 <em>flags</em>, <em>prot</em> 和 <em>access</em> 将导致错误。 请参阅上文中 <em>access</em> 的描述了解有关如何使用此形参的信息。</p>
<p><em>offset</em> 可以被指定为非负整数偏移量。 mmap 引用将相对于从文件开头的偏移。 <em>offset</em> 默认为 0。 <em>offset</em> 必须是 <code>ALLOCATIONGRANULARITY</code> 的倍数，它在 Unix 系统上等价于 <code>PAGESIZE</code>。</p>
<p>To ensure validity of the created memory mapping the file specified by the descriptor <em>fileno</em> is internally automatically synchronized with physical backing store on macOS and OpenVMS.</p>
<p>这个例子演示了使用 <code>mmap</code> 的简单方式:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> mmap
<span class="token comment" spellcheck="true"># write a simple example file</span>
<span class="token keyword">with</span> open<span class="token punctuation">(</span><span class="token string">"hello.txt"</span><span class="token punctuation">,</span> <span class="token string">"wb"</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span>
    f<span class="token punctuation">.</span>write<span class="token punctuation">(</span>b<span class="token string">"Hello Python!\n"</span><span class="token punctuation">)</span>
<span class="token keyword">with</span> open<span class="token punctuation">(</span><span class="token string">"hello.txt"</span><span class="token punctuation">,</span> <span class="token string">"r+b"</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span>
    <span class="token comment" spellcheck="true"># memory-map the file, size 0 means whole file</span>
    mm <span class="token operator">=</span> mmap<span class="token punctuation">.</span>mmap<span class="token punctuation">(</span>f<span class="token punctuation">.</span>fileno<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token comment" spellcheck="true"># read content via standard file methods</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>mm<span class="token punctuation">.</span>readline<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># prints b"Hello Python!\n"</span>
    <span class="token comment" spellcheck="true"># read content via slice notation</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>mm<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># prints b"Hello"</span>
    <span class="token comment" spellcheck="true"># update content using slice notation;</span>
    <span class="token comment" spellcheck="true"># note that new content must have same size</span>
    mm<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">:</span><span class="token punctuation">]</span> <span class="token operator">=</span> b<span class="token string">" world!\n"</span>
    <span class="token comment" spellcheck="true"># ... and read again using standard file methods</span>
    mm<span class="token punctuation">.</span>seek<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>mm<span class="token punctuation">.</span>readline<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># prints b"Hello  world!\n"</span>
    <span class="token comment" spellcheck="true"># close the map</span>
    mm<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>mmap</code> 也可以在 <code>with</code> 语句中被用作上下文管理器:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> mmap
<span class="token keyword">with</span> mmap<span class="token punctuation">.</span>mmap<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">13</span><span class="token punctuation">)</span> <span class="token keyword">as</span> mm<span class="token punctuation">:</span>
    mm<span class="token punctuation">.</span>write<span class="token punctuation">(</span>b<span class="token string">"Hello world!"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>3.2 新版功能: 上下文管理器支持。</p>
<p>下面的例子演示了如何创建一个匿名映射并在父进程和子进程之间交换数据。:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> mmap
<span class="token keyword">import</span> os
mm <span class="token operator">=</span> mmap<span class="token punctuation">.</span>mmap<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">13</span><span class="token punctuation">)</span>
mm<span class="token punctuation">.</span>write<span class="token punctuation">(</span>b<span class="token string">"Hello world!"</span><span class="token punctuation">)</span>
pid <span class="token operator">=</span> os<span class="token punctuation">.</span>fork<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">if</span> pid <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># In a child process</span>
    mm<span class="token punctuation">.</span>seek<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>mm<span class="token punctuation">.</span>readline<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    mm<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>引发一个 审计事件 <code>mmap.__new__</code> 附带参数 <code>fileno</code>, <code>length</code>, <code>access</code>, <code>offset</code>。</p>
<p>映射内存的文件对象支持以下方法:</p>
<ul>
<li><p><code>close</code>()</p>
<p>关闭 mmap。 后续调用该对象的其他方法将导致引发 ValueError 异常。 此方法将不会关闭打开的文件。</p>
</li>
<li><p><code>closed</code></p>
<p>如果文件已关闭则返回 <code>True</code>。</p>
<p>3.2 新版功能.</p>
</li>
<li><p><code>find</code>(<em>sub</em>[, <em>start</em>[, <em>end</em>]])</p>
<p>返回子序列 <em>sub</em> 在对象内被找到的最小索引号，使得 <em>sub</em> 被包含在 [<em>start</em>, <em>end*] 范围中。 可选参数 *start</em> 和 <em>end</em> 会被解读为切片表示法。 如果未找到则返回 <code>-1</code>。</p>
<p>在 3.5 版更改: 现在接受可写的 字节类对象。</p>
</li>
<li><p><code>flush</code>([<em>offset</em>[, <em>size</em>]])</p>
<p>将对文件的内存副本的修改刷新至磁盘。 如果不使用此调用则无法保证在对象被销毁前将修改写回存储。 如果指定了 <em>offset</em> 和 <em>size*，则只将对指定范围内字节的修改刷新至磁盘；在其他情况下，映射的全部范围都会被刷新。 *offset</em> 必须为 <code>PAGESIZE</code> 或 <code>ALLOCATIONGRANULARITY</code> 的倍数。</p>
<p>返回 <code>None</code> 以表示成功。 当调用失败时将引发异常。</p>
<p>在 3.8 版更改: 在之前版本中，成功时将返回非零值；在 Windows 下当发生错误时将返回零。 在 Unix 下 成功时将返回零值；当发生错误时将引发异常。</p>
</li>
<li><p><code>madvise</code>(<em>option</em>[, <em>start</em>[, <em>length</em>]])</p>
<p>将有关内存区域的建议 <em>option</em> 发送至内核，从 <em>start</em> 开始扩展 <em>length</em> 个字节。 <em>option</em> 必须为系统中可用的 MADV_* 常量 之一。 如果省略 <em>start</em> 和 <em>length<em>，则会包含整个映射。 在某些系统中（包括 Linux），</em>start</em> 必须为 <code>PAGESIZE</code> 的倍数。</p>
<p>可用性: 具有 <code>madvise()</code> 系统调用的系统。</p>
<p>3.8 新版功能.</p>
</li>
<li><p><code>move</code>(<em>dest</em>, <em>src</em>, <em>count</em>)</p>
<p>将从偏移量 <em>src</em> 开始的 <em>count</em> 个字节拷贝到目标索引号 <em>dest</em>。 如果 mmap 创建时设置了 <code>ACCESS_READ</code>，则调用 move 将引发 <code>TypeError</code> 异常。</p>
</li>
<li><p><code>read</code>([<em>n</em>])</p>
<p>返回一个 <code>bytes</code>，其中包含从当前文件位置开始的至多 <em>n</em> 个字节。 如果参数省略，为 <code>None</code> 或负数，则返回从当前文件位置开始直至映射结尾的所有字节。 文件位置会被更新为返回字节数据之后的位置。</p>
<p>在 3.3 版更改: 参数可被省略或为 <code>None</code>。</p>
</li>
<li><p><code>read_byte</code>()</p>
<p>将当前文件位置上的一个字节以整数形式返回，并让文件位置前进 1。</p>
</li>
<li><p><code>readline</code>()</p>
<p>返回一个单独的行，从当前文件位置开始直到下一个换行符。 文件位置会被更新为返回字节数据之后的位置。</p>
</li>
<li><p><code>resize</code>(<em>newsize</em>)</p>
<p>改变映射以及下层文件的大小，如果存在的话。 如果 mmap 创建时设置了 <code>ACCESS_READ</code> 或 <code>ACCESS_COPY</code>，则改变映射大小将引发 <code>TypeError</code> 异常。</p>
</li>
<li><p><code>rfind</code>(<em>sub</em>[, <em>start</em>[, <em>end</em>]])</p>
<p>返回子序列 <em>sub</em> 在对象内被找到的最大索引号，使得 <em>sub</em> 被包含在 [<em>start</em>, <em>end*] 范围中。 可选参数 *start</em> 和 <em>end</em> 会被解读为切片表示法。 如果未找到则返回 <code>-1</code>。</p>
<p>在 3.5 版更改: 现在接受可写的 字节类对象。</p>
</li>
<li><p><code>seek</code>(<em>pos</em>[, <em>whence</em>])</p>
<p>设置文件的当前位置。 <em>whence</em> 参数为可选项并且默认为 <code>os.SEEK_SET</code> 或 <code>0</code> (绝对文件定位)；其他值还有 <code>os.SEEK_CUR</code> 或 <code>1</code> (相对当前位置查找) 和 <code>os.SEEK_END</code> 或 <code>2</code> (相对文件末尾查找)。</p>
</li>
<li><p><code>size</code>()</p>
<p>返回文件的长度，该数值可以大于内存映射区域的大小。</p>
</li>
<li><p><code>tell</code>()</p>
<p>返回文件指针的当前位置。</p>
</li>
<li><p><code>write</code>(<em>bytes</em>)</p>
<p>将 <em>bytes</em> 中的字节数据写入文件指针当前位置的内存并返回写入的字节总数 (一定不小于 <code>len(bytes)</code>，因为如果写入失败，将会引发 <code>ValueError</code>)。 在字节数据被写入后文件位置将会更新。 如果 mmap 创建时设置了 <code>ACCESS_READ</code>，则向其写入将引发 <code>TypeError</code> 异常。</p>
<p>在 3.5 版更改: 现在接受可写的 字节类对象。</p>
<p>在 3.6 版更改: 现在会返回写入的字节总数。</p>
</li>
<li><p><code>write_byte</code>(<em>byte</em>)</p>
<p>将整数值 <em>byte</em> 写入文件指针当前位置的内存；文件位置前进 <code>1</code>。 如果 mmap 创建时设置了 <code>ACCESS_READ</code>，则向其写入将引发 <code>TypeError</code> 异常。</p>
</li>
</ul>
<h3 id="MADV-常量"><a href="#MADV-常量" class="headerlink" title="MADV_* 常量"></a>MADV_* 常量</h3><pre><code>mmap.MADV_NORMAL
mmap.MADV_RANDOM
mmap.MADV_SEQUENTIAL
mmap.MADV_WILLNEED
mmap.MADV_DONTNEED
mmap.MADV_REMOVE
mmap.MADV_DONTFORK
mmap.MADV_DOFORK
mmap.MADV_HWPOISON
mmap.MADV_MERGEABLE
mmap.MADV_UNMERGEABLE
mmap.MADV_SOFT_OFFLINE
mmap.MADV_HUGEPAGE
mmap.MADV_NOHUGEPAGE
mmap.MADV_DONTDUMP
mmap.MADV_DODUMP
mmap.MADV_FREE
mmap.MADV_NOSYNC
mmap.MADV_AUTOSYNC
mmap.MADV_NOCORE
mmap.MADV_CORE
mmap.MADV_PROTECT
mmap.MADV_FREE_REUSABLE
mmap.MADV_FREE_REUSE</code></pre><p>这些选项可被传给 <code>mmap.madvise()</code>。 不是每个选项都存在于每个系统中。</p>
<p>可用性: 具有 madvise() 系统调用的系统。</p>
<p>3.8 新版功能.</p>
<h3 id="MAP-常量"><a href="#MAP-常量" class="headerlink" title="MAP_* 常量"></a>MAP_* 常量</h3><pre><code>mmap.MAP_SHARED
mmap.MAP_PRIVATE
mmap.MAP_DENYWRITE
mmap.MAP_EXECUTABLE
mmap.MAP_ANON
mmap.MAP_ANONYMOUS
mmap.MAP_POPULATE</code></pre><p>这些是可被传给 <code>mmap.mmap()</code> 的各种旗标。 请注意某些选项在某些系统上可能不存在。</p>
<p>在 3.10 版更改: 增加了 MAP_POPULATE 常量。</p>
<h1 id="互联网数据处理"><a href="#互联网数据处理" class="headerlink" title="互联网数据处理"></a>互联网数据处理</h1><p>本章介绍了一些支持处理因特网上常用数据格式的模块。</p>
<ul>
<li><code>email</code> —- 电子邮件与 MIME 处理包<ul>
<li><code>email.message</code>: 表示一封电子邮件信息</li>
<li><code>email.parser</code>: 解析电子邮件信息<ul>
<li>FeedParser API</li>
<li>Parser API</li>
<li>附加说明</li>
</ul>
</li>
<li><code>email.generator</code>: 生成 MIME 文档</li>
<li><code>email.policy</code>: Policy 对象</li>
<li><code>email.errors</code>: 异常和缺陷类</li>
<li><code>email.headerregistry</code>: 自定义标头对象</li>
<li><code>email.contentmanager</code>: 管理 MIME 内容<ul>
<li>内容管理器实例</li>
</ul>
</li>
<li><code>email</code>: 示例</li>
<li><code>email.message.Message</code>: 使用 <code>compat32</code> API 来表示电子邮件消息</li>
<li><code>email.mime</code>: 从头创建电子邮件和 MIME 对象</li>
<li><code>email.header</code>: 国际化标头</li>
<li><code>email.charset</code>: 表示字符集</li>
<li><code>email.encoders</code>: 编码器</li>
<li><code>email.utils</code>: 其他工具</li>
<li><code>email.iterators</code>: 迭代器</li>
</ul>
</li>
<li><code>json</code> —- JSON 编码和解码器<ul>
<li>基本使用</li>
<li>编码器和解码器</li>
<li>异常</li>
<li>标准符合性和互操作性<ul>
<li>字符编码</li>
<li>Infinite 和 NaN 数值</li>
<li>对象中的重复名称</li>
<li>顶级非对象，非数组值</li>
<li>实现限制</li>
</ul>
</li>
<li>命令行界面<ul>
<li>命令行选项</li>
</ul>
</li>
</ul>
</li>
<li><code>mailcap</code> —- Mailcap 文件处理</li>
<li><code>mailbox</code> —- 操作多种格式的邮箱<ul>
<li><code>Mailbox</code> 对象<ul>
<li><code>Maildir</code></li>
<li><code>mbox</code></li>
<li><code>MH</code></li>
<li><code>Babyl</code></li>
<li><code>MMDF</code></li>
</ul>
</li>
<li><code>Message</code> 对象<ul>
<li><code>MaildirMessage</code></li>
<li><code>mboxMessage</code></li>
<li><code>MHMessage</code></li>
<li><code>BabylMessage</code></li>
<li><code>MMDFMessage</code></li>
</ul>
</li>
<li>异常</li>
<li>例子</li>
</ul>
</li>
<li><code>mimetypes</code> —- 映射文件名到 MIME 类型<ul>
<li>MimeTypes 对象</li>
</ul>
</li>
<li><code>base64</code> —- Base16, Base32, Base64, Base85 数据编码<ul>
<li>安全考量</li>
</ul>
</li>
<li><code>binhex</code> —- 对binhex4文件进行编码和解码<ul>
<li>备注</li>
</ul>
</li>
<li><code>binascii</code> —- 二进制和 ASCII 码互转</li>
<li><code>quopri</code> —- 编码与解码经过 MIME 转码的可打印数据</li>
<li><code>uu</code> —- 对 uuencode 文件进行编码与解码</li>
</ul>
<h2 id="email-—-电子邮件与-MIME-处理包"><a href="#email-—-电子邮件与-MIME-处理包" class="headerlink" title="email —- 电子邮件与 MIME 处理包"></a><code>email</code> —- 电子邮件与 MIME 处理包</h2><p><strong>源代码:</strong> <a href="https://github.com/python/cpython/tree/3.10/Lib/email/__init__.py" target="_blank" rel="noopener">Lib/email/<strong>init</strong>.py</a></p>
<hr>
<p><code>email</code> 包是一个用于管理电子邮件消息的库。 它 <em>并非</em> 被设计为执行向 SMTP (<a href="https://tools.ietf.org/html/rfc2821.html" target="_blank" rel="noopener"><strong>RFC 2821</strong></a>), NNTP 或其他服务器发送电子邮件消息的操作；这些是 <code>smtplib</code> 和 <code>nntplib</code> 等模块的功能。 <code>email</code> 包试图尽可能地遵循 RFC，支持 <a href="https://tools.ietf.org/html/rfc5322.html" target="_blank" rel="noopener"><strong>RFC 5322</strong></a> 和 <a href="https://tools.ietf.org/html/rfc6532.html" target="_blank" rel="noopener"><strong>RFC 6532</strong></a>，以及与 MIME 相关的各个 RFC 例如 <a href="https://tools.ietf.org/html/rfc2045.html" target="_blank" rel="noopener"><strong>RFC 2045</strong></a>, <a href="https://tools.ietf.org/html/rfc2046.html" target="_blank" rel="noopener"><strong>RFC 2046</strong></a>, <a href="https://tools.ietf.org/html/rfc2047.html" target="_blank" rel="noopener"><strong>RFC 2047</strong></a>, <a href="https://tools.ietf.org/html/rfc2183.html" target="_blank" rel="noopener"><strong>RFC 2183</strong></a> 和 <a href="https://tools.ietf.org/html/rfc2231.html" target="_blank" rel="noopener"><strong>RFC 2231</strong></a>。</p>
<p>email 包的总体结构可以分为三个主要组件，另外还有第四个组件用于控制其他组件的行为。</p>
<p>这个包的中心组件是代表电子邮件消息的“对象模型”。 应用程序主要通过在 <code>message</code> 子模块中定义的对象模型接口与这个包进行交互。 应用程序可以使用此 API 来询问有关现有电子邮件的问题、构造新的电子邮件，或者添加或移除自身也使用相同对象模型接口的电子邮件子组件。 也就是说，遵循电子邮件消息及其 MIME 子组件的性质，电子邮件对象模型是所有提供 <code>EmailMessage</code> API 的对象所构成的树状结构。</p>
<p>这个包的另外两个主要组件是 <code>parser</code> 和 <code>generator</code>。 parser 接受电子邮件消息的序列化版本（字节流）并将其转换为 <code>EmailMessage</code> 对象树。 generator 接受 <code>EmailMessage</code> 并将其转回序列化的字节流。 (parser 和 generator 还能处理文本字符流，但不建议这种用法，因为这很容易导致某种形式的无效消息。</p>
<p>控制组件是 <code>policy</code> 模块。 每一个 <code>EmailMessage</code>、每一个 <code>generator</code> 和每一个 <code>parser</code> 都有一个相关联的 <code>policy</code> 对象来控制其行为。 通常应用程序只有在 <code>EmailMessage</code> 被创建时才需要指明控制策略，或者通过直接实例代 <code>EmailMessage</code> 来新建电子邮件，或者通过使用 <code>parser</code> 来解析输入流。 但是策略也可以在使用 <code>generator</code> 序列化消息时被更改。 例如，这允许从磁盘解析通用电子邮件消息，而在将消息发送到电子邮件服务器时使用标准 SMTP 设置对其进行序列化。</p>
<p>email 包会尽量地对应用程序隐藏各种控制类 RFC 的细节。 从概念上讲应用程序应当能够将电子邮件消息视为 Unicode 文本和二进制附件的结构化树，而不必担心在序列化时要如何表示它们。 但在实际中，经常有必要至少了解一部分控制类 MIME 消息及其结构的规划，特别是 MIME “内容类型” 的名称和性质以及它们是如何标识多部分文档的。 在大多数情况下这些知识应当仅对于更复杂的应用程序来说才是必需的，并且即便在那时它也应当仅是特定的高层级结构，而不是如何表示这些结构的细节信息。 由于 MIME 内容类型被广泛应用于现代因特网软件（而非只是电子邮件），因此这对许多程序员来说将是很熟悉的概念。</p>
<p>以下小节描述了 <code>email</code> 包的具体功能。 我们会从 <code>message</code> 对象模型开始，它是应用程序将要使用的主要接口，之后是 <code>parser</code> 和 <code>generator</code> 组件。 然后我们会介绍 <code>policy</code> 控制组件，它将完成对这个库的主要组件的处理。</p>
<p>接下来的三个小节会介绍这个包可能引发的异常以及 <code>parser</code> 可能检测到的缺陷（即与 RFC 不相符）。 然后我们会介绍 <code>headerregistry</code> 和 <code>contentmanager</code> 子组件，它们分别提供了用于更精细地操纵标题和载荷的工具。 这两个组件除了包含使用与生成非简单消息的相关特性，还记录了它们的可扩展性 API，这将是高级应用程序所感兴趣的内容。</p>
<p>在此之后是一组使用之前小节所介绍的 API 的基本部分的示例。</p>
<p>前面的内容是 email 包的现代（对 Unicode 支持良好）API。 从 <code>Message</code> 类开始的其余小节则介绍了旧式 <code>compat32</code> API，它会更直接地处理如何表示电子邮件消息的细节。 <code>compat32</code> API <em>不会</em> 向应用程序隐藏 RFC 的相关细节，但对于需要进行此种层级操作的应用程序来说将是很有用的工具。 此文档对于因向下兼容理由而仍然使用 <code>compat32</code> API 的应用程序也是很适合的。</p>
<p>在 3.6 版更改: 文档经过重新组织和撰写以鼓励使用新的 <code>EmailMessage</code>/<code>EmailPolicy</code> API。</p>
<p><code>email</code> 包文档的内容:</p>
<ul>
<li><a href="https://docs.python.org/zh-cn/3.10/library/email.message.html" target="_blank" rel="noopener"><code>email.message</code>: 表示一封电子邮件信息</a></li>
<li><code>email.parser</code>: 解析电子邮件信息<ul>
<li><a href="https://docs.python.org/zh-cn/3.10/library/email.parser.html#feedparser-api" target="_blank" rel="noopener">FeedParser API</a></li>
<li><a href="https://docs.python.org/zh-cn/3.10/library/email.parser.html#parser-api" target="_blank" rel="noopener">Parser API</a></li>
<li><a href="https://docs.python.org/zh-cn/3.10/library/email.parser.html#additional-notes" target="_blank" rel="noopener">附加说明</a></li>
</ul>
</li>
<li><a href="https://docs.python.org/zh-cn/3.10/library/email.generator.html" target="_blank" rel="noopener"><code>email.generator</code>: 生成 MIME 文档</a></li>
<li><a href="https://docs.python.org/zh-cn/3.10/library/email.policy.html" target="_blank" rel="noopener"><code>email.policy</code>: Policy 对象</a></li>
<li><a href="https://docs.python.org/zh-cn/3.10/library/email.errors.html" target="_blank" rel="noopener"><code>email.errors</code>: 异常和缺陷类</a></li>
<li><a href="https://docs.python.org/zh-cn/3.10/library/email.headerregistry.html" target="_blank" rel="noopener"><code>email.headerregistry</code>: 自定义标头对象</a></li>
<li><code>email.contentmanager</code>: 管理 MIME 内容<ul>
<li><a href="https://docs.python.org/zh-cn/3.10/library/email.contentmanager.html#content-manager-instances" target="_blank" rel="noopener">内容管理器实例</a></li>
</ul>
</li>
<li><a href="https://docs.python.org/zh-cn/3.10/library/email.examples.html" target="_blank" rel="noopener"><code>email</code>: 示例</a></li>
</ul>
<p>旧式 API:</p>
<ul>
<li><a href="https://docs.python.org/zh-cn/3.10/library/email.compat32-message.html" target="_blank" rel="noopener"><code>email.message.Message</code>: 使用 <code>compat32</code> API 来表示电子邮件消息</a></li>
<li><a href="https://docs.python.org/zh-cn/3.10/library/email.mime.html" target="_blank" rel="noopener"><code>email.mime</code>: 从头创建电子邮件和 MIME 对象</a></li>
<li><a href="https://docs.python.org/zh-cn/3.10/library/email.header.html" target="_blank" rel="noopener"><code>email.header</code>: 国际化标头</a></li>
<li><a href="https://docs.python.org/zh-cn/3.10/library/email.charset.html" target="_blank" rel="noopener"><code>email.charset</code>: 表示字符集</a></li>
<li><a href="https://docs.python.org/zh-cn/3.10/library/email.encoders.html" target="_blank" rel="noopener"><code>email.encoders</code>: 编码器</a></li>
<li><a href="https://docs.python.org/zh-cn/3.10/library/email.utils.html" target="_blank" rel="noopener"><code>email.utils</code>: 其他工具</a></li>
<li><a href="https://docs.python.org/zh-cn/3.10/library/email.iterators.html" target="_blank" rel="noopener"><code>email.iterators</code>: 迭代器</a></li>
</ul>
<h2 id="json-—-JSON-编码和解码器"><a href="#json-—-JSON-编码和解码器" class="headerlink" title="json —- JSON 编码和解码器"></a><code>json</code> —- JSON 编码和解码器</h2><p><strong>源代码:</strong> <a href="https://github.com/python/cpython/tree/3.10/Lib/json/__init__.py" target="_blank" rel="noopener">Lib/json/<strong>init</strong>.py</a></p>
<hr>
<p><a href="http://json.org/" target="_blank" rel="noopener">JSON (JavaScript Object Notation)</a>，由 <a href="https://tools.ietf.org/html/rfc7159.html" target="_blank" rel="noopener"><strong>RFC 7159</strong></a> (which obsoletes <a href="https://tools.ietf.org/html/rfc4627.html" target="_blank" rel="noopener"><strong>RFC 4627</strong></a>) 和 <a href="http://www.ecma-international.org/publications/standards/Ecma-404.htm" target="_blank" rel="noopener">ECMA-404</a> 指定，是一个受 <a href="https://en.wikipedia.org/wiki/JavaScript" target="_blank" rel="noopener">JavaScript</a> 的对象字面量语法启发的轻量级数据交换格式，尽管它不仅仅是一个严格意义上的 JavaScript 的字集 <a href="https://www.bookstack.cn/read/python-3.10.0-zh/069b207a6de7de69.md#rfc-errata" target="_blank" rel="noopener">1</a>。</p>
<p><code>json</code> 提供了与标准库 <code>marshal</code> 和 <code>pickle</code> 相似的API接口。</p>
<p>对基本的 Python 对象层次结构进行编码：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> json
<span class="token operator">>></span><span class="token operator">></span> json<span class="token punctuation">.</span>dumps<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'foo'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token string">'bar'</span><span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token string">'baz'</span><span class="token punctuation">,</span> None<span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token string">'["foo", {"bar": ["baz", null, 1.0, 2]}]'</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>json<span class="token punctuation">.</span>dumps<span class="token punctuation">(</span><span class="token string">"\"foo\bar"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token string">"\"foo\bar"</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>json<span class="token punctuation">.</span>dumps<span class="token punctuation">(</span><span class="token string">'\u1234'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token string">"\u1234"</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>json<span class="token punctuation">.</span>dumps<span class="token punctuation">(</span><span class="token string">'\\'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token string">"\\"</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>json<span class="token punctuation">.</span>dumps<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">"c"</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">"b"</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">"a"</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">,</span> sort_keys<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span><span class="token string">"a"</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">"b"</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">"c"</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">}</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> io <span class="token keyword">import</span> StringIO
<span class="token operator">>></span><span class="token operator">></span> io <span class="token operator">=</span> StringIO<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> json<span class="token punctuation">.</span>dump<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'streaming API'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> io<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> io<span class="token punctuation">.</span>getvalue<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token string">'["streaming API"]'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>紧凑编码：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> json
<span class="token operator">>></span><span class="token operator">></span> json<span class="token punctuation">.</span>dumps<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token string">'4'</span><span class="token punctuation">:</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token string">'6'</span><span class="token punctuation">:</span> <span class="token number">7</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">,</span> separators<span class="token operator">=</span><span class="token punctuation">(</span><span class="token string">','</span><span class="token punctuation">,</span> <span class="token string">':'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token string">'[1,2,3,{"4":5,"6":7}]'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>美化输出：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> json
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>json<span class="token punctuation">.</span>dumps<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">'4'</span><span class="token punctuation">:</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token string">'6'</span><span class="token punctuation">:</span> <span class="token number">7</span><span class="token punctuation">}</span><span class="token punctuation">,</span> sort_keys<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span> indent<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token string">"4"</span><span class="token punctuation">:</span> <span class="token number">5</span><span class="token punctuation">,</span>
    <span class="token string">"6"</span><span class="token punctuation">:</span> <span class="token number">7</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>JSON解码：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> json
<span class="token operator">>></span><span class="token operator">></span> json<span class="token punctuation">.</span>loads<span class="token punctuation">(</span><span class="token string">'["foo", {"bar":["baz", null, 1.0, 2]}]'</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token string">'foo'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token string">'bar'</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'baz'</span><span class="token punctuation">,</span> None<span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> json<span class="token punctuation">.</span>loads<span class="token punctuation">(</span><span class="token string">'"\\"foo\\bar"'</span><span class="token punctuation">)</span>
<span class="token string">'"foo\x08ar'</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> io <span class="token keyword">import</span> StringIO
<span class="token operator">>></span><span class="token operator">></span> io <span class="token operator">=</span> StringIO<span class="token punctuation">(</span><span class="token string">'["streaming API"]'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> json<span class="token punctuation">.</span>load<span class="token punctuation">(</span>io<span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token string">'streaming API'</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>特殊 JSON 对象解码：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> json
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">def</span> <span class="token function">as_complex</span><span class="token punctuation">(</span>dct<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">if</span> <span class="token string">'__complex__'</span> <span class="token keyword">in</span> dct<span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         <span class="token keyword">return</span> complex<span class="token punctuation">(</span>dct<span class="token punctuation">[</span><span class="token string">'real'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dct<span class="token punctuation">[</span><span class="token string">'imag'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">return</span> dct
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> json<span class="token punctuation">.</span>loads<span class="token punctuation">(</span><span class="token string">'{"__complex__": true, "real": 1, "imag": 2}'</span><span class="token punctuation">,</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     object_hook<span class="token operator">=</span>as_complex<span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">+</span><span class="token number">2j</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> decimal
<span class="token operator">>></span><span class="token operator">></span> json<span class="token punctuation">.</span>loads<span class="token punctuation">(</span><span class="token string">'1.1'</span><span class="token punctuation">,</span> parse_float<span class="token operator">=</span>decimal<span class="token punctuation">.</span>Decimal<span class="token punctuation">)</span>
Decimal<span class="token punctuation">(</span><span class="token string">'1.1'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>扩展 <code>JSONEncoder</code>：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> json
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">class</span> <span class="token class-name">ComplexEncoder</span><span class="token punctuation">(</span>json<span class="token punctuation">.</span>JSONEncoder<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">def</span> <span class="token function">default</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> obj<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         <span class="token keyword">if</span> isinstance<span class="token punctuation">(</span>obj<span class="token punctuation">,</span> complex<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>             <span class="token keyword">return</span> <span class="token punctuation">[</span>obj<span class="token punctuation">.</span>real<span class="token punctuation">,</span> obj<span class="token punctuation">.</span>imag<span class="token punctuation">]</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         <span class="token comment" spellcheck="true"># Let the base class default method raise the TypeError</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         <span class="token keyword">return</span> json<span class="token punctuation">.</span>JSONEncoder<span class="token punctuation">.</span>default<span class="token punctuation">(</span>self<span class="token punctuation">,</span> obj<span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> json<span class="token punctuation">.</span>dumps<span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">+</span> <span class="token number">1j</span><span class="token punctuation">,</span> cls<span class="token operator">=</span>ComplexEncoder<span class="token punctuation">)</span>
<span class="token string">'[2.0, 1.0]'</span>
<span class="token operator">>></span><span class="token operator">></span> ComplexEncoder<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">+</span> <span class="token number">1j</span><span class="token punctuation">)</span>
<span class="token string">'[2.0, 1.0]'</span>
<span class="token operator">>></span><span class="token operator">></span> list<span class="token punctuation">(</span>ComplexEncoder<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>iterencode<span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">+</span> <span class="token number">1j</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token string">'[2.0'</span><span class="token punctuation">,</span> <span class="token string">', 1.0'</span><span class="token punctuation">,</span> <span class="token string">']'</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>从命令行使用 <code>json.tool</code> 来验证并美化输出：</p>
<pre class="line-numbers language-python"><code class="language-python">$ echo <span class="token string">'{"json":"obj"}'</span> <span class="token operator">|</span> python <span class="token operator">-</span>m json<span class="token punctuation">.</span>tool
<span class="token punctuation">{</span>
    <span class="token string">"json"</span><span class="token punctuation">:</span> <span class="token string">"obj"</span>
<span class="token punctuation">}</span>
$ echo <span class="token string">'{1.2:3.4}'</span> <span class="token operator">|</span> python <span class="token operator">-</span>m json<span class="token punctuation">.</span>tool
Expecting property name enclosed <span class="token keyword">in</span> double quotes<span class="token punctuation">:</span> line <span class="token number">1</span> column <span class="token number">2</span> <span class="token punctuation">(</span>char <span class="token number">1</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>注解</p>
<p>JSON 是 YAML 1.2 的一个子集。由该模块的默认设置生成的 JSON （尤其是默认的 “分隔符” 设置值）也是 YAML 1.0 and 1.1 的一个子集。因此该模块也能够用于序列化为 YAML。</p>
<p>注解</p>
<p>这个模块的编码器和解码器默认保护输入和输出的顺序。仅当底层的容器未排序时才会失去顺序。</p>
<p>在 Python 3.7 之前，<code>dict</code> 并不保证有序，因此输入和输出通常都是乱序的，除非是明确地请求 <code>collections.OrderedDict</code>。 从 Python 3.7 开始，普通的 <code>dict</code> 会保留顺序，因此不必再为 JSON 的生成和解析指定使用 <code>collections.OrderedDict</code>。</p>
<h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p><code>json.dump</code>(<em>obj</em>, <em>fp</em>, **<em>,</em> skipkeys=False<em>,</em> ensure_ascii=True<em>,</em> check_circular=True<em>,</em> allow_nan=True<em>,</em> cls=None<em>,</em> indent=None<em>,</em> separators=None<em>,</em> default=None<em>,</em> sort_keys=False<em>,</em> <em>*kw</em>)</p>
<p>使用这个 转换表 将 <em>obj</em> 序列化为 JSON 格式化流形式的 <em>fp</em> (支持 <code>.write()</code> 的 file-like object)。</p>
<p>如果 <em>skipkeys</em> 是 true （默认为 <code>False</code>），那么那些不是基本对象的字典的键会被跳过；否则引发一个 <code>TypeError</code>。</p>
<p><code>json</code> 模块始终产生 <code>str</code> 对象而非 <code>bytes</code> 对象。因此，<code>fp.write()</code> 必须支持 <code>str</code> 输入。</p>
<p>如果 <em>ensure_ascii</em> 是 true （即默认值），输出保证将所有输入的非 ASCII 字符转义。如果 <em>ensure_ascii</em> 是 false，这些字符会原样输出。</p>
<p>如果 <em>check_circular</em> 是为假值 (默认为 <code>True</code>)，那么容器类型的循环引用检验会被跳过并且循环引用会引发一个 <code>OverflowError</code> (或者更糟的情况)。</p>
<p>如果 <em>allow_nan</em> 是 false（默认为 <code>True</code>），那么在对严格 JSON 规格范围外的 <code>float</code> 类型值（<code>nan</code>、<code>inf</code> 和 <code>-inf</code>）进行序列化时会引发一个 <code>ValueError</code>。如果 <em>allow_nan</em> 是 true，则使用它们的 JavaScript 等价形式（<code>NaN</code>、<code>Infinity</code> 和 <code>-Infinity</code>）。</p>
<p>如果 <em>indent</em> 是一个非负整数或者字符串，那么 JSON 数组元素和对象成员会被美化输出为该值指定的缩进等级。 如果缩进等级为零、负数或者 <code>""</code>，则只会添加换行符。 <code>None</code> (默认值) 选择最紧凑的表达。 使用一个正整数会让每一层缩进同样数量的空格。 如果 <em>indent</em> 是一个字符串 (比如 <code>"\t"</code>)，那个字符串会被用于缩进每一层。</p>
<p>在 3.2 版更改: 现允许使用字符串作为 <em>indent</em> 而不再仅仅是整数。</p>
<p>当被指定时，<em>separators</em> 应当是一个 <code>(item_separator, key_separator)</code> 元组。当 <em>indent</em> 为 <code>None</code> 时，默认值取 <code>(', ', ': ')</code>，否则取 <code>(',', ': ')</code>。为了得到最紧凑的 JSON 表达式，你应该指定其为 <code>(',', ':')</code> 以消除空白字符。</p>
<p>在 3.4 版更改: 现当 <em>indent</em> 不是 <code>None</code> 时，采用 <code>(',', ': ')</code> 作为默认值。</p>
<p>当 <em>default</em> 被指定时，其应该是一个函数，每当某个对象无法被序列化时它会被调用。它应该返回该对象的一个可以被 JSON 编码的版本或者引发一个 <code>TypeError</code>。如果没有被指定，则会直接引发 <code>TypeError</code>。</p>
<p>如果 <em>sort_keys</em> 是 true（默认为 <code>False</code>），那么字典的输出会以键的顺序排序。</p>
<p>为了使用一个自定义的 <code>JSONEncoder</code> 子类（比如：覆盖了 <code>default()</code> 方法来序列化额外的类型）， 通过 <em>cls</em> 关键字参数来指定；否则将使用 <code>JSONEncoder</code>。</p>
<p>在 3.6 版更改: 所有可选形参现在都是 仅限关键字参数。</p>
<p>注解</p>
<p>与 <code>pickle</code> 和 <code>marshal</code> 不同，JSON 不是一个具有框架的协议，所以尝试多次使用同一个 <em>fp</em> 调用 <code>dump()</code> 来序列化多个对象会产生一个不合规的 JSON 文件。</p>
<p><code>json.dumps</code>(<em>obj</em>, **<em>,</em> skipkeys=False<em>,</em> ensure_ascii=True<em>,</em> check_circular=True<em>,</em> allow_nan=True<em>,</em> cls=None<em>,</em> indent=None<em>,</em> separators=None<em>,</em> default=None<em>,</em> sort_keys=False<em>,</em> <em>*kw</em>)</p>
<p>使用这个 转换表 将 <em>obj</em> 序列化为 JSON 格式的 <code>str</code>。 其参数的含义与 <code>dump()</code> 中的相同。</p>
<p>注解</p>
<p>JSON 中的键-值对中的键永远是 <code>str</code> 类型的。当一个对象被转化为 JSON 时，字典中所有的键都会被强制转换为字符串。这所造成的结果是字典被转换为 JSON 然后转换回字典时可能和原来的不相等。换句话说，如果 x 具有非字符串的键，则有 <code>loads(dumps(x)) != x</code>。</p>
<p><code>json.load</code>(<em>fp</em>, **<em>,</em> cls=None<em>,</em> object_hook=None<em>,</em> parse_float=None<em>,</em> parse_int=None<em>,</em> parse_constant=None<em>,</em> object_pairs_hook=None<em>,</em> <em>*kw</em>)</p>
<p>使用这个 转换表 将 <em>fp</em> (一个支持 <code>.read()</code> 并包含一个 JSON 文档的 text file 或者 binary file) 反序列化为一个 Python 对象。</p>
<p><em>object_hook</em> 是一个可选的函数，它会被调用于每一个解码出的对象字面量（即一个 <code>dict</code>）。<em>object_hook</em> 的返回值会取代原本的 <code>dict</code>。这一特性能够被用于实现自定义解码器（如 <a href="http://www.jsonrpc.org/" target="_blank" rel="noopener">JSON-RPC</a> 的类型提示)。</p>
<p><em>object_pairs_hook</em> 是一个可选的函数，它会被调用于每一个有序列表对解码出的对象字面量。 <em>object_pairs_hook</em> 的返回值将会取代原本的 <code>dict</code> 。这一特性能够被用于实现自定义解码器。如果 <em>object_hook</em> 也被定义， <em>object_pairs_hook</em> 优先。</p>
<p>在 3.1 版更改: 添加了对 <em>object_pairs_hook</em> 的支持。</p>
<p><em>parse_float</em> ，如果指定，将与每个要解码 JSON 浮点数的字符串一同调用。默认状态下，相当于 <code>float(num_str)</code> 。可以用于对 JSON 浮点数使用其它数据类型和语法分析程序 （比如 <code>decimal.Decimal</code> ）。</p>
<p><em>parse_int</em> ，如果指定，将与每个要解码 JSON 整数的字符串一同调用。默认状态下，相当于 <code>int(num_str)</code> 。可以用于对 JSON 整数使用其它数据类型和语法分析程序 （比如 <code>float</code> ）。</p>
<p><em>parse_constant</em> ，如果指定，将要与以下字符串中的一个一同调用： <code>'-Infinity'</code> ， <code>'Infinity'</code> ， <code>'NaN'</code> 。如果遇到无效的 JSON 数字则可以使用它引发异常。</p>
<p>在 3.1 版更改: <em>parse_constant</em> 不再调用 ‘null’ ， ‘true’ ， ‘false’ 。</p>
<p>要使用自定义的 <code>JSONDecoder</code> 子类，用 <code>cls</code> 指定他；否则使用 <code>JSONDecoder</code> 。额外的关键词参数会通过类的构造函数传递。</p>
<p>如果反序列化的数据不是有效 JSON 文档，引发 <code>JSONDecodeError</code> 错误。</p>
<p>在 3.6 版更改: 所有可选形参现在都是 仅限关键字参数。</p>
<p>在 3.6 版更改: <em>fp</em> 现在可以是 binary file 。输入编码应当是 UTF-8 ， UTF-16 或者 UTF-32 。</p>
<p><code>json.loads</code>(<em>s</em>, **<em>,</em> cls=None<em>,</em> object_hook=None<em>,</em> parse_float=None<em>,</em> parse_int=None<em>,</em> parse_constant=None<em>,</em> object_pairs_hook=None<em>,</em> <em>*kw</em>)</p>
<p>使用这个 转换表 将 <em>s</em> (一个包含 JSON 文档的 <code>str</code>, <code>bytes</code> 或 <code>bytearray</code> 实例) 反序列化为 Python 对象。</p>
<p>其他参数的含义与 <code>load()</code> 中的相同。</p>
<p>如果反序列化的数据不是有效 JSON 文档，引发 <code>JSONDecodeError</code> 错误。</p>
<p>在 3.6 版更改: <em>s</em> 现在可以为 <code>bytes</code> 或 <code>bytearray</code> 类型。 输入编码应为 UTF-8, UTF-16 或 UTF-32。</p>
<p>在 3.9 版更改: 关键字参数 <em>encoding</em> 已被移除。</p>
<h3 id="编码器和解码器"><a href="#编码器和解码器" class="headerlink" title="编码器和解码器"></a>编码器和解码器</h3><p><em>class</em> <code>json.JSONDecoder</code>(**<em>,</em> object_hook=None<em>,</em> parse_float=None<em>,</em> parse_int=None<em>,</em> parse_constant=None<em>,</em> strict=True<em>,</em> object_pairs_hook=None*)</p>
<p>简单的JSON解码器。</p>
<p>默认情况下，解码执行以下翻译:</p>
<table>
<thead>
<tr>
<th align="left">JSON</th>
<th align="left">Python</th>
</tr>
</thead>
<tbody><tr>
<td align="left">object — 对象</td>
<td align="left">dict</td>
</tr>
<tr>
<td align="left">array</td>
<td align="left">list — 列表</td>
</tr>
<tr>
<td align="left">string</td>
<td align="left">str</td>
</tr>
<tr>
<td align="left">number (int)</td>
<td align="left">int</td>
</tr>
<tr>
<td align="left">number (real)</td>
<td align="left">float</td>
</tr>
<tr>
<td align="left">true</td>
<td align="left">True</td>
</tr>
<tr>
<td align="left">false</td>
<td align="left">False</td>
</tr>
<tr>
<td align="left">null</td>
<td align="left">None</td>
</tr>
</tbody></table>
<p>它还将“NaN”、“Infinity”和“-Infinity”理解为它们对应的“float”值，这超出了JSON规范。</p>
<p>如果指定了 <em>object_hook</em>，它将被调用并传入每个已解码 JSON 对象的结果，并且其返回值将被用来替代给定的 <code>dict</code>。 它可被用于提供自定义的反序列化操作（例如支持 <a href="http://www.jsonrpc.org/" target="_blank" rel="noopener">JSON-RPC</a> 类提示）。</p>
<p>如果指定了 <em>object_pairs_hook</em> 则它将被调用并传入以对照值有序列表进行解码的每个 JSON 对象的结果。 <em>object_pairs_hook</em> 的结果值将被用来替代 <code>dict</code>。 这一特性可被用于实现自定义解码器。 如果还定义了 <em>object_hook*，则 *object_pairs_hook</em> 的优先级更高。</p>
<p>在 3.1 版更改: 添加了对 <em>object_pairs_hook</em> 的支持。</p>
<p><em>parse_float</em> ，如果指定，将与每个要解码 JSON 浮点数的字符串一同调用。默认状态下，相当于 <code>float(num_str)</code> 。可以用于对 JSON 浮点数使用其它数据类型和语法分析程序 （比如 <code>decimal.Decimal</code> ）。</p>
<p><em>parse_int</em> ，如果指定，将与每个要解码 JSON 整数的字符串一同调用。默认状态下，相当于 <code>int(num_str)</code> 。可以用于对 JSON 整数使用其它数据类型和语法分析程序 （比如 <code>float</code> ）。</p>
<p><em>parse_constant</em> ，如果指定，将要与以下字符串中的一个一同调用： <code>'-Infinity'</code> ， <code>'Infinity'</code> ， <code>'NaN'</code> 。如果遇到无效的 JSON 数字则可以使用它引发异常。</p>
<p>如果 <em>strict</em> 为 false （默认为 <code>True</code> ），那么控制字符将被允许在字符串内。在此上下文中的控制字符编码在范围 0—31 内的字符，包括 <code>'\t'</code> (制表符）， <code>'\n'</code> ， <code>'\r'</code> 和 <code>'\0'</code> 。</p>
<p>如果反序列化的数据不是有效 JSON 文档，引发 <code>JSONDecodeError</code> 错误。</p>
<p>在 3.6 版更改: 所有形参现在都是 仅限关键字参数。</p>
<ul>
<li><p><code>decode</code>(<em>s</em>)</p>
<p>返回 <em>s</em> 的 Python 表示形式（包含一个 JSON 文档的 <code>str</code> 实例）。</p>
<p>如果给定的 JSON 文档无效则将引发 <code>JSONDecodeError</code>。</p>
</li>
<li><p><code>raw_decode</code>(<em>s</em>)</p>
<p>从 <em>s</em> 中解码出 JSON 文档（以 JSON 文档开头的一个 <code>str</code> 对象）并返回一个 Python 表示形式为 2 元组以及指明该文档在 <em>s</em> 中结束位置的序号。</p>
<p>这可以用于从一个字符串解码JSON文档，该字符串的末尾可能有无关的数据。</p>
</li>
</ul>
<p><em>class</em> <code>json.JSONEncoder</code>(<em>**,</em> skipkeys=False<em>,</em> ensure_ascii=True<em>,</em> check_circular=True<em>,</em> allow_nan=True<em>,</em> sort_keys=False<em>,</em> indent=None<em>,</em> separators=None<em>,</em> default=None*)</p>
<p>用于Python数据结构的可扩展JSON编码器。</p>
<p>默认支持以下对象和类型：</p>
<table>
<thead>
<tr>
<th align="left">Python</th>
<th align="left">JSON</th>
</tr>
</thead>
<tbody><tr>
<td align="left">dict</td>
<td align="left">object — 对象</td>
</tr>
<tr>
<td align="left">list, tuple</td>
<td align="left">array</td>
</tr>
<tr>
<td align="left">str</td>
<td align="left">string</td>
</tr>
<tr>
<td align="left">int, float, int 和 float 派生的枚举</td>
<td align="left">number</td>
</tr>
<tr>
<td align="left">True</td>
<td align="left">true</td>
</tr>
<tr>
<td align="left">False</td>
<td align="left">false</td>
</tr>
<tr>
<td align="left">None</td>
<td align="left">null</td>
</tr>
</tbody></table>
<p>在 3.4 版更改: 添加了对 int 和 float 派生的枚举类的支持</p>
<p>为了将其拓展至识别其他对象，需要子类化并实现 <code>default()</code> 方法于另一种返回 <code>o</code> 的可序列化对象的方法如果可行，否则它应该调用超类实现（来引发 <code>TypeError</code> ）。</p>
<p>如果 <em>skipkeys</em> 为假值（默认），则当尝试对非 <code>str</code>, <code>int</code>, <code>float</code> 或 <code>None</code> 的键进行编码时将会引发 <code>TypeError</code>。 如果 <em>skipkeys</em> 为真值，这些条目将被直接跳过。</p>
<p>如果 <em>ensure_ascii</em> 是 true （即默认值），输出保证将所有输入的非 ASCII 字符转义。如果 <em>ensure_ascii</em> 是 false，这些字符会原样输出。</p>
<p>如果 <em>check_circular</em> 为 true （默认），那么列表，字典，和自定义编码的对象在编码期间会被检查重复循环引用防止无限递归（无限递归将导致 <code>OverflowError</code> ）。否则，这样进行检查。</p>
<p>如果 <em>allow_nan</em> 为 true （默认），那么 <code>NaN</code> ， <code>Infinity</code> ，和 <code>-Infinity</code> 进行编码。此行为不符合 JSON 规范，但与大多数的基于 Javascript 的编码器和解码器一致。否则，它将是一个 <code>ValueError</code> 来编码这些浮点数。</p>
<p>如果 <em>sort_keys</em> 为 true （默认为： <code>False</code> ），那么字典的输出是按照键排序；这对回归测试很有用，以确保可以每天比较 JSON 序列化。</p>
<p>如果 <em>indent</em> 是一个非负整数或者字符串，那么 JSON 数组元素和对象成员会被美化输出为该值指定的缩进等级。 如果缩进等级为零、负数或者 <code>""</code>，则只会添加换行符。 <code>None</code> (默认值) 选择最紧凑的表达。 使用一个正整数会让每一层缩进同样数量的空格。 如果 <em>indent</em> 是一个字符串 (比如 <code>"\t"</code>)，那个字符串会被用于缩进每一层。</p>
<p>在 3.2 版更改: 现允许使用字符串作为 <em>indent</em> 而不再仅仅是整数。</p>
<p>当被指定时，<em>separators</em> 应当是一个 <code>(item_separator, key_separator)</code> 元组。当 <em>indent</em> 为 <code>None</code> 时，默认值取 <code>(', ', ': ')</code>，否则取 <code>(',', ': ')</code>。为了得到最紧凑的 JSON 表达式，你应该指定其为 <code>(',', ':')</code> 以消除空白字符。</p>
<p>在 3.4 版更改: 现当 <em>indent</em> 不是 <code>None</code> 时，采用 <code>(',', ': ')</code> 作为默认值。</p>
<p>当 <em>default</em> 被指定时，其应该是一个函数，每当某个对象无法被序列化时它会被调用。它应该返回该对象的一个可以被 JSON 编码的版本或者引发一个 <code>TypeError</code>。如果没有被指定，则会直接引发 <code>TypeError</code>。</p>
<p>在 3.6 版更改: 所有形参现在都是 仅限关键字参数。</p>
<ul>
<li><p><code>default</code>(<em>o</em>)</p>
<p>在子类中实现这种方法使其返回 <em>o</em> 的可序列化对象，或者调用基础实现（引发 <code>TypeError</code> ）。</p>
<p>例如，为了支持任意的迭代器，你可以这样来实现 <code>default()</code>:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">default</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> o<span class="token punctuation">)</span><span class="token punctuation">:</span>
   <span class="token keyword">try</span><span class="token punctuation">:</span>
       iterable <span class="token operator">=</span> iter<span class="token punctuation">(</span>o<span class="token punctuation">)</span>
   <span class="token keyword">except</span> TypeError<span class="token punctuation">:</span>
       <span class="token keyword">pass</span>
   <span class="token keyword">else</span><span class="token punctuation">:</span>
       <span class="token keyword">return</span> list<span class="token punctuation">(</span>iterable<span class="token punctuation">)</span>
   <span class="token comment" spellcheck="true"># Let the base class default method raise the TypeError</span>
   <span class="token keyword">return</span> json<span class="token punctuation">.</span>JSONEncoder<span class="token punctuation">.</span>default<span class="token punctuation">(</span>self<span class="token punctuation">,</span> o<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><code>encode</code>(<em>o</em>)</p>
<p>返回 Python <em>o</em> 数据结构的 JSON 字符串表达方式。例如:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> json<span class="token punctuation">.</span>JSONEncoder<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">"foo"</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"bar"</span><span class="token punctuation">,</span> <span class="token string">"baz"</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token string">'{"foo": ["bar", "baz"]}'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li><p><code>iterencode</code>(<em>o</em>)</p>
<p>编码给定对象 <em>o</em> ，并且让每个可用的字符串表达方式。例如:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">for</span> chunk <span class="token keyword">in</span> json<span class="token punctuation">.</span>JSONEncoder<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>iterencode<span class="token punctuation">(</span>bigobject<span class="token punctuation">)</span><span class="token punctuation">:</span>
    mysocket<span class="token punctuation">.</span>write<span class="token punctuation">(</span>chunk<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
</ul>
<h3 id="异常-3"><a href="#异常-3" class="headerlink" title="异常"></a>异常</h3><p><em>exception</em> <code>json.JSONDecodeError</code>(<em>msg</em>, <em>doc</em>, <em>pos</em>)</p>
<p>拥有以下附加属性的 <code>ValueError</code> 的子类：</p>
<ul>
<li><p><code>msg</code></p>
<p>未格式化的错误消息。</p>
</li>
<li><p><code>doc</code></p>
<p>正在解析的 JSON 文档。</p>
</li>
<li><p><code>pos</code></p>
<p>The start index of <em>doc</em> where parsing failed.</p>
</li>
<li><p><code>lineno</code></p>
<p>The line corresponding to <em>pos</em>.</p>
</li>
<li><p><code>colno</code></p>
<p>The column corresponding to <em>pos</em>.</p>
</li>
</ul>
<p>3.5 新版功能.</p>
<h3 id="标准符合性和互操作性"><a href="#标准符合性和互操作性" class="headerlink" title="标准符合性和互操作性"></a>标准符合性和互操作性</h3><p>JSON 格式由 <a href="https://tools.ietf.org/html/rfc7159.html" target="_blank" rel="noopener"><strong>RFC 7159</strong></a> 和 <a href="http://www.ecma-international.org/publications/standards/Ecma-404.htm" target="_blank" rel="noopener">ECMA-404</a> 指定。此段落详细讲了这个模块符合 RFC 的级别。简单来说， <code>JSONEncoder</code> 和 <code>JSONDecoder</code> 子类，和明确提到的参数以外的参数，不作考虑。</p>
<p>此模块不严格遵循于 RFC ，它实现了一些扩展是有效的 Javascript 但不是有效的 JSON。尤其是：</p>
<ul>
<li>无限和 NaN 数值是被接受并输出；</li>
<li>对象内的重复名称是接受的，并且仅使用最后一对属性-值对的值。</li>
</ul>
<p>自从 RFC 允许符合 RFC 的语法分析程序接收 不符合 RFC 的输入文本以来，这个模块的解串器在默认状态下默认符合 RFC 。</p>
<h4 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h4><p>RFC 要求使用 UTF-8 ， UTF-16 ，或 UTF-32 之一来表示 JSON ，为了最大互通性推荐使用 UTF-8 。</p>
<p>RFC允许，尽管不是必须的，这个模块的序列化默认设置为 <em>ensure_ascii=True</em> ，这样消除输出以便结果字符串至容纳 ASCII 字符。</p>
<p><em>ensure_ascii</em> 参数以外，此模块是严格的按照在 Python 对象和 <code>Unicode strings</code> 间的转换定义的，并且因此不能直接解决字符编码的问题。</p>
<p>RFC 禁止添加字符顺序标记（ BOM ）在 JSON 文本的开头，这个模块的序列化器不添加 BOM 标记在它的输出上。 RFC，准许 JSON 反序列化器忽略它们输入中的初始 BOM 标记，但不要求。此模块的反序列化器引发 <code>ValueError</code> 当存在初始 BOM 标记。</p>
<p>RFC 不会明确禁止包含字节序列的 JSON 字符串这不对应有效的 Unicode 字符（比如 不成对的 UTF-16 的替代物），但是它确实指出它们可能会导致互操作性问题。默认下，模块对这样的序列接受和输出（当在原始 <code>str</code> 存在时）代码点。</p>
<h4 id="Infinite-和-NaN-数值"><a href="#Infinite-和-NaN-数值" class="headerlink" title="Infinite 和 NaN 数值"></a>Infinite 和 NaN 数值</h4><p>RFC 不允许 infinite 或者 NaN 数值的表达方式。尽管这样，默认情况下，此模块接受并且输出 <code>Infinity</code> ， <code>-Infinity</code>，和 <code>NaN</code> 好像它们是有效的JSON数字字面值</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token comment" spellcheck="true"># Neither of these calls raises an exception, but the results are not valid JSON</span>
<span class="token operator">>></span><span class="token operator">></span> json<span class="token punctuation">.</span>dumps<span class="token punctuation">(</span>float<span class="token punctuation">(</span><span class="token string">'-inf'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token string">'-Infinity'</span>
<span class="token operator">>></span><span class="token operator">></span> json<span class="token punctuation">.</span>dumps<span class="token punctuation">(</span>float<span class="token punctuation">(</span><span class="token string">'nan'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token string">'NaN'</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token comment" spellcheck="true"># Same when deserializing</span>
<span class="token operator">>></span><span class="token operator">></span> json<span class="token punctuation">.</span>loads<span class="token punctuation">(</span><span class="token string">'-Infinity'</span><span class="token punctuation">)</span>
<span class="token operator">-</span>inf
<span class="token operator">>></span><span class="token operator">></span> json<span class="token punctuation">.</span>loads<span class="token punctuation">(</span><span class="token string">'NaN'</span><span class="token punctuation">)</span>
nan<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>序列化器中， <em>allow_nan</em> 参数可用于替代这个行为。反序列化器中， <em>parse_constant</em> 参数，可用于替代这个行为。</p>
<h4 id="对象中的重复名称"><a href="#对象中的重复名称" class="headerlink" title="对象中的重复名称"></a>对象中的重复名称</h4><p>RFC 具体说明了 在 JSON对象里的名字应该是唯一的，但没有规定如何处理JSON对象中的重复名称。默认下，此模块不引发异常；作为替代，对于给定名它将忽略除姓-值对之外的所有对:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> weird_json <span class="token operator">=</span> <span class="token string">'{"x": 1, "x": 2, "x": 3}'</span>
<span class="token operator">>></span><span class="token operator">></span> json<span class="token punctuation">.</span>loads<span class="token punctuation">(</span>weird_json<span class="token punctuation">)</span>
<span class="token punctuation">{</span><span class="token string">'x'</span><span class="token punctuation">:</span> <span class="token number">3</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>The <em>object_pairs_hook</em> parameter can be used to alter this behavior.</p>
<h4 id="顶级非对象，非数组值"><a href="#顶级非对象，非数组值" class="headerlink" title="顶级非对象，非数组值"></a>顶级非对象，非数组值</h4><p>过时的 <a href="https://tools.ietf.org/html/rfc4627.html" target="_blank" rel="noopener"><strong>RFC 4627</strong></a> 指定的旧版本 JSON 要求 JSON 文本顶级值必须是 JSON 对象或数组（ Python <code>dict</code> 或 <code>list</code> ），并且不能是 JSON null 值，布尔值，数值或者字符串值。 <a href="https://tools.ietf.org/html/rfc7159.html" target="_blank" rel="noopener"><strong>RFC 7159</strong></a> 移除这个限制，此模块没有并且从未在序列化器和反序列化器中实现这个限制。</p>
<p>无论如何，为了最大化地获取互操作性，你可能希望自己遵守该原则。</p>
<h4 id="实现限制"><a href="#实现限制" class="headerlink" title="实现限制"></a>实现限制</h4><p>一些 JSON 反序列化器的实现应该在以下方面做出限制：</p>
<ul>
<li>可接受的 JSON 文本大小</li>
<li>嵌套 JSON 对象和数组的最高水平</li>
<li>JSON 数字的范围和精度</li>
<li>JSON 字符串的内容和最大长度</li>
</ul>
<p>此模块不强制执行任何上述限制，除了相关的 Python 数据类型本身或者 Python 解释器本身的限制以外。</p>
<p>当序列化为 JSON ，在应用中当心此类限制这可能破坏你的 JSON 。特别是，通常将 JSON 数字反序列化为 IEEE 754 双精度数字，从而受到该表示方式的范围和精度限制。这是特别相关的，当序列化非常大的 Python <code>int</code> 值时，或者当序列化 “exotic” 数值类型的实例时比如 <code>decimal.Decimal</code> 。</p>
<h3 id="命令行界面"><a href="#命令行界面" class="headerlink" title="命令行界面"></a>命令行界面</h3><p><strong>源代码：</strong> <a href="https://github.com/python/cpython/tree/3.10/Lib/json/tool.py" target="_blank" rel="noopener">Lib/json/tool.py</a></p>
<hr>
<p>The <code>json.tool</code> module provides a simple command line interface to validate and pretty-print JSON objects.</p>
<p>如果未指定可选的 <code>infile</code> 和 <code>outfile</code> 参数，则将分别使用 <code>sys.stdin</code> 和 <code>sys.stdout</code>:</p>
<pre class="line-numbers language-python"><code class="language-python">$ echo <span class="token string">'{"json": "obj"}'</span> <span class="token operator">|</span> python <span class="token operator">-</span>m json<span class="token punctuation">.</span>tool
<span class="token punctuation">{</span>
    <span class="token string">"json"</span><span class="token punctuation">:</span> <span class="token string">"obj"</span>
<span class="token punctuation">}</span>
$ echo <span class="token string">'{1.2:3.4}'</span> <span class="token operator">|</span> python <span class="token operator">-</span>m json<span class="token punctuation">.</span>tool
Expecting property name enclosed <span class="token keyword">in</span> double quotes<span class="token punctuation">:</span> line <span class="token number">1</span> column <span class="token number">2</span> <span class="token punctuation">(</span>char <span class="token number">1</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在 3.5 版更改: 输出现在将与输入顺序保持一致。 请使用 <code>--sort-keys</code> 选项来将输出按照键的字母顺序排序。</p>
<h4 id="命令行选项"><a href="#命令行选项" class="headerlink" title="命令行选项"></a>命令行选项</h4><pre><code>infile</code></pre><p>要被验证或美化打印的 JSON 文件：</p>
<pre class="line-numbers language-python"><code class="language-python">$ python <span class="token operator">-</span>m json<span class="token punctuation">.</span>tool mp_films<span class="token punctuation">.</span>json
<span class="token punctuation">[</span>
    <span class="token punctuation">{</span>
        <span class="token string">"title"</span><span class="token punctuation">:</span> <span class="token string">"And Now for Something Completely Different"</span><span class="token punctuation">,</span>
        <span class="token string">"year"</span><span class="token punctuation">:</span> <span class="token number">1971</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">{</span>
        <span class="token string">"title"</span><span class="token punctuation">:</span> <span class="token string">"Monty Python and the Holy Grail"</span><span class="token punctuation">,</span>
        <span class="token string">"year"</span><span class="token punctuation">:</span> <span class="token number">1975</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果 <em>infile</em> 未指定，则从 <code>sys.stdin</code> 读取。</p>
<pre><code>outfile</code></pre><p>将 <em>infile</em> 输出写入到给定的 <em>outfile</em>。 在其他情况下写入到 <code>sys.stdout</code>。</p>
<pre><code>--sort-keys</code></pre><p>将字典输出按照键的字母顺序排序。</p>
<p>3.5 新版功能.</p>
<pre><code>--no-ensure-ascii</code></pre><p>禁用非 ASCII 字符的转义，详情参见 <code>json.dumps()</code>。</p>
<p>3.9 新版功能.</p>
<pre><code>--json-lines</code></pre><p>将每个输入行解析为单独的 JSON 对象。</p>
<p>3.8 新版功能.</p>
<pre><code>--indent``,` `--tab``,` `--no-indent``,` `--compact</code></pre><p>用于空白符控制的互斥选项。</p>
<p>3.9 新版功能.</p>
<pre><code>-h``,` `--help</code></pre><p>显示帮助消息。</p>
<h2 id="mailcap-—-Mailcap-文件处理"><a href="#mailcap-—-Mailcap-文件处理" class="headerlink" title="mailcap —- Mailcap 文件处理"></a><code>mailcap</code> —- Mailcap 文件处理</h2><p><strong>源代码:</strong> <a href="https://github.com/python/cpython/tree/3.10/Lib/mailcap.py" target="_blank" rel="noopener">Lib/mailcap.py</a></p>
<hr>
<p>Mailcap 文件可用来配置支持 MIME 的应用程序例如邮件阅读器和 Web 浏览器如何响应具有不同 MIME 类型的文件。 (“mailcap” 这个名称源自短语 “mail capability”。) 例如，一个 mailcap 文件可能包含 <code>video/mpeg; xmpeg %s</code> 这样的行。 然后，如果用户遇到 MIME 类型为 <em>video/mpeg</em> 的邮件消息或 Web 文档时，<code>%s</code> 将被替换为一个文件名 (通常属于临时文件) 并且会自动启动 <strong>xmpeg</strong> 程序来查看该文件。</p>
<p>mailcap 格式的说明文档见 <a href="https://tools.ietf.org/html/rfc1524.html" target="_blank" rel="noopener"><strong>RFC 1524</strong></a>, “A User Agent Configuration Mechanism For Multimedia Mail Format Information”，但它并不是一个互联网标准。 不过，mailcap 文件在大多数 Unix 系统上都受到支持。</p>
<p><code>mailcap.findmatch</code>(<em>caps</em>, <em>MIMEtype</em>, <em>key=’view’</em>, <em>filename=’/dev/null’</em>, <em>plist=[]</em>)</p>
<p>返回一个 2 元组；其中第一个元素是包含所要执行命令的字符串 (它可被传递给 <code>os.system()</code>)，第二个元素是对应于给定 MIME 类型的 mailcap 条目。 如果找不到匹配的 MIME 类型，则将返回 <code>(None, None)</code>。</p>
<p><em>key</em> 是所需字段的名称，它代表要执行的活动类型；默认值是 ‘view’，因为在最通常的情况下你只是想要查看 MIME 类型数据的正文。 其他可能的值还有 ‘compose’ 和 ‘edit’，分别用于想要创建给定 MIME 类型正文或修改现有正文数据的情况。 请参阅 <a href="https://tools.ietf.org/html/rfc1524.html" target="_blank" rel="noopener"><strong>RFC 1524</strong></a> 获取这些字段的完整列表。</p>
<p><em>filename</em> 是在命令行中用来替换 <code>%s</code> 的文件名；默认值 <code>'/dev/null'</code> 几乎肯定不是你想要的，因此通常你要通过指定一个文件名来重载它。</p>
<p><em>plist</em> 可以是一个包含命名形参的列表；默认值只是一个空列表。 列表中的每个条目必须为包含形参名称的字符串、等于号 (<code>'='</code>) 以及形参的值。 Mailcap 条目可以包含形如 <code>%{foo}</code> 的命名形参，它将由名为 ‘foo’ 的形参的值所替换。 例如，如果命令行 <code>showpartial %{id} %{number} %{total}</code> 是在一个 mailcap 文件中，并且 <em>plist</em> 被设为 <code>['id=1', 'number=2', 'total=3']</code>，则结果命令行将为 <code>'showpartial 1 2 3'</code>。</p>
<p>在 mailcap 文件中，可以指定可选的 “test” 字段来检测某些外部条件（例如所使用的机器架构或窗口系统）来确定是否要应用 mailcap 行。 <code>findmatch()</code> 将自动检查此类条件并在检查未通过时跳过条目。</p>
<p><code>mailcap.getcaps</code>()</p>
<p>返回一个将 MIME 类型映射到 mailcap 文件条目列表的字典。 此字典必须被传给 <code>findmatch()</code> 函数。 条目会被存储为字典列表，但并不需要了解此表示形式的细节。</p>
<p>此信息来自在系统中找到的所有 mailcap 文件。 用户的 mailcap 文件 <code>$HOME/.mailcap</code> 中的设置将覆盖系统 mailcap 文件 <code>/etc/mailcap</code>, <code>/usr/etc/mailcap</code> 和 <code>/usr/local/etc/mailcap</code> 中的设置。</p>
<p>一个用法示例:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> mailcap
<span class="token operator">>></span><span class="token operator">></span> d <span class="token operator">=</span> mailcap<span class="token punctuation">.</span>getcaps<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> mailcap<span class="token punctuation">.</span>findmatch<span class="token punctuation">(</span>d<span class="token punctuation">,</span> <span class="token string">'video/mpeg'</span><span class="token punctuation">,</span> filename<span class="token operator">=</span><span class="token string">'tmp1223'</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token string">'xmpeg tmp1223'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token string">'view'</span><span class="token punctuation">:</span> <span class="token string">'xmpeg %s'</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="mailbox-—-操作多种格式的邮箱"><a href="#mailbox-—-操作多种格式的邮箱" class="headerlink" title="mailbox —- 操作多种格式的邮箱"></a><code>mailbox</code> —- 操作多种格式的邮箱</h2><p><strong>源代码：</strong> <a href="https://github.com/python/cpython/tree/3.10/Lib/mailbox.py" target="_blank" rel="noopener">Lib/mailbox.py</a></p>
<hr>
<p>本模块定义了两个类，<code>Mailbox</code> 和 <code>Message</code>，用于访问和操作磁盘中的邮箱及其所包含的电子邮件。 <code>Mailbox</code> 提供了类似字典的从键到消息的映射。 <code>Message</code> 为 <code>email.message</code> 模块的 <code>Message</code> 类增加了特定格式专属的状态和行为。 支持的邮箱格式有 Maildir, mbox, MH, Babyl 以及 MMDF。</p>
<h3 id="Mailbox-对象"><a href="#Mailbox-对象" class="headerlink" title="Mailbox 对象"></a><code>Mailbox</code> 对象</h3><p><em>class</em> <code>mailbox.Mailbox</code></p>
<p>一个邮箱，它可以被检视和修改。</p>
<p><code>Mailbox</code> 类定义了一个接口并且它不应被实例化。 而是应该让格式专属的子类继承 <code>Mailbox</code> 并且你的代码应当实例化一个特定的子类。</p>
<p><code>Mailbox</code> 接口类似于字典，其中每个小键都有对应的消息。 键是由 <code>Mailbox</code> 实例发出的，它们将由实例来使用并且只对该 <code>Mailbox</code> 实例有意义。 键会持续标识一条消息，即使对应的消息已被修改，例如被另一条消息所替代。</p>
<p>可以使用 set 型方法 <code>add()</code> 将消息添加到 <code>Mailbox</code> 并可以使用 <code>del</code> 语句或 set 型方法 <code>remove()</code> 和 <code>discard()</code> 将其移除。</p>
<p><code>Mailbox</code> 接口语义在某些值得注意的方面与字典语义有所不同。 每次请求消息时，都会基于邮箱的当前状态生成一个新的表示形式（通常为 <code>Message</code> 实例）。 类似地，当向 <code>Mailbox</code> 实例添加消息时，所提供的消息表示形式的内容将被复制。 无论在哪种情况下 <code>Mailbox</code> 实例都不会保留对消息表示形式的引用。</p>
<p>默认的 <code>Mailbox</code> 迭代器会迭代消息表示形式，而不像默认的字典迭代器那样迭代键。 此外，在迭代期间修改邮箱是安全且有明确定义的。 在创建迭代器之后被添加到邮箱的消息将对该迭代不可见。 在迭代器产出消息之前被从邮箱移除的消息将被静默地跳过，但是使用来自迭代器的键也有可能导致 <code>KeyError</code> 异常，如果对应的消息后来被移除的话。</p>
<p>警告</p>
<p>在修改可能同时被其他某个进程修改的邮箱时要非常小心。 用于此种任务的最安全邮箱格式是 Maildir；请尽量避免使用 mbox 之类的单文件格式进行并发写入。 如果你正在修改一个邮箱，你 <em>必须</em> 在读取文件中的任何消息或者执行添加或删除消息等修改操作 <em>之前</em> 通过调用 <code>lock()</code> 以及 <code>unlock()</code> 方法来锁定它。 如果未锁定邮箱则将导致丢失消息或损坏整个邮箱的风险。</p>
<p><code>Mailbox</code> 实例具有下列方法:</p>
<ul>
<li><p><code>add</code>(<em>message</em>)</p>
<p>将 <em>message</em> 添加到邮箱并返回分配给它的键。</p>
<p>形参 <em>message</em> 可以是 <code>Message</code> 实例、<code>email.message.Message</code> 实例、字符串、字节串或文件类对象（应当以二进制模式打开）。 如果 <em>message</em> 是适当的格式专属 <code>Message</code> 子类的实例（举例来说，如果它是一个 <code>mboxMessage</code> 实例而这是一个 <code>mbox</code> 实例），将使用其格式专属的信息。 在其他情况下，则会使用合理的默认值作为格式专属的信息。</p>
<p>在 3.2 版更改: 增加了对二进制输入的支持。</p>
</li>
<li><p><code>remove</code>(<em>key</em>)</p>
<p><code>__delitem__</code>(<em>key</em>)</p>
<p><code>discard</code>(<em>key</em>)</p>
<p>从邮箱中删除对应于 <em>key</em> 的消息。</p>
<p>当消息不存在时，如果此方法是作为 <code>remove()</code> 或 <code>__delitem__()</code> 调用则会引发 <code>KeyError</code> 异常，而如果此方法是作为 <code>discard()</code> 调用则不会引发异常。 如果下层邮箱格式支持来自其他进程的并发修改则 <code>discard()</code> 的行为可能是更为适合的。</p>
</li>
<li><p><code>__setitem__</code>(<em>key</em>, <em>message</em>)</p>
<p>将 <em>key</em> 所对应的消息替换为 <em>message*。 如果没有与 *key</em> 所对应的消息则会引发 <code>KeyError</code> 异常。</p>
<p>与 <code>add()</code> 一样，形参 <em>message</em> 可以是 <code>Message</code> 实例、<code>email.message.Message</code> 实例、字符串、字节串或文件类对象（应当以二进制模式打开）。 如果 <em>message</em> 是适当的格式专属 <code>Message</code> 子类的实例（举例来说，如果它是一个 <code>mboxMessage</code> 实例而这是一个 <code>mbox</code> 实例），将使用其格式专属的信息。 在其他情况下，当前与 <em>key</em> 所对应的消息的格式专属信息则会保持不变。</p>
</li>
<li><p><code>iterkeys</code>()</p>
<p><code>keys</code>()</p>
<p>如果通过 <code>iterkeys()</code> 调用则返回一个迭代所有键的迭代器，或者如果通过 <code>keys()</code> 调用则返回一个键列表。</p>
</li>
<li><p><code>itervalues</code>()</p>
<p><code>__iter__</code>()</p>
<p><code>values</code>()</p>
<p>如果通过 <code>itervalues()</code> 或 <code>__iter__()</code> 调用则返回一个迭代所有消息的表示形式的迭代器，或者如果通过 <code>values()</code> 调用则返回一个由这些表示形式组成的列表。 消息会被表示为适当的格式专属 <code>Message</code> 子类的实例，除非当 <code>Mailbox</code> 实例被初始化时指定了自定义的消息工厂函数。</p>
<p>注解</p>
<p><code>__iter__()</code> 的行为与字典不同，后者是对键进行迭代。</p>
</li>
<li><p><code>iteritems</code>()</p>
<p><code>items</code>()</p>
<p>如果通过 <code>iteritems()</code> 调用则返回一个迭代 (<em>key</em>, <em>message</em>) 对的迭代器，其中 <em>key</em> 为键而 <em>message</em> 为消息的表示形式，或者如果通过 <code>items()</code> 调用则返回一个由这种键值对组成的列表。 消息会被表示为适当的格式专属 <code>Message</code> 子类的实例，除非当 <code>Mailbox</code> 实例被初始化时指定了自定义的消息工厂函数。</p>
</li>
<li><p><code>get</code>(<em>key</em>, <em>default=None</em>)</p>
<p><code>__getitem__</code>(<em>key</em>)</p>
<p>返回对应于 <em>key</em> 的消息的表示形式。 当对应的消息不存在时，如果通过 <code>get()</code> 调用则返回 <em>default</em> 而如果通过 <code>__getitem__()</code> 调用此方法则会引发 <code>KeyError</code> 异常。 消息会被表示为适当的格式专属 <code>Message</code> 子类的实例，除非当 <code>Mailbox</code> 实例被初始化时指定了自定义的消息工厂函数。</p>
</li>
<li><p><code>get_message</code>(<em>key</em>)</p>
<p>将对应于 <em>key</em> 的消息的表示形式作为适当的格式专属 <code>Message</code> 子类的实例返回，或者如果对应的消息不存在则会引发 <code>KeyError</code> 异常。</p>
</li>
<li><p><code>get_bytes</code>(<em>key</em>)</p>
<p>返回对应于 <em>key</em> 的消息的字节表示形式，或者如果对应的消息不存在则会引发 <a href="https://www.bookstack.cn/read/python-3.10.0-zh/177bd954d1cc6696.md#KeyError" target="_blank" rel="noopener"><code>KeyError</code></a> 异常。</p>
<p>3.2 新版功能.</p>
</li>
<li><p><code>get_string</code>(<em>key</em>)</p>
<p>返回对应于 <em>key</em> 的消息的字符串表示形式，或者如果对应的消息不存在则会引发 <code>KeyError</code> 异常。 消息是通过 <code>email.message.Message</code> 处理来将其转换为纯 7bit 表示形式的。</p>
</li>
<li><p><code>get_file</code>(<em>key</em>)</p>
<p>返回对应于 <em>key</em> 的消息的文件类表示形式，或者如果对应的消息不存在则会引发 <code>KeyError</code> 异常。 文件类对象的行为相当于以二进制模式打开。 当不再需要此文件时应当将其关闭。</p>
<p>在 3.2 版更改: 此文件对象实际上是二进制文件；之前它被不正确地以文本模式返回。 并且，此文件类对象现在还支持上下文管理协议：你可以使用 <code>with</code> 语句来自动关闭它。</p>
<p>注解</p>
<p>不同于其他消息表示形式，文件类表示形式并不一定独立于创建它们的 <code>Mailbox</code> 实例或下层的邮箱。 每个子类都会提供更具体的文档。</p>
</li>
<li><p><code>__contains__</code>(<em>key</em>)</p>
<p>如果 <em>key</em> 有对应的消息则返回 <code>True</code>，否则返回 <code>False</code>。</p>
</li>
<li><p><code>__len__</code>()</p>
<p>返回邮箱中消息的数量。</p>
</li>
<li><p><code>clear</code>()</p>
<p>从邮箱中删除所有消息。</p>
</li>
<li><p><code>pop</code>(<em>key</em>, <em>default=None</em>)</p>
<p>返回对应于 <em>key</em> 的消息的表示形式并删除该消息。 如果对应的消息不存在则返回 <em>default</em>。 消息会被表示为适当的格式专属 <code>Message</code> 子类的实例，除非当 <code>Mailbox</code> 实例被初始化时指定了自定义的消息工厂函数。</p>
</li>
<li><p><code>popitem</code>()</p>
<p>返回一个任意的 (<em>key</em>, <em>message</em>) 对，其中 <em>key</em> 为键而 <em>message</em> 为消息的表示形式，并删除对应的消息。 如果邮箱为空，则会引发 <code>KeyError</code> 异常。 消息会被表示为适当的格式专属 <code>Message</code> 子类的实例，除非当 <code>Mailbox</code> 实例被初始化时指定了自定义的消息工厂函数。</p>
</li>
<li><p><code>update</code>(<em>arg</em>)</p>
<p>形参 <em>arg</em> 应当是 <em>key</em> 到 <em>message</em> 的映射或 (<em>key</em>, <em>message</em>) 对的可迭代对象。 用来更新邮箱以使得对于每个给定的 <em>key</em> 和 <em>message*，与 *key</em> 相对应的消息会被设为 <em>message*，就像通过使用 <code>__setitem__()</code> 一样。 类似于 <code>__setitem__()</code>，每个 *key</em> 都必须在邮箱中有一个对应的消息否则将会引发 <code>KeyError</code> 异常，因此在通常情况下将 <em>arg</em> 设为 <code>Mailbox</code> 实例是不正确的。</p>
<p>注解</p>
<p>与字典不同，关键字参数是不受支持的。</p>
</li>
<li><p><code>flush</code>()</p>
<p>将所有待定的更改写入到文件系统。 对于某些 <code>Mailbox</code> 子类来说，更改总是被立即写入因而 <code>flush()</code> 并不会做任何事，但您仍然应当养成调用此方法的习惯。</p>
</li>
<li><p><code>lock</code>()</p>
<p>在邮箱上获取一个独占式咨询锁以使其他进程知道不能修改它。 如果锁无法被获取则会引发 <code>ExternalClashError</code>。 所使用的具体锁机制取决于邮箱的格式。 在对邮箱内容进行任何修改之前你应当 <em>总是</em> 锁定它。</p>
</li>
<li><p><code>unlock</code>()</p>
<p>释放邮箱上的锁，如果存在的话。</p>
</li>
<li><p><code>close</code>()</p>
<p>刷新邮箱，如果必要则将其解锁。 并关闭所有打开的文件。 对于某些 <code>Mailbox</code> 子类来说，此方法并不会做任何事。</p>
</li>
</ul>
<h4 id="Maildir"><a href="#Maildir" class="headerlink" title="Maildir"></a><code>Maildir</code></h4><p><em>class</em> <code>mailbox.Maildir</code>(<em>dirname</em>, <em>factory=None</em>, <em>create=True</em>)</p>
<p><code>Mailbox</code> 的一个子类，用于 Maildir 格式的邮箱。 形参 <em>factory</em> 是一个可调用对象，它接受一个文件类消息表示形式（其行为相当于以二进制模式打开）并返回一个自定义的表示形式。 如果 <em>factory</em> 为 <code>None</code>，则会使用 <code>MaildirMessage</code> 作为默认的消息表示形式。 如果 <em>create</em> 为 <code>True</code>，则当邮箱不存在时会创建它。</p>
<p>如果 <em>create</em> 为 <code>True</code> 且 <em>dirname</em> 路径存在，它将被视为已有的 maildir 而无需尝试验证其目录布局。</p>
<p>使用 <em>dirname</em> 这个名称而不使用 <em>path</em> 是出于历史原因。</p>
<p>Maildir 是一种基于目录的邮箱格式，它是针对 qmail 邮件传输代理而发明的，现在也得到了其他程序的广泛支持。 Maildir 邮箱中的消息存储在一个公共目录结构中的单独文件内。 这样的设计允许 Maildir 邮箱被多个彼此无关的程序访问和修改而不会导致数据损坏，因此文件锁定操作是不必要的。</p>
<p>Maildir 邮箱包含三个子目录，分别是: <code>tmp</code>, <code>new</code> 和 <code>cur</code>。 消息会不时地在 <code>tmp</code> 子目录中创建然后移至 <code>new</code> 子目录来结束投递。 后续电子邮件客户端可能将消息移至 <code>cur</code> 子目录并将有关消息状态的信息存储在附带到其文件名的特殊 “info” 小节中。</p>
<p>Courier 电子邮件传输代理所引入的文件夹风格也是受支持的。 主邮箱中任何子目录只要其名称的第一个字符是 <code>'.'</code> 就会被视为文件夹。 文件夹名称会被 <code>Maildir</code> 表示为不带前缀 <code>'.'</code> 的形式。 每个文件夹自身都是一个 Maildir 邮箱但不应包含其他文件夹。 逻辑嵌套关系是使用 <code>'.'</code> 来划定层级，例如 “Archived.2005.07”。</p>
<p>注解</p>
<p>Maildir 规范要求使用在特定消息文件名中使用冒号 (<code>':'</code>)。 但是，某些操作系统不允许将此字符用于文件名，如果你希望在这些操作系统上使用类似 Maildir 的格式，你应当指定改用另一个字符。 叹号 (<code>'!'</code>) 是一个受欢迎的选择。 例如:</p>
<pre><code>import mailboxmailbox.Maildir.colon = '!'</code></pre><p><code>colon</code> 属性也可以在每个实例上分别设置。</p>
<p><code>Maildir</code> 实例具有 <code>Mailbox</code> 的所有方法及下列附加方法:</p>
<ul>
<li><p><code>list_folders</code>()</p>
<p>返回所有文件夹名称的列表。</p>
</li>
<li><p><code>get_folder</code>(<em>folder</em>)</p>
<p>返回表示名称为 <em>folder</em> 的文件夹的 <code>Maildir</code> 实例。 如果文件夹不存在则会引发 <code>NoSuchMailboxError</code> 异常。</p>
</li>
<li><p><code>add_folder</code>(<em>folder</em>)</p>
<p>创建名称为 <em>folder</em> 的文件夹并返回表示它的 <code>Maildir</code> 实例。</p>
</li>
<li><p><code>remove_folder</code>(<em>folder</em>)</p>
<p>删除名称为 <em>folder</em> 的文件夹。 如果文件夹包含任何消息，则将引发 <code>NotEmptyError</code> 异常且该文件夹将不会被删除。</p>
</li>
<li><p><code>clean</code>()</p>
<p>从邮箱中删除最近 36 小时内未被访问过的临时文件。 Maildir 规范要求邮件阅读程序应当时常进行此操作。</p>
</li>
</ul>
<p><code>Maildir</code> 所实现的某些 <code>Mailbox</code> 方法值得进行特别的说明:</p>
<ul>
<li><p><code>add</code>(<em>message</em>)</p>
<p><code>__setitem__</code>(<em>key</em>, <em>message</em>)</p>
<p><code>update</code>(<em>arg</em>)</p>
<p>警告</p>
<p>这些方法会基于当前进程 ID 来生成唯一文件名。 当使用多线程时，可能发生未被检测到的名称冲突并导致邮箱损坏，除非是对线程进行协调以避免使用这些方法同时操作同一个邮箱。</p>
</li>
<li><p><code>flush</code>()</p>
<p>对 Maildir 邮箱的所有更改都会立即被应用，所以此方法并不会做任何事情。</p>
</li>
<li><p><code>lock</code>()</p>
<p><code>unlock</code>()</p>
<p>Maildir 邮箱不支持（或要求）锁定操作，所以此方法并不会做任何事情。</p>
</li>
<li><p><code>close</code>()</p>
<p><code>Maildir</code> 实例不保留任何打开的文件并且下层的邮箱不支持锁定操作，所以此方法不会做任何事情。</p>
</li>
<li><p><code>get_file</code>(<em>key</em>)</p>
<p>根据主机平台的不同，当返回的文件保持打开状态时可能无法修改或移除下层的消息。</p>
</li>
</ul>
<h4 id="mbox"><a href="#mbox" class="headerlink" title="mbox"></a><code>mbox</code></h4><p><em>class</em> <code>mailbox.mbox</code>(<em>path</em>, <em>factory=None</em>, <em>create=True</em>)</p>
<p><code>Mailbox</code> 的子类，用于 mbox 格式的邮箱。 形参 <em>factory</em> 是一个可调用对象，它接受一个文件类消息表示形式（其行为相当于以二进制模式打开）并返回一个自定义的表示形式。 如果 <em>factory</em> 为 <code>None</code>，则会使用 <code>mboxMessage</code> 作为默认的消息表示形式。 如果 <em>create</em> 为 <code>True</code>，则当邮箱不存在时会创建它。</p>
<p>mbox 格式是在 Unix 系统上存储电子邮件的经典格式。 mbox 邮箱中的所有消息都存储在一个单独文件中，每条消息的开头由前五个字符为 “From “ 的行来指明。</p>
<p>还有一些 mbox 格式变种对原始格式中发现的缺点做了改进，<code>mbox</code> 只实现原始格式，有时被称为 <em>mboxo*。 这意味着当存储消息时 *Content-Length</em> 标头如果存在则会被忽略并且消息体中出现于行开头的任何 “From “ 会被转换为 “&gt;From “，但是当读取消息时 “&gt;From “ 则不会被转换为 “From “。</p>
<p><code>mbox</code> 所实现的某些 <code>Mailbox</code> 方法值得进行特别的说明:</p>
<ul>
<li><p><code>get_file</code>(<em>key</em>)</p>
<p>在 <code>mbox</code> 实例上调用 <code>flush()</code> 或 <code>close()</code> 之后再使用文件可能产生无法预料的结果或者引发异常。</p>
</li>
<li><p><code>lock</code>()</p>
<p><code>unlock</code>()</p>
<p>使用三种锁机制 —- dot 锁，以及可能情况下的 <code>flock()</code> 和 <code>lockf()</code> 系统调用。</p>
</li>
</ul>
<p>参见</p>
<p><a href="http://www.tin.org/bin/man.cgi?section=5&amp;topic=mbox" target="_blank" rel="noopener">tin 上的 mbox 指南页面</a></p>
<p>该格式的规格说明，包括有关锁的详情。</p>
<p><a href="https://www.jwz.org/doc/content-length.html" target="_blank" rel="noopener">在 Unix 上配置 Netscape Mail: 为何 Content-Length 格式是不好的</a></p>
<p>使用原始 mbox 格式而非其变种的一些理由。</p>
<p><a href="https://www.loc.gov/preservation/digital/formats/fdd/fdd000383.shtml" target="_blank" rel="noopener">“mbox” 是由多个彼此不兼容的邮箱格式构成的家族</a></p>
<p>有关 mbox 变种的历史。</p>
<h4 id="MH"><a href="#MH" class="headerlink" title="MH"></a><code>MH</code></h4><p><em>class</em> <code>mailbox.MH</code>(<em>path</em>, <em>factory=None</em>, <em>create=True</em>)</p>
<p><code>Mailbox</code> 的子类，用于 MH 格式的邮箱。 形参 <em>factory</em> 是一个可调用对象，它接受一个文件类消息表示形式（其行为相当于以二进制模式打开）并返回一个自定义的表示形式。 如果 <em>factory</em> 为 <code>None</code>，则会使用 <code>MHMessage</code> 作为默认的消息表示形式。 如果 <em>create</em> 为 <code>True</code>，则当邮箱不存在时会创建它。</p>
<p>MH 是一种基于目录的邮箱格式，它是针对 MH Message Handling System 电子邮件用户代理而发明的。 在 MH 邮箱的每条消息都放在单独文件中。 MH 邮箱中除了邮件消息还可以包含其他 MH 邮箱 (称为 <em>文件夹</em>)。 文件夹可以无限嵌套。 MH 邮箱还支持 <em>序列</em>，这是一种命名列表，用来对消息进行逻辑分组而不必将其移入子文件夹。 序列是在每个文件夹中名为 <code>.mh_sequences</code> 的文件内定义的。</p>
<p><code>MH</code> 类可以操作 MH 邮箱，但它并不试图模拟 <strong>mh</strong> 的所有行为。 特别地，它并不会修改 <code>context</code> 或 <code>.mh_profile</code> 文件也不会受其影响，这两个文件是 <strong>mh</strong> 用来存储状态和配置数据的。</p>
<p><code>MH</code> 实例具有 <code>Mailbox</code> 的所有方法及下列附加方法:</p>
<ul>
<li><p><code>list_folders</code>()</p>
<p>返回所有文件夹名称的列表。</p>
</li>
<li><p><code>get_folder</code>(<em>folder</em>)</p>
<p>返回表示名称为 <em>folder</em> 的文件夹的 <code>MH</code> 实例。 如果文件夹不存在则会引发 <code>NoSuchMailboxError</code> 异常。</p>
</li>
<li><p><code>add_folder</code>(<em>folder</em>)</p>
<p>创建名称为 <em>folder</em> 的文件夹并返回表示它的 <code>MH</code> 实例。</p>
</li>
<li><p><code>remove_folder</code>(<em>folder</em>)</p>
<p>删除名称为 <em>folder</em> 的文件夹。 如果文件夹包含任何消息，则将引发 <code>NotEmptyError</code> 异常且该文件夹将不会被删除。</p>
</li>
<li><p><code>get_sequences</code>()</p>
<p>返回映射到键列表的序列名称字典。 如果不存在任何序列，则返回空字典。</p>
</li>
<li><p><code>set_sequences</code>(<em>sequences</em>)</p>
<p>根据由映射到键列表的名称组成的字典 <em>sequences</em> 来重新定义邮箱中的序列，该字典与 <code>get_sequences()</code> 返回值的形式一样。</p>
</li>
<li><p><code>pack</code>()</p>
<p>根据需要重命名邮箱中的消息以消除序号中的空缺。 序列列表中的条目会做相应的修改。</p>
<p>注解</p>
<p>已发送的键会因此操作而失效并且不应当被继续使用。</p>
</li>
</ul>
<p><code>MH</code> 所实现的某些 <code>Mailbox</code> 方法值得进行特别的说明:</p>
<ul>
<li><p><code>remove</code>(<em>key</em>)</p>
<p><code>__delitem__</code>(<em>key</em>)</p>
<p><code>discard</code>(<em>key</em>)</p>
<p>这些方法会立即删除消息。 通过在名称前加缀一个冒号作为消息删除标记的 MH 惯例不会被使用。</p>
</li>
<li><p><code>lock</code>()</p>
<p><code>unlock</code>()</p>
<p>使用三种锁机制 —- dot 锁，以及可能情况下下 <code>flock()</code> 和 <code>lockf()</code> 系统调用。 对于 MH 邮箱来说，锁定邮箱意味着锁定 <code>.mh_sequences</code> 文件，并且仅在执行会影响单独消息文件的操作期间锁定单独消息文件。</p>
</li>
<li><p><code>get_file</code>(<em>key</em>)</p>
<p>根据主机平台的不同，当返回的文件保持打开状态时可能无法移除下层的消息。</p>
</li>
<li><p><code>flush</code>()</p>
<p>对 MH 邮箱的所有更改都会立即被应用，所以此方法并不会做任何事情。</p>
</li>
<li><p><code>close</code>()</p>
<p><code>MH</code> 实例不保留任何打开的文件，所以此方法等价于 <code>unlock()</code>。</p>
</li>
</ul>
<p>参见</p>
<p><a href="http://www.nongnu.org/nmh/" target="_blank" rel="noopener">nmh - Message Handling System</a></p>
<p><strong>nmh</strong> 的主页，这是原始 <strong>mh</strong> 的更新版本。</p>
<p><a href="https://rand-mh.sourceforge.io/book/" target="_blank" rel="noopener">MH &amp; nmh: Email for Users &amp; Programmers</a></p>
<p>使用 GPL 许可证的介绍 <strong>mh</strong> 与 <strong>nmh</strong> 的图书，包含有关该邮箱格式的各种信息。</p>
<h4 id="Babyl"><a href="#Babyl" class="headerlink" title="Babyl"></a><code>Babyl</code></h4><p><em>class</em> <code>mailbox.Babyl</code>(<em>path</em>, <em>factory=None</em>, <em>create=True</em>)</p>
<p><code>Mailbox</code> 的子类，用于 Babyl 格式的邮箱。 形参 <em>factory</em> 是一个可调用对象，它接受一个文件类表示形式（其行为相当于以二进制模式打开）并返回一个自定义的表示形式。 如果 <em>factory</em> 为 <code>None</code>，则会使用 <code>BabylMessage</code> 作为默认的消息表示形式。 如果 <em>create</em> 为 <code>True</code>，则当邮箱不存在时会创建它。</p>
<p>Babyl 是 Rmail 电子邮箱用户代理所使用单文件邮箱格式，包括在 Emacs 中。 每条消息的开头由一个包含 Control-Underscore (<code>'\037'</code>) 和 Control-L (<code>'\014'</code>) 这两个字符的行来指明。 消息的结束由下一条消息的开头来指明，或者当为最后一条消息时则由一个包含 Control-Underscore (<code>'\037'</code>) 字符的行来指明。</p>
<p>Babyl 邮箱中的消息带有两组标头：原始标头和所谓的可见标头。 可见标头通常为原始标头经过重格式化和删减以更易读的子集。 Babyl 邮箱中的每条消息都附带了一个 <em>标签</em> 列表，即记录消息相关额外信息的短字符串，邮箱中所有的用户定义标签列表会存储于 Babyl 的选项部分。</p>
<p><code>Babyl</code> 实例具有 <code>Mailbox</code> 的所有方法及下列附加方法:</p>
<ul>
<li><p><code>get_labels</code>()</p>
<p>返回邮箱中使用的所有用户定义标签名称的列表。</p>
<p>注解</p>
<p>邮箱中存在哪些标签会通过检查实际的消息而非查询 Babyl 选项部分的标签列表，但 Babyl 选项部分会在邮箱被修改时更新。</p>
</li>
</ul>
<p><code>Babyl</code> 所实现的某些 <code>Mailbox</code> 方法使得进行特别的说明:</p>
<ul>
<li><p><code>get_file</code>(<em>key</em>)</p>
<p>在 Babyl 邮箱中，消息的标头并不是与消息体存储在一起的。 要生成文件类表示形式，标头和消息体会被一起拷贝到一个 <code>io.BytesIO</code> 实例中，它具有与文件相似的 API。 因此，文件类对象实际上独立于下层邮箱，但与字符串表达形式相比并不会更节省内存。</p>
</li>
<li><p><code>lock</code>()</p>
<p><code>unlock</code>()</p>
<p>使用三种锁机制 —- dot 锁，以及可能情况下的 <code>flock()</code> 和 <code>lockf()</code> 系统调用。</p>
</li>
</ul>
<p>参见</p>
<p><a href="https://quimby.gnus.org/notes/BABYL" target="_blank" rel="noopener">Format of Version 5 Babyl Files</a></p>
<p>Babyl 格式的规格说明。</p>
<p><a href="https://www.gnu.org/software/emacs/manual/html_node/emacs/Rmail.html" target="_blank" rel="noopener">Reading Mail with Rmail</a></p>
<p>Rmail 的帮助手册，包含了有关 Babyl 语义的一些信息。</p>
<h4 id="MMDF"><a href="#MMDF" class="headerlink" title="MMDF"></a><code>MMDF</code></h4><p><em>class</em> <code>mailbox.MMDF</code>(<em>path</em>, <em>factory=None</em>, <em>create=True</em>)</p>
<p><code>Mailbox</code> 的子类，用于 MMDF 格式的邮箱。 形参 <em>factory</em> 是一个可调用对象，它接受一个文件类消息表示形式（其行为相当于以二进制模式打开）并返回一个自定义的表示形式。 如果 <em>factory</em> 为 <code>None</code>，则会使用 <code>MMDFMessage</code> 作为默认的消息表示形式。 如果 <em>create</em> 为 <code>True</code>，则当邮箱不存在时会创建它。</p>
<p>MMDF 是一种专用于电子邮件传输代理 Multichannel Memorandum Distribution Facility 的单文件邮箱格式。 每条消息使用与 mbox 消息相同的形式，但其前后各有包含四个 Control-A (<code>'\001'</code>) 字符的行。 与 mbox 格式一样，每条消息的开头由一个前五个字符为 “From “ 的行来指明，但当存储消息时额外出现的 “From “ 不会被转换为 “&gt;From “ 因为附加的消息分隔符可防止将这些内容误认为是后续消息的开头。</p>
<p><code>MMDF</code> 所实现的某些 <code>Mailbox</code> 方法值得进行特别的说明:</p>
<ul>
<li><p><code>get_file</code>(<em>key</em>)</p>
<p>在 <code>MMDF</code> 实例上调用 <code>flush()</code> 或 <code>close()</code> 之后再使用文件可能产生无法预料的结果或者引发异常。</p>
</li>
<li><p><code>lock</code>()</p>
<p><code>unlock</code>()</p>
<p>使用三种锁机制 —- dot 锁，以及可能情况下的 <code>flock()</code> 和 <code>lockf()</code> 系统调用。</p>
</li>
</ul>
<p>参见</p>
<p><a href="http://www.tin.org/bin/man.cgi?section=5&amp;topic=mmdf" target="_blank" rel="noopener">tin 上的 mmdf 指南页面</a></p>
<p>MMDF 格式的规格说明，来自新闻阅读器 tin 的文档。</p>
<p><a href="https://en.wikipedia.org/wiki/MMDF" target="_blank" rel="noopener">MMDF</a></p>
<p>一篇描述 Multichannel Memorandum Distribution Facility 的维基百科文章。</p>
<h3 id="Message-对象"><a href="#Message-对象" class="headerlink" title="Message 对象"></a><code>Message</code> 对象</h3><p><em>class</em> <code>mailbox.Message</code>(<em>message=None</em>)</p>
<p><code>email.message</code> 模块的 <code>Message</code> 的子类。 <code>mailbox.Message</code> 的子类添加了特定邮箱格式专属的状态和行为。</p>
<p>如果省略了 <em>message*，则新实例会以默认的空状态被创建。 如果 *message</em> 是一个 <code>email.message.Message</code> 实例，其内容会被拷贝；此外，如果 <em>message</em> 是一个 <code>Message</code> 实例，则任何格式专属信息会尽可能地被拷贝。 如果 <em>message</em> 是一个字符串、字节串或文件，则它应当包含兼容 <a href="https://tools.ietf.org/html/rfc2822.html" target="_blank" rel="noopener"><strong>RFC 2822</strong></a> 的消息，该消息会被读取和解析。 文档应当以二进制模式打开，但文本模式的文件也会被接受以向下兼容。</p>
<p>各个子类所提供的格式专属状态和行为各有不同，但总的来说只有那些不仅限于特定邮箱的特性才会被支持（虽然这些特性可能专属于特定邮箱格式）。 例如，例如，单文件邮箱格式的文件偏移量和基于目录的邮箱格式的文件名都不会被保留，因为它们都仅适用于对应的原始邮箱。 但消息是否已被用户读取或标记为重要等状态则会被保留，因为它们适用于消息本身。</p>
<p>不要求用 <code>Message</code> 实例来表示使用 <code>Mailbox</code> 实例所提取到的消息。 在某些情况下，生成 <code>Message</code> 表示形式所需的时间和内存空间可能是不可接受的。 对于此类情况，<code>Mailbox</code> 实例还提供了字符串和文件类表示形式，并可在初始化 <code>Mailbox</code> 实例时指定自定义的消息工厂函数。</p>
<h4 id="MaildirMessage"><a href="#MaildirMessage" class="headerlink" title="MaildirMessage"></a><code>MaildirMessage</code></h4><p><em>class</em> <code>mailbox.MaildirMessage</code>(<em>message=None</em>)</p>
<p>具有 Maildir 专属行为的消息。 形参 <em>message</em> 的含义与 <code>Message</code> 构造器一致。</p>
<p>通常，邮件用户代理应用程序会在用户第一次打开并关闭邮箱之后将 <code>new</code> 子目录中的所有消息移至 <code>cur</code> 子目录，将这些消息记录为旧消息，无论它们是否真的已被阅读。 <code>cur</code> 下的每条消息都有一个 “info” 部分被添加到其文件名中以存储有关其状态的信息。 （某些邮件阅读器还会把 “info” 部分也添加到 <code>new</code> 下的消息中。） “info” 部分可以采用两种形式之一：它可能包含 “2,” 后面跟一个经标准化的旗标列表（例如 “2,FR”）或者它可能包含 “1,” 后面跟所谓的实验性信息。 Maildir 消息的标准旗标如下:</p>
<table>
<thead>
<tr>
<th align="left">旗标</th>
<th align="left">含意</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">D</td>
<td align="left">草稿</td>
<td align="left">正在撰写中</td>
</tr>
<tr>
<td align="left">F</td>
<td align="left">已标记</td>
<td align="left">已被标记为重要</td>
</tr>
<tr>
<td align="left">P</td>
<td align="left">已检视</td>
<td align="left">转发，重新发送或退回</td>
</tr>
<tr>
<td align="left">R</td>
<td align="left">已回复</td>
<td align="left">回复给</td>
</tr>
<tr>
<td align="left">S</td>
<td align="left">已查看</td>
<td align="left">已阅读</td>
</tr>
<tr>
<td align="left">T</td>
<td align="left">已删除</td>
<td align="left">标记为可被删除</td>
</tr>
</tbody></table>
<p><code>MaildirMessage</code> 实例提供以下方法：</p>
<ul>
<li><p><code>get_subdir</code>()</p>
<p>返回 “new” (如果消息应当被存储在 <code>new</code> 子目录下) 或者 “cur” (如果消息应当被存储在 <code>cur</code> 子目录下)。</p>
<p>注解</p>
<p>消息通常会在其邮箱被访问后被从 <code>new</code> 移至 <code>cur</code>，无论该消息是否已被阅读。 如果 msg.get_flags()<code>中的 `"S" 为</code>True<code>则说明消息</code>msg` 已被阅读。</p>
</li>
<li><p><code>set_subdir</code>(<em>subdir</em>)</p>
<p>设置消息应当被存储到的子目录。 形参 <em>subdir</em> 必须为 “new” 或 “cur”。</p>
</li>
<li><p><code>get_flags</code>()</p>
<p>返回一个指明当前所设旗标的字符串。 如果消息符合标准的 Maildir 格式，则结果为零或按字母顺序各自出现一次的 <code>'D'</code>, <code>'F'</code>, <code>'P'</code>, <code>'R'</code>, <code>'S'</code> 和 <code>'T'</code> 的拼接。 如果未设任何旗标或者如果 “info” 包含实验性语义则返回空字符串。</p>
</li>
<li><p><code>set_flags</code>(<em>flags</em>)</p>
<p>设置由 <em>flags</em> 所指定的旗标并重置所有其它旗标。</p>
</li>
<li><p><code>add_flag</code>(<em>flag</em>)</p>
<p>设置由 <em>flag</em> 所指明的旗标而不改变其他旗标。 要一次性添加一个以上的旗标，<em>flag</em> 可以为包含一个以上字符的字符串。 当前 “info” 会被覆盖，无论它是否只包含实验性信息而非旗标。</p>
</li>
<li><p><code>remove_flag</code>(<em>flag</em>)</p>
<p>重置由 <em>flag</em> 所指明的旗标而不改变其他旗标。 要一次性移除一个以上的旗标，<em>flag</em> 可以为包含一个以上字符的字符串。 如果 “info” 包含实验性信息而非旗标，则当前的 “info” 不会被修改。</p>
</li>
<li><p><code>get_date</code>()</p>
<p>以表示 Unix 纪元秒数的浮点数形式返回消息的发送日期。</p>
</li>
<li><p><code>set_date</code>(<em>date</em>)</p>
<p>将消息的发送日期设为 <em>date</em>，一个表示 Unix 纪元秒数的浮点数。</p>
</li>
<li><p><code>get_info</code>()</p>
<p>返回一个包含消息的 “info” 的字符串。 这适用于访问和修改实验性的 “info” (即不是由旗标组成的列表)。</p>
</li>
<li><p><code>set_info</code>(<em>info</em>)</p>
<p>将 “info” 设为 <em>info</em>，这应当是一个字符串。</p>
</li>
</ul>
<p>当一个 <code>MaildirMessage</code> 实例基于 <code>mboxMessage</code> 或 <code>MMDFMessage</code> 实例被创建时，将会忽略 <em>Status</em> 和 <em>X-Status</em> 标头并进行下列转换:</p>
<table>
<thead>
<tr>
<th align="left">结果状态</th>
<th align="left"><code>mboxMessage</code> 或 <code>MMDFMessage</code> 状态</th>
</tr>
</thead>
<tbody><tr>
<td align="left">“cur” 子目录</td>
<td align="left">O 旗标</td>
</tr>
<tr>
<td align="left">F 旗标</td>
<td align="left">F 旗标</td>
</tr>
<tr>
<td align="left">R 旗标</td>
<td align="left">A 旗标</td>
</tr>
<tr>
<td align="left">S 旗标</td>
<td align="left">R 旗标</td>
</tr>
<tr>
<td align="left">T 旗标</td>
<td align="left">D 旗标</td>
</tr>
</tbody></table>
<p>当一个 <code>MaildirMessage</code> 实例基于 <code>MHMessage</code> 实例被创建时，将进行下列转换:</p>
<table>
<thead>
<tr>
<th align="left">结果状态</th>
<th align="left"><code>MHMessage</code> 状态</th>
</tr>
</thead>
<tbody><tr>
<td align="left">“cur” 子目录</td>
<td align="left">“unseen” 序列</td>
</tr>
<tr>
<td align="left">“cur” 子目录和 S 旗标</td>
<td align="left">非 “unseen” 序列</td>
</tr>
<tr>
<td align="left">F 旗标</td>
<td align="left">“flagged” 序列</td>
</tr>
<tr>
<td align="left">R 旗标</td>
<td align="left">“replied” 序列</td>
</tr>
</tbody></table>
<p>当一个 <code>MaildirMessage</code> 实例基于 <code>BabylMessage</code> 实例被创建时，将进行下列转换:</p>
<table>
<thead>
<tr>
<th align="left">结果状态</th>
<th align="left"><code>BabylMessage</code> 状态</th>
</tr>
</thead>
<tbody><tr>
<td align="left">“cur” 子目录</td>
<td align="left">“unseen” 标签</td>
</tr>
<tr>
<td align="left">“cur” 子目录和 S 旗标</td>
<td align="left">非 “unseen” 标签</td>
</tr>
<tr>
<td align="left">P 旗标</td>
<td align="left">“forwarded” 或 “resent” 标签</td>
</tr>
<tr>
<td align="left">R 旗标</td>
<td align="left">“answered” 标签</td>
</tr>
<tr>
<td align="left">T 旗标</td>
<td align="left">“deleted” 标签</td>
</tr>
</tbody></table>
<h4 id="mboxMessage"><a href="#mboxMessage" class="headerlink" title="mboxMessage"></a><code>mboxMessage</code></h4><p><em>class</em> <code>mailbox.mboxMessage</code>(<em>message=None</em>)</p>
<p>具有 mbox 专属行为的消息。 形参 <em>message</em> 的含义与 <code>Message</code> 构造器一致。</p>
<p>mbox 邮箱中的消息会一起存储在单个文件中。 发件人的信封地址和发送时间通常存储在指明每条消息的起始的以 “From “ 打头的行中，不过在 mbox 的各种实现之间此数据的确切格式具有相当大的差异。 指明消息状态的各种旗标，例如是否已读或标记为重要等等通常存储在 <em>Status</em> 和 <em>X-Status</em> 标头中。</p>
<p>传统的 mbox 消息旗标如下:</p>
<table>
<thead>
<tr>
<th align="left">旗标</th>
<th align="left">含意</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">R</td>
<td align="left">已阅读</td>
<td align="left">已阅读</td>
</tr>
<tr>
<td align="left">O</td>
<td align="left">旧消息</td>
<td align="left">之前已经过 MUA 检测</td>
</tr>
<tr>
<td align="left">D</td>
<td align="left">已删除</td>
<td align="left">标记为可被删除</td>
</tr>
<tr>
<td align="left">F</td>
<td align="left">已标记</td>
<td align="left">已被标记为重要</td>
</tr>
<tr>
<td align="left">A</td>
<td align="left">已回复</td>
<td align="left">回复给</td>
</tr>
</tbody></table>
<p>“R” 和 “O” 旗标存储在 <em>Status</em> 标头中，而 “D”, “F” 和 “A” 旗标存储在 <em>X-Status</em> 标头中。 旗标和标头通常会按上述顺序显示。</p>
<p><code>mboxMessage</code> 实例提供了下列方法:</p>
<ul>
<li><p><code>get_from</code>()</p>
<p>返回一个表示在 mbox 邮箱中标记消息起始的 “From “ 行的字符串。 开头的 “From “ 和末尾的换行符会被去除。</p>
</li>
<li><p><code>set_from</code>(<em>from_</em>, <em>time_=None</em>)</p>
<p>将 “From “ 行设为 <em>from_*，这应当被指定为不带开头的 “From “ 或末尾的换行符。 为方便起见，可以指定 *time_</em> 并将经过适当的格式化再添加到 <em>from_</em>。 如果指定了 <em>time_</em>，它应当是一个 <code>time.struct_time</code> 实例，适合传入 <code>time.strftime()</code> 的元组或者 <code>True</code> (以使用 <code>time.gmtime()</code>)。</p>
</li>
<li><p><code>get_flags</code>()</p>
<p>返回一个指明当前所设旗标的字符串。 如果消息符合规范格式，则结果为零或各自出现一次的 <code>'R'</code>, <code>'O'</code>, <code>'D'</code>, <code>'F'</code> 和 <code>'A'</code> 按上述顺序的拼接。</p>
</li>
<li><p><code>set_flags</code>(<em>flags</em>)</p>
<p>设置由 <em>flags</em> 所指明的旗标并重启所有其他旗标。 形参 <em>flags</em> 应当为零或各自出现多次的 <code>'R'</code>, <code>'O'</code>, <code>'D'</code>, <code>'F'</code> 和 <code>'A'</code> 按任意顺序的拼接。</p>
</li>
<li><p><code>add_flag</code>(<em>flag</em>)</p>
<p>设置由 <em>flag</em> 所指明的旗标而不改变其他旗标。 要一次性添加一个以上的旗标，<em>flag</em> 可以为包含一个以上字符的字符串。</p>
</li>
<li><p><code>remove_flag</code>(<em>flag</em>)</p>
<p>重置由 <em>flag</em> 所指明的旗标而不改变其他旗标。 要一次性移除一个以上的旗标，<em>flag</em> 可以为包含一个以上字符的字符串。</p>
</li>
</ul>
<p>当一个 <code>mboxMessage</code> 实例基于 <code>MaildirMessage</code> 实例被创建时，”From “ 行会基于 <code>MaildirMessage</code> 实例的发送时间被生成，并进行下列转换:</p>
<table>
<thead>
<tr>
<th align="left">结果状态</th>
<th align="left"><code>MaildirMessage</code> 状态</th>
</tr>
</thead>
<tbody><tr>
<td align="left">R 旗标</td>
<td align="left">S 旗标</td>
</tr>
<tr>
<td align="left">O 旗标</td>
<td align="left">“cur” 子目录</td>
</tr>
<tr>
<td align="left">D 旗标</td>
<td align="left">T 旗标</td>
</tr>
<tr>
<td align="left">F 旗标</td>
<td align="left">F 旗标</td>
</tr>
<tr>
<td align="left">A 旗标</td>
<td align="left">R 旗标</td>
</tr>
</tbody></table>
<p>当一个 <code>mboxMessage</code> 实例基于 <code>MHMessage</code> 实例被创建时，将进行下列转换:</p>
<table>
<thead>
<tr>
<th align="left">结果状态</th>
<th align="left"><code>MHMessage</code> 状态</th>
</tr>
</thead>
<tbody><tr>
<td align="left">R 旗标 和 O 旗标</td>
<td align="left">非 “unseen” 序列</td>
</tr>
<tr>
<td align="left">O 旗标</td>
<td align="left">“unseen” 序列</td>
</tr>
<tr>
<td align="left">F 旗标</td>
<td align="left">“flagged” 序列</td>
</tr>
<tr>
<td align="left">A 旗标</td>
<td align="left">“replied” 序列</td>
</tr>
</tbody></table>
<p>当一个 <code>mboxMessage</code> 实例基于 <code>BabylMessage</code> 实例被创建时，将进行下列转换:</p>
<table>
<thead>
<tr>
<th align="left">结果状态</th>
<th align="left"><code>BabylMessage</code> 状态</th>
</tr>
</thead>
<tbody><tr>
<td align="left">R 旗标 和 O 旗标</td>
<td align="left">非 “unseen” 标签</td>
</tr>
<tr>
<td align="left">O 旗标</td>
<td align="left">“unseen” 标签</td>
</tr>
<tr>
<td align="left">D 旗标</td>
<td align="left">“deleted” 标签</td>
</tr>
<tr>
<td align="left">A 旗标</td>
<td align="left">“answered” 标签</td>
</tr>
</tbody></table>
<p>当一个 <code>Message</code> 实例基于 <code>MMDFMessage</code> 实例被创建时，”From “ 行会被拷贝并直接对应所有旗标。</p>
<table>
<thead>
<tr>
<th align="left">结果状态</th>
<th align="left"><code>MMDFMessage</code> 状态</th>
</tr>
</thead>
<tbody><tr>
<td align="left">R 旗标</td>
<td align="left">R 旗标</td>
</tr>
<tr>
<td align="left">O 旗标</td>
<td align="left">O 旗标</td>
</tr>
<tr>
<td align="left">D 旗标</td>
<td align="left">D 旗标</td>
</tr>
<tr>
<td align="left">F 旗标</td>
<td align="left">F 旗标</td>
</tr>
<tr>
<td align="left">A 旗标</td>
<td align="left">A 旗标</td>
</tr>
</tbody></table>
<h4 id="MHMessage"><a href="#MHMessage" class="headerlink" title="MHMessage"></a><code>MHMessage</code></h4><p><em>class</em> <code>mailbox.MHMessage</code>(<em>message=None</em>)</p>
<p>具有 MH 专属行为的消息。 形参 <em>message</em> 的含义与 <code>Message</code> 构造器一致。</p>
<p>MH 消息不支持传统意义上的标记或旗标，但它们支持序列，即对任意消息的逻辑分组。 某些邮件阅读程序 (但不包括标准 <strong>mh</strong> 和 <strong>nmh</strong>) 以与其他格式使用旗标类似的方式来使用序列，如下所示:</p>
<table>
<thead>
<tr>
<th align="left">序列</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">unseen</td>
<td align="left">未阅读，但之前已经过 MUA 检测</td>
</tr>
<tr>
<td align="left">已回复</td>
<td align="left">回复给</td>
</tr>
<tr>
<td align="left">已标记</td>
<td align="left">已被标记为重要</td>
</tr>
</tbody></table>
<p><code>MHMessage</code> 实例提供了下列方法:</p>
<ul>
<li><p><code>get_sequences</code>()</p>
<p>返回一个包含此消息的序列的名称的列表。</p>
</li>
<li><p><code>set_sequences</code>(<em>sequences</em>)</p>
<p>设置包含此消息的序列的列表。</p>
</li>
<li><p><code>add_sequence</code>(<em>sequence</em>)</p>
<p>将 <em>sequence</em> 添加到包含此消息的序列的列表。</p>
</li>
<li><p><code>remove_sequence</code>(<em>sequence</em>)</p>
<p>将 <em>sequence</em> 从包含此消息的序列的列表中移除。</p>
</li>
</ul>
<p>当一个 <code>MHMessage</code> 实例基于 <code>MaildirMessage</code> 实例被创建时，将进行下列转换:</p>
<table>
<thead>
<tr>
<th align="left">结果状态</th>
<th align="left"><code>MaildirMessage</code> 状态</th>
</tr>
</thead>
<tbody><tr>
<td align="left">“unseen” 序列</td>
<td align="left">非 S 旗标</td>
</tr>
<tr>
<td align="left">“replied” 序列</td>
<td align="left">R 旗标</td>
</tr>
<tr>
<td align="left">“flagged” 序列</td>
<td align="left">F 旗标</td>
</tr>
</tbody></table>
<p>当一个 <code>MHMessage</code> 实例基于 <code>mboxMessage</code> 或 <code>MMDFMessage</code> 实例被创建时，将会忽略 <em>Status</em> 和 <em>X-Status</em> 标头并进行下列转换:</p>
<table>
<thead>
<tr>
<th align="left">结果状态</th>
<th align="left"><code>mboxMessage</code> 或 <code>MMDFMessage</code> 状态</th>
</tr>
</thead>
<tbody><tr>
<td align="left">“unseen” 序列</td>
<td align="left">非 R 旗标</td>
</tr>
<tr>
<td align="left">“replied” 序列</td>
<td align="left">A 旗标</td>
</tr>
<tr>
<td align="left">“flagged” 序列</td>
<td align="left">F 旗标</td>
</tr>
</tbody></table>
<p>当一个 <code>MHMessage</code> 实例基于 <code>BabylMessage</code> 实例被创建时，将进入下列转换:</p>
<table>
<thead>
<tr>
<th align="left">结果状态</th>
<th align="left"><code>BabylMessage</code> 状态</th>
</tr>
</thead>
<tbody><tr>
<td align="left">“unseen” 序列</td>
<td align="left">“unseen” 标签</td>
</tr>
<tr>
<td align="left">“replied” 序列</td>
<td align="left">“answered” 标签</td>
</tr>
</tbody></table>
<h4 id="BabylMessage"><a href="#BabylMessage" class="headerlink" title="BabylMessage"></a><code>BabylMessage</code></h4><p><em>class</em> <code>mailbox.BabylMessage</code>(<em>message=None</em>)</p>
<p>具有 Babyl 专属行为的消息。 形参 <em>message</em> 的含义与 <code>Message</code> 构造器一致。</p>
<p>某些消息标签被称为 <em>属性</em>，根据惯例被定义为具有特殊的含义。 这些属性如下所示:</p>
<table>
<thead>
<tr>
<th align="left">标签</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">unseen</td>
<td align="left">未阅读，但之前已经过 MUA 检测</td>
</tr>
<tr>
<td align="left">deleted</td>
<td align="left">标记为可被删除</td>
</tr>
<tr>
<td align="left">filed</td>
<td align="left">复制到另一个文件或邮箱</td>
</tr>
<tr>
<td align="left">answered</td>
<td align="left">回复给</td>
</tr>
<tr>
<td align="left">forwarded</td>
<td align="left">已转发</td>
</tr>
<tr>
<td align="left">edited</td>
<td align="left">已被用户修改</td>
</tr>
<tr>
<td align="left">resent</td>
<td align="left">已重发</td>
</tr>
</tbody></table>
<p>默认情况下，Rmail 只显示可见标头。 不过 <code>BabylMessage</code> 类会使用原始标头因为它们更完整。 如果需要可以显式地访问可见标头。</p>
<p><code>BabylMessage</code> 实例提供了下列方法:</p>
<ul>
<li><p><code>get_labels</code>()</p>
<p>返回邮件上的标签列表。</p>
</li>
<li><p><code>set_labels</code>(<em>labels</em>)</p>
<p>将消息上的标签列表设置为 <em>labels</em> 。</p>
</li>
<li><p><code>add_label</code>(<em>label</em>)</p>
<p>将 <em>label</em> 添加到消息上的标签列表中。</p>
</li>
<li><p><code>remove_label</code>(<em>label</em>)</p>
<p>从消息上的标签列表中删除 <em>label</em> 。</p>
</li>
<li><p><code>get_visible</code>()</p>
<p>返回一个 <code>Message</code> 实例，其标头为消息的可见标头而其消息体为空。</p>
</li>
<li><p><code>set_visible</code>(<em>visible</em>)</p>
<p>将消息的可见标头设为与 <em>message</em> 中的标头一致。 形参 <em>visible</em> 应当是一个 <code>Message</code> 实例，<code>email.message.Message</code> 实例，字符串或文件类对象（且应当以文本模式打开）。</p>
</li>
<li><p><code>update_visible</code>()</p>
<p>当一个 <code>BabylMessage</code> 实例的原始标头被修改时，可见标头不会自动进行对应修改。 此方法将按以下方式更新可见标头：每个具有对应原始标头的可见标头会被设为原始标头的值，每个没有对应原始标头的可见标头会被移除，而任何存在于原始标头但不存在于可见标头中的 <em>Date</em>, <em>From</em>, <em>Reply-To</em>, <em>To</em>, <em>CC</em> 和 <em>Subject</em> 会被添加至可见标头。</p>
</li>
</ul>
<p>当一个 <code>BabylMessage</code> 实例基于 <code>MaildirMessage</code> 实例被创建时，将进行下列转换:</p>
<table>
<thead>
<tr>
<th align="left">结果状态</th>
<th align="left"><code>MaildirMessage</code> 状态</th>
</tr>
</thead>
<tbody><tr>
<td align="left">“unseen” 标签</td>
<td align="left">非 S 旗标</td>
</tr>
<tr>
<td align="left">“deleted” 标签</td>
<td align="left">T 旗标</td>
</tr>
<tr>
<td align="left">“answered” 标签</td>
<td align="left">R 旗标</td>
</tr>
<tr>
<td align="left">“forwarded” 标签</td>
<td align="left">P 旗标</td>
</tr>
</tbody></table>
<p>当一个 <code>BabylMessage</code> 实例基于 <code>mboxMessage</code> 或 <code>MMDFMessage</code> 实例被创建时，将会忽略 <em>Status</em> 和 <em>X-Status</em> 标头并进入下列转换:</p>
<table>
<thead>
<tr>
<th align="left">结果状态</th>
<th align="left"><code>mboxMessage</code> 或 <code>MMDFMessage</code> 状态</th>
</tr>
</thead>
<tbody><tr>
<td align="left">“unseen” 标签</td>
<td align="left">非 R 旗标</td>
</tr>
<tr>
<td align="left">“deleted” 标签</td>
<td align="left">D 旗标</td>
</tr>
<tr>
<td align="left">“answered” 标签</td>
<td align="left">A 旗标</td>
</tr>
</tbody></table>
<p>当一个 <code>BabylMessage</code> 实例基于 <code>MHMessage</code> 实例被创建时，将进入下列转换:</p>
<table>
<thead>
<tr>
<th align="left">结果状态</th>
<th align="left"><code>MHMessage</code> 状态</th>
</tr>
</thead>
<tbody><tr>
<td align="left">“unseen” 标签</td>
<td align="left">“unseen” 序列</td>
</tr>
<tr>
<td align="left">“answered” 标签</td>
<td align="left">“replied” 序列</td>
</tr>
</tbody></table>
<h4 id="MMDFMessage"><a href="#MMDFMessage" class="headerlink" title="MMDFMessage"></a><code>MMDFMessage</code></h4><p><em>class</em> <code>mailbox.MMDFMessage</code>(<em>message=None</em>)</p>
<p>具有 MMDF 专属行为的消息。 形参 <em>message</em> 的含义与 <code>Message</code> 构造器一致。</p>
<p>与 mbox 邮箱中的消息类似，MMDF 消息会与将发件人的地址和发送日期作为以 “From “ 打头的初始行一起存储。 同样地，指明消息状态的旗标通常存储在 <em>Status</em> 和 <em>X-Status</em> 标头中。</p>
<p>传统的 MMDF 消息旗标与 mbox 消息的类似，如下所示:</p>
<table>
<thead>
<tr>
<th align="left">旗标</th>
<th align="left">含意</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">R</td>
<td align="left">已阅读</td>
<td align="left">已阅读</td>
</tr>
<tr>
<td align="left">O</td>
<td align="left">旧消息</td>
<td align="left">之前已经过 MUA 检测</td>
</tr>
<tr>
<td align="left">D</td>
<td align="left">已删除</td>
<td align="left">标记为可被删除</td>
</tr>
<tr>
<td align="left">F</td>
<td align="left">已标记</td>
<td align="left">已被标记为重要</td>
</tr>
<tr>
<td align="left">A</td>
<td align="left">已回复</td>
<td align="left">回复给</td>
</tr>
</tbody></table>
<p>“R” 和 “O” 旗标存储在 <em>Status</em> 标头中，而 “D”, “F” 和 “A” 旗标存储在 <em>X-Status</em> 标头中。 旗标和标头通常会按上述顺序显示。</p>
<p><code>MMDFMessage</code> 实例提供了下列方法，与 <code>mboxMessage</code> 所提供的类似:</p>
<ul>
<li><p><code>get_from</code>()</p>
<p>返回一个表示在 mbox 邮箱中标记消息起始的 “From “ 行的字符串。 开头的 “From “ 和末尾的换行符会被去除。</p>
</li>
<li><p><code>set_from</code>(<em>from_</em>, <em>time_=None</em>)</p>
<p>将 “From “ 行设为 <em>from_*，这应当被指定为不带开头的 “From “ 或末尾的换行符。 为方便起见，可以指定 *time_</em> 并将经过适当的格式化再添加到 <em>from_</em>。 如果指定了 <em>time_</em>，它应当是一个 <code>time.struct_time</code> 实例，适合传入 <code>time.strftime()</code> 的元组或者 <code>True</code> (以使用 <code>time.gmtime()</code>)。</p>
</li>
<li><p><code>get_flags</code>()</p>
<p>返回一个指明当前所设旗标的字符串。 如果消息符合规范格式，则结果为零或各自出现一次的 <code>'R'</code>, <code>'O'</code>, <code>'D'</code>, <code>'F'</code> 和 <code>'A'</code> 按上述顺序的拼接。</p>
</li>
<li><p><code>set_flags</code>(<em>flags</em>)</p>
<p>设置由 <em>flags</em> 所指明的旗标并重启所有其他旗标。 形参 <em>flags</em> 应当为零或各自出现多次的 <code>'R'</code>, <code>'O'</code>, <code>'D'</code>, <code>'F'</code> 和 <code>'A'</code> 按任意顺序的拼接。</p>
</li>
<li><p><code>add_flag</code>(<em>flag</em>)</p>
<p>设置由 <em>flag</em> 所指明的旗标而不改变其他旗标。 要一次性添加一个以上的旗标，<em>flag</em> 可以为包含一个以上字符的字符串。</p>
</li>
<li><p><code>remove_flag</code>(<em>flag</em>)</p>
<p>重置由 <em>flag</em> 所指明的旗标而不改变其他旗标。 要一次性移除一个以上的旗标，<em>flag</em> 可以为包含一个以上字符的字符串。</p>
</li>
</ul>
<p>当一个 <code>MMDFMessage</code> 实例基于 <code>MaildirMessage</code> 实例被创建时，”From “ 行会基于 <code>MaildirMessage</code> 实例的发送日期被生成，并进入下列转换:</p>
<table>
<thead>
<tr>
<th align="left">结果状态</th>
<th align="left"><code>MaildirMessage</code> 状态</th>
</tr>
</thead>
<tbody><tr>
<td align="left">R 旗标</td>
<td align="left">S 旗标</td>
</tr>
<tr>
<td align="left">O 旗标</td>
<td align="left">“cur” 子目录</td>
</tr>
<tr>
<td align="left">D 旗标</td>
<td align="left">T 旗标</td>
</tr>
<tr>
<td align="left">F 旗标</td>
<td align="left">F 旗标</td>
</tr>
<tr>
<td align="left">A 旗标</td>
<td align="left">R 旗标</td>
</tr>
</tbody></table>
<p>当一个 <code>MMDFMessage</code> 实例基于 <code>MHMessage</code> 实例被创建时，将进行下列转换:</p>
<table>
<thead>
<tr>
<th align="left">结果状态</th>
<th align="left"><code>MHMessage</code> 状态</th>
</tr>
</thead>
<tbody><tr>
<td align="left">R 旗标 和 O 旗标</td>
<td align="left">非 “unseen” 序列</td>
</tr>
<tr>
<td align="left">O 旗标</td>
<td align="left">“unseen” 序列</td>
</tr>
<tr>
<td align="left">F 旗标</td>
<td align="left">“flagged” 序列</td>
</tr>
<tr>
<td align="left">A 旗标</td>
<td align="left">“replied” 序列</td>
</tr>
</tbody></table>
<p>当一个 <code>MMDFMessage</code> 实例基于 <code>BabylMessage</code> 实例被创建时，将进行下列转换:</p>
<table>
<thead>
<tr>
<th align="left">结果状态</th>
<th align="left"><code>BabylMessage</code> 状态</th>
</tr>
</thead>
<tbody><tr>
<td align="left">R 旗标 和 O 旗标</td>
<td align="left">非 “unseen” 标签</td>
</tr>
<tr>
<td align="left">O 旗标</td>
<td align="left">“unseen” 标签</td>
</tr>
<tr>
<td align="left">D 旗标</td>
<td align="left">“deleted” 标签</td>
</tr>
<tr>
<td align="left">A 旗标</td>
<td align="left">“answered” 标签</td>
</tr>
</tbody></table>
<p>当一个 <code>MMDFMessage</code> 实例基于 <code>mboxMessage</code> 实例被创建时，”From “ 行会被拷贝并直接对应所有旗标:</p>
<table>
<thead>
<tr>
<th align="left">结果状态</th>
<th align="left"><code>mboxMessage</code> 状态</th>
</tr>
</thead>
<tbody><tr>
<td align="left">R 旗标</td>
<td align="left">R 旗标</td>
</tr>
<tr>
<td align="left">O 旗标</td>
<td align="left">O 旗标</td>
</tr>
<tr>
<td align="left">D 旗标</td>
<td align="left">D 旗标</td>
</tr>
<tr>
<td align="left">F 旗标</td>
<td align="left">F 旗标</td>
</tr>
<tr>
<td align="left">A 旗标</td>
<td align="left">A 旗标</td>
</tr>
</tbody></table>
<h3 id="异常-4"><a href="#异常-4" class="headerlink" title="异常"></a>异常</h3><p><code>mailbox</code> 模块中定义了下列异常类:</p>
<p><em>exception</em> <code>mailbox.Error</code></p>
<p>所有其他模块专属异常的基类。</p>
<p><em>exception</em> <code>mailbox.NoSuchMailboxError</code></p>
<p>在期望获得一个邮箱但未找到时被引发，例如当使用不存在的路径来实例化一个 <code>Mailbox</code> 子类时 (且将 <em>create</em> 形参设为 <code>False</code>)，或是当打开一个不存在的路径时。</p>
<p><em>exception</em> <code>mailbox.NotEmptyError</code></p>
<p>在期望一个邮箱为空但不为空时被引发，例如当删除一个包含消息的文件夹时。</p>
<p><em>exception</em> <code>mailbox.ExternalClashError</code></p>
<p>在某些邮箱相关条件超出了程序控制范围导致其无法继续运行时被引发，例如当要获取的锁已被另一个程序获取时，或是当要生成的唯一性文件名已存在时。</p>
<p><em>exception</em> <code>mailbox.FormatError</code></p>
<p>在某个文件中的数据无法被解析时被引发，例如当一个 <code>MH</code> 实例尝试读取已损坏的 <code>.mh_sequences</code> 文件时。</p>
<h3 id="例子-3"><a href="#例子-3" class="headerlink" title="例子"></a>例子</h3><p>一个打印指定邮箱中所有消息的主题的简单示例:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> mailbox
<span class="token keyword">for</span> message <span class="token keyword">in</span> mailbox<span class="token punctuation">.</span>mbox<span class="token punctuation">(</span><span class="token string">'~/mbox'</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    subject <span class="token operator">=</span> message<span class="token punctuation">[</span><span class="token string">'subject'</span><span class="token punctuation">]</span>       <span class="token comment" spellcheck="true"># Could possibly be None.</span>
    <span class="token keyword">if</span> subject <span class="token operator">and</span> <span class="token string">'python'</span> <span class="token keyword">in</span> subject<span class="token punctuation">.</span>lower<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span>subject<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>要将所有邮件从 Babyl 邮箱拷贝到 MH 邮箱，请转换所有可转换的格式专属信息:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> mailbox
destination <span class="token operator">=</span> mailbox<span class="token punctuation">.</span>MH<span class="token punctuation">(</span><span class="token string">'~/Mail'</span><span class="token punctuation">)</span>
destination<span class="token punctuation">.</span>lock<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">for</span> message <span class="token keyword">in</span> mailbox<span class="token punctuation">.</span>Babyl<span class="token punctuation">(</span><span class="token string">'~/RMAIL'</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    destination<span class="token punctuation">.</span>add<span class="token punctuation">(</span>mailbox<span class="token punctuation">.</span>MHMessage<span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">)</span>
destination<span class="token punctuation">.</span>flush<span class="token punctuation">(</span><span class="token punctuation">)</span>
destination<span class="token punctuation">.</span>unlock<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这个示例将来自多个邮件列表的邮件分类放入不同的邮箱，小心避免由于其他程序的并发修改导致的邮件损坏，由于程序中断导致的邮件丢失，或是由于邮箱中消息格式错误导致的意外终止:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> mailbox
<span class="token keyword">import</span> email<span class="token punctuation">.</span>errors
list_names <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token string">'python-list'</span><span class="token punctuation">,</span> <span class="token string">'python-dev'</span><span class="token punctuation">,</span> <span class="token string">'python-bugs'</span><span class="token punctuation">)</span>
boxes <span class="token operator">=</span> <span class="token punctuation">{</span>name<span class="token punctuation">:</span> mailbox<span class="token punctuation">.</span>mbox<span class="token punctuation">(</span><span class="token string">'~/email/%s'</span> <span class="token operator">%</span> name<span class="token punctuation">)</span> <span class="token keyword">for</span> name <span class="token keyword">in</span> list_names<span class="token punctuation">}</span>
inbox <span class="token operator">=</span> mailbox<span class="token punctuation">.</span>Maildir<span class="token punctuation">(</span><span class="token string">'~/Maildir'</span><span class="token punctuation">,</span> factory<span class="token operator">=</span>None<span class="token punctuation">)</span>
<span class="token keyword">for</span> key <span class="token keyword">in</span> inbox<span class="token punctuation">.</span>iterkeys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">try</span><span class="token punctuation">:</span>
        message <span class="token operator">=</span> inbox<span class="token punctuation">[</span>key<span class="token punctuation">]</span>
    <span class="token keyword">except</span> email<span class="token punctuation">.</span>errors<span class="token punctuation">.</span>MessageParseError<span class="token punctuation">:</span>
        <span class="token keyword">continue</span>                <span class="token comment" spellcheck="true"># The message is malformed. Just leave it.</span>
    <span class="token keyword">for</span> name <span class="token keyword">in</span> list_names<span class="token punctuation">:</span>
        list_id <span class="token operator">=</span> message<span class="token punctuation">[</span><span class="token string">'list-id'</span><span class="token punctuation">]</span>
        <span class="token keyword">if</span> list_id <span class="token operator">and</span> name <span class="token keyword">in</span> list_id<span class="token punctuation">:</span>
            <span class="token comment" spellcheck="true"># Get mailbox to use</span>
            box <span class="token operator">=</span> boxes<span class="token punctuation">[</span>name<span class="token punctuation">]</span>
            <span class="token comment" spellcheck="true"># Write copy to disk before removing original.</span>
            <span class="token comment" spellcheck="true"># If there's a crash, you might duplicate a message, but</span>
            <span class="token comment" spellcheck="true"># that's better than losing a message completely.</span>
            box<span class="token punctuation">.</span>lock<span class="token punctuation">(</span><span class="token punctuation">)</span>
            box<span class="token punctuation">.</span>add<span class="token punctuation">(</span>message<span class="token punctuation">)</span>
            box<span class="token punctuation">.</span>flush<span class="token punctuation">(</span><span class="token punctuation">)</span>
            box<span class="token punctuation">.</span>unlock<span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token comment" spellcheck="true"># Remove original message</span>
            inbox<span class="token punctuation">.</span>lock<span class="token punctuation">(</span><span class="token punctuation">)</span>
            inbox<span class="token punctuation">.</span>discard<span class="token punctuation">(</span>key<span class="token punctuation">)</span>
            inbox<span class="token punctuation">.</span>flush<span class="token punctuation">(</span><span class="token punctuation">)</span>
            inbox<span class="token punctuation">.</span>unlock<span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token keyword">break</span>               <span class="token comment" spellcheck="true"># Found destination, so stop looking.</span>
<span class="token keyword">for</span> box <span class="token keyword">in</span> boxes<span class="token punctuation">.</span>itervalues<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    box<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="mimetypes-—-映射文件名到-MIME-类型"><a href="#mimetypes-—-映射文件名到-MIME-类型" class="headerlink" title="mimetypes —- 映射文件名到 MIME 类型"></a><code>mimetypes</code> —- 映射文件名到 MIME 类型</h2><p><strong>源代码:</strong> <a href="https://github.com/python/cpython/tree/3.10/Lib/mimetypes.py" target="_blank" rel="noopener">Lib/mimetypes.py</a></p>
<hr>
<p><code>mimetypes</code> 模块可以在文件名或 URL 和关联到文件扩展名的 MIME 类型之间执行转换。 所提供的转换包括从文件名到 MIME 类型和从 MIME 类型到文件扩展名；后一种转换不支持编码格式。</p>
<p>该模块提供了一个类和一些便捷函数。 这些函数是该模块通常的接口，但某些应用程序可能也会希望使用类。</p>
<p>下列函数提供了此模块的主要接口。 如果此模块尚未被初始化，它们将会调用 <code>init()</code>，如果它们依赖于 <code>init()</code> 所设置的信息的话。</p>
<p><code>mimetypes.guess_type</code>(<em>url</em>, <em>strict=True</em>)</p>
<p>根据 <em>url</em> 给出的文件名、路径或 URL 来猜测文件的类型，URL 可以为字符串或 path-like object。</p>
<p>返回值是一个元组 <code>(type, encoding)</code> 其中 <em>type</em> 在无法猜测（后缀不存在或者未知）时为 <code>None</code>，或者为 <code>'type/subtype'</code> 形式的字符串，可以作为 MIME <em>content-type</em> 标头。</p>
<p><em>encoding</em> 在无编码格式时为 <code>None</code>，或者为程序所用的编码格式 (例如 <strong>compress</strong> 或 <strong>gzip</strong>)。 它可以作为 <em>Content-Encoding</em> 标头，但 <strong>不可</strong> 作为 <em>Content-Transfer-Encoding</em> 标头。 映射是表格驱动的。 编码格式前缀对大小写敏感；类型前缀会先以大小写敏感方式检测再以大小写不敏感方式检测。</p>
<p>可选的 <em>strict</em> 参数是一个旗标，指明要将已知 MIME 类型限制在 <a href="https://www.iana.org/assignments/media-types/media-types.xhtml" target="_blank" rel="noopener">IANA 已注册</a> 的官方类型之内。 当 <em>strict</em> 为 <code>True</code> 时（默认值），则仅支持 IANA 类型；当 <em>strict</em> 为 <code>False</code> 时，则还支持某些附加的非标准但常用的 MIME 类型。</p>
<p>在 3.8 版更改: 增加了 path-like object 作为 url 的支持。</p>
<p><code>mimetypes.guess_all_extensions</code>(<em>type</em>, <em>strict=True</em>)</p>
<p>根据由 <em>type</em> 给出的文件 MIME 类型猜测其扩展名。 返回值是由所有可能的文件扩展名组成的字符串列表，包括开头的点号 (<code>'.'</code>)。 这些扩展名不保证能关联到任何特定的数据流，但是将会由 <code>guess_type()</code> 映射到 MIME 类型 <em>type</em>。</p>
<p>可选的 <em>strict</em> 参数具有与 <code>guess_type()</code> 函数一致的含义。</p>
<p><code>mimetypes.guess_extension</code>(<em>type</em>, <em>strict=True</em>)</p>
<p>根据由 <em>type</em> 给出的文件 MIME 类型猜测其扩展名。 返回值是一个表示文件扩展名的字符串，包括开头的点号 (<code>'.'</code>)。 该扩展名不保证能关联到任何特定的数据流，但是将会由 <code>guess_type()</code> 映射到 MIME 类型 <em>type*。 如果不能猜测出 *type</em> 的扩展名，则将返回 <code>None</code>。</p>
<p>可选的 <em>strict</em> 参数具有与 <code>guess_type()</code> 函数一致的含义。</p>
<p>有一些附加函数和数据项可被用于控制此模块的行为。</p>
<p><code>mimetypes.init</code>(<em>files=None</em>)</p>
<p>初始化内部数据结构。 <em>files</em> 如果给出则必须是一个文件名序列，它应当被用于协助默认的类型映射。 如果省略则要使用的文件名会从 <code>knownfiles</code> 中获取； 在 Windows 上，将会载入当前注册表设置。 在 <em>files</em> 或 <code>knownfiles</code> 中指定的每个文件名的优先级将高于在它之前的文件名。 <code>init()</code> 允许被重复调用。</p>
<p>为 <em>files</em> 指定一个空列表将防止应用系统默认选项：将只保留来自内置列表的常用值。</p>
<p>如果 <em>files</em> 为 <code>None</code> 则内部数据结构会完全重建为其初始默认值。 这是一个稳定操作并将在多次调用时产生相同的结果。</p>
<p>在 3.2 版更改: 在之前版本中，Windows 注册表设置会被忽略。</p>
<p><code>mimetypes.read_mime_types</code>(<em>filename</em>)</p>
<p>载入在文件 <em>filename</em> 中给定的类型映射，如果文件存在的话。 返回的类型映射会是一个字典，其中的键值对为文件扩展名包括开头的点号 (<code>'.'</code>) 与 <code>'type/subtype'</code> 形式的字符串。 如果文件 <em>filename</em> 不存在或无法被读取，则返回 <code>None</code>。</p>
<p><code>mimetypes.add_type</code>(<em>type</em>, <em>ext</em>, <em>strict=True</em>)</p>
<p>添加一个从 MIME 类型 <em>type</em> 到扩展名 <em>ext</em> 的映射。 当扩展名已知时，新类型将替代旧类型。 当类型已知时，扩展名将被添加到已知扩展名列表。</p>
<p>当 <em>strict</em> 为 <code>True</code> 时（默认值），映射将被添加到官方 MIME 类型，否则添加到非标准类型。</p>
<pre><code>mimetypes.inited</code></pre><p>指明全局数据结构是否已被初始化的旗标。 这会由 <code>init()</code> 设为 <code>True</code>。</p>
<pre><code>mimetypes.knownfiles</code></pre><p>通常安装的类型映射文件名列表。 这些文件一般被命名为 <code>mime.types</code> 并会由不同的包安装在不同的位置。</p>
<pre><code>mimetypes.suffix_map</code></pre><p>将后缀映射到其他后缀的字典。 它被用来允许识别已编码的文件，其编码格式和类型是由相同的扩展名来指明的。 例如，<code>.tgz</code> 扩展名被映射到 <code>.tar.gz</code> 以允许编码格式和类型被分别识别。</p>
<pre><code>mimetypes.encodings_map</code></pre><p>映射文件扩展名到编码格式类型的字典。</p>
<pre><code>mimetypes.types_map</code></pre><p>映射文件扩展名到 MIME 类型的字典。</p>
<pre><code>mimetypes.common_types</code></pre><p>映射文件扩展名到非标准但常见的 MIME 类型的字典。</p>
<p>此模块一个使用示例:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> mimetypes
<span class="token operator">>></span><span class="token operator">></span> mimetypes<span class="token punctuation">.</span>init<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> mimetypes<span class="token punctuation">.</span>knownfiles
<span class="token punctuation">[</span><span class="token string">'/etc/mime.types'</span><span class="token punctuation">,</span> <span class="token string">'/etc/httpd/mime.types'</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> mimetypes<span class="token punctuation">.</span>suffix_map<span class="token punctuation">[</span><span class="token string">'.tgz'</span><span class="token punctuation">]</span>
<span class="token string">'.tar.gz'</span>
<span class="token operator">>></span><span class="token operator">></span> mimetypes<span class="token punctuation">.</span>encodings_map<span class="token punctuation">[</span><span class="token string">'.gz'</span><span class="token punctuation">]</span>
<span class="token string">'gzip'</span>
<span class="token operator">>></span><span class="token operator">></span> mimetypes<span class="token punctuation">.</span>types_map<span class="token punctuation">[</span><span class="token string">'.tgz'</span><span class="token punctuation">]</span>
<span class="token string">'application/x-tar-gz'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="MimeTypes-对象"><a href="#MimeTypes-对象" class="headerlink" title="MimeTypes 对象"></a>MimeTypes 对象</h3><p><code>MimeTypes</code> 类可以被用于那些需要多个 MIME 类型数据库的应用程序；它提供了与 <code>mimetypes</code> 模块所提供的类似接口。</p>
<p><em>class</em> <code>mimetypes.MimeTypes</code>(<em>filenames=()</em>, <em>strict=True</em>)</p>
<p>这个类表示 MIME 类型数据库。 默认情况下，它提供了对与此模块其余部分一致的数据库的访问权限。 这个初始数据库是此模块所提供数据库的一个副本，并可以通过使用 <code>read()</code> 或 <code>readfp()</code> 方法将附加的 <code>mime.types</code> 样式文载入到数据库中来进行扩展。 如果不需要默认数据的话这个映射字典也可以在载入附加数据之前先被清空。</p>
<p>可选的 <em>filenames</em> 形参可被用来让附加文件被载入到默认数据库“之上”。</p>
<ul>
<li><p><code>suffix_map</code></p>
<p>将后缀映射到其他后缀的字典。 它被用来允许识别已编码的文件，其编码格式和类型是由相同的扩展名来指明的。 例如，<code>.tgz</code> 扩展名被映射到 <code>.tar.gz</code> 以允许编码格式和类型被分别识别。 这是在模块中定义的全局 <code>suffix_map</code> 的一个副本。</p>
</li>
<li><p><code>encodings_map</code></p>
<p>映射文件扩展名到编码格式类型的字典。 这是在模块中定义的全局 <code>encodings_map</code> 的一个副本。</p>
</li>
<li><p><code>types_map</code></p>
<p>包含两个字典的元组，将文件扩展名映射到 MIME 类型：第一个字典针对非标准类型而第二个字典针对标准类型。 它们会由 <code>common_types</code> 和 <code>types_map</code> 来初始化。</p>
</li>
<li><p><code>types_map_inv</code></p>
<p>包含两个字典的元组，将 MIME 类型映射到文件扩展名列表：第一个字典针对非标准类型而第二个字典针对标准类型。 它们会由 <code>common_types</code> 和 <code>types_map</code> 来初始化。</p>
</li>
<li><p><code>guess_extension</code>(<em>type</em>, <em>strict=True</em>)</p>
<p>类似于 <code>guess_extension()</code> 函数，使用存储的表作为对象的一部分。</p>
</li>
<li><p><code>guess_type</code>(<em>url</em>, <em>strict=True</em>)</p>
<p>类似于 <code>guess_type()</code> 函数，使用存储的表作为对象的一部分。</p>
</li>
<li><p><code>guess_all_extensions</code>(<em>type</em>, <em>strict=True</em>)</p>
<p>类似于 <code>guess_all_extensions()</code> 函数，使用存储的表作为对象的一部分。</p>
</li>
<li><p><code>read</code>(<em>filename</em>, <em>strict=True</em>)</p>
<p>从名称为 <em>filename</em> 的文件载入 MIME 信息。 此方法使用 <code>readfp()</code> 来解析文件。</p>
<p>如果 <em>strict</em> 为 <code>True</code>，信息将被添加到标准类型列表，否则添加到非标准类型列表。</p>
</li>
<li><p><code>readfp</code>(<em>fp</em>, <em>strict=True</em>)</p>
<p>从打开的文件 <em>fp</em> 载入 MIME 类型信息。 文件必须具有标准 <code>mime.types</code> 文件的格式。</p>
<p>如果 <em>strict</em> 为 <code>True</code>，信息将被添加到标准类型列表，否则添加到非标准类型列表。</p>
</li>
<li><p><code>read_windows_registry</code>(<em>strict=True</em>)</p>
<p>从 Windows 注册表载入 MIME 类型信息。</p>
<p>可用性: Windows。</p>
<p>如果 <em>strict</em> 为 <code>True</code>，信息将被添加到标准类型列表，否则添加到非标准类型列表。</p>
<p>3.2 新版功能.</p>
</li>
</ul>
<h2 id="base64-—-Base16-Base32-Base64-Base85-数据编码"><a href="#base64-—-Base16-Base32-Base64-Base85-数据编码" class="headerlink" title="base64 —- Base16, Base32, Base64, Base85 数据编码"></a><code>base64</code> —- Base16, Base32, Base64, Base85 数据编码</h2><p><strong>源代码：</strong> <a href="https://github.com/python/cpython/tree/3.10/Lib/base64.py" target="_blank" rel="noopener">Lib/base64.py</a></p>
<hr>
<p>此模块提供了将二进制数据编码为可打印的 ASCII 字符以及将这种编码格式解码回二进制数据的函数。 它为 <a href="https://tools.ietf.org/html/rfc4648.html" target="_blank" rel="noopener"><strong>RFC 4648</strong></a> 所定义的 Base16, Base32 和 Base64 算法及已成为事实标准的 Ascii85 和 Base85 编码格式提供了编码和解码函数。</p>
<p><a href="https://tools.ietf.org/html/rfc4648.html" target="_blank" rel="noopener"><strong>RFC 4648</strong></a> 中的编码格式适用于编码二进制数据使得它能安全地通过电子邮件发送、用作 URL 的一部分，或者包括在 HTTP POST 请求之中。 此编码格式算法与 <strong>uuencode</strong> 程序并不相同。</p>
<p>此模块提供了两个接口。 较新的接口支持将 字节类对象 编码为 ASCII <code>bytes</code>，以及将 字节类对象 或包含 ASCII 的字符串解码为 <code>bytes</code>。 在 <a href="https://tools.ietf.org/html/rfc4648.html" target="_blank" rel="noopener"><strong>RFC 4648</strong></a> 中定义的几种 base-64 字母表（普通的以及 URL 和文件系统安全的）都受到支持。</p>
<p>旧的接口不提供从字符串的解码操作，但提供了操作 文件对象 的编码和解码函数。旧接口只支持标准的 Base64 字母表，并且按照 <a href="https://tools.ietf.org/html/rfc2045.html" target="_blank" rel="noopener"><strong>RFC 2045</strong></a> 的规范每 76 个字符增加一个换行符。注意：如果你需要支持 <a href="https://tools.ietf.org/html/rfc2045.html" target="_blank" rel="noopener"><strong>RFC 2045</strong></a>，那么使用 <code>email</code> 模块可能更加合适。</p>
<p>在 3.3 版更改: 新的接口提供的解码函数现在已经支持只包含 ASCII 的 Unicode 字符串。</p>
<p>在 3.4 版更改: 所有 类字节对象 现在已经被所有编码和解码函数接受。添加了对 Ascii85/Base85 的支持。</p>
<p>新的接口提供：</p>
<p><code>base64.b64encode</code>(<em>s</em>, <em>altchars=None</em>)</p>
<p>对 bytes-like object <em>s</em> 进行 Base64 编码，并返回编码后的 <code>bytes</code>。</p>
<p>可选项 <em>altchars</em> 必须是一个长 2 字节的 bytes-like object，它指定了用于替换 <code>+</code> 和 <code>/</code> 的字符。这允许应用程序生成 URL 或文件系统安全的 Base64 字符串。默认值是 <code>None</code>，使用标准 Base64 字母表。</p>
<p><code>base64.b64decode</code>(<em>s</em>, <em>altchars=None</em>, <em>validate=False</em>)</p>
<p>解码 Base64 编码过的 bytes-like object 或 ASCII 字符串 <em>s</em> 并返回解码过的 <code>bytes</code>。</p>
<p>可选项 <em>altchars</em> 必须是一个长 2 字节的 bytes-like object，它指定了用于替换 <code>+</code> 和 <code>/</code> 的字符。</p>
<p>如果 <em>s</em> 被不正确地填写，一个 <code>binascii.Error</code> 错误将被抛出。</p>
<p>如果 <em>validate</em> 值为 <code>False</code> （默认情况），则在填充检查前，将丢弃既不在标准 base-64 字母表之中也不在备用字母表中的字符。如果 <em>validate</em> 为 <code>True</code>，这些非 base64 字符将导致 <code>binascii.Error</code>。</p>
<p><code>base64.standard_b64encode</code>(<em>s</em>)</p>
<p>编码 bytes-like object <em>s</em>，使用标准 Base64 字母表并返回编码过的 <code>bytes</code>。</p>
<p><code>base64.standard_b64decode</code>(<em>s</em>)</p>
<p>解码 bytes-like object 或 ASCII 字符串 <em>s</em>，使用标准 Base64 字母表并返回编码过的 <code>bytes</code>。</p>
<p><code>base64.urlsafe_b64encode</code>(<em>s</em>)</p>
<p>编码 bytes-like object <em>s</em>，使用 URL 与文件系统安全的字母表，使用 <code>-</code> 以及 <code>_</code> 代替标准 Base64 字母表中的 <code>+</code> 和 <code>/</code>。返回编码过的 <code>bytes</code>。结果中可能包含 <code>=</code>。</p>
<p><code>base64.urlsafe_b64decode</code>(<em>s</em>)</p>
<p>解码 bytes-like object 或 ASCII 字符串 <em>s</em>，使用 URL 与文件系统安全的字母表，使用 <code>-</code> 以及 <code>_</code> 代替标准 Base64 字母表中的 <code>+</code> 和 <code>/</code>。返回解码过的 <code>bytes</code></p>
<p><code>base64.b32encode</code>(<em>s</em>)</p>
<p>用 Base32 编码 bytes-like object <em>s</em> 并返回编码过的 <code>bytes</code></p>
<p><code>base64.b32decode</code>(<em>s</em>, <em>casefold=False</em>, <em>map01=None</em>)</p>
<p>解码 Base32 编码过的 bytes-like object 或 ASCII 字符串 <em>s</em> 并返回解码过的 <code>bytes</code>。</p>
<p>可选的 <em>casefold</em> 是一个指定小写字幕是否可接受为输入的标志。为了安全考虑，默认值为 <code>False</code>。</p>
<p><a href="https://tools.ietf.org/html/rfc4648.html" target="_blank" rel="noopener"><strong>RFC 4648</strong></a> 允许可以选择将数码 0 (zero) 映射为字母 O (oh)，并可以选择将数码 1 (one) 映射为字母 I (eye) 或字母 L (el)。 可选参数 <em>map01</em> 在不为 <code>None</code> 时，指定数码 1 应当映射为哪个字母 (当 <em>map01</em> 不为 <code>None</code> 时，数码 0 总是被映射为字母 O)。 出于安全考虑其默认值为 <code>None</code>，因而在输入中不允许 0 和 1。</p>
<p>如果 <em>s</em> 被错误地填写或输入中存在字母表之外的字符，将抛出 <code>binascii.Error</code>。</p>
<p><code>base64.b32hexencode</code>(<em>s</em>)</p>
<p>类似于 <code>b32encode()</code> 但是使用 Extended Hex Alphabet，如 <a href="https://tools.ietf.org/html/rfc4648.html" target="_blank" rel="noopener"><strong>RFC 4648</strong></a> 所定义。</p>
<p>3.10 新版功能.</p>
<p><code>base64.b32hexdecode</code>(<em>s</em>, <em>casefold=False</em>)</p>
<p>类似于 <code>b32decode()</code> 但是使用 Extended Hex Alphabet，如 <a href="https://tools.ietf.org/html/rfc4648.html" target="_blank" rel="noopener"><strong>RFC 4648</strong></a> 所定义。</p>
<p>此版本不允许数码 0 (zero) 到字母 O (oh) 以及数码 1 (one) 到字母 I (eye) 或字母 L (el) 的映射，所有这些字符均包括在 Extended Hex Alphabet 当中并且不可相互替代。</p>
<p>3.10 新版功能.</p>
<p><code>base64.b16encode</code>(<em>s</em>)</p>
<p>用 Base16 编码 bytes-like object <em>s</em> 并返回编码过的 <code>bytes</code></p>
<p><code>base64.b16decode</code>(<em>s</em>, <em>casefold=False</em>)</p>
<p>解码 Base16 编码过的 bytes-like object 或 ASCII 字符串 <em>s</em> 并返回解码过的 <code>bytes</code>。</p>
<p>可选的 <em>casefold</em> 是一个指定小写字幕是否可接受为输入的标志。为了安全考虑，默认值为 <code>False</code>。</p>
<p>如果 <em>s</em> 被错误地填写或输入中存在字母表之外的字符，将抛出 <code>binascii.Error</code>。</p>
<p><code>base64.a85encode</code>(<em>b</em>, <em>**,</em> foldspaces=False<em>,</em> wrapcol=0<em>,</em> pad=False<em>,</em> adobe=False*)</p>
<p>用 Ascii85 编码 bytes-like object <em>s</em> 并返回编码过的 <code>bytes</code></p>
<p><em>foldspaces</em> 是一个可选的标志，使用特殊的短序列 ‘y’ 代替 ‘btoa’ 提供的 4 个连续空格 (ASCII 0x20)。这个特性不被 “标准” Ascii85 编码支持。</p>
<p><em>wrapcol</em> 控制了输出是否包含换行符 (<code>b'\n'</code>). 如果该值非零, 则每一行只有该值所限制的字符长度.</p>
<p><em>pad</em> 控制在编码之前输入是否填充为4的倍数。请注意，<code>btoa</code> 实现总是填充。</p>
<p><em>adobe</em> 控制编码后的字节序列是否要加上 <code>&lt;~</code> 和 <code>~&gt;</code>，这是 Adobe 实现所使用的。</p>
<p>3.4 新版功能.</p>
<p><code>base64.a85decode</code>(<em>b</em>, <em>**,</em> foldspaces=False<em>,</em> adobe=False<em>,</em> ignorechars=b’ \t\n\r\x0b’*)</p>
<p>解码 Ascii85 编码过的 bytes-like object 或 ASCII 字符串 <em>s</em> 并返回解码过的 <code>bytes</code>。</p>
<p><em>foldspaces</em> 旗标指明是否应接受 ‘y’ 短序列作为 4 个连续空格 (ASCII 0x20) 的快捷方式。 此特性不被 “标准” Ascii85 编码格式所支持。</p>
<p><em>adobe</em> 控制输入序列是否为 Adobe Ascii85 格式 (即附加 &lt;~ 和 ~&gt;)。</p>
<p><em>ignorechars</em> 应当是一个 bytes-like object 或 ASCII 字符串，其中包含要从输入中忽略的字符。 这应当只包含空白字符，并且默认包含 ASCII 中所有的空白字符。</p>
<p>3.4 新版功能.</p>
<p><code>base64.b85encode</code>(<em>b</em>, <em>pad=False</em>)</p>
<p>用 base85（如 git 风格的二进制 diff 数据所用格式）编码 bytes-like object <em>b</em> 并返回编码后的 <code>bytes</code>。</p>
<p>如果 <em>pad</em> 为真值，输入将以 <code>b'\0'</code> 填充以使其编码前长度为 4 字节的倍数。</p>
<p>3.4 新版功能.</p>
<p><code>base64.b85decode</code>(<em>b</em>)</p>
<p>解码 base85 编码过的 bytes-like object 或 ASCII 字符串 <em>b</em> 并返回解码过的 <code>bytes</code>。 如有必要，填充会被隐式地移除。</p>
<p>3.4 新版功能.</p>
<p>旧式接口:</p>
<p><code>base64.decode</code>(<em>input</em>, <em>output</em>)</p>
<p>解码二进制 <em>input</em> 文件的内容并将结果二进制数据写入 <em>output</em> 文件。 <em>input</em> 和 <em>output</em> 必须为 文件对象. <em>input</em> 将被读取直至 <code>input.readline()</code> 返回空字节串对象。</p>
<p><code>base64.decodebytes</code>(<em>s</em>)</p>
<p>解码 bytes-like object <em>s</em>，该对象必须包含一行或多行 base64 编码的数据，并返回已解码的 <code>bytes</code>。</p>
<p>3.1 新版功能.</p>
<p><code>base64.encode</code>(<em>input</em>, <em>output</em>)</p>
<p>编码二进制 <em>input</em> 文件的内容并将经 base64 编码的数据写入 <em>output</em> 文件。 <em>input</em> 和 <em>output</em> 必须为 文件对象。 <em>input</em> 将被读取直到 <code>input.read()</code> 返回空字节串对象。 <code>encode()</code> 会在每输出 76 个字节之后插入一个换行符 (<code>b'\n'</code>)，并会确保输出总是以换行符来结束，如 <a href="https://tools.ietf.org/html/rfc2045.html" target="_blank" rel="noopener"><strong>RFC 2045</strong></a> (MIME) 所规定的那样。</p>
<p><code>base64.encodebytes</code>(<em>s</em>)</p>
<p>编码 bytes-like object <em>s</em>，其中可以包含任意二进制数据，并返回包含经 base64 编码数据的 <code>bytes</code>，每输出 76 个字节之后将带一个换行符 (<code>b'\n'</code>)，并会确保在末尾也有一个换行符，如 <a href="https://tools.ietf.org/html/rfc2045.html" target="_blank" rel="noopener"><strong>RFC 2045</strong></a> (MIME) 所规定的那样。</p>
<p>3.1 新版功能.</p>
<p>此模块的一个使用示例:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> base64
<span class="token operator">>></span><span class="token operator">></span> encoded <span class="token operator">=</span> base64<span class="token punctuation">.</span>b64encode<span class="token punctuation">(</span>b<span class="token string">'data to be encoded'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> encoded
b<span class="token string">'ZGF0YSB0byBiZSBlbmNvZGVk'</span>
<span class="token operator">>></span><span class="token operator">></span> data <span class="token operator">=</span> base64<span class="token punctuation">.</span>b64decode<span class="token punctuation">(</span>encoded<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> data
b<span class="token string">'data to be encoded'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="安全考量-2"><a href="#安全考量-2" class="headerlink" title="安全考量"></a>安全考量</h3><p>在 <a href="https://tools.ietf.org/html/rfc4648.html" target="_blank" rel="noopener"><strong>RFC 4648</strong></a> 中新增了安全事项部分（第 12 节）；对于要部署到生产环境的任何代码都建议充分考虑此安全事项部分。</p>
<p>参见</p>
<p>模块 <code>binascii</code></p>
<p>支持模块，包含ASCII到二进制和二进制到ASCII转换。</p>
<p><a href="https://tools.ietf.org/html/rfc1521.html" target="_blank" rel="noopener"><strong>RFC 1521</strong></a> - MIME (Multipurpose Internet Mail Extensions) 第一部分：规定并描述因特网消息体的格式的机制。</p>
<p>第 5.2 节，“Base64 内容转换编码格式” 提供了 base64 编码格式的定义。</p>
<h2 id="binhex-—-对binhex4文件进行编码和解码"><a href="#binhex-—-对binhex4文件进行编码和解码" class="headerlink" title="binhex —- 对binhex4文件进行编码和解码"></a><code>binhex</code> —- 对binhex4文件进行编码和解码</h2><p><strong>源代码:</strong> <a href="https://github.com/python/cpython/tree/3.10/Lib/binhex.py" target="_blank" rel="noopener">Lib/binhex.py</a></p>
<p>3.9 版后已移除.</p>
<hr>
<p>此模块以binhe4格式对文件进行编码和解码，该格式允许Macintosh文件以ASCII格式表示。仅处理数据分支。</p>
<p><code>binhex</code> 模块定义了以下功能：</p>
<p><code>binhex.binhex</code>(<em>input</em>, <em>output</em>)</p>
<p>将带有文件名 <em>输入</em> 的二进制文件转换为binhex文件 <em>输出</em> 。输出参数可以是文件名或类文件对象（ <code>write()</code> 和 <code>close()</code> 方法的任何对象）。</p>
<p><code>binhex.hexbin</code>(<em>input</em>, <em>output</em>)</p>
<p>解码binhex文件输入。 <em>输入</em> 可以是支持 <code>read()</code> 和 <code>close()</code> 方法的文件名或类文件对象。生成的文件将写入名为 <em>output</em> 的文件，除非参数为 <code>None</code> ，在这种情况下，从binhex文件中读取输出文件名。</p>
<p>还定义了以下异常：</p>
<p><em>exception</em> <code>binhex.Error</code></p>
<p>当无法使用binhex格式编码某些内容时（例如，文件名太长而无法放入文件名字段中），或者输入未正确编码的binhex数据时，会引发异常。</p>
<h3 id="备注-1"><a href="#备注-1" class="headerlink" title="备注"></a>备注</h3><p>还有一个替代的、功能更强大的编码器和解码器接口，详细信息请参见源代码。</p>
<p>如果您在非Macintosh平台上编码或解码文本文件，它们仍将使用旧的Macintosh换行符约定（回车符作为行尾）。</p>
<h2 id="binascii-—-二进制和-ASCII-码互转"><a href="#binascii-—-二进制和-ASCII-码互转" class="headerlink" title="binascii —- 二进制和 ASCII 码互转"></a><code>binascii</code> —- 二进制和 ASCII 码互转</h2><p><code>binascii</code> 模块包含很多在二进制和二进制表示的各种ASCII码之间转换的方法。 通常情况不会直接使用这些函数，而是使用像 <code>uu</code> ， <code>base64</code> ，或 <code>binhex</code> 这样的封装模块。 为了执行效率高，<code>binascii</code> 模块含有许多用 C 写的低级函数，这些底层函数被一些高级模块所使用。</p>
<p>注解</p>
<p><code>a2b_*</code> 函数接受只含有 ASCII 码的Unicode 字符串。其他函数只接受 字节类对象 （例如 <code>bytes</code>，<code>bytearray</code> 和其他支持缓冲区协议的对象）。</p>
<p>在 3.3 版更改: ASCII-only unicode strings are now accepted by the <code>a2b_*</code> functions.</p>
<p><code>binascii</code> 模块定义了以下函数：</p>
<p><code>binascii.a2b_uu</code>(<em>string</em>)</p>
<p>将单行 uu 编码数据转换成二进制数据并返回。uu 编码每行的数据通常包含45 个（二进制）字节，最后一行除外。每行数据后面可能跟有空格。</p>
<p><code>binascii.b2a_uu</code>(<em>data</em>, <em>**,</em> backtick=False*)</p>
<p>将二进制数据转换为 ASCII 编码字符，返回值是转换后的行数据，包括换行符。 <em>data</em> 的长度最多为45。如果 <em>backtick</em> 为ture，则零由 <code>'</code>‘` 而不是空格表示。</p>
<p>在 3.7 版更改: 增加 <em>backtick</em> 形参。</p>
<p><code>binascii.a2b_base64</code>(<em>string</em>)</p>
<p>将 base64 数据块转换成二进制并以二进制数据形式返回。一次可以传递多行数据。</p>
<p><code>binascii.b2a_base64</code>(<em>data</em>, <em>**,</em> newline=True*)</p>
<p>将二进制数据转换为一行用 base64 编码的ASCII字符串。返回值是转换后的行数据，如果 <em>newline</em> 为true，则返回值包括换行符。该函数的输出符合：rfc：3548。</p>
<p>在 3.6 版更改: 增加 <em>newline</em> 形参。</p>
<p><code>binascii.a2b_qp</code>(<em>data</em>, <em>header=False</em>)</p>
<p>将一个引号可打印的数据块转换成二进制数据并返回。一次可以转换多行。如果可选参数 <em>header</em> 存在且为true，则数据中的下划线将被解码成空格。</p>
<p><code>binascii.b2a_qp</code>(<em>data</em>, <em>quotetabs=False</em>, <em>istext=True</em>, <em>header=False</em>)</p>
<p>将二进制数据转换为一行或多行带引号可打印编码的ASCII字符串。返回值是转换后的行数据。如果可选参数 <em>quotetabs</em> 存在且为真值，则对所有制表符和空格进行编码。如果可选参数 <em>istext</em> 存在且为真值，则不对新行进行编码，但将对尾随空格进行编码。如果可选参数 <em>header</em> 存在且为true，则空格将被编码为下划线 <a href="https://tools.ietf.org/html/rfc1522.html" target="_blank" rel="noopener"><strong>RFC 1522</strong></a>。如果可选参数 <em>header</em> 存在且为假值，则也会对换行符进行编码;不进行换行转换编码可能会破坏二进制数据流。</p>
<p><code>binascii.a2b_hqx</code>(<em>string</em>)</p>
<p>将 binhex4 格式的 ASCII 数据不进行 RLE 解压缩直接转换为二进制数据。该字符串应包含完整数量的二进制字节，或者（在binhex4 数据最后部分）剩余位为零。</p>
<p>3.9 版后已移除.</p>
<p><code>binascii.rledecode_hqx</code>(<em>data</em>)</p>
<p>根据 binhex4 标准对数据执行 RLE 解压缩。该算法在一个字节的数据后使用 <code>0x90</code> 作为重复指示符，然后计数。计数 <code>0</code> 指定字节值 <code>0x90</code> 。该例程返回解压缩的数据，输入数据以孤立的重复指示符结束的情况下，将引发 <code>Incomplete</code> 异常。</p>
<p>在 3.2 版更改: 仅接受 bytestring 或 bytearray 对象作为输入。</p>
<p>3.9 版后已移除.</p>
<p><code>binascii.rlecode_hqx</code>(<em>data</em>)</p>
<p>在 <em>data</em> 上执行 binhex4 游程编码压缩并返回结果。</p>
<p>3.9 版后已移除.</p>
<p><code>binascii.b2a_hqx</code>(<em>data</em>)</p>
<p>执行 hexbin4 类型二进制到 ASCII 码的转换并返回结果字符串。输入数据应经过 RLE 编码，且数据长度可被3整除（除了最后一个片段）。</p>
<p>3.9 版后已移除.</p>
<p><code>binascii.crc_hqx</code>(<em>data</em>, <em>value</em>)</p>
<p>以 <em>value</em> 作为初始 CRC 计算 <em>data</em> 的16位 CRC 值，返回其结果。这里使用 CRC-CCITT 生成多项式 <em>x</em>16 + <em>x</em>12 + <em>x</em>5 + 1 ，通常表示为0x1021。该 CRC 被用于 binhex4 格式。</p>
<p><code>binascii.crc32</code>(<em>data</em>[, <em>value</em>])</p>
<p>计算 CRC-32 ，从 <em>value</em> 的初始 CRC 开始计算 <em>data</em> 的32位校验和。默认初始 CRC 为零。该算法与 ZIP 文件校验和一致。由于该算法被设计用作校验和算法，因此不适合用作通用散列算法。使用方法如下：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span>binascii<span class="token punctuation">.</span>crc32<span class="token punctuation">(</span>b<span class="token string">"hello world"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment" spellcheck="true"># Or, in two pieces:</span>
crc <span class="token operator">=</span> binascii<span class="token punctuation">.</span>crc32<span class="token punctuation">(</span>b<span class="token string">"hello"</span><span class="token punctuation">)</span>
crc <span class="token operator">=</span> binascii<span class="token punctuation">.</span>crc32<span class="token punctuation">(</span>b<span class="token string">" world"</span><span class="token punctuation">,</span> crc<span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'crc32 = {:#010x}'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>crc<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在 3.0 版更改: 校验结果始终是无符号类型的。要在所有Python版本和平台上生成相同的数值，请使用 <code>crc32(data) &amp; 0xffffffff</code> 。</p>
<p><code>binascii.b2a_hex</code>(<em>data</em>[, <em>sep</em>[, <em>bytes_per_sep=1</em>]])</p>
<p><code>binascii.hexlify</code>(<em>data</em>[, <em>sep</em>[, <em>bytes_per_sep=1</em>]])</p>
<p>返回二进制数据 <em>data</em> 的十六进制表示形式。 <em>data</em> 的每个字节都被转换为相应的2位十六进制表示形式。因此返回的字节对象的长度是 <em>data</em> 的两倍。</p>
<p>使用：<code>bytes.hex()</code> 方法也可以方便地实现相似的功能（但仅返回文本字符串）。</p>
<p>如果指定了 <em>sep*，它必须为单字符 str 或 bytes 对象。 它将被插入每个 *bytes_per_sep</em> 输入字节之后。 分隔符位置默认从输出的右端开始计数，如果你希望从左端开始计数，请提供一个负的 <em>bytes_per_sep</em> 值。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> binascii
<span class="token operator">>></span><span class="token operator">></span> binascii<span class="token punctuation">.</span>b2a_hex<span class="token punctuation">(</span>b<span class="token string">'\xb9\x01\xef'</span><span class="token punctuation">)</span>
b<span class="token string">'b901ef'</span>
<span class="token operator">>></span><span class="token operator">></span> binascii<span class="token punctuation">.</span>hexlify<span class="token punctuation">(</span>b<span class="token string">'\xb9\x01\xef'</span><span class="token punctuation">,</span> <span class="token string">'-'</span><span class="token punctuation">)</span>
b<span class="token string">'b9-01-ef'</span>
<span class="token operator">>></span><span class="token operator">></span> binascii<span class="token punctuation">.</span>b2a_hex<span class="token punctuation">(</span>b<span class="token string">'\xb9\x01\xef'</span><span class="token punctuation">,</span> b<span class="token string">'_'</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>
b<span class="token string">'b9_01ef'</span>
<span class="token operator">>></span><span class="token operator">></span> binascii<span class="token punctuation">.</span>b2a_hex<span class="token punctuation">(</span>b<span class="token string">'\xb9\x01\xef'</span><span class="token punctuation">,</span> b<span class="token string">' '</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">)</span>
b<span class="token string">'b901 ef'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在 3.8 版更改: 添加了 <em>sep</em> 和 <em>bytes_per_sep</em> 形参。</p>
<p><code>binascii.a2b_hex</code>(<em>hexstr</em>)</p>
<p><code>binascii.unhexlify</code>(<em>hexstr</em>)</p>
<p>返回由十六进制字符串 <em>hexstr</em> 表示的二进制数据。此函数功能与 <code>b2a_hex()</code> 相反。 <em>hexstr</em> 必须包含偶数个十六进制数字（可以是大写或小写），否则会引发 <code>Error</code> 异常。</p>
<p>使用：<code>bytes.fromhex()</code> 类方法也实现相似的功能（仅接受文本字符串参数，不限制其中的空白字符）。</p>
<p><em>exception</em> <code>binascii.Error</code></p>
<p>通常是因为编程错误引发的异常。</p>
<p><em>exception</em> <code>binascii.Incomplete</code></p>
<p>数据不完整引发的异常。通常不是编程错误导致的，可以通过读取更多的数据并再次尝试来处理该异常。</p>
<h2 id="quopri-—-编码与解码经过-MIME-转码的可打印数据"><a href="#quopri-—-编码与解码经过-MIME-转码的可打印数据" class="headerlink" title="quopri —- 编码与解码经过 MIME 转码的可打印数据"></a><code>quopri</code> —- 编码与解码经过 MIME 转码的可打印数据</h2><p><strong>源代码:</strong> <a href="https://github.com/python/cpython/tree/3.10/Lib/quopri.py" target="_blank" rel="noopener">Lib/quopri.py</a></p>
<hr>
<p>此模块会执行转换后可打印的传输编码与解码，具体定义见 <a href="https://tools.ietf.org/html/rfc1521.html" target="_blank" rel="noopener"><strong>RFC 1521</strong></a>: “MIME (Multipurpose Internet Mail Extensions) Part One: Mechanisms for Specifying and Describing the Format of Internet Message Bodies”。 转换后可打印的编码格式被设计用于只包含相对较少的不可打印字符的数据；如果存在大量这样的字符，通过 <code>base64</code> 模块所提供的 base64 编码方案会更为紧凑，例如当发送图片文件时。</p>
<p><code>quopri.decode</code>(<em>input</em>, <em>output</em>, <em>header=False</em>)</p>
<p>解码 <em>input</em> 文件的内容并将已解码二进制数据结果写入 <em>output</em> 文件。 <em>input</em> 和 <em>output</em> 必须为 二进制文件对象。 如果提供了可选参数 <em>header</em> 且为真值，下划线将被解码为空格。 此函数可用于解码“Q”编码的头数据，具体描述见 <a href="https://tools.ietf.org/html/rfc1522.html" target="_blank" rel="noopener"><strong>RFC 1522</strong></a>: “MIME (Multipurpose Internet Mail Extensions) Part Two: Message Header Extensions for Non-ASCII Text”。</p>
<p><code>quopri.encode</code>(<em>input</em>, <em>output</em>, <em>quotetabs</em>, <em>header=False</em>)</p>
<p>编码 <em>input</em> 文件的内容并将转换后可打印的数据结果写入 <em>output</em> 文件。 <em>input</em> 和 <em>output</em> 必须为 二进制文件对象. <em>quotetabs</em> 是一个非可选的旗标，它控制是否要编码内嵌的空格与制表符；当为真值时将编码此类内嵌空白符，当为假值时则保持原样不进行编码。 请注意出现在行尾的空格与制表符总是会被编码，具体描述见 <a href="https://tools.ietf.org/html/rfc1521.html" target="_blank" rel="noopener"><strong>RFC 1521</strong></a>。 <em>header</em> 旗标控制空格符是否要编码为下划线，具体描述见 <a href="https://tools.ietf.org/html/rfc1522.html" target="_blank" rel="noopener"><strong>RFC 1522</strong></a>。</p>
<p><code>quopri.decodestring</code>(<em>s</em>, <em>header=False</em>)</p>
<p>类似 <code>decode()</code>，区别在于它接受一个源 <code>bytes</code> 并返回对应的已解码 <a href="https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#bytes" target="_blank" rel="noopener"><code>bytes</code></a>。</p>
<p><code>quopri.encodestring</code>(<em>s</em>, <em>quotetabs=False</em>, <em>header=False</em>)</p>
<p>类型 <code>encode()</code>，区别在于它接受一个源 <code>bytes</code> 并返回对应的已编码 <code>bytes</code>。 在默认情况下，它会发送 <code>False</code> 值给 <code>encode()</code> 函数的 <em>quotetabs</em> 形参。</p>
<h2 id="uu-—-对-uuencode-文件进行编码与解码"><a href="#uu-—-对-uuencode-文件进行编码与解码" class="headerlink" title="uu —- 对 uuencode 文件进行编码与解码"></a><code>uu</code> —- 对 uuencode 文件进行编码与解码</h2><p><strong>源代码:</strong> <a href="https://github.com/python/cpython/tree/3.10/Lib/uu.py" target="_blank" rel="noopener">Lib/uu.py</a></p>
<hr>
<p>此模块使用 uuencode 格式来编码和解码文件，以便任意二进制数据可通过仅限 ASCII 码的连接进行传输。 在任何要求文件参数的地方，这些方法都接受文件类对象。 为了保持向下兼容，也接受包含路径名称的字符串，并且将打开相应的文件进行读写；路径名称 <code>'-'</code> 被解读为标准输入或输出。 但是，此接口已被弃用；在 Windows 中调用者最好是自行打开文件，并在需要时确保模式为 <code>'rb'</code> or <code>'wb'</code>。</p>
<p>此代码由 Lance Ellinghouse 贡献，并由 Jack Jansen 修改。</p>
<p><code>uu</code> 模块定义了以下函数：</p>
<p><code>uu.encode</code>(<em>in_file</em>, <em>out_file</em>, <em>name=None</em>, <em>mode=None</em>, <em>**,</em> backtick=False*)</p>
<p>使用 uuencode 将 <em>in_file</em> 文件编码为 <em>out_file</em> 文件。 经过 uuencoded 编码的文件将具有指定 <em>name</em> 和 <em>mode</em> 作为解码该文件默认结果的标头。 默认值会相应地从 <em>in_file</em> 或 <code>'-'</code> 以及 <code>0o666</code> 中提取。 如果 <em>backtick</em> 为真值，零会用 <code>'</code>‘` 而不是空格来表示。</p>
<p>在 3.7 版更改: 增加 <em>backtick</em> 形参。</p>
<p><code>uu.decode</code>(<em>in_file</em>, <em>out_file=None</em>, <em>mode=None</em>, <em>quiet=False</em>)</p>
<p>调用此函数会解码 uuencod 编码的 <em>in_file</em> 文件并将结果放入 <em>out_file</em> 文件。 如果 <em>out_file</em> 是一个路径名称，<em>mode</em> 会在必须创建文件时用于设置权限位。 <em>out_file</em> 和 <em>mode</em> 的默认值会从 uuencode 标头中提取。 但是，如果标头中指定的文件已存在，则会引发 <code>uu.Error</code>。</p>
<p>如果输入由不正确的 uuencode 编码器生成，<code>decode()</code> 可能会打印一条警告到标准错误 ，这样 Python 可以从该错误中恢复。 将 <em>quiet</em> 设为真值可以屏蔽此警告。</p>
<p><em>exception</em> <code>uu.Error</code></p>
<p><code>Exception</code> 的子类，此异常可由 <code>uu.decode()</code> 在多种情况下引发，如上文所述，此外还包括格式错误的标头或被截断的输入文件等。</p>
<h1 id="结构化标记处理工具"><a href="#结构化标记处理工具" class="headerlink" title="结构化标记处理工具"></a>结构化标记处理工具</h1><p>Python 支持各种模块，以处理各种形式的结构化数据标记。 这包括使用标准通用标记语言（SGML）和超文本标记语言（HTML）的模块，以及使用可扩展标记语言（XML）的几个接口。</p>
<ul>
<li><code>html</code> —- 超文本标记语言支持</li>
<li><code>html.parser</code> —- 简单的 HTML 和 XHTML 解析器<ul>
<li>HTML 解析器的示例程序</li>
<li><code>HTMLParser</code> 方法</li>
<li>例子</li>
</ul>
</li>
<li><code>html.entities</code> —- HTML 一般实体的定义</li>
<li>XML处理模块<ul>
<li>XML 漏洞</li>
<li><code>defusedxml</code> 包</li>
</ul>
</li>
<li><code>xml.etree.ElementTree</code> —- ElementTree XML API<ul>
<li>教程<ul>
<li>XML 树和元素</li>
<li>解析 XML</li>
<li>用于非阻塞解析的拉取 API</li>
<li>查找感兴趣的元素</li>
<li>修改XML文件</li>
<li>构建 XML 文档</li>
<li>解析带有命名空间的 XML</li>
<li>其他资源</li>
</ul>
</li>
<li>XPath支持<ul>
<li>示例</li>
<li>支持的XPath语法</li>
</ul>
</li>
<li>参考<ul>
<li>函数</li>
</ul>
</li>
<li>XInclude 支持<ul>
<li>示例</li>
</ul>
</li>
<li>参考<ul>
<li>函数</li>
<li>元素对象</li>
<li>ElementTree 对象</li>
<li>QName 对象</li>
<li>TreeBuilder 对象</li>
<li>XMLParser对象</li>
<li>XMLPullParser对象</li>
<li>异常</li>
</ul>
</li>
</ul>
</li>
<li><code>xml.dom</code> —- 文档对象模型 API<ul>
<li>模块内容</li>
<li>DOM 中的对象<ul>
<li>DOMImplementation 对象</li>
<li>节点对象</li>
<li>节点列表对象</li>
<li>文档类型对象</li>
<li>Document 对象</li>
<li>元素对象</li>
<li>Attr 对象</li>
<li>NamedNodeMap 对象</li>
<li>注释对象</li>
<li>Text 和 CDATASection 对象</li>
<li>ProcessingInstruction 对象</li>
<li>异常</li>
</ul>
</li>
<li>一致性<ul>
<li>类型映射</li>
<li>访问器方法</li>
</ul>
</li>
</ul>
</li>
<li><code>xml.dom.minidom</code> —- 最小化的 DOM 实现<ul>
<li>DOM 对象</li>
<li>DOM 示例</li>
<li>minidom 和 DOM 标准</li>
</ul>
</li>
<li><code>xml.dom.pulldom</code> —- 支持构建部分 DOM 树<ul>
<li>DOMEventStream 对象</li>
</ul>
</li>
<li><code>xml.sax</code> —- 支持 SAX2 解析器<ul>
<li>SAXException 对象</li>
</ul>
</li>
<li><code>xml.sax.handler</code> —- SAX 处理句柄的基类<ul>
<li>ContentHandler 对象</li>
<li>DTDHandler 对象</li>
<li>EntityResolver 对象</li>
<li>ErrorHandler 对象</li>
<li>LexicalHandler 对象</li>
</ul>
</li>
<li><code>xml.sax.saxutils</code> —- SAX 工具集</li>
<li><code>xml.sax.xmlreader</code> —- 用于 XML 解析器的接口<ul>
<li>XMLReader 对象</li>
<li>IncrementalParser 对象</li>
<li>Locator 对象</li>
<li>InputSource 对象</li>
<li><code>Attributes</code> 接口</li>
<li><code>AttributesNS</code> 接口</li>
</ul>
</li>
<li><code>xml.parsers.expat</code> —- 使用 Expat 的快速 XML 解析<ul>
<li>XMLParser对象</li>
<li>ExpatError 异常</li>
<li>示例</li>
<li>内容模型描述</li>
<li>Expat 错误常量</li>
</ul>
</li>
</ul>
<h2 id="html-—-超文本标记语言支持"><a href="#html-—-超文本标记语言支持" class="headerlink" title="html —- 超文本标记语言支持"></a><code>html</code> —- 超文本标记语言支持</h2><p><strong>源码：</strong> <a href="https://github.com/python/cpython/tree/3.10/Lib/html/__init__.py" target="_blank" rel="noopener">Lib/html/<strong>init</strong>.py</a></p>
<hr>
<p>该模块定义了操作HTML的工具。</p>
<p><code>html.escape</code>(<em>s</em>, <em>quote=True</em>)</p>
<p>将字符串 <em>s</em> 中的字符<code>&amp;</code> 、 <code>&lt;</code> 和 <code>&gt;</code> 转换为安全的HTML序列。 如果需要在 HTML 中显示可能包含此类字符的文本，请使用此选项。 如果可选的标志 <em>quote</em> 为真值，则字符 (<code>"</code>) 和 (<code>'</code>) 也被转换；这有助于包含在由引号分隔的 HTML 属性中，如 <code>&lt;a href="..."&gt;</code>。</p>
<p>3.2 新版功能.</p>
<p><code>html.unescape</code>(<em>s</em>)</p>
<p>将字符串 <em>s</em> 中的所有命名和数字字符引用 (例如 <code>&gt;</code>, <code>&gt;</code>, <code>&gt;</code>) 转换为相应的Unicode字符。 此函数使用HTML 5标准为有效和无效字符引用定义的规则，以及 <code>HTML 5 命名字符引用列表</code>。</p>
<p>3.4 新版功能.</p>
<hr>
<p><code>html</code> 包中的子模块是：</p>
<ul>
<li><a href="https://docs.python.org/zh-cn/3.10/library/html.parser.html#module-html.parser" target="_blank" rel="noopener"><code>html.parser</code></a> —— 具有宽松解析模式的HTML / XHTML解析器</li>
<li><a href="https://docs.python.org/zh-cn/3.10/library/html.entities.html#module-html.entities" target="_blank" rel="noopener"><code>html.entities</code></a> – HTML 实体定义</li>
</ul>
<h2 id="XML处理模块"><a href="#XML处理模块" class="headerlink" title="XML处理模块"></a>XML处理模块</h2><p><strong>源码：</strong> <a href="https://github.com/python/cpython/tree/3.10/Lib/xml/" target="_blank" rel="noopener">Lib/xml/</a></p>
<hr>
<p>用于处理XML的Python接口分组在 <code>xml</code> 包中。</p>
<p>警告</p>
<p>XML 模块对于错误或恶意构造的数据是不安全的。 如果你需要解析不受信任或未经身份验证的数据。</p>
<p>值得注意的是 <code>xml</code> 包中的模块要求至少有一个 SAX 兼容的 XML 解析器可用。在 Python 中包含 Expat 解析器，因此 <code>xml.parsers.expat</code> 模块将始终可用。</p>
<p><code>xml.dom</code> 和 <code>xml.sax</code> 包的文档是 DOM 和 SAX 接口的 Python 绑定的定义。</p>
<p>XML 处理子模块包括:</p>
<ul>
<li><p><a href="https://docs.python.org/zh-cn/3.10/library/xml.etree.elementtree.html#module-xml.etree.ElementTree" target="_blank" rel="noopener"><code>xml.etree.ElementTree</code></a>： ElementTree API，一个简单而轻量级的XML处理器</p>
</li>
<li><p><a href="https://docs.python.org/zh-cn/3.10/library/xml.dom.html#module-xml.dom" target="_blank" rel="noopener"><code>xml.dom</code></a>：DOM API 定义</p>
</li>
<li><p><a href="https://docs.python.org/zh-cn/3.10/library/xml.dom.minidom.html#module-xml.dom.minidom" target="_blank" rel="noopener"><code>xml.dom.minidom</code></a>：最小的 DOM 实现</p>
</li>
<li><p><a href="https://docs.python.org/zh-cn/3.10/library/xml.dom.pulldom.html#module-xml.dom.pulldom" target="_blank" rel="noopener"><code>xml.dom.pulldom</code></a>：支持构建部分 DOM 树</p>
</li>
<li><p><a href="https://docs.python.org/zh-cn/3.10/library/xml.sax.html#module-xml.sax" target="_blank" rel="noopener"><code>xml.sax</code></a>：SAX2 基类和便利函数</p>
</li>
<li><p><a href="https://docs.python.org/zh-cn/3.10/library/pyexpat.html#module-xml.parsers.expat" target="_blank" rel="noopener"><code>xml.parsers.expat</code></a>：Expat解析器绑定</p>
</li>
</ul>
<h3 id="XML-漏洞"><a href="#XML-漏洞" class="headerlink" title="XML 漏洞"></a>XML 漏洞</h3><p>XML 处理模块对于恶意构造的数据是不安全的。 攻击者可能滥用 XML 功能来执行拒绝服务攻击、访问本地文件、生成与其它计算机的网络连接或绕过防火墙。</p>
<p>下表概述了已知的攻击以及各种模块是否容易受到攻击。</p>
<table>
<thead>
<tr>
<th align="left">种类</th>
<th align="left">sax</th>
<th align="left">etree</th>
<th align="left">minidom</th>
<th align="left">pulldom</th>
<th align="left">xmlrpc</th>
</tr>
</thead>
<tbody><tr>
<td align="left">billion laughs</td>
<td align="left"><strong>Vulnerable</strong> (1)</td>
<td align="left"><strong>Vulnerable</strong> (1)</td>
<td align="left"><strong>Vulnerable</strong> (1)</td>
<td align="left"><strong>Vulnerable</strong> (1)</td>
<td align="left"><strong>Vulnerable</strong> (1)</td>
</tr>
<tr>
<td align="left">quadratic blowup</td>
<td align="left"><strong>Vulnerable</strong> (1)</td>
<td align="left"><strong>Vulnerable</strong> (1)</td>
<td align="left"><strong>Vulnerable</strong> (1)</td>
<td align="left"><strong>Vulnerable</strong> (1)</td>
<td align="left"><strong>Vulnerable</strong> (1)</td>
</tr>
<tr>
<td align="left">external entity expansion</td>
<td align="left">Safe (5)</td>
<td align="left">Safe (2)</td>
<td align="left">Safe (3)</td>
<td align="left">Safe (5)</td>
<td align="left">安全 (4)</td>
</tr>
<tr>
<td align="left"><a href="https://en.wikipedia.org/wiki/Document_type_definition" target="_blank" rel="noopener">DTD</a> retrieval</td>
<td align="left">Safe (5)</td>
<td align="left">安全</td>
<td align="left">安全</td>
<td align="left">Safe (5)</td>
<td align="left">安全</td>
</tr>
<tr>
<td align="left">decompression bomb</td>
<td align="left">安全</td>
<td align="left">安全</td>
<td align="left">安全</td>
<td align="left">安全</td>
<td align="left"><strong>易受攻击</strong></td>
</tr>
</tbody></table>
<ol>
<li>Expat 2.4.1 and newer is not vulnerable to the “billion laughs” and “quadratic blowup” vulnerabilities. Items still listed as vulnerable due to potential reliance on system-provided libraries. Check <code>pyexpat.EXPAT_VERSION</code>.</li>
<li><code>xml.etree.ElementTree</code> 不会扩展外部实体并在实体发生时引发 <code>ParserError</code>。</li>
<li><code>xml.dom.minidom</code> 不会扩展外部实体，只是简单地返回未扩展的实体。</li>
<li><code>xmlrpclib</code> 不扩展外部实体并省略它们。</li>
<li>从 Python 3.7.1 开始，默认情况下不再处理外部通用实体。</li>
</ol>
<p>billion laughs / exponential entity expansion （狂笑/递归实体扩展）</p>
<p><a href="https://en.wikipedia.org/wiki/Billion_laughs" target="_blank" rel="noopener">Billion Laughs</a> 攻击 — 也称为递归实体扩展 — 使用多级嵌套实体。 每个实体多次引用另一个实体，最终实体定义包含一个小字符串。 指数级扩展导致几千 GB 的文本，并消耗大量内存和 CPU 时间。</p>
<p>quadratic blowup entity expansion（二次爆炸实体扩展）</p>
<p>二次爆炸攻击类似于 <a href="https://en.wikipedia.org/wiki/Billion_laughs" target="_blank" rel="noopener">Billion Laughs</a> 攻击，它也滥用实体扩展。 它不是嵌套实体，而是一遍又一遍地重复一个具有几千个字符的大型实体。攻击不如递归情况有效，但它避免触发禁止深度嵌套实体的解析器对策。</p>
<p>external entity expansion</p>
<p>实体声明可以包含的不仅仅是替换文本。 它们还可以指向外部资源或本地文件。 XML 解析器访问资源并将内容嵌入到 XML 文档中。</p>
<p><a href="https://en.wikipedia.org/wiki/Document_type_definition" target="_blank" rel="noopener">DTD</a> retrieval</p>
<p>Python 的一些 XML 库 <code>xml.dom.pulldom</code> 从远程或本地位置检索文档类型定义。 该功能与外部实体扩展问题具有相似的含义。</p>
<p>decompression bomb</p>
<p>Decompression bombs（解压炸弹，又名 <a href="https://en.wikipedia.org/wiki/Zip_bomb" target="_blank" rel="noopener">ZIP bomb</a>）适用于所有可以解析压缩 XML 流（例如 gzip 压缩的 HTTP 流或 LZMA 压缩的文件）的 XML 库。 对于攻击者来说，它可以将传输的数据量减少三个量级或更多。</p>
<p>PyPI上 <a href="https://pypi.org/project/defusedxml/" target="_blank" rel="noopener">defusedxml</a> 的文档包含有关所有已知攻击向量的更多信息以及示例和参考。</p>
<h3 id="defusedxml-包"><a href="#defusedxml-包" class="headerlink" title="defusedxml 包"></a><code>defusedxml</code> 包</h3><p><a href="https://pypi.org/project/defusedxml/" target="_blank" rel="noopener">defusedxml</a> 是一个纯 Python 软件包，它修改了所有标准库 XML 解析器的子类，可以防止任何潜在的恶意操作。 对于解析不受信任的XML数据的任何服务器代码，建议使用此程序包。 该软件包还提供了有关更多 XML 漏洞（如 XPath 注入）的示例漏洞和扩展文档。互联网协议和支持</p>
<h1 id="互联网协议和支持"><a href="#互联网协议和支持" class="headerlink" title="互联网协议和支持"></a>互联网协议和支持</h1><ul>
<li><code>webbrowser</code> —- 方便的 Web 浏览器控制工具<ul>
<li>浏览器控制器对象</li>
</ul>
</li>
<li><code>cgi</code> —- 通用网关接口支持<ul>
<li>概述</li>
<li>使用 cgi 模块</li>
<li>更高层级的接口</li>
<li>函数</li>
<li>对于安全性的关注</li>
<li>在 Unix 系统上安装你的 CGI 脚本</li>
<li>测试你的 CGI 脚本</li>
<li>调试 CGI 脚本</li>
<li>常见问题和解决方案</li>
</ul>
</li>
<li><code>cgitb</code> —- 用于 CGI 脚本的回溯管理器</li>
<li><code>wsgiref</code> —- WSGI 工具和参考实现<ul>
<li><code>wsgiref.util</code> — WSGI 环境工具</li>
<li><code>wsgiref.headers</code> — WSGI 响应标头工具</li>
<li><code>wsgiref.simple_server</code> — 一个简单的 WSGI HTTP 服务器</li>
<li><code>wsgiref.validate</code> —- WSGI 一致性检查器</li>
<li><code>wsgiref.handlers</code> — 服务器/网关基类</li>
<li>例子</li>
</ul>
</li>
<li><code>urllib</code> —- URL 处理模块</li>
<li><code>urllib.request</code> —- 用于打开 URL 的可扩展库<ul>
<li>Request 对象</li>
<li>OpenerDirector 对象</li>
<li>BaseHandler 对象</li>
<li>HTTPRedirectHandler 对象</li>
<li>HTTPCookieProcessor 对象</li>
<li>ProxyHandler 对象</li>
<li>HTTPPasswordMgr 对象</li>
<li>HTTPPasswordMgrWithPriorAuth 对象</li>
<li>AbstractBasicAuthHandler 对象</li>
<li>HTTPBasicAuthHandler 对象</li>
<li>ProxyBasicAuthHandler 对象</li>
<li>AbstractDigestAuthHandler 对象</li>
<li>HTTPDigestAuthHandler 对象</li>
<li>ProxyDigestAuthHandler 对象</li>
<li>HTTPHandler 对象</li>
<li>HTTPSHandler 对象</li>
<li>FileHandler 对象</li>
<li>DataHandler 对象</li>
<li>FTPHandler 对象</li>
<li>CacheFTPHandler 对象</li>
<li>UnknownHandler 对象</li>
<li>HTTPErrorProcessor 对象</li>
<li>例子</li>
<li>已停用的接口</li>
<li><code>urllib.request</code> Restrictions</li>
</ul>
</li>
<li><code>urllib.response</code> —- urllib 使用的 Response 类</li>
<li><code>urllib.parse</code> 用于解析 URL<ul>
<li>URL 解析</li>
<li>解析ASCII编码字节</li>
<li>结构化解析结果</li>
<li>URL Quoting</li>
</ul>
</li>
<li><code>urllib.error</code> —- urllib.request 引发的异常类</li>
<li><code>urllib.robotparser</code> —- robots.txt 语法分析程序</li>
<li><code>http</code> —- HTTP 模块<ul>
<li>HTTP 状态码</li>
</ul>
</li>
<li><code>http.client</code> —- HTTP 协议客户端<ul>
<li>HTTPConnection 对象</li>
<li>HTTPResponse 对象</li>
<li>例子</li>
<li>HTTPMessage 对象</li>
</ul>
</li>
<li><code>ftplib</code> —- FTP 协议客户端<ul>
<li>FTP 对象</li>
<li>FTP_TLS 对象</li>
</ul>
</li>
<li><code>poplib</code> —- POP3 协议客户端<ul>
<li>POP3 对象</li>
<li>POP3 示例</li>
</ul>
</li>
<li><code>imaplib</code> —- IMAP4 协议客户端<ul>
<li>IMAP4 Objects</li>
<li>IMAP4 Example</li>
</ul>
</li>
<li><code>nntplib</code> —- NNTP protocol client<ul>
<li>NNTP Objects<ul>
<li>Attributes</li>
<li>方法</li>
</ul>
</li>
<li>工具函数</li>
</ul>
</li>
<li><code>smtplib</code> —-SMTP协议客户端<ul>
<li>SMTP Objects</li>
<li>SMTP Example</li>
</ul>
</li>
<li><code>smtpd</code> —- SMTP 服务器<ul>
<li>SMTPServer 对象</li>
<li>DebuggingServer 对象</li>
<li>PureProxy对象</li>
<li>MailmanProxy 对象</li>
<li>SMTPChannel 对象</li>
</ul>
</li>
<li><code>telnetlib</code> — Telnet 客户端<ul>
<li>Telnet 对象</li>
<li>Telnet 示例</li>
</ul>
</li>
<li><code>uuid</code> —- UUID objects according to <strong>RFC 4122</strong><ul>
<li>示例</li>
</ul>
</li>
<li><code>socketserver</code> —- A framework for network servers<ul>
<li>Server Creation Notes</li>
<li>Server 对象</li>
<li>Request Handler Objects</li>
<li>例子<ul>
<li><code>socketserver.TCPServer</code> Example</li>
<li><code>socketserver.UDPServer</code> Example</li>
<li>Asynchronous Mixins</li>
</ul>
</li>
</ul>
</li>
<li><code>http.server</code> —- HTTP 服务器</li>
<li><code>http.cookies</code> —- HTTP状态管理<ul>
<li>Cookie 对象</li>
<li>Morsel 对象</li>
<li>示例</li>
</ul>
</li>
<li><code>http.cookiejar</code> —— HTTP 客户端的 Cookie 处理<ul>
<li>CookieJar 和 FileCookieJar 对象</li>
<li>FileCookieJar subclasses and co-operation with web browsers</li>
<li>CookiePolicy 对象</li>
<li>DefaultCookiePolicy 对象</li>
<li>Cookie 对象</li>
<li>例子</li>
</ul>
</li>
<li><code>xmlrpc</code> —- XMLRPC 服务端与客户端模块</li>
<li><code>xmlrpc.client</code> —- XML-RPC 客户端访问<ul>
<li>ServerProxy 对象</li>
<li>DateTime 对象</li>
<li>Binary 对象</li>
<li>Fault 对象</li>
<li>ProtocolError 对象</li>
<li>MultiCall 对象</li>
<li>Convenience Functions</li>
<li>Example of Client Usage</li>
<li>Example of Client and Server Usage</li>
</ul>
</li>
<li><code>xmlrpc.server</code> —- 基本 XML-RPC 服务器<ul>
<li>SimpleXMLRPCServer Objects<ul>
<li>SimpleXMLRPCServer Example</li>
</ul>
</li>
<li>CGIXMLRPCRequestHandler</li>
<li>Documenting XMLRPC server</li>
<li>DocXMLRPCServer Objects</li>
<li>DocCGIXMLRPCRequestHandler</li>
</ul>
</li>
<li><code>ipaddress</code> —- IPv4/IPv6 操作库<ul>
<li>方便的工厂函数</li>
<li>IP 地址<ul>
<li>地址对象</li>
<li>Conversion to Strings and Integers</li>
<li>运算符<ul>
<li>比较运算符</li>
<li>算术运算符</li>
</ul>
</li>
</ul>
</li>
<li>IP网络的定义<ul>
<li>Prefix, net mask and host mask</li>
<li>Network objects</li>
<li>运算符<ul>
<li>Logical operators</li>
<li>迭代</li>
<li>Networks as containers of addresses</li>
</ul>
</li>
</ul>
</li>
<li>Interface objects<ul>
<li>运算符<ul>
<li>Logical operators</li>
</ul>
</li>
</ul>
</li>
<li>Other Module Level Functions</li>
<li>Custom Exceptions</li>
</ul>
</li>
</ul>
<h2 id="webbrowser-—-方便的-Web-浏览器控制工具"><a href="#webbrowser-—-方便的-Web-浏览器控制工具" class="headerlink" title="webbrowser —- 方便的 Web 浏览器控制工具"></a><code>webbrowser</code> —- 方便的 Web 浏览器控制工具</h2><p>源码：<a href="https://github.com/python/cpython/tree/3.10/Lib/webbrowser.py" target="_blank" rel="noopener">Lib/webbrowser.py</a></p>
<hr>
<p><code>webbrowser</code> 模块提供了一个高层级接口，允许向用户显示基于 Web 的文档。 在大多数情况下，只需调用此模块的 <code>open()</code> 函数就可以了。</p>
<p>在 Unix 下，图形浏览器在 X11 下是首选，但如果图形浏览器不可用或 X11 显示不可用，则将使用文本模式浏览器。 如果使用文本模式浏览器，则调用进程将阻塞，直到用户退出浏览器。</p>
<p>如果存在环境变量 <code>BROWSER</code> ，则将其解释为 <code>os.pathsep</code> 分隔的浏览器列表，以便在平台默认值之前尝试。 当列表部分的值包含字符串 <code>％s</code> 时，它被解释为一个文字浏览器命令行，用于替换 <code>％s</code> 的参数 URL ；如果该部分不包含 <code>％s</code>，则它只被解释为要启动的浏览器的名称。</p>
<p>对于非 Unix 平台，或者当 Unix 上有远程浏览器时，控制过程不会等待用户完成浏览器，而是允许远程浏览器在显示界面上维护自己的窗口。 如果 Unix 上没有远程浏览器，控制进程将启动一个新的浏览器并等待。</p>
<p>脚本 <strong>webbrowser</strong> 可以用作模块的命令行界面。它接受一个 URL 作为参数。还接受以下可选参数：<code>-n</code> 如果可能，在新的浏览器窗口中打开 URL ； <code>-t</code> 在新的浏览器页面（“标签”）中打开 URL。这些选择当然是相互排斥的。用法示例:</p>
<pre><code>python -m webbrowser -t "https://www.python.org"</code></pre><p>定义了以下异常：</p>
<p><em>exception</em> <code>webbrowser.Error</code></p>
<p>发生浏览器控件错误时引发异常。</p>
<p>定义了以下函数：</p>
<p><code>webbrowser.open</code>(<em>url</em>, <em>new=0</em>, <em>autoraise=True</em>)</p>
<p>使用默认浏览器显示 <em>url*。 如果 *new</em> 为 0，则尽可能在同一浏览器窗口中打开 <em>url*。 如果 *new</em> 为 1，则尽可能打开新的浏览器窗口。 如果 <em>new</em> 为 2，则尽可能打开新的浏览器页面（“标签”）。 如果 <em>autoraise</em> 为 “True”，则会尽可能置前窗口（请注意，在许多窗口管理器下，无论此变量的设置如何，都会置前窗口）。</p>
<p>请注意，在某些平台上，尝试使用此函数打开文件名，可能会起作用并启动操作系统的关联程序。 但是，这种方式不被支持也不可移植。</p>
<p>使用 <code>url</code> 参数会引发 auditing event <code>webbrowser.open</code> 。</p>
<p><code>webbrowser.open_new</code>(<em>url</em>)</p>
<p>如果可能，在默认浏览器的新窗口中打开 <em>url</em>，否则，在唯一的浏览器窗口中打开 <em>url</em>。</p>
<p><code>webbrowser.open_new_tab</code>(<em>url</em>)</p>
<p>如果可能，在默认浏览器的新页面（“标签”）中打开 <em>url</em>，否则等效于 <code>open_new()</code>。</p>
<p><code>webbrowser.get</code>(<em>using=None</em>)</p>
<p>返回浏览器类型为 <em>using</em> 指定的控制器对象。 如果 <em>using</em> 为 <code>None</code>，则返回适用于调用者环境的默认浏览器的控制器。</p>
<p><code>webbrowser.register</code>(<em>name</em>, <em>constructor</em>, <em>instance=None</em>, <em>**,</em> preferred=False*)</p>
<p>注册 <em>name</em> 浏览器类型。 注册浏览器类型后， <code>get()</code> 函数可以返回该浏览器类型的控制器。 如果没有提供 <em>instance<em>，或者为 <code>None</code>，</em>constructor</em> 将在没有参数的情况下被调用，以在需要时创建实例。 如果提供了 <em>instance</em>，则永远不会调用 <em>constructor</em>，并且可能是 <code>None</code>。</p>
<p>将 <em>preferred</em> 设置为 <code>True</code> 使得这个浏览器成为 <code>get()</code> 不带参数调用的首选结果。 否则，只有在您计划设置 <code>BROWSER</code> 变量，或使用与您声明的处理程序的名称相匹配的非空参数调用 <code>get()</code> 时，此入口点才有用。</p>
<p>在 3.7 版更改: 添加了仅关键字参数 <em>preferred</em>。</p>
<p>预定义了许多浏览器类型。 此表给出了可以传递给 <code>get()</code> 函数的类型名称以及控制器类的相应实例化，这些都在此模块中定义。</p>
<table>
<thead>
<tr>
<th align="left">类型名</th>
<th align="left">类名</th>
<th align="left">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>‘mozilla’</code></td>
<td align="left"><code>Mozilla(‘mozilla’)</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>‘firefox’</code></td>
<td align="left"><code>Mozilla(‘mozilla’)</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>‘netscape’</code></td>
<td align="left"><code>Mozilla(‘netscape’)</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>‘galeon’</code></td>
<td align="left"><code>Galeon(‘galeon’)</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>‘epiphany’</code></td>
<td align="left"><code>Galeon(‘epiphany’)</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>‘skipstone’</code></td>
<td align="left"><code>BackgroundBrowser(‘skipstone’)</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>‘kfmclient’</code></td>
<td align="left"><code>Konqueror()</code></td>
<td align="left">(1)</td>
</tr>
<tr>
<td align="left"><code>‘konqueror’</code></td>
<td align="left"><code>Konqueror()</code></td>
<td align="left">(1)</td>
</tr>
<tr>
<td align="left"><code>‘kfm’</code></td>
<td align="left"><code>Konqueror()</code></td>
<td align="left">(1)</td>
</tr>
<tr>
<td align="left"><code>‘mosaic’</code></td>
<td align="left"><code>BackgroundBrowser(‘mosaic’)</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>‘opera’</code></td>
<td align="left"><code>Opera()</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>‘grail’</code></td>
<td align="left"><code>Grail()</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>‘links’</code></td>
<td align="left"><code>GenericBrowser(‘links’)</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>‘elinks’</code></td>
<td align="left"><code>Elinks(‘elinks’)</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>‘lynx’</code></td>
<td align="left"><code>GenericBrowser(‘lynx’)</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>‘w3m’</code></td>
<td align="left"><code>GenericBrowser(‘w3m’)</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>‘windows-default’</code></td>
<td align="left"><code>WindowsDefault</code></td>
<td align="left">(2)</td>
</tr>
<tr>
<td align="left"><code>‘macosx’</code></td>
<td align="left"><code>MacOSXOSAScript(‘default’)</code></td>
<td align="left">(3)</td>
</tr>
<tr>
<td align="left"><code>‘safari’</code></td>
<td align="left"><code>MacOSXOSAScript(‘safari’)</code></td>
<td align="left">(3)</td>
</tr>
<tr>
<td align="left"><code>‘google-chrome’</code></td>
<td align="left"><code>Chrome(‘google-chrome’)</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>‘chrome’</code></td>
<td align="left"><code>Chrome(‘chrome’)</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>‘chromium’</code></td>
<td align="left"><code>Chromium(‘chromium’)</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>‘chromium-browser’</code></td>
<td align="left"><code>Chromium(‘chromium-browser’)</code></td>
<td align="left"></td>
</tr>
</tbody></table>
<p>注释：</p>
<ol>
<li>“Konqueror” 是 Unix 的 KDE 桌面环境的文件管理器，只有在 KDE 运行时才有意义。 一些可靠地检测 KDE 的方法会很好；仅检查 <code>KDEDIR</code> 变量是不够的。 另请注意，KDE 2的 <strong>konqueror</strong> 命令，会使用名称 “kfm”—-此实现选择运行的 Konqueror 的最佳策略。</li>
<li>仅限 Windows 平台。</li>
<li>Only on macOS platform.</li>
</ol>
<p>3.3 新版功能: 添加了对 Chrome/Chromium 的支持。</p>
<p>以下是一些简单的例子:</p>
<pre class="line-numbers language-python"><code class="language-python">url <span class="token operator">=</span> <span class="token string">'https://docs.python.org/'</span>
<span class="token comment" spellcheck="true"># Open URL in a new tab, if a browser window is already open.</span>
webbrowser<span class="token punctuation">.</span>open_new_tab<span class="token punctuation">(</span>url<span class="token punctuation">)</span>
<span class="token comment" spellcheck="true"># Open URL in new window, raising the window if possible.</span>
webbrowser<span class="token punctuation">.</span>open_new<span class="token punctuation">(</span>url<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="浏览器控制器对象"><a href="#浏览器控制器对象" class="headerlink" title="浏览器控制器对象"></a>浏览器控制器对象</h3><p>浏览器控制器提供三个与模块级便捷函数相同的方法：</p>
<p><code>controller.open</code>(<em>url</em>, <em>new=0</em>, <em>autoraise=True</em>)</p>
<p>使用此控制器处理的浏览器显示 <em>url*。 如果 *new</em> 为 1，则尽可能打开新的浏览器窗口。 如果 <em>new</em> 为 2，则尽可能打开新的浏览器页面（“标签”）。</p>
<p><code>controller.open_new</code>(<em>url</em>)</p>
<p>如果可能，在此控制器处理的浏览器的新窗口中打开 <em>url</em> ，否则，在唯一的浏览器窗口中打开 <em>url</em> 。 别名 <code>open_new()</code>。</p>
<p><code>controller.open_new_tab</code>(<em>url</em>)</p>
<p>如果可能，在此控制器处理的浏览器的新页面（“标签”）中打开 <em>url</em>，否则等效于 <code>open_new()</code>。</p>
<h2 id="cgi-—-通用网关接口支持"><a href="#cgi-—-通用网关接口支持" class="headerlink" title="cgi —- 通用网关接口支持"></a><code>cgi</code> —- 通用网关接口支持</h2><p><strong>源代码：</strong> <a href="https://github.com/python/cpython/tree/3.10/Lib/cgi.py" target="_blank" rel="noopener">Lib/cgi.py</a></p>
<hr>
<p>通用网关接口 (CGI) 脚本的支持模块</p>
<p>本模块定义了一些工具供以 Python 编写的 CGI 脚本使用。</p>
<h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><p>CGI 脚本是由 HTTP 服务器发起调用，通常用来处理通过 HTML <code>&lt;FORM&gt;</code> 或 <code>&lt;ISINDEX&gt;</code> 元素提交的用户输入。</p>
<p>在大多数情况下，CGI 脚本存放在服务器的 <code>cgi-bin</code> 特殊目录下。 HTTP 服务器将有关请求的各种信息（例如客户端的主机名、所请求的 URL、查询字符串以及许多其他内容）放在脚本的 shell 环境中，然后执行脚本，并将脚本的输出发回到客户端。</p>
<p>脚本的输入也会被连接到客户端，并且有时表单数据也会以此方式来读取；在其他时候表单数据会通过 URL 的“查询字符串”部分来传递。 本模块的目标是处理不同的应用场景并向 Python 脚本提供一个更为简单的接口。 它还提供了一些工具为脚本调试提供帮助，而最近增加的还有对通过表单上传文件的支持（如果你的浏览器支持该功能的话）。</p>
<p>CGI 脚本的输出应当由两部分组成，并由一个空行分隔。 前一部分包含一些标头，它们告诉客户端后面会提供何种数据。 生成一个最小化标头部分的 Python 代码如下所示:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Content-Type: text/html"</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># HTML is following</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                             <span class="token comment" spellcheck="true"># blank line, end of headers</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>后一部分通常为 HTML，提供给客户端软件来显示格式良好包含标题的文本、内联图片等内容。 下面是打印一段简单 HTML 的 Python 代码:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"&lt;TITLE>CGI script output&lt;/TITLE>"</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"&lt;H1>This is my first CGI script&lt;/H1>"</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Hello, world!"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h3 id="使用-cgi-模块"><a href="#使用-cgi-模块" class="headerlink" title="使用 cgi 模块"></a>使用 cgi 模块</h3><p>先在开头添加 <code>import cgi</code>。</p>
<p>当你在编写一个新脚本时，请考虑加上这些语句:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> cgitb
cgitb<span class="token punctuation">.</span>enable<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>这会激活一个特殊的异常处理句柄，它将在发生任何错误时将详细错误报告显示到 web 浏览器中。 如果你不希望向你的脚本的用户显示你的程序的内部细节，你可以改为将报告保存到文件中，使用这样的代码即可:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> cgitb
cgitb<span class="token punctuation">.</span>enable<span class="token punctuation">(</span>display<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> logdir<span class="token operator">=</span><span class="token string">"/path/to/logdir"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>在脚本开发期间使用此特性会很有帮助。 <code>cgitb</code> 所产生的报告提供了在追踪程序问题时能为你节省大量时间的信息。 你可以在完成测试你的脚本并确信它能正确工作之后再移除 <code>cgitb</code> 行。</p>
<p>To get at submitted form data, use the <code>FieldStorage</code> class. If the form contains non-ASCII characters, use the <em>encoding</em> keyword parameter set to the value of the encoding defined for the document. It is usually contained in the META tag in the HEAD section of the HTML document or by the <em>Content-Type</em> header. This reads the form contents from the standard input or the environment (depending on the value of various environment variables set according to the CGI standard). Since it may consume standard input, it should be instantiated only once.</p>
<p><code>FieldStorage</code> 实例可以像 Python 字典一样来检索。 它允许通过 <code>in</code> 运算符进行成员检测，也支持标准字典方法 <code>keys()</code> 和内置函数 <code>len()</code>。 包含空字符串的表单字段会被忽略而不会出现在字典中；要保留这样的值，请在创建 <code>FieldStorage</code> 实例时为可选的 <em>keep_blank_values</em> 关键字形参提供一个真值。</p>
<p>举例来说，下面的代码（假定 <em>Content-Type</em> 标头和空行已经被打印）会检查字段 <code>name</code> 和 <code>addr</code> 是否均被设为非空字符串:</p>
<pre class="line-numbers language-python"><code class="language-python">form <span class="token operator">=</span> cgi<span class="token punctuation">.</span>FieldStorage<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">if</span> <span class="token string">"name"</span> <span class="token operator">not</span> <span class="token keyword">in</span> form <span class="token operator">or</span> <span class="token string">"addr"</span> <span class="token operator">not</span> <span class="token keyword">in</span> form<span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"&lt;H1>Error&lt;/H1>"</span><span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Please fill in the name and addr fields."</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"&lt;p>name:"</span><span class="token punctuation">,</span> form<span class="token punctuation">[</span><span class="token string">"name"</span><span class="token punctuation">]</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"&lt;p>addr:"</span><span class="token punctuation">,</span> form<span class="token punctuation">[</span><span class="token string">"addr"</span><span class="token punctuation">]</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>further form processing here<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在这里的字段通过 <code>form[key]</code> 来访问，它们本身就是 <code>FieldStorage</code> (或 <code>MiniFieldStorage</code>，取决于表单的编码格式) 的实例。 实例的 <code>value</code> 属性会产生字段的字符串值。 <code>getvalue()</code> 方法直接返回这个字符串；它还接受可选的第二个参数作为当请求的键不存在时要返回的默认值。</p>
<p>如果提交的表单数据包含一个以上的同名字段，由 <code>form[key]</code> 所提取的对象将不是一个 <code>FieldStorage</code> 或 <code>MiniFieldStorage</code> 实例而是由这种实例组成的列表。 类似地，在这种情况下，<code>form.getvalue(key)</code> 将会返回一个字符串列表。 如果你预计到这种可能性（当你的 HTML 表单包含多个同名字段时），请使用 <code>getlist()</code> 方法，它总是返回一个值的列表（这样你就不需要对只有单个项的情况进行特别处理）。 例如，这段代码拼接了任意数量的 username 字段，以逗号进行分隔:</p>
<pre class="line-numbers language-python"><code class="language-python">value <span class="token operator">=</span> form<span class="token punctuation">.</span>getlist<span class="token punctuation">(</span><span class="token string">"username"</span><span class="token punctuation">)</span>
usernames <span class="token operator">=</span> <span class="token string">","</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>value<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>如果一个字段是代表上传的文件，请通过 <code>value</code> 属性访问该值或是通过 <code>getvalue()</code> 方法以字节形式将整个文件读入内存。 这可能不是你想要的结果。 你可以通过测试 <code>filename</code> 属性或 <code>file</code> 属性来检测上传的文件。 然后你可以从 <code>file</code> 属性读取数据，直到它作为 <code>FieldStorage</code> 实例的垃圾回收的一部分被自动关闭 (<code>read()</code> 和 <code>readline()</code> 方法将返回字节数据):</p>
<pre class="line-numbers language-python"><code class="language-python">fileitem <span class="token operator">=</span> form<span class="token punctuation">[</span><span class="token string">"userfile"</span><span class="token punctuation">]</span>
<span class="token keyword">if</span> fileitem<span class="token punctuation">.</span>file<span class="token punctuation">:</span>
    <span class="token comment" spellcheck="true"># It's an uploaded file; count lines</span>
    linecount <span class="token operator">=</span> <span class="token number">0</span>
    <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>
        line <span class="token operator">=</span> fileitem<span class="token punctuation">.</span>file<span class="token punctuation">.</span>readline<span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">if</span> <span class="token operator">not</span> line<span class="token punctuation">:</span> <span class="token keyword">break</span>
        linecount <span class="token operator">=</span> linecount <span class="token operator">+</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>FieldStorage</code> 对象还支持在 <code>with</code> 语句中使用，该语句结束时将自动关闭它们。</p>
<p>如果在获取上传文件的内容时遇到错误（例如，当用户点击回退或取消按钮中断表单提交时）该字段中对象的 <code>done</code> 属性值将被设为 -1。</p>
<p>文件上传标准草案考虑到了从一个字段上传多个文件的可能性（使用递归的 <em>multipart/** 编码格式）。 当这种情况发生时，该条目将是一个类似字典的 <code>FieldStorage</code> 条目。 这可以通过检测它的 <code>type</code> 属性来确定，该属性应当是</em> multipart/form-data <em>(或者可能是匹配</em> multipart/** 的其他 MIME 类型)。 在这种情况下，它可以像最高层级的表单对象一样被递归地迭代处理。</p>
<p>当一个表单按“旧”格式提交时（即以查询字符串或是单个 <em>application/x-www-form-urlencoded</em> 类型的数据部分的形式），这些条目实际上将是 <code>MiniFieldStorage</code> 类的实例。 在这种情况下，<code>list</code>, <code>file</code> 和 <code>filename</code> 属性将总是为 <code>None</code>。</p>
<p>通过 POST 方式提交并且也带有查询字符串的表单将同时包含 <code>FieldStorage</code> 和 <code>MiniFieldStorage</code> 条目。</p>
<p>在 3.4 版更改: <code>file</code> 属性会在创建 <code>FieldStorage</code> 实例的垃圾回收操作中被自动关闭。</p>
<p>在 3.5 版更改: 为 <code>FieldStorage</code> 类增加了上下文管理协议支持。</p>
<h3 id="更高层级的接口"><a href="#更高层级的接口" class="headerlink" title="更高层级的接口"></a>更高层级的接口</h3><p>前面的部分解释了如何使用 <code>FieldStorage</code> 类来读取 CGI 表单数据。 本部分则会描述一个更高层级的接口，它被添加到此类中以允许人们以更为可读和自然的方式行事。 这个接口并不会完全取代前面的部分所描述的技巧 —- 例如它们在高效处理文件上传时仍然很有用处。</p>
<p>此接口由两个简单的方法组成。 你可以使用这两个方法以通用的方式处理表单数据，而无需担心在一个名称下提交的值是只有一个还是有多个。</p>
<p>在前面的部分中，你已学会当你预期用户在一个名称下提交超过一个值的时候编写以下代码:</p>
<pre class="line-numbers language-python"><code class="language-python">item <span class="token operator">=</span> form<span class="token punctuation">.</span>getvalue<span class="token punctuation">(</span><span class="token string">"item"</span><span class="token punctuation">)</span>
<span class="token keyword">if</span> isinstance<span class="token punctuation">(</span>item<span class="token punctuation">,</span> list<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token comment" spellcheck="true"># The user is requesting more than one item.</span>
<span class="token keyword">else</span><span class="token punctuation">:</span>
    <span class="token comment" spellcheck="true"># The user is requesting only one item.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这种情况很常见，例如当一个表单包含具有相同名称的一组复选框的时候:</p>
<pre><code>&lt;input type="checkbox" name="item" value="1" /&gt;
&lt;input type="checkbox" name="item" value="2" /&gt;</code></pre><p>但是在多数情况下，一个表单中的一个特定名称只对应一个表单控件。 因此你可能会编写包含以下代码的脚本:</p>
<pre class="line-numbers language-python"><code class="language-python">user <span class="token operator">=</span> form<span class="token punctuation">.</span>getvalue<span class="token punctuation">(</span><span class="token string">"user"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>upper<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>这段代码的问题在于你绝不能预期客户端会向你的脚本提供合法的输入。 举例来说，如果一个好奇的用户向查询字符串添加了另一个 <code>user=foo</code> 对，则该脚本将会崩溃，因为在这种情况下 <code>getvalue("user")</code> 方法调用将返回一个列表而不是字符串。 在一个列表上调用 <code>upper()</code> 方法是不合法的（因为列表并没有这个方法）因而会引发 <code>AttributeError</code> 异常。</p>
<p>因此，读取表单数据值的正确方式应当总是使用检查所获取的值是单一值还是值列表的代码。 这很麻烦并且会使脚本缺乏可读性。</p>
<p>一种更便捷的方式是使用这个更高层级接口所提供的 <code>getfirst()</code> 和 <code>getlist()</code> 方法。</p>
<p><code>FieldStorage.getfirst</code>(<em>name</em>, <em>default=None</em>)</p>
<p>此方法总是只返回与表单字段 <em>name</em> 相关联的单一值。 此方法在同一名称下提交了多个值的情况下将仅返回第一个值。 请注意所接收的值顺序在不同浏览器上可能发生变化因而是不确定的。如果指定的表单字段或值不存在则此方法将返回可选形参 <em>default</em> 所指定的值。 如果未指定此形参则默认值为 <code>None</code>。</p>
<p><code>FieldStorage.getlist</code>(<em>name</em>)</p>
<p>此方法总是返回与表单字段 <em>name</em> 相关联的值列表。 如果 <em>name</em> 指定的表单字段或值不存在则此方法将返回一个空列表。 如果指定的表单字段只包含一个值则它将返回只有一项的列表。</p>
<p>使用这两个方法你将能写出优雅简洁的代码:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> cgi
form <span class="token operator">=</span> cgi<span class="token punctuation">.</span>FieldStorage<span class="token punctuation">(</span><span class="token punctuation">)</span>
user <span class="token operator">=</span> form<span class="token punctuation">.</span>getfirst<span class="token punctuation">(</span><span class="token string">"user"</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">.</span>upper<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># This way it's safe.</span>
<span class="token keyword">for</span> item <span class="token keyword">in</span> form<span class="token punctuation">.</span>getlist<span class="token punctuation">(</span><span class="token string">"item"</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    do_something<span class="token punctuation">(</span>item<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="函数-1"><a href="#函数-1" class="headerlink" title="函数"></a>函数</h3><p>这些函数在你想要更多控制，或者如果你想要应用一些此模块中在其他场景下实现的算法时很有用处。</p>
<p><code>cgi.parse</code>(<em>fp=None</em>, <em>environ=os.environ</em>, <em>keep_blank_values=False</em>, <em>strict_parsing=False</em>, <em>separator=’&amp;’</em>)</p>
<p>在环境中或从某个文件中解析一个查询 (文件默认为 <code>sys.stdin</code>)。 <em>keep_blank_values</em>, <em>strict_parsing</em> 和 <em>separator</em> 形参会被原样传给 <code>urllib.parse.parse_qs()</code>。</p>
<p><code>cgi.parse_multipart</code>(<em>fp</em>, <em>pdict</em>, <em>encoding=’utf-8’</em>, <em>errors=’replace’</em>, <em>separator=’&amp;’</em>)</p>
<p>解析 <em>multipart/form-data</em> 类型（用于文件上传）的输入。 参数中 <em>fp</em> 为输入文件，<em>pdict</em> 为包含 <em>Content-Type</em> 标头中的其他形参的字典，<em>encoding</em> 为请求的编码格式。</p>
<p>像 <code>urllib.parse.parse_qs()</code> 那样返回一个字典：其中的键为字段名称，值为对应字段的值列表。 对于非文件字段，其值均为字符串列表。</p>
<p>这很容易使用，但如果你预期要上传巨量字节数据时就不太适合了 —- 在这种情况下，请改用更为灵活的 <code>FieldStorage</code> 类。</p>
<p>在 3.7 版更改: 增加了 <em>encoding</em> 和 <em>errors</em> 形参。 对于非文件字段，其值现在为字符串列表而非字节串列表。</p>
<p>在 3.10 版更改: 增加了 <em>separator</em> 形参。</p>
<p><code>cgi.parse_header</code>(<em>string</em>)</p>
<p>将一个 MIME 标头 (例如 <em>Content-Type</em>) 解析为一个主值和一个参数字典。</p>
<p><code>cgi.test</code>()</p>
<p>对 CGI 执行健壮性检测，适于作为主程序。 写入最小化的 HTTP 标头并以 HTML 格式来格式化提供给脚本的所有信息。</p>
<p><code>cgi.print_environ</code>()</p>
<p>以 HTML 格式来格式化 shell 环境。</p>
<p><code>cgi.print_form</code>(<em>form</em>)</p>
<p>以 HTML 格式来格式化表单。</p>
<p><code>cgi.print_directory</code>()</p>
<p>以 HTML 格式来格式化当前目录。</p>
<p><code>cgi.print_environ_usage</code>()</p>
<p>以 HTML 格式打印有用的环境变量列表（供 CGI 使用）。</p>
<h3 id="对于安全性的关注"><a href="#对于安全性的关注" class="headerlink" title="对于安全性的关注"></a>对于安全性的关注</h3><p>有一条重要的规则：如果你发起调用一个外部程序（通过 <code>os.system()</code>, <code>os.popen()</code> 或其他具有类似功能的函数），需要非常确定你不会把从客户端接收的任意字符串直接传给 shell。 这是一个著名的安全漏洞，网络中聪明的黑客可以通过它来利用容易上当的 CGI 脚本发起调用任何 shell 命令。 即便 URL 的一部分或字段名称也是不可信任的，因为请求并不一定是来自你的表单！</p>
<p>为了安全起见，如果你必须将从表单获取的字符串传给 shell 命令，你应当确保该字符串仅包含字母数字类字符、连字符、下划线和句点。</p>
<h3 id="在-Unix-系统上安装你的-CGI-脚本"><a href="#在-Unix-系统上安装你的-CGI-脚本" class="headerlink" title="在 Unix 系统上安装你的 CGI 脚本"></a>在 Unix 系统上安装你的 CGI 脚本</h3><p>请阅读你的 HTTP 服务器的文档并咨询你所用系统的管理员来找到 CGI 脚本应当安装到哪个目录；通常是服务器目录树中的 <code>cgi-bin</code> 目录。</p>
<p>请确保你的脚本可被“其他人”读取和执行；Unix 文件模式应为八进制数 <code>0o755</code> (使用 <code>chmod 0755 filename</code>)。 请确保脚本的第一行包含 <code>#!</code> 且位置是从第 1 列开始，后面带有 Python 解释器的路径名，例如:</p>
<pre><code>#!/usr/local/bin/python</code></pre><p>请确保该 Python 解释器存在并且可被“其他人”执行。</p>
<p>请确保你的脚本需要读取或写入的任何文件都分别是“其他人”可读取或可写入的 —- 它们的模式应为可读取 <code>0o644</code> 或可写入 <code>0o666</code>。 这是因为出于安全理由，HTTP 服务器是作为没有任何特殊权限的 “nobody” 用户来运行脚本的。 它只能读取（写入、执行）任何人都能读取（写入、执行）的文件。 执行时的当前目录（通常为服务器的 cgi-bin 目录）和环境变量集合也与你在登录时所得到的不同。 特别地，不可依赖于 shell 的可执行文件搜索路径 (<code>PATH</code>) 或 Python 模块搜索路径 (<code>PYTHONPATH</code>) 的任何相关设置。</p>
<p>如果你需要从 Python 的默认模块搜索路径之外的目录载入模块，你可以在导入其他模块之前在你的脚本中改变路径。 例如:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> sys
sys<span class="token punctuation">.</span>path<span class="token punctuation">.</span>insert<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">"/usr/home/joe/lib/python"</span><span class="token punctuation">)</span>
sys<span class="token punctuation">.</span>path<span class="token punctuation">.</span>insert<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">"/usr/local/lib/python"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>（在此方式下，最后插入的目录将最先被搜索！）</p>
<p>针对非 Unix 系统的指导会有所变化；请查看你的 HTTP 服务器的文档（通常会有关于 CGI 脚本的部分）。</p>
<h3 id="测试你的-CGI-脚本"><a href="#测试你的-CGI-脚本" class="headerlink" title="测试你的 CGI 脚本"></a>测试你的 CGI 脚本</h3><p>很不幸，当你在命令行中尝试 CGI 脚本时它通常会无法运行，而能在命令行中完美运行的脚本则可能会在运行于服务器时神秘地失败。 但有一个理由使你仍然应当在命令行中测试你的脚本：如果它包含语法错误，Python 解释器将根本不会执行它，而 HTTP 服务器将很可能向客户端发送令人费解的错误信息。</p>
<p>假定你的脚本没有语法错误，但它仍然无法起作用，你将别无选择，只能继续阅读下一节。</p>
<h3 id="调试-CGI-脚本"><a href="#调试-CGI-脚本" class="headerlink" title="调试 CGI 脚本"></a>调试 CGI 脚本</h3><p>首先，请检查是否有安装上的小错误 —- 仔细阅读上面关于安装 CGI 脚本的部分可以使你节省大量时间。 如果你不确定你是否正确理解了安装过程，请尝试将此模块 (<code>cgi.py</code>) 的副本作为 CGI 脚本安装。 当作为脚本被发起调用时，该文件将以 HTML 格式转储其环境和表单内容。 请给它赋予正确的模式等，并向它发送一个请求。 如果它是安装在标准的 <code>cgi-bin</code> 目录下，应该可以通过在你的浏览器中输入表单的 URL 来向它发送请求。</p>
<pre><code>http://yourhostname/cgi-bin/cgi.py?name=Joe+Blow&amp;addr=At+Home</code></pre><p>如果此操作给出类型为 404 的错误，说明服务器找不到此脚本 — 也许你需要将它安装到不同的目录。 如果它给出另一种错误，说明存在安装问题，你应当解决此问题才能继续操作。 如果你得到一个格式良好的环境和表单内容清单（在这个例子中，应当会列出的有字段 “addr” 值为 “At Home” 以及 “name” 值为 “Joe Blow”），则说明 <code>cgi.py</code> 脚本已正确安装。 如果你为自己的脚本执行了同样的过程，现在你应该能够调试它了。</p>
<p>下一步骤可以是在你的脚本中调用 <code>cgi</code> 模块的 <code>test()</code> 函数：用这一条语句替换它的主代码</p>
<pre class="line-numbers language-python"><code class="language-python">cgi<span class="token punctuation">.</span>test<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>这将产生从安装 <code>cgi.py</code> 文件本身所得到的相同结果。</p>
<p>当某个常规 Python 脚本触发了未处理的异常，（无论出于什么原因：模块名称出错、文件无法打开等)，Python 解释器就会打印出一条完整的跟踪信息并退出。在 CGI 脚本触发异常时，Python 解释器依然会如此，但最有可能的是，跟踪信息只会停留在某个 HTTP 服务日志文件中，或者被完全丢弃。</p>
<p>幸运的是，只要执行 <em>某些</em> 代码，就可以利用 <code>cgitb</code> 模块将跟踪信息发送给浏览器。将以下几行代码加到代码顶部：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> cgitb
cgitb<span class="token punctuation">.</span>enable<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>然后再运行一下看；发生问题时应能看到详细的报告，或许能让崩溃的原因更清晰一些。</p>
<p>如果怀疑是 <code>cgitb</code> 模块导入的问题，可以采用一个功能更强的方法（只用到内置模块）：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> sys
sys<span class="token punctuation">.</span>stderr <span class="token operator">=</span> sys<span class="token punctuation">.</span>stdout
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Content-Type: text/plain"</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>your code here<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这得靠 Python 解释器来打印跟踪信息。输出的类型为纯文本，不经过任何 HTML 处理。如果代码正常，则客户端会显示原有的 HTML。如果触发了异常，很可能在输出前两行后会显示一条跟踪信息。因为不会继续进行 HTML 解析，所以跟踪信息肯定能被读到。</p>
<h3 id="常见问题和解决方案"><a href="#常见问题和解决方案" class="headerlink" title="常见问题和解决方案"></a>常见问题和解决方案</h3><ul>
<li>大部分 HTTP 服务器会对 CGI 脚本的输出进行缓存，等脚本执行完毕再行输出。这意味着在脚本运行时，不可能在客户端屏幕上显示出进度情况。</li>
<li>请查看上述安装说明。</li>
<li>请查看 HTTP 服务器的日志文件。（在另一个单独窗口中执行 <code>tail -f logfile</code> 可能会很有用！）</li>
<li>一定要先检查脚本是否有语法错误，做法类似：<code>python script.py</code> 。</li>
<li>如果脚本没有语法错误，试着在脚本的顶部添加 <code>import cgitb; cgitb.enable()</code>。</li>
<li>当调用外部程序时，要确保其可被读取。通常这意味着采用绝对路径名——— 在 CGI 脚本中， <code>PATH</code> 的值通常没什么用。</li>
<li>在读写外部文件时，要确保其能被 CGI 脚本归属的用户读写：通常是运行网络服务的用户，或由网络服务的 <code>suexec</code> 功能明确指定的一些用户。</li>
<li>不要试图给 CGI 脚本赋予 set-uid 模式。这在大多数系统上都行不通，出于安全考虑也不应如此。</li>
</ul>
<h2 id="cgitb-—-用于-CGI-脚本的回溯管理器"><a href="#cgitb-—-用于-CGI-脚本的回溯管理器" class="headerlink" title="cgitb —- 用于 CGI 脚本的回溯管理器"></a><code>cgitb</code> —- 用于 CGI 脚本的回溯管理器</h2><p><strong>源代码:</strong> <a href="https://github.com/python/cpython/tree/3.10/Lib/cgitb.py" target="_blank" rel="noopener">Lib/cgitb.py</a></p>
<hr>
<p><code>cgitb</code> 模块提供了用于 Python 脚本的特殊异常处理程序。 （这个名称有一点误导性。 它最初是设计用来显示 HTML 格式的 CGI 脚本详细回溯信息。 但后来被一般化为也可显示纯文本格式的回溯信息。） 激活这个模块之后，如果发生了未被捕获的异常，将会显示详细的已格式化的报告。 报告显示内容包括每个层级的源代码摘录，还有当前正在运行的函数的参数和局部变量值，以帮助你调试问题。 你也可以选择将此信息保存至文件而不是将其发送至浏览器。</p>
<p>要启用此特性，只需简单地将此代码添加到你的 CGI 脚本的最顶端:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> cgitb
cgitb<span class="token punctuation">.</span>enable<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><code>enable()</code> 函数的选项可以控制是将报告显示在浏览器中，还是将报告记录到文件供以后进行分析。</p>
<p><code>cgitb.enable</code>(<em>display=1</em>, <em>logdir=None</em>, <em>context=5</em>, <em>format=’html’</em>)</p>
<p>此函数可通过设置 <code>sys.excepthook</code> 的值以使 <code>cgitb</code> 模块接管解释器默认的异常处理机制。</p>
<p>可选参数 <em>display</em> 默认为 <code>1</code> 并可被设为 <code>0</code> 来停止将回溯发送至浏览器。 如果给出了参数 <em>logdir*，则回溯会被写入文件。 *logdir</em> 的值应当是一个用于存放所写入文件的目录。 可选参数 <em>context</em> 是要在回溯中的当前源代码行前后显示的上下文行数；默认为 <code>5</code>。 如果可选参数 <em>format</em> 为 <code>"html"</code>，输出将为 HTML 格式。 任何其它值都会强制启用纯文本输出。 默认取值为 <code>"html"</code>。</p>
<p><code>cgitb.text</code>(<em>info</em>, <em>context=5</em>)</p>
<p>此函数用于处理 <em>info</em> (一个包含 <code>sys.exc_info()</code> 返回结果的 3 元组) 所描述的异常，将其回溯格式化为文本并将结果作为字符串返回。 可选参数 <em>context</em> 是要在回溯中的当前源码行前后显示的上下文行数；默认为 <code>5</code>。</p>
<p><code>cgitb.html</code>(<em>info</em>, <em>context=5</em>)</p>
<p>此函数用于处理 <em>info</em> (一个包含 <code>sys.exc_info()</code> 返回结果的 3 元组) 所描述的异常，将其回溯格式化为 HTML 并将结果作为字符串返回。 可选参数 <em>context</em> 是要在回溯中的当前源码行前后显示的上下文行数；默认为 <code>5</code>。</p>
<p><code>cgitb.handler</code>(<em>info=None</em>)</p>
<p>此函数使用默认设置处理异常（即在浏览器中显示报告，但不记录到文件）。 当你捕获了一个异常并希望使用 <code>cgitb</code> 来报告它时可以使用此函数。 可选的 <em>info</em> 参数应为一个包含异常类型，异常值和回溯对象的 3 元组，与 <code>sys.exc_info()</code> 所返回的元组完全一致。 如果未提供 <em>info</em> 参数，则会从 <code>sys.exc_info()</code> 获取当前异常。</p>
<h2 id="wsgiref-—-WSGI-工具和参考实现"><a href="#wsgiref-—-WSGI-工具和参考实现" class="headerlink" title="wsgiref —- WSGI 工具和参考实现"></a><code>wsgiref</code> —- WSGI 工具和参考实现</h2><p>Web 服务器网关接口（WSGI）是 Web 服务器软件和用 Python 编写的 Web 应用程序之间的标准接口。 具有标准接口能够让支持 WSGI 的应用程序与多种不同的 Web 服务器配合使用。</p>
<p>只有 Web 服务器和编程框架的开发者才需要了解 WSGI 设计的每个细节和边界情况。 你不需要了解 WSGI 的每个细节而只需要安装一个 WSGI 应用程序或编写使用现有框架的 Web 应用程序。</p>
<p><code>wsgiref</code> 是一个 WSGI 规范的参考实现，可被用于将 WSGI 支持添加到 Web 服务器或框架中。 它提供了操作 WSGI 环境变量和响应标头的工具，实现 WSGI 服务器的基类，一个可部署 WSGI 应用程序的演示性 HTTP 服务器，以及一个用于检查 WSGI 服务器和应用程序是否符合 WSGI 规范的验证工具 (<a href="https://www.python.org/dev/peps/pep-3333" target="_blank" rel="noopener"><strong>PEP 3333</strong></a>)。</p>
<p>参看 <a href="https://wsgi.readthedocs.io/" target="_blank" rel="noopener">wsgi.readthedocs.io</a> 获取有关 WSGI 的更多信息，以及教程和其他资源的链接。</p>
<h3 id="wsgiref-util-—-WSGI-环境工具"><a href="#wsgiref-util-—-WSGI-环境工具" class="headerlink" title="wsgiref.util — WSGI 环境工具"></a><code>wsgiref.util</code> — WSGI 环境工具</h3><p>本模块提供了多种工具配合 WSGI 环境使用。 WSGI 环境就是一个包含 <a href="https://www.python.org/dev/peps/pep-3333" target="_blank" rel="noopener"><strong>PEP 3333</strong></a> 所描述的 HTTP 请求变量的目录。 所有接受 <em>environ</em> 形参的函数都会预期被得到一个符合 WSGI 规范的目录；请参阅 <a href="https://www.python.org/dev/peps/pep-3333" target="_blank" rel="noopener"><strong>PEP 3333</strong></a> 来了解相关规范的细节。</p>
<p><code>wsgiref.util.guess_scheme</code>(<em>environ</em>)</p>
<p>返回对于 <code>wsgi.url_scheme</code> 应为 “http” 还是 “https” 的猜测，具体方式是在 <em>environ</em> 中检查 <code>HTTPS</code> 环境变量。 返回值是一个字符串。</p>
<p>此函数适用于创建一个包装了 CGI 或 CGI 类协议例如 FastCGI 的网关。 通常，提供这种协议的服务器将包括一个 <code>HTTPS</code> 变量并会在通过 SSL 接收请求时将其值设为 “1”, “yes” 或 “on”。 这样，此函数会在找到上述值时返回 “https”，否则返回 “http”。</p>
<p><code>wsgiref.util.request_uri</code>(<em>environ</em>, <em>include_query=True</em>)</p>
<p>使用 <a href="https://www.python.org/dev/peps/pep-3333" target="_blank" rel="noopener"><strong>PEP 3333</strong></a> 的 “URL Reconstruction” 一节中的算法返回完整的请求 URL，可能包括查询字符串。 如果 <em>include_query</em> 为假值，则结果 URI 中将不包括查询字符串。</p>
<p><code>wsgiref.util.application_uri</code>(<em>environ</em>)</p>
<p>类似于 <code>request_uri()</code>，区别在于 <code>PATH_INFO</code> 和 <code>QUERY_STRING</code> 变量会被忽略。 结果为请求所指定的应用程序对象的基准 URI。</p>
<p><code>wsgiref.util.shift_path_info</code>(<em>environ</em>)</p>
<p>将单个名称从 <code>PATH_INFO</code> 变换为 <code>SCRIPT_NAME</code> 并返回该名称。 <em>environ</em> 目录将被原地 <em>修改</em>；如果你需要保留原始 <code>PATH_INFO</code> 或 <code>SCRIPT_NAME</code> 不变请使用一个副本。</p>
<p>如果 <code>PATH_INFO</code> 中没有剩余的路径节，则返回 <code>None</code>。</p>
<p>通常，此例程被用来处理请求 URI 路径的每个部分，比如说将路径当作是一系列字典键。 此例程会修改传入的环境以使其适合发起调用位于目标 URI 上的其他 WSGI 应用程序，如果有一个 WSGI 应用程序位于 <code>/foo</code>，而请求 URI 路径为 <code>/foo/bar/baz</code>，且位于 <code>/foo</code> 的 WSGI 应用程序调用了 <code>shift_path_info()</code>，它将获得字符串 “bar”，而环境将被更新以适合传递给位于 <code>/foo/bar</code> 的 WSGI 应用程序。 也就是说，<code>SCRIPT_NAME</code> 将由 <code>/foo</code> 变为 <code>/foo/bar</code>，而 <code>PATH_INFO</code> 将由 <code>/bar/baz</code> 变为 <code>/baz</code>。</p>
<p>当 <code>PATH_INFO</code> 只是 “/“ 时，此例程会返回一个空字符串并在 <code>SCRIPT_NAME</code> 末尾添加一个斜杠，虽然空的路径节通常会被忽略，并且 <code>SCRIPT_NAME</code> 通常也不以斜杠作为结束。 此行为是有意为之的，用来确保应用程序在使用此例程执行对象遍历时能区分以 <code>/x</code> 结束的和以 <code>/x/</code> 结束的 URI。</p>
<p><code>wsgiref.util.setup_testing_defaults</code>(<em>environ</em>)</p>
<p>以简短的默认值更新 <em>environ</em> 用于测试目的。</p>
<p>此例程会添加 WSGI 所需要的各种参数，包括 <code>HTTP_HOST</code>, <code>SERVER_NAME</code>, <code>SERVER_PORT</code>, <code>REQUEST_METHOD</code>, <code>SCRIPT_NAME</code>, <code>PATH_INFO</code> 以及 <a href="https://www.python.org/dev/peps/pep-3333" target="_blank" rel="noopener"><strong>PEP 3333</strong></a> 中定义的所有 <code>wsgi.*</code> 变量。 它只提供默认值，而不会替换这些变量的现有设置。</p>
<p>此例程的目的是让 WSGI 服务器的单元测试以及应用程序设置测试环境更为容易。 它不应该被实际的 WSGI 服务器或应用程序所使用，因为它用的是假数据！</p>
<p>用法示例:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> wsgiref<span class="token punctuation">.</span>util <span class="token keyword">import</span> setup_testing_defaults
<span class="token keyword">from</span> wsgiref<span class="token punctuation">.</span>simple_server <span class="token keyword">import</span> make_server
<span class="token comment" spellcheck="true"># A relatively simple WSGI application. It's going to print out the</span>
<span class="token comment" spellcheck="true"># environment dictionary after being updated by setup_testing_defaults</span>
<span class="token keyword">def</span> <span class="token function">simple_app</span><span class="token punctuation">(</span>environ<span class="token punctuation">,</span> start_response<span class="token punctuation">)</span><span class="token punctuation">:</span>
    setup_testing_defaults<span class="token punctuation">(</span>environ<span class="token punctuation">)</span>
    status <span class="token operator">=</span> <span class="token string">'200 OK'</span>
    headers <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token string">'Content-type'</span><span class="token punctuation">,</span> <span class="token string">'text/plain; charset=utf-8'</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
    start_response<span class="token punctuation">(</span>status<span class="token punctuation">,</span> headers<span class="token punctuation">)</span>
    ret <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token string">"%s: %s\n"</span> <span class="token operator">%</span> <span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token string">"utf-8"</span><span class="token punctuation">)</span>
           <span class="token keyword">for</span> key<span class="token punctuation">,</span> value <span class="token keyword">in</span> environ<span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
    <span class="token keyword">return</span> ret
<span class="token keyword">with</span> make_server<span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">,</span> <span class="token number">8000</span><span class="token punctuation">,</span> simple_app<span class="token punctuation">)</span> <span class="token keyword">as</span> httpd<span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Serving on port 8000..."</span><span class="token punctuation">)</span>
    httpd<span class="token punctuation">.</span>serve_forever<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>除了上述的环境函数，<code>wsgiref.util</code> 模块还提供了以下辅助工具:</p>
<p><code>wsgiref.util.is_hop_by_hop</code>(<em>header_name</em>)</p>
<p>如果 ‘header_name’ 是 <a href="https://tools.ietf.org/html/rfc2616.html" target="_blank" rel="noopener"><strong>RFC 2616</strong></a> 所定义的 HTTP/1.1 “Hop-by-Hop” 标头则返回 <code>True</code>。</p>
<p><em>class</em> <code>wsgiref.util.FileWrapper</code>(<em>filelike</em>, <em>blksize=8192</em>)</p>
<p>一个将文件类对象转换为 iterator 的包装器。 结果对象同时支持 <code>__getitem__()</code> 和 <code>__iter__()</code> 迭代形式，以便兼容 Python 2.1 和 Jython。 当对象被迭代时，可选的 <em>blksize</em> 形参将被反复地传给 <em>filelike</em> 对象的 <code>read()</code> 方法以获取字节串并输出。 当 <code>read()</code> 返回空字节串时，迭代将结束并不可再恢复。</p>
<p>如果 <em>filelike</em> 具有 <code>close()</code> 方法，返回的对象也将具有 <code>close()</code> 方法，并且它将在被调用时发起调用 <em>filelike</em> 对象的 <code>close()</code> 方法。</p>
<p>用法示例:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> io <span class="token keyword">import</span> StringIO
<span class="token keyword">from</span> wsgiref<span class="token punctuation">.</span>util <span class="token keyword">import</span> FileWrapper
<span class="token comment" spellcheck="true"># We're using a StringIO-buffer for as the file-like object</span>
filelike <span class="token operator">=</span> StringIO<span class="token punctuation">(</span><span class="token string">"This is an example file-like object"</span><span class="token operator">*</span><span class="token number">10</span><span class="token punctuation">)</span>
wrapper <span class="token operator">=</span> FileWrapper<span class="token punctuation">(</span>filelike<span class="token punctuation">,</span> blksize<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">)</span>
<span class="token keyword">for</span> chunk <span class="token keyword">in</span> wrapper<span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>chunk<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>3.8 版后已移除: 对 <code>序列协议</code> 的支持已被弃用。</p>
<h3 id="wsgiref-headers-—-WSGI-响应标头工具"><a href="#wsgiref-headers-—-WSGI-响应标头工具" class="headerlink" title="wsgiref.headers — WSGI 响应标头工具"></a><code>wsgiref.headers</code> — WSGI 响应标头工具</h3><p>此模块提供了一个单独的类 <code>Headers</code>，可以方便地使用一个映射类接口操作 WSGI 响应标头。</p>
<p><em>class</em> <code>wsgiref.headers.Headers</code>([<em>headers</em>])</p>
<p>创建一个包装了 <em>headers</em> 的映射类对象，它必须为如 <a href="https://www.python.org/dev/peps/pep-3333" target="_blank" rel="noopener"><strong>PEP 3333</strong></a> 所描述的由标头名称/值元组构成的列表。 <em>headers</em> 的默认值为一个空列表。</p>
<p><code>Headers</code> 对象支持典型的映射操作包括 <code>__getitem__()</code>, <code>get()</code>, <code>__setitem__()</code>, <code>setdefault()</code>, <code>__delitem__()</code> 和 <code>__contains__()</code>。 对于以上各个方法，映射的键是标头名称（大小写不敏感），而值是关联到该标头名称的第一个值。 设置一个标头会移除该标头的任何现有值，再将一个新值添加到所包装的标头列表末尾。 标头的现有顺序通常会保持不变，只在所包装的列表末尾添加新的标头。</p>
<p>与字典不同，当你试图获取或删除所包装的标头列表中不存在的键时 <code>Headers</code> 对象不会引发错误。 获取一个不存在的标头只是返回 <code>None</code>，而删除一个不存在的标头则没有任何影响。</p>
<p><code>Headers</code> 对象还支持 <code>keys()</code>, <code>values()</code> 以及 <code>items()</code> 方法。 如果存在具有多个值的键则 <code>keys()</code> 和 <code>items()</code> 所返回的列表可能包括多个相同的键。 对 <code>Headers</code> 对象执行 <code>len()</code> 的结果与 <code>items()</code> 的长度相同，也与所包装的标头列表的长度相同。 实际上，<code>items()</code> 方法只是返回所包装的标头列表的一个副本。</p>
<p>在 <code>Headers</code> 对象上调用 <code>bytes()</code> 将返回适用于作为 HTTP 响应标头来传输的已格式化字节串。 每个标头附带以逗号加空格分隔的值放置在一行中。 每一行都以回车符加换行符结束，且该字节串会以一个空行作为结束。</p>
<p>除了映射接口和格式化特性，<code>Headers</code> 对象还具有下列方法用来查询和添加多值标头，以及添加具有 MIME 参数的标头:</p>
<ul>
<li><p><code>get_all</code>(<em>name</em>)</p>
<p>返回包含指定标头的所有值的列表。</p>
<p>返回的列表项将按它们在原始标头列表中的出现或被添加到实例中的顺序排序，并可能包含重复项。 任何被删除并重新插入的字段总是会被添加到标头列表末尾。 如果给定名称的字段不存在，则返回一个空列表。</p>
</li>
<li><p><code>add_header</code>(<em>name</em>, <em>value</em>, <em>**_params</em>)</p>
<p>添加一个（可能有多个值）标头，带有通过关键字参数指明的可选的 MIME 参数。</p>
<p><em>name</em> 是要添加的标头字段。 可以使用关键字参数来为标头字段设置 MIME 参数。 每个参数必须为字符串或 <code>None</code>。 参数名中的下划线会被转换为连字符，因为连字符不可在 Python 标识符中出现，但许多 MIME 参数名都包括连字符。 如果参数值为字符串，它会以 <code>name="value"</code> 的形式被添加到标头值参数中。 如果为 <code>None</code>，则只会添加参数名。 （这适用于没有值的 MIME 参数。） 示例用法:</p>
<pre class="line-numbers language-python"><code class="language-python">h<span class="token punctuation">.</span>add_header<span class="token punctuation">(</span><span class="token string">'content-disposition'</span><span class="token punctuation">,</span> <span class="token string">'attachment'</span><span class="token punctuation">,</span> filename<span class="token operator">=</span><span class="token string">'bud.gif'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>以上代码将添加一个这样的标头:</p>
<pre class="line-numbers language-python"><code class="language-python">Content<span class="token operator">-</span>Disposition<span class="token punctuation">:</span> attachment<span class="token punctuation">;</span> filename<span class="token operator">=</span><span class="token string">"bud.gif"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
</ul>
<p>在 3.5 版更改: <em>headers</em> 形参是可选的。</p>
<h3 id="wsgiref-simple-server-—-一个简单的-WSGI-HTTP-服务器"><a href="#wsgiref-simple-server-—-一个简单的-WSGI-HTTP-服务器" class="headerlink" title="wsgiref.simple_server — 一个简单的 WSGI HTTP 服务器"></a><code>wsgiref.simple_server</code> — 一个简单的 WSGI HTTP 服务器</h3><p>此模块实现了一个简单的 HTTP 服务器 (基于 <code>http.server</code>) 来发布 WSGI 应用程序。 每个服务器实例会在给定的主机名和端口号上发布一个 WSGI 应用程序。 如果你想在一个主机名和端口号上发布多个应用程序，你应当创建一个通过解析 <code>PATH_INFO</code> 来选择每个请求要发起调用哪个应用程序的 WSGI 应用程序。 (例如，使用 <code>wsgiref.util</code> 中的 <code>shift_path_info()</code> 函数。)</p>
<p><code>wsgiref.simple_server.make_server</code>(<em>host</em>, <em>port</em>, <em>app</em>, <em>server_class=WSGIServer</em>, <em>handler_class=WSGIRequestHandler</em>)</p>
<p>创建一个新的 WSGI 服务器并在 <em>host</em> 和 <em>port</em> 上进行监听，接受对 <em>app</em> 的连接。 返回值是所提供的 <em>server_class</em> 的实例，并将使用指定的 <em>handler_class</em> 来处理请求。 <em>app</em> 必须是一个如 <a href="https://www.python.org/dev/peps/pep-3333" target="_blank" rel="noopener"><strong>PEP 3333</strong></a> 所定义的 WSGI 应用程序对象。</p>
<p>用法示例:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> wsgiref<span class="token punctuation">.</span>simple_server <span class="token keyword">import</span> make_server<span class="token punctuation">,</span> demo_app
<span class="token keyword">with</span> make_server<span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">,</span> <span class="token number">8000</span><span class="token punctuation">,</span> demo_app<span class="token punctuation">)</span> <span class="token keyword">as</span> httpd<span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Serving HTTP on port 8000..."</span><span class="token punctuation">)</span>
    <span class="token comment" spellcheck="true"># Respond to requests until process is killed</span>
    httpd<span class="token punctuation">.</span>serve_forever<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment" spellcheck="true"># Alternative: serve one request, then exit</span>
    httpd<span class="token punctuation">.</span>handle_request<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>wsgiref.simple_server.demo_app</code>(<em>environ</em>, <em>start_response</em>)</p>
<p>此函数是一个小巧但完整的 WSGI 应用程序，它返回一个包含消息 “Hello world!” 以及 <em>environ</em> 形参中提供的键/值对的文本页面。 它适用于验证 WSGI 服务器 (例如 <code>wsgiref.simple_server</code>) 是否能够正确地运行一个简单的 WSGI 应用程序。</p>
<p><em>class</em> <code>wsgiref.simple_server.WSGIServer</code>(<em>server_address</em>, <em>RequestHandlerClass</em>)</p>
<p>创建一个 <code>WSGIServer</code> 实例。 <em>server_address</em> 应当是一个 <code>(host,port)</code> 元组，而 <em>RequestHandlerClass</em> 应当是 <code>http.server.BaseHTTPRequestHandler</code> 的子类，它将被用来处理请求。</p>
<p>你通常不需要调用此构造器，因为 <code>make_server()</code> 函数能为你处理所有的细节。</p>
<p><code>WSGIServer</code> 是 <code>http.server.HTTPServer</code> 的子类，因此它所有的方法 (例如 <code>serve_forever()</code> 和 <code>handle_request()</code>) 都是可用的。 <code>WSGIServer</code> 还提供了以下 WSGI 专属的方法:</p>
<ul>
<li><p><code>set_app</code>(<em>application</em>)</p>
<p>将可调用对象 <em>application</em> 设为将要接受请求的 WSGI 应用程序。</p>
</li>
<li><p><code>get_app</code>()</p>
<p>返回当前设置的应用程序可调用对象。</p>
</li>
</ul>
<p>但是，你通常不需要使用这些附加的方法，因为 <code>set_app()</code> 通常会由 <code>make_server()</code> 来调用，而 <code>get_app()</code> 主要是针对请求处理句柄实例的。</p>
<p><em>class</em> <code>wsgiref.simple_server.WSGIRequestHandler</code>(<em>request</em>, <em>client_address</em>, <em>server</em>)</p>
<p>为给定的 <em>request</em> 创建一个 HTTP 处理句柄 (例如套接字)，<em>client_address</em> (一个 <code>(host,port)</code> 元组)，以及 <em>server</em> (<code>WSGIServer</code> 实例)。</p>
<p>你不需要直接创建该类的实例；它们会根据 <code>WSGIServer</code> 对象的需要自动创建。 但是，你可以子类化该类并将其作为 <em>handler_class</em> 提供给 <code>make_server()</code> 函数。 一些可能在子类中重载的相关方法:</p>
<ul>
<li><p><code>get_environ</code>()</p>
<p>返回包含针对一个请求的 WSGI 环境的字典。 默认实现会拷贝 <code>WSGIServer</code> 对象的 <code>base_environ</code> 字典属性的内容并添加从 HTTP 请求获取的各种标头。 对此方法的每个调用应当返回一个 <a href="https://www.python.org/dev/peps/pep-3333" target="_blank" rel="noopener"><strong>PEP 3333</strong></a> 所指明的包含所有相关 CGI 环境变量的新字典。</p>
</li>
<li><p><code>get_stderr</code>()</p>
<p>返回应被用作 <code>wsgi.errors</code> 流的对象。 默认实现将只返回 <code>sys.stderr</code>。</p>
</li>
<li><p><code>handle</code>()</p>
<p>处理 HTTP 请求。 默认的实现会使用 <code>wsgiref.handlers</code> 类创建一个处理句柄实例来实现实际的 WSGI 应用程序接口。</p>
</li>
</ul>
<h3 id="wsgiref-validate-—-WSGI-一致性检查器"><a href="#wsgiref-validate-—-WSGI-一致性检查器" class="headerlink" title="wsgiref.validate —- WSGI 一致性检查器"></a><code>wsgiref.validate</code> —- WSGI 一致性检查器</h3><p>当创建新的 WSGI 应用程序对象、框架、服务器或中间件时，使用 <code>wsgiref.validate</code> 来验证新代码的一致性是很有用的。 此模块提供了一个创建 WSGI 应用程序对象的函数来验证 WSGI 服务器或网关与 WSGI 应用程序对象之间的通信，以便检查双方的协议一致性。</p>
<p>请注意这个工具并不保证完全符合 <a href="https://www.python.org/dev/peps/pep-3333" target="_blank" rel="noopener"><strong>PEP 3333</strong></a>；此模块没有报告错误并不一定表示不存在错误。 但是，如果此模块确实报告了错误，那么几乎可以肯定服务器或应用程序不是 100% 符合要求的。</p>
<p>此模块是基于 Ian Bicking 的 “Python Paste” 库的 <code>paste.lint</code> 模块。</p>
<p><code>wsgiref.validate.validator</code>(<em>application</em>)</p>
<p>包装 <em>application</em> 并返回一个新的 WSGI 应用程序对象。 返回的应用程序将转发所有请求到原始的 <em>application*，并将检查 *application</em> 和发起调用它的服务器是否都符合 WSGI 规范和 <a href="https://tools.ietf.org/html/rfc2616.html" target="_blank" rel="noopener"><strong>RFC 2616</strong></a>。</p>
<p>任何被检测到的不一致性都会导致引发 <code>AssertionError</code>；但是请注意，如何对待这些错误取决于具体服务器。 例如，<code>wsgiref.simple_server</code> 和其他基于 <code>wsgiref.handlers</code> 的服务器（它们没有重载错误处理方法来做其他操作）将简单地输出一条消息报告发生了错误，并将回溯转给 <code>sys.stderr</code> 或者其他错误数据流。</p>
<p>这个包装器也可能会使用 <code>warnings</code> 模块生成输出来指明存在问题但实际上未被 <a href="https://www.python.org/dev/peps/pep-3333" target="_blank" rel="noopener"><strong>PEP 3333</strong></a> 所禁止的行为。 除非它们被 Python 命令行选项或 <code>warnings</code> API 所屏蔽，否则任何此类警告都将被写入到 <code>sys.stderr</code> (<em>不是</em> <code>wsgi.errors</code>，除非它们恰好是同一个对象)。</p>
<p>用法示例:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> wsgiref<span class="token punctuation">.</span>validate <span class="token keyword">import</span> validator
<span class="token keyword">from</span> wsgiref<span class="token punctuation">.</span>simple_server <span class="token keyword">import</span> make_server
<span class="token comment" spellcheck="true"># Our callable object which is intentionally not compliant to the</span>
<span class="token comment" spellcheck="true"># standard, so the validator is going to break</span>
<span class="token keyword">def</span> <span class="token function">simple_app</span><span class="token punctuation">(</span>environ<span class="token punctuation">,</span> start_response<span class="token punctuation">)</span><span class="token punctuation">:</span>
    status <span class="token operator">=</span> <span class="token string">'200 OK'</span>  <span class="token comment" spellcheck="true"># HTTP Status</span>
    headers <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token string">'Content-type'</span><span class="token punctuation">,</span> <span class="token string">'text/plain'</span><span class="token punctuation">)</span><span class="token punctuation">]</span>  <span class="token comment" spellcheck="true"># HTTP Headers</span>
    start_response<span class="token punctuation">(</span>status<span class="token punctuation">,</span> headers<span class="token punctuation">)</span>
    <span class="token comment" spellcheck="true"># This is going to break because we need to return a list, and</span>
    <span class="token comment" spellcheck="true"># the validator is going to inform us</span>
    <span class="token keyword">return</span> b<span class="token string">"Hello World"</span>
<span class="token comment" spellcheck="true"># This is the application wrapped in a validator</span>
validator_app <span class="token operator">=</span> validator<span class="token punctuation">(</span>simple_app<span class="token punctuation">)</span>
<span class="token keyword">with</span> make_server<span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">,</span> <span class="token number">8000</span><span class="token punctuation">,</span> validator_app<span class="token punctuation">)</span> <span class="token keyword">as</span> httpd<span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Listening on port 8000...."</span><span class="token punctuation">)</span>
    httpd<span class="token punctuation">.</span>serve_forever<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="wsgiref-handlers-—-服务器-网关基类"><a href="#wsgiref-handlers-—-服务器-网关基类" class="headerlink" title="wsgiref.handlers — 服务器/网关基类"></a><code>wsgiref.handlers</code> — 服务器/网关基类</h3><p>此模块提供了用于实现 WSGI 服务器和网关的处理句柄基类。 这些基类可处理大部分与 WSGI 应用程序通信的工作，只要给予它们一个带有输入、输出和错误流的 CGI 类环境。</p>
<p><em>class</em> <code>wsgiref.handlers.CGIHandler</code></p>
<p>通过 <code>sys.stdin</code>, <code>sys.stdout</code>, <code>sys.stderr</code> 和 <code>os.environ</code> 发起基于 CGI 的调用。 这在当你有一个 WSGI 应用程序并想将其作为 CGI 脚本运行时很有用处。 只需发起调用 <code>CGIHandler().run(app)</code>，其中 <code>app</code> 是你想要发起调用的 WSGI 应用程序。</p>
<p>该类是 <code>BaseCGIHandler</code> 的子类，它将设置 <code>wsgi.run_once</code> 为真值，<code>wsgi.multithread</code> 为假值，<code>wsgi.multiprocess</code> 为真值，并总是使用 <code>sys</code> 和 <code>os</code> 来获取所需的 CGI 流和环境。</p>
<p><em>class</em> <code>wsgiref.handlers.IISCGIHandler</code></p>
<p><code>CGIHandler</code> 的一个专门化替代，用于在 Microsoft 的 IIS Web 服务器上部署，无需设置 config allowPathInfo 选项 (IIS&gt;=7) 或 metabase allowPathInfoForScriptMappings (IIS&lt;7)。</p>
<p>默认情况下，IIS 给出的 <code>PATH_INFO</code> 会与前面的 <code>SCRIPT_NAME</code> 重复，导致想要实现路由的 WSGI 应用程序出现问题。 这个处理句柄会去除任何这样的重复路径。</p>
<p>IIS 可被配置为传递正确的 <code>PATH_INFO</code>，但这会导致另一个 <code>PATH_TRANSLATED</code> 出错的问题。 幸运的是这个变量很少被使用并且不被 WSGI 所保证。 但是在 IIS&lt;7 上，这个设置只能在 vhost 层级上进行，影响到所有其他脚本映射，其中许多在受 <code>PATH_TRANSLATED</code> 问题影响时都会中断运行。 因此 IIS&lt;7 的部署几乎从不附带这样的修正（即使 IIS7 也很少使用它，因为它仍然不带 UI）。</p>
<p>CGI 代码没有办法确定该选项是否已设置，因此提供了一个单独的处理句柄类。 它的用法与 <code>CGIHandler</code> 相同，即通过调用 <code>IISCGIHandler().run(app)</code>，其中 <code>app</code> 是你想要发起调用的 WSGI 应用程序。</p>
<p>3.2 新版功能.</p>
<p><em>class</em> <code>wsgiref.handlers.BaseCGIHandler</code>(<em>stdin</em>, <em>stdout</em>, <em>stderr</em>, <em>environ</em>, <em>multithread=True</em>, <em>multiprocess=False</em>)</p>
<p>类似于 <code>CGIHandler</code>，但是改用 <code>sys</code> 和 <code>os</code> 模块，CGI 环境和 I/O 流会被显式地指定。 <em>multithread</em> 和 <em>multiprocess</em> 值被用来为处理句柄实例所运行的任何应用程序设置 <code>wsgi.multithread</code> 和 <code>wsgi.multiprocess</code> 旗标。</p>
<p>该类是 <code>SimpleHandler</code> 的子类，旨在用于 HTTP “原始服务器” 以外的软件。 如果你在编写一个网关协议实现（例如 CGI, FastCGI, SCGI 等等），它使用 <code>Status:</code> 标头来发布 HTTP 状态，你可能会想要子类化该类而不是 <code>SimpleHandler</code>。</p>
<p><em>class</em> <code>wsgiref.handlers.SimpleHandler</code>(<em>stdin</em>, <em>stdout</em>, <em>stderr</em>, <em>environ</em>, <em>multithread=True</em>, <em>multiprocess=False</em>)</p>
<p>类似于 <code>BaseCGIHandler</code>，但被设计用于 HTTP 原始服务器。 如果你在编写一个 HTTP 服务器实现，你可能会想要子类化该类而不是 <code>BaseCGIHandler</code>。</p>
<p>该类是 <code>BaseHandler</code> 的子类。 它重载了 <code>__init__()</code>, <code>get_stdin()</code>, <code>get_stderr()</code>, <code>add_cgi_vars()</code>, <code>_write()</code> 和 <code>_flush()</code> 方法以支持通过构造器显式地设置环境和流。 所提供的环境和流存储在 <code>stdin</code>, <code>stdout</code>, <code>stderr</code> 和 <code>environ</code> 属性中。</p>
<p><em>stdout</em> 的 <code>write()</code> 方法应该完整写入每个数据块，与 <code>io.BufferedIOBase</code> 一样。</p>
<p><em>class</em> <code>wsgiref.handlers.BaseHandler</code></p>
<p>这是适用于运行 WSGI 应用程序的抽象基类。 每个实例将处理一个单独的 HTTP 请求，不过在原则上你也可以创建一个可针对多个请求重用的子类。</p>
<p><code>BaseHandler</code> 实例只有一个方法提供给外部使用:</p>
<ul>
<li><p><code>run</code>(<em>app</em>)</p>
<p>运行指定的 WSGI 应用程序 <em>app</em>。</p>
</li>
</ul>
<p>所有的 <code>BaseHandler</code> 其他方法都是在运行应用程序过程中由该方法发起调用的，因此主要是为了允许定制运行过程。</p>
<p>以下方法必须在子类中被重载:</p>
<ul>
<li><p><code>_write</code>(<em>data</em>)</p>
<p>缓冲字节数据 <em>data</em> 以便传输给客户端。 如果此方法真的传输了数据也是可以的；<code>BaseHandler</code> 只有在底层系统真有这样的区分时才会区分写入和刷新操作以提高效率。</p>
</li>
<li><p><code>_flush</code>()</p>
<p>强制将缓冲的数据传输给客户端。 如果此方法无任何操作也是可以的（例如，<code>_write()</code> 实际上已发送了数据）。</p>
</li>
<li><p><code>get_stdin</code>()</p>
<p>返回一个适合被用作当前所处理请求的 <code>wsgi.input</code> 的输入流对象。</p>
</li>
<li><p><code>get_stderr</code>()</p>
<p>返回一个适合被用作当前所处理请求的 <code>wsgi.errors</code> 的输出流对象。</p>
</li>
<li><p><code>add_cgi_vars</code>()</p>
<p>将当前请求的 CGI 变量插入到 <code>environ</code> 属性。</p>
</li>
</ul>
<p>以下是一些你可能会想要重载的其他方法。 但这只是个简略的列表，它不包括每个可被重载的方法。 你应当在在尝试创建自定义的 <code>BaseHandler</code> 子类之前参阅文档字符串和源代码来了解更多信息。</p>
<p>用于自定义 WSGI 环境的属性和方法:</p>
<ul>
<li><p><code>wsgi_multithread</code></p>
<p>用于 <code>wsgi.multithread</code> 环境变量的值。 它在 <code>BaseHandler</code> 中默认为真值，但在其他子类中可能有不同的默认值（或是由构造器来设置）。</p>
</li>
<li><p><code>wsgi_multiprocess</code></p>
<p>用于 <code>wsgi.multiprocess</code> 环境变量的值。 它在 <code>BaseHandler</code> 中默认为真值，但在其他子类中可能有不同的默认值（或是由构造器来设置）。</p>
</li>
<li><p><code>wsgi_run_once</code></p>
<p>用于 <code>wsgi.run_once</code> 环境变量的值。 它在 <code>BaseHandler</code> 中默认为假值，但在 <code>CGIHandler</code> 中默认为真值。</p>
</li>
<li><p><code>os_environ</code></p>
<p>要包括在每个请求的 WSGI 环境中的默认环境变量。 在默认情况下，这是当 <code>wsgiref.handlers</code> 被导入时的 <code>os.environ</code> 的一个副本，但也可以在类或实例层级上创建它们自己的子类。 请注意该字典应当被当作是只读的，因为默认值会在多个类和实际之间共享。</p>
</li>
<li><p><code>server_software</code></p>
<p>如果设置了 <code>origin_server</code> 属性，该属性的值会被用来设置默认的 <code>SERVER_SOFTWARE</code> WSGI 环境变量，并且还会被用来设置 HTTP 响应中默认的 <code>Server:</code> 标头。 它会被不是 HTTP 原始服务器的处理句柄所忽略 (例如 <code>BaseCGIHandler</code> 和 <code>CGIHandler</code>)。</p>
<p>在 3.3 版更改: 名称 “Python” 会被替换为实现专属的名称如 “CPython”, “Jython” 等等。</p>
</li>
<li><p><code>get_scheme</code>()</p>
<p>返回当前请求所使用的 URL 方案。 默认的实现会使用来自 <code>wsgiref.util</code> 的 <code>guess_scheme()</code> 函数根据当前请求的 <code>environ</code> 变量来猜测方案应该是 “http” 还是 “https”。</p>
</li>
<li><p><code>setup_environ</code>()</p>
<p>将 <code>environ</code> 属性设为填充了完整内容的 WSGI 环境。 默认的实现会使用上述的所有方法和属性，加上 <code>get_stdin()</code>, <code>get_stderr()</code> 和 <code>add_cgi_vars()</code> 方法以及 <code>wsgi_file_wrapper</code> 属性。 它还会插入一个 <code>SERVER_SOFTWARE</code> 键，如果该键还不存在的话，只要 <code>origin_server</code> 属性为真值并且设置了 <code>server_software</code> 属性。</p>
</li>
</ul>
<p>用于自定义异常处理的方法和属性:</p>
<ul>
<li><p><code>log_exception</code>(<em>exc_info</em>)</p>
<p>将 <em>exc_info</em> 元素记录到服务器日志。 <em>exc_info</em> 是一个 <code>(type, value, traceback)</code> 元组。 默认的实现会简单地将回溯信息写入请求的 <code>wsgi.errors</code> 流并刷新它。 子类可以重载此方法来修改格式或重设输出目标，通过邮件将回溯信息发给管理员，或执行任何其他符合要求的动作。</p>
</li>
<li><p><code>traceback_limit</code></p>
<p>要包括在默认 <code>log_exception()</code> 方法的回溯信息输出中的最大帧数。 如果为 <code>None</code>，则会包括所有的帧。</p>
</li>
<li><p><code>error_output</code>(<em>environ</em>, <em>start_response</em>)</p>
<p>此方法是一个为用户生成错误页面的 WSGI 应用程序。 它仅当将标头发送给客户端之前发生错误时会被发起调用。</p>
<p>此方法可使用 <code>sys.exc_info()</code> 来访问当前错误信息，并应当在调用 <em>start_response</em> 时将该信息传递给它（如 <a href="https://www.python.org/dev/peps/pep-3333" target="_blank" rel="noopener"><strong>PEP 3333</strong></a> 的 “Error Handling” 部分所描述的）。</p>
<p>默认的实现只是使用 <code>error_status</code>, <code>error_headers</code>, 和 <code>error_body</code> 属性来生成一个输出页面。 子类可以重载此方法来产生更动态化的错误输出。</p>
<p>但是请注意，从安全角度看来是不建议将诊断信息暴露给任何用户的；理想的做法是你应当通过特别处理来启用诊断输出，因此默认的实现并不包括这样的内容。</p>
</li>
<li><p><code>error_status</code></p>
<p>用于错误响应的 HTTP 状态。 这应当是一个在 <a href="https://www.python.org/dev/peps/pep-3333" target="_blank" rel="noopener"><strong>PEP 3333</strong></a> 中定义的字符串；它默认为代码 500 以相应的消息。</p>
</li>
<li><p><code>error_headers</code></p>
<p>用于错误响应的 HTTP 标头。 这应当是由 WSGI 响应标头 (<code>(name, value)</code> 元组) 构成的列表，如 <a href="https://www.python.org/dev/peps/pep-3333" target="_blank" rel="noopener"><strong>PEP 3333</strong></a> 所定义的。 默认的列表只是将内容类型设为 <code>text/plain</code>。</p>
</li>
<li><p><code>error_body</code></p>
<p>错误响应体。 这应当是一个 HTTP 响应体字节串。 它默认为纯文本 “A server error occurred. Please contact the administrator.”</p>
</li>
</ul>
<p>用于 <a href="https://www.python.org/dev/peps/pep-3333" target="_blank" rel="noopener"><strong>PEP 3333</strong></a> 的 “可选的平台专属文件处理” 特性的方法和属性:</p>
<ul>
<li><p><code>wsgi_file_wrapper</code></p>
<p>一个 <code>wsgi.file_wrapper</code> 工厂对象，或为 <code>None</code>。 该属性的默认值是 <code>wsgiref.util.FileWrapper</code> 类。</p>
</li>
<li><p><code>sendfile</code>()</p>
<p>重载以实现平台专属的文件传输。 此方法仅在应用程序的返回值是由 <code>wsgi_file_wrapper</code> 属性指定的类的实例时会被调用。 如果它能够成功地传输文件则应当返回真值，以使得默认的传输代码将不会被执行。 此方法的默认实现只会返回假值。</p>
</li>
</ul>
<p>杂项方法和属性:</p>
<ul>
<li><p><code>origin_server</code></p>
<p>该属性在处理句柄的 <code>_write()</code> 和 <code>_flush()</code> 被用于同客户端直接通信而不是通过需要 HTTP 状态为某种特殊 <code>Status:</code> 标头的 CGI 类网关协议时应当被设为真值</p>
<p>该属性在 <code>BaseHandler</code> 中默认为真值，但在 <code>BaseCGIHandler</code> 和 <code>CGIHandler</code> 中则为假值。</p>
</li>
<li><p><code>http_version</code></p>
<p>如果 <code>origin_server</code> 为真值，则该字符串属性会被用来设置给客户端的响应的 HTTP 版本。 它的默认值为 <code>"1.0"</code>。</p>
</li>
</ul>
<p><code>wsgiref.handlers.read_environ</code>()</p>
<p>将来自 <code>os.environ</code> 的 CGI 变量转码为 <a href="https://www.python.org/dev/peps/pep-3333" target="_blank" rel="noopener"><strong>PEP 3333</strong></a> “bytes in unicode” 字符串，返回一个新的字典。 此函数被 <code>CGIHandler</code> 和 <code>IISCGIHandler</code> 用来替代直接使用 <code>os.environ</code>，后者不一定在所有使用 Python 3 的平台和 Web 服务器上都符合 WSGI 标准 — 特别是当 OS 的实际环境为 Unicode 时 (例如 Windows)，或者当环境为字节数据，但被 Python 用来解码它的系统编码格式不是 ISO-8859-1 时 (例如使用 UTF-8 的 Unix 系统)。</p>
<p>如果你要实现自己的基于 CGI 的处理句柄，你可能会想要使用此例程而不是简单地从 <code>os.environ</code> 直接拷贝值。</p>
<p>3.2 新版功能.</p>
<h3 id="例子-4"><a href="#例子-4" class="headerlink" title="例子"></a>例子</h3><p>这是一个可运行的 “Hello World” WSGI 应用程序:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> wsgiref<span class="token punctuation">.</span>simple_server <span class="token keyword">import</span> make_server
<span class="token comment" spellcheck="true"># Every WSGI application must have an application object - a callable</span>
<span class="token comment" spellcheck="true"># object that accepts two arguments. For that purpose, we're going to</span>
<span class="token comment" spellcheck="true"># use a function (note that you're not limited to a function, you can</span>
<span class="token comment" spellcheck="true"># use a class for example). The first argument passed to the function</span>
<span class="token comment" spellcheck="true"># is a dictionary containing CGI-style environment variables and the</span>
<span class="token comment" spellcheck="true"># second variable is the callable object.</span>
<span class="token keyword">def</span> <span class="token function">hello_world_app</span><span class="token punctuation">(</span>environ<span class="token punctuation">,</span> start_response<span class="token punctuation">)</span><span class="token punctuation">:</span>
    status <span class="token operator">=</span> <span class="token string">'200 OK'</span>  <span class="token comment" spellcheck="true"># HTTP Status</span>
    headers <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token string">'Content-type'</span><span class="token punctuation">,</span> <span class="token string">'text/plain; charset=utf-8'</span><span class="token punctuation">)</span><span class="token punctuation">]</span>  <span class="token comment" spellcheck="true"># HTTP Headers</span>
    start_response<span class="token punctuation">(</span>status<span class="token punctuation">,</span> headers<span class="token punctuation">)</span>
    <span class="token comment" spellcheck="true"># The returned object is going to be printed</span>
    <span class="token keyword">return</span> <span class="token punctuation">[</span>b<span class="token string">"Hello World"</span><span class="token punctuation">]</span>
<span class="token keyword">with</span> make_server<span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">,</span> <span class="token number">8000</span><span class="token punctuation">,</span> hello_world_app<span class="token punctuation">)</span> <span class="token keyword">as</span> httpd<span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Serving on port 8000..."</span><span class="token punctuation">)</span>
    <span class="token comment" spellcheck="true"># Serve until process is killed</span>
    httpd<span class="token punctuation">.</span>serve_forever<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>一个发布当前目录的 WSGI 应用程序示例，接受通过命令行指定可选的目录和端口号 (默认值: 8000):</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true">#!/usr/bin/env python3</span>
<span class="token triple-quoted-string string">'''
Small wsgiref based web server. Takes a path to serve from and an
optional port number (defaults to 8000), then tries to serve files.
Mime types are guessed from the file names, 404 errors are raised
if the file is not found. Used for the make serve target in Doc.
'''</span>
<span class="token keyword">import</span> sys
<span class="token keyword">import</span> os
<span class="token keyword">import</span> mimetypes
<span class="token keyword">from</span> wsgiref <span class="token keyword">import</span> simple_server<span class="token punctuation">,</span> util
<span class="token keyword">def</span> <span class="token function">app</span><span class="token punctuation">(</span>environ<span class="token punctuation">,</span> respond<span class="token punctuation">)</span><span class="token punctuation">:</span>
    fn <span class="token operator">=</span> os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>join<span class="token punctuation">(</span>path<span class="token punctuation">,</span> environ<span class="token punctuation">[</span><span class="token string">'PATH_INFO'</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> <span class="token string">'.'</span> <span class="token operator">not</span> <span class="token keyword">in</span> fn<span class="token punctuation">.</span>split<span class="token punctuation">(</span>os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>sep<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
        fn <span class="token operator">=</span> os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>join<span class="token punctuation">(</span>fn<span class="token punctuation">,</span> <span class="token string">'index.html'</span><span class="token punctuation">)</span>
    type <span class="token operator">=</span> mimetypes<span class="token punctuation">.</span>guess_type<span class="token punctuation">(</span>fn<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
    <span class="token keyword">if</span> os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>exists<span class="token punctuation">(</span>fn<span class="token punctuation">)</span><span class="token punctuation">:</span>
        respond<span class="token punctuation">(</span><span class="token string">'200 OK'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token string">'Content-Type'</span><span class="token punctuation">,</span> type<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> util<span class="token punctuation">.</span>FileWrapper<span class="token punctuation">(</span>open<span class="token punctuation">(</span>fn<span class="token punctuation">,</span> <span class="token string">"rb"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">else</span><span class="token punctuation">:</span>
        respond<span class="token punctuation">(</span><span class="token string">'404 Not Found'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token string">'Content-Type'</span><span class="token punctuation">,</span> <span class="token string">'text/plain'</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token punctuation">[</span>b<span class="token string">'not found'</span><span class="token punctuation">]</span>
<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>
    path <span class="token operator">=</span> sys<span class="token punctuation">.</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token keyword">if</span> len<span class="token punctuation">(</span>sys<span class="token punctuation">.</span>argv<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">1</span> <span class="token keyword">else</span> os<span class="token punctuation">.</span>getcwd<span class="token punctuation">(</span><span class="token punctuation">)</span>
    port <span class="token operator">=</span> int<span class="token punctuation">(</span>sys<span class="token punctuation">.</span>argv<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">if</span> len<span class="token punctuation">(</span>sys<span class="token punctuation">.</span>argv<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">2</span> <span class="token keyword">else</span> <span class="token number">8000</span>
    httpd <span class="token operator">=</span> simple_server<span class="token punctuation">.</span>make_server<span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">,</span> port<span class="token punctuation">,</span> app<span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Serving {} on port {}, control-C to stop"</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>path<span class="token punctuation">,</span> port<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">try</span><span class="token punctuation">:</span>
        httpd<span class="token punctuation">.</span>serve_forever<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">except</span> KeyboardInterrupt<span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Shutting down."</span><span class="token punctuation">)</span>
        httpd<span class="token punctuation">.</span>server_close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="urllib-—-URL-处理模块"><a href="#urllib-—-URL-处理模块" class="headerlink" title="urllib —- URL 处理模块"></a><code>urllib</code> —- URL 处理模块</h2><p><strong>源代码:</strong> <a href="https://github.com/python/cpython/tree/3.10/Lib/urllib/" target="_blank" rel="noopener">Lib/urllib/</a></p>
<hr>
<p><code>urllib</code> 是一个收集了多个涉及 URL 的模块的包：</p>
<ul>
<li><a href="https://docs.python.org/zh-cn/3.10/library/urllib.request.html#module-urllib.request" target="_blank" rel="noopener"><code>urllib.request</code></a> 打开和读取 URL</li>
<li><a href="https://docs.python.org/zh-cn/3.10/library/urllib.error.html#module-urllib.error" target="_blank" rel="noopener"><code>urllib.error</code></a> 包含 <a href="https://docs.python.org/zh-cn/3.10/library/urllib.request.html#module-urllib.request" target="_blank" rel="noopener"><code>urllib.request</code></a> 抛出的异常</li>
<li><a href="https://docs.python.org/zh-cn/3.10/library/urllib.parse.html#module-urllib.parse" target="_blank" rel="noopener"><code>urllib.parse</code></a> 用于解析 URL</li>
<li><a href="https://docs.python.org/zh-cn/3.10/library/urllib.robotparser.html#module-urllib.robotparser" target="_blank" rel="noopener"><code>urllib.robotparser</code></a> 用于解析 <code>robots.txt</code> 文件</li>
</ul>
<h2 id="http-—-HTTP-模块"><a href="#http-—-HTTP-模块" class="headerlink" title="http —- HTTP 模块"></a><code>http</code> —- HTTP 模块</h2><p><strong>源代码:</strong> <a href="https://github.com/python/cpython/tree/3.10/Lib/http/__init__.py" target="_blank" rel="noopener">Lib/http/<strong>init</strong>.py</a></p>
<hr>
<p><code>http</code> 是一个包，它收集了多个用于处理超文本传输协议的模块:</p>
<ul>
<li><a href="https://docs.python.org/zh-cn/3.10/library/http.client.html#module-http.client" target="_blank" rel="noopener"><code>http.client</code></a> 是一个低层级的 HTTP 协议客户端；对于高层级的 URL 访问请使用 <a href="https://docs.python.org/zh-cn/3.10/library/urllib.request.html#module-urllib.request" target="_blank" rel="noopener"><code>urllib.request</code></a></li>
<li><a href="https://docs.python.org/zh-cn/3.10/library/http.server.html#module-http.server" target="_blank" rel="noopener"><code>http.server</code></a> 包含基于 <a href="https://docs.python.org/zh-cn/3.10/library/socketserver.html#module-socketserver" target="_blank" rel="noopener"><code>socketserver</code></a> 的基本 HTTP 服务类</li>
<li><a href="https://docs.python.org/zh-cn/3.10/library/http.cookies.html#module-http.cookies" target="_blank" rel="noopener"><code>http.cookies</code></a> 包含一些有用来实现通过 cookies 进行状态管理的工具</li>
<li><a href="https://docs.python.org/zh-cn/3.10/library/http.cookiejar.html#module-http.cookiejar" target="_blank" rel="noopener"><code>http.cookiejar</code></a> 提供了 cookies 的持久化</li>
</ul>
<p><code>http</code> 也是一个通过 <code>http.HTTPStatus</code> 枚举定义了一些 HTTP 状态码以及相关联消息的模块</p>
<p><em>class</em> <code>http.HTTPStatus</code></p>
<p>3.5 新版功能.</p>
<p><code>enum.IntEnum</code> 的子类，它定义了组 HTTP 状态码，原理短语以及用英语书写的长描述文本。</p>
<p>用法：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> http <span class="token keyword">import</span> HTTPStatus
<span class="token operator">>></span><span class="token operator">></span> HTTPStatus<span class="token punctuation">.</span>OK
<span class="token operator">&lt;</span>HTTPStatus<span class="token punctuation">.</span>OK<span class="token punctuation">:</span> <span class="token number">200</span><span class="token operator">></span>
<span class="token operator">>></span><span class="token operator">></span> HTTPStatus<span class="token punctuation">.</span>OK <span class="token operator">==</span> <span class="token number">200</span>
<span class="token boolean">True</span>
<span class="token operator">>></span><span class="token operator">></span> HTTPStatus<span class="token punctuation">.</span>OK<span class="token punctuation">.</span>value
<span class="token number">200</span>
<span class="token operator">>></span><span class="token operator">></span> HTTPStatus<span class="token punctuation">.</span>OK<span class="token punctuation">.</span>phrase
<span class="token string">'OK'</span>
<span class="token operator">>></span><span class="token operator">></span> HTTPStatus<span class="token punctuation">.</span>OK<span class="token punctuation">.</span>description
<span class="token string">'Request fulfilled, document follows'</span>
<span class="token operator">>></span><span class="token operator">></span> list<span class="token punctuation">(</span>HTTPStatus<span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token operator">&lt;</span>HTTPStatus<span class="token punctuation">.</span>CONTINUE<span class="token punctuation">:</span> <span class="token number">100</span><span class="token operator">></span><span class="token punctuation">,</span> <span class="token operator">&lt;</span>HTTPStatus<span class="token punctuation">.</span>SWITCHING_PROTOCOLS<span class="token punctuation">:</span><span class="token number">101</span><span class="token operator">></span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="HTTP-状态码"><a href="#HTTP-状态码" class="headerlink" title="HTTP 状态码"></a>HTTP 状态码</h3><p>已支持并且已在 <code>http.HTTPStatus</code> <a href="https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml" target="_blank" rel="noopener">IANA 注册</a> 的状态码有：</p>
<table>
<thead>
<tr>
<th align="left">双字母代码</th>
<th align="left">映射名</th>
<th align="left">详情</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>100</code></td>
<td align="left"><code>CONTINUE</code>：继续</td>
<td align="left">HTTP/1.1 <a href="https://tools.ietf.org/html/rfc7231.html" target="_blank" rel="noopener"><strong>RFC 7231</strong></a>, 6.2.1 节</td>
</tr>
<tr>
<td align="left"><code>101</code></td>
<td align="left"><code>SWITCHING_PROTOCOLS</code></td>
<td align="left">HTTP/1.1 RFC 7231, 6.2.2 节</td>
</tr>
<tr>
<td align="left"><code>102</code></td>
<td align="left"><code>PROCESSING</code></td>
<td align="left">WebDAV RFC 2518, 10.1 节</td>
</tr>
<tr>
<td align="left"><code>103</code></td>
<td align="left"><code>EARLY_HINTS</code></td>
<td align="left">用于指定提示 <a href="https://tools.ietf.org/html/rfc8297.html" target="_blank" rel="noopener"><strong>RFC 8297</strong></a> 的 HTTP 状态码</td>
</tr>
<tr>
<td align="left"><code>200</code></td>
<td align="left"><code>OK</code></td>
<td align="left">HTTP/1.1 RFC 7231, 6.3.1 节</td>
</tr>
<tr>
<td align="left"><code>201</code></td>
<td align="left"><code>CREATED</code></td>
<td align="left">HTTP/1.1 RFC 7231, 6.3.2 节</td>
</tr>
<tr>
<td align="left"><code>202</code></td>
<td align="left"><code>ACCEPTED</code></td>
<td align="left">HTTP/1.1 RFC 7231, 6.3.3 节</td>
</tr>
<tr>
<td align="left"><code>203</code></td>
<td align="left"><code>NON_AUTHORITATIVE_INFORMATION</code></td>
<td align="left">HTTP/1.1 RFC 7231, 6.3.4 节</td>
</tr>
<tr>
<td align="left"><code>204</code></td>
<td align="left"><code>NO_CONTENT</code>: 没有内容</td>
<td align="left">HTTP/1.1 RFC 7231, 6.3.5 节</td>
</tr>
<tr>
<td align="left"><code>205</code></td>
<td align="left"><code>RESET_CONTENT</code></td>
<td align="left">HTTP/1.1 RFC 7231, 6.3.6 节</td>
</tr>
<tr>
<td align="left"><code>206</code></td>
<td align="left"><code>PARTIAL_CONTENT</code></td>
<td align="left">HTTP/1.1 RFC 7233, 4.1 节</td>
</tr>
<tr>
<td align="left"><code>207</code></td>
<td align="left"><code>MULTI_STATUS</code></td>
<td align="left">WebDAV RFC 4918, 11.1 节</td>
</tr>
<tr>
<td align="left"><code>208</code></td>
<td align="left"><code>ALREADY_REPORTED</code></td>
<td align="left">WebDAV Binding Extensions RFC 5842, 7.1 节（实验性）</td>
</tr>
<tr>
<td align="left"><code>226</code></td>
<td align="left"><code>IM_USED</code></td>
<td align="left">Delta Encoding in HTTP RFC 3229, 10.4.1 节</td>
</tr>
<tr>
<td align="left"><code>300</code></td>
<td align="left"><code>MULTIPLE_CHOICES</code>：有多种资源可选择</td>
<td align="left">HTTP/1.1 RFC 7231, 6.4.1 节</td>
</tr>
<tr>
<td align="left"><code>301</code></td>
<td align="left"><code>MOVED_PERMANENTLY</code>：永久移动</td>
<td align="left">HTTP/1.1 RFC 7231, 6.4.2 节</td>
</tr>
<tr>
<td align="left"><code>302</code></td>
<td align="left"><code>FOUND</code>：临时移动</td>
<td align="left">HTTP/1.1 RFC 7231, 6.4.3 节</td>
</tr>
<tr>
<td align="left"><code>303</code></td>
<td align="left"><code>SEE_OTHER</code>：已经移动</td>
<td align="left">HTTP/1.1 RFC 7231, 6.4.4 节</td>
</tr>
<tr>
<td align="left"><code>304</code></td>
<td align="left"><code>NOT_MODIFIED</code>：没有修改</td>
<td align="left">HTTP/1.1 RFC 7232, 4.1 节</td>
</tr>
<tr>
<td align="left"><code>305</code></td>
<td align="left"><code>USE_PROXY</code>：使用代理</td>
<td align="left">HTTP/1.1 RFC 7231, 6.4.5 节</td>
</tr>
<tr>
<td align="left"><code>307</code></td>
<td align="left"><code>TEMPORARY_REDIRECT</code>：临时重定向</td>
<td align="left">HTTP/1.1 <a href="https://tools.ietf.org/html/rfc7231.html" target="_blank" rel="noopener"><strong>RFC 7231</strong></a>, 6.4.7 节</td>
</tr>
<tr>
<td align="left"><code>308</code></td>
<td align="left"><code>PERMANENT_REDIRECT</code>：永久重定向</td>
<td align="left">Permanent Redirect <a href="https://tools.ietf.org/html/rfc7238.html" target="_blank" rel="noopener"><strong>RFC 7238</strong></a>, Section 3 (Experimental)</td>
</tr>
<tr>
<td align="left"><code>400</code></td>
<td align="left"><code>BAD_REQUEST</code>：错误请求</td>
<td align="left">HTTP/1.1 RFC 7231, 6.5.1 节</td>
</tr>
<tr>
<td align="left"><code>401</code></td>
<td align="left"><code>UNAUTHORIZED</code>：未授权</td>
<td align="left">HTTP/1.1 Authentication RFC 7235, 3.1 节</td>
</tr>
<tr>
<td align="left"><code>402</code></td>
<td align="left"><code>PAYMENT_REQUIRED</code>：保留，将来使用</td>
<td align="left">HTTP/1.1 RFC 7231, 6.5.2 节</td>
</tr>
<tr>
<td align="left"><code>403</code></td>
<td align="left"><code>FORBIDDEN</code>：禁止</td>
<td align="left">HTTP/1.1 RFC 7231, 6.5.3 节</td>
</tr>
<tr>
<td align="left"><code>404</code></td>
<td align="left"><code>NOT_FOUND</code>：没有找到</td>
<td align="left">HTTP/1.1 RFC 7231, 6.5.4 节</td>
</tr>
<tr>
<td align="left"><code>405</code></td>
<td align="left"><code>METHOD_NOT_ALLOWED</code>：该请求方法不允许</td>
<td align="left">HTTP/1.1 RFC 7231, 6.5.5 节</td>
</tr>
<tr>
<td align="left"><code>406</code></td>
<td align="left"><code>NOT_ACCEPTABLE</code>：不可接受</td>
<td align="left">HTTP/1.1 RFC 7231, 6.5.6 节</td>
</tr>
<tr>
<td align="left"><code>407</code></td>
<td align="left"><code>PROXY_AUTHENTICATION_REQUIRED</code>：要求使用代理验明正身</td>
<td align="left">HTTP/1.1 Authentication RFC 7235, 3.1 节</td>
</tr>
<tr>
<td align="left"><code>408</code></td>
<td align="left"><code>REQUEST_TIMEOUT</code>：请求超时</td>
<td align="left">HTTP/1.1 <a href="https://tools.ietf.org/html/rfc7231.html" target="_blank" rel="noopener"><strong>RFC 7231</strong></a>, 6.5.7 节</td>
</tr>
<tr>
<td align="left"><code>409</code></td>
<td align="left"><code>CONFLICT</code>：冲突</td>
<td align="left">HTTP/1.1 RFC 7231, 6.5.8 节</td>
</tr>
<tr>
<td align="left"><code>410</code></td>
<td align="left"><code>GONE</code>：已经不在了</td>
<td align="left">HTTP/1.1 RFC 7231, 6.5.9 节</td>
</tr>
<tr>
<td align="left"><code>411</code></td>
<td align="left"><code>LENGTH_REQUIRED</code>：长度要求</td>
<td align="left">HTTP/1.1 RFC 7231, 6.5.10 节</td>
</tr>
<tr>
<td align="left"><code>412</code></td>
<td align="left"><code>PRECONDITION_FAILED</code>：前提条件错误</td>
<td align="left">HTTP/1.1 RFC 7232, 4.2 节</td>
</tr>
<tr>
<td align="left"><code>413</code></td>
<td align="left"><code>REQUEST_ENTITY_TOO_LARGE</code>：请求体太大了</td>
<td align="left">HTTP/1.1 RFC 7231, 6.5.11 节</td>
</tr>
<tr>
<td align="left"><code>414</code></td>
<td align="left"><code>REQUEST_URI_TOO_LONG</code>：请求URI太长了</td>
<td align="left">HTTP/1.1 RFC 7231, 6.5.12 节</td>
</tr>
<tr>
<td align="left"><code>415</code></td>
<td align="left"><code>UNSUPPORTED_MEDIA_TYPE</code>：不支持的媒体格式</td>
<td align="left">HTTP/1.1 RFC 7231, 6.5.13 节</td>
</tr>
<tr>
<td align="left"><code>416</code></td>
<td align="left"><code>REQUESTED_RANGE_NOT_SATISFIABLE</code></td>
<td align="left">HTTP/1.1 Range Requests RFC 7233, 4.4 节</td>
</tr>
<tr>
<td align="left"><code>417</code></td>
<td align="left"><code>EXPECTATION_FAILED</code>：期望失败</td>
<td align="left">HTTP/1.1 RFC 7231, 6.5.14 节</td>
</tr>
<tr>
<td align="left"><code>418</code></td>
<td align="left"><code>IM_A_TEAPOT</code></td>
<td align="left">HTCPCP/1.0 <a href="https://tools.ietf.org/html/rfc2324.html" target="_blank" rel="noopener"><strong>RFC 2324</strong></a>, Section 2.3.2</td>
</tr>
<tr>
<td align="left"><code>421</code></td>
<td align="left"><code>MISDIRECTED_REQUEST</code></td>
<td align="left">HTTP/2 <a href="https://tools.ietf.org/html/rfc7540.html" target="_blank" rel="noopener"><strong>RFC 7540</strong></a>, 9.1.2 节</td>
</tr>
<tr>
<td align="left"><code>422</code></td>
<td align="left"><code>UNPROCESSABLE_ENTITY</code>：可加工实体</td>
<td align="left">WebDAV RFC 4918, 11.2 节</td>
</tr>
<tr>
<td align="left"><code>423</code></td>
<td align="left"><code>LOCKED</code>：锁着</td>
<td align="left">WebDAV RFC 4918, 11.3 节</td>
</tr>
<tr>
<td align="left"><code>424</code></td>
<td align="left"><code>FAILED_DEPENDENCY</code>：失败的依赖</td>
<td align="left">WebDAV RFC 4918, 11.4 节</td>
</tr>
<tr>
<td align="left"><code>425</code></td>
<td align="left"><code>TOO_EARLY</code></td>
<td align="left">使用 HTTP <a href="https://tools.ietf.org/html/rfc8470.html" target="_blank" rel="noopener"><strong>RFC 8470</strong></a> 中的早期数据</td>
</tr>
<tr>
<td align="left"><code>426</code></td>
<td align="left"><code>UPGRADE_REQUIRED</code>：升级需要</td>
<td align="left">HTTP/1.1 RFC 7231, 6.5.15 节</td>
</tr>
<tr>
<td align="left"><code>428</code></td>
<td align="left"><code>PRECONDITION_REQUIRED</code>：先决条件要求</td>
<td align="left">Additional HTTP Status Codes RFC 6585</td>
</tr>
<tr>
<td align="left"><code>429</code></td>
<td align="left"><code>TOO_MANY_REQUESTS</code>：太多的请求</td>
<td align="left">Additional HTTP Status Codes RFC 6585</td>
</tr>
<tr>
<td align="left"><code>431</code></td>
<td align="left"><code>REQUEST_HEADER_FIELDS_TOO_LARGE</code>：请求头太大</td>
<td align="left">Additional HTTP Status Codes RFC 6585</td>
</tr>
<tr>
<td align="left"><code>451</code></td>
<td align="left"><code>UNAVAILABLE_FOR_LEGAL_REASONS</code></td>
<td align="left">HTTP 状态码用于报告法律障碍 <a href="https://tools.ietf.org/html/rfc7725.html" target="_blank" rel="noopener"><strong>RFC 7725</strong></a></td>
</tr>
<tr>
<td align="left"><code>500</code></td>
<td align="left"><code>INTERNAL_SERVER_ERROR</code>：内部服务错误</td>
<td align="left">HTTP/1.1 RFC 7231, 6.6.1 节</td>
</tr>
<tr>
<td align="left"><code>501</code></td>
<td align="left"><code>NOT_IMPLEMENTED</code>：不可执行</td>
<td align="left">HTTP/1.1 RFC 7231, 6.6.2 节</td>
</tr>
<tr>
<td align="left"><code>502</code></td>
<td align="left"><code>BAD_GATEWAY</code>：无效网关</td>
<td align="left">HTTP/1.1 RFC 7231, 6.6.3 节</td>
</tr>
<tr>
<td align="left"><code>503</code></td>
<td align="left"><code>SERVICE_UNAVAILABLE</code>：服务不可用</td>
<td align="left">HTTP/1.1 RFC 7231, 6.6.4 节</td>
</tr>
<tr>
<td align="left"><code>504</code></td>
<td align="left"><code>GATEWAY_TIMEOUT</code>：网关超时</td>
<td align="left">HTTP/1.1 RFC 7231, 6.6.5 节</td>
</tr>
<tr>
<td align="left"><code>505</code></td>
<td align="left"><code>HTTP_VERSION_NOT_SUPPORTED</code>：HTTP版本不支持</td>
<td align="left">HTTP/1.1 RFC 7231, 6.6.6 节</td>
</tr>
<tr>
<td align="left"><code>506</code></td>
<td align="left"><code>VARIANT_ALSO_NEGOTIATES</code>：服务器存在内部配置错误</td>
<td align="left">透明内容协商在： HTTP <a href="https://tools.ietf.org/html/rfc2295.html" target="_blank" rel="noopener"><strong>RFC 2295</strong></a>, 8.1 节（实验性）</td>
</tr>
<tr>
<td align="left"><code>507</code></td>
<td align="left"><code>INSUFFICIENT_STORAGE</code>：存储不足</td>
<td align="left">WebDAV RFC 4918, 11.5 节</td>
</tr>
<tr>
<td align="left"><code>508</code></td>
<td align="left"><code>LOOP_DETECTED</code>：循环检测</td>
<td align="left">WebDAV Binding Extensions RFC 5842, 7.2 节（实验性）</td>
</tr>
<tr>
<td align="left"><code>510</code></td>
<td align="left"><code>NOT_EXTENDED</code>：不扩展</td>
<td align="left">WebDAV Binding Extensions RFC 5842, 7.2 节（实验性）</td>
</tr>
<tr>
<td align="left"><code>511</code></td>
<td align="left"><code>NETWORK_AUTHENTICATION_REQUIRED</code>：要求网络身份验证</td>
<td align="left">Additional HTTP Status Codes <a href="https://tools.ietf.org/html/rfc6585.html" target="_blank" rel="noopener"><strong>RFC 6585</strong></a>, 6 节</td>
</tr>
</tbody></table>
<p>为了保持向后兼容性，枚举值也以常量形式出现在 <code>http.client</code> 模块中，。 枚举名等于常量名 (例如 <code>http.HTTPStatus.OK</code> 也可以是 <code>http.client.OK</code>)。</p>
<p>在 3.7 版更改: 添加了 <code>421 MISDIRECTED_REQUEST</code> 状态码。</p>
<p>3.8 新版功能: 添加了 <code>451 UNAVAILABLE_FOR_LEGAL_REASONS</code> 状态码。</p>
<p>3.9 新版功能: 增加了 <code>103 EARLY_HINTS</code>, <code>418 IM_A_TEAPOT</code> 和 <code>425 TOO_EARLY</code> 状态码</p>
<h2 id="ftplib-—-FTP-协议客户端"><a href="#ftplib-—-FTP-协议客户端" class="headerlink" title="ftplib —- FTP 协议客户端"></a><code>ftplib</code> —- FTP 协议客户端</h2><p><strong>源代码：</strong> <a href="https://github.com/python/cpython/tree/3.10/Lib/ftplib.py" target="_blank" rel="noopener">Lib/ftplib.py</a></p>
<hr>
<p>本模块定义了 <code>FTP</code> 类和一些相关项目。 <code>FTP</code> 类实现了 FTP 协议的客户端。 你可以用这个类来编写执行各种自动化 FTP 任务的 Python 程序，例如镜像其他 FTP 服务器等。 它还被 <code>urllib.request</code> 模块用来处理使用 FTP 的 URL。 有关 FTP (文件传输协议) 的更多信息，请参阅 <a href="https://tools.ietf.org/html/rfc959.html" target="_blank" rel="noopener"><strong>RFC 959</strong></a>。</p>
<p>默认编码为 UTF-8，遵循 <a href="https://tools.ietf.org/html/rfc2640.html" target="_blank" rel="noopener"><strong>RFC 2640</strong></a>。</p>
<p>以下是使用 <code>ftplib</code> 模块的会话示例:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> ftplib <span class="token keyword">import</span> FTP
<span class="token operator">>></span><span class="token operator">></span> ftp <span class="token operator">=</span> FTP<span class="token punctuation">(</span><span class="token string">'ftp.us.debian.org'</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># connect to host, default port</span>
<span class="token operator">>></span><span class="token operator">></span> ftp<span class="token punctuation">.</span>login<span class="token punctuation">(</span><span class="token punctuation">)</span>                     <span class="token comment" spellcheck="true"># user anonymous, passwd anonymous@</span>
<span class="token string">'230 Login successful.'</span>
<span class="token operator">>></span><span class="token operator">></span> ftp<span class="token punctuation">.</span>cwd<span class="token punctuation">(</span><span class="token string">'debian'</span><span class="token punctuation">)</span>               <span class="token comment" spellcheck="true"># change into "debian" directory</span>
<span class="token string">'250 Directory successfully changed.'</span>
<span class="token operator">>></span><span class="token operator">></span> ftp<span class="token punctuation">.</span>retrlines<span class="token punctuation">(</span><span class="token string">'LIST'</span><span class="token punctuation">)</span>           <span class="token comment" spellcheck="true"># list directory contents</span>
<span class="token operator">-</span>rw<span class="token operator">-</span>rw<span class="token operator">-</span>r<span class="token operator">-</span><span class="token operator">-</span>    <span class="token number">1</span> <span class="token number">1176</span>     <span class="token number">1176</span>         <span class="token number">1063</span> Jun <span class="token number">15</span> <span class="token number">10</span><span class="token punctuation">:</span><span class="token number">18</span> README
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
drwxr<span class="token operator">-</span>sr<span class="token operator">-</span>x    <span class="token number">5</span> <span class="token number">1176</span>     <span class="token number">1176</span>         <span class="token number">4096</span> Dec <span class="token number">19</span>  <span class="token number">2000</span> pool
drwxr<span class="token operator">-</span>sr<span class="token operator">-</span>x    <span class="token number">4</span> <span class="token number">1176</span>     <span class="token number">1176</span>         <span class="token number">4096</span> Nov <span class="token number">17</span>  <span class="token number">2008</span> project
drwxr<span class="token operator">-</span>xr<span class="token operator">-</span>x    <span class="token number">3</span> <span class="token number">1176</span>     <span class="token number">1176</span>         <span class="token number">4096</span> Oct <span class="token number">10</span>  <span class="token number">2012</span> tools
<span class="token string">'226 Directory send OK.'</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">with</span> open<span class="token punctuation">(</span><span class="token string">'README'</span><span class="token punctuation">,</span> <span class="token string">'wb'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> fp<span class="token punctuation">:</span>
<span class="token operator">>></span><span class="token operator">></span>     ftp<span class="token punctuation">.</span>retrbinary<span class="token punctuation">(</span><span class="token string">'RETR README'</span><span class="token punctuation">,</span> fp<span class="token punctuation">.</span>write<span class="token punctuation">)</span>
<span class="token string">'226 Transfer complete.'</span>
<span class="token operator">>></span><span class="token operator">></span> ftp<span class="token punctuation">.</span>quit<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token string">'221 Goodbye.'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这个模块定义了以下内容：</p>
<p><em>class</em> <code>ftplib.FTP</code>(<em>host=’’</em>, <em>user=’’</em>, <em>passwd=’’</em>, <em>acct=’’</em>, <em>timeout=None</em>, <em>source_address=None</em>, <em>**,</em> encoding=’utf-8’*)</p>
<p>返回一个 <code>FTP</code> 类的新实例。当传入 <em>host</em> 时，将调用 <code>connect(host)</code> 方法。当传入 <em>user</em> 时，将额外调用 <code>login(user, passwd, acct)</code> 方法（其中 <em>passwd</em> 和 <em>acct</em> 若没有传入则默认为空字符串）。可选参数 <em>timeout</em> 指定阻塞操作（如连接尝试）的超时（以秒为单位，如果未指定超时，将使用全局默认超时设置）。<em>source_address</em> 是一个 2 元组 <code>(host, port)</code>，套接字在连接前绑定它，作为其源地址。<em>encoding</em> 参数指定目录和文件名的编码。</p>
<p><code>FTP</code> 类支持 <code>with</code> 语句，例如：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> ftplib <span class="token keyword">import</span> FTP
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">with</span> FTP<span class="token punctuation">(</span><span class="token string">"ftp1.at.proftpd.org"</span><span class="token punctuation">)</span> <span class="token keyword">as</span> ftp<span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     ftp<span class="token punctuation">.</span>login<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     ftp<span class="token punctuation">.</span>dir<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> 
<span class="token string">'230 Anonymous login ok, restrictions apply.'</span>
dr<span class="token operator">-</span>xr<span class="token operator">-</span>xr<span class="token operator">-</span>x   <span class="token number">9</span> ftp      ftp           <span class="token number">154</span> May  <span class="token number">6</span> <span class="token number">10</span><span class="token punctuation">:</span><span class="token number">43</span> <span class="token punctuation">.</span>
dr<span class="token operator">-</span>xr<span class="token operator">-</span>xr<span class="token operator">-</span>x   <span class="token number">9</span> ftp      ftp           <span class="token number">154</span> May  <span class="token number">6</span> <span class="token number">10</span><span class="token punctuation">:</span><span class="token number">43</span> <span class="token punctuation">.</span><span class="token punctuation">.</span>
dr<span class="token operator">-</span>xr<span class="token operator">-</span>xr<span class="token operator">-</span>x   <span class="token number">5</span> ftp      ftp          <span class="token number">4096</span> May  <span class="token number">6</span> <span class="token number">10</span><span class="token punctuation">:</span><span class="token number">43</span> CentOS
dr<span class="token operator">-</span>xr<span class="token operator">-</span>xr<span class="token operator">-</span>x   <span class="token number">3</span> ftp      ftp            <span class="token number">18</span> Jul <span class="token number">10</span>  <span class="token number">2008</span> Fedora
<span class="token operator">>></span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在 3.2 版更改: 添加了对 <code>with</code> 语句的支持。</p>
<p>在 3.3 版更改: 添加了 <em>source_address</em> 参数。</p>
<p>在 3.9 版更改: 如果 <em>timeout</em> 参数设置为 0，创建非阻塞套接字时，它将引发 <code>ValueError</code> 来阻止该操作。添加了 <em>encoding</em> 参数，且为了遵循 <a href="https://tools.ietf.org/html/rfc2640.html" target="_blank" rel="noopener"><strong>RFC 2640</strong></a>，该参数默认值从 Latin-1 改为了 UTF-8。</p>
<p><em>class</em> <code>ftplib.FTP_TLS</code>(<em>host=’’</em>, <em>user=’’</em>, <em>passwd=’’</em>, <em>acct=’’</em>, <em>keyfile=None</em>, <em>certfile=None</em>, <em>context=None</em>, <em>timeout=None</em>, <em>source_address=None</em>, <em>**,</em> encoding=’utf-8’*)</p>
<p>一个 <code>FTP</code> 的子类，它为 FTP 添加了 TLS 支持，如 <a href="https://tools.ietf.org/html/rfc4217.html" target="_blank" rel="noopener"><strong>RFC 4217</strong></a> 所述。它将像通常一样连接到 21 端口，暗中保护在身份验证前的 FTP 控制连接。而保护数据连接需要用户明确调用 <code>prot_p()</code> 方法。<em>context</em> 是一个 <code>ssl.SSLContext</code> 对象，该对象可以将 SSL 配置选项、证书和私钥打包放入一个单独的（可以长久存在的）结构中。</p>
<p><em>keyfile</em> 和 <em>certfile</em> 是可以代替 <em>context</em> 的传统方案，它们可以分别指向 PEM 格式的私钥和证书链文件，用于进行 SSL 连接。</p>
<p>3.2 新版功能.</p>
<p>在 3.3 版更改: 添加了 <em>source_address</em> 参数。</p>
<p>在 3.4 版更改: 本类现在支持使用 <code>ssl.SSLContext.check_hostname</code> 和 <em>服务器名称指示</em> 进行主机名检查。</p>
<p>3.6 版后已移除: <em>keyfile</em> 和 <em>certfile</em> 已弃用并转而推荐 <em>context</em>。 请改用 <code>ssl.SSLContext.load_cert_chain()</code> 或让 <code>ssl.create_default_context()</code> 为你选择系统所信任的 CA 证书。</p>
<p>在 3.9 版更改: 如果 <em>timeout</em> 参数设置为 0，创建非阻塞套接字时，它将引发 <code>ValueError</code> 来阻止该操作。添加了 <em>encoding</em> 参数，且为了遵循 <a href="https://tools.ietf.org/html/rfc2640.html" target="_blank" rel="noopener"><strong>RFC 2640</strong></a>，该参数默认值从 Latin-1 改为了 UTF-8。</p>
<p>以下是使用 <code>FTP_TLS</code> 类的会话示例:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> ftps <span class="token operator">=</span> FTP_TLS<span class="token punctuation">(</span><span class="token string">'ftp.pureftpd.org'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> ftps<span class="token punctuation">.</span>login<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token string">'230 Anonymous user logged in'</span>
<span class="token operator">>></span><span class="token operator">></span> ftps<span class="token punctuation">.</span>prot_p<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token string">'200 Data protection level set to "private"'</span>
<span class="token operator">>></span><span class="token operator">></span> ftps<span class="token punctuation">.</span>nlst<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token string">'6jack'</span><span class="token punctuation">,</span> <span class="token string">'OpenBSD'</span><span class="token punctuation">,</span> <span class="token string">'antilink'</span><span class="token punctuation">,</span> <span class="token string">'blogbench'</span><span class="token punctuation">,</span> <span class="token string">'bsdcam'</span><span class="token punctuation">,</span> <span class="token string">'clockspeed'</span><span class="token punctuation">,</span> <span class="token string">'djbdns-jedi'</span><span class="token punctuation">,</span> <span class="token string">'docs'</span><span class="token punctuation">,</span> <span class="token string">'eaccelerator-jedi'</span><span class="token punctuation">,</span> <span class="token string">'favicon.ico'</span><span class="token punctuation">,</span> <span class="token string">'francotone'</span><span class="token punctuation">,</span> <span class="token string">'fugu'</span><span class="token punctuation">,</span> <span class="token string">'ignore'</span><span class="token punctuation">,</span> <span class="token string">'libpuzzle'</span><span class="token punctuation">,</span> <span class="token string">'metalog'</span><span class="token punctuation">,</span> <span class="token string">'minidentd'</span><span class="token punctuation">,</span> <span class="token string">'misc'</span><span class="token punctuation">,</span> <span class="token string">'mysql-udf-global-user-variables'</span><span class="token punctuation">,</span> <span class="token string">'php-jenkins-hash'</span><span class="token punctuation">,</span> <span class="token string">'php-skein-hash'</span><span class="token punctuation">,</span> <span class="token string">'php-webdav'</span><span class="token punctuation">,</span> <span class="token string">'phpaudit'</span><span class="token punctuation">,</span> <span class="token string">'phpbench'</span><span class="token punctuation">,</span> <span class="token string">'pincaster'</span><span class="token punctuation">,</span> <span class="token string">'ping'</span><span class="token punctuation">,</span> <span class="token string">'posto'</span><span class="token punctuation">,</span> <span class="token string">'pub'</span><span class="token punctuation">,</span> <span class="token string">'public'</span><span class="token punctuation">,</span> <span class="token string">'public_keys'</span><span class="token punctuation">,</span> <span class="token string">'pure-ftpd'</span><span class="token punctuation">,</span> <span class="token string">'qscan'</span><span class="token punctuation">,</span> <span class="token string">'qtc'</span><span class="token punctuation">,</span> <span class="token string">'sharedance'</span><span class="token punctuation">,</span> <span class="token string">'skycache'</span><span class="token punctuation">,</span> <span class="token string">'sound'</span><span class="token punctuation">,</span> <span class="token string">'tmp'</span><span class="token punctuation">,</span> <span class="token string">'ucarp'</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><em>exception</em> <code>ftplib.error_reply</code></p>
<p>从服务器收到意外答复时，将引发本异常。</p>
<p><em>exception</em> <code>ftplib.error_temp</code></p>
<p>收到表示临时错误的错误代码（响应代码在 400—499 范围内）时，将引发本异常。</p>
<p><em>exception</em> <code>ftplib.error_perm</code></p>
<p>收到表示永久性错误的错误代码（响应代码在 500—599 范围内）时，将引发本异常。</p>
<p><em>exception</em> <code>ftplib.error_proto</code></p>
<p>从服务器收到不符合 FTP 响应规范的答复，比如以数字 1—5 开头时，将引发本异常。</p>
<pre><code>ftplib.all_errors</code></pre><p>所有异常的集合（一个元组），由于 FTP 连接出现问题（并非调用者的编码错误），<code>FTP</code> 实例的方法可能会引发这些异常。该集合包括上面列出的四个异常以及 <code>OSError</code> 和 <code>EOFError</code>。</p>
<p>参见</p>
<p><code>netrc</code> 模块</p>
<p><code>.netrc</code> 文件格式解析器。FTP 客户端在响应用户之前，通常使用 <code>.netrc</code> 文件来加载用户认证信息。</p>
<h3 id="FTP-对象"><a href="#FTP-对象" class="headerlink" title="FTP 对象"></a>FTP 对象</h3><p>一些方法可以按照两种方式来使用：一种处理文本文件，另一种处理二进制文件。方法名称与相应的命令相同，文本版中命令后面跟着 <code>lines</code>，二进制版中命令后面跟着 <code>binary</code>。</p>
<p><code>FTP</code> 实例具有下列方法:</p>
<p><code>FTP.set_debuglevel</code>(<em>level</em>)</p>
<p>设置实例的调试级别，它控制着调试信息的数量。默认值 <code>0</code> 不产生调试信息。值 <code>1</code> 产生中等数量的调试信息，通常每个请求产生一行。大于或等于 <code>2</code> 的值产生的调试信息最多，FTP 控制连接上发送和接收的每一行都将被记录下来。</p>
<p><code>FTP.connect</code>(<em>host=’’</em>, <em>port=0</em>, <em>timeout=None</em>, <em>source_address=None</em>)</p>
<p>连接到给定的主机和端口。默认端口号由 FTP 协议规范规定，为 <code>21</code>。偶尔才需要指定其他端口号。每个实例只应调用一次本函数，如果在创建实例时就传入了 host，则根本不应调用它。所有其他方法只能在建立连接后使用。可选参数 <em>timeout</em> 指定连接尝试的超时（以秒为单位）。如果没有传入 <em>timeout<em>，将使用全局默认超时设置。</em>source_address</em> 是一个 2 元组 <code>(host, port)</code>，套接字在连接前绑定它，作为其源地址。</p>
<p>引发一个 审计事件 <code>ftplib.connect</code>，附带参数 <code>self</code>, <code>host</code>, <code>port</code>。</p>
<p>在 3.3 版更改: 添加了 <em>source_address</em> 参数。</p>
<p><code>FTP.getwelcome</code>()</p>
<p>返回服务器发送的欢迎消息，作为连接开始的回复。（该消息有时包含与用户有关的免责声明或帮助信息。）</p>
<p><code>FTP.login</code>(<em>user=’anonymous’</em>, <em>passwd=’’</em>, <em>acct=’’</em>)</p>
<p>以 <em>user</em> 的身份登录。<em>passwd</em> 和 <em>acct</em> 是可选参数，默认为空字符串。如果没有指定 <em>user*，则默认为 <code>'anonymous'</code>。如果 *user</em> 为 <code>'anonymous'</code>，那么默认的 <em>passwd</em> 是 <code>'anonymous@'</code>。连接建立后，每个实例只应调用一次本函数；如果在创建实例时传入了 host 和 user，则完全不应该调用本函数。在客户端登录后，才允许执行大多数 FTP 命令。<em>acct</em> 参数提供记账信息 (“accounting information”)；仅少数系统实现了该特性。</p>
<p><code>FTP.abort</code>()</p>
<p>中止正在进行的文件传输。本方法并不总是有效，但值得一试。</p>
<p><code>FTP.sendcmd</code>(<em>cmd</em>)</p>
<p>将一条简单的命令字符串发送到服务器，返回响应的字符串。</p>
<p>引发一个 审计事件 <code>ftplib.sendcmd</code>，附带参数 <code>self</code>, <code>cmd</code>。</p>
<p><code>FTP.voidcmd</code>(<em>cmd</em>)</p>
<p>将一条简单的命令字符串发送到服务器，并处理响应内容。如果收到的响应代码表示的是成功（代码范围 200—299），则不返回任何内容。否则将引发 <code>error_reply</code>。</p>
<p>引发一个 审计事件 <code>ftplib.sendcmd</code>，附带参数 <code>self</code>, <code>cmd</code>。</p>
<p><code>FTP.retrbinary</code>(<em>cmd</em>, <em>callback</em>, <em>blocksize=8192</em>, <em>rest=None</em>)</p>
<p>以二进制传输模式下载文件。<em>cmd</em> 应为恰当的 <code>RETR</code> 命令：<code>'RETR 文件名'</code>。<em>callback</em> 函数会在收到每个数据块时调用，传入的参数是表示数据块的一个字节。为执行实际传输，创建了底层套接字对象，可选参数 <em>blocksize</em> 指定了读取该对象时的最大块大小（这也是传入 <em>callback</em> 的数据块的最大大小）。已经选择了合理的默认值。<em>rest</em> 的含义与 <code>transfercmd()</code> 方法中的含义相同。</p>
<p><code>FTP.retrlines</code>(<em>cmd</em>, <em>callback=None</em>)</p>
<p>按照初始化时的 <em>encoding</em> 参数指定的编码，获取文件或目录列表。<em>cmd</em> 应是恰当的 <code>RETR</code> 命令，也可以是诸如 <code>LIST</code> 或 <code>NLST</code> 之类的命令（通常就只是字符串 <code>'LIST'</code>）。<code>LIST</code> 获取文件列表以及那些文件的信息。<code>NLST</code> 获取文件名称列表。<em>callback</em> 函数会在每一行都调用，参数就是包含一行的字符串，删除了尾部的 CRLF。默认的 <em>callback</em> 会把行打印到 <code>sys.stdout</code>。</p>
<p><code>FTP.set_pasv</code>(<em>val</em>)</p>
<p>如果 <em>val</em> 为 true，则打开“被动”模式，否则禁用被动模式。默认下被动模式是打开的。</p>
<p><code>FTP.storbinary</code>(<em>cmd</em>, <em>fp</em>, <em>blocksize=8192</em>, <em>callback=None</em>, <em>rest=None</em>)</p>
<p>以二进制传输模式存储文件。 <em>cmd</em> 应为恰当的 <code>STOR</code> 命令: <code>"STOR filename"</code>。<em>fp</em> 是一个 文件对象 (以二进制模式打开)，将使用它的 <code>read()</code> 方法读取它，用于提供要存储的数据，直到遇到 EOF，读取时的块大小为 <em>blocksize*。 参数 *blocksize</em> 的默认值为 8192。 可选参数 <em>callback</em> 是单参数函数，在每个数据块发送后都会以该数据块作为参数来调用它。<em>rest</em> 的含义与 <code>transfercmd()</code> 方法中的含义相同。</p>
<p>在 3.2 版更改: 添加了 <em>rest</em> 参数。</p>
<p><code>FTP.storlines</code>(<em>cmd</em>, <em>fp</em>, <em>callback=None</em>)</p>
<p>以文本行模式存储文件。<em>cmd</em> 应为恰当的 <code>STOR</code> 命令 。 <em>fp</em> 是一个 文件对象 (以二进制模式打开)，将使用它的 <code>readline()</code> 方法读取它的每一行，用于提供要存储的数据，直到遇到 EOF。 可选参数 <em>callback</em> 是单参数函数，在每行发送后都会以该行作为参数来调用它。</p>
<p><code>FTP.transfercmd</code>(<em>cmd</em>, <em>rest=None</em>)</p>
<p>在 FTP 数据连接上开始传输数据。如果传输处于活动状态，传输命令由 <em>cmd</em> 指定，需发送 <code>EPRT</code> 或 <code>PORT</code> 命令，然后接受连接 (accept)。如果服务器是被动服务器，需发送 <code>EPSV</code> 或 <code>PASV</code> 命令，连接到服务器 (connect)，然后启动传输命令。两种方式都将返回用于连接的套接字。</p>
<p>如果传入了可选参数 <em>rest*，则一条 <code>REST</code> 命令会被发送到服务器，并以 *rest</em> 作为参数。<em>rest</em> 通常表示请求文件中的字节偏移量，它告诉服务器重新开始发送文件的字节，从请求的偏移量处开始，跳过起始字节。但是请注意，<code>transfercmd()</code> 方法会将 <em>rest</em> 转换为字符串，但是不检查字符串的内容，转换用的编码是在初始化时指定的 <em>encoding</em> 参数。如果服务器无法识别 <code>REST</code> 命令，将引发 <code>error_reply</code> 异常。如果发生这种情况，只需不带 <em>rest</em> 参数调用 <code>transfercmd()</code>。</p>
<p><code>FTP.ntransfercmd</code>(<em>cmd</em>, <em>rest=None</em>)</p>
<p>类似于 <code>transfercmd()</code>，但返回一个元组，包括数据连接和数据的预计大小。如果预计大小无法计算，则返回的预计大小为 <code>None</code>。<em>cmd</em> 和 <em>rest</em> 的含义与 <code>transfercmd()</code> 中的相同。</p>
<p><code>FTP.mlsd</code>(<em>path=’’</em>, <em>facts=[]</em>)</p>
<p>使用 <code>MLSD</code> 命令以标准格式列出目录内容 (<a href="https://tools.ietf.org/html/rfc3659.html" target="_blank" rel="noopener"><strong>RFC 3659</strong></a>)。如果省略 <em>path</em> 则使用当前目录。<em>facts</em> 是字符串列表，表示所需的信息类型（如 <code>["type", "size", "perm"]</code>）。返回一个生成器对象，每个在 path 中找到的文件都将在该对象中生成两个元素的元组。第一个元素是文件名，第二个元素是该文件的 facts 的字典。该字典的内容受 <em>facts</em> 参数限制，但不能保证服务器会返回所有请求的 facts。</p>
<p>3.3 新版功能.</p>
<p><code>FTP.nlst</code>(<em>argument</em>[, <em>…</em>])</p>
<p>返回一个文件名列表，文件名由 <code>NLST</code> 命令返回。可选参数 <em>argument</em> 是待列出的目录（默认为当前服务器目录）。可以使用多个参数，将非标准选项传递给 <code>NLST</code> 命令。</p>
<p>注解</p>
<p>如果目标服务器支持相关命令，那么 <code>mlsd()</code> 提供的 API 更好。</p>
<p><code>FTP.dir</code>(<em>argument</em>[, <em>…</em>])</p>
<p>生成目录列表，即 <code>LIST</code> 命令所返回的结果，并将其打印到标准输出。可选参数 <em>argument</em> 是待列出的目录（默认为当前服务器目录）。可以使用多个参数，将非标准选项传递给 <code>LIST</code> 命令。如果最后一个参数是一个函数，它将被用作 <em>callback</em> 函数，与 <code>retrlines()</code> 中的相同，默认将打印到 <code>sys.stdout</code>。本方法返回 <code>None</code>。</p>
<p>注解</p>
<p>如果目标服务器支持相关命令，那么 <code>mlsd()</code> 提供的 API 更好。</p>
<p><code>FTP.rename</code>(<em>fromname</em>, <em>toname</em>)</p>
<p>将服务器上的文件 <em>fromname</em> 重命名为 <em>toname</em>。</p>
<p><code>FTP.delete</code>(<em>filename</em>)</p>
<p>将服务器上名为 <em>filename</em> 的文件删除。如果删除成功，返回响应文本，如果删除失败，在权限错误时引发 <code>error_perm</code>，在其他错误时引发 <code>error_reply</code>。</p>
<p><code>FTP.cwd</code>(<em>pathname</em>)</p>
<p>设置服务器端的当前目录。</p>
<p><code>FTP.mkd</code>(<em>pathname</em>)</p>
<p>在服务器上创建一个新目录。</p>
<p><code>FTP.pwd</code>()</p>
<p>返回服务器上当前目录的路径。</p>
<p><code>FTP.rmd</code>(<em>dirname</em>)</p>
<p>将服务器上名为 <em>dirname</em> 的目录删除。</p>
<p><code>FTP.size</code>(<em>filename</em>)</p>
<p>请求服务器上名为 <em>filename</em> 的文件大小。成功后以整数返回文件大小，未成功则返回 <code>None</code>。注意，<code>SIZE</code> 不是标准命令，但通常许多服务器的实现都支持该命令。</p>
<p><code>FTP.quit</code>()</p>
<p>向服务器发送 <code>QUIT</code> 命令并关闭连接。 这是关闭一个连接的“礼貌”方式，但是如果服务器对 <code>QUIT</code> 命令的响应带有错误消息则这会引发一个异常。 这意味着对 <code>close()</code> 方法的调用，它将使得 <code>FTP</code> 实例对后继调用无效（见下文）。</p>
<p><code>FTP.close</code>()</p>
<p>单方面关闭连接。 这不该被应用于已经关闭的连接，例如成功调用 <code>quit()</code> 之后的连接。 在此调用之后 <code>FTP</code> 实例不应被继续使用（在调用 <code>close()</code> 或 <code>quit()</code> 之后你不能通过再次发起调用 <code>login()</code> 方法重新打开连接）。</p>
<h3 id="FTP-TLS-对象"><a href="#FTP-TLS-对象" class="headerlink" title="FTP_TLS 对象"></a>FTP_TLS 对象</h3><p><code>FTP_TLS</code> 类继承自 <code>FTP</code>，它定义了下述其他对象：</p>
<pre><code>FTP_TLS.ssl_version</code></pre><p>欲采用的 SSL 版本（默认为 <code>ssl.PROTOCOL_SSLv23</code>）。</p>
<p><code>FTP_TLS.auth</code>()</p>
<p>通过使用 TLS 或 SSL 来设置一个安全控制连接，具体取决于 <code>ssl_version</code> 属性是如何设置的。</p>
<p>在 3.4 版更改: 此方法现在支持使用 <code>ssl.SSLContext.check_hostname</code> 和 <em>服务器名称指示</em> 进行主机名检查。</p>
<p><code>FTP_TLS.ccc</code>()</p>
<p>将控制通道回复为纯文本。 这适用于发挥知道如何使用非安全 FTP 处理 NAT 而无需打开固定端口的防火墙的优势。</p>
<p>3.3 新版功能.</p>
<p><code>FTP_TLS.prot_p</code>()</p>
<p>设置加密数据连接。</p>
<p><code>FTP_TLS.prot_c</code>()</p>
<p>设置明文数据连接。</p>
<h2 id="poplib-—-POP3-协议客户端"><a href="#poplib-—-POP3-协议客户端" class="headerlink" title="poplib —- POP3 协议客户端"></a><code>poplib</code> —- POP3 协议客户端</h2><p><strong>源代码：</strong> <a href="https://github.com/python/cpython/tree/3.10/Lib/poplib.py" target="_blank" rel="noopener">Lib/poplib.py</a></p>
<hr>
<p>本模块定义了一个 <code>POP3</code> 类，该类封装了到 POP3 服务器的连接过程，并实现了 <a href="https://tools.ietf.org/html/rfc1939.html" target="_blank" rel="noopener"><strong>RFC 1939</strong></a> 中定义的协议。<code>POP3</code> 类同时支持 <a href="https://tools.ietf.org/html/rfc1939.html" target="_blank" rel="noopener"><strong>RFC 1939</strong></a> 中最小的和可选的命令集。<code>POP3</code> 类还支持在 <a href="https://tools.ietf.org/html/rfc2595.html" target="_blank" rel="noopener"><strong>RFC 2595</strong></a> 中引入的 <code>STLS</code> 命令，用于在已建立的连接上启用加密通信。</p>
<p>本模块额外提供一个 <code>POP3_SSL</code> 类，在连接到 POP3 服务器时，该类为使用 SSL 作为底层协议层提供了支持。</p>
<p>注意，尽管 POP3 具有广泛的支持，但它已经过时。POP3 服务器的实现质量差异很大，而且大多很糟糕。如果邮件服务器支持 IMAP，则最好使用 <code>imaplib.IMAP4</code> 类，因为 IMAP 服务器一般实现得更好。</p>
<p><code>poplib</code> 模块提供了两个类：</p>
<p><em>class</em> <code>poplib.POP3</code>(<em>host</em>, <em>port=POP3_PORT</em>[, <em>timeout</em>])</p>
<p>本类实现实际的 POP3 协议。实例初始化时，连接就会建立。如果省略 <em>port*，则使用标准 POP3 端口（110）。可选参数 *timeout</em> 指定连接尝试的超时时间（以秒为单位，如果未指定超时，将使用全局默认超时设置）。</p>
<p>引发一个 审计事件 <code>poplib.connect</code>，附带参数 <code>self</code>, <code>host</code>, <code>port</code>。</p>
<p>引发一个 审计事件 <code>poplib.putline</code>，附带参数 <code>self</code>, <code>line</code>。</p>
<p>在 3.9 版更改: 如果 <em>timeout</em> 参数设置为 0，创建非阻塞套接字时，它将引发 <code>ValueError</code> 来阻止该操作。</p>
<p><em>class</em> <code>poplib.POP3_SSL</code>(<em>host</em>, <em>port=POP3_SSL_PORT</em>, <em>keyfile=None</em>, <em>certfile=None</em>, <em>timeout=None</em>, <em>context=None</em>)</p>
<p>一个 <code>POP3</code> 的子类，它使用经 SSL 加密的套接字连接到服务器。如果端口 <em>port</em> 未指定，则使用 995，它是标准的 POP3-over-SSL 端口。<em>timeout</em> 的作用与 <code>POP3</code> 构造函数中的相同。<em>context</em> 是一个可选的 <code>ssl.SSLContext</code> 对象，该对象可以将 SSL 配置选项、证书和私钥打包放入一个单独的（可以长久存在的）结构中。</p>
<p><em>keyfile</em> 和 <em>certfile</em> 是可以代替 <em>context</em> 的传统方案，它们可以分别指向 PEM 格式的私钥和证书链文件，用于进行 SSL 连接。</p>
<p>引发一个 审计事件 <code>poplib.connect</code>，附带参数 <code>self</code>, <code>host</code>, <code>port</code>。</p>
<p>引发一个 审计事件 <code>poplib.putline</code>，附带参数 <code>self</code>, <code>line</code>。</p>
<p>在 3.2 版更改: 添加了 <em>context</em> 参数。</p>
<p>在 3.4 版更改: 本类现在支持使用 <code>ssl.SSLContext.check_hostname</code> 和 <em>服务器名称指示</em> 进行主机名检查。</p>
<p>3.6 版后已移除: <em>keyfile</em> 和 <em>certfile</em> 已弃用并转而推荐 <em>context</em>。 请改用 <code>ssl.SSLContext.load_cert_chain()</code> 或让 <code>ssl.create_default_context()</code> 为你选择系统所信任的 CA 证书。</p>
<p>在 3.9 版更改: 如果 <em>timeout</em> 参数设置为 0，创建非阻塞套接字时，它将引发 <code>ValueError</code> 来阻止该操作。</p>
<p>定义了一个异常，它是作为 <code>poplib</code> 模块的属性定义的：</p>
<p><em>exception</em> <code>poplib.error_proto</code></p>
<p>此模块的所有错误都将引发本异常（来自 <code>socket</code> 模块的错误不会被捕获）。异常的原因将以字符串的形式传递给构造函数。</p>
<p>参见</p>
<p><a href="http://www.catb.org/~esr/fetchmail/fetchmail-FAQ.html" target="_blank" rel="noopener">有关 Fetchmail 的常见问题</a></p>
<p><strong>fetchmail</strong> POP/IMAP 客户端的“常见问题”收集了 POP3 服务器之间的差异和 RFC 不兼容的信息，如果要编写基于 POP 协议的应用程序，这可能会很有用。</p>
<h3 id="POP3-对象"><a href="#POP3-对象" class="headerlink" title="POP3 对象"></a>POP3 对象</h3><p>所有 POP3 命令均以同名的方法表示，小写，大多数方法返回的是服务器发送的响应文本。</p>
<p><code>POP3</code> 实例具有下列方法：</p>
<p><code>POP3.set_debuglevel</code>(<em>level</em>)</p>
<p>设置实例的调试级别，它控制着调试信息的数量。默认值 <code>0</code> 不产生调试信息。值 <code>1</code> 产生中等数量的调试信息，通常每个请求产生一行。大于或等于 <code>2</code> 的值产生的调试信息最多，FTP 控制连接上发送和接收的每一行都将被记录下来。</p>
<p><code>POP3.getwelcome</code>()</p>
<p>返回 POP3 服务器发送的问候语字符串。</p>
<p><code>POP3.capa</code>()</p>
<p>查询服务器支持的功能，这些功能在 <a href="https://tools.ietf.org/html/rfc2449.html" target="_blank" rel="noopener"><strong>RFC 2449</strong></a> 中有说明。返回一个 <code>{'name': ['param'...]}</code> 形式的字典。</p>
<p>3.4 新版功能.</p>
<p><code>POP3.user</code>(<em>username</em>)</p>
<p>发送 user 命令，返回的响应应该指示需要一个密码。</p>
<p><code>POP3.pass_</code>(<em>password</em>)</p>
<p>发送密码，响应包括邮件数和邮箱大小。注意：在调用 <code>quit()</code> 前，服务器上的邮箱都是锁定的。</p>
<p><code>POP3.apop</code>(<em>user</em>, <em>secret</em>)</p>
<p>使用更安全的 APOP 身份验证登录到 POP3 服务器。</p>
<p><code>POP3.rpop</code>(<em>user</em>)</p>
<p>使用 RPOP 身份验证（类似于 Unix r-命令）登录到 POP3 服务器。</p>
<p><code>POP3.stat</code>()</p>
<p>获取邮箱状态。结果为 2 个整数组成的元组：<code>(message count, mailbox size)</code>。</p>
<p><code>POP3.list</code>([<em>which</em>])</p>
<p>请求消息列表，结果的形式为 <code>(response, ['mesg_num octets', ...], octets)</code>。如果设置了 <em>which</em>，它表示需要列出的消息。</p>
<p><code>POP3.retr</code>(<em>which</em>)</p>
<p>检索编号为 <em>which</em> 的整条消息，并设置其已读标志位。结果的形式为 <code>(response, ['line', ...], octets)</code>。</p>
<p><code>POP3.dele</code>(<em>which</em>)</p>
<p>将编号为 <em>which</em> 的消息标记为待删除。在多数服务器上，删除操作直到 QUIT 才会实际执行（主要例外是 Eudora QPOP，它在断开连接时执行删除，故意违反了 RFC）。</p>
<p><code>POP3.rset</code>()</p>
<p>移除邮箱中的所有待删除标记。</p>
<p><code>POP3.noop</code>()</p>
<p>什么都不做。可以用于保持活动状态。</p>
<p><code>POP3.quit</code>()</p>
<p>登出：提交更改，解除邮箱锁定，断开连接。</p>
<p><code>POP3.top</code>(<em>which</em>, <em>howmuch</em>)</p>
<p>检索编号为 <em>which</em> 的消息，范围是消息头加上消息头往后数 <em>howmuch</em> 行。结果的形式为 <code>(response, ['line', ...], octets)</code>。</p>
<p>本方法使用 POP3 TOP 命令，不同于 RETR 命令，它不设置邮件的已读标志位。不幸的是，TOP 在 RFC 中说明不清晰，且在小众的服务器软件中往往不可用。信任并使用它之前，请先手动对目标 POP3 服务器测试本方法。</p>
<p><code>POP3.uidl</code>(<em>which=None</em>)</p>
<p>返回消息摘要（唯一 ID）列表。如果指定了 <em>which</em>，那么结果将包含那条消息的唯一 ID，形式为 <code>'response mesgnum uid</code>，如果未指定，那么结果为列表 <code>(response, ['mesgnum uid', ...], octets)</code>。</p>
<p><code>POP3.utf8</code>()</p>
<p>尝试切换至 UTF-8 模式。成功则返回服务器的响应，失败则引发 <code>error_proto</code> 异常。在 <a href="https://tools.ietf.org/html/rfc6856.html" target="_blank" rel="noopener"><strong>RFC 6856</strong></a> 中有说明。</p>
<p>3.5 新版功能.</p>
<p><code>POP3.stls</code>(<em>context=None</em>)</p>
<p>在活动连接上开启 TLS 会话，在 <a href="https://tools.ietf.org/html/rfc2595.html" target="_blank" rel="noopener"><strong>RFC 2595</strong></a> 中有说明。仅在用户身份验证前允许这样做。</p>
<p><em>context</em> 参数是一个 <code>ssl.SSLContext</code> 对象，该对象可以将 SSL 配置选项、证书和私钥打包放入一个单独的（可以长久存在的）结构中。</p>
<p>此方法支持通过 <code>ssl.SSLContext.check_hostname</code> 和 <em>服务器名称指示</em>进行主机名检查。</p>
<p>3.4 新版功能.</p>
<p><code>POP3_SSL</code> 实例没有额外方法。该子类的接口与其父类的相同。</p>
<h3 id="POP3-示例"><a href="#POP3-示例" class="headerlink" title="POP3 示例"></a>POP3 示例</h3><p>以下是一个最短示例（不带错误检查），该示例将打开邮箱，检索并打印所有消息:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> getpass<span class="token punctuation">,</span> poplib
M <span class="token operator">=</span> poplib<span class="token punctuation">.</span>POP3<span class="token punctuation">(</span><span class="token string">'localhost'</span><span class="token punctuation">)</span>
M<span class="token punctuation">.</span>user<span class="token punctuation">(</span>getpass<span class="token punctuation">.</span>getuser<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
M<span class="token punctuation">.</span>pass_<span class="token punctuation">(</span>getpass<span class="token punctuation">.</span>getpass<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
numMessages <span class="token operator">=</span> len<span class="token punctuation">(</span>M<span class="token punctuation">.</span>list<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>numMessages<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">for</span> j <span class="token keyword">in</span> M<span class="token punctuation">.</span>retr<span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>模块的最后有一段测试，其中包含的用法示例更加广泛。</p>
<h2 id="imaplib-—-IMAP4-协议客户端"><a href="#imaplib-—-IMAP4-协议客户端" class="headerlink" title="imaplib —- IMAP4 协议客户端"></a><code>imaplib</code> —- IMAP4 协议客户端</h2><p><strong>源代码：</strong> <a href="https://github.com/python/cpython/tree/3.10/Lib/imaplib.py" target="_blank" rel="noopener">Lib/imaplib.py</a></p>
<hr>
<p>本模块定义了三个类： <code>IMAP4</code> 、 <code>IMAP4_SSL</code> 和 <code>IMAP4_stream</code> 。这三个类封装了与IMAP4服务器的连接并实现了 <a href="https://tools.ietf.org/html/rfc2060.html" target="_blank" rel="noopener"><strong>RFC 2060</strong></a> 当中定义的大多数IMAP4rev1客户端协议。其与IMAP4（ <a href="https://tools.ietf.org/html/rfc1730.html" target="_blank" rel="noopener"><strong>RFC 1730</strong></a> ）服务器后向兼容，但是 <code>STATUS</code> 指令在IMAP4中不支持。</p>
<p><code>imaplib</code> 模块提供了三个类，其中 <code>IMAP4</code> 是基类：</p>
<p><em>class</em> <code>imaplib.IMAP4</code>(<em>host=’’</em>, <em>port=IMAP4_PORT</em>, <em>timeout=None</em>)</p>
<p>This class implements the actual IMAP4 protocol. The connection is created and protocol version (IMAP4 or IMAP4rev1) is determined when the instance is initialized. If <em>host</em> is not specified, <code>''</code> (the local host) is used. If <em>port</em> is omitted, the standard IMAP4 port (143) is used. The optional <em>timeout</em> parameter specifies a timeout in seconds for the connection attempt. If timeout is not given or is None, the global default socket timeout is used.</p>
<p>The <code>IMAP4</code> class supports the <code>with</code> statement. When used like this, the IMAP4 <code>LOGOUT</code> command is issued automatically when the <code>with</code> statement exits. E.g.:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> imaplib <span class="token keyword">import</span> IMAP4
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">with</span> IMAP4<span class="token punctuation">(</span><span class="token string">"domain.org"</span><span class="token punctuation">)</span> <span class="token keyword">as</span> M<span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     M<span class="token punctuation">.</span>noop<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">(</span><span class="token string">'OK'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>b<span class="token string">'Nothing Accomplished. d25if65hy903weo.87'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在 3.5 版更改: 添加了对 <code>with</code> 语句的支持。</p>
<p>在 3.9 版更改: The optional <em>timeout</em> parameter was added.</p>
<p>Three exceptions are defined as attributes of the <code>IMAP4</code> class:</p>
<p><em>exception</em> <code>IMAP4.error</code></p>
<p>Exception raised on any errors. The reason for the exception is passed to the constructor as a string.</p>
<p><em>exception</em> <code>IMAP4.abort</code></p>
<p>IMAP4 server errors cause this exception to be raised. This is a sub-class of <code>IMAP4.error</code>. Note that closing the instance and instantiating a new one will usually allow recovery from this exception.</p>
<p><em>exception</em> <code>IMAP4.readonly</code></p>
<p>This exception is raised when a writable mailbox has its status changed by the server. This is a sub-class of <code>IMAP4.error</code>. Some other client now has write permission, and the mailbox will need to be re-opened to re-obtain write permission.</p>
<p>There’s also a subclass for secure connections:</p>
<p><em>class</em> <code>imaplib.IMAP4_SSL</code>(<em>host=’’</em>, <em>port=IMAP4_SSL_PORT</em>, <em>keyfile=None</em>, <em>certfile=None</em>, <em>ssl_context=None</em>, <em>timeout=None</em>)</p>
<p>This is a subclass derived from <code>IMAP4</code> that connects over an SSL encrypted socket (to use this class you need a socket module that was compiled with SSL support). If <em>host</em> is not specified, <code>''</code> (the local host) is used. If <em>port</em> is omitted, the standard IMAP4-over-SSL port (993) is used. <em>ssl_context</em> is a <code>ssl.SSLContext</code> object which allows bundling SSL configuration options, certificates and private keys into a single (potentially long-lived) structure. </p>
<p><em>keyfile</em> and <em>certfile</em> are a legacy alternative to <em>ssl_context</em> - they can point to PEM-formatted private key and certificate chain files for the SSL connection. Note that the <em>keyfile</em>/<em>certfile</em> parameters are mutually exclusive with <em>ssl_context</em>, a <code>ValueError</code> is raised if <em>keyfile</em>/<em>certfile</em> is provided along with <em>ssl_context</em>.</p>
<p>The optional <em>timeout</em> parameter specifies a timeout in seconds for the connection attempt. If timeout is not given or is None, the global default socket timeout is used.</p>
<p>在 3.3 版更改: <em>ssl_context</em> parameter was added.</p>
<p>在 3.4 版更改: 本类现在支持使用 <code>ssl.SSLContext.check_hostname</code> 和 <em>服务器名称指示</em> 进行主机名检查。</p>
<p>3.6 版后已移除: <em>keyfile</em> and <em>certfile</em> are deprecated in favor of <em>ssl_context</em>. Please use <code>ssl.SSLContext.load_cert_chain()</code> instead, or let <code>ssl.create_default_context()</code> select the system’s trusted CA certificates for you.</p>
<p>在 3.9 版更改: The optional <em>timeout</em> parameter was added.</p>
<p>The second subclass allows for connections created by a child process:</p>
<p><em>class</em> <code>imaplib.IMAP4_stream</code>(<em>command</em>)</p>
<p>This is a subclass derived from <code>IMAP4</code> that connects to the <code>stdin/stdout</code> file descriptors created by passing <em>command</em> to <code>subprocess.Popen()</code>.</p>
<p>The following utility functions are defined:</p>
<p><code>imaplib.Internaldate2tuple</code>(<em>datestr</em>)</p>
<p>Parse an IMAP4 <code>INTERNALDATE</code> string and return corresponding local time. The return value is a <code>time.struct_time</code> tuple or <code>None</code> if the string has wrong format.</p>
<p><code>imaplib.Int2AP</code>(<em>num</em>)</p>
<p>Converts an integer into a bytes representation using characters from the set [<code>A</code> .. <code>P</code>].</p>
<p><code>imaplib.ParseFlags</code>(<em>flagstr</em>)</p>
<p>Converts an IMAP4 <code>FLAGS</code> response to a tuple of individual flags.</p>
<p><code>imaplib.Time2Internaldate</code>(<em>date_time</em>)</p>
<p>Convert <em>date_time</em> to an IMAP4 <code>INTERNALDATE</code> representation. The return value is a string in the form: <code>"DD-Mmm-YYYY HH:MM:SS +HHMM"</code> (including double-quotes). The <em>date_time</em> argument can be a number (int or float) representing seconds since epoch (as returned by <code>time.time()</code>), a 9-tuple representing local time an instance of <code>time.struct_time</code> (as returned by <code>time.localtime()</code>), an aware instance of <code>datetime.datetime</code>, or a double-quoted string. In the last case, it is assumed to already be in the correct format.</p>
<p>Note that IMAP4 message numbers change as the mailbox changes; in particular, after an <code>EXPUNGE</code> command performs deletions the remaining messages are renumbered. So it is highly advisable to use UIDs instead, with the UID command.</p>
<p>模块的最后有一段测试，其中包含的用法示例更加广泛。</p>
<p>参见</p>
<p>Documents describing the protocol, sources for servers implementing it, by the University of Washington’s IMAP Information Center can all be found at (<strong>Source Code</strong>) <a href="https://github.com/uw-imap/imap" target="_blank" rel="noopener">https://github.com/uw-imap/imap</a> (<strong>Not Maintained</strong>).</p>
<h3 id="IMAP4-Objects"><a href="#IMAP4-Objects" class="headerlink" title="IMAP4 Objects"></a>IMAP4 Objects</h3><p>All IMAP4rev1 commands are represented by methods of the same name, either upper-case or lower-case.</p>
<p>All arguments to commands are converted to strings, except for <code>AUTHENTICATE</code>, and the last argument to <code>APPEND</code> which is passed as an IMAP4 literal. If necessary (the string contains IMAP4 protocol-sensitive characters and isn’t enclosed with either parentheses or double quotes) each string is quoted. However, the <em>password</em> argument to the <code>LOGIN</code> command is always quoted. If you want to avoid having an argument string quoted (eg: the <em>flags</em> argument to <code>STORE</code>) then enclose the string in parentheses (eg: <code>r'(\Deleted)'</code>).</p>
<p>Each command returns a tuple: <code>(type, [data, ...])</code> where <em>type</em> is usually <code>'OK'</code> or <code>'NO'</code>, and <em>data</em> is either the text from the command response, or mandated results from the command. Each <em>data</em> is either a <code>bytes</code>, or a tuple. If a tuple, then the first part is the header of the response, and the second part contains the data (ie: ‘literal’ value).</p>
<p>The <em>message_set</em> options to commands below is a string specifying one or more messages to be acted upon. It may be a simple message number (<code>'1'</code>), a range of message numbers (<code>'2:4'</code>), or a group of non-contiguous ranges separated by commas (<code>'1:3,6:9'</code>). A range can contain an asterisk to indicate an infinite upper bound (<code>'3:*'</code>).</p>
<p>An <code>IMAP4</code> instance has the following methods:</p>
<p><code>IMAP4.append</code>(<em>mailbox</em>, <em>flags</em>, <em>date_time</em>, <em>message</em>)</p>
<p>Append <em>message</em> to named mailbox.</p>
<p><code>IMAP4.authenticate</code>(<em>mechanism</em>, <em>authobject</em>)</p>
<p>Authenticate command —- requires response processing.</p>
<p><em>mechanism</em> specifies which authentication mechanism is to be used - it should appear in the instance variable <code>capabilities</code> in the form <code>AUTH=mechanism</code>.</p>
<p><em>authobject</em> must be a callable object:</p>
<pre><code>data = authobject(response)</code></pre><p>It will be called to process server continuation responses; the <em>response</em> argument it is passed will be <code>bytes</code>. It should return <code>bytes</code> <em>data</em> that will be base64 encoded and sent to the server. It should return <code>None</code> if the client abort response <code>*</code> should be sent instead.</p>
<p>在 3.5 版更改: string usernames and passwords are now encoded to <code>utf-8</code> instead of being limited to ASCII.</p>
<p><code>IMAP4.check</code>()</p>
<p>Checkpoint mailbox on server.</p>
<p><code>IMAP4.close</code>()</p>
<p>Close currently selected mailbox. Deleted messages are removed from writable mailbox. This is the recommended command before <code>LOGOUT</code>.</p>
<p><code>IMAP4.copy</code>(<em>message_set</em>, <em>new_mailbox</em>)</p>
<p>Copy <em>message_set</em> messages onto end of <em>new_mailbox</em>.</p>
<p><code>IMAP4.create</code>(<em>mailbox</em>)</p>
<p>Create new mailbox named <em>mailbox</em>.</p>
<p><code>IMAP4.delete</code>(<em>mailbox</em>)</p>
<p>Delete old mailbox named <em>mailbox</em>.</p>
<p><code>IMAP4.deleteacl</code>(<em>mailbox</em>, <em>who</em>)</p>
<p>Delete the ACLs (remove any rights) set for who on mailbox.</p>
<p><code>IMAP4.enable</code>(<em>capability</em>)</p>
<p>Enable <em>capability</em> (see <a href="https://tools.ietf.org/html/rfc5161.html" target="_blank" rel="noopener"><strong>RFC 5161</strong></a>). Most capabilities do not need to be enabled. Currently only the <code>UTF8=ACCEPT</code> capability is supported (see <a href="https://tools.ietf.org/html/rfc6855.html" target="_blank" rel="noopener"><strong>RFC 6855</strong></a>).</p>
<p>3.5 新版功能: The <code>enable()</code> method itself, and <a href="https://tools.ietf.org/html/rfc6855.html" target="_blank" rel="noopener"><strong>RFC 6855</strong></a> support.</p>
<p><code>IMAP4.expunge</code>()</p>
<p>Permanently remove deleted items from selected mailbox. Generates an <code>EXPUNGE</code> response for each deleted message. Returned data contains a list of <code>EXPUNGE</code> message numbers in order received.</p>
<p><code>IMAP4.fetch</code>(<em>message_set</em>, <em>message_parts</em>)</p>
<p>Fetch (parts of) messages. <em>message_parts</em> should be a string of message part names enclosed within parentheses, eg: <code>"(UID BODY[TEXT])"</code>. Returned data are tuples of message part envelope and data.</p>
<p><code>IMAP4.getacl</code>(<em>mailbox</em>)</p>
<p>Get the <code>ACL</code>s for <em>mailbox</em>. The method is non-standard, but is supported by the <code>Cyrus</code> server.</p>
<p><code>IMAP4.getannotation</code>(<em>mailbox</em>, <em>entry</em>, <em>attribute</em>)</p>
<p>Retrieve the specified <code>ANNOTATION</code>s for <em>mailbox</em>. The method is non-standard, but is supported by the <code>Cyrus</code> server.</p>
<p><code>IMAP4.getquota</code>(<em>root</em>)</p>
<p>Get the <code>quota</code> <em>root</em>‘s resource usage and limits. This method is part of the IMAP4 QUOTA extension defined in rfc2087.</p>
<p><code>IMAP4.getquotaroot</code>(<em>mailbox</em>)</p>
<p>Get the list of <code>quota</code> <code>roots</code> for the named <em>mailbox</em>. This method is part of the IMAP4 QUOTA extension defined in rfc2087.</p>
<p><code>IMAP4.list</code>([<em>directory</em>[, <em>pattern</em>]])</p>
<p>List mailbox names in <em>directory</em> matching <em>pattern</em>. <em>directory</em> defaults to the top-level mail folder, and <em>pattern</em> defaults to match anything. Returned data contains a list of <code>LIST</code> responses.</p>
<p><code>IMAP4.login</code>(<em>user</em>, <em>password</em>)</p>
<p>Identify the client using a plaintext password. The <em>password</em> will be quoted.</p>
<p><code>IMAP4.login_cram_md5</code>(<em>user</em>, <em>password</em>)</p>
<p>Force use of <code>CRAM-MD5</code> authentication when identifying the client to protect the password. Will only work if the server <code>CAPABILITY</code> response includes the phrase <code>AUTH=CRAM-MD5</code>.</p>
<p><code>IMAP4.logout</code>()</p>
<p>Shutdown connection to server. Returns server <code>BYE</code> response.</p>
<p>在 3.8 版更改: The method no longer ignores silently arbitrary exceptions.</p>
<p><code>IMAP4.lsub</code>(<em>directory=’””‘</em>, <em>pattern=’*‘</em>)</p>
<p>List subscribed mailbox names in directory matching pattern. <em>directory</em> defaults to the top level directory and <em>pattern</em> defaults to match any mailbox. Returned data are tuples of message part envelope and data.</p>
<p><code>IMAP4.myrights</code>(<em>mailbox</em>)</p>
<p>Show my ACLs for a mailbox (i.e. the rights that I have on mailbox).</p>
<p><code>IMAP4.namespace</code>()</p>
<p>Returns IMAP namespaces as defined in <a href="https://tools.ietf.org/html/rfc2342.html" target="_blank" rel="noopener"><strong>RFC 2342</strong></a>.</p>
<p><code>IMAP4.noop</code>()</p>
<p>Send <code>NOOP</code> to server.</p>
<p><code>IMAP4.open</code>(<em>host</em>, <em>port</em>, <em>timeout=None</em>)</p>
<p>Opens socket to <em>port</em> at <em>host</em>. The optional <em>timeout</em> parameter specifies a timeout in seconds for the connection attempt. If timeout is not given or is None, the global default socket timeout is used. Also note that if the <em>timeout</em> parameter is set to be zero, it will raise a <code>ValueError</code> to reject creating a non-blocking socket. This method is implicitly called by the <code>IMAP4</code> constructor. The connection objects established by this method will be used in the <code>IMAP4.read()</code>, <code>IMAP4.readline()</code>, <code>IMAP4.send()</code>, and <code>IMAP4.shutdown()</code> methods. You may override this method.</p>
<p>Raises an auditing event <code>imaplib.open</code> with arguments <code>self</code>, <code>host</code>, <code>port</code>.</p>
<p>在 3.9 版更改: 加入 <em>timeout</em> 参数。</p>
<p><code>IMAP4.partial</code>(<em>message_num</em>, <em>message_part</em>, <em>start</em>, <em>length</em>)</p>
<p>Fetch truncated part of a message. Returned data is a tuple of message part envelope and data.</p>
<p><code>IMAP4.proxyauth</code>(<em>user</em>)</p>
<p>Assume authentication as <em>user</em>. Allows an authorised administrator to proxy into any user’s mailbox.</p>
<p><code>IMAP4.read</code>(<em>size</em>)</p>
<p>Reads <em>size</em> bytes from the remote server. You may override this method.</p>
<p><code>IMAP4.readline</code>()</p>
<p>Reads one line from the remote server. You may override this method.</p>
<p><code>IMAP4.recent</code>()</p>
<p>Prompt server for an update. Returned data is <code>None</code> if no new messages, else value of <code>RECENT</code> response.</p>
<p><code>IMAP4.rename</code>(<em>oldmailbox</em>, <em>newmailbox</em>)</p>
<p>Rename mailbox named <em>oldmailbox</em> to <em>newmailbox</em>.</p>
<p><code>IMAP4.response</code>(<em>code</em>)</p>
<p>Return data for response <em>code</em> if received, or <code>None</code>. Returns the given code, instead of the usual type.</p>
<p><code>IMAP4.search</code>(<em>charset</em>, <em>criterion</em>[, <em>…</em>])</p>
<p>Search mailbox for matching messages. <em>charset</em> may be <code>None</code>, in which case no <code>CHARSET</code> will be specified in the request to the server. The IMAP protocol requires that at least one criterion be specified; an exception will be raised when the server returns an error. <em>charset</em> must be <code>None</code> if the <code>UTF8=ACCEPT</code> capability was enabled using the <code>enable()</code> command.</p>
<p>示例:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># M is a connected IMAP4 instance...</span>
typ<span class="token punctuation">,</span> msgnums <span class="token operator">=</span> M<span class="token punctuation">.</span>search<span class="token punctuation">(</span>None<span class="token punctuation">,</span> <span class="token string">'FROM'</span><span class="token punctuation">,</span> <span class="token string">'"LDJ"'</span><span class="token punctuation">)</span>
<span class="token comment" spellcheck="true"># or:</span>
typ<span class="token punctuation">,</span> msgnums <span class="token operator">=</span> M<span class="token punctuation">.</span>search<span class="token punctuation">(</span>None<span class="token punctuation">,</span> <span class="token string">'(FROM "LDJ")'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>IMAP4.select</code>(<em>mailbox=’INBOX’</em>, <em>readonly=False</em>)</p>
<p>Select a mailbox. Returned data is the count of messages in <em>mailbox</em> (<code>EXISTS</code> response). The default <em>mailbox</em> is <code>'INBOX'</code>. If the <em>readonly</em> flag is set, modifications to the mailbox are not allowed.</p>
<p><code>IMAP4.send</code>(<em>data</em>)</p>
<p>Sends <code>data</code> to the remote server. You may override this method.</p>
<p>Raises an auditing event <code>imaplib.send</code> with arguments <code>self</code>, <code>data</code>.</p>
<p><code>IMAP4.setacl</code>(<em>mailbox</em>, <em>who</em>, <em>what</em>)</p>
<p>Set an <code>ACL</code> for <em>mailbox</em>. The method is non-standard, but is supported by the <code>Cyrus</code> server.</p>
<p><code>IMAP4.setannotation</code>(<em>mailbox</em>, <em>entry</em>, <em>attribute</em>[, <em>…</em>])</p>
<p>Set <code>ANNOTATION</code>s for <em>mailbox</em>. The method is non-standard, but is supported by the <code>Cyrus</code> server.</p>
<p><code>IMAP4.setquota</code>(<em>root</em>, <em>limits</em>)</p>
<p>Set the <code>quota</code> <em>root*‘s resource *limits</em>. This method is part of the IMAP4 QUOTA extension defined in rfc2087.</p>
<p><code>IMAP4.shutdown</code>()</p>
<p>Close connection established in <code>open</code>. This method is implicitly called by <code>IMAP4.logout()</code>. You may override this method.</p>
<p><code>IMAP4.socket</code>()</p>
<p>Returns socket instance used to connect to server.</p>
<p><code>IMAP4.sort</code>(<em>sort_criteria</em>, <em>charset</em>, <em>search_criterion</em>[, <em>…</em>])</p>
<p>The <code>sort</code> command is a variant of <code>search</code> with sorting semantics for the results. Returned data contains a space separated list of matching message numbers.</p>
<p>Sort has two arguments before the <em>search_criterion</em> argument(s); a parenthesized list of <em>sort_criteria</em>, and the searching <em>charset</em>. Note that unlike <code>search</code>, the searching <em>charset</em> argument is mandatory. There is also a <code>uid sort</code> command which corresponds to <code>sort</code> the way that <code>uid search</code> corresponds to <code>search</code>. The <code>sort</code> command first searches the mailbox for messages that match the given searching criteria using the charset argument for the interpretation of strings in the searching criteria. It then returns the numbers of matching messages.</p>
<p>This is an <code>IMAP4rev1</code> extension command.</p>
<p><code>IMAP4.starttls</code>(<em>ssl_context=None</em>)</p>
<p>Send a <code>STARTTLS</code> command. The <em>ssl_context</em> argument is optional and should be a <code>ssl.SSLContext</code> object. This will enable encryption on the IMAP connection. </p>
<p>3.2 新版功能.</p>
<p>在 3.4 版更改: 此方法现在支持使用 <code>ssl.SSLContext.check_hostname</code> 和 <em>服务器名称指示</em>进行主机名检查。</p>
<p><code>IMAP4.status</code>(<em>mailbox</em>, <em>names</em>)</p>
<p>Request named status conditions for <em>mailbox</em>.</p>
<p><code>IMAP4.store</code>(<em>message_set</em>, <em>command</em>, <em>flag_list</em>)</p>
<p>Alters flag dispositions for messages in mailbox. <em>command</em> is specified by section 6.4.6 of <a href="https://tools.ietf.org/html/rfc2060.html" target="_blank" rel="noopener"><strong>RFC 2060</strong></a> as being one of “FLAGS”, “+FLAGS”, or “-FLAGS”, optionally with a suffix of “.SILENT”.</p>
<p>For example, to set the delete flag on all messages:</p>
<pre class="line-numbers language-python"><code class="language-python">typ<span class="token punctuation">,</span> data <span class="token operator">=</span> M<span class="token punctuation">.</span>search<span class="token punctuation">(</span>None<span class="token punctuation">,</span> <span class="token string">'ALL'</span><span class="token punctuation">)</span>
<span class="token keyword">for</span> num <span class="token keyword">in</span> data<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
   M<span class="token punctuation">.</span>store<span class="token punctuation">(</span>num<span class="token punctuation">,</span> <span class="token string">'+FLAGS'</span><span class="token punctuation">,</span> <span class="token string">'\\Deleted'</span><span class="token punctuation">)</span>
M<span class="token punctuation">.</span>expunge<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>注解</p>
<p>Creating flags containing ‘]‘ (for example: “[test]“) violates <a href="https://tools.ietf.org/html/rfc3501.html" target="_blank" rel="noopener"><strong>RFC 3501</strong></a> (the IMAP protocol). However, imaplib has historically allowed creation of such tags, and popular IMAP servers, such as Gmail, accept and produce such flags. There are non-Python programs which also create such tags. Although it is an RFC violation and IMAP clients and servers are supposed to be strict, imaplib nonetheless continues to allow such tags to be created for backward compatibility reasons, and as of Python 3.6, handles them if they are sent from the server, since this improves real-world compatibility.</p>
<p><code>IMAP4.subscribe</code>(<em>mailbox</em>)</p>
<p>Subscribe to new mailbox.</p>
<p><code>IMAP4.thread</code>(<em>threading_algorithm</em>, <em>charset</em>, <em>search_criterion</em>[, <em>…</em>])</p>
<p>The <code>thread</code> command is a variant of <code>search</code> with threading semantics for the results. Returned data contains a space separated list of thread members.</p>
<p>Thread members consist of zero or more messages numbers, delimited by spaces, indicating successive parent and child.</p>
<p>Thread has two arguments before the <em>search_criterion</em> argument(s); a <em>threading_algorithm</em>, and the searching <em>charset</em>. Note that unlike <code>search</code>, the searching <em>charset</em> argument is mandatory. There is also a <code>uid thread</code> command which corresponds to <code>thread</code> the way that <code>uid search</code> corresponds to <code>search</code>. The <code>thread</code> command first searches the mailbox for messages that match the given searching criteria using the charset argument for the interpretation of strings in the searching criteria. It then returns the matching messages threaded according to the specified threading algorithm.</p>
<p>This is an <code>IMAP4rev1</code> extension command.</p>
<p><code>IMAP4.uid</code>(<em>command</em>, <em>arg</em>[, <em>…</em>])</p>
<p>Execute command args with messages identified by UID, rather than message number. Returns response appropriate to command. At least one argument must be supplied; if none are provided, the server will return an error and an exception will be raised.</p>
<p><code>IMAP4.unsubscribe</code>(<em>mailbox</em>)</p>
<p>Unsubscribe from old mailbox.</p>
<p><code>IMAP4.unselect</code>()</p>
<p><code>imaplib.IMAP4.unselect()</code> frees server’s resources associated with the selected mailbox and returns the server to the authenticated state. This command performs the same actions as <code>imaplib.IMAP4.close()</code>, except that no messages are permanently removed from the currently selected mailbox.</p>
<p>3.9 新版功能.</p>
<p><code>IMAP4.xatom</code>(<em>name</em>[, <em>…</em>])</p>
<p>Allow simple extension commands notified by server in <code>CAPABILITY</code> response.</p>
<p>The following attributes are defined on instances of <code>IMAP4</code>:</p>
<pre><code>IMAP4.PROTOCOL_VERSION</code></pre><p>The most recent supported protocol in the <code>CAPABILITY</code> response from the server.</p>
<pre><code>IMAP4.debug</code></pre><p>Integer value to control debugging output. The initialize value is taken from the module variable <code>Debug</code>. Values greater than three trace each command.</p>
<pre><code>IMAP4.utf8_enabled</code></pre><p>Boolean value that is normally <code>False</code>, but is set to <code>True</code> if an <code>enable()</code> command is successfully issued for the <code>UTF8=ACCEPT</code> capability.</p>
<p>3.5 新版功能.</p>
<h3 id="IMAP4-Example"><a href="#IMAP4-Example" class="headerlink" title="IMAP4 Example"></a>IMAP4 Example</h3><p>以下是一个最短示例（不带错误检查），该示例将打开邮箱，检索并打印所有消息:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> getpass<span class="token punctuation">,</span> imaplib
M <span class="token operator">=</span> imaplib<span class="token punctuation">.</span>IMAP4<span class="token punctuation">(</span><span class="token punctuation">)</span>
M<span class="token punctuation">.</span>login<span class="token punctuation">(</span>getpass<span class="token punctuation">.</span>getuser<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> getpass<span class="token punctuation">.</span>getpass<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
M<span class="token punctuation">.</span>select<span class="token punctuation">(</span><span class="token punctuation">)</span>
typ<span class="token punctuation">,</span> data <span class="token operator">=</span> M<span class="token punctuation">.</span>search<span class="token punctuation">(</span>None<span class="token punctuation">,</span> <span class="token string">'ALL'</span><span class="token punctuation">)</span>
<span class="token keyword">for</span> num <span class="token keyword">in</span> data<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    typ<span class="token punctuation">,</span> data <span class="token operator">=</span> M<span class="token punctuation">.</span>fetch<span class="token punctuation">(</span>num<span class="token punctuation">,</span> <span class="token string">'(RFC822)'</span><span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Message %s\n%s\n'</span> <span class="token operator">%</span> <span class="token punctuation">(</span>num<span class="token punctuation">,</span> data<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
M<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>
M<span class="token punctuation">.</span>logout<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="nntplib-—-NNTP-protocol-client"><a href="#nntplib-—-NNTP-protocol-client" class="headerlink" title="nntplib —- NNTP protocol client"></a><code>nntplib</code> —- NNTP protocol client</h2><p><strong>Source code:</strong> <a href="https://github.com/python/cpython/tree/3.10/Lib/nntplib.py" target="_blank" rel="noopener">Lib/nntplib.py</a></p>
<hr>
<p>This module defines the class <code>NNTP</code> which implements the client side of the Network News Transfer Protocol. It can be used to implement a news reader or poster, or automated news processors. It is compatible with <a href="https://tools.ietf.org/html/rfc3977.html" target="_blank" rel="noopener"><strong>RFC 3977</strong></a> as well as the older <a href="https://tools.ietf.org/html/rfc977.html" target="_blank" rel="noopener"><strong>RFC 977</strong></a> and <a href="https://tools.ietf.org/html/rfc2980.html" target="_blank" rel="noopener"><strong>RFC 2980</strong></a>.</p>
<p>Here are two small examples of how it can be used. To list some statistics about a newsgroup and print the subjects of the last 10 articles:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> s <span class="token operator">=</span> nntplib<span class="token punctuation">.</span>NNTP<span class="token punctuation">(</span><span class="token string">'news.gmane.io'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> resp<span class="token punctuation">,</span> count<span class="token punctuation">,</span> first<span class="token punctuation">,</span> last<span class="token punctuation">,</span> name <span class="token operator">=</span> s<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token string">'gmane.comp.python.committers'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Group'</span><span class="token punctuation">,</span> name<span class="token punctuation">,</span> <span class="token string">'has'</span><span class="token punctuation">,</span> count<span class="token punctuation">,</span> <span class="token string">'articles, range'</span><span class="token punctuation">,</span> first<span class="token punctuation">,</span> <span class="token string">'to'</span><span class="token punctuation">,</span> last<span class="token punctuation">)</span>
Group gmane<span class="token punctuation">.</span>comp<span class="token punctuation">.</span>python<span class="token punctuation">.</span>committers has <span class="token number">1096</span> articles<span class="token punctuation">,</span> range <span class="token number">1</span> to <span class="token number">1096</span>
<span class="token operator">>></span><span class="token operator">></span> resp<span class="token punctuation">,</span> overviews <span class="token operator">=</span> s<span class="token punctuation">.</span>over<span class="token punctuation">(</span><span class="token punctuation">(</span>last <span class="token operator">-</span> <span class="token number">9</span><span class="token punctuation">,</span> last<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">for</span> id<span class="token punctuation">,</span> over <span class="token keyword">in</span> overviews<span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">print</span><span class="token punctuation">(</span>id<span class="token punctuation">,</span> nntplib<span class="token punctuation">.</span>decode_header<span class="token punctuation">(</span>over<span class="token punctuation">[</span><span class="token string">'subject'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token number">1087</span> Re<span class="token punctuation">:</span> Commit privileges <span class="token keyword">for</span> Łukasz Langa
<span class="token number">1088</span> Re<span class="token punctuation">:</span> <span class="token number">3.2</span> alpha <span class="token number">2</span> freeze
<span class="token number">1089</span> Re<span class="token punctuation">:</span> <span class="token number">3.2</span> alpha <span class="token number">2</span> freeze
<span class="token number">1090</span> Re<span class="token punctuation">:</span> Commit privileges <span class="token keyword">for</span> Łukasz Langa
<span class="token number">1091</span> Re<span class="token punctuation">:</span> Commit privileges <span class="token keyword">for</span> Łukasz Langa
<span class="token number">1092</span> Updated ssh key
<span class="token number">1093</span> Re<span class="token punctuation">:</span> Updated ssh key
<span class="token number">1094</span> Re<span class="token punctuation">:</span> Updated ssh key
<span class="token number">1095</span> Hello fellow committers!
<span class="token number">1096</span> Re<span class="token punctuation">:</span> Hello fellow committers!
<span class="token operator">>></span><span class="token operator">></span> s<span class="token punctuation">.</span>quit<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token string">'205 Bye!'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>To post an article from a binary file (this assumes that the article has valid headers, and that you have right to post on the particular newsgroup):</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> s <span class="token operator">=</span> nntplib<span class="token punctuation">.</span>NNTP<span class="token punctuation">(</span><span class="token string">'news.gmane.io'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> f <span class="token operator">=</span> open<span class="token punctuation">(</span><span class="token string">'article.txt'</span><span class="token punctuation">,</span> <span class="token string">'rb'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> s<span class="token punctuation">.</span>post<span class="token punctuation">(</span>f<span class="token punctuation">)</span>
<span class="token string">'240 Article posted successfully.'</span>
<span class="token operator">>></span><span class="token operator">></span> s<span class="token punctuation">.</span>quit<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token string">'205 Bye!'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>The module itself defines the following classes:</p>
<p><em>class</em> <code>nntplib.NNTP</code>(<em>host</em>, <em>port=119</em>, <em>user=None</em>, <em>password=None</em>, <em>readermode=None</em>, <em>usenetrc=False</em>[, <em>timeout</em>])</p>
<p>Return a new <code>NNTP</code> object, representing a connection to the NNTP server running on host <em>host</em>, listening at port <em>port</em>. An optional <em>timeout</em> can be specified for the socket connection. If the optional <em>user</em> and <em>password</em> are provided, or if suitable credentials are present in <code>/.netrc</code> and the optional flag <em>usenetrc</em> is true, the <code>AUTHINFO USER</code> and <code>AUTHINFO PASS</code> commands are used to identify and authenticate the user to the server. If the optional flag <em>readermode</em> is true, then a <code>mode reader</code> command is sent before authentication is performed. Reader mode is sometimes necessary if you are connecting to an NNTP server on the local machine and intend to call reader-specific commands, such as <code>group</code>. If you get unexpected <code>NNTPPermanentError</code>s, you might need to set <em>readermode</em>. The <code>NNTP</code> class supports the <code>with</code> statement to unconditionally consume <code>OSError</code> exceptions and to close the NNTP connection when done, e.g.:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> nntplib <span class="token keyword">import</span> NNTP
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">with</span> NNTP<span class="token punctuation">(</span><span class="token string">'news.gmane.io'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> n<span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     n<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token string">'gmane.comp.python.committers'</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> 
<span class="token punctuation">(</span><span class="token string">'211 1755 1 1755 gmane.comp.python.committers'</span><span class="token punctuation">,</span> <span class="token number">1755</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1755</span><span class="token punctuation">,</span> <span class="token string">'gmane.comp.python.committers'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>Raises an auditing event <code>nntplib.connect</code> with arguments <code>self</code>, <code>host</code>, <code>port</code>.</p>
<p>All commands will raise an auditing event <code>nntplib.putline</code> with arguments <code>self</code> and <code>line</code>, where <code>line</code> is the bytes about to be sent to the remote host.</p>
<p>在 3.2 版更改: <em>usenetrc</em> is now <code>False</code> by default.</p>
<p>在 3.3 版更改: 添加了对 <code>with</code> 语句的支持。</p>
<p>在 3.9 版更改: 如果 <em>timeout</em> 参数设置为 0，创建非阻塞套接字时，它将引发 <code>ValueError</code> 来阻止该操作。</p>
<p><em>class</em> <code>nntplib.NNTP_SSL</code>(<em>host</em>, <em>port=563</em>, <em>user=None</em>, <em>password=None</em>, <em>ssl_context=None</em>, <em>readermode=None</em>, <em>usenetrc=False</em>[, <em>timeout</em>])</p>
<p>Return a new <code>NNTP_SSL</code> object, representing an encrypted connection to the NNTP server running on host <em>host</em>, listening at port <em>port</em>. <code>NNTP_SSL</code> objects have the same methods as <code>NNTP</code> objects. If <em>port</em> is omitted, port 563 (NNTPS) is used. <em>ssl_context</em> is also optional, and is a <code>SSLContext</code> object.All other parameters behave the same as for <code>NNTP</code>.</p>
<p>Note that SSL-on-563 is discouraged per <a href="https://tools.ietf.org/html/rfc4642.html" target="_blank" rel="noopener"><strong>RFC 4642</strong></a>, in favor of STARTTLS as described below. However, some servers only support the former.</p>
<p>Raises an auditing event <code>nntplib.connect</code> with arguments <code>self</code>, <code>host</code>, <code>port</code>.</p>
<p>All commands will raise an auditing event <code>nntplib.putline</code> with arguments <code>self</code> and <code>line</code>, where <code>line</code> is the bytes about to be sent to the remote host.</p>
<p>3.2 新版功能.</p>
<p>在 3.4 版更改: 本类现在支持使用 <code>ssl.SSLContext.check_hostname</code> 和 <em>服务器名称指示</em>进行主机名检查。</p>
<p>在 3.9 版更改: 如果 <em>timeout</em> 参数设置为 0，创建非阻塞套接字时，它将引发 <code>ValueError</code> 来阻止该操作。</p>
<p><em>exception</em> <code>nntplib.NNTPError</code></p>
<p>Derived from the standard exception <code>Exception</code>, this is the base class for all exceptions raised by the <code>nntplib</code> module. Instances of this class have the following attribute:</p>
<ul>
<li><p><code>response</code></p>
<p>The response of the server if available, as a <code>str</code> object.</p>
</li>
</ul>
<p><em>exception</em> <code>nntplib.NNTPReplyError</code></p>
<p>从服务器收到意外答复时，将引发本异常。</p>
<p><em>exception</em> <code>nntplib.NNTPTemporaryError</code></p>
<p>Exception raised when a response code in the range 400—499 is received.</p>
<p><em>exception</em> <code>nntplib.NNTPPermanentError</code></p>
<p>Exception raised when a response code in the range 500—599 is received.</p>
<p><em>exception</em> <code>nntplib.NNTPProtocolError</code></p>
<p>Exception raised when a reply is received from the server that does not begin with a digit in the range 1—5.</p>
<p><em>exception</em> <code>nntplib.NNTPDataError</code></p>
<p>Exception raised when there is some error in the response data.</p>
<h3 id="NNTP-Objects"><a href="#NNTP-Objects" class="headerlink" title="NNTP Objects"></a>NNTP Objects</h3><p>When connected, <code>NNTP</code> and <code>NNTP_SSL</code> objects support the following methods and attributes.</p>
<h4 id="Attributes"><a href="#Attributes" class="headerlink" title="Attributes"></a>Attributes</h4><pre><code>NNTP.nntp_version</code></pre><p>An integer representing the version of the NNTP protocol supported by the server. In practice, this should be <code>2</code> for servers advertising <a href="https://tools.ietf.org/html/rfc3977.html" target="_blank" rel="noopener"><strong>RFC 3977</strong></a> compliance and <code>1</code> for others.</p>
<p>3.2 新版功能.</p>
<pre><code>NNTP.nntp_implementation</code></pre><p>A string describing the software name and version of the NNTP server, or <code>None</code> if not advertised by the server.</p>
<p>3.2 新版功能.</p>
<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>The <em>response</em> that is returned as the first item in the return tuple of almost all methods is the server’s response: a string beginning with a three-digit code. If the server’s response indicates an error, the method raises one of the above exceptions.</p>
<p>Many of the following methods take an optional keyword-only argument <em>file</em>. When the <em>file</em> argument is supplied, it must be either a file object opened for binary writing, or the name of an on-disk file to be written to. The method will then write any data returned by the server (except for the response line and the terminating dot) to the file; any list of lines, tuples or objects that the method normally returns will be empty.</p>
<p>在 3.2 版更改: Many of the following methods have been reworked and fixed, which makes them incompatible with their 3.1 counterparts.</p>
<p><code>NNTP.quit</code>()</p>
<p>Send a <code>QUIT</code> command and close the connection. Once this method has been called, no other methods of the NNTP object should be called.</p>
<p><code>NNTP.getwelcome</code>()</p>
<p>返回服务器发送的欢迎消息，作为连接开始的回复。（该消息有时包含与用户有关的免责声明或帮助信息。）</p>
<p><code>NNTP.getcapabilities</code>()</p>
<p>Return the <a href="https://tools.ietf.org/html/rfc3977.html" target="_blank" rel="noopener"><strong>RFC 3977</strong></a> capabilities advertised by the server, as a <code>dict</code> instance mapping capability names to (possibly empty) lists of values. On legacy servers which don’t understand the <code>CAPABILITIES</code> command, an empty dictionary is returned instead.</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> s <span class="token operator">=</span> NNTP<span class="token punctuation">(</span><span class="token string">'news.gmane.io'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token string">'POST'</span> <span class="token keyword">in</span> s<span class="token punctuation">.</span>getcapabilities<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>3.2 新版功能.</p>
<p><code>NNTP.login</code>(<em>user=None</em>, <em>password=None</em>, <em>usenetrc=True</em>)</p>
<p>Send <code>AUTHINFO</code> commands with the user name and password. If <em>user</em> and <em>password</em> are <code>None</code> and <em>usenetrc</em> is true, credentials from <code>~/.netrc</code> will be used if possible.</p>
<p>Unless intentionally delayed, login is normally performed during the <code>NNTP</code> object initialization and separately calling this function is unnecessary. To force authentication to be delayed, you must not set <em>user</em> or <em>password</em> when creating the object, and must set <em>usenetrc</em> to False.</p>
<p>3.2 新版功能.</p>
<p><code>NNTP.starttls</code>(<em>context=None</em>)</p>
<p>Send a <code>STARTTLS</code> command. This will enable encryption on the NNTP connection. The <em>context</em> argument is optional and should be a <code>ssl.SSLContext</code> object. </p>
<p>Note that this may not be done after authentication information has been transmitted, and authentication occurs by default if possible during a <code>NNTP</code> object initialization. See <code>NNTP.login()</code> for information on suppressing this behavior.</p>
<p>3.2 新版功能.</p>
<p>在 3.4 版更改: 此方法现在支持使用 <code>ssl.SSLContext.check_hostname</code> 和 <em>服务器名称指示</em>  进行主机名检查。</p>
<p><code>NNTP.newgroups</code>(<em>date</em>, <em>**,</em> file=None*)</p>
<p>Send a <code>NEWGROUPS</code> command. The <em>date</em> argument should be a <code>datetime.date</code> or <code>datetime.datetime</code> object. Return a pair <code>(response, groups)</code> where <em>groups</em> is a list representing the groups that are new since the given <em>date</em>. If <em>file</em> is supplied, though, then <em>groups</em> will be empty.</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> datetime <span class="token keyword">import</span> date<span class="token punctuation">,</span> timedelta
<span class="token operator">>></span><span class="token operator">></span> resp<span class="token punctuation">,</span> groups <span class="token operator">=</span> s<span class="token punctuation">.</span>newgroups<span class="token punctuation">(</span>date<span class="token punctuation">.</span>today<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> timedelta<span class="token punctuation">(</span>days<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> len<span class="token punctuation">(</span>groups<span class="token punctuation">)</span> 
<span class="token number">85</span>
<span class="token operator">>></span><span class="token operator">></span> groups<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> 
GroupInfo<span class="token punctuation">(</span>group<span class="token operator">=</span><span class="token string">'gmane.network.tor.devel'</span><span class="token punctuation">,</span> last<span class="token operator">=</span><span class="token string">'4'</span><span class="token punctuation">,</span> first<span class="token operator">=</span><span class="token string">'1'</span><span class="token punctuation">,</span> flag<span class="token operator">=</span><span class="token string">'m'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>NNTP.newnews</code>(<em>group</em>, <em>date</em>, <em>**,</em> file=None*)</p>
<p>Send a <code>NEWNEWS</code> command. Here, <em>group</em> is a group name or <code>'*'</code>, and <em>date</em> has the same meaning as for <code>newgroups()</code>. Return a pair <code>(response, articles)</code> where <em>articles</em> is a list of message ids.</p>
<p>This command is frequently disabled by NNTP server administrators.</p>
<p><code>NNTP.list</code>(<em>group_pattern=None</em>, <em>**,</em> file=None*)</p>
<p>Send a <code>LIST</code> or <code>LIST ACTIVE</code> command. Return a pair <code>(response, list)</code> where <em>list</em> is a list of tuples representing all the groups available from this NNTP server, optionally matching the pattern string <em>group_pattern</em>. Each tuple has the form <code>(group, last, first, flag)</code>, where <em>group</em> is a group name, <em>last</em> and <em>first</em> are the last and first article numbers, and <em>flag</em> usually takes one of these values:</p>
<ul>
<li><code>y</code>: Local postings and articles from peers are allowed.</li>
<li><code>m</code>: The group is moderated and all postings must be approved.</li>
<li><code>n</code>: No local postings are allowed, only articles from peers.</li>
<li><code>j</code>: Articles from peers are filed in the junk group instead.</li>
<li><code>x</code>: No local postings, and articles from peers are ignored.</li>
<li><code>=foo.bar</code>: Articles are filed in the <code>foo.bar</code> group instead.</li>
</ul>
<p>If <em>flag</em> has another value, then the status of the newsgroup should be considered unknown.</p>
<p>This command can return very large results, especially if <em>group_pattern</em> is not specified. It is best to cache the results offline unless you really need to refresh them.</p>
<p>在 3.2 版更改: <em>group_pattern</em> was added.</p>
<p><code>NNTP.descriptions</code>(<em>grouppattern</em>)</p>
<p>Send a <code>LIST NEWSGROUPS</code> command, where <em>grouppattern</em> is a wildmat string as specified in <a href="https://tools.ietf.org/html/rfc3977.html" target="_blank" rel="noopener"><strong>RFC 3977</strong></a> (it’s essentially the same as DOS or UNIX shell wildcard strings). Return a pair <code>(response, descriptions)</code>, where <em>descriptions</em> is a dictionary mapping group names to textual descriptions.</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> resp<span class="token punctuation">,</span> descs <span class="token operator">=</span> s<span class="token punctuation">.</span>descriptions<span class="token punctuation">(</span><span class="token string">'gmane.comp.python.*'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> len<span class="token punctuation">(</span>descs<span class="token punctuation">)</span> 
<span class="token number">295</span>
<span class="token operator">>></span><span class="token operator">></span> descs<span class="token punctuation">.</span>popitem<span class="token punctuation">(</span><span class="token punctuation">)</span> 
<span class="token punctuation">(</span><span class="token string">'gmane.comp.python.bio.general'</span><span class="token punctuation">,</span> <span class="token string">'BioPython discussion list (Moderated)'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>NNTP.description</code>(<em>group</em>)</p>
<p>Get a description for a single group <em>group</em>. If more than one group matches (if ‘group’ is a real wildmat string), return the first match. If no group matches, return an empty string.</p>
<p>This elides the response code from the server. If the response code is needed, use <code>descriptions()</code>.</p>
<p><code>NNTP.group</code>(<em>name</em>)</p>
<p>Send a <code>GROUP</code> command, where <em>name</em> is the group name. The group is selected as the current group, if it exists. Return a tuple <code>(response, count, first, last, name)</code> where <em>count</em> is the (estimated) number of articles in the group, <em>first</em> is the first article number in the group, <em>last</em> is the last article number in the group, and <em>name</em> is the group name.</p>
<p><code>NNTP.over</code>(<em>message_spec</em>, <em>**,</em> file=None*)</p>
<p>Send an <code>OVER</code> command, or an <code>XOVER</code> command on legacy servers. <em>message_spec</em> can be either a string representing a message id, or a <code>(first, last)</code> tuple of numbers indicating a range of articles in the current group, or a <code>(first, None)</code> tuple indicating a range of articles starting from <em>first</em> to the last article in the current group, or <code>None</code> to select the current article in the current group.</p>
<p>Return a pair <code>(response, overviews)</code>. <em>overviews</em> is a list of <code>(article_number, overview)</code> tuples, one for each article selected by <em>message_spec</em>. Each <em>overview</em> is a dictionary with the same number of items, but this number depends on the server. These items are either message headers (the key is then the lower-cased header name) or metadata items (the key is then the metadata name prepended with <code>":"</code>). The following items are guaranteed to be present by the NNTP specification:</p>
<ul>
<li>the <code>subject</code>, <code>from</code>, <code>date</code>, <code>message-id</code> and <code>references</code> headers</li>
<li>the <code>:bytes</code> metadata: the number of bytes in the entire raw article (including headers and body)</li>
<li>the <code>:lines</code> metadata: the number of lines in the article body</li>
</ul>
<p>The value of each item is either a string, or <code>None</code> if not present.</p>
<p>It is advisable to use the <code>decode_header()</code> function on header values when they may contain non-ASCII characters:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> _<span class="token punctuation">,</span> _<span class="token punctuation">,</span> first<span class="token punctuation">,</span> last<span class="token punctuation">,</span> _ <span class="token operator">=</span> s<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token string">'gmane.comp.python.devel'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> resp<span class="token punctuation">,</span> overviews <span class="token operator">=</span> s<span class="token punctuation">.</span>over<span class="token punctuation">(</span><span class="token punctuation">(</span>last<span class="token punctuation">,</span> last<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> art_num<span class="token punctuation">,</span> over <span class="token operator">=</span> overviews<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> art_num
<span class="token number">117216</span>
<span class="token operator">>></span><span class="token operator">></span> list<span class="token punctuation">(</span>over<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token string">'xref'</span><span class="token punctuation">,</span> <span class="token string">'from'</span><span class="token punctuation">,</span> <span class="token string">':lines'</span><span class="token punctuation">,</span> <span class="token string">':bytes'</span><span class="token punctuation">,</span> <span class="token string">'references'</span><span class="token punctuation">,</span> <span class="token string">'date'</span><span class="token punctuation">,</span> <span class="token string">'message-id'</span><span class="token punctuation">,</span> <span class="token string">'subject'</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> over<span class="token punctuation">[</span><span class="token string">'from'</span><span class="token punctuation">]</span>
<span class="token string">'=?UTF-8?B?Ik1hcnRpbiB2LiBMw7Z3aXMi?= &lt;martin@v.loewis.de>'</span>
<span class="token operator">>></span><span class="token operator">></span> nntplib<span class="token punctuation">.</span>decode_header<span class="token punctuation">(</span>over<span class="token punctuation">[</span><span class="token string">'from'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token string">'"Martin v. Löwis" &lt;martin@v.loewis.de>'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>3.2 新版功能.</p>
<p><code>NNTP.help</code>(<em>**,</em> file=None*)</p>
<p>Send a <code>HELP</code> command. Return a pair <code>(response, list)</code> where <em>list</em> is a list of help strings.</p>
<p><code>NNTP.stat</code>(<em>message_spec=None</em>)</p>
<p>Send a <code>STAT</code> command, where <em>message_spec</em> is either a message id (enclosed in <code>'&lt;'</code> and <code>'&gt;'</code>) or an article number in the current group. If <em>message_spec</em> is omitted or <code>None</code>, the current article in the current group is considered. Return a triple <code>(response, number, id)</code> where <em>number</em> is the article number and <em>id</em> is the message id.</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> _<span class="token punctuation">,</span> _<span class="token punctuation">,</span> first<span class="token punctuation">,</span> last<span class="token punctuation">,</span> _ <span class="token operator">=</span> s<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token string">'gmane.comp.python.devel'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> resp<span class="token punctuation">,</span> number<span class="token punctuation">,</span> message_id <span class="token operator">=</span> s<span class="token punctuation">.</span>stat<span class="token punctuation">(</span>first<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> number<span class="token punctuation">,</span> message_id
<span class="token punctuation">(</span><span class="token number">9099</span><span class="token punctuation">,</span> <span class="token string">'&lt;20030112190404.GE29873@epoch.metaslash.com>'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>NNTP.next</code>()</p>
<p>Send a <code>NEXT</code> command. Return as for <code>stat()</code>.</p>
<p><code>NNTP.last</code>()</p>
<p>Send a <code>LAST</code> command. Return as for <code>stat()</code>.</p>
<p><code>NNTP.article</code>(<em>message_spec=None</em>, <em>**,</em> file=None*)</p>
<p>Send an <code>ARTICLE</code> command, where <em>message_spec</em> has the same meaning as for <code>stat()</code>. Return a tuple <code>(response, info)</code> where <em>info</em> is a <code>namedtuple</code> with three attributes <em>number</em>, <em>message_id</em> and <em>lines</em> (in that order). <em>number</em> is the article number in the group (or 0 if the information is not available), <em>message_id</em> the message id as a string, and <em>lines</em> a list of lines (without terminating newlines) comprising the raw message including headers and body.</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> resp<span class="token punctuation">,</span> info <span class="token operator">=</span> s<span class="token punctuation">.</span>article<span class="token punctuation">(</span><span class="token string">'&lt;20030112190404.GE29873@epoch.metaslash.com>'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> info<span class="token punctuation">.</span>number
<span class="token number">0</span>
<span class="token operator">>></span><span class="token operator">></span> info<span class="token punctuation">.</span>message_id
<span class="token string">'&lt;20030112190404.GE29873@epoch.metaslash.com>'</span>
<span class="token operator">>></span><span class="token operator">></span> len<span class="token punctuation">(</span>info<span class="token punctuation">.</span>lines<span class="token punctuation">)</span>
<span class="token number">65</span>
<span class="token operator">>></span><span class="token operator">></span> info<span class="token punctuation">.</span>lines<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
b<span class="token string">'Path: main.gmane.org!not-for-mail'</span>
<span class="token operator">>></span><span class="token operator">></span> info<span class="token punctuation">.</span>lines<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>
b<span class="token string">'From: Neal Norwitz &lt;neal@metaslash.com>'</span>
<span class="token operator">>></span><span class="token operator">></span> info<span class="token punctuation">.</span>lines<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span>b<span class="token string">'There is a patch for 2.3 as well as 2.2.'</span><span class="token punctuation">,</span> b<span class="token string">''</span><span class="token punctuation">,</span> b<span class="token string">'Neal'</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>NNTP.head</code>(<em>message_spec=None</em>, <em>**,</em> file=None*)</p>
<p>Same as <code>article()</code>, but sends a <code>HEAD</code> command. The <em>lines</em> returned (or written to <em>file</em>) will only contain the message headers, not the body.</p>
<p><code>NNTP.body</code>(<em>message_spec=None</em>, <em>**,</em> file=None*)</p>
<p>Same as <code>article()</code>, but sends a <code>BODY</code> command. The <em>lines</em> returned (or written to <em>file</em>) will only contain the message body, not the headers.</p>
<p><code>NNTP.post</code>(<em>data</em>)</p>
<p>Post an article using the <code>POST</code> command. The <em>data</em> argument is either a file object opened for binary reading, or any iterable of bytes objects (representing raw lines of the article to be posted). It should represent a well-formed news article, including the required headers. The <code>post()</code> method automatically escapes lines beginning with <code>.</code> and appends the termination line.</p>
<p>If the method succeeds, the server’s response is returned. If the server refuses posting, a <code>NNTPReplyError</code> is raised.</p>
<p><code>NNTP.ihave</code>(<em>message_id</em>, <em>data</em>)</p>
<p>Send an <code>IHAVE</code> command. <em>message_id</em> is the id of the message to send to the server (enclosed in <code>'&lt;'</code> and <code>'&gt;'</code>). The <em>data</em> parameter and the return value are the same as for <code>post()</code>.</p>
<p><code>NNTP.date</code>()</p>
<p>Return a pair <code>(response, date)</code>. <em>date</em> is a <code>datetime</code> object containing the current date and time of the server.</p>
<p><code>NNTP.slave</code>()</p>
<p>Send a <code>SLAVE</code> command. Return the server’s <em>response</em>.</p>
<p><code>NNTP.set_debuglevel</code>(<em>level</em>)</p>
<p>Set the instance’s debugging level. This controls the amount of debugging output printed. The default, <code>0</code>, produces no debugging output. A value of <code>1</code> produces a moderate amount of debugging output, generally a single line per request or response. A value of <code>2</code> or higher produces the maximum amount of debugging output, logging each line sent and received on the connection (including message text).</p>
<p>The following are optional NNTP extensions defined in <a href="https://tools.ietf.org/html/rfc2980.html" target="_blank" rel="noopener"><strong>RFC 2980</strong></a>. Some of them have been superseded by newer commands in <a href="https://tools.ietf.org/html/rfc3977.html" target="_blank" rel="noopener"><strong>RFC 3977</strong></a>.</p>
<p><code>NNTP.xhdr</code>(<em>hdr</em>, <em>str</em>, <em>**,</em> file=None*)</p>
<p>Send an <code>XHDR</code> command. The <em>hdr</em> argument is a header keyword, e.g. <code>'subject'</code>. The <em>str</em> argument should have the form <code>'first-last'</code> where <em>first</em> and <em>last</em> are the first and last article numbers to search. Return a pair <code>(response, list)</code>, where <em>list</em> is a list of pairs <code>(id, text)</code>, where <em>id</em> is an article number (as a string) and <em>text</em> is the text of the requested header for that article. If the <em>file</em> parameter is supplied, then the output of the <code>XHDR</code> command is stored in a file. If <em>file</em> is a string, then the method will open a file with that name, write to it then close it. If <em>file</em> is a file object, then it will start calling <code>write()</code> on it to store the lines of the command output. If <em>file</em> is supplied, then the returned <em>list</em> is an empty list.</p>
<p><code>NNTP.xover</code>(<em>start</em>, <em>end</em>, <em>**,</em> file=None*)</p>
<p>Send an <code>XOVER</code> command. <em>start</em> and <em>end</em> are article numbers delimiting the range of articles to select. The return value is the same of for <code>over()</code>. It is recommended to use <code>over()</code> instead, since it will automatically use the newer <code>OVER</code> command if available.</p>
<h3 id="工具函数"><a href="#工具函数" class="headerlink" title="工具函数"></a>工具函数</h3><p>The module also defines the following utility function:</p>
<p><code>nntplib.decode_header</code>(<em>header_str</em>)</p>
<p>Decode a header value, un-escaping any escaped non-ASCII characters. <em>header_str</em> must be a <a href="https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#str" target="_blank" rel="noopener"><code>str</code></a> object. The unescaped value is returned. Using this function is recommended to display some headers in a human readable form:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> decode_header<span class="token punctuation">(</span><span class="token string">"Some subject"</span><span class="token punctuation">)</span>
<span class="token string">'Some subject'</span>
<span class="token operator">>></span><span class="token operator">></span> decode_header<span class="token punctuation">(</span><span class="token string">"=?ISO-8859-15?Q?D=E9buter_en_Python?="</span><span class="token punctuation">)</span>
<span class="token string">'Débuter en Python'</span>
<span class="token operator">>></span><span class="token operator">></span> decode_header<span class="token punctuation">(</span><span class="token string">"Re: =?UTF-8?B?cHJvYmzDqG1lIGRlIG1hdHJpY2U=?="</span><span class="token punctuation">)</span>
<span class="token string">'Re: problème de matrice'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="smtplib-—-SMTP协议客户端"><a href="#smtplib-—-SMTP协议客户端" class="headerlink" title="smtplib —-SMTP协议客户端"></a><code>smtplib</code> —-SMTP协议客户端</h2><p><strong>源代码：</strong> <a href="https://github.com/python/cpython/tree/3.10/Lib/smtplib.py" target="_blank" rel="noopener">Lib/smtplib.py</a></p>
<hr>
<p>The <code>smtplib</code> module defines an SMTP client session object that can be used to send mail to any internet machine with an SMTP or ESMTP listener daemon. For details of SMTP and ESMTP operation, consult <a href="https://tools.ietf.org/html/rfc821.html" target="_blank" rel="noopener"><strong>RFC 821</strong></a> (Simple Mail Transfer Protocol) and <a href="https://tools.ietf.org/html/rfc1869.html" target="_blank" rel="noopener"><strong>RFC 1869</strong></a> (SMTP Service Extensions).</p>
<p><em>class</em> <code>smtplib.SMTP</code>(<em>host=’’</em>, <em>port=0</em>, <em>local_hostname=None</em>, [<em>timeout</em>, ]<em>source_address=None</em>)</p>
<p>An <code>SMTP</code> instance encapsulates an SMTP connection. It has methods that support a full repertoire of SMTP and ESMTP operations. If the optional host and port parameters are given, the SMTP <code>connect()</code> method is called with those parameters during initialization. If specified, <em>local_hostname</em> is used as the FQDN of the local host in the HELO/EHLO command. Otherwise, the local hostname is found using <code>socket.getfqdn()</code>. If the <code>connect()</code> call returns anything other than a success code, an <code>SMTPConnectError</code> is raised. The optional <em>timeout</em> parameter specifies a timeout in seconds for blocking operations like the connection attempt (if not specified, the global default timeout setting will be used). If the timeout expires, <code>TimeoutError</code> is raised. The optional source_address parameter allows binding to some specific source address in a machine with multiple network interfaces, and/or to some specific source TCP port. It takes a 2-tuple (host, port), for the socket to bind to as its source address before connecting. If omitted (or if host or port are <code>''</code> and/or 0 respectively) the OS default behavior will be used.</p>
<p>正常使用时，只需要初始化或 connect 方法，<code>sendmail()</code> 方法，再加上 <code>SMTP.quit()</code> 方法即可。下文包括了一个示例。</p>
<p><code>SMTP</code> 类支持 <code>with</code> 语句。当这样使用时，<code>with</code> 语句一退出就会自动发出 SMTP <code>QUIT</code> 命令。例如:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> smtplib <span class="token keyword">import</span> SMTP
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">with</span> SMTP<span class="token punctuation">(</span><span class="token string">"domain.org"</span><span class="token punctuation">)</span> <span class="token keyword">as</span> smtp<span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     smtp<span class="token punctuation">.</span>noop<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">(</span><span class="token number">250</span><span class="token punctuation">,</span> b<span class="token string">'Ok'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>All commands will raise an auditing event <code>smtplib.SMTP.send</code> with arguments <code>self</code> and <code>data</code>, where <code>data</code> is the bytes about to be sent to the remote host.</p>
<p>在 3.3 版更改: 添加了对 <code>with</code> 语句的支持。</p>
<p>在 3.3 版更改: source_address argument was added.</p>
<p>3.5 新版功能: The SMTPUTF8 extension (<a href="https://tools.ietf.org/html/rfc6531.html" target="_blank" rel="noopener"><strong>RFC 6531</strong></a>) is now supported.</p>
<p>在 3.9 版更改: If the <em>timeout</em> parameter is set to be zero, it will raise a <code>ValueError</code> to prevent the creation of a non-blocking socket</p>
<p><em>class</em> <code>smtplib.SMTP_SSL</code>(<em>host=’’</em>, <em>port=0</em>, <em>local_hostname=None</em>, <em>keyfile=None</em>, <em>certfile=None</em>, [<em>timeout</em>, ]<em>context=None</em>, <em>source_address=None</em>)</p>
<p><code>SMTP_SSL</code> 实例与 <code>SMTP</code> 实例的行为完全相同。在开始连接就需要 SSL，且 <code>starttls()</code> 不适合的情况下，应该使用 <code>SMTP_SSL</code>。如果未指定 <em>host*，则使用 localhost。如果 *port</em> 为 0，则使用标准 SMTP-over-SSL 端口（465）。可选参数 <em>local_hostname<em>、</em>timeout</em> 和 <em>source_address</em> 的含义与 <code>SMTP</code> 类中的相同。可选参数 <em>context</em> 是一个 <code>SSLContext</code> 对象，可以从多个方面配置安全连接。</p>
<p><em>keyfile</em> and <em>certfile</em> are a legacy alternative to <em>context</em>, and can point to a PEM formatted private key and certificate chain file for the SSL connection.</p>
<p>在 3.3 版更改: 增加了 <em>context</em>。</p>
<p>在 3.3 版更改: source_address argument was added.</p>
<p>在 3.4 版更改: 本类现在支持使用 <code>ssl.SSLContext.check_hostname</code> 和 <em>服务器名称指示</em> 进行主机名检查。</p>
<p>3.6 版后已移除: <em>keyfile</em> 和 <em>certfile</em> 已弃用并转而推荐 <em>context</em>。 请改用 <code>ssl.SSLContext.load_cert_chain()</code> 或让 <code>ssl.create_default_context()</code> 为你选择系统所信任的 CA 证书。</p>
<p>在 3.9 版更改: If the <em>timeout</em> parameter is set to be zero, it will raise a <code>ValueError</code> to prevent the creation of a non-blocking socket</p>
<p><em>class</em> <code>smtplib.LMTP</code>(<em>host=’’</em>, <em>port=LMTP_PORT</em>, <em>local_hostname=None</em>, <em>source_address=None</em>[, <em>timeout</em>])</p>
<p>LMTP 协议与 ESMTP 非常相似，它很大程度上基于标准的 SMTP 客户端。将 Unix 套接字用于 LMTP 是很常见的，因此 <code>connect()</code> 方法支持 Unix 套接字，也支持常规的 host:port 服务器。可选参数 local_hostname 和 source_address 的含义与 <code>SMTP</code> 类中的相同。要指定 Unix 套接字，<em>host</em> 必须使用绝对路径，以 ‘/‘ 开头。</p>
<p>Authentication is supported, using the regular SMTP mechanism. When using a Unix socket, LMTP generally don’t support or require any authentication, but your mileage might vary.</p>
<p>在 3.9 版更改: The optional <em>timeout</em> parameter was added.</p>
<p>A nice selection of exceptions is defined as well:</p>
<p><em>exception</em> <code>smtplib.SMTPException</code></p>
<p>Subclass of <code>OSError</code> that is the base exception class for all the other exceptions provided by this module.</p>
<p>在 3.4 版更改: SMTPException became subclass of <code>OSError</code></p>
<p><em>exception</em> <code>smtplib.SMTPServerDisconnected</code></p>
<p>This exception is raised when the server unexpectedly disconnects, or when an attempt is made to use the <code>SMTP</code> instance before connecting it to a server.</p>
<p><em>exception</em> <code>smtplib.SMTPResponseException</code></p>
<p>Base class for all exceptions that include an SMTP error code. These exceptions are generated in some instances when the SMTP server returns an error code. The error code is stored in the <code>smtp_code</code> attribute of the error, and the <code>smtp_error</code> attribute is set to the error message.</p>
<p><em>exception</em> <code>smtplib.SMTPSenderRefused</code></p>
<p>Sender address refused. In addition to the attributes set by on all <code>SMTPResponseException</code> exceptions, this sets ‘sender’ to the string that the SMTP server refused.</p>
<p><em>exception</em> <code>smtplib.SMTPRecipientsRefused</code></p>
<p>All recipient addresses refused. The errors for each recipient are accessible through the attribute <code>recipients</code>, which is a dictionary of exactly the same sort as <code>SMTP.sendmail()</code> returns.</p>
<p><em>exception</em> <code>smtplib.SMTPDataError</code></p>
<p>The SMTP server refused to accept the message data.</p>
<p><em>exception</em> <code>smtplib.SMTPConnectError</code></p>
<p>Error occurred during establishment of a connection with the server.</p>
<p><em>exception</em> <code>smtplib.SMTPHeloError</code></p>
<p>The server refused our <code>HELO</code> message.</p>
<p><em>exception</em> <code>smtplib.SMTPNotSupportedError</code></p>
<p>The command or option attempted is not supported by the server.</p>
<p>3.5 新版功能.</p>
<p><em>exception</em> <code>smtplib.SMTPAuthenticationError</code></p>
<p>SMTP authentication went wrong. Most probably the server didn’t accept the username/password combination provided.</p>
<p>参见</p>
<p><a href="https://tools.ietf.org/html/rfc821.html" target="_blank" rel="noopener"><strong>RFC 821</strong></a> - Simple Mail Transfer Protocol</p>
<p>Protocol definition for SMTP. This document covers the model, operating procedure, and protocol details for SMTP.</p>
<p><a href="https://tools.ietf.org/html/rfc1869.html" target="_blank" rel="noopener"><strong>RFC 1869</strong></a> - SMTP Service Extensions</p>
<p>Definition of the ESMTP extensions for SMTP. This describes a framework for extending SMTP with new commands, supporting dynamic discovery of the commands provided by the server, and defines a few additional commands.</p>
<h3 id="SMTP-Objects"><a href="#SMTP-Objects" class="headerlink" title="SMTP Objects"></a>SMTP Objects</h3><p>An <code>SMTP</code> instance has the following methods:</p>
<p><code>SMTP.set_debuglevel</code>(<em>level</em>)</p>
<p>Set the debug output level. A value of 1 or <code>True</code> for <em>level</em> results in debug messages for connection and for all messages sent to and received from the server. A value of 2 for <em>level</em> results in these messages being timestamped.</p>
<p>在 3.5 版更改: Added debuglevel 2.</p>
<p><code>SMTP.docmd</code>(<em>cmd</em>, <em>args=’’</em>)</p>
<p>Send a command <em>cmd</em> to the server. The optional argument <em>args</em> is simply concatenated to the command, separated by a space.</p>
<p>This returns a 2-tuple composed of a numeric response code and the actual response line (multiline responses are joined into one long line.)</p>
<p>In normal operation it should not be necessary to call this method explicitly. It is used to implement other methods and may be useful for testing private extensions.</p>
<p>If the connection to the server is lost while waiting for the reply, <code>SMTPServerDisconnected</code> will be raised.</p>
<p><code>SMTP.connect</code>(<em>host=’localhost’</em>, <em>port=0</em>)</p>
<p>连接到某个主机的某个端口。默认是连接到 localhost 的标准 SMTP 端口（25）上。如果主机名以冒号 (<code>':'</code>) 结尾，后跟数字，则该后缀将被删除，且数字将视作要使用的端口号。如果在实例化时指定了 host，则构造函数会自动调用本方法。返回包含响应码和响应消息的 2 元组，它们由服务器在其连接响应中发送。</p>
<p>Raises an auditing event <code>smtplib.connect</code> with arguments <code>self</code>, <code>host</code>, <code>port</code>.</p>
<p><code>SMTP.helo</code>(<em>name=’’</em>)</p>
<p>Identify yourself to the SMTP server using <code>HELO</code>. The hostname argument defaults to the fully qualified domain name of the local host. The message returned by the server is stored as the <code>helo_resp</code> attribute of the object.</p>
<p>In normal operation it should not be necessary to call this method explicitly. It will be implicitly called by the <code>sendmail()</code> when necessary.</p>
<p><code>SMTP.ehlo</code>(<em>name=’’</em>)</p>
<p>Identify yourself to an ESMTP server using <code>EHLO</code>. The hostname argument defaults to the fully qualified domain name of the local host. Examine the response for ESMTP option and store them for use by <code>has_extn()</code>. Also sets several informational attributes: the message returned by the server is stored as the <code>ehlo_resp</code> attribute, <code>does_esmtp</code> is set to <code>True</code> or <code>False</code> depending on whether the server supports ESMTP, and <code>esmtp_features</code> will be a dictionary containing the names of the SMTP service extensions this server supports, and their parameters (if any).</p>
<p>Unless you wish to use <code>has_extn()</code> before sending mail, it should not be necessary to call this method explicitly. It will be implicitly called by <code>sendmail()</code> when necessary.</p>
<p><code>SMTP.ehlo_or_helo_if_needed</code>()</p>
<p>This method calls <code>ehlo()</code> and/or <code>helo()</code> if there has been no previous <code>EHLO</code> or <code>HELO</code> command this session. It tries ESMTP <code>EHLO</code> first.</p>
<ul>
<li><p><code>SMTPHeloError</code></p>
<p>The server didn’t reply properly to the <code>HELO</code> greeting.</p>
</li>
</ul>
<p><code>SMTP.has_extn</code>(<em>name</em>)</p>
<p>Return <code>True</code> if <em>name</em> is in the set of SMTP service extensions returned by the server, <code>False</code> otherwise. Case is ignored.</p>
<p><code>SMTP.verify</code>(<em>address</em>)</p>
<p>Check the validity of an address on this server using SMTP <code>VRFY</code>. Returns a tuple consisting of code 250 and a full <a href="https://tools.ietf.org/html/rfc822.html" target="_blank" rel="noopener"><strong>RFC 822</strong></a> address (including human name) if the user address is valid. Otherwise returns an SMTP error code of 400 or greater and an error string.</p>
<p>注解</p>
<p>Many sites disable SMTP <code>VRFY</code> in order to foil spammers.</p>
<p><code>SMTP.login</code>(<em>user</em>, <em>password</em>, <em>**,</em> initial_response_ok=True*)</p>
<p>Log in on an SMTP server that requires authentication. The arguments are the username and the password to authenticate with. If there has been no previous <code>EHLO</code> or <code>HELO</code> command this session, this method tries ESMTP <code>EHLO</code> first. This method will return normally if the authentication was successful, or may raise the following exceptions:</p>
<ul>
<li><p><code>SMTPHeloError</code></p>
<p>The server didn’t reply properly to the <code>HELO</code> greeting.</p>
<p><code>SMTPAuthenticationError</code></p>
<p>The server didn’t accept the username/password combination.</p>
<p><code>SMTPNotSupportedError</code></p>
<p>The <code>AUTH</code> command is not supported by the server.</p>
<p><code>SMTPException</code></p>
<p>No suitable authentication method was found.</p>
</li>
</ul>
<p>Each of the authentication methods supported by <code>smtplib</code> are tried in turn if they are advertised as supported by the server. See <code>auth()</code> for a list of supported authentication methods. <em>initial_response_ok</em> is passed through to <code>auth()</code>.</p>
<p>Optional keyword argument <em>initial_response_ok</em> specifies whether, for authentication methods that support it, an “initial response” as specified in <a href="https://tools.ietf.org/html/rfc4954.html" target="_blank" rel="noopener"><strong>RFC 4954</strong></a> can be sent along with the <code>AUTH</code> command, rather than requiring a challenge/response.</p>
<p>在 3.5 版更改: <code>SMTPNotSupportedError</code> may be raised, and the <em>initial_response_ok</em> parameter was added.</p>
<p><code>SMTP.auth</code>(<em>mechanism</em>, <em>authobject</em>, <em>**,</em> initial_response_ok=True*)</p>
<p>Issue an <code>SMTP</code> <code>AUTH</code> command for the specified authentication <em>mechanism</em>, and handle the challenge response via <em>authobject</em>.</p>
<p><em>mechanism</em> specifies which authentication mechanism is to be used as argument to the <code>AUTH</code> command; the valid values are those listed in the <code>auth</code> element of <code>esmtp_features</code>.</p>
<p><em>authobject</em> must be a callable object taking an optional single argument:</p>
<blockquote>
<p>data = authobject(challenge=None)</p>
</blockquote>
<p>If optional keyword argument <em>initial_response_ok</em> is true, <code>authobject()</code> will be called first with no argument. It can return the <a href="https://tools.ietf.org/html/rfc4954.html" target="_blank" rel="noopener"><strong>RFC 4954</strong></a> “initial response” ASCII <code>str</code> which will be encoded and sent with the <code>AUTH</code> command as below. If the <code>authobject()</code> does not support an initial response (e.g. because it requires a challenge), it should return <code>None</code> when called with <code>challenge=None</code>. If <em>initial_response_ok</em> is false, then <code>authobject()</code> will not be called first with <code>None</code>.</p>
<p>If the initial response check returns <code>None</code>, or if <em>initial_response_ok</em> is false, <code>authobject()</code> will be called to process the server’s challenge response; the <em>challenge</em> argument it is passed will be a <code>bytes</code>. It should return ASCII <code>str</code> <em>data</em> that will be base64 encoded and sent to the server.</p>
<p>The <code>SMTP</code> class provides <code>authobjects</code> for the <code>CRAM-MD5</code>, <code>PLAIN</code>, and <code>LOGIN</code> mechanisms; they are named <code>SMTP.auth_cram_md5</code>, <code>SMTP.auth_plain</code>, and <code>SMTP.auth_login</code> respectively. They all require that the <code>user</code> and <code>password</code> properties of the <code>SMTP</code> instance are set to appropriate values.</p>
<p>User code does not normally need to call <code>auth</code> directly, but can instead call the <code>login()</code> method, which will try each of the above mechanisms in turn, in the order listed. <code>auth</code> is exposed to facilitate the implementation of authentication methods not (or not yet) supported directly by <code>smtplib</code>.</p>
<p>3.5 新版功能.</p>
<p><code>SMTP.starttls</code>(<em>keyfile=None</em>, <em>certfile=None</em>, <em>context=None</em>)</p>
<p>Put the SMTP connection in TLS (Transport Layer Security) mode. All SMTP commands that follow will be encrypted. You should then call <code>ehlo()</code> again.</p>
<p>If <em>keyfile</em> and <em>certfile</em> are provided, they are used to create an <code>ssl.SSLContext</code>.</p>
<p>Optional <em>context</em> parameter is an <code>ssl.SSLContext</code> object; This is an alternative to using a keyfile and a certfile and if specified both <em>keyfile</em> and <em>certfile</em> should be <code>None</code>.</p>
<p>If there has been no previous <code>EHLO</code> or <code>HELO</code> command this session, this method tries ESMTP <code>EHLO</code> first.</p>
<p>3.6 版后已移除: <em>keyfile</em> 和 <em>certfile</em> 已弃用并转而推荐 <em>context</em>。 请改用 <code>ssl.SSLContext.load_cert_chain()</code> 或让 <code>ssl.create_default_context()</code> 为你选择系统所信任的 CA 证书。</p>
<ul>
<li><p><code>SMTPHeloError</code></p>
<p>The server didn’t reply properly to the <code>HELO</code> greeting.</p>
<p><code>SMTPNotSupportedError</code></p>
<p>The server does not support the STARTTLS extension.</p>
<p><code>RuntimeError</code></p>
<p>SSL/TLS support is not available to your Python interpreter.</p>
</li>
</ul>
<p>在 3.3 版更改: 增加了 <em>context</em>。</p>
<p>在 3.4 版更改: The method now supports hostname check with <code>SSLContext.check_hostname</code> and <em>Server Name Indicator</em> (see <code>HAS_SNI</code>).</p>
<p>在 3.5 版更改: The error raised for lack of STARTTLS support is now the <code>SMTPNotSupportedError</code> subclass instead of the base <code>SMTPException</code>.</p>
<p><code>SMTP.sendmail</code>(<em>from_addr</em>, <em>to_addrs</em>, <em>msg</em>, <em>mail_options=()</em>, <em>rcpt_options=()</em>)</p>
<p>发送邮件。必要参数是一个 <a href="https://tools.ietf.org/html/rfc822.html" target="_blank" rel="noopener"><strong>RFC 822</strong></a> 发件地址字符串，一个 <a href="https://tools.ietf.org/html/rfc822.html" target="_blank" rel="noopener"><strong>RFC 822</strong></a> 收件地址字符串列表（裸字符串将被视为含有 1 个地址的列表），以及一个消息字符串。调用者可以将 ESMTP 选项列表（如 <code>8bitmime</code>）作为 <em>mail_options</em> 传入，用于 <code>MAIL FROM</code> 命令。需要与所有 <code>RCPT</code> 命令一起使用的 ESMTP 选项（如 <code>DSN</code> 命令）可以作为 <em>rcpt_options</em> 传入。（如果需要对不同的收件人使用不同的 ESMTP 选项，则必须使用底层的方法来发送消息，如 <code>mail()</code>, <code>rcpt()</code> 和 <code>data()</code>。）</p>
<p>注解</p>
<p>The <em>from_addr</em> and <em>to_addrs</em> parameters are used to construct the message envelope used by the transport agents. <code>sendmail</code> does not modify the message headers in any way.</p>
<p><em>msg</em> may be a string containing characters in the ASCII range, or a byte string. A string is encoded to bytes using the ascii codec, and lone <code>\r</code> and <code>\n</code> characters are converted to <code>\r\n</code> characters. A byte string is not modified.</p>
<p>If there has been no previous <code>EHLO</code> or <code>HELO</code> command this session, this method tries ESMTP <code>EHLO</code> first. If the server does ESMTP, message size and each of the specified options will be passed to it (if the option is in the feature set the server advertises). If <code>EHLO</code> fails, <code>HELO</code> will be tried and ESMTP options suppressed.</p>
<p>This method will return normally if the mail is accepted for at least one recipient. Otherwise it will raise an exception. That is, if this method does not raise an exception, then someone should get your mail. If this method does not raise an exception, it returns a dictionary, with one entry for each recipient that was refused. Each entry contains a tuple of the SMTP error code and the accompanying error message sent by the server.</p>
<p>If <code>SMTPUTF8</code> is included in <em>mail_options</em>, and the server supports it, <em>from_addr</em> and <em>to_addrs</em> may contain non-ASCII characters.</p>
<p>This method may raise the following exceptions:</p>
<ul>
<li><p><code>SMTPRecipientsRefused</code></p>
<p>All recipients were refused. Nobody got the mail. The <code>recipients</code> attribute of the exception object is a dictionary with information about the refused recipients (like the one returned when at least one recipient was accepted).</p>
<p><code>SMTPHeloError</code></p>
<p>The server didn’t reply properly to the <code>HELO</code> greeting.</p>
<p><code>SMTPSenderRefused</code></p>
<p>The server didn’t accept the <em>from_addr</em>.</p>
<p><code>SMTPDataError</code></p>
<p>The server replied with an unexpected error code (other than a refusal of a recipient).</p>
<p><code>SMTPNotSupportedError</code></p>
<p><code>SMTPUTF8</code> was given in the <em>mail_options</em> but is not supported by the server.</p>
</li>
</ul>
<p>Unless otherwise noted, the connection will be open even after an exception is raised.</p>
<p>在 3.2 版更改: <em>msg</em> may be a byte string.</p>
<p>在 3.5 版更改: <code>SMTPUTF8</code> support added, and <code>SMTPNotSupportedError</code> may be raised if <code>SMTPUTF8</code> is specified but the server does not support it.</p>
<p><code>SMTP.send_message</code>(<em>msg</em>, <em>from_addr=None</em>, <em>to_addrs=None</em>, <em>mail_options=()</em>, <em>rcpt_options=()</em>)</p>
<p>本方法是一种快捷方法，用于带着消息调用 <code>sendmail()</code>，消息由 <code>email.message.Message</code> 对象表示。参数的含义与 <code>sendmail()</code> 中的相同，除了 <em>msg</em>，它是一个 <code>Message</code> 对象。</p>
<p>如果 <em>from_addr</em> 为 <code>None</code> 或 <em>to_addrs</em> 为 <code>None</code>，那么<code>send_message</code>将根据 <a href="https://tools.ietf.org/html/rfc5322.html" target="_blank" rel="noopener"><strong>RFC 5322</strong></a>，从 <em>msg</em> 头部提取地址填充下列参数：如果头部存在 <em>Sender</em> 字段，则用它填充 <em>from_addr*，不存在则用 *From</em> 字段填充 <em>from_addr<em>。</em>to_addrs</em> 组合了 <em>msg</em> 中的 <em>To</em>, <em>Cc</em> 和 <em>Bcc</em> 字段的值（字段存在的情况下）。如果一组 <em>Resent-** 头部恰好出现在 message 中，那么就忽略常规的头部，改用</em> Resent-* <em>头部。如果 message 包含多组</em> Resent-* <em>头部，则引发 <code>ValueError</code>，因为无法明确检测出哪一组</em> Resent-* 头部是最新的。</p>
<p><code>send_message</code> 使用 <code>BytesGenerator</code> 来序列化 <em>msg<em>，且将 <code>\r\n</code> 作为 *linesep</em>，并调用 <code>sendmail()</code> 来传输序列化后的结果。无论 *from_addr</em> 和 <em>to_addrs</em> 的值为何，<code>send_message</code> 都不会传输 <em>msg</em> 中可能出现的 <em>Bcc</em> 或 <em>Resent-Bcc</em> 头部。如果 <em>from_addr</em> 和 <em>to_addrs</em> 中的某个地址包含非 ASCII 字符，且服务器没有声明支持 <code>SMTPUTF8</code>，则引发 <code>SMTPNotSupported</code> 错误。如果服务器支持，则 <code>Message</code> 将按新克隆的 <code>policy</code> 进行序列化，其中的 <code>utf8</code> 属性被设置为 <code>True</code>，且 <code>SMTPUTF8</code> 和 <code>BODY=8BITMIME</code> 被添加到 <em>mail_options</em> 中。</p>
<p>3.2 新版功能.</p>
<p>3.5 新版功能: Support for internationalized addresses (<code>SMTPUTF8</code>).</p>
<p><code>SMTP.quit</code>()</p>
<p>Terminate the SMTP session and close the connection. Return the result of the SMTP <code>QUIT</code> command.</p>
<p>Low-level methods corresponding to the standard SMTP/ESMTP commands <code>HELP</code>, <code>RSET</code>, <code>NOOP</code>, <code>MAIL</code>, <code>RCPT</code>, and <code>DATA</code> are also supported. Normally these do not need to be called directly, so they are not documented here. For details, consult the module code.</p>
<h3 id="SMTP-Example"><a href="#SMTP-Example" class="headerlink" title="SMTP Example"></a>SMTP Example</h3><p>This example prompts the user for addresses needed in the message envelope (‘To’ and ‘From’ addresses), and the message to be delivered. Note that the headers to be included with the message must be included in the message as entered; this example doesn’t do any processing of the <a href="https://tools.ietf.org/html/rfc822.html" target="_blank" rel="noopener"><strong>RFC 822</strong></a> headers. In particular, the ‘To’ and ‘From’ addresses must be included in the message headers explicitly.</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> smtplib
<span class="token keyword">def</span> <span class="token function">prompt</span><span class="token punctuation">(</span>prompt<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">return</span> input<span class="token punctuation">(</span>prompt<span class="token punctuation">)</span><span class="token punctuation">.</span>strip<span class="token punctuation">(</span><span class="token punctuation">)</span>
fromaddr <span class="token operator">=</span> prompt<span class="token punctuation">(</span><span class="token string">"From: "</span><span class="token punctuation">)</span>
toaddrs  <span class="token operator">=</span> prompt<span class="token punctuation">(</span><span class="token string">"To: "</span><span class="token punctuation">)</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Enter message, end with ^D (Unix) or ^Z (Windows):"</span><span class="token punctuation">)</span>
<span class="token comment" spellcheck="true"># Add the From: and To: headers at the start!</span>
msg <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token string">"From: %s\r\nTo: %s\r\n\r\n"</span>
       <span class="token operator">%</span> <span class="token punctuation">(</span>fromaddr<span class="token punctuation">,</span> <span class="token string">", "</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>toaddrs<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>
    <span class="token keyword">try</span><span class="token punctuation">:</span>
        line <span class="token operator">=</span> input<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">except</span> EOFError<span class="token punctuation">:</span>
        <span class="token keyword">break</span>
    <span class="token keyword">if</span> <span class="token operator">not</span> line<span class="token punctuation">:</span>
        <span class="token keyword">break</span>
    msg <span class="token operator">=</span> msg <span class="token operator">+</span> line
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Message length is"</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">)</span>
server <span class="token operator">=</span> smtplib<span class="token punctuation">.</span>SMTP<span class="token punctuation">(</span><span class="token string">'localhost'</span><span class="token punctuation">)</span>
server<span class="token punctuation">.</span>set_debuglevel<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
server<span class="token punctuation">.</span>sendmail<span class="token punctuation">(</span>fromaddr<span class="token punctuation">,</span> toaddrs<span class="token punctuation">,</span> msg<span class="token punctuation">)</span>
server<span class="token punctuation">.</span>quit<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>注解</p>
<p>In general, you will want to use the <code>email</code> package’s features to construct an email message, which you can then send via <code>send_message()</code>; see email: 示例.</p>
<h2 id="smtpd-—-SMTP-服务器"><a href="#smtpd-—-SMTP-服务器" class="headerlink" title="smtpd —- SMTP 服务器"></a><code>smtpd</code> —- SMTP 服务器</h2><p><strong>源代码:</strong> <a href="https://github.com/python/cpython/tree/3.10/Lib/smtpd.py" target="_blank" rel="noopener">Lib/smtpd.py</a></p>
<hr>
<p>This module offers several classes to implement SMTP (email) servers.</p>
<p>3.6 版后已移除: The aiosmtpd package is a recommended replacement for this module. It is based on <code>asyncio</code> and provides a more straightforward API.</p>
<p>Several server implementations are present; one is a generic do-nothing implementation, which can be overridden, while the other two offer specific mail-sending strategies.</p>
<p>Additionally the SMTPChannel may be extended to implement very specific interaction behaviour with SMTP clients.</p>
<p>The code supports <a href="https://tools.ietf.org/html/rfc5321.html" target="_blank" rel="noopener"><strong>RFC 5321</strong></a>, plus the <a href="https://tools.ietf.org/html/rfc1870.html" target="_blank" rel="noopener"><strong>RFC 1870</strong></a> SIZE and <a href="https://tools.ietf.org/html/rfc6531.html" target="_blank" rel="noopener"><strong>RFC 6531</strong></a> SMTPUTF8 extensions.</p>
<h3 id="SMTPServer-对象"><a href="#SMTPServer-对象" class="headerlink" title="SMTPServer 对象"></a>SMTPServer 对象</h3><p><em>class</em> <code>smtpd.SMTPServer</code>(<em>localaddr</em>, <em>remoteaddr</em>, <em>data_size_limit=33554432</em>, <em>map=None</em>, <em>enable_SMTPUTF8=False</em>, <em>decode_data=False</em>)</p>
<p>Create a new <code>SMTPServer</code> object, which binds to local address <em>localaddr</em>. It will treat <em>remoteaddr</em> as an upstream SMTP relayer. Both <em>localaddr</em> and <em>remoteaddr</em> should be a (host, port) tuple. The object inherits from <code>asyncore.dispatcher</code>, and so will insert itself into <code>asyncore</code>‘s event loop on instantiation.</p>
<p><em>data_size_limit</em> specifies the maximum number of bytes that will be accepted in a <code>DATA</code> command. A value of <code>None</code> or <code>0</code> means no limit.</p>
<p><em>map</em> is the socket map to use for connections (an initially empty dictionary is a suitable value). If not specified the <code>asyncore</code> global socket map is used.</p>
<p><em>enable_SMTPUTF8</em> determines whether the <code>SMTPUTF8</code> extension (as defined in <a href="https://tools.ietf.org/html/rfc6531.html" target="_blank" rel="noopener"><strong>RFC 6531</strong></a>) should be enabled. The default is <code>False</code>. When <code>True</code>, <code>SMTPUTF8</code> is accepted as a parameter to the <code>MAIL</code> command and when present is passed to <code>process_message()</code> in the <code>kwargs['mail_options']</code> list. <em>decode_data</em> and <em>enable_SMTPUTF8</em> cannot be set to <code>True</code> at the same time.</p>
<p><em>decode_data</em> specifies whether the data portion of the SMTP transaction should be decoded using UTF-8. When <em>decode_data</em> is <code>False</code> (the default), the server advertises the <code>8BITMIME</code> extension (<a href="https://tools.ietf.org/html/rfc6152.html" target="_blank" rel="noopener"><strong>RFC 6152</strong></a>), accepts the <code>BODY=8BITMIME</code> parameter to the <code>MAIL</code> command, and when present passes it to <code>process_message()</code> in the <code>kwargs['mail_options']</code> list. <em>decode_data</em> and <em>enable_SMTPUTF8</em> cannot be set to <code>True</code> at the same time.</p>
<ul>
<li><p><code>process_message</code>(<em>peer</em>, <em>mailfrom</em>, <em>rcpttos</em>, <em>data</em>, <em>**kwargs</em>)</p>
<p>Raise a <code>NotImplementedError</code> exception. Override this in subclasses to do something useful with this message. Whatever was passed in the constructor as <em>remoteaddr</em> will be available as the <code>_remoteaddr</code> attribute. <em>peer</em> is the remote host’s address, <em>mailfrom</em> is the envelope originator, <em>rcpttos</em> are the envelope recipients and <em>data</em> is a string containing the contents of the e-mail (which should be in <a href="https://tools.ietf.org/html/rfc5321.html" target="_blank" rel="noopener"><strong>RFC 5321</strong></a> format).</p>
<p>If the <em>decode_data</em> constructor keyword is set to <code>True</code>, the <em>data</em> argument will be a unicode string. If it is set to <code>False</code>, it will be a bytes object.</p>
<p><em>kwargs</em> is a dictionary containing additional information. It is empty if <code>decode_data=True</code> was given as an init argument, otherwise it contains the following keys:</p>
<blockquote>
<ul>
<li><p><em>mail_options</em>:</p>
<p>a list of all received parameters to the <code>MAIL</code> command (the elements are uppercase strings; example: <code>['BODY=8BITMIME', 'SMTPUTF8']</code>).</p>
<p><em>rcpt_options</em>:</p>
<p>same as <em>mail_options</em> but for the <code>RCPT</code> command. Currently no <code>RCPT TO</code> options are supported, so for now this will always be an empty list.</p>
</li>
</ul>
</blockquote>
<p>Implementations of <code>process_message</code> should use the <code>**kwargs</code> signature to accept arbitrary keyword arguments, since future feature enhancements may add keys to the kwargs dictionary.</p>
<p>Return <code>None</code> to request a normal <code>250 Ok</code> response; otherwise return the desired response string in <a href="https://tools.ietf.org/html/rfc5321.html" target="_blank" rel="noopener"><strong>RFC 5321</strong></a> format.</p>
</li>
<li><p><code>channel_class</code></p>
<p>Override this in subclasses to use a custom <code>SMTPChannel</code> for managing SMTP clients.</p>
</li>
</ul>
<p>3.4 新版功能: The <em>map</em> constructor argument.</p>
<p>在 3.5 版更改: <em>localaddr</em> and <em>remoteaddr</em> may now contain IPv6 addresses.</p>
<p>3.5 新版功能: The <em>decode_data</em> and <em>enable_SMTPUTF8</em> constructor parameters, and the <em>kwargs</em> parameter to <code>process_message()</code> when <em>decode_data</em> is <code>False</code>.</p>
<p>在 3.6 版更改: <em>decode_data</em> is now <code>False</code> by default.</p>
<h3 id="DebuggingServer-对象"><a href="#DebuggingServer-对象" class="headerlink" title="DebuggingServer 对象"></a>DebuggingServer 对象</h3><p><em>class</em> <code>smtpd.DebuggingServer</code>(<em>localaddr</em>, <em>remoteaddr</em>)</p>
<p>Create a new debugging server. Arguments are as per <code>SMTPServer</code>. Messages will be discarded, and printed on stdout.</p>
<h3 id="PureProxy对象"><a href="#PureProxy对象" class="headerlink" title="PureProxy对象"></a>PureProxy对象</h3><p><em>class</em> <code>smtpd.PureProxy</code>(<em>localaddr</em>, <em>remoteaddr</em>)</p>
<p>Create a new pure proxy server. Arguments are as per <code>SMTPServer</code>. Everything will be relayed to <em>remoteaddr</em>. Note that running this has a good chance to make you into an open relay, so please be careful.</p>
<h3 id="MailmanProxy-对象"><a href="#MailmanProxy-对象" class="headerlink" title="MailmanProxy 对象"></a>MailmanProxy 对象</h3><p><em>class</em> <code>smtpd.MailmanProxy</code>(<em>localaddr</em>, <em>remoteaddr</em>)</p>
<p>Deprecated since version 3.9, will be removed in version 3.11: <code>MailmanProxy</code> is deprecated, it depends on a <code>Mailman</code> module which no longer exists and therefore is already broken.</p>
<p>Create a new pure proxy server. Arguments are as per <code>SMTPServer</code>. Everything will be relayed to <em>remoteaddr</em>, unless local mailman configurations knows about an address, in which case it will be handled via mailman. Note that running this has a good chance to make you into an open relay, so please be careful.</p>
<h3 id="SMTPChannel-对象"><a href="#SMTPChannel-对象" class="headerlink" title="SMTPChannel 对象"></a>SMTPChannel 对象</h3><p><em>class</em> <code>smtpd.SMTPChannel</code>(<em>server</em>, <em>conn</em>, <em>addr</em>, <em>data_size_limit=33554432</em>, <em>map=None</em>, <em>enable_SMTPUTF8=False</em>, <em>decode_data=False</em>)</p>
<p>Create a new <code>SMTPChannel</code> object which manages the communication between the server and a single SMTP client.</p>
<p><em>conn</em> and <em>addr</em> are as per the instance variables described below.</p>
<p><em>data_size_limit</em> specifies the maximum number of bytes that will be accepted in a <code>DATA</code> command. A value of <code>None</code> or <code>0</code> means no limit.</p>
<p><em>enable_SMTPUTF8</em> determines whether the <code>SMTPUTF8</code> extension (as defined in <a href="https://tools.ietf.org/html/rfc6531.html" target="_blank" rel="noopener"><strong>RFC 6531</strong></a>) should be enabled. The default is <code>False</code>. <em>decode_data</em> and <em>enable_SMTPUTF8</em> cannot be set to <code>True</code> at the same time.</p>
<p>A dictionary can be specified in <em>map</em> to avoid using a global socket map.</p>
<p><em>decode_data</em> specifies whether the data portion of the SMTP transaction should be decoded using UTF-8. The default is <code>False</code>. <em>decode_data</em> and <em>enable_SMTPUTF8</em> cannot be set to <code>True</code> at the same time.</p>
<p>To use a custom SMTPChannel implementation you need to override the <code>SMTPServer.channel_class</code> of your <code>SMTPServer</code>.</p>
<p>在 3.5 版更改: The <em>decode_data</em> and <em>enable_SMTPUTF8</em> parameters were added.</p>
<p>在 3.6 版更改: <em>decode_data</em> is now <code>False</code> by default.</p>
<p>The <code>SMTPChannel</code> has the following instance variables:</p>
<ul>
<li><p><code>smtp_server</code></p>
<p>Holds the <code>SMTPServer</code> that spawned this channel.</p>
</li>
<li><p><code>conn</code></p>
<p>Holds the socket object connecting to the client.</p>
</li>
<li><p><code>addr</code></p>
<p>Holds the address of the client, the second value returned by <code>socket.accept</code></p>
</li>
<li><p><code>received_lines</code></p>
<p>Holds a list of the line strings (decoded using UTF-8) received from the client. The lines have their <code>"\r\n"</code> line ending translated to <code>"\n"</code>.</p>
</li>
<li><p><code>smtp_state</code></p>
<p>Holds the current state of the channel. This will be either <code>COMMAND</code> initially and then <code>DATA</code> after the client sends a “DATA” line.</p>
</li>
<li><p><code>seen_greeting</code></p>
<p>Holds a string containing the greeting sent by the client in its “HELO”.</p>
</li>
<li><p><code>mailfrom</code></p>
<p>Holds a string containing the address identified in the “MAIL FROM:” line from the client.</p>
</li>
<li><p><code>rcpttos</code></p>
<p>Holds a list of strings containing the addresses identified in the “RCPT TO:” lines from the client.</p>
</li>
<li><p><code>received_data</code></p>
<p>Holds a string containing all of the data sent by the client during the DATA state, up to but not including the terminating <code>"\r\n.\r\n"</code>.</p>
</li>
<li><p><code>fqdn</code></p>
<p>Holds the fully-qualified domain name of the server as returned by <code>socket.getfqdn()</code>.</p>
</li>
<li><p><code>peer</code></p>
<p>Holds the name of the client peer as returned by <code>conn.getpeername()</code> where <code>conn</code> is <code>conn</code>.</p>
</li>
</ul>
<p>The <code>SMTPChannel</code> operates by invoking methods named <code>smtp_&lt;command&gt;</code> upon reception of a command line from the client. Built into the base <code>SMTPChannel</code> class are methods for handling the following commands (and responding to them appropriately):</p>
<table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left">所采取的行动</th>
</tr>
</thead>
<tbody><tr>
<td align="left">HELO</td>
<td align="left">接受来自客户端的问候语，并将其存储在 <code>seen_greeting</code> 中。将服务器设置为基本命令模式。</td>
</tr>
<tr>
<td align="left">EHLO</td>
<td align="left">接受来自客户的问候并将其存储在 <code>seen_greeting</code> 中。将服务器设置为扩展命令模式。</td>
</tr>
<tr>
<td align="left">NOOP</td>
<td align="left">不采取任何措施。</td>
</tr>
<tr>
<td align="left">QUIT</td>
<td align="left">干净地关闭连接。</td>
</tr>
<tr>
<td align="left">MAIL</td>
<td align="left">Accepts the “MAIL FROM:” syntax and stores the supplied address as <code>mailfrom</code>. In extended command mode, accepts the <a href="https://tools.ietf.org/html/rfc1870.html" target="_blank" rel="noopener"><strong>RFC 1870</strong></a> SIZE attribute and responds appropriately based on the value of <em>data_size_limit</em>.</td>
</tr>
<tr>
<td align="left">RCPT</td>
<td align="left">Accepts the “RCPT TO:” syntax and stores the supplied addresses in the <code>rcpttos</code> list.</td>
</tr>
<tr>
<td align="left">RSET</td>
<td align="left">重置 <code>mailfrom</code>, <code>rcpttos</code>, 和 <code>received_data</code> ，但不重置问候语。</td>
</tr>
<tr>
<td align="left">DATA</td>
<td align="left">Sets the internal state to <code>DATA</code> and stores remaining lines from the client in <code>received_data</code> until the terminator <code>“\r\n.\r\n”</code> is received.</td>
</tr>
<tr>
<td align="left">HELP</td>
<td align="left">返回有关命令语法的最少信息</td>
</tr>
<tr>
<td align="left">VRFY</td>
<td align="left">返回代码252（服务器不知道该地址是否有效）</td>
</tr>
<tr>
<td align="left">EXPN</td>
<td align="left">报告该命令未实现。</td>
</tr>
</tbody></table>
<h2 id="telnetlib-—-Telnet-客户端"><a href="#telnetlib-—-Telnet-客户端" class="headerlink" title="telnetlib — Telnet 客户端"></a><code>telnetlib</code> — Telnet 客户端</h2><p><strong>源代码：</strong> <a href="https://github.com/python/cpython/tree/3.10/Lib/telnetlib.py" target="_blank" rel="noopener">Lib/telnetlib.py</a></p>
<hr>
<p><code>telnetlib</code> 模块提供一个实现Telnet协议的类 <code>Telnet</code>。关于此协议的细节请参见 <a href="https://tools.ietf.org/html/rfc854.html" target="_blank" rel="noopener"><strong>RFC 854</strong></a> 。此外，它还为协议字符（见下文）和 telnet 选项提供了对应的符号常量。telnet选项对应的符号名遵循 <code>arpa/telnet.h</code> 中的定义，但删除了前缀 <code>TELOPT_</code>。对于不在 <code>arpa/telnet.h</code> 的选项的符号常量名，请参考本模块源码。</p>
<p>telnet命令的符号常量名有： IAC, DONT, DO, WONT, WILL, SE (Subnegotiation End), NOP (No Operation), DM (Data Mark), BRK (Break), IP (Interrupt process), AO (Abort output), AYT (Are You There), EC (Erase Character), EL (Erase Line), GA (Go Ahead), SB (Subnegotiation Begin).</p>
<p><em>class</em> <code>telnetlib.Telnet</code>(<em>host=None</em>, <em>port=0</em>[, <em>timeout</em>])</p>
<p><code>Telnet</code> 表示到 Telnet 服务器的连接. 实例初始化后默认不连接；必须使用 <code>open()</code> 方法来建立连接。或者， 可选参数 host 和 port 也可以传递给构造函数，在这种情况下，到服务器的连接将在构造函数返回前建立。可选参数 <em>timeout</em> 为阻塞操作（如连接尝试）指定一个以秒为单位的超时时间（如果没有指定，将使用全局默认设置） 。</p>
<p>不要重新打开一个已经连接的实例。</p>
<p>这个类有很多 <code>read_*()</code> 方法。 请注意，其中一些方法在读取结束时会触发 <code>EOFError</code> 异常，这是由于连接对象可能出于其它原因返回一个空字符串。 请参阅下面的个别描述。</p>
<p><code>Telnet</code> 对象一个上下文管理器，可以在 <code>with</code> 语句中使用。当 <code>with</code> 块结束，<code>close()</code> 方法会被调用:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> telnetlib <span class="token keyword">import</span> Telnet
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">with</span> Telnet<span class="token punctuation">(</span><span class="token string">'localhost'</span><span class="token punctuation">,</span> <span class="token number">23</span><span class="token punctuation">)</span> <span class="token keyword">as</span> tn<span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     tn<span class="token punctuation">.</span>interact<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>在 3.6 版更改: 添加了上下文管理器的支持</p>
<p>参见</p>
<p><a href="https://tools.ietf.org/html/rfc854.html" target="_blank" rel="noopener"><strong>RFC 854</strong></a> - Telnet 协议规范</p>
<p>Telnet 协议的定义。</p>
<h3 id="Telnet-对象"><a href="#Telnet-对象" class="headerlink" title="Telnet 对象"></a>Telnet 对象</h3><p><code>Telnet</code> 实例有以下几种方法：</p>
<p><code>Telnet.read_until</code>(<em>expected</em>, <em>timeout=None</em>)</p>
<p>读取直到遇到给定字节串 <em>expected</em> 或 <em>timeout</em> 秒已经过去。</p>
<p>当没有找到匹配时，返回可用的内容，也可能返回空字节。如果连接已关闭且没有可用的熟数据，将触发 <code>EOFError</code>。</p>
<p><code>Telnet.read_all</code>()</p>
<p>读取数据，直到遇到 EOF；连接关闭前都会保持阻塞。</p>
<p><code>Telnet.read_some</code>()</p>
<p>在达到 EOF 前，读取至少一个字节的熟数据。如果命中 EOF，返回 <code>b''</code>。如果没有立即可用的数据，则阻塞。</p>
<p><code>Telnet.read_very_eager</code>()</p>
<p>在不阻塞 I/O 的情况下读取所有的内容（eager）。</p>
<p>如果连接已关闭并且没有可用的熟数据，将会触发 <code>EOFError</code> 。如果没有熟数据可用返回 <code>b''</code> 。除非在一个 IAC 序列的中间，否则不要进行阻塞。</p>
<p><code>Telnet.read_eager</code>()</p>
<p>读取现成的数据。</p>
<p>如果连接已关闭并且没有可用的熟数据，将会触发 <code>EOFError</code> 。如果没有熟数据可用返回 <code>b''</code> 。除非在一个 IAC 序列的中间，否则不要进行阻塞。</p>
<p><code>Telnet.read_lazy</code>()</p>
<p>处理并返回已经在队列中的数据（lazy）。</p>
<p>如果连接已关闭并且没有可用的数据，将会触发 <code>EOFError</code> 。如果没有熟数据可用则返回 <code>b''</code> 。除非在一个 IAC 序列的中间，否则不要进行阻塞。</p>
<p><code>Telnet.read_very_lazy</code>()</p>
<p>返回熟数据队列任何可用的数据（very lazy）。</p>
<p>如果连接已关闭并且没有可用的数据，将会触发 <code>EOFError</code> 。如果没有熟数据可用则返回 <code>b''</code> 。该方法永远不会阻塞。</p>
<p><code>Telnet.read_sb_data</code>()</p>
<p>返回在 SB/SE 对之间收集的数据（子选项 begin/end）。当使用 <code>SE</code> 命令调用回调函数时，该回调函数应该访问这些数据。该方法永远不会阻塞。</p>
<p><code>Telnet.open</code>(<em>host</em>, <em>port=0</em>[, <em>timeout</em>])</p>
<p>连接主机。第二个可选参数是端口号，默认为标准 Telnet 端口（23）。可选参数 <em>timeout</em> 指定一个以秒为单位的超时时间用于像连接尝试这样的阻塞操作（如果没有指定，将使用全局默认超时设置）。</p>
<p>不要尝试重新打开一个已经连接的实例。</p>
<p>触发 auditing event <code>telnetlib.Telnet.open</code> ，参数为 <code>self</code>，<code>host</code>，<code>port</code>。</p>
<p><code>Telnet.msg</code>(<em>msg</em>, <em>\</em>args*)</p>
<p>当调试级别 <code>&gt;</code> 0 时打印一条调试信息。如果存在额外参数，则它们会被替换在使用标准字符串格式化操作符的信息中。</p>
<p><code>Telnet.set_debuglevel</code>(<em>debuglevel</em>)</p>
<p>设置调试级别。<em>debuglevel</em> 的值越高，得到的调试输出越多（在 <code>sys.stdout</code> ）。</p>
<p><code>Telnet.close</code>()</p>
<p>关闭连接对象。</p>
<p><code>Telnet.get_socket</code>()</p>
<p>返回内部使用的套接字对象。</p>
<p><code>Telnet.fileno</code>()</p>
<p>返回内部使用的套接字对象的文件描述符。</p>
<p><code>Telnet.write</code>(<em>buffer</em>)</p>
<p>向套接字写入一个字节字符串，将所有 IAC 字符加倍。如果连接被阻塞，这可能也会阻塞。如果连接关闭可能触发 <code>OSError</code>。</p>
<p>触发 auditing event <code>telnetlib.Telnet.write</code> ，参数为 <code>self</code>，<code>buffer</code>。</p>
<p>在 3.3 版更改: 曾经该函数抛出 <code>socket.error</code>，现在这是 <code>OSError</code> 的别名。</p>
<p><code>Telnet.interact</code>()</p>
<p>交互函数，模拟一个非常笨拙的 Telnet 客户端。</p>
<p><code>Telnet.mt_interact</code>()</p>
<p>多线程版的 <code>interact()</code>.</p>
<p><code>Telnet.expect</code>(<em>list</em>, <em>timeout=None</em>)</p>
<p>一直读取，直到匹配列表中的某个正则表达式。</p>
<p>第一个参数是一个正则表达式列表，可以是已编译的 (正则表达式对象)，也可以是未编译的 (字节串)。 第二个可选参数是超时，单位是秒；默认一直阻塞。</p>
<p>返回一个包含三个元素的元组：列表中的第一个匹配的正则表达式的索引；返回的匹配对象；包括匹配在内的读取过的字节。</p>
<p>如果找到了文件的结尾且没有字节被读取，触发 <code>EOFError</code>。否则，当没有匹配时,返回 <code>(-1, None, data)</code>，其中 <em>data</em> 是到目前为止接受到的字节（如果发生超时，则可能是空字节）。</p>
<p>如果一个正则表达式以贪婪匹配结束（例如 <code>.*</code>），或者多个表达式可以匹配同一个输出，则结果是不确定的，可能取决于 I/O 计时。</p>
<p><code>Telnet.set_option_negotiation_callback</code>(<em>callback</em>)</p>
<p>每次在输入流上读取 telnet 选项时，这个带有如下参数的 <em>callback</em> （如果设置了）会被调用： callback(telnet socket, command (DO/DONT/WILL/WONT), option)。telnetlib 之后不会再执行其它操作。</p>
<h3 id="Telnet-示例"><a href="#Telnet-示例" class="headerlink" title="Telnet 示例"></a>Telnet 示例</h3><p>一个简单的说明性典型用法例子:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> getpass
<span class="token keyword">import</span> telnetlib
HOST <span class="token operator">=</span> <span class="token string">"localhost"</span>
user <span class="token operator">=</span> input<span class="token punctuation">(</span><span class="token string">"Enter your remote account: "</span><span class="token punctuation">)</span>
password <span class="token operator">=</span> getpass<span class="token punctuation">.</span>getpass<span class="token punctuation">(</span><span class="token punctuation">)</span>
tn <span class="token operator">=</span> telnetlib<span class="token punctuation">.</span>Telnet<span class="token punctuation">(</span>HOST<span class="token punctuation">)</span>
tn<span class="token punctuation">.</span>read_until<span class="token punctuation">(</span>b<span class="token string">"login: "</span><span class="token punctuation">)</span>
tn<span class="token punctuation">.</span>write<span class="token punctuation">(</span>user<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token string">'ascii'</span><span class="token punctuation">)</span> <span class="token operator">+</span> b<span class="token string">"\n"</span><span class="token punctuation">)</span>
<span class="token keyword">if</span> password<span class="token punctuation">:</span>
    tn<span class="token punctuation">.</span>read_until<span class="token punctuation">(</span>b<span class="token string">"Password: "</span><span class="token punctuation">)</span>
    tn<span class="token punctuation">.</span>write<span class="token punctuation">(</span>password<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token string">'ascii'</span><span class="token punctuation">)</span> <span class="token operator">+</span> b<span class="token string">"\n"</span><span class="token punctuation">)</span>
tn<span class="token punctuation">.</span>write<span class="token punctuation">(</span>b<span class="token string">"ls\n"</span><span class="token punctuation">)</span>
tn<span class="token punctuation">.</span>write<span class="token punctuation">(</span>b<span class="token string">"exit\n"</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>tn<span class="token punctuation">.</span>read_all<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token string">'ascii'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="uuid-—-UUID-objects-according-to-RFC-4122"><a href="#uuid-—-UUID-objects-according-to-RFC-4122" class="headerlink" title="uuid —- UUID objects according to RFC 4122"></a><code>uuid</code> —- UUID objects according to <strong>RFC 4122</strong></h2><p>Source code: <a href="https://github.com/python/cpython/tree/3.10/Lib/uuid.py" target="_blank" rel="noopener">Lib/uuid.py</a></p>
<hr>
<p>这个模块提供了不可变的 <code>UUID</code> 对象 (<code>UUID</code> 类) 和 <code>uuid1()</code>, <code>uuid3()</code>, <code>uuid4()</code>, <code>uuid5()</code> 等函数用于生成 <a href="https://tools.ietf.org/html/rfc4122.html" target="_blank" rel="noopener"><strong>RFC 4122</strong></a> 所定义的第 1, 3, 4 和 5 版 UUID。</p>
<p>If all you want is a unique ID, you should probably call <code>uuid1()</code> or <code>uuid4()</code>. Note that <code>uuid1()</code> may compromise privacy since it creates a UUID containing the computer’s network address. <code>uuid4()</code> creates a random UUID.</p>
<p>Depending on support from the underlying platform, <code>uuid1()</code> may or may not return a “safe” UUID. A safe UUID is one which is generated using synchronization methods that ensure no two processes can obtain the same UUID. All instances of <code>UUID</code> have an <code>is_safe</code> attribute which relays any information about the UUID’s safety, using this enumeration:</p>
<p><em>class</em> <code>uuid.SafeUUID</code></p>
<p>3.7 新版功能.</p>
<ul>
<li><p><code>safe</code></p>
<p>The UUID was generated by the platform in a multiprocessing-safe way.</p>
</li>
<li><p><code>unsafe</code></p>
<p>The UUID was not generated in a multiprocessing-safe way.</p>
</li>
<li><p><code>unknown</code></p>
<p>The platform does not provide information on whether the UUID was generated safely or not.</p>
</li>
</ul>
<p><em>class</em> <code>uuid.UUID</code>(<em>hex=None</em>, <em>bytes=None</em>, <em>bytes_le=None</em>, <em>fields=None</em>, <em>int=None</em>, <em>version=None</em>, <em>**,</em> is_safe=SafeUUID.unknown*)</p>
<p>Create a UUID from either a string of 32 hexadecimal digits, a string of 16 bytes in big-endian order as the <em>bytes</em> argument, a string of 16 bytes in little-endian order as the <em>bytes_le</em> argument, a tuple of six integers (32-bit <em>time_low</em>, 16-bit <em>time_mid</em>, 16-bit <em>time_hi_version</em>, 8-bit <em>clock_seq_hi_variant</em>, 8-bit <em>clock_seq_low</em>, 48-bit <em>node</em>) as the <em>fields</em> argument, or a single 128-bit integer as the <em>int</em> argument. When a string of hex digits is given, curly braces, hyphens, and a URN prefix are all optional. For example, these expressions all yield the same UUID:</p>
<pre><code>UUID('{12345678-1234-5678-1234-567812345678}')
UUID('12345678123456781234567812345678')
UUID('urn:uuid:12345678-1234-5678-1234-567812345678')
UUID(bytes=b'\x12\x34\x56\x78'*4)
UUID(bytes_le=b'\x78\x56\x34\x12\x34\x12\x78\x56' +
              b'\x12\x34\x56\x78\x12\x34\x56\x78')
UUID(fields=(0x12345678, 0x1234, 0x5678, 0x12, 0x34, 0x567812345678))
UUID(int=0x12345678123456781234567812345678)</code></pre><p>Exactly one of <em>hex</em>, <em>bytes</em>, <em>bytes_le</em>, <em>fields</em>, or <em>int</em> must be given. The <em>version</em> argument is optional; if given, the resulting UUID will have its variant and version number set according to <a href="https://tools.ietf.org/html/rfc4122.html" target="_blank" rel="noopener"><strong>RFC 4122</strong></a>, overriding bits in the given <em>hex</em>, <em>bytes</em>, <em>bytes_le</em>, <em>fields</em>, or <em>int</em>.</p>
<p>Comparison of UUID objects are made by way of comparing their <code>UUID.int</code> attributes. Comparison with a non-UUID object raises a <a href="https://www.bookstack.cn/read/python-3.10.0-zh/177bd954d1cc6696.md#TypeError" target="_blank" rel="noopener"><code>TypeError</code></a>.</p>
<p><code>str(uuid)</code> returns a string in the form <code>12345678-1234-5678-1234-567812345678</code> where the 32 hexadecimal digits represent the UUID.</p>
<p><code>UUID</code> instances have these read-only attributes:</p>
<pre><code>UUID.bytes</code></pre><p>The UUID as a 16-byte string (containing the six integer fields in big-endian byte order).</p>
<pre><code>UUID.bytes_le</code></pre><p>The UUID as a 16-byte string (with <em>time_low</em>, <em>time_mid</em>, and <em>time_hi_version</em> in little-endian byte order).</p>
<pre><code>UUID.fields</code></pre><p>以元组形式存放的UUID的6个整数域，有六个单独的属性和两个派生属性：</p>
<table>
<thead>
<tr>
<th align="left">域</th>
<th align="left">含意</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>time_low</code></td>
<td align="left">UUID的前32位</td>
</tr>
<tr>
<td align="left"><code>time_mid</code></td>
<td align="left">接前一域的16位</td>
</tr>
<tr>
<td align="left"><code>time_hi_version</code></td>
<td align="left">接前一域的16位</td>
</tr>
<tr>
<td align="left"><code>clock_seq_hi_variant</code></td>
<td align="left">接前一域的8位</td>
</tr>
<tr>
<td align="left"><code>clock_seq_low</code></td>
<td align="left">接前一域的8位</td>
</tr>
<tr>
<td align="left"><code>node</code></td>
<td align="left">UUID的最后48位</td>
</tr>
<tr>
<td align="left"><code>time</code></td>
<td align="left">UUID的总长60位的时间戳</td>
</tr>
<tr>
<td align="left"><code>clock_seq</code></td>
<td align="left">14位的序列号</td>
</tr>
</tbody></table>
<pre><code>UUID.hex</code></pre><p>The UUID as a 32-character hexadecimal string.</p>
<pre><code>UUID.int</code></pre><p>The UUID as a 128-bit integer.</p>
<pre><code>UUID.urn</code></pre><p>在 <a href="https://tools.ietf.org/html/rfc4122.html" target="_blank" rel="noopener"><strong>RFC 4122</strong></a> 中定义的 URN 形式的 UUID。</p>
<pre><code>UUID.variant</code></pre><p>The UUID variant, which determines the internal layout of the UUID. This will be one of the constants <code>RESERVED_NCS</code>, <code>RFC_4122</code>, <code>RESERVED_MICROSOFT</code>, or <code>RESERVED_FUTURE</code>.</p>
<pre><code>UUID.version</code></pre><p>The UUID version number (1 through 5, meaningful only when the variant is <code>RFC_4122</code>).</p>
<pre><code>UUID.is_safe</code></pre><p>An enumeration of <code>SafeUUID</code> which indicates whether the platform generated the UUID in a multiprocessing-safe way.</p>
<p>3.7 新版功能.</p>
<p>The <code>uuid</code> module defines the following functions:</p>
<p><code>uuid.getnode</code>()</p>
<p>Get the hardware address as a 48-bit positive integer. The first time this runs, it may launch a separate program, which could be quite slow. If all attempts to obtain the hardware address fail, we choose a random 48-bit number with the multicast bit (least significant bit of the first octet) set to 1 as recommended in <a href="https://tools.ietf.org/html/rfc4122.html" target="_blank" rel="noopener"><strong>RFC 4122</strong></a>. “Hardware address” means the MAC address of a network interface. On a machine with multiple network interfaces, universally administered MAC addresses (i.e. where the second least significant bit of the first octet is <em>unset</em>) will be preferred over locally administered MAC addresses, but with no other ordering guarantees.</p>
<p>在 3.7 版更改: Universally administered MAC addresses are preferred over locally administered MAC addresses, since the former are guaranteed to be globally unique, while the latter are not.</p>
<p><code>uuid.uuid1</code>(<em>node=None</em>, <em>clock_seq=None</em>)</p>
<p>Generate a UUID from a host ID, sequence number, and the current time. If <em>node</em> is not given, <code>getnode()</code> is used to obtain the hardware address. If <em>clock_seq</em> is given, it is used as the sequence number; otherwise a random 14-bit sequence number is chosen.</p>
<p><code>uuid.uuid3</code>(<em>namespace</em>, <em>name</em>)</p>
<p>Generate a UUID based on the MD5 hash of a namespace identifier (which is a UUID) and a name (which is a string).</p>
<p><code>uuid.uuid4</code>()</p>
<p>Generate a random UUID.</p>
<p><code>uuid.uuid5</code>(<em>namespace</em>, <em>name</em>)</p>
<p>Generate a UUID based on the SHA-1 hash of a namespace identifier (which is a UUID) and a name (which is a string).</p>
<p>The <code>uuid</code> module defines the following namespace identifiers for use with <code>uuid3()</code> or <code>uuid5()</code>.</p>
<pre><code>uuid.NAMESPACE_DNS</code></pre><p>When this namespace is specified, the <em>name</em> string is a fully-qualified domain name.</p>
<pre><code>uuid.NAMESPACE_URL</code></pre><p>When this namespace is specified, the <em>name</em> string is a URL.</p>
<pre><code>uuid.NAMESPACE_OID</code></pre><p>When this namespace is specified, the <em>name</em> string is an ISO OID.</p>
<pre><code>uuid.NAMESPACE_X500</code></pre><p>When this namespace is specified, the <em>name</em> string is an X.500 DN in DER or a text output format.</p>
<p>The <code>uuid</code> module defines the following constants for the possible values of the <code>variant</code> attribute:</p>
<pre><code>uuid.RESERVED_NCS</code></pre><p>Reserved for NCS compatibility.</p>
<pre><code>uuid.RFC_4122</code></pre><p>Specifies the UUID layout given in <a href="https://tools.ietf.org/html/rfc4122.html" target="_blank" rel="noopener"><strong>RFC 4122</strong></a>.</p>
<pre><code>uuid.RESERVED_MICROSOFT</code></pre><p>为微软的兼容性保留。</p>
<pre><code>uuid.RESERVED_FUTURE</code></pre><p>Reserved for future definition.</p>
<p>参见</p>
<p><a href="https://tools.ietf.org/html/rfc4122.html" target="_blank" rel="noopener"><strong>RFC 4122</strong></a> - A Universally Unique IDentifier (UUID) URN Namespace</p>
<p>This specification defines a Uniform Resource Name namespace for UUIDs, the internal format of UUIDs, and methods of generating UUIDs.</p>
<h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h3><p>Here are some examples of typical usage of the <code>uuid</code> module:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> uuid
<span class="token operator">>></span><span class="token operator">></span> <span class="token comment" spellcheck="true"># make a UUID based on the host ID and current time</span>
<span class="token operator">>></span><span class="token operator">></span> uuid<span class="token punctuation">.</span>uuid1<span class="token punctuation">(</span><span class="token punctuation">)</span>
UUID<span class="token punctuation">(</span><span class="token string">'a8098c1a-f86e-11da-bd1a-00112444be1e'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token comment" spellcheck="true"># make a UUID using an MD5 hash of a namespace UUID and a name</span>
<span class="token operator">>></span><span class="token operator">></span> uuid<span class="token punctuation">.</span>uuid3<span class="token punctuation">(</span>uuid<span class="token punctuation">.</span>NAMESPACE_DNS<span class="token punctuation">,</span> <span class="token string">'python.org'</span><span class="token punctuation">)</span>
UUID<span class="token punctuation">(</span><span class="token string">'6fa459ea-ee8a-3ca4-894e-db77e160355e'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token comment" spellcheck="true"># make a random UUID</span>
<span class="token operator">>></span><span class="token operator">></span> uuid<span class="token punctuation">.</span>uuid4<span class="token punctuation">(</span><span class="token punctuation">)</span>
UUID<span class="token punctuation">(</span><span class="token string">'16fd2706-8baf-433b-82eb-8c7fada847da'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token comment" spellcheck="true"># make a UUID using a SHA-1 hash of a namespace UUID and a name</span>
<span class="token operator">>></span><span class="token operator">></span> uuid<span class="token punctuation">.</span>uuid5<span class="token punctuation">(</span>uuid<span class="token punctuation">.</span>NAMESPACE_DNS<span class="token punctuation">,</span> <span class="token string">'python.org'</span><span class="token punctuation">)</span>
UUID<span class="token punctuation">(</span><span class="token string">'886313e1-3b8a-5372-9b90-0c9aee199e5d'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token comment" spellcheck="true"># make a UUID from a string of hex digits (braces and hyphens ignored)</span>
<span class="token operator">>></span><span class="token operator">></span> x <span class="token operator">=</span> uuid<span class="token punctuation">.</span>UUID<span class="token punctuation">(</span><span class="token string">'{00010203-0405-0607-0809-0a0b0c0d0e0f}'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token comment" spellcheck="true"># convert a UUID to a string of hex digits in standard form</span>
<span class="token operator">>></span><span class="token operator">></span> str<span class="token punctuation">(</span>x<span class="token punctuation">)</span>
<span class="token string">'00010203-0405-0607-0809-0a0b0c0d0e0f'</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token comment" spellcheck="true"># get the raw 16 bytes of the UUID</span>
<span class="token operator">>></span><span class="token operator">></span> x<span class="token punctuation">.</span>bytes
b<span class="token string">'\x00\x01\x02\x03\x04\x05\x06\x07\x08\t\n\x0b\x0c\r\x0e\x0f'</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token comment" spellcheck="true"># make a UUID from a 16-byte string</span>
<span class="token operator">>></span><span class="token operator">></span> uuid<span class="token punctuation">.</span>UUID<span class="token punctuation">(</span>bytes<span class="token operator">=</span>x<span class="token punctuation">.</span>bytes<span class="token punctuation">)</span>
UUID<span class="token punctuation">(</span><span class="token string">'00010203-0405-0607-0809-0a0b0c0d0e0f'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="socketserver-—-A-framework-for-network-servers"><a href="#socketserver-—-A-framework-for-network-servers" class="headerlink" title="socketserver —- A framework for network servers"></a><code>socketserver</code> —- A framework for network servers</h2><p>Source code: <a href="https://github.com/python/cpython/tree/3.10/Lib/socketserver.py" target="_blank" rel="noopener">Lib/socketserver.py</a></p>
<hr>
<p>The <code>socketserver</code> module simplifies the task of writing network servers.</p>
<p>There are four basic concrete server classes:</p>
<p><em>class</em> <code>socketserver.TCPServer</code>(<em>server_address</em>, <em>RequestHandlerClass</em>, <em>bind_and_activate=True</em>)</p>
<p>This uses the internet TCP protocol, which provides for continuous streams of data between the client and server. If <em>bind_and_activate</em> is true, the constructor automatically attempts to invoke <code>server_bind()</code> and <code>server_activate()</code>. The other parameters are passed to the <code>BaseServer</code> base class.</p>
<p><em>class</em> <code>socketserver.UDPServer</code>(<em>server_address</em>, <em>RequestHandlerClass</em>, <em>bind_and_activate=True</em>)</p>
<p>This uses datagrams, which are discrete packets of information that may arrive out of order or be lost while in transit. The parameters are the same as for <code>TCPServer</code>.</p>
<p><em>class</em> <code>socketserver.UnixStreamServer</code>(<em>server_address</em>, <em>RequestHandlerClass</em>, <em>bind_and_activate=True</em>)</p>
<p><em>class</em> <code>socketserver.UnixDatagramServer</code>(<em>server_address</em>, <em>RequestHandlerClass</em>, <em>bind_and_activate=True</em>)</p>
<p>These more infrequently used classes are similar to the TCP and UDP classes, but use Unix domain sockets; they’re not available on non-Unix platforms. The parameters are the same as for <code>TCPServer</code>.</p>
<p>These four classes process requests <em>synchronously</em>; each request must be completed before the next request can be started. This isn’t suitable if each request takes a long time to complete, because it requires a lot of computation, or because it returns a lot of data which the client is slow to process. The solution is to create a separate process or thread to handle each request; the <code>ForkingMixIn</code> and <code>ThreadingMixIn</code> mix-in classes can be used to support asynchronous behaviour.</p>
<p>Creating a server requires several steps. First, you must create a request handler class by subclassing the <code>BaseRequestHandler</code> class and overriding its <code>handle()</code> method; this method will process incoming requests. Second, you must instantiate one of the server classes, passing it the server’s address and the request handler class. It is recommended to use the server in a <code>with</code> statement. Then call the <code>handle_request()</code> or <code>serve_forever()</code> method of the server object to process one or many requests. Finally, call <code>server_close()</code> to close the socket (unless you used a <code>with</code> statement).</p>
<p>When inheriting from <code>ThreadingMixIn</code> for threaded connection behavior, you should explicitly declare how you want your threads to behave on an abrupt shutdown. The <code>ThreadingMixIn</code> class defines an attribute <em>daemon_threads</em>, which indicates whether or not the server should wait for thread termination. You should set the flag explicitly if you would like threads to behave autonomously; the default is <code>False</code>, meaning that Python will not exit until all threads created by <code>ThreadingMixIn</code> have exited.</p>
<p>Server classes have the same external methods and attributes, no matter what network protocol they use.</p>
<h3 id="Server-Creation-Notes"><a href="#Server-Creation-Notes" class="headerlink" title="Server Creation Notes"></a>Server Creation Notes</h3><p>There are five classes in an inheritance diagram, four of which represent synchronous servers of four types:</p>
<pre><code>+------------+
| BaseServer |
+------------+
      |
      v
+-----------+        +------------------+
| TCPServer |-------&gt;| UnixStreamServer |
+-----------+        +------------------+
      |
      v
+-----------+        +--------------------+
| UDPServer |-------&gt;| UnixDatagramServer |
+-----------+        +--------------------+</code></pre><p>Note that <code>UnixDatagramServer</code> derives from <code>UDPServer</code>, not from <code>UnixStreamServer</code> —- the only difference between an IP and a Unix stream server is the address family, which is simply repeated in both Unix server classes.</p>
<p><em>class</em> <code>socketserver.ForkingMixIn</code></p>
<p><em>class</em> <code>socketserver.ThreadingMixIn</code></p>
<p>Forking and threading versions of each type of server can be created using these mix-in classes. For instance, <code>ThreadingUDPServer</code> is created as follows:</p>
<pre><code>class ThreadingUDPServer(ThreadingMixIn, UDPServer):
    pass</code></pre><p>The mix-in class comes first, since it overrides a method defined in <code>UDPServer</code>. Setting the various attributes also changes the behavior of the underlying server mechanism.</p>
<p><code>ForkingMixIn</code> and the Forking classes mentioned below are only available on POSIX platforms that support <code>fork()</code>.</p>
<p><code>socketserver.ForkingMixIn.server_close()</code> waits until all child processes complete, except if <code>socketserver.ForkingMixIn.block_on_close</code> attribute is false.</p>
<p><code>socketserver.ThreadingMixIn.server_close()</code> waits until all non-daemon threads complete, except if <code>socketserver.ThreadingMixIn.block_on_close</code> attribute is false. Use daemonic threads by setting <code>ThreadingMixIn.daemon_threads</code> to <code>True</code> to not wait until threads complete.</p>
<p>在 3.7 版更改: <code>socketserver.ForkingMixIn.server_close()</code> and <code>socketserver.ThreadingMixIn.server_close()</code> now waits until all child processes and non-daemonic threads complete. Add a new <code>socketserver.ForkingMixIn.block_on_close</code> class attribute to opt-in for the pre-3.7 behaviour.</p>
<p><em>class</em> <code>socketserver.ForkingTCPServer</code></p>
<p><em>class</em> <code>socketserver.ForkingUDPServer</code></p>
<p><em>class</em> <code>socketserver.ThreadingTCPServer</code></p>
<p><em>class</em> <code>socketserver.ThreadingUDPServer</code></p>
<p>These classes are pre-defined using the mix-in classes.</p>
<p>To implement a service, you must derive a class from <code>BaseRequestHandler</code> and redefine its <code>handle()</code> method. You can then run various versions of the service by combining one of the server classes with your request handler class. The request handler class must be different for datagram or stream services. This can be hidden by using the handler subclasses <code>StreamRequestHandler</code> or <code>DatagramRequestHandler</code>.</p>
<p>Of course, you still have to use your head! For instance, it makes no sense to use a forking server if the service contains state in memory that can be modified by different requests, since the modifications in the child process would never reach the initial state kept in the parent process and passed to each child. In this case, you can use a threading server, but you will probably have to use locks to protect the integrity of the shared data.</p>
<p>On the other hand, if you are building an HTTP server where all data is stored externally (for instance, in the file system), a synchronous class will essentially render the service “deaf” while one request is being handled — which may be for a very long time if a client is slow to receive all the data it has requested. Here a threading or forking server is appropriate.</p>
<p>In some cases, it may be appropriate to process part of a request synchronously, but to finish processing in a forked child depending on the request data. This can be implemented by using a synchronous server and doing an explicit fork in the request handler class <code>handle()</code> method.</p>
<p>Another approach to handling multiple simultaneous requests in an environment that supports neither threads nor <code>fork()</code> (or where these are too expensive or inappropriate for the service) is to maintain an explicit table of partially finished requests and to use <code>selectors</code> to decide which request to work on next (or whether to handle a new incoming request). This is particularly important for stream services where each client can potentially be connected for a long time (if threads or subprocesses cannot be used). See <code>asyncore</code> for another way to manage this.</p>
<h3 id="Server-对象"><a href="#Server-对象" class="headerlink" title="Server 对象"></a>Server 对象</h3><p><em>class</em> <code>socketserver.BaseServer</code>(<em>server_address</em>, <em>RequestHandlerClass</em>)</p>
<p>This is the superclass of all Server objects in the module. It defines the interface, given below, but does not implement most of the methods, which is done in subclasses. The two parameters are stored in the respective <code>server_address</code> and <code>RequestHandlerClass</code> attributes.</p>
<ul>
<li><p><code>fileno</code>()</p>
<p>Return an integer file descriptor for the socket on which the server is listening. This function is most commonly passed to <code>selectors</code>, to allow monitoring multiple servers in the same process.</p>
</li>
<li><p><code>handle_request</code>()</p>
<p>Process a single request. This function calls the following methods in order: <code>get_request()</code>, <code>verify_request()</code>, and <code>process_request()</code>. If the user-provided <code>handle()</code> method of the handler class raises an exception, the server’s <code>handle_error()</code> method will be called. If no request is received within <code>timeout</code> seconds, <code>handle_timeout()</code> will be called and <code>handle_request()</code> will return.</p>
</li>
<li><p><code>serve_forever</code>(<em>poll_interval=0.5</em>)</p>
<p>Handle requests until an explicit <code>shutdown()</code> request. Poll for shutdown every <em>poll_interval</em> seconds. Ignores the <code>timeout</code> attribute. It also calls <code>service_actions()</code>, which may be used by a subclass or mixin to provide actions specific to a given service. For example, the <code>ForkingMixIn</code> class uses <code>service_actions()</code> to clean up zombie child processes.</p>
<p>在 3.3 版更改: Added <code>service_actions</code> call to the <code>serve_forever</code> method.</p>
</li>
<li><p><code>service_actions</code>()</p>
<p>This is called in the <code>serve_forever()</code> loop. This method can be overridden by subclasses or mixin classes to perform actions specific to a given service, such as cleanup actions.</p>
<p>3.3 新版功能.</p>
</li>
<li><p><code>shutdown</code>()</p>
<p>Tell the <code>serve_forever()</code> loop to stop and wait until it does. <code>shutdown()</code> must be called while <code>serve_forever()</code> is running in a different thread otherwise it will deadlock.</p>
</li>
<li><p><code>server_close</code>()</p>
<p>Clean up the server. May be overridden.</p>
</li>
<li><p><code>address_family</code></p>
<p>The family of protocols to which the server’s socket belongs. Common examples are <code>socket.AkF_INET</code> and <code>socket.AF_UNIX</code>.</p>
</li>
<li><p><code>RequestHandlerClass</code></p>
<p>The user-provided request handler class; an instance of this class is created for each request.</p>
</li>
<li><p><code>server_address</code></p>
<p>The address on which the server is listening. The format of addresses varies depending on the protocol family; see the documentation for the <code>socket</code> module for details. For internet protocols, this is a tuple containing a string giving the address, and an integer port number: <code>('127.0.0.1', 80)</code>, for example.</p>
</li>
<li><p><code>socket</code></p>
<p>The socket object on which the server will listen for incoming requests.</p>
</li>
</ul>
<p>The server classes support the following class variables:</p>
<ul>
<li><p><code>allow_reuse_address</code></p>
<p>Whether the server will allow the reuse of an address. This defaults to <code>False</code>, and can be set in subclasses to change the policy.</p>
</li>
<li><p><code>request_queue_size</code></p>
<p>The size of the request queue. If it takes a long time to process a single request, any requests that arrive while the server is busy are placed into a queue, up to <code>request_queue_size</code> requests. Once the queue is full, further requests from clients will get a “Connection denied” error. The default value is usually 5, but this can be overridden by subclasses.</p>
</li>
<li><p><code>socket_type</code></p>
<p>The type of socket used by the server; <code>socket.SOCK_STREAM</code> and <code>socket.SOCK_DGRAM</code> are two common values.</p>
</li>
<li><p><code>timeout</code></p>
<p>Timeout duration, measured in seconds, or <code>None</code> if no timeout is desired. If <code>handle_request()</code> receives no incoming requests within the timeout period, the <code>handle_timeout()</code> method is called.</p>
</li>
</ul>
<p>There are various server methods that can be overridden by subclasses of base server classes like <code>TCPServer</code>; these methods aren’t useful to external users of the server object.</p>
<ul>
<li><p><code>finish_request</code>(<em>request</em>, <em>client_address</em>)</p>
<p>Actually processes the request by instantiating <code>RequestHandlerClass</code> and calling its <code>handle()</code> method.</p>
</li>
<li><p><code>get_request</code>()</p>
<p>Must accept a request from the socket, and return a 2-tuple containing the <em>new</em> socket object to be used to communicate with the client, and the client’s address.</p>
</li>
<li><p><code>handle_error</code>(<em>request</em>, <em>client_address</em>)</p>
<p>This function is called if the <code>handle()</code> method of a <code>RequestHandlerClass</code> instance raises an exception. The default action is to print the traceback to standard error and continue handling further requests.</p>
<p>在 3.6 版更改: Now only called for exceptions derived from the <code>Exception</code> class.</p>
</li>
<li><p><code>handle_timeout</code>()</p>
<p>This function is called when the <code>timeout</code> attribute has been set to a value other than <code>None</code> and the timeout period has passed with no requests being received. The default action for forking servers is to collect the status of any child processes that have exited, while in threading servers this method does nothing.</p>
</li>
<li><p><code>process_request</code>(<em>request</em>, <em>client_address</em>)</p>
<p>Calls <code>finish_request()</code> to create an instance of the <code>RequestHandlerClass</code>. If desired, this function can create a new process or thread to handle the request; the <code>ForkingMixIn</code> and <code>ThreadingMixIn</code> classes do this.</p>
</li>
<li><p><code>server_activate</code>()</p>
<p>Called by the server’s constructor to activate the server. The default behavior for a TCP server just invokes <code>listen()</code> on the server’s socket. May be overridden.</p>
</li>
<li><p><code>server_bind</code>()</p>
<p>Called by the server’s constructor to bind the socket to the desired address. May be overridden.</p>
</li>
<li><p><code>verify_request</code>(<em>request</em>, <em>client_address</em>)</p>
<p>Must return a Boolean value; if the value is <code>True</code>, the request will be processed, and if it’s <code>False</code>, the request will be denied. This function can be overridden to implement access controls for a server. The default implementation always returns <code>True</code>.</p>
</li>
</ul>
<p>在 3.6 版更改: Support for the context manager protocol was added. Exiting the context manager is equivalent to calling <code>server_close()</code>.</p>
<h3 id="Request-Handler-Objects"><a href="#Request-Handler-Objects" class="headerlink" title="Request Handler Objects"></a>Request Handler Objects</h3><p><em>class</em> <code>socketserver.BaseRequestHandler</code></p>
<p>This is the superclass of all request handler objects. It defines the interface, given below. A concrete request handler subclass must define a new <code>handle()</code> method, and can override any of the other methods. A new instance of the subclass is created for each request.</p>
<ul>
<li><p><code>setup</code>()</p>
<p>Called before the <code>handle()</code> method to perform any initialization actions required. The default implementation does nothing.</p>
</li>
<li><p><code>handle</code>()</p>
<p>This function must do all the work required to service a request. The default implementation does nothing. Several instance attributes are available to it; the request is available as <code>self.request</code>; the client address as <code>self.client_address</code>; and the server instance as <code>self.server</code>, in case it needs access to per-server information.</p>
<p>The type of <code>self.request</code> is different for datagram or stream services. For stream services, <code>self.request</code> is a socket object; for datagram services, <code>self.request</code> is a pair of string and socket.</p>
</li>
<li><p><code>finish</code>()</p>
<p>Called after the <code>handle()</code> method to perform any clean-up actions required. The default implementation does nothing. If <code>setup()</code> raises an exception, this function will not be called.</p>
</li>
</ul>
<p><em>class</em> <code>socketserver.StreamRequestHandler</code></p>
<p><em>class</em> <code>socketserver.DatagramRequestHandler</code></p>
<p>These <code>BaseRequestHandler</code> subclasses override the <code>setup()</code> and <code>finish()</code> methods, and provide <code>self.rfile</code> and <code>self.wfile</code> attributes. The <code>self.rfile</code> and <code>self.wfile</code> attributes can be read or written, respectively, to get the request data or return data to the client.</p>
<p>The <code>rfile</code> attributes of both classes support the <code>io.BufferedIOBase</code> readable interface, and <code>DatagramRequestHandler.wfile</code> supports the <code>io.BufferedIOBase</code> writable interface.</p>
<p>在 3.6 版更改: <code>StreamRequestHandler.wfile</code> also supports the <code>io.BufferedIOBase</code> writable interface.</p>
<h3 id="例子-5"><a href="#例子-5" class="headerlink" title="例子"></a>例子</h3><h4 id="socketserver-TCPServer-Example"><a href="#socketserver-TCPServer-Example" class="headerlink" title="socketserver.TCPServer Example"></a><code>socketserver.TCPServer</code> Example</h4><p>This is the server side:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> socketserver
<span class="token keyword">class</span> <span class="token class-name">MyTCPHandler</span><span class="token punctuation">(</span>socketserver<span class="token punctuation">.</span>BaseRequestHandler<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">"""
    The request handler class for our server.
    It is instantiated once per connection to the server, and must
    override the handle() method to implement communication to the
    client.
    """</span>
    <span class="token keyword">def</span> <span class="token function">handle</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token comment" spellcheck="true"># self.request is the TCP socket connected to the client</span>
        self<span class="token punctuation">.</span>data <span class="token operator">=</span> self<span class="token punctuation">.</span>request<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">.</span>strip<span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"{} wrote:"</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>self<span class="token punctuation">.</span>client_address<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>data<span class="token punctuation">)</span>
        <span class="token comment" spellcheck="true"># just send back the same data, but upper-cased</span>
        self<span class="token punctuation">.</span>request<span class="token punctuation">.</span>sendall<span class="token punctuation">(</span>self<span class="token punctuation">.</span>data<span class="token punctuation">.</span>upper<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">"__main__"</span><span class="token punctuation">:</span>
    HOST<span class="token punctuation">,</span> PORT <span class="token operator">=</span> <span class="token string">"localhost"</span><span class="token punctuation">,</span> <span class="token number">9999</span>
    <span class="token comment" spellcheck="true"># Create the server, binding to localhost on port 9999</span>
    <span class="token keyword">with</span> socketserver<span class="token punctuation">.</span>TCPServer<span class="token punctuation">(</span><span class="token punctuation">(</span>HOST<span class="token punctuation">,</span> PORT<span class="token punctuation">)</span><span class="token punctuation">,</span> MyTCPHandler<span class="token punctuation">)</span> <span class="token keyword">as</span> server<span class="token punctuation">:</span>
        <span class="token comment" spellcheck="true"># Activate the server; this will keep running until you</span>
        <span class="token comment" spellcheck="true"># interrupt the program with Ctrl-C</span>
        server<span class="token punctuation">.</span>serve_forever<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>An alternative request handler class that makes use of streams (file-like objects that simplify communication by providing the standard file interface):</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">MyTCPHandler</span><span class="token punctuation">(</span>socketserver<span class="token punctuation">.</span>StreamRequestHandler<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">handle</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token comment" spellcheck="true"># self.rfile is a file-like object created by the handler;</span>
        <span class="token comment" spellcheck="true"># we can now use e.g. readline() instead of raw recv() calls</span>
        self<span class="token punctuation">.</span>data <span class="token operator">=</span> self<span class="token punctuation">.</span>rfile<span class="token punctuation">.</span>readline<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>strip<span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"{} wrote:"</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>self<span class="token punctuation">.</span>client_address<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>data<span class="token punctuation">)</span>
        <span class="token comment" spellcheck="true"># Likewise, self.wfile is a file-like object used to write back</span>
        <span class="token comment" spellcheck="true"># to the client</span>
        self<span class="token punctuation">.</span>wfile<span class="token punctuation">.</span>write<span class="token punctuation">(</span>self<span class="token punctuation">.</span>data<span class="token punctuation">.</span>upper<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>The difference is that the <code>readline()</code> call in the second handler will call <code>recv()</code> multiple times until it encounters a newline character, while the single <code>recv()</code> call in the first handler will just return what has been sent from the client in one <code>sendall()</code> call.</p>
<p>This is the client side:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> socket
<span class="token keyword">import</span> sys
HOST<span class="token punctuation">,</span> PORT <span class="token operator">=</span> <span class="token string">"localhost"</span><span class="token punctuation">,</span> <span class="token number">9999</span>
data <span class="token operator">=</span> <span class="token string">" "</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>sys<span class="token punctuation">.</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token comment" spellcheck="true"># Create a socket (SOCK_STREAM means a TCP socket)</span>
<span class="token keyword">with</span> socket<span class="token punctuation">.</span>socket<span class="token punctuation">(</span>socket<span class="token punctuation">.</span>AF_INET<span class="token punctuation">,</span> socket<span class="token punctuation">.</span>SOCK_STREAM<span class="token punctuation">)</span> <span class="token keyword">as</span> sock<span class="token punctuation">:</span>
    <span class="token comment" spellcheck="true"># Connect to server and send data</span>
    sock<span class="token punctuation">.</span>connect<span class="token punctuation">(</span><span class="token punctuation">(</span>HOST<span class="token punctuation">,</span> PORT<span class="token punctuation">)</span><span class="token punctuation">)</span>
    sock<span class="token punctuation">.</span>sendall<span class="token punctuation">(</span>bytes<span class="token punctuation">(</span>data <span class="token operator">+</span> <span class="token string">"\n"</span><span class="token punctuation">,</span> <span class="token string">"utf-8"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token comment" spellcheck="true"># Receive data from the server and shut down</span>
    received <span class="token operator">=</span> str<span class="token punctuation">(</span>sock<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"utf-8"</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Sent:     {}"</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Received: {}"</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>received<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>The output of the example should look something like this:</p>
<p>Server:</p>
<pre><code>$ python TCPServer.py
127.0.0.1 wrote:
b'hello world with TCP'
127.0.0.1 wrote:
b'python is nice'</code></pre><p>Client:</p>
<pre><code>$ python TCPClient.py hello world with TCP
Sent:     hello world with TCP
Received: HELLO WORLD WITH TCP
$ python TCPClient.py python is nice
Sent:     python is nice
Received: PYTHON IS NICE</code></pre><h4 id="socketserver-UDPServer-Example"><a href="#socketserver-UDPServer-Example" class="headerlink" title="socketserver.UDPServer Example"></a><code>socketserver.UDPServer</code> Example</h4><p>This is the server side:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> socketserver
<span class="token keyword">class</span> <span class="token class-name">MyUDPHandler</span><span class="token punctuation">(</span>socketserver<span class="token punctuation">.</span>BaseRequestHandler<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">"""
    This class works similar to the TCP handler class, except that
    self.request consists of a pair of data and client socket, and since
    there is no connection the client address must be given explicitly
    when sending data back via sendto().
    """</span>
    <span class="token keyword">def</span> <span class="token function">handle</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        data <span class="token operator">=</span> self<span class="token punctuation">.</span>request<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>strip<span class="token punctuation">(</span><span class="token punctuation">)</span>
        socket <span class="token operator">=</span> self<span class="token punctuation">.</span>request<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"{} wrote:"</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>self<span class="token punctuation">.</span>client_address<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>
        socket<span class="token punctuation">.</span>sendto<span class="token punctuation">(</span>data<span class="token punctuation">.</span>upper<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> self<span class="token punctuation">.</span>client_address<span class="token punctuation">)</span>
<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">"__main__"</span><span class="token punctuation">:</span>
    HOST<span class="token punctuation">,</span> PORT <span class="token operator">=</span> <span class="token string">"localhost"</span><span class="token punctuation">,</span> <span class="token number">9999</span>
    <span class="token keyword">with</span> socketserver<span class="token punctuation">.</span>UDPServer<span class="token punctuation">(</span><span class="token punctuation">(</span>HOST<span class="token punctuation">,</span> PORT<span class="token punctuation">)</span><span class="token punctuation">,</span> MyUDPHandler<span class="token punctuation">)</span> <span class="token keyword">as</span> server<span class="token punctuation">:</span>
        server<span class="token punctuation">.</span>serve_forever<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>This is the client side:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> socket
<span class="token keyword">import</span> sys
HOST<span class="token punctuation">,</span> PORT <span class="token operator">=</span> <span class="token string">"localhost"</span><span class="token punctuation">,</span> <span class="token number">9999</span>
data <span class="token operator">=</span> <span class="token string">" "</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>sys<span class="token punctuation">.</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token comment" spellcheck="true"># SOCK_DGRAM is the socket type to use for UDP sockets</span>
sock <span class="token operator">=</span> socket<span class="token punctuation">.</span>socket<span class="token punctuation">(</span>socket<span class="token punctuation">.</span>AF_INET<span class="token punctuation">,</span> socket<span class="token punctuation">.</span>SOCK_DGRAM<span class="token punctuation">)</span>
<span class="token comment" spellcheck="true"># As you can see, there is no connect() call; UDP has no connections.</span>
<span class="token comment" spellcheck="true"># Instead, data is directly sent to the recipient via sendto().</span>
sock<span class="token punctuation">.</span>sendto<span class="token punctuation">(</span>bytes<span class="token punctuation">(</span>data <span class="token operator">+</span> <span class="token string">"\n"</span><span class="token punctuation">,</span> <span class="token string">"utf-8"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>HOST<span class="token punctuation">,</span> PORT<span class="token punctuation">)</span><span class="token punctuation">)</span>
received <span class="token operator">=</span> str<span class="token punctuation">(</span>sock<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"utf-8"</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Sent:     {}"</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Received: {}"</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>received<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>The output of the example should look exactly like for the TCP server example.</p>
<h4 id="Asynchronous-Mixins"><a href="#Asynchronous-Mixins" class="headerlink" title="Asynchronous Mixins"></a>Asynchronous Mixins</h4><p>To build asynchronous handlers, use the <code>ThreadingMixIn</code> and <code>ForkingMixIn</code> classes.</p>
<p>An example for the <code>ThreadingMixIn</code> class:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> socket
<span class="token keyword">import</span> threading
<span class="token keyword">import</span> socketserver
<span class="token keyword">class</span> <span class="token class-name">ThreadedTCPRequestHandler</span><span class="token punctuation">(</span>socketserver<span class="token punctuation">.</span>BaseRequestHandler<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">handle</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        data <span class="token operator">=</span> str<span class="token punctuation">(</span>self<span class="token punctuation">.</span>request<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">'ascii'</span><span class="token punctuation">)</span>
        cur_thread <span class="token operator">=</span> threading<span class="token punctuation">.</span>current_thread<span class="token punctuation">(</span><span class="token punctuation">)</span>
        response <span class="token operator">=</span> bytes<span class="token punctuation">(</span><span class="token string">"{}: {}"</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>cur_thread<span class="token punctuation">.</span>name<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">'ascii'</span><span class="token punctuation">)</span>
        self<span class="token punctuation">.</span>request<span class="token punctuation">.</span>sendall<span class="token punctuation">(</span>response<span class="token punctuation">)</span>
<span class="token keyword">class</span> <span class="token class-name">ThreadedTCPServer</span><span class="token punctuation">(</span>socketserver<span class="token punctuation">.</span>ThreadingMixIn<span class="token punctuation">,</span> socketserver<span class="token punctuation">.</span>TCPServer<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">pass</span>
<span class="token keyword">def</span> <span class="token function">client</span><span class="token punctuation">(</span>ip<span class="token punctuation">,</span> port<span class="token punctuation">,</span> message<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">with</span> socket<span class="token punctuation">.</span>socket<span class="token punctuation">(</span>socket<span class="token punctuation">.</span>AF_INET<span class="token punctuation">,</span> socket<span class="token punctuation">.</span>SOCK_STREAM<span class="token punctuation">)</span> <span class="token keyword">as</span> sock<span class="token punctuation">:</span>
        sock<span class="token punctuation">.</span>connect<span class="token punctuation">(</span><span class="token punctuation">(</span>ip<span class="token punctuation">,</span> port<span class="token punctuation">)</span><span class="token punctuation">)</span>
        sock<span class="token punctuation">.</span>sendall<span class="token punctuation">(</span>bytes<span class="token punctuation">(</span>message<span class="token punctuation">,</span> <span class="token string">'ascii'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        response <span class="token operator">=</span> str<span class="token punctuation">(</span>sock<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">'ascii'</span><span class="token punctuation">)</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Received: {}"</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>response<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">"__main__"</span><span class="token punctuation">:</span>
    <span class="token comment" spellcheck="true"># Port 0 means to select an arbitrary unused port</span>
    HOST<span class="token punctuation">,</span> PORT <span class="token operator">=</span> <span class="token string">"localhost"</span><span class="token punctuation">,</span> <span class="token number">0</span>
    server <span class="token operator">=</span> ThreadedTCPServer<span class="token punctuation">(</span><span class="token punctuation">(</span>HOST<span class="token punctuation">,</span> PORT<span class="token punctuation">)</span><span class="token punctuation">,</span> ThreadedTCPRequestHandler<span class="token punctuation">)</span>
    <span class="token keyword">with</span> server<span class="token punctuation">:</span>
        ip<span class="token punctuation">,</span> port <span class="token operator">=</span> server<span class="token punctuation">.</span>server_address
        <span class="token comment" spellcheck="true"># Start a thread with the server -- that thread will then start one</span>
        <span class="token comment" spellcheck="true"># more thread for each request</span>
        server_thread <span class="token operator">=</span> threading<span class="token punctuation">.</span>Thread<span class="token punctuation">(</span>target<span class="token operator">=</span>server<span class="token punctuation">.</span>serve_forever<span class="token punctuation">)</span>
        <span class="token comment" spellcheck="true"># Exit the server thread when the main thread terminates</span>
        server_thread<span class="token punctuation">.</span>daemon <span class="token operator">=</span> <span class="token boolean">True</span>
        server_thread<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Server loop running in thread:"</span><span class="token punctuation">,</span> server_thread<span class="token punctuation">.</span>name<span class="token punctuation">)</span>
        client<span class="token punctuation">(</span>ip<span class="token punctuation">,</span> port<span class="token punctuation">,</span> <span class="token string">"Hello World 1"</span><span class="token punctuation">)</span>
        client<span class="token punctuation">(</span>ip<span class="token punctuation">,</span> port<span class="token punctuation">,</span> <span class="token string">"Hello World 2"</span><span class="token punctuation">)</span>
        client<span class="token punctuation">(</span>ip<span class="token punctuation">,</span> port<span class="token punctuation">,</span> <span class="token string">"Hello World 3"</span><span class="token punctuation">)</span>
        server<span class="token punctuation">.</span>shutdown<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>The output of the example should look something like this:</p>
<pre><code>$ python ThreadedTCPServer.py
Server loop running in thread: Thread-1
Received: Thread-2: Hello World 1
Received: Thread-3: Hello World 2
Received: Thread-4: Hello World 3</code></pre><p>The <code>ForkingMixIn</code> class is used in the same way, except that the server will spawn a new process for each request. Available only on POSIX platforms that support <code>fork()</code>.</p>
<h2 id="xmlrpc-—-XMLRPC-服务端与客户端模块"><a href="#xmlrpc-—-XMLRPC-服务端与客户端模块" class="headerlink" title="xmlrpc —- XMLRPC 服务端与客户端模块"></a><code>xmlrpc</code> —- XMLRPC 服务端与客户端模块</h2><p>XML-RPC 是一种远程过程调用方法，它使用通过 HTTP 传递的 XML 作为载体。 有了它，客户端可以在远程服务器上调用带参数的方法（服务器以 URI 命名）并获取结构化的数据。</p>
<p><code>xmlrpc</code> 是一个集合了 XML-RPC 服务端与客户端实现模块的包。 这些模块是:</p>
<ul>
<li><a href="https://docs.python.org/zh-cn/3.10/library/xmlrpc.client.html#module-xmlrpc.client" target="_blank" rel="noopener"><code>xmlrpc.client</code></a></li>
<li><a href="https://docs.python.org/zh-cn/3.10/library/xmlrpc.server.html#module-xmlrpc.server" target="_blank" rel="noopener"><code>xmlrpc.server</code></a></li>
</ul>
<h2 id="ipaddress-—-IPv4-IPv6-操作库"><a href="#ipaddress-—-IPv4-IPv6-操作库" class="headerlink" title="ipaddress —- IPv4/IPv6 操作库"></a><code>ipaddress</code> —- IPv4/IPv6 操作库</h2><p><strong>源代码：</strong> <a href="https://github.com/python/cpython/tree/3.10/Lib/ipaddress.py" target="_blank" rel="noopener">Lib/ipaddress.py</a></p>
<hr>
<p><code>ipaddress</code> 提供了创建、处理和操作 IPv4 和 IPv6 地址和网络的功能。</p>
<p>该模块中的函数和类可以直接处理与IP地址相关的各种任务，包括检查两个主机是否在同一个子网中，遍历某个子网中的所有主机，检查一个字符串是否是一个有效的IP地址或网络定义等等。</p>
<p>3.3 新版功能.</p>
<h3 id="方便的工厂函数"><a href="#方便的工厂函数" class="headerlink" title="方便的工厂函数"></a>方便的工厂函数</h3><p><code>ipaddress</code> 模块提供来工厂函数来方便地创建 IP 地址，网络和接口：</p>
<p><code>ipaddress.ip_address</code>(<em>address</em>)</p>
<p>Return an <code>IPv4Address</code> or <code>IPv6Address</code> object depending on the IP address passed as argument. Either IPv4 or IPv6 addresses may be supplied; integers less than <code>2**32</code> will be considered to be IPv4 by default. A <code>ValueError</code> is raised if <em>address</em> does not represent a valid IPv4 or IPv6 address.</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> ipaddress<span class="token punctuation">.</span>ip_address<span class="token punctuation">(</span><span class="token string">'192.168.0.1'</span><span class="token punctuation">)</span>
IPv4Address<span class="token punctuation">(</span><span class="token string">'192.168.0.1'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> ipaddress<span class="token punctuation">.</span>ip_address<span class="token punctuation">(</span><span class="token string">'2001:db8::'</span><span class="token punctuation">)</span>
IPv6Address<span class="token punctuation">(</span><span class="token string">'2001:db8::'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>ipaddress.ip_network</code>(<em>address</em>, <em>strict=True</em>)</p>
<p>Return an <code>IPv4Network</code> or <code>IPv6Network</code> object depending on the IP address passed as argument. <em>address</em> is a string or integer representing the IP network. Either IPv4 or IPv6 networks may be supplied; integers less than <code>2**32</code> will be considered to be IPv4 by default. <em>strict</em> is passed to <code>IPv4Network</code> or <code>IPv6Network</code> constructor. A <code>ValueError</code> is raised if <em>address</em> does not represent a valid IPv4 or IPv6 address, or if the network has host bits set.</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> ipaddress<span class="token punctuation">.</span>ip_network<span class="token punctuation">(</span><span class="token string">'192.168.0.0/28'</span><span class="token punctuation">)</span>
IPv4Network<span class="token punctuation">(</span><span class="token string">'192.168.0.0/28'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><code>ipaddress.ip_interface</code>(<em>address</em>)</p>
<p>Return an <code>IPv4Interface</code> or <code>IPv6Interface</code> object depending on the IP address passed as argument. <em>address</em> is a string or integer representing the IP address. Either IPv4 or IPv6 addresses may be supplied; integers less than <code>2**32</code> will be considered to be IPv4 by default. A <code>ValueError</code> is raised if <em>address</em> does not represent a valid IPv4 or IPv6 address.</p>
<p>这些方便的函数的一个缺点是需要同时处理IPv4和IPv6格式，这意味着提供的错误信息并不精准，因为函数不知道是打算采用IPv4还是IPv6格式。更详细的错误报告可以通过直接调用相应版本的类构造函数来获得。</p>
<h3 id="IP-地址"><a href="#IP-地址" class="headerlink" title="IP 地址"></a>IP 地址</h3><h4 id="地址对象"><a href="#地址对象" class="headerlink" title="地址对象"></a>地址对象</h4><p><code>IPv4Address</code> 和 <code>IPv6Address</code> 对象有很多共同的属性。一些只对IPv6 地址有意义的属性也在 <code>IPv4Address</code> 对象实现，以便更容易编写正确处理两种 IP 版本的代码。地址对象是可哈希的 hashable，所以它们可以作为字典中的键来使用。</p>
<p><em>class</em> <code>ipaddress.IPv4Address</code>(<em>address</em>)</p>
<p>构造一个 IPv4 地址。 如果 <em>address</em> 不是一个有效的 IPv4 地址，会抛出 <code>AddressValueError</code> 。</p>
<p>以下是有效的 IPv4 地址：</p>
<ol>
<li>以十进制小数点表示的字符串，由四个十进制整数组成，范围为0—255，用点隔开(例如 <code>192.168.0.1</code> )。每个整数代表地址中的八位（一个字节）。不允许使用前导零，以免与八进制表示产生歧义。</li>
<li>一个32位可容纳的整数。</li>
<li>一个长度为 4 的封装在 <code>bytes</code> 对象中的整数(高位优先)。</li>
</ol>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> ipaddress<span class="token punctuation">.</span>IPv4Address<span class="token punctuation">(</span><span class="token string">'192.168.0.1'</span><span class="token punctuation">)</span>
IPv4Address<span class="token punctuation">(</span><span class="token string">'192.168.0.1'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> ipaddress<span class="token punctuation">.</span>IPv4Address<span class="token punctuation">(</span><span class="token number">3232235521</span><span class="token punctuation">)</span>
IPv4Address<span class="token punctuation">(</span><span class="token string">'192.168.0.1'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> ipaddress<span class="token punctuation">.</span>IPv4Address<span class="token punctuation">(</span>b<span class="token string">'\xC0\xA8\x00\x01'</span><span class="token punctuation">)</span>
IPv4Address<span class="token punctuation">(</span><span class="token string">'192.168.0.1'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在 3.8 版更改: 前导零可被接受，即使是在可能与八进制表示混淆的情况下也会被接受。</p>
<p>在 3.10 版更改: 前导零不再被接受，并且会被视作错误。IPv4地址字符串现在严格按照glibc的 <code>inet_pton()</code> 函数进行解析。</p>
<p>在 3.9.5 版更改: 上述变更也在自3.9.5版本起的Python 3.9当中被包含。</p>
<p>在 3.8.12 版更改: The above change was also included in Python 3.8 starting with version 3.8.12.</p>
<ul>
<li><p><code>version</code></p>
<p>合适的版本号：IPv4为 <code>4</code> ，IPv6为 <code>6</code> 。</p>
</li>
<li><p><code>max_prefixlen</code></p>
<p>在该版本的地址表示中，比特数的总数：IPv4为 <code>32</code> ；IPv6为 <code>128</code> 。</p>
<p>The prefix defines the number of leading bits in an address that are compared to determine whether or not an address is part of a network.</p>
</li>
<li><p><code>compressed</code></p>
</li>
<li><p><code>exploded</code></p>
<p>The string representation in dotted decimal notation. Leading zeroes are never included in the representation.</p>
<p>As IPv4 does not define a shorthand notation for addresses with octets set to zero, these two attributes are always the same as <code>str(addr)</code> for IPv4 addresses. Exposing these attributes makes it easier to write display code that can handle both IPv4 and IPv6 addresses.</p>
</li>
<li><p><code>packed</code></p>
<p>The binary representation of this address - a <code>bytes</code> object of the appropriate length (most significant octet first). This is 4 bytes for IPv4 and 16 bytes for IPv6.</p>
</li>
<li><p><code>reverse_pointer</code></p>
<p>The name of the reverse DNS PTR record for the IP address, e.g.:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> ipaddress<span class="token punctuation">.</span>ip_address<span class="token punctuation">(</span><span class="token string">"127.0.0.1"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>reverse_pointer
<span class="token string">'1.0.0.127.in-addr.arpa'</span>
<span class="token operator">>></span><span class="token operator">></span> ipaddress<span class="token punctuation">.</span>ip_address<span class="token punctuation">(</span><span class="token string">"2001:db8::1"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>reverse_pointer
<span class="token string">'1.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.8.b.d.0.1.0.0.2.ip6.arpa'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>This is the name that could be used for performing a PTR lookup, not the resolved hostname itself.</p>
<p>3.5 新版功能.</p>
</li>
<li><p><code>is_multicast</code></p>
<p>如果该地址被保留用作多播用途，返回 <code>True</code> 。关于多播地址，请参见 <a href="https://tools.ietf.org/html/rfc3171.html" target="_blank" rel="noopener"><strong>RFC 3171</strong></a> （IPv4）和 <a href="https://tools.ietf.org/html/rfc2373.html" target="_blank" rel="noopener"><strong>RFC 2373</strong></a> （IPv6）。</p>
</li>
<li><p><code>is_private</code></p>
<p>如果该地址被分配至私有网络，返回 <code>True</code> 。关于公共网络，请参见 <a href="https://www.iana.org/assignments/iana-ipv4-special-registry/iana-ipv4-special-registry.xhtml" target="_blank" rel="noopener">iana-ipv4-special-registry</a> （针对IPv4）和 <a href="https://www.iana.org/assignments/iana-ipv6-special-registry/iana-ipv6-special-registry.xhtml" target="_blank" rel="noopener">iana-ipv6-special-registry</a> （针对IPv6）。</p>
</li>
<li><p><code>is_global</code></p>
<p>如果该地址被分配至公共网络，返回 <code>True</code> 。关于公共网络，请参见 <a href="https://www.iana.org/assignments/iana-ipv4-special-registry/iana-ipv4-special-registry.xhtml" target="_blank" rel="noopener">iana-ipv4-special-registry</a> （针对IPv4）和 <a href="https://www.iana.org/assignments/iana-ipv6-special-registry/iana-ipv6-special-registry.xhtml" target="_blank" rel="noopener">iana-ipv6-special-registry</a> （针对IPv6）。</p>
<p>3.4 新版功能.</p>
</li>
<li><p><code>is_unspecified</code></p>
<p><code>True</code> if the address is unspecified. See <a href="https://tools.ietf.org/html/rfc5735.html" target="_blank" rel="noopener"><strong>RFC 5735</strong></a> (for IPv4) or <a href="https://tools.ietf.org/html/rfc2373.html" target="_blank" rel="noopener"><strong>RFC 2373</strong></a> (for IPv6).</p>
</li>
<li><p><code>is_reserved</code></p>
<p>如果该地址属于互联网工程任务组（IETF）所规定的其他保留地址，返回 <code>True</code> 。</p>
</li>
<li><p><code>is_loopback</code></p>
<p>如果该地址为一个回环地址，返回 <code>True</code> 。关于回环地址，请见 <a href="https://tools.ietf.org/html/rfc3330.html" target="_blank" rel="noopener"><strong>RFC 3330</strong></a> （IPv4）和 <a href="https://tools.ietf.org/html/rfc2373.html" target="_blank" rel="noopener"><strong>RFC 2373</strong></a> （IPv6）。</p>
</li>
<li><p><code>is_link_local</code></p>
<p><code>True</code> if the address is reserved for link-local usage. See <a href="https://tools.ietf.org/html/rfc3927.html" target="_blank" rel="noopener"><strong>RFC 3927</strong></a>.</p>
</li>
</ul>
<p><code>IPv4Address.__format__</code>(<em>fmt</em>)</p>
<p>Returns a string representation of the IP address, controlled by an explicit format string. <em>fmt</em> can be one of the following: <code>'s'</code>, the default option, equivalent to <code>str()</code>, <code>'b'</code> for a zero-padded binary string, <code>'X'</code> or <code>'x'</code> for an uppercase or lowercase hexadecimal representation, or <code>'n'</code>, which is equivalent to <code>'b'</code> for IPv4 addresses and <code>'x'</code> for IPv6. For binary and hexadecimal representations, the form specifier <code>'#'</code> and the grouping option <code>'_'</code> are available. <code>__format__</code> is used by <code>format</code>, <code>str.format</code> and f-strings.</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> format<span class="token punctuation">(</span>ipaddress<span class="token punctuation">.</span>IPv4Address<span class="token punctuation">(</span><span class="token string">'192.168.0.1'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token string">'192.168.0.1'</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token string">'{:#b}'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>ipaddress<span class="token punctuation">.</span>IPv4Address<span class="token punctuation">(</span><span class="token string">'192.168.0.1'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token string">'0b11000000101010000000000000000001'</span>
<span class="token operator">>></span><span class="token operator">></span> f<span class="token string">'{ipaddress.IPv6Address("2001:db8::1000"):s}'</span>
<span class="token string">'2001:db8::1000'</span>
<span class="token operator">>></span><span class="token operator">></span> format<span class="token punctuation">(</span>ipaddress<span class="token punctuation">.</span>IPv6Address<span class="token punctuation">(</span><span class="token string">'2001:db8::1000'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">'_X'</span><span class="token punctuation">)</span>
<span class="token string">'2001_0DB8_0000_0000_0000_0000_0000_1000'</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token string">'{:#_n}'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>ipaddress<span class="token punctuation">.</span>IPv6Address<span class="token punctuation">(</span><span class="token string">'2001:db8::1000'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token string">'0x2001_0db8_0000_0000_0000_0000_0000_1000'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>3.9 新版功能.</p>
<p><em>class</em> <code>ipaddress.IPv6Address</code>(<em>address</em>)</p>
<p>构造一个 IPv6 地址。 如果 <em>address</em> 不是一个有效的 IPv6 地址，会抛出 <code>AddressValueError</code> 。</p>
<p>以下是有效的 IPv6 地址：</p>
<ol>
<li><p>A string consisting of eight groups of four hexadecimal digits, each group representing 16 bits. The groups are separated by colons. This describes an <em>exploded</em> (longhand) notation. The string can also be <em>compressed</em> (shorthand notation) by various means. See <a href="https://tools.ietf.org/html/rfc4291.html" target="_blank" rel="noopener"><strong>RFC 4291</strong></a> for details. For example, <code>"0000:0000:0000:0000:0000:0abc:0007:0def"</code> can be compressed to <code>"::abc:7:def"</code>.</p>
<p>Optionally, the string may also have a scope zone ID, expressed with a suffix <code>%scope_id</code>. If present, the scope ID must be non-empty, and may not contain <code>%</code>. See <a href="https://tools.ietf.org/html/rfc4007.html" target="_blank" rel="noopener"><strong>RFC 4007</strong></a> for details. For example, <code>fe80::1234%1</code> might identify address <code>fe80::1234</code> on the first link of the node.</p>
</li>
<li><p>An integer that fits into 128 bits.</p>
</li>
<li><p>An integer packed into a <code>bytes</code> object of length 16, big-endian.</p>
</li>
</ol>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> ipaddress<span class="token punctuation">.</span>IPv6Address<span class="token punctuation">(</span><span class="token string">'2001:db8::1000'</span><span class="token punctuation">)</span>
IPv6Address<span class="token punctuation">(</span><span class="token string">'2001:db8::1000'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> ipaddress<span class="token punctuation">.</span>IPv6Address<span class="token punctuation">(</span><span class="token string">'ff02::5678%1'</span><span class="token punctuation">)</span>
IPv6Address<span class="token punctuation">(</span><span class="token string">'ff02::5678%1'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li><code>compressed</code></li>
</ul>
<p>The short form of the address representation, with leading zeroes in groups omitted and the longest sequence of groups consisting entirely of zeroes collapsed to a single empty group.</p>
<p>This is also the value returned by <code>str(addr)</code> for IPv6 addresses.</p>
<ul>
<li><code>exploded</code></li>
</ul>
<p>The long form of the address representation, with all leading zeroes and groups consisting entirely of zeroes included.</p>
<p>For the following attributes and methods, see the corresponding documentation of the <code>IPv4Address</code> class:</p>
<ul>
<li><p><code>packed</code></p>
</li>
<li><p><code>reverse_pointer</code></p>
</li>
<li><p><code>version</code></p>
</li>
<li><p><code>max_prefixlen</code></p>
</li>
<li><p><code>is_multicast</code></p>
</li>
<li><p><code>is_private</code></p>
</li>
<li><p><code>is_global</code></p>
</li>
<li><p><code>is_unspecified</code></p>
</li>
<li><p><code>is_reserved</code></p>
</li>
<li><p><code>is_loopback</code></p>
</li>
<li><p><code>is_link_local</code></p>
<p>3.4 新版功能: is_global</p>
</li>
<li><p><code>is_site_local</code></p>
<p><code>True</code> if the address is reserved for site-local usage. Note that the site-local address space has been deprecated by <a href="https://tools.ietf.org/html/rfc3879.html" target="_blank" rel="noopener"><strong>RFC 3879</strong></a>. Use <code>is_private</code> to test if this address is in the space of unique local addresses as defined by <a href="https://tools.ietf.org/html/rfc4193.html" target="_blank" rel="noopener"><strong>RFC 4193</strong></a>.</p>
</li>
<li><p><code>ipv4_mapped</code></p>
<p>For addresses that appear to be IPv4 mapped addresses (starting with <code>::FFFF/96</code>), this property will report the embedded IPv4 address. For any other address, this property will be <code>None</code>.</p>
</li>
<li><p><code>scope_id</code></p>
<p>For scoped addresses as defined by <a href="https://tools.ietf.org/html/rfc4007.html" target="_blank" rel="noopener"><strong>RFC 4007</strong></a>, this property identifies the particular zone of the address’s scope that the address belongs to, as a string. When no scope zone is specified, this property will be <code>None</code>.</p>
</li>
<li><p><code>sixtofour</code></p>
<p>For addresses that appear to be 6to4 addresses (starting with <code>2002::/16</code>) as defined by <a href="https://tools.ietf.org/html/rfc3056.html" target="_blank" rel="noopener"><strong>RFC 3056</strong></a>, this property will report the embedded IPv4 address. For any other address, this property will be <code>None</code>.</p>
</li>
<li><p><code>teredo</code></p>
<p>For addresses that appear to be Teredo addresses (starting with <code>2001::/32</code>) as defined by <a href="https://tools.ietf.org/html/rfc4380.html" target="_blank" rel="noopener"><strong>RFC 4380</strong></a>, this property will report the embedded <code>(server, client)</code> IP address pair. For any other address, this property will be <code>None</code>.</p>
</li>
</ul>
<p><code>IPv6Address.__format__</code>(<em>fmt</em>)</p>
<p>Refer to the corresponding method documentation in <code>IPv4Address</code>.</p>
<p>3.9 新版功能.</p>
<h4 id="Conversion-to-Strings-and-Integers"><a href="#Conversion-to-Strings-and-Integers" class="headerlink" title="Conversion to Strings and Integers"></a>Conversion to Strings and Integers</h4><p>To interoperate with networking interfaces such as the socket module, addresses must be converted to strings or integers. This is handled using the <code>str()</code> and <code>int()</code> builtin functions:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> str<span class="token punctuation">(</span>ipaddress<span class="token punctuation">.</span>IPv4Address<span class="token punctuation">(</span><span class="token string">'192.168.0.1'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token string">'192.168.0.1'</span>
<span class="token operator">>></span><span class="token operator">></span> int<span class="token punctuation">(</span>ipaddress<span class="token punctuation">.</span>IPv4Address<span class="token punctuation">(</span><span class="token string">'192.168.0.1'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token number">3232235521</span>
<span class="token operator">>></span><span class="token operator">></span> str<span class="token punctuation">(</span>ipaddress<span class="token punctuation">.</span>IPv6Address<span class="token punctuation">(</span><span class="token string">'::1'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token string">'::1'</span>
<span class="token operator">>></span><span class="token operator">></span> int<span class="token punctuation">(</span>ipaddress<span class="token punctuation">.</span>IPv6Address<span class="token punctuation">(</span><span class="token string">'::1'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>Note that IPv6 scoped addresses are converted to integers without scope zone ID.</p>
<h4 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h4><p>Address objects support some operators. Unless stated otherwise, operators can only be applied between compatible objects (i.e. IPv4 with IPv4, IPv6 with IPv6).</p>
<h5 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h5><p>Address objects can be compared with the usual set of comparison operators. Same IPv6 addresses with different scope zone IDs are not equal. Some examples:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> IPv4Address<span class="token punctuation">(</span><span class="token string">'127.0.0.2'</span><span class="token punctuation">)</span> <span class="token operator">></span> IPv4Address<span class="token punctuation">(</span><span class="token string">'127.0.0.1'</span><span class="token punctuation">)</span>
<span class="token boolean">True</span>
<span class="token operator">>></span><span class="token operator">></span> IPv4Address<span class="token punctuation">(</span><span class="token string">'127.0.0.2'</span><span class="token punctuation">)</span> <span class="token operator">==</span> IPv4Address<span class="token punctuation">(</span><span class="token string">'127.0.0.1'</span><span class="token punctuation">)</span>
<span class="token boolean">False</span>
<span class="token operator">>></span><span class="token operator">></span> IPv4Address<span class="token punctuation">(</span><span class="token string">'127.0.0.2'</span><span class="token punctuation">)</span> <span class="token operator">!=</span> IPv4Address<span class="token punctuation">(</span><span class="token string">'127.0.0.1'</span><span class="token punctuation">)</span>
<span class="token boolean">True</span>
<span class="token operator">>></span><span class="token operator">></span> IPv6Address<span class="token punctuation">(</span><span class="token string">'fe80::1234'</span><span class="token punctuation">)</span> <span class="token operator">==</span> IPv6Address<span class="token punctuation">(</span><span class="token string">'fe80::1234%1'</span><span class="token punctuation">)</span>
<span class="token boolean">False</span>
<span class="token operator">>></span><span class="token operator">></span> IPv6Address<span class="token punctuation">(</span><span class="token string">'fe80::1234%1'</span><span class="token punctuation">)</span> <span class="token operator">!=</span> IPv6Address<span class="token punctuation">(</span><span class="token string">'fe80::1234%2'</span><span class="token punctuation">)</span>
<span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h5 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h5><p>Integers can be added to or subtracted from address objects. Some examples:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> IPv4Address<span class="token punctuation">(</span><span class="token string">'127.0.0.2'</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">3</span>
IPv4Address<span class="token punctuation">(</span><span class="token string">'127.0.0.5'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> IPv4Address<span class="token punctuation">(</span><span class="token string">'127.0.0.2'</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">3</span>
IPv4Address<span class="token punctuation">(</span><span class="token string">'126.255.255.255'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> IPv4Address<span class="token punctuation">(</span><span class="token string">'255.255.255.255'</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span>
Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>
  File <span class="token string">"&lt;stdin>"</span><span class="token punctuation">,</span> line <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">></span>
ipaddress<span class="token punctuation">.</span>AddressValueError<span class="token punctuation">:</span> <span class="token number">4294967296</span> <span class="token punctuation">(</span><span class="token operator">>=</span> <span class="token number">2</span><span class="token operator">**</span><span class="token number">32</span><span class="token punctuation">)</span> <span class="token keyword">is</span> <span class="token operator">not</span> permitted <span class="token keyword">as</span> an IPv4 address<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="IP网络的定义"><a href="#IP网络的定义" class="headerlink" title="IP网络的定义"></a>IP网络的定义</h3><p>The <code>IPv4Network</code> and <code>IPv6Network</code> objects provide a mechanism for defining and inspecting IP network definitions. A network definition consists of a <em>mask</em> and a <em>network address</em>, and as such defines a range of IP addresses that equal the network address when masked (binary AND) with the mask. For example, a network definition with the mask <code>255.255.255.0</code> and the network address <code>192.168.1.0</code> consists of IP addresses in the inclusive range <code>192.168.1.0</code> to <code>192.168.1.255</code>.</p>
<h4 id="Prefix-net-mask-and-host-mask"><a href="#Prefix-net-mask-and-host-mask" class="headerlink" title="Prefix, net mask and host mask"></a>Prefix, net mask and host mask</h4><p>There are several equivalent ways to specify IP network masks. A <em>prefix</em> <code>/&lt;nbits&gt;</code> is a notation that denotes how many high-order bits are set in the network mask. A <em>net mask</em> is an IP address with some number of high-order bits set. Thus the prefix <code>/24</code> is equivalent to the net mask <code>255.255.255.0</code> in IPv4, or <code>ffff:ff00::</code> in IPv6. In addition, a <em>host mask</em> is the logical inverse of a <em>net mask</em>, and is sometimes used (for example in Cisco access control lists) to denote a network mask. The host mask equivalent to <code>/24</code> in IPv4 is <code>0.0.0.255</code>.</p>
<h4 id="Network-objects"><a href="#Network-objects" class="headerlink" title="Network objects"></a>Network objects</h4><p>All attributes implemented by address objects are implemented by network objects as well. In addition, network objects implement additional attributes. All of these are common between <code>IPv4Network</code> and <code>IPv6Network</code>, so to avoid duplication they are only documented for <code>IPv4Network</code>. Network objects are hashable, so they can be used as keys in dictionaries.</p>
<p><em>class</em> <code>ipaddress.IPv4Network</code>(<em>address</em>, <em>strict=True</em>)</p>
<p>Construct an IPv4 network definition. <em>address</em> can be one of the following:</p>
<ol>
<li><p>A string consisting of an IP address and an optional mask, separated by a slash (<code>/</code>). The IP address is the network address, and the mask can be either a single number, which means it’s a <em>prefix</em>, or a string representation of an IPv4 address. If it’s the latter, the mask is interpreted as a <em>net mask</em> if it starts with a non-zero field, or as a <em>host mask</em> if it starts with a zero field, with the single exception of an all-zero mask which is treated as a <em>net mask</em>. If no mask is provided, it’s considered to be <code>/32</code>.</p>
<p>For example, the following <em>address</em> specifications are equivalent: <code>192.168.1.0/24</code>, <code>192.168.1.0/255.255.255.0</code> and <code>192.168.1.0/0.0.0.255</code>.</p>
</li>
<li><p>An integer that fits into 32 bits. This is equivalent to a single-address network, with the network address being <em>address</em> and the mask being <code>/32</code>.</p>
</li>
<li><p>An integer packed into a <code>bytes</code> object of length 4, big-endian. The interpretation is similar to an integer <em>address</em>.</p>
</li>
<li><p>A two-tuple of an address description and a netmask, where the address description is either a string, a 32-bits integer, a 4-bytes packed integer, or an existing IPv4Address object; and the netmask is either an integer representing the prefix length (e.g. <code>24</code>) or a string representing the prefix mask (e.g. <code>255.255.255.0</code>).</p>
</li>
</ol>
<p>An <code>AddressValueError</code> is raised if <em>address</em> is not a valid IPv4 address. A <code>NetmaskValueError</code> is raised if the mask is not valid for an IPv4 address.</p>
<p>If <em>strict</em> is <code>True</code> and host bits are set in the supplied address, then <code>ValueError</code> is raised. Otherwise, the host bits are masked out to determine the appropriate network address.</p>
<p>Unless stated otherwise, all network methods accepting other network/address objects will raise <code>TypeError</code> if the argument’s IP version is incompatible to <code>self</code>.</p>
<p>在 3.5 版更改: Added the two-tuple form for the <em>address</em> constructor parameter.</p>
<ul>
<li><p><code>version</code></p>
</li>
<li><p><code>max_prefixlen</code></p>
<p>Refer to the corresponding attribute documentation in <code>IPv4Address</code>.</p>
</li>
<li><p><code>is_multicast</code></p>
</li>
<li><p><code>is_private</code></p>
</li>
<li><p><code>is_unspecified</code></p>
</li>
<li><p><code>is_reserved</code></p>
</li>
<li><p><code>is_loopback</code></p>
</li>
<li><p><code>is_link_local</code></p>
<p>These attributes are true for the network as a whole if they are true for both the network address and the broadcast address.</p>
</li>
<li><p><code>network_address</code></p>
<p>The network address for the network. The network address and the prefix length together uniquely define a network.</p>
</li>
<li><p><code>broadcast_address</code></p>
<p>The broadcast address for the network. Packets sent to the broadcast address should be received by every host on the network.</p>
</li>
<li><p><code>hostmask</code></p>
<p>The host mask, as an <code>IPv4Address</code> object.</p>
</li>
<li><p><code>netmask</code></p>
<p>The net mask, as an <code>IPv4Address</code> object.</p>
</li>
<li><p><code>with_prefixlen</code></p>
</li>
<li><p><code>compressed</code></p>
</li>
<li><p><code>exploded</code></p>
<p>A string representation of the network, with the mask in prefix notation.</p>
<p><code>with_prefixlen</code> and <code>compressed</code> are always the same as <code>str(network)</code>. <code>exploded</code> uses the exploded form the network address.</p>
</li>
<li><p><code>with_netmask</code></p>
<p>A string representation of the network, with the mask in net mask notation.</p>
</li>
<li><p><code>with_hostmask</code></p>
<p>A string representation of the network, with the mask in host mask notation.</p>
</li>
<li><p><code>num_addresses</code></p>
<p>The total number of addresses in the network.</p>
</li>
<li><p><code>prefixlen</code></p>
<p>Length of the network prefix, in bits.</p>
</li>
<li><p><code>hosts</code>()</p>
<p>Returns an iterator over the usable hosts in the network. The usable hosts are all the IP addresses that belong to the network, except the network address itself and the network broadcast address. For networks with a mask length of 31, the network address and network broadcast address are also included in the result. Networks with a mask of 32 will return a list containing the single host address.</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> list<span class="token punctuation">(</span>ip_network<span class="token punctuation">(</span><span class="token string">'192.0.2.0/29'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>hosts<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  
<span class="token punctuation">[</span>IPv4Address<span class="token punctuation">(</span><span class="token string">'192.0.2.1'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> IPv4Address<span class="token punctuation">(</span><span class="token string">'192.0.2.2'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
 IPv4Address<span class="token punctuation">(</span><span class="token string">'192.0.2.3'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> IPv4Address<span class="token punctuation">(</span><span class="token string">'192.0.2.4'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
 IPv4Address<span class="token punctuation">(</span><span class="token string">'192.0.2.5'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> IPv4Address<span class="token punctuation">(</span><span class="token string">'192.0.2.6'</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> list<span class="token punctuation">(</span>ip_network<span class="token punctuation">(</span><span class="token string">'192.0.2.0/31'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>hosts<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span>IPv4Address<span class="token punctuation">(</span><span class="token string">'192.0.2.0'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> IPv4Address<span class="token punctuation">(</span><span class="token string">'192.0.2.1'</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> list<span class="token punctuation">(</span>ip_network<span class="token punctuation">(</span><span class="token string">'192.0.2.1/32'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>hosts<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span>IPv4Address<span class="token punctuation">(</span><span class="token string">'192.0.2.1'</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><code>overlaps</code>(<em>other</em>)</p>
<p><code>True</code> if this network is partly or wholly contained in <em>other</em> or <em>other</em> is wholly contained in this network.</p>
</li>
<li><p><code>address_exclude</code>(<em>network</em>)</p>
<p>Computes the network definitions resulting from removing the given <em>network</em> from this one. Returns an iterator of network objects. Raises <code>ValueError</code> if <em>network</em> is not completely contained in this network.</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> n1 <span class="token operator">=</span> ip_network<span class="token punctuation">(</span><span class="token string">'192.0.2.0/28'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> n2 <span class="token operator">=</span> ip_network<span class="token punctuation">(</span><span class="token string">'192.0.2.1/32'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> list<span class="token punctuation">(</span>n1<span class="token punctuation">.</span>address_exclude<span class="token punctuation">(</span>n2<span class="token punctuation">)</span><span class="token punctuation">)</span>  
<span class="token punctuation">[</span>IPv4Network<span class="token punctuation">(</span><span class="token string">'192.0.2.8/29'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> IPv4Network<span class="token punctuation">(</span><span class="token string">'192.0.2.4/30'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
 IPv4Network<span class="token punctuation">(</span><span class="token string">'192.0.2.2/31'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> IPv4Network<span class="token punctuation">(</span><span class="token string">'192.0.2.0/32'</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><code>subnets</code>(<em>prefixlen_diff=1</em>, <em>new_prefix=None</em>)</p>
<p>The subnets that join to make the current network definition, depending on the argument values. <em>prefixlen_diff</em> is the amount our prefix length should be increased by. <em>new_prefix</em> is the desired new prefix of the subnets; it must be larger than our prefix. One and only one of <em>prefixlen_diff</em> and <em>new_prefix</em> must be set. Returns an iterator of network objects.</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> list<span class="token punctuation">(</span>ip_network<span class="token punctuation">(</span><span class="token string">'192.0.2.0/24'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>subnets<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span>IPv4Network<span class="token punctuation">(</span><span class="token string">'192.0.2.0/25'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> IPv4Network<span class="token punctuation">(</span><span class="token string">'192.0.2.128/25'</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> list<span class="token punctuation">(</span>ip_network<span class="token punctuation">(</span><span class="token string">'192.0.2.0/24'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>subnets<span class="token punctuation">(</span>prefixlen_diff<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  
<span class="token punctuation">[</span>IPv4Network<span class="token punctuation">(</span><span class="token string">'192.0.2.0/26'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> IPv4Network<span class="token punctuation">(</span><span class="token string">'192.0.2.64/26'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
 IPv4Network<span class="token punctuation">(</span><span class="token string">'192.0.2.128/26'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> IPv4Network<span class="token punctuation">(</span><span class="token string">'192.0.2.192/26'</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> list<span class="token punctuation">(</span>ip_network<span class="token punctuation">(</span><span class="token string">'192.0.2.0/24'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>subnets<span class="token punctuation">(</span>new_prefix<span class="token operator">=</span><span class="token number">26</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  
<span class="token punctuation">[</span>IPv4Network<span class="token punctuation">(</span><span class="token string">'192.0.2.0/26'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> IPv4Network<span class="token punctuation">(</span><span class="token string">'192.0.2.64/26'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
 IPv4Network<span class="token punctuation">(</span><span class="token string">'192.0.2.128/26'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> IPv4Network<span class="token punctuation">(</span><span class="token string">'192.0.2.192/26'</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> list<span class="token punctuation">(</span>ip_network<span class="token punctuation">(</span><span class="token string">'192.0.2.0/24'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>subnets<span class="token punctuation">(</span>new_prefix<span class="token operator">=</span><span class="token number">23</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>
  File <span class="token string">"&lt;stdin>"</span><span class="token punctuation">,</span> line <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">></span>
    <span class="token keyword">raise</span> ValueError<span class="token punctuation">(</span><span class="token string">'new prefix must be longer'</span><span class="token punctuation">)</span>
ValueError<span class="token punctuation">:</span> new prefix must be longer
<span class="token operator">>></span><span class="token operator">></span> list<span class="token punctuation">(</span>ip_network<span class="token punctuation">(</span><span class="token string">'192.0.2.0/24'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>subnets<span class="token punctuation">(</span>new_prefix<span class="token operator">=</span><span class="token number">25</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span>IPv4Network<span class="token punctuation">(</span><span class="token string">'192.0.2.0/25'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> IPv4Network<span class="token punctuation">(</span><span class="token string">'192.0.2.128/25'</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><code>supernet</code>(<em>prefixlen_diff=1</em>, <em>new_prefix=None</em>)</p>
<p>The supernet containing this network definition, depending on the argument values. <em>prefixlen_diff</em> is the amount our prefix length should be decreased by. <em>new_prefix</em> is the desired new prefix of the supernet; it must be smaller than our prefix. One and only one of <em>prefixlen_diff</em> and <em>new_prefix</em> must be set. Returns a single network object.</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> ip_network<span class="token punctuation">(</span><span class="token string">'192.0.2.0/24'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>supernet<span class="token punctuation">(</span><span class="token punctuation">)</span>
IPv4Network<span class="token punctuation">(</span><span class="token string">'192.0.2.0/23'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> ip_network<span class="token punctuation">(</span><span class="token string">'192.0.2.0/24'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>supernet<span class="token punctuation">(</span>prefixlen_diff<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span>
IPv4Network<span class="token punctuation">(</span><span class="token string">'192.0.0.0/22'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> ip_network<span class="token punctuation">(</span><span class="token string">'192.0.2.0/24'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>supernet<span class="token punctuation">(</span>new_prefix<span class="token operator">=</span><span class="token number">20</span><span class="token punctuation">)</span>
IPv4Network<span class="token punctuation">(</span><span class="token string">'192.0.0.0/20'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><code>subnet_of</code>(<em>other</em>)</p>
<p>Return <code>True</code> if this network is a subnet of <em>other</em>.</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> a <span class="token operator">=</span> ip_network<span class="token punctuation">(</span><span class="token string">'192.168.1.0/24'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> b <span class="token operator">=</span> ip_network<span class="token punctuation">(</span><span class="token string">'192.168.1.128/30'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> b<span class="token punctuation">.</span>subnet_of<span class="token punctuation">(</span>a<span class="token punctuation">)</span>
<span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>3.7 新版功能.</p>
</li>
<li><p><code>supernet_of</code>(<em>other</em>)</p>
<p>Return <code>True</code> if this network is a supernet of <em>other</em>.</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> a <span class="token operator">=</span> ip_network<span class="token punctuation">(</span><span class="token string">'192.168.1.0/24'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> b <span class="token operator">=</span> ip_network<span class="token punctuation">(</span><span class="token string">'192.168.1.128/30'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> a<span class="token punctuation">.</span>supernet_of<span class="token punctuation">(</span>b<span class="token punctuation">)</span>
<span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>3.7 新版功能.</p>
</li>
<li><p><code>compare_networks</code>(<em>other</em>)</p>
<p>Compare this network to <em>other</em>. In this comparison only the network addresses are considered; host bits aren’t. Returns either <code>-1</code>, <code>0</code> or <code>1</code>.</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> ip_network<span class="token punctuation">(</span><span class="token string">'192.0.2.1/32'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>compare_networks<span class="token punctuation">(</span>ip_network<span class="token punctuation">(</span><span class="token string">'192.0.2.2/32'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token operator">-</span><span class="token number">1</span>
<span class="token operator">>></span><span class="token operator">></span> ip_network<span class="token punctuation">(</span><span class="token string">'192.0.2.1/32'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>compare_networks<span class="token punctuation">(</span>ip_network<span class="token punctuation">(</span><span class="token string">'192.0.2.0/32'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token number">1</span>
<span class="token operator">>></span><span class="token operator">></span> ip_network<span class="token punctuation">(</span><span class="token string">'192.0.2.1/32'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>compare_networks<span class="token punctuation">(</span>ip_network<span class="token punctuation">(</span><span class="token string">'192.0.2.1/32'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>3.7 版后已移除: It uses the same ordering and comparison algorithm as “&lt;”, “==”, and “&gt;”</p>
</li>
</ul>
<p><em>class</em> <code>ipaddress.IPv6Network</code>(<em>address</em>, <em>strict=True</em>)</p>
<p>Construct an IPv6 network definition. <em>address</em> can be one of the following:</p>
<ol>
<li><p>A string consisting of an IP address and an optional prefix length, separated by a slash (<code>/</code>). The IP address is the network address, and the prefix length must be a single number, the <em>prefix</em>. If no prefix length is provided, it’s considered to be <code>/128</code>.</p>
<p>Note that currently expanded netmasks are not supported. That means <code>2001:db00::0/24</code> is a valid argument while <code>2001:db00::0/ffff:ff00::</code> not.</p>
</li>
<li><p>An integer that fits into 128 bits. This is equivalent to a single-address network, with the network address being <em>address</em> and the mask being <code>/128</code>.</p>
</li>
<li><p>An integer packed into a <code>bytes</code> object of length 16, big-endian. The interpretation is similar to an integer <em>address</em>.</p>
</li>
<li><p>A two-tuple of an address description and a netmask, where the address description is either a string, a 128-bits integer, a 16-bytes packed integer, or an existing IPv6Address object; and the netmask is an integer representing the prefix length.</p>
</li>
</ol>
<p>An <code>AddressValueError</code> is raised if <em>address</em> is not a valid IPv6 address. A <code>NetmaskValueError</code> is raised if the mask is not valid for an IPv6 address.</p>
<p>If <em>strict</em> is <code>True</code> and host bits are set in the supplied address, then <code>ValueError</code> is raised. Otherwise, the host bits are masked out to determine the appropriate network address.</p>
<p>在 3.5 版更改: Added the two-tuple form for the <em>address</em> constructor parameter.</p>
<ul>
<li><p><code>version</code></p>
</li>
<li><p><code>max_prefixlen</code></p>
</li>
<li><p><code>is_multicast</code></p>
</li>
<li><p><code>is_private</code></p>
</li>
<li><p><code>is_unspecified</code></p>
</li>
<li><p><code>is_reserved</code></p>
</li>
<li><p><code>is_loopback</code></p>
</li>
<li><p><code>is_link_local</code></p>
</li>
<li><p><code>network_address</code></p>
</li>
<li><p><code>broadcast_address</code></p>
</li>
<li><p><code>hostmask</code></p>
</li>
<li><p><code>netmask</code></p>
</li>
<li><p><code>with_prefixlen</code></p>
</li>
<li><p><code>compressed</code></p>
</li>
<li><p><code>exploded</code></p>
</li>
<li><p><code>with_netmask</code></p>
</li>
<li><p><code>with_hostmask</code></p>
</li>
<li><p><code>num_addresses</code></p>
</li>
<li><p><code>prefixlen</code></p>
</li>
<li><p><code>hosts</code>()</p>
<p>Returns an iterator over the usable hosts in the network. The usable hosts are all the IP addresses that belong to the network, except the Subnet-Router anycast address. For networks with a mask length of 127, the Subnet-Router anycast address is also included in the result. Networks with a mask of 128 will return a list containing the single host address.</p>
</li>
<li><p><code>overlaps</code>(<em>other</em>)</p>
</li>
<li><p><code>address_exclude</code>(<em>network</em>)</p>
</li>
<li><p><code>subnets</code>(<em>prefixlen_diff=1</em>, <em>new_prefix=None</em>)</p>
</li>
<li><p><code>supernet</code>(<em>prefixlen_diff=1</em>, <em>new_prefix=None</em>)</p>
</li>
<li><p><code>subnet_of</code>(<em>other</em>)</p>
</li>
<li><p><code>supernet_of</code>(<em>other</em>)</p>
</li>
<li><p><code>compare_networks</code>(<em>other</em>)</p>
<p>Refer to the corresponding attribute documentation in <code>IPv4Network</code>.</p>
</li>
<li><p><code>is_site_local</code></p>
<p>These attribute is true for the network as a whole if it is true for both the network address and the broadcast address.</p>
</li>
</ul>
<h4 id="运算符-1"><a href="#运算符-1" class="headerlink" title="运算符"></a>运算符</h4><p>Network objects support some operators. Unless stated otherwise, operators can only be applied between compatible objects (i.e. IPv4 with IPv4, IPv6 with IPv6).</p>
<h5 id="Logical-operators"><a href="#Logical-operators" class="headerlink" title="Logical operators"></a>Logical operators</h5><p>Network objects can be compared with the usual set of logical operators. Network objects are ordered first by network address, then by net mask.</p>
<h5 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h5><p>Network objects can be iterated to list all the addresses belonging to the network. For iteration, <em>all</em> hosts are returned, including unusable hosts (for usable hosts, use the <code>hosts()</code> method). An example:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">for</span> addr <span class="token keyword">in</span> IPv4Network<span class="token punctuation">(</span><span class="token string">'192.0.2.0/28'</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     addr
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
IPv4Address<span class="token punctuation">(</span><span class="token string">'192.0.2.0'</span><span class="token punctuation">)</span>
IPv4Address<span class="token punctuation">(</span><span class="token string">'192.0.2.1'</span><span class="token punctuation">)</span>
IPv4Address<span class="token punctuation">(</span><span class="token string">'192.0.2.2'</span><span class="token punctuation">)</span>
IPv4Address<span class="token punctuation">(</span><span class="token string">'192.0.2.3'</span><span class="token punctuation">)</span>
IPv4Address<span class="token punctuation">(</span><span class="token string">'192.0.2.4'</span><span class="token punctuation">)</span>
IPv4Address<span class="token punctuation">(</span><span class="token string">'192.0.2.5'</span><span class="token punctuation">)</span>
IPv4Address<span class="token punctuation">(</span><span class="token string">'192.0.2.6'</span><span class="token punctuation">)</span>
IPv4Address<span class="token punctuation">(</span><span class="token string">'192.0.2.7'</span><span class="token punctuation">)</span>
IPv4Address<span class="token punctuation">(</span><span class="token string">'192.0.2.8'</span><span class="token punctuation">)</span>
IPv4Address<span class="token punctuation">(</span><span class="token string">'192.0.2.9'</span><span class="token punctuation">)</span>
IPv4Address<span class="token punctuation">(</span><span class="token string">'192.0.2.10'</span><span class="token punctuation">)</span>
IPv4Address<span class="token punctuation">(</span><span class="token string">'192.0.2.11'</span><span class="token punctuation">)</span>
IPv4Address<span class="token punctuation">(</span><span class="token string">'192.0.2.12'</span><span class="token punctuation">)</span>
IPv4Address<span class="token punctuation">(</span><span class="token string">'192.0.2.13'</span><span class="token punctuation">)</span>
IPv4Address<span class="token punctuation">(</span><span class="token string">'192.0.2.14'</span><span class="token punctuation">)</span>
IPv4Address<span class="token punctuation">(</span><span class="token string">'192.0.2.15'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h5 id="Networks-as-containers-of-addresses"><a href="#Networks-as-containers-of-addresses" class="headerlink" title="Networks as containers of addresses"></a>Networks as containers of addresses</h5><p>Network objects can act as containers of addresses. Some examples:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> IPv4Network<span class="token punctuation">(</span><span class="token string">'192.0.2.0/28'</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
IPv4Address<span class="token punctuation">(</span><span class="token string">'192.0.2.0'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> IPv4Network<span class="token punctuation">(</span><span class="token string">'192.0.2.0/28'</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">]</span>
IPv4Address<span class="token punctuation">(</span><span class="token string">'192.0.2.15'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> IPv4Address<span class="token punctuation">(</span><span class="token string">'192.0.2.6'</span><span class="token punctuation">)</span> <span class="token keyword">in</span> IPv4Network<span class="token punctuation">(</span><span class="token string">'192.0.2.0/28'</span><span class="token punctuation">)</span>
<span class="token boolean">True</span>
<span class="token operator">>></span><span class="token operator">></span> IPv4Address<span class="token punctuation">(</span><span class="token string">'192.0.3.6'</span><span class="token punctuation">)</span> <span class="token keyword">in</span> IPv4Network<span class="token punctuation">(</span><span class="token string">'192.0.2.0/28'</span><span class="token punctuation">)</span>
<span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="Interface-objects"><a href="#Interface-objects" class="headerlink" title="Interface objects"></a>Interface objects</h4><p>Interface objects are hashable, so they can be used as keys in dictionaries.</p>
<p><em>class</em> <code>ipaddress.IPv4Interface</code>(<em>address</em>)</p>
<p>Construct an IPv4 interface. The meaning of <em>address</em> is as in the constructor of <code>IPv4Network</code>, except that arbitrary host addresses are always accepted.</p>
<p><code>IPv4Interface</code> is a subclass of <code>IPv4Address</code>, so it inherits all the attributes from that class. In addition, the following attributes are available:</p>
<ul>
<li><p><code>ip</code></p>
<p>The address (<code>IPv4Address</code>) without network information.</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> interface <span class="token operator">=</span> IPv4Interface<span class="token punctuation">(</span><span class="token string">'192.0.2.5/24'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> interface<span class="token punctuation">.</span>ip
IPv4Address<span class="token punctuation">(</span><span class="token string">'192.0.2.5'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><code>network</code></p>
<p>The network (<code>IPv4Network</code>) this interface belongs to.</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> interface <span class="token operator">=</span> IPv4Interface<span class="token punctuation">(</span><span class="token string">'192.0.2.5/24'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> interface<span class="token punctuation">.</span>network
IPv4Network<span class="token punctuation">(</span><span class="token string">'192.0.2.0/24'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><code>with_prefixlen</code></p>
<p>A string representation of the interface with the mask in prefix notation.</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> interface <span class="token operator">=</span> IPv4Interface<span class="token punctuation">(</span><span class="token string">'192.0.2.5/24'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> interface<span class="token punctuation">.</span>with_prefixlen
<span class="token string">'192.0.2.5/24'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><code>with_netmask</code></p>
<p>A string representation of the interface with the network as a net mask.</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> interface <span class="token operator">=</span> IPv4Interface<span class="token punctuation">(</span><span class="token string">'192.0.2.5/24'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> interface<span class="token punctuation">.</span>with_netmask
<span class="token string">'192.0.2.5/255.255.255.0'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><code>with_hostmask</code></p>
<p>A string representation of the interface with the network as a host mask.</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> interface <span class="token operator">=</span> IPv4Interface<span class="token punctuation">(</span><span class="token string">'192.0.2.5/24'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> interface<span class="token punctuation">.</span>with_hostmask
<span class="token string">'192.0.2.5/0.0.0.255'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
<p><em>class</em> <code>ipaddress.IPv6Interface</code>(<em>address</em>)</p>
<p>Construct an IPv6 interface. The meaning of <em>address</em> is as in the constructor of <code>IPv6Network</code>, except that arbitrary host addresses are always accepted.</p>
<p><code>IPv6Interface</code> is a subclass of <code>IPv6Address</code>, so it inherits all the attributes from that class. In addition, the following attributes are available:</p>
<ul>
<li><p><code>ip</code></p>
</li>
<li><p><code>network</code></p>
</li>
<li><p><code>with_prefixlen</code></p>
</li>
<li><p><code>with_netmask</code></p>
</li>
<li><p><code>with_hostmask</code></p>
<p>Refer to the corresponding attribute documentation in <code>IPv4Interface</code>.</p>
</li>
</ul>
<h4 id="运算符-2"><a href="#运算符-2" class="headerlink" title="运算符"></a>运算符</h4><p>Interface objects support some operators. Unless stated otherwise, operators can only be applied between compatible objects (i.e. IPv4 with IPv4, IPv6 with IPv6).</p>
<h5 id="Logical-operators-1"><a href="#Logical-operators-1" class="headerlink" title="Logical operators"></a>Logical operators</h5><p>Interface objects can be compared with the usual set of logical operators.</p>
<p>For equality comparison (<code>==</code> and <code>!=</code>), both the IP address and network must be the same for the objects to be equal. An interface will not compare equal to any address or network object.</p>
<p>For ordering (<code>&lt;</code>, <code>&gt;</code>, etc) the rules are different. Interface and address objects with the same IP version can be compared, and the address objects will always sort before the interface objects. Two interface objects are first compared by their networks and, if those are the same, then by their IP addresses.</p>
<h3 id="Other-Module-Level-Functions"><a href="#Other-Module-Level-Functions" class="headerlink" title="Other Module Level Functions"></a>Other Module Level Functions</h3><p>The module also provides the following module level functions:</p>
<p><code>ipaddress.v4_int_to_packed</code>(<em>address</em>)</p>
<p>Represent an address as 4 packed bytes in network (big-endian) order. <em>address</em> is an integer representation of an IPv4 IP address. A <code>ValueError</code> is raised if the integer is negative or too large to be an IPv4 IP address.</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> ipaddress<span class="token punctuation">.</span>ip_address<span class="token punctuation">(</span><span class="token number">3221225985</span><span class="token punctuation">)</span>
IPv4Address<span class="token punctuation">(</span><span class="token string">'192.0.2.1'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> ipaddress<span class="token punctuation">.</span>v4_int_to_packed<span class="token punctuation">(</span><span class="token number">3221225985</span><span class="token punctuation">)</span>
b<span class="token string">'\xc0\x00\x02\x01'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>ipaddress.v6_int_to_packed</code>(<em>address</em>)</p>
<p>Represent an address as 16 packed bytes in network (big-endian) order. <em>address</em> is an integer representation of an IPv6 IP address. A <code>ValueError</code> is raised if the integer is negative or too large to be an IPv6 IP address.</p>
<p><code>ipaddress.summarize_address_range</code>(<em>first</em>, <em>last</em>)</p>
<p>Return an iterator of the summarized network range given the first and last IP addresses. <em>first</em> is the first <code>IPv4Address</code> or <code>IPv6Address</code> in the range and <em>last</em> is the last <code>IPv4Address</code> or <code>IPv6Address</code> in the range. A <code>TypeError</code> is raised if <em>first</em> or <em>last</em> are not IP addresses or are not of the same version. A <code>ValueError</code> is raised if <em>last</em> is not greater than <em>first</em> or if <em>first</em> address version is not 4 or 6.</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token punctuation">[</span>ipaddr <span class="token keyword">for</span> ipaddr <span class="token keyword">in</span> ipaddress<span class="token punctuation">.</span>summarize_address_range<span class="token punctuation">(</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    ipaddress<span class="token punctuation">.</span>IPv4Address<span class="token punctuation">(</span><span class="token string">'192.0.2.0'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    ipaddress<span class="token punctuation">.</span>IPv4Address<span class="token punctuation">(</span><span class="token string">'192.0.2.130'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span>IPv4Network<span class="token punctuation">(</span><span class="token string">'192.0.2.0/25'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> IPv4Network<span class="token punctuation">(</span><span class="token string">'192.0.2.128/31'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> IPv4Network<span class="token punctuation">(</span><span class="token string">'192.0.2.130/32'</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>ipaddress.collapse_addresses</code>(<em>addresses</em>)</p>
<p>Return an iterator of the collapsed <code>IPv4Network</code> or <code>IPv6Network</code> objects. <em>addresses</em> is an iterator of <code>IPv4Network</code> or <code>IPv6Network</code> objects. A <code>TypeError</code> is raised if <em>addresses</em> contains mixed version objects.</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token punctuation">[</span>ipaddr <span class="token keyword">for</span> ipaddr <span class="token keyword">in</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> ipaddress<span class="token punctuation">.</span>collapse_addresses<span class="token punctuation">(</span><span class="token punctuation">[</span>ipaddress<span class="token punctuation">.</span>IPv4Network<span class="token punctuation">(</span><span class="token string">'192.0.2.0/25'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> ipaddress<span class="token punctuation">.</span>IPv4Network<span class="token punctuation">(</span><span class="token string">'192.0.2.128/25'</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span>IPv4Network<span class="token punctuation">(</span><span class="token string">'192.0.2.0/24'</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>ipaddress.get_mixed_type_key</code>(<em>obj</em>)</p>
<p>Return a key suitable for sorting between networks and addresses. Address and Network objects are not sortable by default; they’re fundamentally different, so the expression:</p>
<pre class="line-numbers language-python"><code class="language-python">IPv4Address<span class="token punctuation">(</span><span class="token string">'192.0.2.0'</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> IPv4Network<span class="token punctuation">(</span><span class="token string">'192.0.2.0/24'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>doesn’t make sense. There are some times however, where you may wish to have <code>ipaddress</code> sort these anyway. If you need to do this, you can use this function as the <em>key</em> argument to <code>sorted()</code>.</p>
<p><em>obj</em> is either a network or address object.</p>
<h3 id="Custom-Exceptions"><a href="#Custom-Exceptions" class="headerlink" title="Custom Exceptions"></a>Custom Exceptions</h3><p>To support more specific error reporting from class constructors, the module defines the following exceptions:</p>
<p><em>exception</em> <code>ipaddress.AddressValueError</code>(<em>ValueError</em>)</p>
<p>Any value error related to the address.</p>
<p><em>exception</em> <code>ipaddress.NetmaskValueError</code>(<em>ValueError</em>)</p>
<p>Any value error related to the net mask.</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://jackhcc.github.io" rel="external nofollow noreferrer">杰克成</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://jackhcc.github.io/posts/Language-Python-Lib3.html">https://jackhcc.github.io/posts/Language-Python-Lib3.html</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="https://jackhcc.github.io" target="_blank">杰克成</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/Python/">
                                    <span class="chip bg-color">Python</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/share/css/share.min.css">

<div id="article-share">
    
    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/medias/reward/aliqr.png" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/medias/reward/wxqr.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>
            
        </div>
    </div>

    
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/gitalk/gitalk.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/css/my-gitalk.css">

<div class="card gitalk-card" data-aos="fade-up">
    <div class="comment_headling" style="font-size: 20px; font-weight: 700; position: relative; left: 20px; top: 15px; padding-bottom: 5px;">
        <i class="fas fa-comments fa-fw" aria-hidden="true"></i>
        <span>评论</span>
    </div>
    <div id="gitalk-container" class="card-content"></div>
</div>

<script src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/gitalk/gitalk.min.js"></script>
<script>
    let gitalk = new Gitalk({
        clientID: '3821a0bbb773038a51fc',
        clientSecret: '4b30b507d67ec5497ec0e77f43f80cb3e0d7dd3a',
        repo: 'JackHCC.github.io',
        owner: 'JackHCC',
        admin: "JackHCC",
        id: '2021-11-09T11-58-47',
        distractionFreeMode: false  // Facebook-like distraction free mode
    });

    gitalk.render('gitalk-container');
</script>
    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/posts/dl-series18.html">
                    <div class="card-image">
                        
                        
                        <img src="/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/medias/featureimages/5.jpg" class="responsive-img" alt="DL专栏18-Normalization">
                        
                        <span class="card-title">DL专栏18-Normalization</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            Normalization方法
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2021-11-11
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/Deep-Learning/" class="post-category">
                                    Deep Learning
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Normalization/">
                        <span class="chip bg-color">Normalization</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/posts/Algorithm.html">
                    <div class="card-image">
                        
                        
                        <img src="/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/medias/featureimages/3.jpg" class="responsive-img" alt="Algorithm Summary">
                        
                        <span class="card-title">Algorithm Summary</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            经典算法实现汇总
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2021-11-08
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/Algorithm/" class="post-category">
                                    Algorithm
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Algorithm/">
                        <span class="chip bg-color">Algorithm</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/codeBlock/codeShrink.js"></script>


<!-- 代码块折行 -->

<style type="text/css">
code[class*="language-"], pre[class*="language-"] { white-space: pre !important; }
</style>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('4'),
            headingSelector: 'h1, h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h1, h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>



    <footer class="page-footer bg-color">
    <div class="container row center-align" style="margin-bottom: 15px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            <span id="year">2020</span>
            <a href="https://jackhcc.github.io" target="_blank">杰克成</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                class="white-color">3591.2k</span>&nbsp;字
            
            
            
            
            
            
            <span id="busuanzi_container_site_pv">
                |&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv"
                    class="white-color"></span>&nbsp;次
            </span>
            
            
            <span id="busuanzi_container_site_uv">
                |&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv"
                    class="white-color"></span>&nbsp;人
            </span>
            
            <br>
            
            <span id="sitetime">载入运行时间...</span>
            <script>
                function siteTime() {
                    var seconds = 1000;
                    var minutes = seconds * 60;
                    var hours = minutes * 60;
                    var days = hours * 24;
                    var years = days * 365;
                    var today = new Date();
                    var startYear = "2020";
                    var startMonth = "2";
                    var startDate = "27";
                    var startHour = "6";
                    var startMinute = "30";
                    var startSecond = "0";
                    var todayYear = today.getFullYear();
                    var todayMonth = today.getMonth() + 1;
                    var todayDate = today.getDate();
                    var todayHour = today.getHours();
                    var todayMinute = today.getMinutes();
                    var todaySecond = today.getSeconds();
                    var t1 = Date.UTC(startYear, startMonth, startDate, startHour, startMinute, startSecond);
                    var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
                    var diff = t2 - t1;
                    var diffYears = Math.floor(diff / years);
                    var diffDays = Math.floor((diff / days) - diffYears * 365);
                    var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours);
                    var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) /
                        minutes);
                    var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours -
                        diffMinutes * minutes) / seconds);
                    if (startYear == todayYear) {
                        document.getElementById("year").innerHTML = todayYear;
                        document.getElementById("sitetime").innerHTML = "本站已安全运行 " + diffDays + " 天 " + diffHours +
                            " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                    } else {
                        document.getElementById("year").innerHTML = startYear + " - " + todayYear;
                        document.getElementById("sitetime").innerHTML = "本站已安全运行 " + diffYears + " 年 " + diffDays +
                            " 天 " + diffHours + " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                    }
                }
                setInterval(siteTime, 1000);
            </script>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/JackHCC" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:jackcc0701@163.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>



    <a href="https://www.facebook.com/profile.php?id=100046343443643" class="tooltipped" target="_blank" data-tooltip="关注我的Facebook: https://www.facebook.com/profile.php?id=100046343443643" data-position="top" data-delay="50">
        <i class="fab fa-facebook-f"></i>
    </a>



    <a href="https://twitter.com/JackChe66021834" class="tooltipped" target="_blank" data-tooltip="关注我的Twitter: https://twitter.com/JackChe66021834" data-position="top" data-delay="50">
        <i class="fab fa-twitter"></i>
    </a>



    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=2508074836" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 2508074836" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>



    <a href="https://weibo.com/u/6885584679" class="tooltipped" target="_blank" data-tooltip="关注我的微博: https://weibo.com/u/6885584679" data-position="top" data-delay="50">
        <i class="fab fa-weibo"></i>
    </a>



    <a href="https://www.zhihu.com/people/8f8482f01f0d6a04e844efe32e0f0710" class="tooltipped" target="_blank" data-tooltip="关注我的知乎: https://www.zhihu.com/people/8f8482f01f0d6a04e844efe32e0f0710" data-position="top" data-delay="50">
        <i class="fab fa-zhihu1">知</i>
    </a>



</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/js/search.js"></script>
<script type="text/javascript">
$(function () {
    searchFunc("https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/" + "search.xml", 'searchInput', 'searchResult');
});
</script>
    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/materialize/materialize.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/aos/aos.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/js/matery.js"></script>

    <canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" ></canvas>
    <script type="text/javascript" src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script>
    <script type="text/javascript" src="/js/fireworks.js"></script>

    <script type="text/javascript">
        //只在桌面版网页启用特效
        var windowWidth = $(window).width();
        if (windowWidth > 768) {
            document.write('<script type="text/javascript" src="/js/sakura.js"><\/script>'); }
    </script>

    <!-- weather -->
	<script type="text/javascript">
	WIDGET = {FID: 'TToslpmkVO'}
	</script>
	<script type="text/javascript" src="https://apip.weatherdt.com/float/static/js/r.js?v=1111"></script>


    <!-- Global site tag (gtag.js) - Google Analytics -->


    <!-- Baidu Analytics -->

<script>
    var _hmt = _hmt || [];
    (function () {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
    })();
</script>

    <!-- Baidu Push -->

    
    
    <script async src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/others/busuanzi.pure.mini.js"></script>
    

    
        <script src="//code.tidio.co/kqhlkxviiccyoa0czpfpu4ijuey9hfre.js"></script>
        <script> 
            $(document).ready(function () {
                setInterval(change_Tidio, 50);  
                function change_Tidio() { 
                    var tidio=$("#tidio-chat iframe");
                    if(tidio.css("display")=="block"&& $(window).width()>977 ){
                        document.getElementById("tidio-chat-iframe").style.bottom= ($("div#backTop.top-scroll").css("display")=="none" &&$(window).width()>977)>0? "-40px" : ($("div.toc-title").length&&$(window).width()>977)>0?"85px":"20px";   
                        document.getElementById("tidio-chat-iframe").style.right="-15px";   
                        document.getElementById("tidio-chat-iframe").style.height=parseInt(tidio.css("height"))>=520?"520px":tidio.css("height");
                        document.getElementById("tidio-chat-iframe").style.zIndex="997";
                    } 
                    else if(tidio.css("display")=="block"&&$(window).width()>601 &&$(window).width()<992 ){
                        document.getElementById("tidio-chat-iframe").style.bottom= ($("div#backTop.top-scroll").css("display")=="none" && 601< $(window).width()<992)>0? "-40px":"20px" ;   
                        document.getElementById("tidio-chat-iframe").style.right="-15px"; 
                        document.getElementById("tidio-chat-iframe").style.zIndex="997";
                    }
                    else if(tidio.css("display")=="block"&&$(window).width()<601 && parseInt(tidio.css("height"))<230){
                        document.getElementById("tidio-chat-iframe").style.bottom= ($("div#backTop.top-scroll").css("display")=="none" && $(window).width()<601)>0? "-10px":"45px" ;   
                        document.getElementById("tidio-chat-iframe").style.zIndex="997";
                    }
                    if( tidio.css("display")=="block"&&$(window).width()<601 && parseInt(tidio.css("height"))>=230){
                        document.getElementById("tidio-chat-iframe").style.zIndex="998";
                    }
                } 
            }); 
        </script>
    

    

    
    <script type="text/javascript" color="0,0,255"
        pointColor="0,0,255" opacity='0.7'
        zIndex="-1" count="99"
        src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/background/canvas-nest.js"></script>
    

    

    
    <script type="text/javascript" src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/background/ribbon-dynamic.js" async="async"></script>
    
    
    
    <script src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/instantpage/instantpage.js" type="module"></script>
    

        <script src="//cdn.jsdelivr.net/npm/js-base64/base64.min.js"></script>
        <script>
        $('a').each(function() {
          const $this = $(this);
          const href = $this.attr('href');
          if (href && href.match('^((http|https|thunder|qqdl|ed2k|Flashget|qbrowser|ftp|rtsp|mms)://)')) {
            const strs = href.split('/');
            if (strs.length >= 3) {
                const host = strs[2];
                if (host !== 'your_domain' || window.location.host) {
                    $this.attr('href', '/go.html?u='+Base64.encode(href)+'').attr('rel', 'external nofollow noopener noreferrer');
                    if (true) {
                        $this.attr('target', '_blank');
                    }
                }
            }
          }
        });
        </script><script>!function(e){var c=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));function i(){for(var r=0;r<c.length;r++)t=c[r],0<=(n=t.getBoundingClientRect()).bottom&&0<=n.left&&n.top<=(e.innerHeight||document.documentElement.clientHeight)&&function(){var t,n,e,i,o=c[r];t=o,n=function(){c=c.filter(function(t){return o!==t})},e=new Image,i=t.getAttribute("data-original"),e.onload=function(){t.src=i,n&&n()},e.src=i}();var t,n}i(),e.addEventListener("scroll",function(){var t,n;t=i,n=e,clearTimeout(t.tId),t.tId=setTimeout(function(){t.call(n)},500)})}(this);</script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script></body>

</html>

