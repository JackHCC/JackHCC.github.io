<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="Python-Standard Library, JackHCC">
    <meta name="description" content="Python标准库详解【1】">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Python-Standard Library | JackHCC</title>
    <link rel="icon" type="image/png" href="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/medias/favicon.png">

    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/css/matery.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/css/my.css">
    
    <script src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/jquery/jquery.min.js"></script>
    
<meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="JackHCC" type="application/atom+xml">
<link rel="stylesheet" href="/css/prism-hopscotch.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper head-container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/medias/me.jpg" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">JackHCC</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="" class="waves-effect waves-light">

      
      <i class="fas fa-list" style="zoom: 0.6;"></i>
      
      <span>Tools</span>
      <i class="fas fa-chevron-down" aria-hidden="true" style="zoom: 0.6;"></i>
    </a>
    <ul class="sub-nav menus_item_child ">
      
      <li>
        <a href="https://creativecc.cn/" target="_blank" rel="noopener">
          
          <i class="fas fa-book" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>Creative工具导航</span>
        </a>
      </li>
      
      <li>
        <a href="https://blog.creativecc.cn/Arxiv-NLP-Reporter/" target="_blank" rel="noopener">
          
          <i class="fas fa-film" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>NLP每日论文</span>
        </a>
      </li>
      
      <li>
        <a href="http://chat.creativecc.cn/" target="_blank" rel="noopener">
          
          <i class="fas fa-music" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>RocketChat聊天室</span>
        </a>
      </li>
      
      <li>
        <a href="/contact">
          
          <i class="fas fa-comments" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>Contact留言板</span>
        </a>
      </li>
      
    </ul>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>

<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/medias/me.jpg" class="logo-img circle responsive-img">
        
        <div class="logo-name">JackHCC</div>
        <div class="logo-desc">
            
            Make the world betterrrr!!!
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="javascript:;">
			
				<i class="fa-fw fas fa-list"></i>
			
			Tools
			<span class="m-icon"><i class="fas fa-chevron-right"></i></span>
		</a>
            <ul  style="background:  ;" >
              
                <li>   
				
                  <a href="https://creativecc.cn/ " target="_blank" rel="noopener" style="margin-left:75px";>
				  
				   <i class="fa fas fa-book" style="position: absolute;left:50px" ></i>
			      
		          <span>Creative工具导航</span>
                  </a>
                </li>
              
                <li>   
				
                  <a href="https://blog.creativecc.cn/Arxiv-NLP-Reporter/ " target="_blank" rel="noopener" style="margin-left:75px";>
				  
				   <i class="fa fas fa-film" style="position: absolute;left:50px" ></i>
			      
		          <span>NLP每日论文</span>
                  </a>
                </li>
              
                <li>   
				
                  <a href="http://chat.creativecc.cn/ " target="_blank" rel="noopener" style="margin-left:75px";>
				  
				   <i class="fa fas fa-music" style="position: absolute;left:50px" ></i>
			      
		          <span>RocketChat聊天室</span>
                  </a>
                </li>
              
                <li>   
				
                  <a href="/contact " style="margin-left:75px";>
				  
				   <i class="fa fas fa-comments" style="position: absolute;left:50px" ></i>
			      
		          <span>Contact留言板</span>
                  </a>
                </li>
               
            </ul>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/JackHCC/JackHCC.github.io" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>

        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/JackHCC/JackHCC.github.io" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    
<script src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/cryptojs/crypto-js.min.js"></script>
<script>
    (function() {
        let pwd = '';
        if (pwd && pwd.length > 0) {
            if (pwd !== CryptoJS.SHA256(prompt('请输入访问本文章的密码')).toString(CryptoJS.enc.Hex)) {
                alert('密码错误，将返回主页！');
                location.href = '/';
            }
        }
    })();
</script>




<div class="bg-cover pd-header post-cover" style="background-image: url('https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/medias/featureimages/7.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">Python-Standard Library</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        margin: 35px 0 15px 0;
        padding-left: 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        height: calc(100vh - 250px);
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #toc-content .is-active-link::before {
        background-color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 30px;
        bottom: 146px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/Python/">
                                <span class="chip bg-color">Python</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/Language/" class="post-category">
                                Language
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2021-11-03
                </div>
                

                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-check fa-fw"></i>更新日期:&nbsp;&nbsp;
                    2021-11-13
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    194.9k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    774 分
                </div>
                

                
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="far fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>

        </div>
        <hr class="clearfix">
        <div class="card-content article-card-content">
            <div id="articleContent">
                <h1 id="Python-标准库"><a href="#Python-标准库" class="headerlink" title="Python 标准库"></a>Python 标准库</h1><ul>
<li><p>概述</p>
<ul>
<li>可用性注释</li>
</ul>
</li>
<li><p>内置函数</p>
</li>
<li><p>内置常量</p>
<ul>
<li>由 <code>site</code> 模块添加的常量</li>
</ul>
</li>
<li><p>内置类型</p>
<ul>
<li>逻辑值检测</li>
<li>布尔运算 —- <code>and</code>, <code>or</code>, <code>not</code></li>
<li>比较运算</li>
<li>数字类型 —- <code>int</code>, <code>float</code>, <code>complex</code></li>
<li>迭代器类型</li>
<li>序列类型 —- <code>list</code>, <code>tuple</code>, <code>range</code></li>
<li>文本序列类型 —- <code>str</code></li>
<li>二进制序列类型 —- <code>bytes</code>, <code>bytearray</code>, <code>memoryview</code></li>
<li>集合类型 —- <code>set</code>, <code>frozenset</code></li>
<li>映射类型 —- <code>dict</code></li>
<li>上下文管理器类型</li>
<li>Type Annotation Types —- Generic Alias, Union</li>
<li>其他内置类型</li>
<li>特殊属性</li>
</ul>
</li>
<li><p>内置异常</p>
<ul>
<li>基类</li>
<li>具体异常</li>
<li>警告</li>
<li>异常层次结构</li>
</ul>
</li>
<li><p>文本处理服务</p>
<ul>
<li><code>string</code> —- 常见的字符串操作</li>
<li><code>re</code> —- 正则表达式操作</li>
<li><code>difflib</code> —- 计算差异的辅助工具</li>
<li><code>textwrap</code> —- 文本自动换行与填充</li>
<li><code>unicodedata</code> —- Unicode 数据库</li>
<li><code>stringprep</code> —- 因特网字符串预备</li>
<li><code>readline</code> —- GNU readline 接口</li>
<li><code>rlcompleter</code> —- GNU readline 的补全函数</li>
</ul>
</li>
<li><p>二进制数据服务</p>
<ul>
<li><code>struct</code> —- 将字节串解读为打包的二进制数据</li>
<li><code>codecs</code> —- 编解码器注册和相关基类</li>
</ul>
</li>
<li><p>数据类型</p>
<ul>
<li><code>datetime</code> —- 基本日期和时间类型</li>
<li><code>zoneinfo</code> —- IANA 时区支持</li>
<li><code>calendar</code> —- 日历相关函数</li>
<li><code>collections</code> —- 容器数据类型</li>
<li><code>collections.abc</code> —- 容器的抽象基类</li>
<li><code>heapq</code> —- 堆队列算法</li>
<li><code>bisect</code> —- 数组二分查找算法</li>
<li><code>array</code> —- 高效的数值数组</li>
<li><code>weakref</code> —- 弱引用</li>
<li><code>types</code> —- 动态类型创建和内置类型名称</li>
<li><code>copy</code> —- 浅层 (shallow) 和深层 (deep) 复制操作</li>
<li><code>pprint</code> —- 数据美化输出</li>
<li><code>reprlib</code> —- 另一种 <code>repr()</code> 实现</li>
<li><code>enum</code> —- 对枚举的支持</li>
<li><code>graphlib</code> —- 操作类似图的结构的功能</li>
</ul>
</li>
<li><p>数字和数学模块</p>
<ul>
<li><p><code>numbers</code> —- 数字的抽象基类</p>
</li>
<li><p><code>math</code> —- 数学函数</p>
</li>
<li><p><code>cmath</code> —- 关于复数的数学函数</p>
</li>
<li><p><code>decimal</code> —- 十进制定点和浮点运算</p>
</li>
<li><p><code>fractions</code> —- 分数</p>
</li>
<li><p><code>random</code> —- 生成伪随机数</p>
</li>
<li><p><code>statistics</code> —- 数学统计函数</p>
</li>
</ul>
</li>
</ul>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>“Python 库”中包含了几种不同的组件。</p>
<p>它包含通常被视为语言“核心”中的一部分的数据类型，例如数字和列表。对于这些类型，Python语言核心定义了文字的形式，并对它们的语义设置了一些约束，但没有完全定义语义。（另一方面，语言核心确实定义了语法属性，如操作符的拼写和优先级。）</p>
<p>这个库也包含了内置函数和异常 —- 不需要 <code>import</code> 语句就可以在所有Python代码中使用的对象。有一些是由语言核心定义的，但是许多对于核心语义不是必需的，并且仅在这里描述。</p>
<p>不过这个库主要是由一系列的模块组成。这些模块集可以不同方式分类。有些模块是用 C 编写并内置于 Python 解释器中；另一些模块则是用 Python 编写并以源码形式导入。有些模块提供专用于 Python 的接口，例如打印栈追踪信息；有些模块提供专用于特定操作系统的接口，例如操作特定的硬件；另一些模块则提供针对特定应用领域的接口，例如万维网。有些模块在所有更新和移植版本的 Python 中可用；另一些模块仅在底层系统支持或要求时可用；还有些模块则仅当编译和安装 Python 时选择了特定配置选项时才可用。</p>
<h1 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h1><p>Python 解释器内置了很多函数和类型，任何时候都能使用。以下按字母顺序给出列表。</p>
<ul>
<li><code>abs</code>(<em>x</em>)</li>
</ul>
<p>返回一个数的绝对值。 参数可以是整数、浮点数或任何实现了 <code>__abs__()</code> 的对象。 如果参数是一个复数，则返回它的模。</p>
<ul>
<li><code>aiter</code>(<em>async_iterable</em>)</li>
</ul>
<p>返回 asynchronous iterable 的 asynchronous iterator 。相当于调用 <code>x.__aiter__()</code>。</p>
<ul>
<li><code>aiter(x)</code> 本身带有 <code>__aiter__()</code> 方法，返回 <code>x</code>，所以 <code>aiter(aiter(x))</code> 与 <code>aiter(x)</code> 相同。</li>
</ul>
<p>注意：与 <code>iter()</code> 不同，<code>aiter()</code> 没有两个参数的版本。</p>
<p>3.10 新版功能.</p>
<ul>
<li><code>all</code>(<em>iterable</em>)</li>
</ul>
<p>如果 <em>iterable</em> 的所有元素均为真值（或可迭代对象为空）则返回 <code>True</code> 。 等价于：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">all</span><span class="token punctuation">(</span>iterable<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">for</span> element <span class="token keyword">in</span> iterable<span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token operator">not</span> element<span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token boolean">False</span>
    <span class="token keyword">return</span> <span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li><em>awaitable</em> <code>anext</code>(<em>async_iterator</em>[, <em>default</em>])</li>
</ul>
<p>当进入 await 状态时，从给定 asynchronous iterator 返回下一数据项，迭代完毕则返回 <em>default</em>。</p>
<p>这是内置函数 <code>next()</code> 的异步版本，类似于：</p>
<p>调用 <em>async_iterator</em> 的 <code>__anext__()</code> 方法，返回一个 awaitable。等待返回迭代器的下一个值。若有给出 <em>default</em>，则在迭代完毕后会返回给出的值，否则会触发 <code>StopAsyncIteration</code>。</p>
<p>3.10 新版功能.</p>
<ul>
<li><code>any</code>(<em>iterable</em>)</li>
</ul>
<p>如果 <em>iterable</em> 的任一元素为真值则返回 <code>True</code>。 如果可迭代对象为空，返回 <code>False</code>。 等价于:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">any</span><span class="token punctuation">(</span>iterable<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">for</span> element <span class="token keyword">in</span> iterable<span class="token punctuation">:</span>
        <span class="token keyword">if</span> element<span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token boolean">True</span>
    <span class="token keyword">return</span> <span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li><code>ascii</code>(<em>object</em>)</li>
</ul>
<p>与 <code>repr()</code> 类似，返回一个字符串，表示对象的可打印形式，但在 <code>repr()</code> 返回的字符串中，非 ASCII 字符会用 <code>\x</code>、<code>\u</code> 和 <code>\U</code> 进行转义。生成的字符串类似于 Python 2 中 <code>repr()</code> 的返回结果。</p>
<ul>
<li><code>bin</code>(<em>x</em>)</li>
</ul>
<p>将整数转变为以“0b”前缀的二进制字符串。结果是一个合法的 Python 表达式。如果 <em>x</em> 不是 Python 的 <code>int</code> 对象，它必须定义 <code>__index__()</code> 方法，以便返回整数值。下面是一些例子：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> bin<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>
<span class="token string">'0b11'</span>
<span class="token operator">>></span><span class="token operator">></span> bin<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">10</span><span class="token punctuation">)</span>
<span class="token string">'-0b1010'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>若要控制是否显示前缀“0b”，可以采用以下两种方案：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> format<span class="token punctuation">(</span><span class="token number">14</span><span class="token punctuation">,</span><span class="token string">'#b'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> format<span class="token punctuation">(</span><span class="token number">14</span><span class="token punctuation">,</span><span class="token string">'b'</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token string">'0b1110'</span><span class="token punctuation">,</span><span class="token string">'1110'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> f<span class="token string">'{14:#b}'</span><span class="token punctuation">,</span> f<span class="token string">'{14:b}'</span>
<span class="token punctuation">(</span><span class="token string">'0b1110'</span><span class="token punctuation">,</span><span class="token string">'1110'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>另见 <code>format()</code> 获取更多信息。</p>
<ul>
<li><em>class</em> <code>bool</code>([<em>x</em>])</li>
</ul>
<p>返回布尔值，<code>True</code> 或 <code>False</code>。<em>x</em> 用标准的 真值测试过程 进行转换。如果 <em>x</em> 为 False 或省略，则返回 <code>False</code>；否则返回 <code>True</code>。 <code>bool</code> 类是 <code>int</code> 的子类。它不能再被继承。它唯一的实例就是 <code>False</code> 和 <code>True</code> 。</p>
<p>在 3.7 版更改: <em>x</em> 现在只能作为位置参数。</p>
<ul>
<li><code>breakpoint</code>(<em>\</em>args<em>,</em> <em>*kws</em>)</li>
</ul>
<p>此函数会在调用时将你陷入调试器中。具体来说，它调用 <code>sys.breakpointhook()</code> ，直接传递 <code>args</code> 和 <code>kws</code> 。默认情况下， <code>sys.breakpointhook()</code> 调用 <code>pdb.set_trace()</code> 且没有参数。在这种情况下，它纯粹是一个便利函数，因此您不必显式导入 <code>pdb</code> 且键入尽可能少的代码即可进入调试器。但是， <code>sys.breakpointhook()</code> 可以设置为其他一些函数并被 <code>breakpoint()</code> 自动调用，以允许进入你想用的调试器。</p>
<p>引发一个 审计事件<code>builtins.breakpoint</code> 并附带参数 <code>breakpointhook</code>。</p>
<p>3.7 新版功能.</p>
<ul>
<li><em>class</em> <code>bytearray</code>([<em>source</em>[, <em>encoding</em>[, <em>errors</em>]]])</li>
</ul>
<p>返回一个新的 bytes 数组。 <code>bytearray</code> 类是一个可变序列，包含范围为 0 &lt;= x &lt; 256 的整数。它有可变序列大部分常见的方法，见 可变序列类型 的描述；同时有 <code>bytes</code> 类型的大部分方法。</p>
<p>可选形参 <em>source</em> 可以用不同的方式来初始化数组：</p>
<ul>
<li>如果是一个 <em>string*，您必须提供 *encoding</em> 参数（<em>errors</em> 参数仍是可选的）；<code>bytearray()</code> 会使用 <code>str.encode()</code> 方法来将 string 转变成 bytes。</li>
<li>如果是一个 <em>integer</em>，会初始化大小为该数字的数组，并使用 null 字节填充。</li>
<li>如果是一个遵循 缓冲区接口 的对象，该对象的只读缓冲区将被用来初始化字节数组。</li>
<li>如果是一个 <em>iterable</em> 可迭代对象，它的元素的范围必须是 <code>0 &lt;= x &lt; 256</code> 的整数，它会被用作数组的初始内容。</li>
</ul>
<p>如果没有实参，则创建大小为 0 的数组。</p>
<ul>
<li><em>class</em> <code>bytes</code>([<em>source</em>[, <em>encoding</em>[, <em>errors</em>]]])</li>
</ul>
<p>返回一个新的“bytes”对象，这是一个不可变序列，包含范围为 <code>0 &lt;= x &lt; 256</code> 的整数。<code>bytes</code> 是 <code>bytearray</code> 的不可变版本——带有同样不改变序列的方法，支持同样的索引、切片操作。</p>
<p>因此，构造函数的实参和 <code>bytearray()</code> 相同。</p>
<ul>
<li><code>callable</code>(<em>object</em>)</li>
</ul>
<p>如果参数 <em>object</em> 是可调用的就返回 <code>True</code>，否则返回 <code>False</code>。 如果返回 <code>True</code>，调用仍可能失败，但如果返回 <code>False</code>，则调用 <em>object</em> 将肯定不会成功。 请注意类是可调用的（调用类将返回一个新的实例）；如果实例所属的类有 <code>__call__()</code> 则它就是可调用的。</p>
<p>3.2 新版功能: 这个函数一开始在 Python 3.0 被移除了，但在 Python 3.2 被重新加入。</p>
<ul>
<li><code>chr</code>(<em>i</em>)</li>
</ul>
<p>返回 Unicode 码位为整数 <em>i</em> 的字符的字符串格式。例如，<code>chr(97)</code> 返回字符串 <code>'a'</code>，<code>chr(8364)</code> 返回字符串 <code>'€'</code>。这是 <code>ord()</code> 的逆函数。</p>
<p>实参的合法范围是 0 到 1,114,111（16 进制表示是 0x10FFFF）。如果 <em>i</em> 超过这个范围，会触发 <code>ValueError</code> 异常。</p>
<ul>
<li><code>@classmethod</code></li>
</ul>
<p>把一个方法封装成类方法。</p>
<p>类方法隐含的第一个参数就是类，就像实例方法接收实例作为参数一样。要声明一个类方法，按惯例请使用以下方案：</p>
<pre><code>class C:
@classmethod
def f(cls, arg1, arg2,...):...</code></pre><p><code>@classmethod</code> 这样的形式称为函数的 decorator 。</p>
<p>类方法的调用可以在类上进行 (例如 <code>C.f()</code>) 也可以在实例上进行 (例如 <code>C().f()</code>)。 其所属类以外的类实例会被忽略。 如果类方法在其所属类的派生类上调用，则该派生类对象会被作为隐含的第一个参数被传入。</p>
<p>类方法与 C++ 或 Java 中的静态方法不同。 </p>
<p>在 3.9 版更改: 类方法现在可以包装其他 描述器 例如 <code>property()</code>。</p>
<p>在 3.10 版更改: 类方法现在继承了方法的属性（<code>__module__</code>、<code>__name__</code>、<code>__qualname__</code>、<code>__doc__</code> 和 <code>__annotations__</code>），并拥有一个新的<code>__wrapped__</code> 属性。</p>
<ul>
<li><code>compile</code>(<em>source</em>, <em>filename</em>, <em>mode</em>, <em>flags=0</em>, <em>dont_inherit=False</em>, <em>optimize=- 1</em>)</li>
</ul>
<p>将 <em>source</em> 编译成代码或 AST 对象。代码对象可以被 <code>exec()</code> 或 <code>eval()</code> 执行。<em>source</em> 可以是常规的字符串、字节字符串，或者 AST 对象。</p>
<p><em>filename</em> 实参需要是代码读取的文件名；如果代码不需要从文件中读取，可以传入一些可辨识的值（经常会使用 <code>'&lt;string&gt;'</code>）。</p>
<p><em>mode</em> 实参指定了编译代码必须用的模式。如果 <em>source</em> 是语句序列，可以是 <code>'exec'</code>；如果是单一表达式，可以是 <code>'eval'</code>；如果是单个交互式语句，可以是 <code>'single'</code>。（在最后一种情况下，如果表达式执行结果不是 <code>None</code> 将会被打印出来。）</p>
<p>可选参数 <em>flags</em> 和 <em>dont_inherit</em> 控制应当激活哪个 编译器选项 以及应当允许哪个 future 特性。 如果两者都未提供 (或都为零) 则代码会应用与调用 <code>compile()</code> 的代码相同的旗标来编译。 如果给出了 <em>flags</em> 参数而未给出 <em>dont_inherit</em> (或者为零) 则会在无论如何都将被使用的旗标之外还会额外使用 <em>flags</em> 参数所指定的编译器选项和 future 语句。 如果 <em>dont_inherit</em> 为非零整数，则只使用 <em>flags</em> 参数 — 外围代码中的旗标 (future 特性和编译器选项) 会被忽略。</p>
<p>编译器选项和 future 语句是由比特位来指明的。 比特位可以通过一起按位 OR 来指明多个选项。 指明特定 future 特性所需的比特位可以在 <code>__future__</code> 模块的 <code>_Feature</code> 实例的 <code>compiler_flag</code> 属性中找到。 编译器旗标 可以在 <code>ast</code> 模块中查找带有 <code>PyCF_</code> 前缀的名称。</p>
<p><em>optimize</em> 实参指定编译器的优化级别；默认值 <code>-1</code> 选择与解释器的 <code>-O</code> 选项相同的优化级别。显式级别为 <code>0</code> （没有优化；<code>__debug__</code> 为真）、<code>1</code> （断言被删除， <code>__debug__</code> 为假）或 <code>2</code> （文档字符串也被删除）。</p>
<p>如果编译的源码不合法，此函数会触发 <code>SyntaxError</code> 异常；如果源码包含 null 字节，则会触发 <code>ValueError</code> 异常。</p>
<p>引发一个 审计事件<code>compile</code> 附带参数 <code>source</code>, <code>filename</code>。</p>
<p>注解</p>
<p>在 <code>'single'</code> 或 <code>'eval'</code> 模式编译多行代码字符串时，输入必须以至少一个换行符结尾。 这使 <code>code</code> 模块更容易检测语句的完整性。</p>
<p>警告</p>
<p>在将足够大或者足够复杂的字符串编译成 AST 对象时，Python 解释器有可能因为 Python AST 编译器的栈深度限制而崩溃。</p>
<p>在 3.2 版更改: Windows 和 Mac 的换行符均可使用。而且在 <code>'exec'</code> 模式下的输入不必再以换行符结尾了。另增加了 <em>optimize</em> 参数。</p>
<p>在 3.5 版更改: 之前 <em>source</em> 中包含 null 字节的话会触发 <code>TypeError</code> 异常。</p>
<p>3.8 新版功能: <code>ast.PyCF_ALLOW_TOP_LEVEL_AWAIT</code> 现在可在旗标中传入以启用对最高层级 <code>await</code>, <code>async for</code> 和 <code>async with</code> 的支持。</p>
<ul>
<li><em>class<em><code>complex</code>([</em>real</em>[, <em>imag</em>]])</li>
</ul>
<p>返回值为 <em>real</em> + <em>imag</em>j 的复数，或将字符串或数字转换为复数。如果第一个形参是字符串，则它被解释为一个复数，并且函数调用时必须没有第二个形参。第二个形参不能是字符串。每个实参都可以是任意的数值类型（包括复数）。如果省略了 <em>imag</em>，则默认值为零，构造函数会像 <code>int</code> 和 <code>float</code> 一样进行数值转换。如果两个实参都省略，则返回 <code>0j</code>。</p>
<p>对于一个普通 Python 对象 <code>x</code>，<code>complex(x)</code> 会委托给 <code>x.__complex__()</code>。 如果 <code>__complex__()</code> 未定义则将回退至 <code>__float__()</code>。 如果 <code>__float__()</code> 未定义则将回退至 <code>__index__()</code>。</p>
<p>注解</p>
<p>当从字符串转换时，字符串在 <code>+</code> 或 <code>-</code> 的周围必须不能有空格。例如 <code>complex('1+2j')</code> 是合法的，但 <code>complex('1 + 2j')</code> 会触发 <code>ValueError</code> 异常。</p>
<p>在 3.6 版更改: 您可以使用下划线将代码文字中的数字进行分组。</p>
<p>在 3.8 版更改: 如果 <code>__complex__()</code> 和 <code>__float__()</code> 未定义则回退至 <code>__index__()</code>。</p>
<ul>
<li><code>delattr</code>(<em>object</em>, <em>name</em>)</li>
</ul>
<p><code>setattr()</code> 相关的函数。实参是一个对象和一个字符串。该字符串必须是对象的某个属性。如果对象允许，该函数将删除指定的属性。例如 <code>delattr(x, 'foobar')</code> 等价于 <code>del x.foobar</code> 。</p>
<ul>
<li><em>class<em><code>dict</code>(</em>**kwarg</em>)*</li>
<li>class<em><code>dict</code>(*mapping</em>, <em>**kwarg</em>)</li>
</ul>
<ul>
<li>class<em><code>dict</code>(*iterable</em>, <em>**kwarg</em>)</li>
</ul>
<p>创建一个新的字典。<code>dict</code> 对象是一个字典类。</p>
<ul>
<li><code>dir</code>([<em>object</em>])</li>
</ul>
<p>如果没有实参，则返回当前本地作用域中的名称列表。如果有实参，它会尝试返回该对象的有效属性列表。</p>
<p>如果对象有一个名为 <code>__dir__()</code> 的方法，那么该方法将被调用，并且必须返回一个属性列表。这允许实现自定义 <code>__getattr__()</code> 或 <code>__getattribute__()</code> 函数的对象能够自定义 <code>dir()</code> 来报告它们的属性。</p>
<p>如果对象未提供 <code>__dir__()</code> 方法，该函数会尽量从对象的 <code>__dict__</code> 属性和其类型对象中收集信息。得到的列表不一定是完整，如果对象带有自定义 <code>__getattr__()</code> 方法时，结果可能不准确。</p>
<p>默认的 <code>dir()</code> 机制对不同类型的对象行为不同，它会试图返回最相关而不是最全的信息：</p>
<ul>
<li>如果对象是模块对象，则列表包含模块的属性名称。</li>
<li>如果对象是类型或类对象，则列表包含它们的属性名称，并且递归查找所有基类的属性。</li>
<li>否则，列表包含对象的属性名称，它的类属性名称，并且递归查找它的类的所有基类的属性。</li>
</ul>
<p>返回的列表按字母表排序。例如：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span><span class="token keyword">import</span> struct
<span class="token operator">>></span><span class="token operator">></span> dir<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># show the names in the module namespace  </span>
<span class="token punctuation">[</span><span class="token string">'__builtins__'</span><span class="token punctuation">,</span><span class="token string">'__name__'</span><span class="token punctuation">,</span><span class="token string">'struct'</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> dir<span class="token punctuation">(</span>struct<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># show the names in the struct module </span>
<span class="token punctuation">[</span><span class="token string">'Struct'</span><span class="token punctuation">,</span><span class="token string">'__all__'</span><span class="token punctuation">,</span><span class="token string">'__builtins__'</span><span class="token punctuation">,</span><span class="token string">'__cached__'</span><span class="token punctuation">,</span><span class="token string">'__doc__'</span><span class="token punctuation">,</span><span class="token string">'__file__'</span><span class="token punctuation">,</span>
<span class="token string">'__initializing__'</span><span class="token punctuation">,</span><span class="token string">'__loader__'</span><span class="token punctuation">,</span><span class="token string">'__name__'</span><span class="token punctuation">,</span><span class="token string">'__package__'</span><span class="token punctuation">,</span>
<span class="token string">'_clearcache'</span><span class="token punctuation">,</span><span class="token string">'calcsize'</span><span class="token punctuation">,</span><span class="token string">'error'</span><span class="token punctuation">,</span><span class="token string">'pack'</span><span class="token punctuation">,</span><span class="token string">'pack_into'</span><span class="token punctuation">,</span>
<span class="token string">'unpack'</span><span class="token punctuation">,</span><span class="token string">'unpack_from'</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">Shape</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">def</span> __dir__<span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">return</span><span class="token punctuation">[</span><span class="token string">'area'</span><span class="token punctuation">,</span><span class="token string">'perimeter'</span><span class="token punctuation">,</span><span class="token string">'location'</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> s <span class="token operator">=</span>Shape<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> dir<span class="token punctuation">(</span>s<span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token string">'area'</span><span class="token punctuation">,</span><span class="token string">'location'</span><span class="token punctuation">,</span><span class="token string">'perimeter'</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>注解</p>
<p>因为 <code>dir()</code> 主要是为了便于在交互式时使用，所以它会试图返回人们感兴趣的名字集合，而不是试图保证结果的严格性或一致性，它具体的行为也可能在不同版本之间改变。例如，当实参是一个类时，metaclass 的属性不包含在结果列表中。</p>
<ul>
<li><code>divmod</code>(<em>a</em>, <em>b</em>)</li>
</ul>
<p>以两个（非复数）数字为参数，在作整数除法时，返回商和余数。若操作数为混合类型，则适用二进制算术运算符的规则。对于整数而言，结果与 <code>(a // b, a % b)</code> 相同。对于浮点数则结果为<code>(q, a % b)</code>，其中 <em>q</em> 通常为 <code>math.floor(a / b)</code>，但可能比它小 1。在任何情况下，<code>q * b + a % b</code> 都非常接近 <em>a</em>，如果 <code>a % b</code> 非零，则结果符号与 <em>b</em> 相同，并且 <code>0 &lt;= abs(a % b) &lt; abs(b)</code>。</p>
<ul>
<li><code>enumerate</code>(<em>iterable</em>, <em>start=0</em>)</li>
</ul>
<p>返回一个枚举对象。<em>iterable</em> 必须是一个序列，或 iterator，或其他支持迭代的对象。 <code>enumerate()</code> 返回的迭代器的 <code>__next__()</code> 方法返回一个元组，里面包含一个计数值（从 <em>start</em> 开始，默认为 0）和通过迭代 <em>iterable</em> 获得的值。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> seasons <span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">'Spring'</span><span class="token punctuation">,</span><span class="token string">'Summer'</span><span class="token punctuation">,</span><span class="token string">'Fall'</span><span class="token punctuation">,</span><span class="token string">'Winter'</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> list<span class="token punctuation">(</span>enumerate<span class="token punctuation">(</span>seasons<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token string">'Spring'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">'Summer'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token string">'Fall'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token string">'Winter'</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> list<span class="token punctuation">(</span>enumerate<span class="token punctuation">(</span>seasons<span class="token punctuation">,</span> start<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">'Spring'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token string">'Summer'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token string">'Fall'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token string">'Winter'</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>等价于:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">enumerate</span><span class="token punctuation">(</span>sequence<span class="token punctuation">,</span> start<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    n <span class="token operator">=</span> start
<span class="token keyword">for</span> elem <span class="token keyword">in</span> sequence<span class="token punctuation">:</span>
    <span class="token keyword">yield</span> n<span class="token punctuation">,</span> elem
    n <span class="token operator">+=</span><span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li><code>eval</code>(<em>expression</em>[, <em>globals</em>[, <em>locals</em>]])</li>
</ul>
<p>实参是一个字符串，以及可选的 globals 和 locals。<em>globals</em> 实参必须是一个字典。<em>locals</em> 可以是任何映射对象。</p>
<p>表达式解析参数 <em>expression</em> 并作为 Python 表达式进行求值（从技术上说是一个条件列表），采用 <em>globals</em> 和 <em>locals</em> 字典作为全局和局部命名空间。 如果存在 <em>globals</em> 字典，并且不包含 <code>__builtins__</code> 键的值，则在解析 <em>expression</em> 之前会插入以该字符串为键以对内置模块 <code>builtins</code> 的字典的引用为值的项。 这样就可以在将 <em>globals</em> 传给 <code>eval()</code> 之前通过向其传入你自己的 <code>__builtins__</code> 字典来控制可供被执行代码可以使用哪些内置模块。 如果 <em>locals</em> 字典被省略则它默认为 <em>globals</em> 字典。 如果两个字典都被省略，则将使用调用 <code>eval()</code> 的环境中的 <em>globals</em> 和 <em>locals</em> 来执行该表达式。 注意，<em>eval()</em> 无法访问闭包环境中的 嵌套作用域 (非局部变量)。</p>
<p>返回值就是表达式的求值结果。 语法错误将作为异常被报告。 例如：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> x <span class="token operator">=</span><span class="token number">1</span>
<span class="token operator">>></span><span class="token operator">></span>eval<span class="token punctuation">(</span><span class="token string">'x+1'</span><span class="token punctuation">)</span>
<span class="token number">2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>该函数还可用于执行任意代码对象（比如由 <code>compile()</code> 创建的对象）。 这时传入的是代码对象，而非一个字符串了。如果代码对象已用参数为 <em>mode</em> 的 <code>'exec'</code> 进行了编译，那么 <code>eval()</code> 的返回值将为 <code>None</code>。</p>
<p>提示： <code>exec()</code> 函数支持语句的动态执行。 <code>globals()</code> 和 <code>locals()</code> 函数分别返回当前的全局和本地字典，可供传给 <code>eval()</code> 或 <code>exec()</code> 使用。</p>
<p>如果给出的源数据是个字符串，那么其前后的空格和制表符将被剔除。</p>
<p>引发一个 审计事件<code>exec</code> 附带参数 <code>code_object</code>。</p>
<ul>
<li><code>exec</code>(<em>object</em>[, <em>globals</em>[, <em>locals</em>]])</li>
</ul>
<p>这个函数支持动态执行 Python 代码。 <em>object</em> 必须是字符串或者代码对象。 如果是字符串，那么该字符串将被解析为一系列 Python 语句并执行（除非发生语法错误）。 如果是代码对象，它将被直接执行。 在任何情况下，被执行的代码都应当是有效的文件输入（见参考手册中的“文件输入”一节）。 请注意即使在传递给 <code>exec()</code> 函数的代码的上下文中，<code>nonlocal</code>, <code>yield</code> 和 <code>return</code> 语句也不能在函数定义以外使用。 该函数的返回值是 <code>None</code>。</p>
<p>无论在什么情况下，如果省略了可选部分，代码将运行于当前作用域中。如果只提供了 <em>globals*，则必须为字典对象（而不能是字典的子类），同时用于存放全局变量和局部变量。如果提供了 *globals</em> 和 <em>locals<em>，则将分别用于全局变量和局部变量。</em>locals</em> 可以是任意字典映射对象。请记住，在模块级别，globals 和 locals 是同一个字典。如果 exec 获得两个独立的对象作为 <em>globals</em> 和 <em>locals</em>，代码执行起来就像嵌入到某个类定义中一样。</p>
<p>如果 <em>globals</em> 字典不包含 <code>__builtins__</code> 键值，则将为该键插入对内建 <code>builtins</code> 模块字典的引用。因此，在将执行的代码传递给 <code>exec()</code> 之前，可以通过将自己的 <code>__builtins__</code> 字典插入到 <em>globals</em> 中来控制可以使用哪些内置代码。</p>
<p>引发一个 审计事件<code>exec</code> 附带参数 <code>code_object</code>。</p>
<p>注解</p>
<p>内置 <code>globals()</code> 和 <code>locals()</code> 函数各自返回当前的全局和本地字典，因此可以将它们传递给 <code>exec()</code> 的第二个和第三个实参。</p>
<p>注解</p>
<p>默认情况下，<em>locals</em> 的行为如下面 <code>locals()</code> 函数描述的一样：不要试图改变默认的 <em>locals</em> 字典。如果您想在 <code>exec()</code> 函数返回时知道代码对 <em>locals</em> 的变动，请明确地传递 <em>locals</em> 字典。</p>
<ul>
<li><code>filter</code>(<em>function</em>, <em>iterable</em>)</li>
</ul>
<p>用 <em>iterable</em> 中函数 <em>function</em> 返回真的那些元素，构建一个新的迭代器。<em>iterable</em> 可以是一个序列，一个支持迭代的容器，或一个迭代器。如果 <em>function</em> 是 <code>None</code> ，则会假设它是一个身份函数，即 <em>iterable</em> 中所有返回假的元素会被移除。</p>
<p>请注意， <code>filter(function, iterable)</code> 相当于一个生成器表达式，当 function 不是 <code>None</code> 的时候为 <code>(item for item in iterable if function(item))</code>；function 是 <code>None</code> 的时候为 <code>(item for item in iterable if item)</code> 。</p>
<p>请参阅 <code>itertools.filterfalse()</code> 了解，只有 <em>function</em> 返回 false 时才选取 <em>iterable</em> 中元素的补充函数。</p>
<ul>
<li><em>class</em> <code>float</code>([<em>x</em>])</li>
</ul>
<p>返回从数字或字符串 <em>x</em> 生成的浮点数。</p>
<p>如果参数是个字符串，则应包含一个十进制数字，前面可选带上符号，也可选前后带有空白符。符号可以是<code>‘+’</code> 或 <code>'-'</code>；<code>'+'</code> 符号对值没有影响。参数也可以是一个代表 NaN（非数字）或正负无穷大的字符串。更确切地说，在去除前导和尾部的空白符后，输入参数必须符合以下语法：</p>
<pre><code>sign          ::="+"|"-"
infinity      ::="Infinity"|"inf"
nan           ::="nan"
numeric_value ::=floatnumber|infinity|nan
numeric_string::=[sign]numeric_value</code></pre><p>这里的 <code>floatnumber</code> 是指 Python 的浮点数格式，在 浮点数字面值 中有介绍。大小写没有关系，所以“inf”、“Inf”、“INFINITY”、“iNfINity”都可接受为正无穷的拼写形式。</p>
<p>另一方面，如果实参是整数或浮点数，则返回具有相同值（在 Python 浮点精度范围内）的浮点数。如果实参在 Python 浮点精度范围外，则会触发 <code>OverflowError</code>。</p>
<p>对于一个普通 Python 对象 <code>x</code>，<code>float(x)</code> 会委托给 <code>x.__float__()</code>。 如果 <code>__float__()</code> 未定义则将回退至 <code>__index__()</code>。</p>
<p>如果没有实参，则返回 <code>0.0</code> 。</p>
<p>示例:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span>float<span class="token punctuation">(</span><span class="token string">'+1.23'</span><span class="token punctuation">)</span>
<span class="token number">1.23</span>
<span class="token operator">>></span><span class="token operator">></span>float<span class="token punctuation">(</span><span class="token string">'   -12345\n'</span><span class="token punctuation">)</span>
<span class="token operator">-</span><span class="token number">12345.0</span>
<span class="token operator">>></span><span class="token operator">></span>float<span class="token punctuation">(</span><span class="token string">'1e-003'</span><span class="token punctuation">)</span>
<span class="token number">0.001</span>
<span class="token operator">>></span><span class="token operator">></span>float<span class="token punctuation">(</span><span class="token string">'+1E6'</span><span class="token punctuation">)</span>
<span class="token number">1000000.0</span>
<span class="token operator">>></span><span class="token operator">></span>float<span class="token punctuation">(</span><span class="token string">'-Infinity'</span><span class="token punctuation">)</span>
<span class="token operator">-</span>inf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在 3.6 版更改: 您可以使用下划线将代码文字中的数字进行分组。</p>
<p>在 3.7 版更改: <em>x</em> 现在只能作为位置参数。</p>
<p>在 3.8 版更改: 如果 <code>__float__()</code> 未定义则回退至 <code>__index__()</code>。</p>
<ul>
<li><code>format</code>(<em>value</em>[, <em>format_spec</em>])</li>
</ul>
<p>将 <em>value</em> 转换为“格式化后”的形式，格式由 <em>format_spec</em> 进行控制。<em>format_spec</em> 的解释方式取决于 <em>value</em> 参数的类型；但大多数内置类型使用一种标准的格式化语法： 格式规格迷你语言。</p>
<p>默认的 <em>format_spec</em> 是一个空字符串，它通常给出与调用 <code>str(value)</code> 相同的结果。</p>
<p>调用 <code>format(value, format_spec)</code> 会转换成 <code>type(value).__format__(value, format_spec)</code> ，所以实例字典中的 <code>__format__()</code> 方法将不会调用。如果方法搜索回退到 <code>object</code> 类但 <em>format_spec</em> 不为空，或者如果 <em>format_spec</em> 或返回值不是字符串，则会触发 <code>TypeError</code> 异常。</p>
<p>在 3.4 版更改: 当 <em>format_spec</em> 不是空字符串时， <code>object().__format__(format_spec)</code> 会触发 <code>TypeError</code>。</p>
<ul>
<li><em>class</em> <code>frozenset</code>([<em>iterable</em>])</li>
</ul>
<p>返回一个新的 <code>frozenset</code> 对象，它包含可选参数 <em>iterable</em> 中的元素。 <code>frozenset</code> 是一个内置的类。</p>
<ul>
<li><code>getattr</code>(<em>object</em>, <em>name</em>[, <em>default</em>])</li>
</ul>
<p>返回对象命名属性的值。<em>name</em> 必须是字符串。如果该字符串是对象的属性之一，则返回该属性的值。例如， <code>getattr(x, 'foobar')</code> 等同于 <code>x.foobar</code>。如果指定的属性不存在，且提供了 <em>default</em> 值，则返回它，否则触发 <code>AttributeError</code>。</p>
<p>注解</p>
<p>由于 私有名称混合 发生在编译时，因此必须 手动混合私有属性（以两个下划线打头的属性）名称以使使用 <code>getattr()</code> 来提取它。</p>
<ul>
<li><code>globals</code>()</li>
</ul>
<p>返回表示当前全局符号表的字典。这总是当前模块的字典（在函数或方法中，不是调用它的模块，而是定义它的模块）。</p>
<ul>
<li><code>hasattr</code>(<em>object</em>, <em>name</em>)</li>
</ul>
<p>该实参是一个对象和一个字符串。如果字符串是对象的属性之一的名称，则返回 <code>True</code>，否则返回 <code>False</code>。（此功能是通过调用 <code>getattr(object, name)</code> 看是否有 <code>AttributeError</code> 异常来实现的。）</p>
<ul>
<li><code>hash</code>(<em>object</em>)</li>
</ul>
<p>返回该对象的哈希值（如果它有的话）。哈希值是整数。它们在字典查找元素时用来快速比较字典的键。相同大小的数字变量有相同的哈希值（即使它们类型不同，如 1 和 1.0）。</p>
<p>注解</p>
<p>如果对象实现了自己的 <code>__hash__()</code> 方法，请注意，<code>hash()</code> 根据机器的字长来截断返回值。</p>
<ul>
<li><code>help</code>([<em>object</em>])</li>
</ul>
<p>启动内置的帮助系统（此函数主要在交互式中使用）。如果没有实参，解释器控制台里会启动交互式帮助系统。如果实参是一个字符串，则在模块、函数、类、方法、关键字或文档主题中搜索该字符串，并在控制台上打印帮助信息。如果实参是其他任意对象，则会生成该对象的帮助页。</p>
<p>请注意，如果在调用 <code>help()</code> 时，目标函数的形参列表中存在斜杠（/），则意味着斜杠之前的参数只能是位置参数。</p>
<p>该函数通过 <code>site</code> 模块加入到内置命名空间。</p>
<p>在 3.4 版更改: <code>pydoc</code> 和 <code>inspect</code> 的变更使得可调用对象的签名信息更加全面和一致。</p>
<ul>
<li><code>hex</code>(<em>x</em>)</li>
</ul>
<p>将整数转换为以“0x”为前缀的小写十六进制字符串。如果 <em>x</em> 不是 Python <code>int</code> 对象，则必须定义返回整数的 <code>__index__()</code> 方法。一些例子：</p>
<pre><code>&gt;&gt;&gt; hex(255)
'0xff'
&gt;&gt;&gt; hex(-42)
'-0x2a'</code></pre><p>如果要将整数转换为大写或小写的十六进制字符串，并可选择有无“0x”前缀，则可以使用如下方法：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span><span class="token string">'%#x'</span><span class="token operator">%</span><span class="token number">255</span><span class="token punctuation">,</span><span class="token string">'%x'</span><span class="token operator">%</span><span class="token number">255</span><span class="token punctuation">,</span><span class="token string">'%X'</span><span class="token operator">%</span><span class="token number">255</span>
<span class="token punctuation">(</span><span class="token string">'0xff'</span><span class="token punctuation">,</span><span class="token string">'ff'</span><span class="token punctuation">,</span><span class="token string">'FF'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> format<span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">,</span><span class="token string">'#x'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> format<span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">,</span><span class="token string">'x'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> format<span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">,</span><span class="token string">'X'</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token string">'0xff'</span><span class="token punctuation">,</span><span class="token string">'ff'</span><span class="token punctuation">,</span><span class="token string">'FF'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> f<span class="token string">'{255:#x}'</span><span class="token punctuation">,</span> f<span class="token string">'{255:x}'</span><span class="token punctuation">,</span> f<span class="token string">'{255:X}'</span>
<span class="token punctuation">(</span><span class="token string">'0xff'</span><span class="token punctuation">,</span><span class="token string">'ff'</span><span class="token punctuation">,</span><span class="token string">'FF'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>注解</p>
<p>如果要获取浮点数的十六进制字符串形式，请使用 <code>float.hex()</code> 方法。</p>
<ul>
<li><code>id</code>(<em>object</em>)</li>
</ul>
<p>返回对象的“标识值”。该值是一个整数，在此对象的生命周期中保证是唯一且恒定的。两个生命期不重叠的对象可能具有相同的 <code>id()</code> 值。</p>
<p><strong>CPython implementation detail:</strong> This is the address of the object in memory.</p>
<p>引发一个 审计事件<code>builtins.id</code>，附带参数 <code>id</code>。</p>
<ul>
<li><code>input</code>([<em>prompt</em>])</li>
</ul>
<p>如果存在 <em>prompt</em> 实参，则将其写入标准输出，末尾不带换行符。接下来，该函数从输入中读取一行，将其转换为字符串（除了末尾的换行符）并返回。当读取到 EOF 时，则触发 <code>EOFError</code>。例如:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> s <span class="token operator">=</span> input<span class="token punctuation">(</span><span class="token string">'--> '</span><span class="token punctuation">)</span>
<span class="token operator">-</span><span class="token operator">-</span><span class="token operator">></span>MontyPython's Flying Circus
<span class="token operator">>></span><span class="token operator">></span> s  
<span class="token string">"Monty Python's FlyingCircus"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果加载了 <code>readline</code> 模块，<code>input()</code> 将使用它来提供复杂的行编辑和历史记录功能。</p>
<p>引发一个 审计事件<code>builtins.input</code> 附带参数 <code>prompt</code>。</p>
<p>在成功读取输入之后引发一个审计事件 <code>builtins.input/result</code> 附带结果。</p>
<ul>
<li><p><em>class</em> <code>int</code>([<em>x</em>])</p>
</li>
<li><p><em>class</em> <code>int</code>(<em>x</em>, <em>base=10</em>)</p>
</li>
</ul>
<p>返回一个基于数字或字符串 <em>x</em> 构造的整数对象，或者在未给出参数时返回 <code>0</code>。 如果 <em>x</em> 定义了 <code>__int__()</code>，<code>int(x)</code> 将返回 <code>x.__int__()</code>。 如果 <em>x</em> 定义了 <code>__index__()</code>，它将返回 <code>x.__index__()</code>。 如果 <em>x</em> 定义了 <code>__trunc__()</code>，它将返回 <code>x.__trunc__()</code>。 对于浮点数，它将向零舍入。</p>
<p>如果 <em>x</em> 不是数字，或者有 <em>base</em> 参数，<em>x</em> 必须是字符串、<code>bytes</code>、表示进制为 <em>base</em> 的 整数字面值 的 <code>bytearray</code> 实例。该文字前可以有 <code>+</code> 或 <code>-</code> （中间不能有空格），前后可以有空格。一个进制为 n 的数字包含 0 到 n-1 的数，其中 <code>a</code> 到 <code>z</code> （或 <code>A</code> 到 <code>Z</code> ）表示 10 到 35。默认的 <em>base</em> 为 10 ，允许的进制有 0、2-36。2、8、16 进制的数字可以在代码中用 <code>0b</code>/<code>0B</code> 、 <code>0o</code>/<code>0O</code> 、 <code>0x</code>/<code>0X</code> 前缀来表示。进制为 0 将安照代码的字面量来精确解释，最后的结果会是 2、8、10、16 进制中的一个。所以 <code>int('010', 0)</code> 是非法的，但 <code>int('010')</code> 和 <code>int('010', 8)</code> 是合法的。</p>
<p>在 3.4 版更改: 如果 <em>base</em> 不是 <code>int</code> 的实例，但 <em>base</em> 对象有 <code>base.__index__</code> 方法，则会调用该方法来获取进制数。以前的版本使用 <code>base.__int__</code> 而不是 <code>base.__index__</code>。</p>
<p>在 3.6 版更改: 您可以使用下划线将代码文字中的数字进行分组。</p>
<p>在 3.7 版更改: <em>x</em> 现在只能作为位置参数。</p>
<p>在 3.8 版更改: 如果 <code>__int__()</code> 未定义则回退至 <code>__index__()</code>。</p>
<ul>
<li><code>isinstance</code>(<em>object</em>, <em>classinfo</em>)</li>
</ul>
<p>如果 <em>object</em> 参数是 <em>classinfo</em> 参数的实例，或其（直接、间接或 virtual ）子类的实例，则返回 <code>True</code>。 如果 <em>object</em> 不是给定类型的对象，则总是返回 <code>False</code>。如果 <em>classinfo</em> 是类型对象的元组（或由该类元组递归生成）或多个类型的 Union Type，那么当 <em>object</em> 是其中任一类型的实例时就会返回 <code>True</code>。如果 <em>classinfo</em> 不是某个类型或类型元组，将会触发 <code>TypeError</code> 异常。</p>
<p>在 3.10 版更改: <em>classinfo</em> 可以是一个 Union Type。</p>
<ul>
<li><code>issubclass</code>(<em>class</em>, <em>classinfo</em>)</li>
</ul>
<p>Return <code>True</code> if <em>class</em> is a subclass (direct, indirect, or virtual) of <em>classinfo</em>. A class is considered a subclass of itself. <em>classinfo</em> may be a tuple of class objects or a Union Type, in which case return <code>True</code> if <em>class</em> is a subclass of any entry in <em>classinfo</em>. In any other case, a <code>TypeError</code> exception is raised.</p>
<p>在 3.10 版更改: <em>classinfo</em> 可以是一个 Union Type。</p>
<ul>
<li><code>iter</code>(<em>object</em>[, <em>sentinel</em>])</li>
</ul>
<p>返回一个 iterator 对象。根据是否存在第二个实参，第一个实参的解释是非常不同的。如果没有第二个实参，<em>object</em> 必须是支持迭代协议（有 <code>__iter__()</code> 方法）的集合对象，或必须支持序列协议（有 <code>__getitem__()</code> 方法，且数字参数从 <code>0</code> 开始）。如果它不支持这些协议，会触发 <code>TypeError</code>。如果有第二个实参 <em>sentinel*，那么 *object</em> 必须是可调用的对象。这种情况下生成的迭代器，每次迭代调用它的 <code>__next__()</code> 方法时都会不带实参地调用 <em>object*；如果返回的结果是 *sentinel</em> 则触发 <code>StopIteration</code>，否则返回调用结果。</p>
<p>适合 <code>iter()</code> 的第二种形式的应用之一是构建块读取器。 例如，从二进制数据库文件中读取固定宽度的块，直至到达文件的末尾:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> functools importpartial
<span class="token keyword">with</span> open<span class="token punctuation">(</span><span class="token string">'mydata.db'</span><span class="token punctuation">,</span><span class="token string">'rb'</span><span class="token punctuation">)</span><span class="token keyword">as</span> f<span class="token punctuation">:</span>
<span class="token keyword">for</span> block <span class="token keyword">in</span> iter<span class="token punctuation">(</span>partial<span class="token punctuation">(</span>f<span class="token punctuation">.</span>read<span class="token punctuation">,</span><span class="token number">64</span><span class="token punctuation">)</span><span class="token punctuation">,</span> b<span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        process_block<span class="token punctuation">(</span>block<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li><code>len</code>(<em>s</em>)</li>
</ul>
<p>返回对象的长度（元素个数）。实参可以是序列（如 string、bytes、tuple、list 或 range 等）或集合（如 dictionary、set 或 frozen set 等）。</p>
<p><strong>CPython implementation detail:</strong><code>len</code> 对于大于 <code>sys.maxsize</code> 的长度如 <code>range(2 ** 100)</code> 会引发 <code>OverflowError</code>。</p>
<ul>
<li><em>class</em><code>list</code>([<em>iterable</em>])</li>
</ul>
<p>虽然被称为函数，<code>list</code> 实际上是一种可变序列类型。</p>
<ul>
<li><code>locals</code>()</li>
</ul>
<p>更新并返回表示当前本地符号表的字典。 在函数代码块但不是类代码块中调用 <code>locals()</code> 时将返回自由变量。 请注意在模块层级上，<code>locals()</code> 和 <code>globals()</code> 是同一个字典。</p>
<p>注解</p>
<p>不要更改此字典的内容；更改不会影响解释器使用的局部变量或自由变量的值。</p>
<ul>
<li><code>map</code>(<em>function</em>, <em>iterable</em>, <em>…</em>)</li>
</ul>
<p>返回一个将 <em>function</em> 应用于 <em>iterable</em> 中每一项并输出其结果的迭代器。 如果传入了额外的 <em>iterable</em> 参数，<em>function</em> 必须接受相同个数的实参并被应用于从所有可迭代对象中并行获取的项。 当有多个可迭代对象时，最短的可迭代对象耗尽则整个迭代就将结束。 对于函数的输入已经是参数元组的情况。</p>
<ul>
<li><p><code>max</code>(<em>iterable</em>, <em>**[,</em> key<em>,</em> default*])</p>
</li>
<li><p><code>max</code>(<em>arg1</em>, <em>arg2</em>, <em>\</em>args<em>[,</em> key*])</p>
</li>
</ul>
<p>返回可迭代对象中最大的元素，或者返回两个及以上实参中最大的。</p>
<p>如果只提供了一个位置参数，它必须是非空 iterable，返回可迭代对象中最大的元素；如果提供了两个及以上的位置参数，则返回最大的位置参数。</p>
<p>有两个可选只能用关键字的实参。<em>key</em> 实参指定排序函数用的参数，如传给 <code>list.sort()</code> 的。<em>default</em> 实参是当可迭代对象为空时返回的值。如果可迭代对象为空，并且没有给 <em>default</em> ，则会触发 <code>ValueError</code>。</p>
<p>如果有多个最大元素，则此函数将返回第一个找到的。这和其他稳定排序工具如 <code>sorted(iterable, key=keyfunc, reverse=True)[0]</code> 和 <code>heapq.nlargest(1, iterable, key=keyfunc)</code> 保持一致。</p>
<p>3.4 新版功能: keyword-only 实参 <em>default</em> 。</p>
<p>在 3.8 版更改: <em>key</em> 可以为 <code>None</code>。</p>
<ul>
<li><em>class</em> <code>memoryview</code>(<em>object</em>)</li>
</ul>
<p>返回由给定实参创建的“内存视图”对象。</p>
<ul>
<li><p><code>min</code>(<em>iterable</em>, <em>**[,</em> key<em>,</em> default*])</p>
</li>
<li><p><code>min</code>(<em>arg1</em>, <em>arg2</em>, <em>\</em>args<em>[,</em> key*])</p>
</li>
</ul>
<p>返回可迭代对象中最小的元素，或者返回两个及以上实参中最小的。</p>
<p>如果只提供了一个位置参数，它必须是 iterable，返回可迭代对象中最小的元素；如果提供了两个及以上的位置参数，则返回最小的位置参数。</p>
<p>有两个可选只能用关键字的实参。<em>key</em> 实参指定排序函数用的参数，如传给 <code>list.sort()</code> 的。<em>default</em> 实参是当可迭代对象为空时返回的值。如果可迭代对象为空，并且没有给 <em>default</em> ，则会触发 <code>ValueError</code>。</p>
<p>如果有多个最小元素，则此函数将返回第一个找到的。这和其他稳定排序工具如 <code>sorted(iterable, key=keyfunc)[0]</code> 和 <code>heapq.nsmallest(1, iterable, key=keyfunc)</code> 保持一致。</p>
<p>3.4 新版功能: keyword-only 实参 <em>default</em> 。</p>
<p>在 3.8 版更改: <em>key</em> 可以为 <code>None</code>。</p>
<ul>
<li><code>next</code>(<em>iterator</em>[, <em>default</em>])</li>
</ul>
<p>通过调用 <em>iterator</em> 的 <code>__next__()</code> 方法获取下一个元素。如果迭代器耗尽，则返回给定的 <em>default</em>，如果没有默认值则触发 <code>StopIteration</code>。</p>
<ul>
<li><em>class</em><code>object</code></li>
</ul>
<p>返回一个不带特征的新对象。<code>object</code> 是所有类的基类。它带有所有 Python 类实例均通用的方法。本函数不接受任何参数。</p>
<p>注解</p>
<p>由于 <code>object</code> 没有 <code>__dict__</code>，因此无法将任意属性赋给 <code>object</code> 的实例。</p>
<ul>
<li><code>oct</code>(<em>x</em>)</li>
</ul>
<p>将一个整数转变为一个前缀为“0o”的八进制字符串。结果是一个合法的 Python 表达式。如果 <em>x</em> 不是 Python 的 <code>int</code> 对象，那它需要定义 <code>__index__()</code> 方法返回一个整数。一些例子：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> oct<span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span>
<span class="token string">'0o10'</span>
<span class="token operator">>></span><span class="token operator">></span> oct<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">56</span><span class="token punctuation">)</span>
<span class="token string">'-0o70'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>若要将整数转换为八进制字符串，并可选择是否带有“0o”前缀，可采用如下方法：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span><span class="token string">'%#o'</span><span class="token operator">%</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token string">'%o'</span><span class="token operator">%</span><span class="token number">10</span>
<span class="token punctuation">(</span><span class="token string">'0o12'</span><span class="token punctuation">,</span><span class="token string">'12'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> format<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token string">'#o'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> format<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token string">'o'</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token string">'0o12'</span><span class="token punctuation">,</span><span class="token string">'12'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> f<span class="token string">'{10:#o}'</span><span class="token punctuation">,</span> f<span class="token string">'{10:o}'</span>
<span class="token punctuation">(</span><span class="token string">'0o12'</span><span class="token punctuation">,</span><span class="token string">'12'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li><code>open</code>(<em>file</em>, <em>mode=’r’</em>, <em>buffering=- 1</em>, <em>encoding=None</em>, <em>errors=None</em>, <em>newline=None</em>, <em>closefd=True</em>, <em>opener=None</em>)</li>
</ul>
<p>打开 <em>file</em> 并返回对应的 file object。 如果该文件不能被打开，则引发 <code>OSError</code>。 </p>
<p><em>file</em> 是一个 path-like object，表示将要打开的文件的路径（绝对路径或者相对当前工作目录的路径），也可以是要封装文件对应的整数类型文件描述符。（如果给出的是文件描述符，则当返回的 I/O 对象关闭时它也会关闭，除非将 <em>closefd</em> 设为 <code>False</code> 。）</p>
<p><em>mode</em> 是可选的字符串，用于指定打开文件的模式。默认值是 <code>'r'</code> ，表示以文本模式打开并读取文件。其他常见模式有：写入模式 <code>'w'</code> （已存在文件会被清空）、独占创建模式 <code>'x'</code> 、追加写入模式 <code>'a'</code> （在 <em>某些</em> Unix 系统中，无论当前文件指针在什么位置，<em>所有</em> 的写入操作都会追加到文件末尾）。在文本模式，如果未指定 <em>encoding</em> ，则会根据当前平台决定编码格式：调用 <code>locale.getpreferredencoding(False)</code> 获取当前地区的编码。若要读写原生字节格式，请使用二进制模式且不要指定 <em>encoding</em>。可用的模式有：</p>
<table>
<thead>
<tr>
<th align="left">字符</th>
<th align="left">含意</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>‘r’</code></td>
<td align="left">读取（默认）</td>
</tr>
<tr>
<td align="left"><code>‘w’</code></td>
<td align="left">写入，并先截断文件</td>
</tr>
<tr>
<td align="left"><code>‘x’</code></td>
<td align="left">排它性创建，如果文件已存在则失败</td>
</tr>
<tr>
<td align="left"><code>‘a’</code></td>
<td align="left">打开文件用于写入，如果文件存在则在末尾追加</td>
</tr>
<tr>
<td align="left"><code>‘b’</code></td>
<td align="left">二进制模式</td>
</tr>
<tr>
<td align="left"><code>‘t’</code></td>
<td align="left">文本模式（默认）</td>
</tr>
<tr>
<td align="left"><code>‘+’</code></td>
<td align="left">打开用于更新（读取与写入）</td>
</tr>
</tbody></table>
<p>默认模式为 <code>'r'</code> （打开文件用于读取文本，与 <code>'rt'</code> 同义）。<code>'w+'</code> 和 <code>'w+b'</code> 模式将打开文件并清空内容。而 <code>'r+'</code> 和 <code>'r+b'</code> 模式将打开文件但不清空内容。</p>
<p>正如在 概述 中提到的，Python区分二进制和文本I/O。以二进制模式打开的文件（包括 <em>mode</em> 参数中的 <code>'b'</code> ）返回的内容为 <code>bytes</code> 对象，不进行任何解码。在文本模式下（默认情况下，或者在 <em>mode</em> 参数中包含 <code>'t'</code> ）时，文件内容返回为 <code>str</code> ，首先使用指定的 <em>encoding</em> （如果给定）或者使用平台默认的的字节编码解码。</p>
<p>另外还有一种模式字符 <code>'U'</code> 可用，不过它已失效，并视作弃用。以前它会在文本模式中启用 universal newlines，这在 Python 3.0 已成为默认行为。详情请参阅 newline 形参的文档。</p>
<p>注解</p>
<p>Python不依赖于底层操作系统的文本文件概念;所有处理都由Python本身完成，因此与平台无关。</p>
<p><em>buffering</em> 是一个可选的整数，用于设置缓冲策略。传递0以切换缓冲关闭（仅允许在二进制模式下），1选择行缓冲（仅在文本模式下可用），并且&gt;1的整数以指示固定大小的块缓冲区的大小（以字节为单位）。如果没有给出 <em>buffering</em> 参数，则默认缓冲策略的工作方式如下:</p>
<ul>
<li>二进制文件以固定大小的块进行缓冲；使用启发式方法选择缓冲区的大小，尝试确定底层设备的“块大小”或使用 <code>io.DEFAULT_BUFFER_SIZE</code>。在许多系统上，缓冲区的长度通常为4096或8192字节。</li>
<li>“交互式”文本文件（ <code>isatty()</code> 返回 <code>True</code> 的文件）使用行缓冲。其他文本文件使用上述策略用于二进制文件。</li>
</ul>
<p><em>encoding</em> 是用于解码或编码文件的编码的名称。这应该只在文本模式下使用。默认编码是依赖于平台的（不 管 <code>locale.getpreferredencoding()</code> 返回何值），但可以使用任何Python支持的 text encoding 。有关支持的编码列表，请参阅 <code>codecs</code> 模块。</p>
<p><em>errors</em> 是一个可选的字符串参数，用于指定如何处理编码和解码错误 - 这不能在二进制模式下使用。可以使用各种标准错误处理程序，但是使用 <code>codecs.register_error()</code> 注册的任何错误处理名称也是有效的。标准名称包括:</p>
<ul>
<li>如果存在编码错误，<code>'strict'</code> 会引发 <code>ValueError</code> 异常。 默认值 <code>None</code> 具有相同的效果。</li>
<li><code>'ignore'</code> 忽略错误。请注意，忽略编码错误可能会导致数据丢失。</li>
<li><code>'replace'</code> 会将替换标记（例如 <code>'?'</code> ）插入有错误数据的地方。</li>
<li><code>'surrogateescape'</code> 将把任何不正确的字节表示为 U+DC80 至 U+DCFF 范围内的下方替代码位。 当在写入数据时使用 <code>surrogateescape</code> 错误处理句柄时这些替代码位会被转回到相同的字节。 这适用于处理具有未知编码格式的文件。</li>
<li>只有在写入文件时才支持 <code>'xmlcharrefreplace'</code>。编码不支持的字符将替换为相应的XML字符引用 <code>&amp;#nnn;</code>。</li>
<li><code>'backslashreplace'</code> 用Python的反向转义序列替换格式错误的数据。</li>
<li><code>'namereplace'</code> （也只在编写时支持）用 <code>\N{...}</code> 转义序列替换不支持的字符。</li>
</ul>
<p><em>newline</em> 控制 universal newlines 模式如何生效（它仅适用于文本模式）。它可以是 <code>None</code>，<code>''</code>，<code>'\n'</code>，<code>'\r'</code> 和 <code>'\r\n'</code>。它的工作原理:</p>
<ul>
<li>从流中读取输入时，如果 <em>newline</em> 为 <code>None</code>，则启用通用换行模式。输入中的行可以以 <code>'\n'</code>，<code>'\r'</code> 或 <code>'\r\n'</code> 结尾，这些行被翻译成 <code>'\n'</code> 在返回呼叫者之前。如果它是 <code>''</code>，则启用通用换行模式，但行结尾将返回给调用者未翻译。如果它具有任何其他合法值，则输入行仅由给定字符串终止，并且行结尾将返回给未调用的调用者。</li>
<li>将输出写入流时，如果 <em>newline</em> 为 <code>None</code>，则写入的任何 <code>'\n'</code> 字符都将转换为系统默认行分隔符 <code>os.linesep</code>。如果 <em>newline</em> 是 <code>''</code> 或 <code>'\n'</code>，则不进行翻译。如果 <em>newline</em> 是任何其他合法值，则写入的任何 <code>'\n'</code> 字符将被转换为给定的字符串。</li>
</ul>
<p>如果 <em>closefd</em> 为 <code>False</code> 且给出的不是文件名而是文件描述符，那么当文件关闭时，底层文件描述符将保持打开状态。如果给出的是文件名，则 <em>closefd</em> 必须为 <code>True</code> （默认值），否则将触发错误。</p>
<p>可以通过传递可调用的 <em>opener</em> 来使用自定义开启器。然后通过使用参数（ <em>file<em>，</em>flags</em> ）调用 <em>opener</em> 获得文件对象的基础文件描述符。 <em>opener</em> 必须返回一个打开的文件描述符（使用 <code>os.open</code> as <em>opener</em> 时与传递 <code>None</code> 的效果相同）。</p>
<p>新创建的文件是 不可继承的。</p>
<p>下面的示例使用 <code>os.open()</code> 函数的 dir_fd 的形参，从给定的目录中用相对路径打开文件:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span><span class="token keyword">import</span> os
<span class="token operator">>></span><span class="token operator">></span> dir_fd <span class="token operator">=</span> os<span class="token punctuation">.</span>open<span class="token punctuation">(</span><span class="token string">'somedir'</span><span class="token punctuation">,</span> os<span class="token punctuation">.</span>O_RDONLY<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span><span class="token keyword">def</span> opener<span class="token punctuation">(</span>path<span class="token punctuation">,</span> flags<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">return</span> os<span class="token punctuation">.</span>open<span class="token punctuation">(</span>path<span class="token punctuation">,</span> flags<span class="token punctuation">,</span> dir_fd<span class="token operator">=</span>dir_fd<span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span><span class="token keyword">with</span> open<span class="token punctuation">(</span><span class="token string">'spamspam.txt'</span><span class="token punctuation">,</span><span class="token string">'w'</span><span class="token punctuation">,</span> opener<span class="token operator">=</span>opener<span class="token punctuation">)</span><span class="token keyword">as</span> f<span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'This will be written to somedir/spamspam.txt'</span><span class="token punctuation">,</span> file<span class="token operator">=</span>f<span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> os<span class="token punctuation">.</span>close<span class="token punctuation">(</span>dir_fd<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># don't leak a file descriptor</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>open()</code> 函数所返回的 file object 类型取决于所用模式。 当使用 <code>open()</code> 以文本模式 (<code>'w'</code>, <code>'r'</code>, <code>'wt'</code>, <code>'rt'</code> 等) 打开文件时，它将返回 <code>io.TextIOBase</code> (特别是 <code>io.TextIOWrapper</code>) 的一个子类。 当使用缓冲以二进制模式打开文件时，返回的类是 <code>io.BufferedIOBase</code> 的一个子类。 具体的类会有多种：在只读的二进制模式下，它将返回 <code>io.BufferedReader</code>；在写入二进制和追加二进制模式下，它将返回 <code>io.BufferedWriter</code>，而在读/写模式下，它将返回 <code>io.BufferedRandom</code>。 当禁用缓冲时，则会返回原始流，即 <code>io.RawIOBase</code> 的一个子类 <code>io.FileIO</code>。</p>
<p>引发一个 审计事件<code>open</code> 附带参数 <code>file</code>, <code>mode</code>, <code>flags</code>。</p>
<p><code>mode</code> 与 <code>flags</code> 参数可以在原始调用的基础上被修改或传递。</p>
<blockquote>
<p>在 3.3 版更改:</p>
<ul>
<li>增加了 <em>opener</em> 形参。</li>
<li>增加了 <code>'x'</code> 模式。</li>
<li>过去触发的 <code>IOError</code>，现在是 <code>OSError</code> 的别名。</li>
<li>如果文件已存在但使用了排它性创建模式（ <code>'x'</code> ），现在会触发 <code>FileExistsError</code>。</li>
</ul>
<p>在 3.4 版更改:</p>
<ul>
<li>文件现在禁止继承。</li>
</ul>
</blockquote>
<p>Deprecated since version 3.4, removed in version 3.10: <code>'U'</code> 模式。</p>
<blockquote>
<p>在 3.5 版更改:</p>
<ul>
<li>如果系统调用被中断，但信号处理程序没有触发异常，此函数现在会重试系统调用，而不是触发 <code>InterruptedError</code> 异常 (原因详见 <a href="https://www.python.org/dev/peps/pep-0475" target="_blank" rel="noopener"><strong>PEP 475</strong></a>)。</li>
<li>增加了 <code>'namereplace'</code> 错误处理接口。</li>
</ul>
<p>在 3.6 版更改:</p>
<ul>
<li>增加对实现了 <code>os.PathLike</code> 对象的支持。</li>
<li>在 Windows 上，打开一个控制台缓冲区将返回 <code>io.RawIOBase</code> 的子类，而不是 <code>io.FileIO</code>。</li>
</ul>
</blockquote>
<ul>
<li><code>ord</code>(<em>c</em>)</li>
</ul>
<p>对表示单个 Unicode 字符的字符串，返回代表它 Unicode 码点的整数。例如 <code>ord('a')</code> 返回整数 <code>97</code>， <code>ord('€')</code> （欧元符号）返回 <code>8364</code> 。这是 <code>chr()</code> 的逆函数。</p>
<ul>
<li><code>pow</code>(<em>base</em>, <em>exp</em>[, <em>mod</em>])</li>
</ul>
<p>返回 <em>base</em> 的 <em>exp</em> 次幂；如果 <em>mod</em> 存在，则返回 <em>base</em> 的 <em>exp</em> 次幂对 <em>mod</em> 取余（比 <code>pow(base, exp) % mod</code> 更高效）。 两参数形式 <code>pow(base, exp)</code> 等价于乘方运算符: <code>base**exp</code>。</p>
<p>The arguments must have numeric types. With mixed operand types, the coercion rules for binary arithmetic operators apply. For <code>int</code> operands, the result has the same type as the operands (after coercion) unless the second argument is negative; in that case, all arguments are converted to float and a float result is delivered. For example, <code>pow(10, 2)</code> returns <code>100</code>, but <code>pow(10, -2)</code> returns <code>0.01</code>.</p>
<p>对于 <code>int</code> 操作数 <em>base</em> 和 <em>exp<em>，如果给出 *mod</em>，则 *mod</em> 必须为整数类型并且 <em>mod</em> 必须不为零。 如果给出 <em>mod</em> 并且 <em>exp</em> 为负值，则 <em>base</em> 必须相对于 <em>mod</em> 不可整除。 在这种情况下，将会返回 <code>pow(inv_base, -exp, mod)</code>，其中 <em>inv_base</em> 为 <em>base</em> 的倒数对 <em>mod</em> 取余。</p>
<p>下面的例子是 <code>38</code> 的倒数对 <code>97</code> 取余:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> pow<span class="token punctuation">(</span><span class="token number">38</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> mod<span class="token operator">=</span><span class="token number">97</span><span class="token punctuation">)</span>
<span class="token number">23</span>
<span class="token operator">>></span><span class="token operator">></span><span class="token number">23</span><span class="token operator">*</span><span class="token number">38</span><span class="token operator">%</span><span class="token number">97</span><span class="token operator">==</span><span class="token number">1</span>
<span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>在 3.8 版更改: 对于 <code>int</code> 操作数，三参数形式的 <code>pow</code> 现在允许第二个参数为负值，即可以计算倒数的余数。</p>
<p>在 3.8 版更改: 允许关键字参数。 之前只支持位置参数。</p>
<ul>
<li><code>print</code>(<em>\</em>objects<em>,</em> sep=’ ‘<em>,</em> end=’\n’<em>,</em> file=sys.stdout<em>,</em> flush=False*)</li>
</ul>
<p>将 <em>objects</em> 打印输出至 <em>file</em> 指定的文本流，以 <em>sep</em> 分隔并在末尾加上 <em>end*。 *sep</em> 、 <em>end</em> 、 <em>file</em> 和 <em>flush</em> 必须以关键字参数的形式给出。</p>
<p>所有非关键字参数都会被转换为字符串，就像是执行了 <code>str()</code> 一样，并会被写入到流，以 <em>sep</em> 且在末尾加上 <em>end*。 *sep</em> 和 <em>end</em> 都必须为字符串；它们也可以为 <code>None</code>，这意味着使用默认值。 如果没有给出 <em>objects</em>，则 <code>print()</code> 将只写入 <em>end</em>。</p>
<p><em>file</em> 参数必须是一个具有 <code>write(string)</code> 方法的对象；如果参数不存在或为 <code>None</code>，则将使用 <code>sys.stdout</code>。 由于要打印的参数会被转换为文本字符串，因此 <code>print()</code> 不能用于二进制模式的文件对象。 对于这些对象，应改用 <code>file.write(...)</code>。</p>
<p>输出是否缓存通常取决于 <em>file*，但如果 *flush</em> 关键字参数为 True，输出流会被强制刷新。</p>
<p>在 3.3 版更改: 增加了 <em>flush</em> 关键字参数。</p>
<ul>
<li><em>class</em> <code>property</code>(<em>fget=None</em>, <em>fset=None</em>, <em>fdel=None</em>, <em>doc=None</em>)</li>
</ul>
<p>返回 property 属性。</p>
<p><em>fget</em> 是获取属性值的函数。 <em>fset</em> 是用于设置属性值的函数。 <em>fdel</em> 是用于删除属性值的函数。并且 <em>doc</em> 为属性对象创建文档字符串。</p>
<p>一个典型的用法是定义一个托管属性 <code>x</code>:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">C</span><span class="token punctuation">:</span>
<span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
    self<span class="token punctuation">.</span>_x <span class="token operator">=</span>None
<span class="token keyword">def</span> <span class="token function">getx</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">return</span> self<span class="token punctuation">.</span>_x
<span class="token keyword">def</span> <span class="token function">setx</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">:</span>
    self<span class="token punctuation">.</span>_x <span class="token operator">=</span> value
<span class="token keyword">def</span> <span class="token function">delx</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
    delself<span class="token punctuation">.</span>_x
    x <span class="token operator">=</span>property<span class="token punctuation">(</span>getx<span class="token punctuation">,</span> setx<span class="token punctuation">,</span> delx<span class="token punctuation">,</span><span class="token string">"I'm the 'x' property."</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果 <em>c</em> 为 <em>C</em> 的实例，<code>c.x</code> 将调用 getter，<code>c.x = value</code> 将调用 setter， <code>del c.x</code> 将调用 deleter。</p>
<p>如果给出，<em>doc</em> 将成为该 property 属性的文档字符串。 否则该 property 将拷贝 <em>fget</em> 的文档字符串（如果存在）。 这令使用 <code>property()</code> 作为 decorator 来创建只读的特征属性可以很容易地实现:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Parrot</span><span class="token punctuation">:</span>
<span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
    self<span class="token punctuation">.</span>_voltage <span class="token operator">=</span><span class="token number">100000</span>
@property
<span class="token keyword">def</span> <span class="token function">voltage</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">"""Get the current voltage."""</span>
    <span class="token keyword">return</span> self<span class="token punctuation">.</span>_voltage<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>以上 <code>@property</code> 装饰器会将 <code>voltage()</code> 方法转化为一个具有相同名称的只读属性的 “getter”，并将 <em>voltage</em> 的文档字符串设置为 “Get the current voltage.”</p>
<p>特征属性对象具有 <code>getter</code>, <code>setter</code> 以及 <code>deleter</code> 方法，它们可用作装饰器来创建该特征属性的副本，并将相应的访问函数设为所装饰的函数。 这最好是用一个例子来解释:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">C</span><span class="token punctuation">:</span>
<span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
    self<span class="token punctuation">.</span>_x <span class="token operator">=</span>None
@property
<span class="token keyword">def</span> <span class="token function">x</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">"""I'm the 'x' property."""</span>
    <span class="token keyword">return</span> self<span class="token punctuation">.</span>_x
@x<span class="token punctuation">.</span>setter
<span class="token keyword">def</span> <span class="token function">x</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">:</span>
    self<span class="token punctuation">.</span>_x <span class="token operator">=</span> value
@x<span class="token punctuation">.</span>deleter
<span class="token keyword">def</span> <span class="token function">x</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
    delself<span class="token punctuation">.</span>_x<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>上述代码与第一个例子完全等价。 注意一定要给附加函数与原始的特征属性相同的名称 (在本例中为 <code>x</code>。)</p>
<p>返回的特征属性对象同样具有与构造器参数相对应的属性 <code>fget</code>, <code>fset</code> 和 <code>fdel</code>。</p>
<p>在 3.5 版更改: 特征属性对象的文档字符串现在是可写的。</p>
<ul>
<li><p><em>class<em><code>range</code>(</em>stop</em>)</p>
</li>
<li><p><em>class<em><code>range</code>(</em>start</em>, <em>stop</em>[, <em>step</em>])</p>
</li>
</ul>
<p>虽然被称为函数，但 <code>range</code> 实际上是一个不可变的序列类型。</p>
<ul>
<li><code>repr</code>(<em>object</em>)</li>
</ul>
<p>返回对象的可打印形式字符串。对于很多类型而言，本函数试图返回的字符串，会与将对象传给 <code>eval()</code> 所生成的结果相同；不然，结果就是一个尖括号包裹的字符串，包含了对象类型名称及其附加信息，附加信息通常包括对象的名称和内存地址。通过定义 <code>__repr__()</code> 方法，类可以控制本函数将为实例返回的内容。</p>
<ul>
<li><code>reversed</code>(<em>seq</em>)</li>
</ul>
<p>返回一个反向的 iterator。 <em>seq</em> 必须是一个具有 <code>__reversed__()</code> 方法的对象或者是支持该序列协议（具有从 <code>0</code> 开始的整数类型参数的 <code>__len__()</code> 方法和 <code>__getitem__()</code> 方法）。</p>
<ul>
<li><code>round</code>(<em>number</em>[, <em>ndigits</em>])</li>
</ul>
<p>返回 <em>number</em> 舍入到小数点后 <em>ndigits</em> 位精度的值。 如果 <em>ndigits</em> 被省略或为 <code>None</code>，则返回最接近输入值的整数。</p>
<p>对于支持 <code>round()</code> 方法的内置类型，结果值会舍入至最接近的 10 的负 <em>ndigits</em> 次幂的倍数；如果与两个倍数同样接近，则选用偶数。因此，<code>round(0.5)</code> 和 <code>round(-0.5)</code> 均得出 <code>0</code> 而 <code>round(1.5)</code> 则为 <code>2</code>。<em>ndigits</em> 可为任意整数值（正数、零或负数）。如果省略了 <em>ndigits</em> 或为 <code>None</code> ，则返回值将为整数。否则返回值与 <em>number</em> 的类型相同。</p>
<p>对于一般的 Python 对象 <code>number</code>, <code>round</code> 将委托给 <code>number.__round__</code>。</p>
<p>注解</p>
<p>对浮点数执行 <code>round()</code> 的行为可能会令人惊讶：例如，<code>round(2.675, 2)</code> 将给出 <code>2.67</code> 而不是期望的 <code>2.68</code>。 这不算是程序错误：这一结果是由于大多数十进制小数实际上都不能以浮点数精确地表示。 </p>
<ul>
<li><em>class</em><code>set</code>([<em>iterable</em>])</li>
</ul>
<p>返回一个新的 <code>set</code> 对象，可以选择带有从 <em>iterable</em> 获取的元素。 <code>set</code> 是一个内置类型。</p>
<ul>
<li><code>setattr</code>(<em>object</em>, <em>name</em>, <em>value</em>)</li>
</ul>
<p>本函数与 <code>getattr()</code> 相对应。其参数为一个对象、一个字符串和一个任意值。字符串可以为某现有属性的名称，或为新属性。只要对象允许，函数会将值赋给属性。如 <code>setattr(x, 'foobar', 123)</code> 等价于 <code>x.foobar = 123</code>。</p>
<p>注解</p>
<p>由于 私有名称混合 发生在编译时，因此必须手动混合私有属性（以两个下划线打头的属性）名称以便使用 <code>setattr()</code> 来设置它。</p>
<ul>
<li><p><em>class<em><code>slice</code>(</em>stop</em>)</p>
</li>
<li><p><em>class<em><code>slice</code>(</em>start</em>, <em>stop</em>[, <em>step</em>])</p>
</li>
</ul>
<p>返回一个 slice 对象，代表由 <code>range(start, stop, step)</code> 指定索引集的切片。 其中参数 <em>start</em> 和 <em>step</em> 的默认值为 <code>None</code>。切片对象具有只读数据属性 <code>start</code> 、<code>stop</code> 和 <code>step</code>，只是返回对应的参数值（或默认值）。这几个属性没有其他明确的功能；不过 NumPy 和其他第三方扩展会用到。在使用扩展索引语法时，也会生成切片对象。例如： <code>a[start:stop:step]</code> 或 <code>a[start:stop, i]</code>。 另一种方案是返回迭代器对象。</p>
<ul>
<li><code>sorted</code>(<em>iterable</em>, <em>**,</em> key=None<em>,</em> reverse=False*)</li>
</ul>
<p>根据 <em>iterable</em> 中的项返回一个新的已排序列表。</p>
<p>具有两个可选参数，它们都必须指定为关键字参数。</p>
<p><em>key</em> 指定带有单个参数的函数，用于从 <em>iterable</em> 的每个元素中提取用于比较的键 (例如 <code>key=str.lower</code>)。 默认值为 <code>None</code> (直接比较元素)。</p>
<p><em>reverse</em> 为一个布尔值。 如果设为 <code>True</code>，则每个列表元素将按反向顺序比较进行排序。</p>
<p>使用 <code>functools.cmp_to_key()</code> 可将老式的 <em>cmp</em> 函数转换为 <em>key</em> 函数。</p>
<p>内置的 <code>sorted()</code> 确保是稳定的。 如果一个排序确保不会改变比较结果相等的元素的相对顺序就称其为稳定的 —- 这有利于进行多重排序（例如先按部门、再按薪级排序）。</p>
<p>The sort algorithm uses only <code>&lt;</code> comparisons between items. While defining an <code>__lt__()</code> method will suffice for sorting, <a href="https://www.python.org/dev/peps/pep-0008" target="_blank" rel="noopener"><strong>PEP 8</strong></a> recommends that all six rich comparisons be implemented. This will help avoid bugs when using the same data with other ordering tools such as <code>max()</code> that rely on a different underlying method. Implementing all six comparisons also helps avoid confusion for mixed type comparisons which can call reflected the <code>__gt__()</code> method.</p>
<ul>
<li><code>@staticmethod</code></li>
</ul>
<p>将方法转换为静态方法。</p>
<p>静态方法不会接收隐式的第一个参数。要声明一个静态方法，请使用此语法</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">C</span><span class="token punctuation">:</span>
@staticmethod
<span class="token keyword">def</span> <span class="token function">f</span><span class="token punctuation">(</span>arg1<span class="token punctuation">,</span> arg2<span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p><code>@staticmethod</code> 这样的形式称为函数的 decorator 。</p>
<p>静态方法既可以由类中调用（如 <code>C.f()</code>），也可以由实例中调用（如```C().f()<code>）。此外，还可以作为普通的函数进行调用（如</code>f()``）。</p>
<p>Python 的静态方法与 Java 或 C++ 类似。，可用于创建另一种类构造函数。</p>
<p>像所有装饰器一样，也可以像常规函数一样调用 <code>staticmethod</code> ，并对其结果执行某些操作。比如某些情况下需要从类主体引用函数并且您希望避免自动转换为实例方法。对于这些情况，请使用此语法:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">regular_function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token keyword">class</span> <span class="token class-name">C</span><span class="token punctuation">:</span>
    method <span class="token operator">=</span> staticmethod<span class="token punctuation">(</span>regular_function<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>在 3.10 版更改: 静态方法继承了方法的多个属性（<code>__module__</code>、<code>__name__</code>、<code>__qualname__</code>、<code>__doc__</code> 和 <code>__annotations__</code>），还拥有一个新的<code>__wrapped__</code> 属性，并且现在还可以作为普通函数进行调用。</p>
<ul>
<li><p><em>class<em><code>str</code>(</em>object=’’</em>)</p>
</li>
<li><p><em>class<em><code>str</code>(</em>object=b’’</em>, <em>encoding=’utf-8’</em>, <em>errors=’strict’</em>)</p>
</li>
</ul>
<p>返回一个 <code>str</code> 版本的 <em>object</em> 。</p>
<p><code>str</code> 是内置字符串 class 。</p>
<ul>
<li><code>sum</code>(<em>iterable</em>, <em>/</em>, <em>start=0</em>)</li>
</ul>
<p>从 <em>start</em> 开始自左向右对 <em>iterable</em> 的项求和并返回总计值。 <em>iterable</em> 的项通常为数字，而 start 值则不允许为字符串。</p>
<p>对某些用例来说，存在 <code>sum()</code> 的更好替代。 拼接字符串序列的更好更快方式是调用 <code>''.join(sequence)</code>。 </p>
<p>在 3.8 版更改: <em>start</em> 形参可用关键字参数形式来指定。</p>
<ul>
<li><em>class<em><code>super</code>([</em>type</em>[, <em>object-or-type</em>]])</li>
</ul>
<p>返回一个代理对象，它会将方法调用委托给 <em>type</em> 的父类或兄弟类。 这对于访问已在类中被重载的继承方法很有用。</p>
<p><em>object-or-type</em> 确定用于搜索的 method resolution order。 搜索会从 <em>type</em> 之后的类开始。</p>
<p>举例来说，如果 <em>object-or-type</em> 的 <code>__mro__</code> 为 <code>D -&gt; B -&gt; C -&gt; A -&gt; object</code> 并且 <em>type</em> 的值为 <code>B</code>，则 <code>super()</code> 将会搜索 <code>C -&gt; A -&gt; object</code>。</p>
<p><em>object-or-type</em> 的 <code>__mro__</code> 属性列出了 <code>getattr()</code> 和 <code>super()</code> 所共同使用的方法解析搜索顺序。 该属性是动态的，可以在任何继承层级结构发生更新的时候被改变。</p>
<p>如果省略第二个参数，则返回的超类对象是未绑定的。 如果第二个参数为一个对象，则 <code>isinstance(obj, type)</code> 必须为真值。 如果第二个参数为一个类型，则 <code>issubclass(type2, type)</code> 必须为真值（这适用于类方法）。</p>
<p><em>super</em> 有两个典型用例。 在具有单继承的类层级结构中，<em>super</em> 可用来引用父类而不必显式地指定它们的名称，从而令代码更易维护。 这种用法与其他编程语言中 <em>super</em> 的用法非常相似。</p>
<p>第二个用例是在动态执行环境中支持协作多重继承。 此用例为 Python 所独有而不存在于静态编码语言或仅支持单继承的语言当中。 这使用实现“菱形图”成为可能，即有多个基类实现相同的方法。 好的设计强制要求这样的方法在每个情况下都具有相同的调用签名（因为调用顺序是在运行时确定的，也因为这个顺序要适应类层级结构的更改，还因为这个顺序可能包括在运行时之前未知的兄弟类）。</p>
<p>对于以上两个用例，典型的超类调用看起来是这样的:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">C</span><span class="token punctuation">(</span>B<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token keyword">def</span> <span class="token function">method</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> arg<span class="token punctuation">)</span><span class="token punctuation">:</span>
super<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>method<span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># This does the same thing as:</span>
<span class="token comment" spellcheck="true"># super(C, self).method(arg)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>除了方法查找之外，<code>super()</code> 也可用于属性查找。 一个可能的应用场合是在上级或同级类中调用 描述器。</p>
<p>请注意 <code>super()</code> 是作为显式加点属性查找的绑定过程的一部分来实现的，例如 <code>super().__getitem__(name)</code>。 它做到这一点是通过实现自己的 <code>__getattribute__()</code> 方法，这样就能以可预测的顺序搜索类，并且支持协作多重继承。 对应地，<code>super()</code> 在像 <code>super()[name]</code> 这样使用语句或操作符进行隐式查找时则未被定义。</p>
<p>还要注意的是，除了零个参数的形式以外，<code>super()</code> 并不限于在方法内部使用。 两个参数的形式明确指定参数并进行相应的引用。 零个参数的形式仅适用于类定义内部，因为编译器需要填入必要的细节以正确地检索到被定义的类，还需要让普通方法访问当前实例。</p>
<p>对于有关如何使用 <code>super()</code> 来如何设计协作类的实用建议。</p>
<ul>
<li><em>class</em><code>tuple</code>([<em>iterable</em>])</li>
</ul>
<p>虽然被称为函数，但 <code>tuple</code> 实际上是一个不可变的序列类型</p>
<ul>
<li><p><em>class<em><code>type</code>(</em>object</em>)</p>
</li>
<li><p><em>class<em><code>type</code>(</em>name</em>, <em>bases</em>, <em>dict</em>, <em>**kwds</em>)</p>
</li>
</ul>
<p>传入一个参数时，返回 <em>object</em> 的类型。 返回值是一个 type 对象，通常与 <code>object.__class__</code> 所返回的对象相同。</p>
<p>推荐使用 <code>isinstance()</code> 内置函数来检测对象的类型，因为它会考虑子类的情况。</p>
<p>传入三个参数时，返回一个新的 type 对象。 这在本质上是 <code>class</code> 语句的一种动态形式，<em>name</em> 字符串即类名并会成为 <code>__name__</code> 属性；<em>bases</em> 元组包含基类并会成为 <code>__bases__</code> 属性；如果为空则会添加所有类的终极基类 <code>object</code>。 <em>dict</em> 字典包含类主体的属性和方法定义；它在成为 <code>__dict__</code> 属性之前可能会被拷贝或包装。 下面两条语句会创建相同的 <code>type</code> 对象:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">X</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     a <span class="token operator">=</span><span class="token number">1</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> X <span class="token operator">=</span> type<span class="token punctuation">(</span><span class="token string">'X'</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> dict<span class="token punctuation">(</span>a<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>提供给三参数形式的关键字参数会被传递给适当的元类机制 (通常为 <code>__init_subclass__()</code>)，相当于类定义中关键字 (除了 <em>metaclass</em>) 的行为方式。</p>
<p>在 3.6 版更改: <code>type</code> 的子类如果未重载 <code>type.__new__</code>，将不再能使用一个参数的形式来获取对象的类型。</p>
<ul>
<li><code>vars</code>([<em>object</em>])</li>
</ul>
<p>返回模块、类、实例或任何其它具有 <code>__dict__</code> 属性的对象的 <code>__dict__</code> 属性。</p>
<p>模块和实例这样的对象具有可更新的 <code>__dict__</code> 属性；但是，其它对象的 <code>__dict__</code> 属性可能会设为限制写入（例如，类会使用 <code>types.MappingProxyType</code> 来防止直接更新字典）。</p>
<p>不带参数时，<code>vars()</code> 的行为类似 <code>locals()</code>。 请注意，locals 字典仅对于读取起作用，因为对 locals 字典的更新会被忽略。</p>
<p>如果指定了一个对象但它没有 <code>__dict__</code> 属性（例如，当它所属的类定义了 <code>__slots__</code> 属性时）则会引发 <code>TypeError</code> 异常。</p>
<ul>
<li><code>zip</code>(<em>\</em>iterables<em>,</em> strict=False*)</li>
</ul>
<p>在多个迭代器上并行迭代，从每个迭代器返回一个数据项组成元组。</p>
<p>示例:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span><span class="token keyword">for</span> item <span class="token keyword">in</span> zip<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token string">'sugar'</span><span class="token punctuation">,</span><span class="token string">'spice'</span><span class="token punctuation">,</span><span class="token string">'everything nice'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">print</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">'sugar'</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token string">'spice'</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token string">'everything nice'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>更正式的说法： <code>zip()</code> 返回元组的迭代器，其中第 <em>i</em> 个元组包含的是每个参数迭代器的第 <em>i</em> 个元素。</p>
<p>不妨换一种方式认识 <code>zip()</code> ：它会把行变成列，把列变成行。这类似于 矩阵转置 。</p>
<p><code>zip()</code> 是延迟执行的：直至迭代时才会对元素进行处理，比如 <code>for</code> 循环或放入 <code>list</code> 中。</p>
<p>值得考虑的是，传给 <code>zip()</code> 的可迭代对象可能长度不同；有时是有意为之，有时是因为准备这些对象的代码存在错误。Python 提供了三种不同的处理方案：</p>
<ul>
<li><p>默认情况下，<code>zip()</code> 在最短的迭代完成后停止。较长可迭代对象中的剩余项将被忽略，结果会裁切至最短可迭代对象的长度：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> list<span class="token punctuation">(</span>zip<span class="token punctuation">(</span>range<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token string">'fee'</span><span class="token punctuation">,</span><span class="token string">'fi'</span><span class="token punctuation">,</span><span class="token string">'fo'</span><span class="token punctuation">,</span><span class="token string">'fum'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token string">'fee'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">'fi'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token string">'fo'</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li><p>通常 <code>zip()</code> 用于可迭代对象等长的情况下。这时建议用 <code>strict=True</code> 的选项。输出与普通的 <code>zip()</code> 相同：。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> list<span class="token punctuation">(</span>zip<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">,</span><span class="token string">'b'</span><span class="token punctuation">,</span><span class="token string">'c'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span> strict<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token string">'b'</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token string">'c'</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>与默认行为不同的是，它会检查可迭代对象的长度是否相同，如果不相同则触发 <code>ValueError</code> 。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> list<span class="token punctuation">(</span>zip<span class="token punctuation">(</span>range<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token string">'fee'</span><span class="token punctuation">,</span><span class="token string">'fi'</span><span class="token punctuation">,</span><span class="token string">'fo'</span><span class="token punctuation">,</span><span class="token string">'fum'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> strict<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
Traceback<span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
ValueError<span class="token punctuation">:</span> zip<span class="token punctuation">(</span><span class="token punctuation">)</span> argument 2is longer than argument <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果未指定 <code>strict=True</code> 参数，所有导致可迭代对象长度不同的错误都会被抑制，这可能会在程序的其他地方表现为难以发现的错误。</p>
</li>
<li><p>为了让所有的可迭代对象具有相同的长度，长度较短的可用常量进行填充。这可由 <code>itertools.zip_longest()</code> 来完成。</p>
</li>
</ul>
<p>极端例子是只有一个可迭代对象参数，<code>zip()</code> 会返回一个一元组的迭代器。如果未给出参数，则返回一个空的迭代器。</p>
<p>小技巧：</p>
<ul>
<li><p>可确保迭代器的求值顺序是从左到右的。这样就能用 <code>zip(*[iter(s)]*n, strict=True)</code> 将数据列表按长度 n 进行分组。这将重复 <em>相同</em> 的迭代器 <code>n</code> 次，输出的每个元组都包含 <code>n</code> 次调用迭代器的结果。这样做的效果是把输入拆分为长度为 n 的块。</p>
</li>
<li><p><code>zip()</code> 与 <code>*</code> 运算符相结合可以用来拆解一个列表:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> x <span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> y <span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> list<span class="token punctuation">(</span>zip<span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> x2<span class="token punctuation">,</span> y2 <span class="token operator">=</span> zip<span class="token punctuation">(</span><span class="token operator">*</span>zip<span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> x <span class="token operator">==</span> list<span class="token punctuation">(</span>x2<span class="token punctuation">)</span> <span class="token operator">and</span> y <span class="token operator">==</span> list<span class="token punctuation">(</span>y2<span class="token punctuation">)</span>
<span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
<p>在 3.10 版更改: 增加了 <code>strict</code> 参数。</p>
<ul>
<li><code>__import__</code>(<em>name</em>, <em>globals=None</em>, <em>locals=None</em>, <em>fromlist=()</em>, <em>level=0</em>)</li>
</ul>
<p>注解</p>
<p>与 <code>importlib.import_module()</code> 不同，这是一个日常 Python 编程中不需要用到的高级函数。</p>
<p>此函数会由 <code>import</code> 语句发起调用。 它可以被替换 (通过导入 <code>builtins</code> 模块并赋值给 <code>builtins.__import__</code>) 以便修改 <code>import</code> 语句的语义，但是 <strong>强烈</strong> 不建议这样做，因为使用导入钩子 (参见 <a href="https://www.python.org/dev/peps/pep-0302" target="_blank" rel="noopener"><strong>PEP 302</strong></a>) 通常更容易实现同样的目标，并且不会导致代码问题，因为许多代码都会假定所用的是默认实现。 同样也不建议直接使用 <code>__import__()</code> 而应该用 <code>importlib.import_module()</code>。</p>
<p>本函数会导入模块 <em>name*，利用 *globals</em> 和 <em>locals</em> 来决定如何在包的上下文中解释该名称。<em>fromlist</em> 给出了应从 <em>name</em> 模块中导入的对象或子模块的名称。标准的实现代码完全不会用到 <em>locals</em> 参数，只用到了 <em>globals</em> 用于确定 <code>import</code> 语句所在的包上下文。</p>
<p><em>level</em> 指定是使用绝对还是相对导入。 <code>0</code> (默认值) 意味着仅执行绝对导入。 <em>level</em> 为正数值表示相对于模块调用 <code>__import__()</code> 的目录，将要搜索的父目录层数 (详情参见 <a href="https://www.python.org/dev/peps/pep-0328" target="_blank" rel="noopener"><strong>PEP 328</strong></a>)。</p>
<p>当 <em>name</em> 变量的形式为 <code>package.module</code> 时，通常将会返回最高层级的包（第一个点号之前的名称），而 <em>不是</em> 以 <em>name</em> 命名的模块。 但是，当给出了非空的 <em>fromlist</em> 参数时，则将返回以 <em>name</em> 命名的模块。</p>
<p>例如，语句 <code>import spam</code> 的结果将为与以下代码作用相同的字节码:</p>
<pre class="line-numbers language-python"><code class="language-python">spam <span class="token operator">=</span> __import__<span class="token punctuation">(</span><span class="token string">'spam'</span><span class="token punctuation">,</span> globals<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> locals<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>语句 <code>import spam.ham</code> 的结果将为以下调用:</p>
<pre class="line-numbers language-python"><code class="language-python">spam <span class="token operator">=</span> __import__<span class="token punctuation">(</span><span class="token string">'spam.ham'</span><span class="token punctuation">,</span> globals<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> locals<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>请注意在这里 <code>__import__()</code> 是如何返回顶层模块的，因为这是通过 <code>import</code> 语句被绑定到特定名称的对象。</p>
<p>另一方面，语句 <code>from spam.ham import eggs, sausage as saus</code> 的结果将为</p>
<pre class="line-numbers language-python"><code class="language-python">_temp <span class="token operator">=</span> __import__<span class="token punctuation">(</span><span class="token string">'spam.ham'</span><span class="token punctuation">,</span> globals<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> locals<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token string">'eggs'</span><span class="token punctuation">,</span><span class="token string">'sausage'</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span>
eggs <span class="token operator">=</span> _temp<span class="token punctuation">.</span>eggs
saus <span class="token operator">=</span> _temp<span class="token punctuation">.</span>sausage<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>在这里， <code>spam.ham</code> 模块会由 <code>__import__()</code> 返回。 要导入的对象将从此对象中提取并赋值给它们对应的名称。</p>
<p>如果您只想按名称导入模块（可能在包中），请使用 <code>importlib.import_module()</code></p>
<p>在 3.3 版更改: <em>level</em> 的值不再支持负数（默认值也修改为0）。</p>
<p>在 3.9 版更改: 当使用了命令行参数 <code>-E</code> 或 <code>-I</code> 时，环境变量 <code>PYTHONCASEOK</code> 现在将被忽略。</p>
<h1 id="内置常量"><a href="#内置常量" class="headerlink" title="内置常量"></a>内置常量</h1><p>有少数的常量存在于内置命名空间中。 它们是：</p>
<pre><code>False</code></pre><p><code>bool</code> 类型的假值。 给 <code>False</code> 赋值是非法的并会引发 <code>SyntaxError</code>。</p>
<pre><code>True</code></pre><p><code>bool</code> 类型的真值。 给 <code>True</code> 赋值是非法的并会引发 <code>SyntaxError</code>。</p>
<pre><code>None</code></pre><p>通常被用来代表空值的对象，例如在未向某个函数传入默认参数时。 给 <code>None</code> 赋值是非法的并会引发 <code>SyntaxError</code>。 <code>None</code> 是 <code>NoneType</code> 类型的唯一实例。</p>
<pre><code>NotImplemented</code></pre><p>应当由双目运算特殊方法（如 <code>__eq__()</code>, <code>__lt__()</code>, <code>__add__()</code>, <code>__rsub__()</code> 等）返回的特殊值，用于表明运算没有针对其他类型的实现；也可由原地双目运算特殊方法（如 <code>__imul__()</code>, <code>__iand__()</code> 等）出于同样的目的而返回。 它不应在布尔运算中被求值。 <code>NotImplemented</code> 是 <code>types.NotImplementedType</code> 类型的唯一实例。</p>
<p>注解</p>
<p>当二进制（或就地）方法返回<code>NotImplemented</code>时，解释器将尝试对另一种类型（或其他一些回滚操作，取决于运算符）的反射操作。 如果所有尝试都返回<code>NotImplemented</code>，则解释器将引发适当的异常。 错误返回的<code>NotImplemented</code>将导致误导性错误消息或返回到Python代码中的<code>NotImplemented</code>值。</p>
<p>注解</p>
<p><code>NotImplementedError</code> 和 <code>NotImplemented</code> 不可互换，即使它们有相似的名称和用途。 </p>
<p>在 3.9 版更改: 作为布尔值来解读 <code>NotImplemented</code> 已被弃用。 虽然它目前会被解读为真值，但将同时发出 <code>DeprecationWarning</code>。 它将在未来的 Python 版本中引发 <code>TypeError</code>。</p>
<pre><code>Ellipsis</code></pre><p>与省略号字面值 “<code>...</code>“ 相同。 该特殊值主要是与用户定义的容器数据类型的扩展切片语法结合使用。 <code>Ellipsis</code> 是 <code>types.EllipsisType</code> 类型的唯一实例。</p>
<pre><code>__debug__</code></pre><p>如果 Python 没有以 <code>-O</code> 选项启动，则此常量为真值。 </p>
<p>注解</p>
<p>变量名 <code>None</code>，<code>False</code>，<code>True</code> 和 <code>__ debug__</code> 无法重新赋值（赋值给它们，即使是属性名，将引发 <code>SyntaxError</code> ），所以它们可以被认为是“真正的”常数。</p>
<h2 id="由-site-模块添加的常量"><a href="#由-site-模块添加的常量" class="headerlink" title="由 site 模块添加的常量"></a>由 <code>site</code> 模块添加的常量</h2><p><code>site</code> 模块（在启动期间自动导入，除非给出 <code>-S</code> 命令行选项）将几个常量添加到内置命名空间。 它们对交互式解释器 shell 很有用，并且不应在程序中使用。</p>
<ul>
<li><p><code>quit</code>(<em>code=None</em>)</p>
</li>
<li><p><code>exit</code>(<em>code=None</em>)</p>
</li>
</ul>
<p>当打印此对象时，会打印出一条消息，例如“Use quit() or Ctrl-D (i.e. EOF) to exit”，当调用此对象时，将使用指定的退出代码来引发 <code>SystemExit</code>。</p>
<pre><code>copyright
credits</code></pre><p>打印或调用的对象分别打印版权或作者的文本。</p>
<pre><code>license</code></pre><p>当打印此对象时，会打印出一条消息“Type license() to see the full license text”，当调用此对象时，将以分页形式显示完整的许可证文本（每次显示一屏）。</p>
<h1 id="内置类型"><a href="#内置类型" class="headerlink" title="内置类型"></a>内置类型</h1><p>以下部分描述了解释器中内置的标准类型。</p>
<p>主要内置类型有数字、序列、映射、类、实例和异常。</p>
<p>有些多项集类是可变的。 它们用于添加、移除或重排其成员的方法将原地执行，并不返回特定的项，绝对不会返回多项集实例自身而是返回 <code>None</code>。</p>
<p>有些操作受多种对象类型的支持；特别地，实际上所有对象都可以比较是否相等、检测逻辑值，以及转换为字符串（使用 <code>repr()</code> 函数或略有差异的 <code>str()</code> 函数）。 后一个函数是在对象由 <code>print()</code> 函数输出时被隐式地调用的。</p>
<h2 id="逻辑值检测"><a href="#逻辑值检测" class="headerlink" title="逻辑值检测"></a>逻辑值检测</h2><p>任何对象都可以进行逻辑值的检测，以便在 <code>if</code> 或 <code>while</code> 作为条件或是作为下文所述布尔运算的操作数来使用。</p>
<p>一个对象在默认情况下均被视为真值，除非当该对象被调用时其所属类定义了 <code>__bool__()</code> 方法且返回 <code>False</code> 或是定义了 <code>__len__()</code> 方法且返回零。 下面基本完整地列出了会被视为假值的内置对象:</p>
<ul>
<li>被定义为假值的常量: <code>None</code> 和 <code>False</code>。</li>
<li>任何数值类型的零: <code>0</code>, <code>0.0</code>, <code>0j</code>, <code>Decimal(0)</code>, <code>Fraction(0, 1)</code></li>
<li>空的序列和多项集: <code>''</code>, <code>()</code>, <code>[]</code>, <code>{}</code>, <code>set()</code>, <code>range(0)</code></li>
</ul>
<p>产生布尔值结果的运算和内置函数总是返回 <code>0</code> 或 <code>False</code> 作为假值，<code>1</code> 或 <code>True</code> 作为真值，除非另行说明。 （重要例外：布尔运算 <code>or</code> 和 <code>and</code> 总是返回其中一个操作数。）</p>
<h2 id="布尔运算-—-and-or-not"><a href="#布尔运算-—-and-or-not" class="headerlink" title="布尔运算 —- and, or, not"></a>布尔运算 —- <code>and</code>, <code>or</code>, <code>not</code></h2><p>这些属于布尔运算，按优先级升序排列:</p>
<table>
<thead>
<tr>
<th align="left">运算</th>
<th align="left">结果：</th>
<th align="left">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>x or y</code></td>
<td align="left">if <em>x</em> is false, then <em>y</em>, else <em>x</em></td>
<td align="left">(1)</td>
</tr>
<tr>
<td align="left"><code>x and y</code></td>
<td align="left">if <em>x</em> is false, then <em>x</em>, else <em>y</em></td>
<td align="left">(2)</td>
</tr>
<tr>
<td align="left"><code>not x</code></td>
<td align="left">if <em>x</em> is false, then <code>True</code>, else <code>False</code></td>
<td align="left">(3)</td>
</tr>
</tbody></table>
<p>注释：</p>
<ol>
<li>这是个短路运算符，因此只有在第一个参数为假值时才会对第二个参数求值。</li>
<li>这是个短路运算符，因此只有在第一个参数为真值时才会对第二个参数求值。</li>
<li><code>not</code> 的优先级比非布尔运算符低，因此 <code>not a == b</code> 会被解读为 <code>not (a == b)</code> 而 <code>a == not b</code> 会引发语法错误。</li>
</ol>
<h2 id="比较运算"><a href="#比较运算" class="headerlink" title="比较运算"></a>比较运算</h2><p>在 Python 中有八种比较运算符。 它们的优先级相同（比布尔运算的优先级高）。 比较运算可以任意串连；例如，<code>x &lt; y &lt;= z</code> 等价于 <code>x &lt; y and y &lt;= z</code>，前者的不同之处在于 <em>y</em> 只被求值一次（但在两种情况下当 <code>x &lt; y</code> 结果为假值时 <em>z</em> 都不会被求值）。</p>
<p>此表格汇总了比较运算:</p>
<table>
<thead>
<tr>
<th align="left">运算</th>
<th align="left">含意</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>&lt;</code></td>
<td align="left">严格小于</td>
</tr>
<tr>
<td align="left"><code>&lt;=</code></td>
<td align="left">小于或等于</td>
</tr>
<tr>
<td align="left"><code>&gt;</code></td>
<td align="left">严格大于</td>
</tr>
<tr>
<td align="left"><code>&gt;=</code></td>
<td align="left">大于或等于</td>
</tr>
<tr>
<td align="left"><code>==</code></td>
<td align="left">等于</td>
</tr>
<tr>
<td align="left"><code>!=</code></td>
<td align="left">不等于</td>
</tr>
<tr>
<td align="left"><code>is</code></td>
<td align="left">对象标识</td>
</tr>
<tr>
<td align="left"><code>is not</code></td>
<td align="left">否定的对象标识</td>
</tr>
</tbody></table>
<p>除不同的数字类型外，不同类型的对象不能进行相等比较。<code>==</code> 运算符总有定义，但对于某些对象类型（例如，类对象），它等于 <code>is</code> 。其他 <code>&lt;</code>、<code>&lt;=</code>、<code>&gt;</code> 和 <code>&gt;=</code> 运算符仅在有意义的地方定义。例如，当参与比较的参数之一为复数时，它们会抛出 <code>TypeError</code> 异常。</p>
<p>具有不同标识的类的实例比较结果通常为不相等，除非类定义了 <code>__eq__()</code> 方法。</p>
<p>一个类实例不能与相同类或的其他实例或其他类型的对象进行排序，除非该类定义了足够多的方法，包括 <code>__lt__()</code>, <code>__le__()</code>, <code>__gt__()</code> 以及 <code>__ge__()</code> (而如果你想实现常规意义上的比较操作，通常只要有 <code>__lt__()</code> 和 <code>__eq__()</code> 就可以了)。</p>
<p><code>is</code> 和 <code>is not</code> 运算符无法自定义；并且它们可以被应用于任意两个对象而不会引发异常。</p>
<p>还有两种具有相同语法优先级的运算 <code>in</code> 和 <code>not in</code>，它们被 iterable 或实现了 <code>__contains__()</code> 方法的类型所支持。</p>
<h2 id="数字类型-—-int-float-complex"><a href="#数字类型-—-int-float-complex" class="headerlink" title="数字类型 —- int, float, complex"></a>数字类型 —- <code>int</code>, <code>float</code>, <code>complex</code></h2><p>存在三种不同的数字类型: <em>整数</em>, <em>浮点数</em> 和 <em>复数*。 此外，布尔值属于整数的子类型。 整数具有无限的精度。 浮点数通常使用 C 中的 double 来实现；有关你的程序运行所在机器上浮点数的精度和内部表示法可在 <code>sys.float_info</code> 中查看。 复数包含实部和虚部，分别以一个浮点数表示。 要从一个复数 *z</em> 中提取这两个部分，可使用 <code>z.real</code> 和 <code>z.imag</code>。 （标准库包含附加的数字类型，如表示有理数的 <code>fractions.Fraction</code> 以及以用户定制精度表示浮点数的 <code>decimal.Decimal</code>。）</p>
<p>数字是由数字字面值或内置函数与运算符的结果来创建的。 不带修饰的整数字面值（包括十六进制、八进制和二进制数）会生成整数。 包含小数点或幂运算符的数字字面值会生成浮点数。 在数字字面值末尾加上 <code>'j'</code> 或 <code>'J'</code> 会生成虚数（实部为零的复数），你可以将其与整数或浮点数相加来得到具有实部和虚部的复数。</p>
<p>Python 完全支持混合运算：当一个二元算术运算符的操作数有不同数值类型时，”较窄”类型的操作数会拓宽到另一个操作数的类型，其中整数比浮点数窄，浮点数比复数窄。不同类型的数字之间的比较，同比较这些数字的精确值一样。</p>
<p>构造函数 <code>int()</code>、 <code>float()</code> 和 <code>complex()</code> 可以用来构造特定类型的数字。</p>
<p>所有数字类型（复数除外）都支持下列运算:</p>
<table>
<thead>
<tr>
<th align="left">运算</th>
<th align="left">结果：</th>
<th align="left">备注</th>
<th align="left">完整文档</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>x + y</code></td>
<td align="left"><em>x</em> 和 <em>y</em> 的和</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>x - y</code></td>
<td align="left"><em>x</em> 和 <em>y</em> 的差</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>x * y</code></td>
<td align="left"><em>x</em> 和 <em>y</em> 的乘积</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>x / y</code></td>
<td align="left"><em>x</em> 和 <em>y</em> 的商</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>x // y</code></td>
<td align="left"><em>x</em> 和 <em>y</em> 的商数</td>
<td align="left">(1)</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>x % y</code></td>
<td align="left"><code>x / y</code> 的余数</td>
<td align="left">(2)</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>-x</code></td>
<td align="left"><em>x</em> 取反</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>+x</code></td>
<td align="left"><em>x</em> 不变</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>abs(x)</code></td>
<td align="left"><em>x</em> 的绝对值或大小</td>
<td align="left"></td>
<td align="left"><code>abs()</code></td>
</tr>
<tr>
<td align="left"><code>int(x)</code></td>
<td align="left">将 <em>x</em> 转换为整数</td>
<td align="left">(3)(6)</td>
<td align="left"><code>int()</code></td>
</tr>
<tr>
<td align="left"><code>float(x)</code></td>
<td align="left">将 <em>x</em> 转换为浮点数</td>
<td align="left">(4)(6)</td>
<td align="left"><code>float()</code></td>
</tr>
<tr>
<td align="left"><code>complex(re, im)</code></td>
<td align="left">一个带有实部 <em>re</em> 和虚部 <em>im</em> 的复数。<em>im</em> 默认为0。</td>
<td align="left">(6)</td>
<td align="left"><code>complex()</code></td>
</tr>
<tr>
<td align="left"><code>c.conjugate()</code></td>
<td align="left">复数 <em>c</em> 的共轭</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>divmod(x, y)</code></td>
<td align="left"><code>(x // y, x % y)</code></td>
<td align="left">(2)</td>
<td align="left"><code>divmod()</code></td>
</tr>
<tr>
<td align="left"><code>pow(x, y)</code></td>
<td align="left"><em>x</em> 的 <em>y</em> 次幂</td>
<td align="left">(5)</td>
<td align="left"><code>pow()</code></td>
</tr>
<tr>
<td align="left"><code>x ** y</code></td>
<td align="left"><em>x</em> 的 <em>y</em> 次幂</td>
<td align="left">(5)</td>
<td align="left"></td>
</tr>
</tbody></table>
<p>注释：</p>
<ol>
<li><p>也称为整数除法。 结果值是一个整数，但结果的类型不一定是 int。 运算结果总是向负无穷的方向舍入: <code>1//2</code> 为 <code>0</code>, <code>(-1)//2</code> 为 <code>-1</code>, <code>1//(-2)</code> 为 <code>-1</code> 而 <code>(-1)//(-2)</code> 为 <code>0</code>。</p>
</li>
<li><p>不可用于复数。 而应在适当条件下使用 <code>abs()</code> 转换为浮点数。</p>
</li>
<li><p>从浮点数转换为整数会被舍入或是像在 C 语言中一样被截断。</p>
</li>
<li><p>float 也接受字符串 “nan” 和附带可选前缀 “+” 或 “-“ 的 “inf” 分别表示非数字 (NaN) 以及正或负无穷。</p>
</li>
<li><p>Python 将 <code>pow(0, 0)</code> 和 <code>0 ** 0</code> 定义为 <code>1</code>，这是编程语言的普遍做法。</p>
</li>
<li><p>接受的数字字面值包括数码 <code>0</code> 到 <code>9</code> 或任何等效的 Unicode 字符（具有 <code>Nd</code> 特征属性的代码点）。</p>
<p>请参阅 <a href="https://www.unicode.org/Public/13.0.0/ucd/extracted/DerivedNumericType.txt" target="_blank" rel="noopener">https://www.unicode.org/Public/13.0.0/ucd/extracted/DerivedNumericType.txt</a> 查看具有 <code>Nd</code> 特征属性的代码点的完整列表。</p>
</li>
</ol>
<p>所有 <code>numbers.Real</code> 类型 (<code>int</code> 和 <code>float</code>) 还包括下列运算:</p>
<table>
<thead>
<tr>
<th align="left">运算</th>
<th align="left">结果：</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>math.trunc(x)</code></td>
<td align="left"><em>x</em> 截断为 <code>Integral</code></td>
</tr>
<tr>
<td align="left"><code>round(x[, n\])</code></td>
<td align="left"><em>x</em> 舍入到 <em>n</em> 位小数，半数值会舍入到偶数。 如果省略 <em>n</em>，则默认为 0。</td>
</tr>
<tr>
<td align="left"><code>math.floor(x)</code></td>
<td align="left">&lt;= <em>x</em> 的最大 <code>Integral</code></td>
</tr>
<tr>
<td align="left"><code>math.ceil(x)</code></td>
<td align="left">&gt;= <em>x</em> 的最小 <code>Integral</code></td>
</tr>
</tbody></table>
<h3 id="整数类型的按位运算"><a href="#整数类型的按位运算" class="headerlink" title="整数类型的按位运算"></a>整数类型的按位运算</h3><p>按位运算只对整数有意义。 计算按位运算的结果，就相当于使用无穷多个二进制符号位对二的补码执行操作。</p>
<p>二进制按位运算的优先级全都低于数字运算，但又高于比较运算；一元运算 <code>~</code> 具有与其他一元算术运算 (<code>+</code> and <code>-</code>) 相同的优先级。</p>
<p>此表格是以优先级升序排序的按位运算列表:</p>
<table>
<thead>
<tr>
<th align="left">运算</th>
<th align="left">结果：</th>
<th align="left">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="left">`x</td>
<td align="left">y`</td>
<td align="left"><em>x</em> 和 <em>y</em> 按位 <em>或</em></td>
</tr>
<tr>
<td align="left"><code>x ^ y</code></td>
<td align="left"><em>x</em> 和 <em>y</em> 按位 <em>异或</em></td>
<td align="left">(4)</td>
</tr>
<tr>
<td align="left"><code>x &amp; y</code></td>
<td align="left"><em>x</em> 和 <em>y</em> 按位 <em>与</em></td>
<td align="left">(4)</td>
</tr>
<tr>
<td align="left"><code>x &lt;&lt; n</code></td>
<td align="left"><em>x</em> 左移 <em>n</em> 位</td>
<td align="left">(1)(2)</td>
</tr>
<tr>
<td align="left"><code>x &gt;&gt; n</code></td>
<td align="left"><em>x</em> 右移 <em>n</em> 位</td>
<td align="left">(1)(3)</td>
</tr>
<tr>
<td align="left"><code>~x</code></td>
<td align="left"><em>x</em> 逐位取反</td>
<td align="left"></td>
</tr>
</tbody></table>
<p>注释：</p>
<ol>
<li>负的移位数是非法的，会导致引发 <code>ValueError</code>。</li>
<li>左移 <em>n</em> 位等价于乘以 <code>pow(2, n)</code> 。</li>
<li>右移 <em>n</em> 位等价于除以 <code>pow(2, n)</code> ，作向下取整除法。</li>
<li>使用带有至少一个额外符号扩展位的有限个二进制补码表示（有效位宽度为 <code>1 + max(x.bit_length(), y.bit_length())</code> 或以上）执行这些计算就足以获得相当于有无数个符号位时的同样结果。</li>
</ol>
<h3 id="整数类型的附加方法"><a href="#整数类型的附加方法" class="headerlink" title="整数类型的附加方法"></a>整数类型的附加方法</h3><p>int 类型实现了 <code>numbers.Integral</code> abstract base class。 此外，它还提供了其他几个方法:</p>
<p><code>int.bit_length</code>()</p>
<p>返回以二进制表示一个整数所需要的位数，不包括符号位和前面的零:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> n <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">37</span>
<span class="token operator">>></span><span class="token operator">></span> bin<span class="token punctuation">(</span>n<span class="token punctuation">)</span>
<span class="token string">'-0b100101'</span>
<span class="token operator">>></span><span class="token operator">></span> n<span class="token punctuation">.</span>bit_length<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token number">6</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>更准确地说，如果 <code>x</code> 非零，则 <code>x.bit_length()</code> 是使得 <code>2**(k-1) &lt;= abs(x) &lt; 2**k</code> 的唯一正整数 <code>k</code>。 同样地，当 <code>abs(x)</code> 小到足以具有正确的舍入对数时，则 <code>k = 1 + int(log(abs(x), 2))</code>。 如果 <code>x</code> 为零，则 <code>x.bit_length()</code> 返回 <code>0</code>。</p>
<p>等价于:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">bit_length</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
    s <span class="token operator">=</span> bin<span class="token punctuation">(</span>self<span class="token punctuation">)</span>       <span class="token comment" spellcheck="true"># binary representation:  bin(-37) --> '-0b100101'</span>
    s <span class="token operator">=</span> s<span class="token punctuation">.</span>lstrip<span class="token punctuation">(</span><span class="token string">'-0b'</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># remove leading zeros and minus sign</span>
    <span class="token keyword">return</span> len<span class="token punctuation">(</span>s<span class="token punctuation">)</span>       <span class="token comment" spellcheck="true"># len('100101') --> 6</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>3.1 新版功能.</p>
<p><code>int.bit_count</code>()</p>
<p>Return the number of ones in the binary representation of the absolute value of the integer. This is also known as the population count. Example:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> n <span class="token operator">=</span> <span class="token number">19</span>
<span class="token operator">>></span><span class="token operator">></span> bin<span class="token punctuation">(</span>n<span class="token punctuation">)</span>
<span class="token string">'0b10011'</span>
<span class="token operator">>></span><span class="token operator">></span> n<span class="token punctuation">.</span>bit_count<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token number">3</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token punctuation">(</span><span class="token operator">-</span>n<span class="token punctuation">)</span><span class="token punctuation">.</span>bit_count<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token number">3</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>等价于:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">bit_count</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>    
    <span class="token keyword">return</span> bin<span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">.</span>count<span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>3.10 新版功能.</p>
<p><code>int.to_bytes</code>(<em>length</em>, <em>byteorder</em>, <em>**,</em> signed=False*)</p>
<p>返回表示一个整数的字节数组。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">.</span>to_bytes<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> byteorder<span class="token operator">=</span><span class="token string">'big'</span><span class="token punctuation">)</span>
b<span class="token string">'\x04\x00'</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">.</span>to_bytes<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> byteorder<span class="token operator">=</span><span class="token string">'big'</span><span class="token punctuation">)</span>
b<span class="token string">'\x00\x00\x00\x00\x00\x00\x00\x00\x04\x00'</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">.</span>to_bytes<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> byteorder<span class="token operator">=</span><span class="token string">'big'</span><span class="token punctuation">,</span> signed<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>
b<span class="token string">'\xff\xff\xff\xff\xff\xff\xff\xff\xfc\x00'</span>
<span class="token operator">>></span><span class="token operator">></span> x <span class="token operator">=</span> <span class="token number">1000</span>
<span class="token operator">>></span><span class="token operator">></span> x<span class="token punctuation">.</span>to_bytes<span class="token punctuation">(</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>bit_length<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">7</span><span class="token punctuation">)</span> <span class="token operator">//</span> <span class="token number">8</span><span class="token punctuation">,</span> byteorder<span class="token operator">=</span><span class="token string">'little'</span><span class="token punctuation">)</span>
b<span class="token string">'\xe8\x03'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>整数会使用 <em>length</em> 个字节来表示。 如果整数不能用给定的字节数来表示则会引发 <code>OverflowError</code>。</p>
<p><em>byteorder</em> 参数确定用于表示整数的字节顺序。 如果 <em>byteorder</em> 为 <code>"big"</code>，则最高位字节放在字节数组的开头。 如果 <em>byteorder</em> 为 <code>"little"</code>，则最高位字节放在字节数组的末尾。 要请求主机系统上的原生字节顺序，请使用 <code>sys.byteorder</code> 作为字节顺序值。</p>
<p><em>signed</em> 参数确定是否使用二的补码来表示整数。 如果 <em>signed</em> 为 <code>False</code> 并且给出的是负整数，则会引发 <code>OverflowError</code>。 <em>signed</em> 的默认值为 <code>False</code>。</p>
<p>3.2 新版功能.</p>
<p><em>classmethod</em> <code>int.from_bytes</code>(<em>bytes</em>, <em>byteorder</em>, <em>**,</em> signed=False*)</p>
<p>返回由给定字节数组所表示的整数。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> int<span class="token punctuation">.</span>from_bytes<span class="token punctuation">(</span>b<span class="token string">'\x00\x10'</span><span class="token punctuation">,</span> byteorder<span class="token operator">=</span><span class="token string">'big'</span><span class="token punctuation">)</span>
<span class="token number">16</span>
<span class="token operator">>></span><span class="token operator">></span> int<span class="token punctuation">.</span>from_bytes<span class="token punctuation">(</span>b<span class="token string">'\x00\x10'</span><span class="token punctuation">,</span> byteorder<span class="token operator">=</span><span class="token string">'little'</span><span class="token punctuation">)</span>
<span class="token number">4096</span>
<span class="token operator">>></span><span class="token operator">></span> int<span class="token punctuation">.</span>from_bytes<span class="token punctuation">(</span>b<span class="token string">'\xfc\x00'</span><span class="token punctuation">,</span> byteorder<span class="token operator">=</span><span class="token string">'big'</span><span class="token punctuation">,</span> signed<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>
<span class="token operator">-</span><span class="token number">1024</span>
<span class="token operator">>></span><span class="token operator">></span> int<span class="token punctuation">.</span>from_bytes<span class="token punctuation">(</span>b<span class="token string">'\xfc\x00'</span><span class="token punctuation">,</span> byteorder<span class="token operator">=</span><span class="token string">'big'</span><span class="token punctuation">,</span> signed<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span>
<span class="token number">64512</span>
<span class="token operator">>></span><span class="token operator">></span> int<span class="token punctuation">.</span>from_bytes<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">255</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> byteorder<span class="token operator">=</span><span class="token string">'big'</span><span class="token punctuation">)</span>
<span class="token number">16711680</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><em>bytes</em> 参数必须为一个 bytes-like object 或是生成字节的可迭代对象。</p>
<p><em>byteorder</em> 参数确定用于表示整数的字节顺序。 如果 <em>byteorder</em> 为 <code>"big"</code>，则最高位字节放在字节数组的开头。 如果 <em>byteorder</em> 为 <code>"little"</code>，则最高位字节放在字节数组的末尾。 要请求主机系统上的原生字节顺序，请使用 <code>sys.byteorder</code> 作为字节顺序值。</p>
<p><em>signed</em> 参数指明是否使用二的补码来表示整数。</p>
<p>3.2 新版功能.</p>
<p><code>int.as_integer_ratio</code>()</p>
<p>返回一对整数，其比率正好等于原整数并且分母为正数。 整数的比率总是用这个整数本身作为分子，<code>1</code> 作为分母。</p>
<p>3.8 新版功能.</p>
<h3 id="浮点类型的附加方法"><a href="#浮点类型的附加方法" class="headerlink" title="浮点类型的附加方法"></a>浮点类型的附加方法</h3><p>float 类型实现了 <code>numbers.Real</code> abstract base class。 float 还具有以下附加方法。</p>
<p><code>float.as_integer_ratio</code>()</p>
<p>返回一对整数，其比率正好等于原浮点数并且分母为正数。 无穷大会引发 <code>OverflowError</code> 而 NaN 则会引发 <code>ValueError</code>。</p>
<p><code>float.is_integer</code>()</p>
<p>如果 float 实例可用有限位整数表示则返回 <code>True</code>，否则返回 <code>False</code>:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">2.0</span><span class="token punctuation">)</span><span class="token punctuation">.</span>is_integer<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token boolean">True</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token punctuation">(</span><span class="token number">3.2</span><span class="token punctuation">)</span><span class="token punctuation">.</span>is_integer<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>两个方法均支持与十六进制数字符串之间的转换。 由于 Python 浮点数在内部存储为二进制数，因此浮点数与 <em>十进制数</em> 字符串之间的转换往往会导致微小的舍入错误。 而十六进制数字符串却允许精确地表示和描述浮点数。 这在进行调试和数值工作时非常有用。</p>
<p><code>float.hex</code>()</p>
<p>以十六进制字符串的形式返回一个浮点数表示。 对于有限浮点数，这种表示法将总是包含前导的 <code>0x</code> 和尾随的 <code>p</code> 加指数。</p>
<p><em>classmethod</em> <code>float.fromhex</code>(<em>s</em>)</p>
<p>返回以十六进制字符串 <em>s</em> 表示的浮点数的类方法。 字符串 <em>s</em> 可以带有前导和尾随的空格。</p>
<p>请注意 <code>float.hex()</code> 是实例方法，而 <code>float.fromhex()</code> 是类方法。</p>
<p>十六进制字符串采用的形式为:</p>
<pre><code>[sign] ['0x'] integer ['.' fraction] ['p' exponent]</code></pre><p>可选的 <code>sign</code> 可以是 <code>+</code> 或 <code>-</code>，<code>integer</code> 和 <code>fraction</code> 是十六进制数码组成的字符串，<code>exponent</code> 是带有可选前导符的十进制整数。 大小写没有影响，在 integer 或 fraction 中必须至少有一个十六进制数码。 此语法类似于 C99 标准的 6.4.4.2 小节中所描述的语法，也是 Java 1.5 以上所使用的语法。 特别地，<code>float.hex()</code> 的输出可以用作 C 或 Java 代码中的十六进制浮点数字面值，而由 C 的 <code>%a</code> 格式字符或 Java 的 <code>Double.toHexString</code> 所生成的十六进制数字符串由为 <code>float.fromhex()</code> 所接受。</p>
<p>请注意 exponent 是十进制数而非十六进制数，它给出要与系数相乘的 2 的幂次。 例如，十六进制数字符串 <code>0x3.a7p10</code> 表示浮点数 <code>(3 + 10./16 + 7./16**2) * 2.0**10</code> 即 <code>3740.0</code>:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> float<span class="token punctuation">.</span>fromhex<span class="token punctuation">(</span><span class="token string">'0x3.a7p10'</span><span class="token punctuation">)</span>
<span class="token number">3740.0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>对 <code>3740.0</code> 应用反向转换会得到另一个代表相同数值的十六进制数字符串:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> float<span class="token punctuation">.</span>hex<span class="token punctuation">(</span><span class="token number">3740.0</span><span class="token punctuation">)</span>
<span class="token string">'0x1.d380000000000p+11'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h3 id="数字类型的哈希运算"><a href="#数字类型的哈希运算" class="headerlink" title="数字类型的哈希运算"></a>数字类型的哈希运算</h3><p>对于可能为不同类型的数字 <code>x</code> 和 <code>y</code>，要求 <code>x == y</code> 时必定 <code>hash(x) == hash(y)</code>。 为了便于在各种数字类型 (包括 <code>int</code>, <code>float</code>, <code>decimal.Decimal</code> 和 <code>fractions.Fraction</code>) 上实现并保证效率，Python 对数字类型的哈希运算是基于为任意有理数定义统一的数学函数，因此该运算对 <code>int</code> 和 <code>fractions.Fraction</code> 的全部实例，以及 <code>float</code> 和 <code>decimal.Decimal</code> 的全部有限实例均可用。 从本质上说，此函数是通过以一个固定质数 <code>P</code> 进行 <code>P</code> 降模给出的。 <code>P</code> 的值在 Python 中可以 <code>sys.hash_info</code> 的 <code>modulus</code> 属性的形式被访问。</p>
<p><strong>CPython implementation detail:</strong> 目前所用的质数设定，在 C long 为 32 位的机器上 <code>P = 2**31 - 1</code> 而在 C long 为 64 位的机器上 <code>P = 2**61 - 1</code>。</p>
<p>详细规则如下所述:</p>
<ul>
<li>如果 <code>x = m / n</code> 是一个非负的有理数且 <code>n</code> 不可被 <code>P</code> 整除，则定义 <code>hash(x)</code> 为 <code>m * invmod(n, P) % P</code>，其中 <code>invmod(n, P)</code> 是对 <code>n</code> 模 <code>P</code> 取反。</li>
<li>如果 <code>x = m / n</code> 是一个非负的有理数且 <code>n</code> 可被 <code>P</code> 整除（但 <code>m</code> 不能）则 <code>n</code> 不能对 <code>P</code> 降模，以上规则不适用；在此情况下则定义 <code>hash(x)</code> 为常数值 <code>sys.hash_info.inf</code>。</li>
<li>如果 <code>x = m / n</code> 是一个负的有理数则定义 <code>hash(x)</code> 为 <code>-hash(-x)</code>。 如果结果哈希值为 <code>-1</code> 则将其替换为 <code>-2</code>。</li>
<li>The particular values <code>sys.hash_info.inf</code> and <code>-sys.hash_info.inf</code> are used as hash values for positive infinity or negative infinity (respectively).</li>
<li>对于一个 <code>complex</code> 值 <code>z</code>，会通过计算 <code>hash(z.real) + sys.hash_info.imag * hash(z.imag)</code> 将实部和虚部的哈希值结合起来，并进行降模 <code>2**sys.hash_info.width</code> 以使其处于 <code>range(-2**(sys.hash_info.width - 1), 2**(sys.hash_info.width - 1))</code> 范围之内。 同样地，如果结果为 <code>-1</code> 则将其替换为 <code>-2</code>。</li>
</ul>
<p>为了阐明上述规则，这里有一些等价于内置哈希算法的 Python 代码示例，可用于计算有理数、<code>float</code> 或 <code>complex</code> 的哈希值:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> sys<span class="token punctuation">,</span> math
<span class="token keyword">def</span> <span class="token function">hash_fraction</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">"""Compute the hash of a rational number m / n.
    Assumes m and n are integers, with n positive.
    Equivalent to hash(fractions.Fraction(m, n)).
    """</span>
    P <span class="token operator">=</span> sys<span class="token punctuation">.</span>hash_info<span class="token punctuation">.</span>modulus
    <span class="token comment" spellcheck="true"># Remove common factors of P.  (Unnecessary if m and n already coprime.)</span>
    <span class="token keyword">while</span> m <span class="token operator">%</span> P <span class="token operator">==</span> n <span class="token operator">%</span> P <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>
        m<span class="token punctuation">,</span> n <span class="token operator">=</span> m <span class="token operator">//</span> P<span class="token punctuation">,</span> n <span class="token operator">//</span> P
    <span class="token keyword">if</span> n <span class="token operator">%</span> P <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>
        hash_value <span class="token operator">=</span> sys<span class="token punctuation">.</span>hash_info<span class="token punctuation">.</span>inf
    <span class="token keyword">else</span><span class="token punctuation">:</span>
        <span class="token comment" spellcheck="true"># Fermat's Little Theorem: pow(n, P-1, P) is 1, so</span>
        <span class="token comment" spellcheck="true"># pow(n, P-2, P) gives the inverse of n modulo P.</span>
        hash_value <span class="token operator">=</span> <span class="token punctuation">(</span>abs<span class="token punctuation">(</span>m<span class="token punctuation">)</span> <span class="token operator">%</span> P<span class="token punctuation">)</span> <span class="token operator">*</span> pow<span class="token punctuation">(</span>n<span class="token punctuation">,</span> P <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">,</span> P<span class="token punctuation">)</span> <span class="token operator">%</span> P
    <span class="token keyword">if</span> m <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">:</span>
        hash_value <span class="token operator">=</span> <span class="token operator">-</span>hash_value
    <span class="token keyword">if</span> hash_value <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span>
        hash_value <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">2</span>
    <span class="token keyword">return</span> hash_value
<span class="token keyword">def</span> <span class="token function">hash_float</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">"""Compute the hash of a float x."""</span>
    <span class="token keyword">if</span> math<span class="token punctuation">.</span>isnan<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> object<span class="token punctuation">.</span>__hash__<span class="token punctuation">(</span>x<span class="token punctuation">)</span>
    <span class="token keyword">elif</span> math<span class="token punctuation">.</span>isinf<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> sys<span class="token punctuation">.</span>hash_info<span class="token punctuation">.</span>inf <span class="token keyword">if</span> x <span class="token operator">></span> <span class="token number">0</span> <span class="token keyword">else</span> <span class="token operator">-</span>sys<span class="token punctuation">.</span>hash_info<span class="token punctuation">.</span>inf
    <span class="token keyword">else</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> hash_fraction<span class="token punctuation">(</span><span class="token operator">*</span>x<span class="token punctuation">.</span>as_integer_ratio<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">hash_complex</span><span class="token punctuation">(</span>z<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">"""Compute the hash of a complex number z."""</span>
    hash_value <span class="token operator">=</span> hash_float<span class="token punctuation">(</span>z<span class="token punctuation">.</span>real<span class="token punctuation">)</span> <span class="token operator">+</span> sys<span class="token punctuation">.</span>hash_info<span class="token punctuation">.</span>imag <span class="token operator">*</span> hash_float<span class="token punctuation">(</span>z<span class="token punctuation">.</span>imag<span class="token punctuation">)</span>
    <span class="token comment" spellcheck="true"># do a signed reduction modulo 2**sys.hash_info.width</span>
    M <span class="token operator">=</span> <span class="token number">2</span><span class="token operator">**</span><span class="token punctuation">(</span>sys<span class="token punctuation">.</span>hash_info<span class="token punctuation">.</span>width <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>
    hash_value <span class="token operator">=</span> <span class="token punctuation">(</span>hash_value <span class="token operator">&amp;</span> <span class="token punctuation">(</span>M <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token punctuation">(</span>hash_value <span class="token operator">&amp;</span> M<span class="token punctuation">)</span>
    <span class="token keyword">if</span> hash_value <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span>
        hash_value <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">2</span>
    <span class="token keyword">return</span> hash_value<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="迭代器类型"><a href="#迭代器类型" class="headerlink" title="迭代器类型"></a>迭代器类型</h2><p>Python 支持在容器中进行迭代的概念。 这是通过使用两个单独方法来实现的；它们被用于允许用户自定义类对迭代的支持。 将在下文中详细描述的序列总是支持迭代方法。</p>
<p>容器对象要提供迭代支持，必须定义一个方法:</p>
<p><code>container.__iter__</code>()</p>
<p>返回一个迭代器对象。 该对象需要支持下文所述的迭代器协议。 如果容器支持不同的迭代类型，则可以提供额外的方法来专门地请求不同迭代类型的迭代器。 （支持多种迭代形式的对象的例子有同时支持广度优先和深度优先遍历的树结构。） 此方法对应于 Python/C API 中 Python 对象类型结构体的 <code>tp_iter</code> 槽位。</p>
<p>迭代器对象自身需要支持以下两个方法，它们共同组成了 <em>迭代器协议</em>:</p>
<p><code>iterator.__iter__</code>()</p>
<p>返回迭代器对象本身。 这是同时允许容器和迭代器配合 <code>for</code> 和 <code>in</code> 语句使用所必须的。 此方法对应于 Python/C API 中 Python 对象类型结构体的 <code>tp_iter</code> 槽位。</p>
<p><code>iterator.__next__</code>()</p>
<p>从容器中返回下一项。 如果已经没有项可返回，则会引发 <code>StopIteration</code> 异常。 此方法对应于 Python/C API 中 Python 对象类型结构体的 <code>tp_iternext</code> 槽位。</p>
<p>Python 定义了几种迭代器对象以支持对一般和特定序列类型、字典和其他更特别的形式进行迭代。 除了迭代器协议的实现，特定类型的其他性质对迭代操作来说都不重要。</p>
<p>一旦迭代器的 <code>__next__()</code> 方法引发了 <code>StopIteration</code>，它必须一直对后续调用引发同样的异常。 不遵循此行为特性的实现将无法正常使用。</p>
<h3 id="生成器类型"><a href="#生成器类型" class="headerlink" title="生成器类型"></a>生成器类型</h3><p>Python 的 generator 提供了一种实现迭代器协议的便捷方式。 如果容器对象 <code>__iter__()</code> 方法被实现为一个生成器，它将自动返回一个迭代器对象（从技术上说是一个生成器对象），该对象提供 <code>__iter__()</code> 和 <code>__next__()</code> 方法。 </p>
<h2 id="序列类型-—-list-tuple-range"><a href="#序列类型-—-list-tuple-range" class="headerlink" title="序列类型 —- list, tuple, range"></a>序列类型 —- <code>list</code>, <code>tuple</code>, <code>range</code></h2><p>有三种基本序列类型：list, tuple 和 range 对象。 </p>
<h3 id="通用序列操作"><a href="#通用序列操作" class="headerlink" title="通用序列操作"></a>通用序列操作</h3><p>大多数序列类型，包括可变类型和不可变类型都支持下表中的操作。 <code>collections.abc.Sequence</code> ABC 被提供用来更容易地在自定义序列类型上正确地实现这些操作。</p>
<p>此表按优先级升序列出了序列操作。 在表格中，<em>s</em> 和 <em>t</em> 是具有相同类型的序列，<em>n</em>, <em>i</em>, <em>j</em> 和 <em>k</em> 是整数而 <em>x</em> 是任何满足 <em>s</em> 所规定的类型和值限制的任意对象。</p>
<p><code>in</code> 和 <code>not in</code> 操作具有与比较操作相同的优先级。 <code>+</code> (拼接) 和 <code>*</code> (重复) 操作具有与对应数值运算相同的优先级。</p>
<table>
<thead>
<tr>
<th align="left">运算</th>
<th align="left">结果：</th>
<th align="left">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>x in s</code></td>
<td align="left">如果 <em>s</em> 中的某项等于 <em>x</em> 则结果为 <code>True</code>，否则为 <code>False</code></td>
<td align="left">(1)</td>
</tr>
<tr>
<td align="left"><code>x not in s</code></td>
<td align="left">如果 <em>s</em> 中的某项等于 <em>x</em> 则结果为 <code>False</code>，否则为 <code>True</code></td>
<td align="left">(1)</td>
</tr>
<tr>
<td align="left"><code>s + t</code></td>
<td align="left"><em>s</em> 与 <em>t</em> 相拼接</td>
<td align="left">(6)(7)</td>
</tr>
<tr>
<td align="left"><code>s * n</code> <em>或 <code>n</code></em><code>s</code></td>
<td align="left">相当于 <em>s</em> 与自身进行 <em>n</em> 次拼接</td>
<td align="left">(2)(7)</td>
</tr>
<tr>
<td align="left"><code>s[i]</code></td>
<td align="left"><em>s</em> 的第 <em>i</em> 项，起始为 0</td>
<td align="left">(3)</td>
</tr>
<tr>
<td align="left"><code>s[i:j]</code></td>
<td align="left"><em>s</em> 从 <em>i</em> 到 <em>j</em> 的切片</td>
<td align="left">(3)(4)</td>
</tr>
<tr>
<td align="left"><code>s[i:j:k]</code></td>
<td align="left"><em>s</em> 从 <em>i</em> 到 <em>j</em> 步长为 <em>k</em> 的切片</td>
<td align="left">(3)(5)</td>
</tr>
<tr>
<td align="left"><code>len(s)</code></td>
<td align="left"><em>s</em> 的长度</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>min(s)</code></td>
<td align="left"><em>s</em> 的最小项</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>max(s)</code></td>
<td align="left"><em>s</em> 的最大项</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>s.index(x[, i[, j]])</code></td>
<td align="left"><em>x</em> 在 <em>s</em> 中首次出现项的索引号（索引号在 <em>i</em> 或其后且在 <em>j</em> 之前）</td>
<td align="left">(8)</td>
</tr>
<tr>
<td align="left"><code>s.count(x)</code></td>
<td align="left"><em>x</em> 在 <em>s</em> 中出现的总次数</td>
<td align="left"></td>
</tr>
</tbody></table>
<p>相同类型的序列也支持比较。 特别地，tuple 和 list 的比较是通过比较对应元素的字典顺序。 这意味着想要比较结果相等，则每个元素比较结果都必须相等，并且两个序列长度必须相同。 </p>
<p>注释：</p>
<ol>
<li><p>虽然 <code>in</code> 和 <code>not in</code> 操作在通常情况下仅被用于简单的成员检测，某些专门化序列 (例如 <code>str</code>, <code>bytes</code> 和 <code>bytearray</code>) 也使用它们进行子序列检测:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token string">"gg"</span> <span class="token keyword">in</span> <span class="token string">"eggs"</span>
<span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li><p>小于 <code>0</code> 的 <em>n</em> 值会被当作 <code>0</code> 来处理 (生成一个与 <em>s</em> 同类型的空序列)。 请注意序列 <em>s</em> 中的项并不会被拷贝；它们会被多次引用。 这一点经常会令 Python 编程新手感到困扰；例如:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> lists <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token number">3</span>
<span class="token operator">>></span><span class="token operator">></span> lists
<span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> lists<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> lists
<span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>具体的原因在于 <code>[[]]</code> 是一个包含了一个空列表的单元素列表，所以 <code>[[]] * 3</code> 结果中的三个元素都是对这一个空列表的引用。 修改 <code>lists</code> 中的任何一个元素实际上都是对这一个空列表的修改。 你可以用以下方式创建以不同列表为元素的列表:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> lists <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> lists<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> lists<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> lists<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> lists
<span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>如果 <em>i</em> 或 <em>j</em> 为负值，则索引顺序是相对于序列 <em>s</em> 的末尾: 索引号会被替换为 <code>len(s) + i</code> 或 <code>len(s) + j</code>。 但要注意 <code>-0</code> 仍然为 <code>0</code>。</p>
</li>
<li><p><em>s</em> 从 <em>i</em> 到 <em>j</em> 的切片被定义为所有满足 <code>i &lt;= k &lt; j</code> 的索引号 <em>k</em> 的项组成的序列。 如果 <em>i</em> 或 <em>j</em> 大于 <code>len(s)</code>，则使用 <code>len(s)</code>。 如果 <em>i</em> 被省略或为 <code>None</code>，则使用 <code>0</code>。 如果 <em>j</em> 被省略或为 <code>None</code>，则使用 <code>len(s)</code>。 如果 <em>i</em> 大于等于 <em>j</em>，则切片为空。</p>
</li>
<li><p><em>s</em> 从 <em>i</em> 到 <em>j</em> 步长为 <em>k</em> 的切片被定义为所有满足 <code>0 &lt;= n &lt; (j-i)/k</code> 的索引号 <code>x = i + n*k</code> 的项组成的序列。 换句话说，索引号为 <code>i</code>, <code>i+k</code>, <code>i+2*k</code>, <code>i+3*k</code>，以此类推，当达到 <em>j</em> 时停止 (但一定不包括 <em>j</em>)。 当 <em>k</em> 为正值时，<em>i</em> 和 <em>j</em> 会被减至不大于 <code>len(s)</code>。 当 <em>k</em> 为负值时，<em>i</em> 和 <em>j</em> 会被减至不大于 <code>len(s) - 1</code>。 如果 <em>i</em> 或 <em>j</em> 被省略或为 <code>None</code>，它们会成为“终止”值 (是哪一端的终止值则取决于 <em>k</em> 的符号)。 请注意，<em>k</em> 不可为零。 如果 <em>k</em> 为 <code>None</code>，则当作 <code>1</code> 处理。</p>
</li>
<li><p>拼接不可变序列总是会生成新的对象。 这意味着通过重复拼接来构建序列的运行时开销将会基于序列总长度的乘方。 想要获得线性的运行时开销，你必须改用下列替代方案之一：</p>
<ul>
<li>如果拼接 <code>str</code> 对象，你可以构建一个列表并在最后使用 <code>str.join()</code> 或是写入一个 <code>io.StringIO</code> 实例并在结束时获取它的值</li>
<li>如果拼接 <code>bytes</code> 对象，你可以类似地使用 <code>bytes.join()</code> 或 <code>io.BytesIO</code>，或者你也可以使用 <code>bytearray</code> 对象进行原地拼接。 <code>bytearray</code> 对象是可变的，并且具有高效的重分配机制</li>
<li>如果拼接 <code>tuple</code> 对象，请改为扩展 <code>list</code> 类</li>
<li>对于其它类型，请查看相应的文档</li>
</ul>
</li>
<li><p>某些序列类型 (例如 <code>range</code>) 仅支持遵循特定模式的项序列，因此并不支持序列拼接或重复。</p>
</li>
<li><p>当 <em>x</em> 在 <em>s</em> 中找不到时 <code>index</code> 会引发 <code>ValueError</code>。 不是所有实现都支持传入额外参数 <em>i</em> 和 <em>j</em>。 这两个参数允许高效地搜索序列的子序列。 传入这两个额外参数大致相当于使用 <code>s[i:j].index(x)</code>，但是不会复制任何数据，并且返回的索引是相对于序列的开头而非切片的开头。</p>
</li>
</ol>
<h3 id="不可变序列类型"><a href="#不可变序列类型" class="headerlink" title="不可变序列类型"></a>不可变序列类型</h3><p>不可变序列类型普遍实现而可变序列类型未实现的唯一操作就是对 <code>hash()</code> 内置函数的支持。</p>
<p>这种支持允许不可变类型，例如 <code>tuple</code> 实例被用作 <code>dict</code> 键，以及存储在 <code>set</code> 和 <code>frozenset</code> 实例中。</p>
<p>尝试对包含有不可哈希值的不可变序列进行哈希运算将会导致 <code>TypeError</code>。</p>
<h3 id="可变序列类型"><a href="#可变序列类型" class="headerlink" title="可变序列类型"></a>可变序列类型</h3><p>以下表格中的操作是在可变序列类型上定义的。 <code>collections.abc.MutableSequence</code> ABC 被提供用来更容易地在自定义序列类型上正确实现这些操作。</p>
<p>表格中的 <em>s</em> 是可变序列类型的实例，<em>t</em> 是任意可迭代对象，而 <em>x</em> 是符合对 <em>s</em> 所规定类型与值限制的任何对象 (例如，<code>bytearray</code> 仅接受满足 <code>0 &lt;= x &lt;= 255</code> 值限制的整数)。</p>
<table>
<thead>
<tr>
<th align="left">运算</th>
<th align="left">结果：</th>
<th align="left">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>s[i] = x</code></td>
<td align="left">将 <em>s</em> 的第 <em>i</em> 项替换为 <em>x</em></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>s[i:j] = t</code></td>
<td align="left">将 <em>s</em> 从 <em>i</em> 到 <em>j</em> 的切片替换为可迭代对象 <em>t</em> 的内容</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>del s[i:j]</code></td>
<td align="left">等同于 <code>s[i:j] = []</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>s[i:j:k] = t</code></td>
<td align="left">将 <code>s[i:j:k]</code> 的元素替换为 <em>t</em> 的元素</td>
<td align="left">(1)</td>
</tr>
<tr>
<td align="left"><code>del s[i:j:k]</code></td>
<td align="left">从列表中移除 <code>s[i:j:k]</code> 的元素</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>s.append(x)</code></td>
<td align="left">将 <em>x</em> 添加到序列的末尾 (等同于 <code>s[len(s):len(s)] = [x]</code>)</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>s.clear()</code></td>
<td align="left">从 <em>s</em> 中移除所有项 (等同于 <code>del s[:]</code>)</td>
<td align="left">(5)</td>
</tr>
<tr>
<td align="left"><code>s.copy()</code></td>
<td align="left">创建 <em>s</em> 的浅拷贝 (等同于 <code>s[:]</code>)</td>
<td align="left">(5)</td>
</tr>
<tr>
<td align="left"><code>s.extend(t)</code> 或 <code>s += t</code></td>
<td align="left">用 <em>t</em> 的内容扩展 <em>s</em> (基本上等同于 <code>s[len(s):len(s)] = t</code>)</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>s *= n</code></td>
<td align="left">使用 <em>s</em> 的内容重复 <em>n</em> 次来对其进行更新</td>
<td align="left">(6)</td>
</tr>
<tr>
<td align="left"><code>s.insert(i, x)</code></td>
<td align="left">在由 <em>i</em> 给出的索引位置将 <em>x</em> 插入 <em>s</em> (等同于 <code>s[i:i] = [x]</code>)</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>s.pop()</code> or <code>s.pop(i)</code></td>
<td align="left">提取在 <em>i</em> 位置上的项，并将其从 <em>s</em> 中移除</td>
<td align="left">(2)</td>
</tr>
<tr>
<td align="left"><code>s.remove(x)</code></td>
<td align="left">删除 <em>s</em> 中第一个 <code>s[i]</code> 等于 <em>x</em> 的项目。</td>
<td align="left">(3)</td>
</tr>
<tr>
<td align="left"><code>s.reverse()</code></td>
<td align="left">就地将列表中的元素逆序。</td>
<td align="left">(4)</td>
</tr>
</tbody></table>
<p>注释：</p>
<ol>
<li><p><em>t</em> 必须与它所替换的切片具有相同的长度。</p>
</li>
<li><p>可选参数 <em>i</em> 默认为 <code>-1</code>，因此在默认情况下会移除并返回最后一项。</p>
</li>
<li><p>当在 <em>s</em> 中找不到 <em>x</em> 时 <code>remove()</code> 操作会引发 <code>ValueError</code>。</p>
</li>
<li><p>当反转大尺寸序列时 <code>reverse()</code> 方法会原地修改该序列以保证空间经济性。 为提醒用户此操作是通过间接影响进行的，它并不会返回反转后的序列。</p>
</li>
<li><p>包括 <code>clear()</code> 和 <code>copy()</code> 是为了与不支持切片操作的可变容器 (例如 <code>dict</code> 和 <code>set</code>) 的接口保持一致。 <code>copy()</code> 不是 <code>collections.abc.MutableSequence</code> ABC 的一部分，但大多数具体的可变序列类都提供了它。</p>
<p>3.3 新版功能: <code>clear()</code> 和 <code>copy()</code> 方法。</p>
</li>
<li><p><em>n</em> 值为一个整数，或是一个实现了 <code>__index__()</code> 的对象。 <em>n</em> 值为零或负数将清空序列。 序列中的项不会被拷贝；它们会被多次引用，正如 通用序列操作 中有关 <code>s * n</code> 的说明。</p>
</li>
</ol>
<h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>列表是可变序列，通常用于存放同类项目的集合（其中精确的相似程度将根据应用而变化）。</p>
<p><em>class</em> <code>list</code>([<em>iterable</em>])</p>
<p>可以用多种方式构建列表：</p>
<ul>
<li>使用一对方括号来表示空列表: <code>[]</code></li>
<li>使用方括号，其中的项以逗号分隔: <code>[a]</code>, <code>[a, b, c]</code></li>
<li>使用列表推导式: <code>[x for x in iterable]</code></li>
<li>使用类型的构造器: <code>list()</code> 或 <code>list(iterable)</code></li>
</ul>
<p>构造器将构造一个列表，其中的项与 <em>iterable</em> 中的项具有相同的的值与顺序。 <em>iterable</em> 可以是序列、支持迭代的容器或其它可迭代对象。 如果 <em>iterable</em> 已经是一个列表，将创建并返回其副本，类似于 <code>iterable[:]</code>。 例如，<code>list('abc')</code> 返回 <code>['a', 'b', 'c']</code> 而 <code>list( (1, 2, 3) )</code> 返回 <code>[1, 2, 3]</code>。 如果没有给出参数，构造器将创建一个空列表 <code>[]</code>。</p>
<p>其它许多操作也会产生列表，包括 <code>sorted()</code> 内置函数。</p>
<p>列表实现了所有 一般 和 可变 序列的操作。 列表还额外提供了以下方法：</p>
<ul>
<li><p><code>sort</code>(<em>**,</em> key=None<em>,</em> reverse=False*)</p>
<p>此方法会对列表进行原地排序，只使用 <code>&lt;</code> 来进行各项间比较。 异常不会被屏蔽 —— 如果有任何比较操作失败，整个排序操作将失败（而列表可能会处于被部分修改的状态）。</p>
<p><code>sort()</code> 接受两个仅限以关键字形式传入的参数 (仅限关键字参数):</p>
<p><em>key</em> 指定带有一个参数的函数，用于从每个列表元素中提取比较键 (例如 <code>key=str.lower</code>)。 对应于列表中每一项的键会被计算一次，然后在整个排序过程中使用。 默认值 <code>None</code> 表示直接对列表项排序而不计算一个单独的键值。</p>
<p>可以使用 <code>functools.cmp_to_key()</code> 将 2.x 风格的 <em>cmp</em> 函数转换为 <em>key</em> 函数。</p>
<p><em>reverse</em> 为一个布尔值。 如果设为 <code>True</code>，则每个列表元素将按反向顺序比较进行排序。</p>
<p>当顺序大尺寸序列时此方法会原地修改该序列以保证空间经济性。 为提醒用户此操作是通过间接影响进行的，它并不会返回排序后的序列（请使用 <code>sorted()</code> 显示地请求一个新的已排序列表实例）。</p>
<p><code>sort()</code> 方法确保是稳定的。 如果一个排序确保不会改变比较结果相等的元素的相对顺序就称其为稳定的 —- 这有利于进行多重排序（例如先按部门、再接薪级排序）。</p>
<p><strong>CPython implementation detail:</strong> 在一个列表被排序期间，尝试改变甚至进行检测也会造成未定义的影响。 Python 的 C 实现会在排序期间将列表显示为空，如果发现列表在排序期间被改变将会引发 <code>ValueError</code>。</p>
</li>
</ul>
<h3 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h3><p>元组是不可变序列，通常用于储存异构数据的多项集（例如由 <code>enumerate()</code> 内置函数所产生的二元组）。 元组也被用于需要同构数据的不可变序列的情况（例如允许存储到 <code>set</code> 或 <code>dict</code> 的实例）。</p>
<p><em>class</em> <code>tuple</code>([<em>iterable</em>])</p>
<p>可以用多种方式构建元组：</p>
<ul>
<li>使用一对圆括号来表示空元组: <code>()</code></li>
<li>使用一个后缀的逗号来表示单元组: <code>a,</code> 或 <code>(a,)</code></li>
<li>使用以逗号分隔的多个项: <code>a, b, c</code> or <code>(a, b, c)</code></li>
<li>使用内置的 <code>tuple()</code>: <code>tuple()</code> 或 <code>tuple(iterable)</code></li>
</ul>
<p>构造器将构造一个元组，其中的项与 <em>iterable</em> 中的项具有相同的值与顺序。 <em>iterable</em> 可以是序列、支持迭代的容器或其他可迭代对象。 如果 <em>iterable</em> 已经是一个元组，会不加改变地将其返回。 例如，<code>tuple('abc')</code> 返回 <code>('a', 'b', 'c')</code> 而 <code>tuple( [1, 2, 3] )</code> 返回 <code>(1, 2, 3)</code>。 如果没有给出参数，构造器将创建一个空元组 <code>()</code>。</p>
<p>请注意决定生成元组的其实是逗号而不是圆括号。 圆括号只是可选的，生成空元组或需要避免语法歧义的情况除外。 例如，<code>f(a, b, c)</code> 是在调用函数时附带三个参数，而 <code>f((a, b, c))</code> 则是在调用函数时附带一个三元组。</p>
<p>元组实现了所有 一般 序列的操作。</p>
<p>对于通过名称访问相比通过索引访问更清晰的异构数据多项集，<code>collections.namedtuple()</code> 可能是比简单元组对象更为合适的选择。</p>
<h3 id="range-对象"><a href="#range-对象" class="headerlink" title="range 对象"></a>range 对象</h3><p><code>range</code> 类型表示不可变的数字序列，通常用于在 <code>for</code> 循环中循环指定的次数。</p>
<p><em>class</em> <code>range</code>(<em>stop</em>)</p>
<p><em>class</em> <code>range</code>(<em>start</em>, <em>stop</em>[, <em>step</em>])</p>
<p>range 构造器的参数必须为整数（可以是内置的 <code>int</code> 或任何实现了 <code>__index__</code> 特殊方法的对象）。 如果省略 <em>step</em> 参数，其默认值为 <code>1</code>。 如果省略 <em>start</em> 参数，其默认值为 <code>0</code>，如果 <em>step</em> 为零则会引发 <code>ValueError</code>。</p>
<p>如果 <em>step</em> 为正值，确定 range <code>r</code> 内容的公式为 <code>r[i] = start + step*i</code> 其中 <code>i &gt;= 0</code> 且 <code>r[i] &lt; stop</code>。</p>
<p>如果 <em>step</em> 为负值，确定 range 内容的公式仍然为 <code>r[i] = start + step*i</code>，但限制条件改为 <code>i &gt;= 0</code> 且 <code>r[i] &gt; stop</code>.</p>
<p>如果 <code>r[0]</code> 不符合值的限制条件，则该 range 对象为空。 range 对象确实支持负索引，但是会将其解读为从正索引所确定的序列的末尾开始索引。</p>
<p>元素绝对值大于 <code>sys.maxsize</code> 的 range 对象是被允许的，但某些特性 (例如 <code>len()</code>) 可能引发 <code>OverflowError</code>。</p>
<p>一些 range 对象的例子:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> list<span class="token punctuation">(</span>range<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> list<span class="token punctuation">(</span>range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> list<span class="token punctuation">(</span>range<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">25</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> list<span class="token punctuation">(</span>range<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> list<span class="token punctuation">(</span>range<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">6</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">7</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">8</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">9</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> list<span class="token punctuation">(</span>range<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> list<span class="token punctuation">(</span>range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>range 对象实现了 一般 序列的所有操作，但拼接和重复除外（这是由于 range 对象只能表示符合严格模式的序列，而重复和拼接通常都会违反这样的模式）。</p>
<ul>
<li><p><code>start</code></p>
<p><em>start</em> 形参的值 (如果该形参未提供则为 <code>0</code>)</p>
</li>
<li><p><code>stop</code></p>
<p><em>stop</em> 形参的值</p>
</li>
<li><p><code>step</code></p>
<p><em>step</em> 形参的值 (如果该形参未提供则为 <code>1</code>)</p>
</li>
</ul>
<p><code>range</code> 类型相比常规 <code>list</code> 或 <code>tuple</code> 的优势在于一个 <code>range</code> 对象总是占用固定数量的（较小）内存，不论其所表示的范围有多大（因为它只保存了 <code>start</code>, <code>stop</code> 和 <code>step</code> 值，并会根据需要计算具体单项或子范围的值）。</p>
<p>range 对象实现了 <code>collections.abc.Sequence</code> ABC，提供如包含检测、元素索引查找、切片等特性，并支持负索引 :</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> r <span class="token operator">=</span> range<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> r
range<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token number">11</span> <span class="token keyword">in</span> r
<span class="token boolean">False</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token number">10</span> <span class="token keyword">in</span> r
<span class="token boolean">True</span>
<span class="token operator">>></span><span class="token operator">></span> r<span class="token punctuation">.</span>index<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span>
<span class="token number">5</span>
<span class="token operator">>></span><span class="token operator">></span> r<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span>
<span class="token number">10</span>
<span class="token operator">>></span><span class="token operator">></span> r<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">5</span><span class="token punctuation">]</span>
range<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> r<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>
<span class="token number">18</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>使用 <code>==</code> 和 <code>!=</code> 检测 range 对象是否相等是将其作为序列来比较。 也就是说，如果两个 range 对象表示相同的值序列就认为它们是相等的。 （请注意比较结果相等的两个 range 对象可能会具有不同的 <code>start</code>, <code>stop</code> 和 <code>step</code> 属性，例如 <code>range(0) == range(2, 1, 3)</code> 而 <code>range(0, 3, 2) == range(0, 4, 2)</code>。）</p>
<p>在 3.2 版更改: 实现 Sequence ABC。 支持切片和负数索引。 使用 <code>int</code> 对象在固定时间内进行成员检测，而不是逐一迭代所有项。</p>
<p>在 3.3 版更改: 定义 ‘==’ 和 ‘!=’ 以根据 range 对象所定义的值序列来进行比较（而不是根据对象的标识）。</p>
<p>3.3 新版功能: <code>start</code>, <code>stop</code> 和 <code>step</code> 属性。</p>
<p>参见</p>
<ul>
<li>linspace recipe 演示了如何实现一个延迟求值版本的适合浮点数应用的 range 对象。</li>
</ul>
<h2 id="文本序列类型-—-str"><a href="#文本序列类型-—-str" class="headerlink" title="文本序列类型 —- str"></a>文本序列类型 —- <code>str</code></h2><p>在 Python 中处理文本数据是使用 <code>str</code> 对象，也称为 <em>字符串</em>。 字符串是由 Unicode 码位构成的不可变 序列。 字符串字面值有多种不同的写法：</p>
<ul>
<li>单引号: <code>'允许包含有 "双" 引号'</code></li>
<li>双引号: <code>"允许包含有 '单' 引号"</code>。</li>
<li>三重引号: <code>'''三重单引号'''</code>, <code>"""三重双引号"""</code></li>
</ul>
<p>使用三重引号的字符串可以跨越多行 —— 其中所有的空白字符都将包含在该字符串字面值中。</p>
<p>作为单一表达式组成部分，之间只由空格分隔的多个字符串字面值会被隐式地转换为单个字符串字面值。 也就是说，<code>("spam " "eggs") == "spam eggs"</code>。</p>
<p>使用 <code>r</code> (“raw”) 前缀来禁用大多数转义序列的处理。</p>
<p>字符串也可以通过使用 <code>str</code> 构造器从其他对象创建。</p>
<p>由于不存在单独的“字符”类型，对字符串做索引操作将产生一个长度为 1 的字符串。 也就是说，对于一个非空字符串 <em>s</em>, <code>s[0] == s[0:1]</code>。</p>
<p>不存在可变的字符串类型，但是 <code>str.join()</code> 或 <code>io.StringIO</code> 可以被被用来根据多个片段高效率地构建字符串。</p>
<p>在 3.3 版更改: 为了与 Python 2 系列的向下兼容，再次允许字符串字面值使用 <code>u</code> 前缀。 它对字符串字面值的含义没有影响，并且不能与 <code>r</code> 前缀同时出现。</p>
<p><em>class</em> <code>str</code>(<em>object=’’</em>)</p>
<p><em>class</em> <code>str</code>(<em>object=b’’</em>, <em>encoding=’utf-8’</em>, <em>errors=’strict’</em>)</p>
<p>返回 <em>object</em> 的 字符串 版本。 如果未提供 <em>object</em> 则返回空字符串。 在其他情况下 <code>str()</code> 的行为取决于 <em>encoding</em> 或 <em>errors</em> 是否有给出，具体见下。</p>
<p>如果 <em>encoding</em> 或 <em>errors</em> 均未给出，<code>str(object)</code> 返回 <code>object.__str__()</code>，这是 <em>object</em> 的“非正式”或格式良好的字符串表示。 对于字符串对象，这是该字符串本身。 如果 <em>object</em> 没有 <code>__str__()</code> 方法，则 <code>str()</code> 将回退为返回 <code>repr(object)</code>。</p>
<p>如果 <em>encoding</em> 或 <em>errors</em> 至少给出其中之一，则 <em>object</em> 应该是一个 bytes-like object (例如 <code>bytes</code> 或 <code>bytearray</code>)。 在此情况下，如果 <em>object</em> 是一个 <code>bytes</code> (或 <code>bytearray</code>) 对象，则 <code>str(bytes, encoding, errors)</code> 等价于 <code>bytes.decode(encoding, errors)</code>。 否则的话，会在调用 <code>bytes.decode()</code> 之前获取缓冲区对象下层的 bytes 对象。 </p>
<p>将一个 <code>bytes</code> 对象传入 <code>str()</code> 而不给出 <em>encoding</em> 或 <em>errors</em> 参数的操作属于第一种情况， 将返回非正式的字符串表示（另请参阅 Python 的 <code>-b</code> 命令行选项）。 例如:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> str<span class="token punctuation">(</span>b<span class="token string">'Zoot!'</span><span class="token punctuation">)</span>
<span class="token string">"b'Zoot!'"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h3 id="字符串的方法"><a href="#字符串的方法" class="headerlink" title="字符串的方法"></a>字符串的方法</h3><p>字符串实现了所有 一般 序列的操作，还额外提供了以下列出的一些附加方法。</p>
<p>字符串还支持两种字符串格式化样式，一种提供了很大程度的灵活性和可定制性 而另一种是基于 C <code>printf</code> 样式的格式化，它可处理的类型范围较窄，并且更难以正确使用，但对于它可处理的情况往往会更为快速 (printf 风格的字符串格式化)。</p>
<p>标准库的 文本处理服务 部分涵盖了许多其他模块，提供各种文本相关工具（例如包含于 <code>re</code> 模块中的正则表达式支持）。</p>
<p><code>str.capitalize</code>()</p>
<p>返回原字符串的副本，其首个字符大写，其余为小写。</p>
<p>在 3.8 版更改: 第一个字符现在被放入了 titlecase 而不是 uppercase。 这意味着复合字母类字符将只有首个字母改为大写，而再不是全部字符大写。</p>
<p><code>str.casefold</code>()</p>
<p>返回原字符串消除大小写的副本。 消除大小写的字符串可用于忽略大小写的匹配。</p>
<p>消除大小写类似于转为小写，但是更加彻底一些，因为它会移除字符串中的所有大小写变化形式。 例如，德语小写字母 <code>'ß'</code> 相当于 <code>"ss"</code>。 由于它已经是小写了，<code>lower()</code> 不会对 <code>'ß'</code> 做任何改变；而 <code>casefold()</code> 则会将其转换为 <code>"ss"</code>。</p>
<p>消除大小写算法的描述请参见 Unicode 标准的 3.13 节。</p>
<p>3.3 新版功能.</p>
<p><code>str.center</code>(<em>width</em>[, <em>fillchar</em>])</p>
<p>返回长度为 <em>width</em> 的字符串，原字符串在其正中。 使用指定的 <em>fillchar</em> 填充两边的空位（默认使用 ASCII 空格符）。 如果 <em>width</em> 小于等于 <code>len(s)</code> 则返回原字符串的副本。</p>
<p><code>str.count</code>(<em>sub</em>[, <em>start</em>[, <em>end</em>]])</p>
<p>返回子字符串 <em>sub</em> 在 [<em>start</em>, <em>end*] 范围内非重叠出现的次数。 可选参数 *start</em> 与 <em>end</em> 会被解读为切片表示法。</p>
<p><code>str.encode</code>(<em>encoding=’utf-8’</em>, <em>errors=’strict’</em>)</p>
<p>返回原字符串编码为字节串对象的版本。 默认编码为 <code>'utf-8'</code>。 可以给出 <em>errors</em> 来设置不同的错误处理方案。 <em>errors</em> 的默认值为 <code>'strict'</code>，表示编码错误会引发 <code>UnicodeError</code>。 其他可用的值为 <code>'ignore'</code>, <code>'replace'</code>, <code>'xmlcharrefreplace'</code>, <code>'backslashreplace'</code> 以及任何其他通过 <code>codecs.register_error()</code> 注册的值。 要查看可用的编码列表。</p>
<p>By default, the <em>errors</em> argument is not checked for best performances, but only used at the first encoding error. Enable the Python Development Mode, or use a debug build to check <em>errors</em>.</p>
<p>在 3.1 版更改: 加入了对关键字参数的支持。</p>
<p>在 3.9 版更改: The <em>errors</em> is now checked in development mode and in debug mode.</p>
<p><code>str.endswith</code>(<em>suffix</em>[, <em>start</em>[, <em>end</em>]])</p>
<p>如果字符串以指定的 <em>suffix</em> 结束返回 <code>True</code>，否则返回 <code>False</code>。 <em>suffix</em> 也可以为由多个供查找的后缀构成的元组。 如果有可选项 <em>start</em>，将从所指定位置开始检查。 如果有可选项 <em>end</em>，将在所指定位置停止比较。</p>
<p><code>str.expandtabs</code>(<em>tabsize=8</em>)</p>
<p>返回字符串的副本，其中所有的制表符会由一个或多个空格替换，具体取决于当前列位置和给定的制表符宽度。 每 <em>tabsize</em> 个字符设为一个制表位（默认值 8 时设定的制表位在列 0, 8, 16 依次类推）。 要展开字符串，当前列将被设为零并逐一检查字符串中的每个字符。 如果字符为制表符 (<code>\t</code>)，则会在结果中插入一个或多个空格符，直到当前列等于下一个制表位。 （制表符本身不会被复制。） 如果字符为换行符 (<code>\n</code>) 或回车符 (<code>\r</code>)，它会被复制并将当前列重设为零。 任何其他字符会被不加修改地复制并将当前列加一，不论该字符在被打印时会如何显示。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token string">'01\t012\t0123\t01234'</span><span class="token punctuation">.</span>expandtabs<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token string">'01      012     0123    01234'</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token string">'01\t012\t0123\t01234'</span><span class="token punctuation">.</span>expandtabs<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span>
<span class="token string">'01  012 0123    01234'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>str.find</code>(<em>sub</em>[, <em>start</em>[, <em>end</em>]])</p>
<p>返回子字符串 <em>sub</em> 在 <code>s[start:end]</code> 切片内被找到的最小索引。 可选参数 <em>start</em> 与 <em>end</em> 会被解读为切片表示法。 如果 <em>sub</em> 未被找到则返回 <code>-1</code>。</p>
<p>注解</p>
<p><code>find()</code> 方法应该只在你需要知道 <em>sub</em> 所在位置时使用。 要检查 <em>sub</em> 是否为子字符串，请使用 <code>in</code> 操作符:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token string">'Py'</span> <span class="token keyword">in</span> <span class="token string">'Python'</span>
<span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><code>str.format</code>(<em>\</em>args<em>,</em> <em>*kwargs</em>)</p>
<p>执行字符串格式化操作。 调用此方法的字符串可以包含字符串字面值或者以花括号 <code>{}</code> 括起来的替换域。 每个替换域可以包含一个位置参数的数字索引，或者一个关键字参数的名称。 返回的字符串副本中每个替换域都会被替换为对应参数的字符串值。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token string">"The sum of 1 + 2 is {0}"</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">)</span>
<span class="token string">'The sum of 1 + 2 is 3'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>请参阅 格式字符串语法 了解有关可以在格式字符串中指定的各种格式选项的说明。</p>
<p>注解</p>
<p>当使用 <code>n</code> 类型 (例如: <code>'{:n}'.format(1234)</code>) 来格式化数字 (<code>int</code>, <code>float</code>, <code>complex</code>, <code>decimal.Decimal</code> 及其子类) 的时候，该函数会临时性地将 <code>LC_CTYPE</code> 区域设置为 <code>LC_NUMERIC</code> 区域以解码 <code>localeconv()</code> 的 <code>decimal_point</code> 和 <code>thousands_sep</code> 字段，如果它们是非 ASCII 字符或长度超过 1 字节的话，并且 <code>LC_NUMERIC</code> 区域会与 <code>LC_CTYPE</code> 区域不一致。 这个临时更改会影响其他线程。</p>
<p>在 3.7 版更改: 当使用 <code>n</code> 类型格式化数字时，该函数在某些情况下会临时性地将 <code>LC_CTYPE</code> 区域设置为 <code>LC_NUMERIC</code> 区域。</p>
<p><code>str.format_map</code>(<em>mapping</em>)</p>
<p>类似于 <code>str.format(**mapping)</code>，不同之处在于 <code>mapping</code> 会被直接使用而不是复制到一个 <code>dict</code>。 适宜使用此方法的一个例子是当 <code>mapping</code> 为 dict 的子类的情况：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">class</span> <span class="token class-name">Default</span><span class="token punctuation">(</span>dict<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">def</span> <span class="token function">__missing__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         <span class="token keyword">return</span> key
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token string">'{name} was born in {country}'</span><span class="token punctuation">.</span>format_map<span class="token punctuation">(</span>Default<span class="token punctuation">(</span>name<span class="token operator">=</span><span class="token string">'Guido'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token string">'Guido was born in country'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>3.2 新版功能.</p>
<p><code>str.index</code>(<em>sub</em>[, <em>start</em>[, <em>end</em>]])</p>
<p>类似于 <code>find()</code>，但在找不到子类时会引发 <code>ValueError</code>。</p>
<p><code>str.isalnum</code>()</p>
<p>如果字符串中的所有字符都是字母或数字且至少有一个字符，则返回 <code>True</code> ， 否则返回 <code>False</code> 。 如果 <code>c.isalpha()</code> ， <code>c.isdecimal()</code> ， <code>c.isdigit()</code> ，或 <code>c.isnumeric()</code> 之中有一个返回 <code>True</code> ，则字符<code>c</code>是字母或数字。</p>
<p><code>str.isalpha</code>()</p>
<p>如果字符串中的所有字符都是字母，并且至少有一个字符，返回 <code>True</code> ，否则返回 <code>False</code> 。字母字符是指那些在 Unicode 字符数据库中定义为 “Letter” 的字符，即那些具有 “Lm”、”Lt”、”Lu”、”Ll” 或 “Lo” 之一的通用类别属性的字符。 注意，这与 Unicode 标准中定义的”字母”属性不同。</p>
<p><code>str.isascii</code>()</p>
<p>如果字符串为空或字符串中的所有字符都是 ASCII ，返回 <code>True</code> ，否则返回 <code>False</code> 。ASCII 字符的码点范围是 U+0000-U+007F 。</p>
<p>3.7 新版功能.</p>
<p><code>str.isdecimal</code>()</p>
<p>如果字符串中的所有字符都是十进制字符且该字符串至少有一个字符，则返回 <code>True</code> ， 否则返回 <code>False</code> 。十进制字符指那些可以用来组成10进制数字的字符，例如 U+0660 ，即阿拉伯字母数字0 。 严格地讲，十进制字符是 Unicode 通用类别 “Nd” 中的一个字符。</p>
<p><code>str.isdigit</code>()</p>
<p>如果字符串中的所有字符都是数字，并且至少有一个字符，返回 <code>True</code> ，否则返回 <code>False</code> 。 数字包括十进制字符和需要特殊处理的数字，如兼容性上标数字。这包括了不能用来组成 10 进制数的数字，如 Kharosthi 数。 严格地讲，数字是指属性值为 Numeric_Type=Digit 或 Numeric_Type=Decimal 的字符。</p>
<p><code>str.isidentifier</code>()</p>
<p>如果字符串是有效的标识符，返回 <code>True</code> ，依据语言定义， 标识符和关键字 节。</p>
<p>调用 <code>keyword.iskeyword()</code> 来检测字符串 <code>s</code> 是否为保留标识符，例如 <code>def</code> 和 <code>class</code>。</p>
<p>示例：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> keyword <span class="token keyword">import</span> iskeyword
<span class="token operator">>></span><span class="token operator">></span> <span class="token string">'hello'</span><span class="token punctuation">.</span>isidentifier<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> iskeyword<span class="token punctuation">(</span><span class="token string">'hello'</span><span class="token punctuation">)</span>
<span class="token boolean">True</span><span class="token punctuation">,</span> <span class="token boolean">False</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token string">'def'</span><span class="token punctuation">.</span>isidentifier<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> iskeyword<span class="token punctuation">(</span><span class="token string">'def'</span><span class="token punctuation">)</span>
<span class="token boolean">True</span><span class="token punctuation">,</span> <span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>str.islower</code>()</p>
<p>如果字符串中至少有一个区分大小写的字符 且此类字符均为小写则返回 <code>True</code> ，否则返回 <code>False</code> 。</p>
<p><code>str.isnumeric</code>()</p>
<p>如果字符串中至少有一个字符且所有字符均为数值字符则返回 <code>True</code> ，否则返回 <code>False</code> 。 数值字符包括数字字符，以及所有在 Unicode 中设置了数值特性属性的字符，例如 U+2155, VULGAR FRACTION ONE FIFTH。 正式的定义为：数值字符就是具有特征属性值 Numeric_Type=Digit, Numeric_Type=Decimal 或 Numeric_Type=Numeric 的字符。</p>
<p><code>str.isprintable</code>()</p>
<p>如果字符串中所有字符均为可打印字符或字符串为空则返回 <code>True</code> ，否则返回 <code>False</code> 。 不可打印字符是在 Unicode 字符数据库中被定义为 “Other” 或 “Separator” 的字符，例外情况是 ASCII 空格字符 (0x20) 被视作可打印字符。 （请注意在此语境下可打印字符是指当对一个字符串发起调用 <code>repr()</code> 时不必被转义的字符。 它们与字符串写入 <code>sys.stdout</code> 或 <code>sys.stderr</code> 时所需的处理无关。）</p>
<p><code>str.isspace</code>()</p>
<p>如果字符串中只有空白字符且至少有一个字符则返回 <code>True</code> ，否则返回 <code>False</code> 。</p>
<p><em>空白</em> 字符是指在 Unicode 字符数据库 中主要类别为 <code>Zs</code> (“Separator, space”) 或所属双向类为 <code>WS</code>, <code>B</code> 或 <code>S</code> 的字符。</p>
<p><code>str.istitle</code>()</p>
<p>如果字符串中至少有一个字符且为标题字符串则返回 <code>True</code> ，例如大写字符之后只能带非大写字符而小写字符必须有大写字符打头。 否则返回 <code>False</code> 。</p>
<p><code>str.isupper</code>()</p>
<p>如果字符串中至少有一个区分大小写的字符 且此类字符均为大写则返回 <code>True</code> ，否则返回 <code>False</code> 。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token string">'BANANA'</span><span class="token punctuation">.</span>isupper<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token boolean">True</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token string">'banana'</span><span class="token punctuation">.</span>isupper<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token boolean">False</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token string">'baNana'</span><span class="token punctuation">.</span>isupper<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token boolean">False</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token string">' '</span><span class="token punctuation">.</span>isupper<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>str.join</code>(<em>iterable</em>)</p>
<p>返回一个由 <em>iterable</em> 中的字符串拼接而成的字符串。 如果 <em>iterable</em> 中存在任何非字符串值包括 <code>bytes</code> 对象则会引发 <code>TypeError</code>。 调用该方法的字符串将作为元素之间的分隔。</p>
<p><code>str.ljust</code>(<em>width</em>[, <em>fillchar</em>])</p>
<p>返回长度为 <em>width</em> 的字符串，原字符串在其中靠左对齐。 使用指定的 <em>fillchar</em> 填充空位 (默认使用 ASCII 空格符)。 如果 <em>width</em> 小于等于 <code>len(s)</code> 则返回原字符串的副本。</p>
<p><code>str.lower</code>()</p>
<p>返回原字符串的副本，其所有区分大小写的字符 均转换为小写。</p>
<p>所用转换小写算法的描述请参见 Unicode 标准的 3.13 节。</p>
<p><code>str.lstrip</code>([<em>chars</em>])</p>
<p>返回原字符串的副本，移除其中的前导字符。 <em>chars</em> 参数为指定要移除字符的字符串。 如果省略或为 <code>None</code>，则 <em>chars</em> 参数默认移除空白符。 实际上 <em>chars</em> 参数并非指定单个前缀；而是会移除参数值的所有组合:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token string">'   spacious   '</span><span class="token punctuation">.</span>lstrip<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token string">'spacious   '</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token string">'www.example.com'</span><span class="token punctuation">.</span>lstrip<span class="token punctuation">(</span><span class="token string">'cmowz.'</span><span class="token punctuation">)</span>
<span class="token string">'example.com'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>参见 <code>str.removeprefix()</code> ，该方法将删除单个前缀字符串，而不是全部给定集合中的字符。 例如:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token string">'Arthur: three!'</span><span class="token punctuation">.</span>lstrip<span class="token punctuation">(</span><span class="token string">'Arthur: '</span><span class="token punctuation">)</span>
<span class="token string">'ee!'</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token string">'Arthur: three!'</span><span class="token punctuation">.</span>removeprefix<span class="token punctuation">(</span><span class="token string">'Arthur: '</span><span class="token punctuation">)</span>
<span class="token string">'three!'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p><em>static</em> <code>str.maketrans</code>(<em>x</em>[, <em>y</em>[, <em>z</em>]])</p>
<p>此静态方法返回一个可供 <code>str.translate()</code> 使用的转换对照表。</p>
<p>如果只有一个参数，则它必须是一个将 Unicode 码位序号（整数）或字符（长度为 1 的字符串）映射到 Unicode 码位序号、（任意长度的）字符串或 <code>None</code> 的字典。 字符键将会被转换为码位序号。</p>
<p>如果有两个参数，则它们必须是两个长度相等的字符串，并且在结果字典中，x 中每个字符将被映射到 y 中相同位置的字符。 如果有第三个参数，它必须是一个字符串，其中的字符将在结果中被映射到 <code>None</code>。</p>
<p><code>str.partition</code>(<em>sep</em>)</p>
<p>在 <em>sep</em> 首次出现的位置拆分字符串，返回一个 3 元组，其中包含分隔符之前的部分、分隔符本身，以及分隔符之后的部分。 如果分隔符未找到，则返回的 3 元组中包含字符本身以及两个空字符串。</p>
<p><code>str.removeprefix</code>(<em>prefix</em>, <em>/</em>)</p>
<p>如果字符串以 <em>前缀</em> 字符串开头，返回 <code>string[len(prefix):]</code> 。否则，返回原始字符串的副本：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token string">'TestHook'</span><span class="token punctuation">.</span>removeprefix<span class="token punctuation">(</span><span class="token string">'Test'</span><span class="token punctuation">)</span>
<span class="token string">'Hook'</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token string">'BaseTestCase'</span><span class="token punctuation">.</span>removeprefix<span class="token punctuation">(</span><span class="token string">'Test'</span><span class="token punctuation">)</span>
<span class="token string">'BaseTestCase'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>3.9 新版功能.</p>
<p><code>str.removesuffix</code>(<em>suffix</em>, <em>/</em>)</p>
<p>如果字符串以 <em>后缀</em> 字符串结尾，并且 <em>后缀</em> 非空，返回 <code>string[:-len(suffix)]</code> 。否则，返回原始字符串的副本：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token string">'MiscTests'</span><span class="token punctuation">.</span>removesuffix<span class="token punctuation">(</span><span class="token string">'Tests'</span><span class="token punctuation">)</span>
<span class="token string">'Misc'</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token string">'TmpDirMixin'</span><span class="token punctuation">.</span>removesuffix<span class="token punctuation">(</span><span class="token string">'Tests'</span><span class="token punctuation">)</span>
<span class="token string">'TmpDirMixin'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>3.9 新版功能.</p>
<p><code>str.replace</code>(<em>old</em>, <em>new</em>[, <em>count</em>])</p>
<p>返回字符串的副本，其中出现的所有子字符串 <em>old</em> 都将被替换为 <em>new<em>。 如果给出了可选参数 *count</em>，则只替换前 *count</em> 次出现。</p>
<p><code>str.rfind</code>(<em>sub</em>[, <em>start</em>[, <em>end</em>]])</p>
<p>返回子字符串 <em>sub</em> 在字符串内被找到的最大（最右）索引，这样 <em>sub</em> 将包含在 <code>s[start:end]</code> 当中。 可选参数 <em>start</em> 与 <em>end</em> 会被解读为切片表示法。 如果未找到则返回 <code>-1</code>。</p>
<p><code>str.rindex</code>(<em>sub</em>[, <em>start</em>[, <em>end</em>]])</p>
<p>类似于 <code>rfind()</code>，但在子字符串 <em>sub</em> 未找到时会引发 <code>ValueError</code>。</p>
<p><code>str.rjust</code>(<em>width</em>[, <em>fillchar</em>])</p>
<p>返回长度为 <em>width</em> 的字符串，原字符串在其中靠右对齐。 使用指定的 <em>fillchar</em> 填充空位 (默认使用 ASCII 空格符)。 如果 <em>width</em> 小于等于 <code>len(s)</code> 则返回原字符串的副本。</p>
<p><code>str.rpartition</code>(<em>sep</em>)</p>
<p>在 <em>sep</em> 最后一次出现的位置拆分字符串，返回一个 3 元组，其中包含分隔符之前的部分、分隔符本身，以及分隔符之后的部分。 如果分隔符未找到，则返回的 3 元组中包含两个空字符串以及字符串本身。</p>
<p><code>str.rsplit</code>(<em>sep=None</em>, <em>maxsplit=- 1</em>)</p>
<p>返回一个由字符串内单词组成的列表，使用 <em>sep</em> 作为分隔字符串。 如果给出了 <em>maxsplit*，则最多进行 *maxsplit</em> 次拆分，从 <em>最右边</em> 开始。 如果 <em>sep</em> 未指定或为 <code>None</code>，任何空白字符串都会被作为分隔符。 除了从右边开始拆分，<code>rsplit()</code> 的其他行为都类似于下文所述的 <code>split()</code>。</p>
<p><code>str.rstrip</code>([<em>chars</em>])</p>
<p>返回原字符串的副本，移除其中的末尾字符。 <em>chars</em> 参数为指定要移除字符的字符串。 如果省略或为 <code>None</code>，则 <em>chars</em> 参数默认移除空白符。 实际上 <em>chars</em> 参数并非指定单个后缀；而是会移除参数值的所有组合:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token string">'   spacious   '</span><span class="token punctuation">.</span>rstrip<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token string">'   spacious'</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token string">'mississippi'</span><span class="token punctuation">.</span>rstrip<span class="token punctuation">(</span><span class="token string">'ipz'</span><span class="token punctuation">)</span>
<span class="token string">'mississ'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>要删除单个后缀字符串，而不是全部给定集合中的字符。 例如:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token string">'Monty Python'</span><span class="token punctuation">.</span>rstrip<span class="token punctuation">(</span><span class="token string">' Python'</span><span class="token punctuation">)</span>
<span class="token string">'M'</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token string">'Monty Python'</span><span class="token punctuation">.</span>removesuffix<span class="token punctuation">(</span><span class="token string">' Python'</span><span class="token punctuation">)</span>
<span class="token string">'Monty'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>str.split</code>(<em>sep=None</em>, <em>maxsplit=- 1</em>)</p>
<p>返回一个由字符串内单词组成的列表，使用 <em>sep</em> 作为分隔字符串。 如果给出了 <em>maxsplit*，则最多进行 *maxsplit</em> 次拆分（因此，列表最多会有 <code>maxsplit+1</code> 个元素）。 如果 <em>maxsplit</em> 未指定或为 <code>-1</code>，则不限制拆分次数（进行所有可能的拆分）。</p>
<p>如果给出了 <em>sep*，则连续的分隔符不会被组合在一起而是被视为分隔空字符串 (例如 <code>'1,,2'.split(',')</code> 将返回 <code>['1', '', '2']</code>)。 *sep</em> 参数可能由多个字符组成 (例如 <code>'1&lt;&gt;2&lt;&gt;3'.split('&lt;&gt;')</code> 将返回 <code>['1', '2', '3']</code>)。 使用指定的分隔符拆分空字符串将返回 <code>['']</code>。</p>
<p>例如：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token string">'1,2,3'</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">','</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token string">'1'</span><span class="token punctuation">,</span> <span class="token string">'2'</span><span class="token punctuation">,</span> <span class="token string">'3'</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token string">'1,2,3'</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">','</span><span class="token punctuation">,</span> maxsplit<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token string">'1'</span><span class="token punctuation">,</span> <span class="token string">'2,3'</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token string">'1,2,,3,'</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">','</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token string">'1'</span><span class="token punctuation">,</span> <span class="token string">'2'</span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">,</span> <span class="token string">'3'</span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果 <em>sep</em> 未指定或为 <code>None</code>，则会应用另一种拆分算法：连续的空格会被视为单个分隔符，其结果将不包含开头或末尾的空字符串，如果字符串包含前缀或后缀空格的话。 因此，使用 <code>None</code> 拆分空字符串或仅包含空格的字符串将返回 <code>[]</code>。</p>
<p>例如：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token string">'1 2 3'</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token string">'1'</span><span class="token punctuation">,</span> <span class="token string">'2'</span><span class="token punctuation">,</span> <span class="token string">'3'</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token string">'1 2 3'</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span>maxsplit<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token string">'1'</span><span class="token punctuation">,</span> <span class="token string">'2 3'</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token string">'   1   2   3   '</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token string">'1'</span><span class="token punctuation">,</span> <span class="token string">'2'</span><span class="token punctuation">,</span> <span class="token string">'3'</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>str.splitlines</code>([<em>keepends</em>])</p>
<p>返回由原字符串中各行组成的列表，在行边界的位置拆分。 结果列表中不包含行边界，除非给出了 <em>keepends</em> 且为真值。</p>
<p>此方法会以下列行边界进行拆分。 特别地，行边界是 universal newlines 的一个超集。</p>
<table>
<thead>
<tr>
<th align="left">表示符</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>\n</code></td>
<td align="left">换行</td>
</tr>
<tr>
<td align="left"><code>\r</code></td>
<td align="left">回车</td>
</tr>
<tr>
<td align="left"><code>\r\n</code></td>
<td align="left">回车 + 换行</td>
</tr>
<tr>
<td align="left"><code>\v</code> 或 <code>\x0b</code></td>
<td align="left">行制表符</td>
</tr>
<tr>
<td align="left"><code>\f</code> 或 <code>\x0c</code></td>
<td align="left">换表单</td>
</tr>
<tr>
<td align="left"><code>\x1c</code></td>
<td align="left">文件分隔符</td>
</tr>
<tr>
<td align="left"><code>\x1d</code></td>
<td align="left">组分隔符</td>
</tr>
<tr>
<td align="left"><code>\x1e</code></td>
<td align="left">记录分隔符</td>
</tr>
<tr>
<td align="left"><code>\x85</code></td>
<td align="left">下一行 (C1 控制码)</td>
</tr>
<tr>
<td align="left"><code>\u2028</code></td>
<td align="left">行分隔符</td>
</tr>
<tr>
<td align="left"><code>\u2029</code></td>
<td align="left">段分隔符</td>
</tr>
</tbody></table>
<p>在 3.2 版更改: <code>\v</code> 和 <code>\f</code> 被添加到行边界列表</p>
<p>例如：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token string">'ab c\n\nde fg\rkl\r\n'</span><span class="token punctuation">.</span>splitlines<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token string">'ab c'</span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">,</span> <span class="token string">'de fg'</span><span class="token punctuation">,</span> <span class="token string">'kl'</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token string">'ab c\n\nde fg\rkl\r\n'</span><span class="token punctuation">.</span>splitlines<span class="token punctuation">(</span>keepends<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token string">'ab c\n'</span><span class="token punctuation">,</span> <span class="token string">'\n'</span><span class="token punctuation">,</span> <span class="token string">'de fg\r'</span><span class="token punctuation">,</span> <span class="token string">'kl\r\n'</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>不同于 <code>split()</code>，当给出了分隔字符串 <em>sep</em> 时，对于空字符串此方法将返回一个空列表，而末尾的换行不会令结果中增加额外的行:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token string">""</span><span class="token punctuation">.</span>splitlines<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token string">"One line\n"</span><span class="token punctuation">.</span>splitlines<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token string">'One line'</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>作为比较，<code>split('\n')</code> 的结果为:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token string">''</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">'\n'</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token string">''</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token string">'Two lines\n'</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">'\n'</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token string">'Two lines'</span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>str.startswith</code>(<em>prefix</em>[, <em>start</em>[, <em>end</em>]])</p>
<p>如果字符串以指定的 <em>prefix</em> 开始则返回 <code>True</code>，否则返回 <code>False</code>。 <em>prefix</em> 也可以为由多个供查找的前缀构成的元组。 如果有可选项 <em>start</em>，将从所指定位置开始检查。 如果有可选项 <em>end</em>，将在所指定位置停止比较。</p>
<p><code>str.strip</code>([<em>chars</em>])</p>
<p>返回原字符串的副本，移除其中的前导和末尾字符。 <em>chars</em> 参数为指定要移除字符的字符串。 如果省略或为 <code>None</code>，则 <em>chars</em> 参数默认移除空白符。 实际上 <em>chars</em> 参数并非指定单个前缀或后缀；而是会移除参数值的所有组合:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token string">'   spacious   '</span><span class="token punctuation">.</span>strip<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token string">'spacious'</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token string">'www.example.com'</span><span class="token punctuation">.</span>strip<span class="token punctuation">(</span><span class="token string">'cmowz.'</span><span class="token punctuation">)</span>
<span class="token string">'example'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>最外侧的前导和末尾 <em>chars</em> 参数值将从字符串中移除。 开头端的字符的移除将在遇到一个未包含于 <em>chars</em> 所指定字符集的字符时停止。 类似的操作也将在结尾端发生。 例如:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> comment_string <span class="token operator">=</span> <span class="token string">'#....... Section 3.2.1 Issue #32 .......'</span>
<span class="token operator">>></span><span class="token operator">></span> comment_string<span class="token punctuation">.</span>strip<span class="token punctuation">(</span><span class="token string">'.#! '</span><span class="token punctuation">)</span>
<span class="token string">'Section 3.2.1 Issue #32'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p><code>str.swapcase</code>()</p>
<p>返回原字符串的副本，其中大写字符转换为小写，反之亦然。 请注意 <code>s.swapcase().swapcase() == s</code> 并不一定为真值。</p>
<p><code>str.title</code>()</p>
<p>返回原字符串的标题版本，其中每个单词第一个字母为大写，其余字母为小写。</p>
<p>例如：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token string">'Hello world'</span><span class="token punctuation">.</span>title<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token string">'Hello World'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>该算法使用一种简单的与语言无关的定义，将连续的字母组合视为单词。 该定义在多数情况下都很有效，但它也意味着代表缩写形式与所有格的撇号也会成为单词边界，这可能导致不希望的结果:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token string">"they're bill's friends from the UK"</span><span class="token punctuation">.</span>title<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token string">"They'Re Bill'S Friends From The Uk"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>可以使用正则表达式来构建针对撇号的特别处理:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> re
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">def</span> <span class="token function">titlecase</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">return</span> re<span class="token punctuation">.</span>sub<span class="token punctuation">(</span>r<span class="token string">"[A-Za-z]+('[A-Za-z]+)?"</span><span class="token punctuation">,</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                   <span class="token keyword">lambda</span> mo<span class="token punctuation">:</span> mo<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span>capitalize<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                   s<span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> titlecase<span class="token punctuation">(</span><span class="token string">"they're bill's friends."</span><span class="token punctuation">)</span>
<span class="token string">"They're Bill's Friends."</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>str.translate</code>(<em>table</em>)</p>
<p>返回原字符串的副本，其中每个字符按给定的转换表进行映射。 转换表必须是一个使用 <code>__getitem__()</code> 来实现索引操作的对象，通常为 mapping 或 sequence。 当以 Unicode 码位序号（整数）为索引时，转换表对象可以做以下任何一种操作：返回 Unicode 序号或字符串，将字符映射为一个或多个字符；返回 <code>None</code>，将字符从结果字符串中删除；或引发 <code>LookupError</code> 异常，将字符映射为其自身。</p>
<p>你可以使用 <code>str.maketrans()</code> 基于不同格式的字符到字符映射来创建一个转换映射表。</p>
<p><code>str.upper</code>()</p>
<p>返回原字符串的副本，其中所有区分大小写的字符 均转换为大写。 请注意如果 <code>s</code> 包含不区分大小写的字符或者如果结果字符的 Unicode 类别不是 “Lu” (Letter, uppercase) 而是 “Lt” (Letter, titlecase) 则 <code>s.upper().isupper()</code> 有可能为 <code>False</code>。</p>
<p>所用转换大写算法的描述请参见 Unicode 标准的 3.13 节。</p>
<p><code>str.zfill</code>(<em>width</em>)</p>
<p>返回原字符串的副本，在左边填充 ASCII <code>'0'</code> 数码使其长度变为 <em>width*。 正负值前缀 (<code>'+'</code>/<code>'-'</code>) 的处理方式是在正负符号 *之后</em> 填充而非在之前。 如果 <em>width</em> 小于等于 <code>len(s)</code> 则返回原字符串的副本。</p>
<p>例如：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token string">"42"</span><span class="token punctuation">.</span>zfill<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>
<span class="token string">'00042'</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token string">"-42"</span><span class="token punctuation">.</span>zfill<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>
<span class="token string">'-0042'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="printf-风格的字符串格式化"><a href="#printf-风格的字符串格式化" class="headerlink" title="printf 风格的字符串格式化"></a><code>printf</code> 风格的字符串格式化</h3><p>注解</p>
<p>此处介绍的格式化操作具有多种怪异特性，可能导致许多常见错误（例如无法正确显示元组和字典）。 使用较新的 格式化字符串字面值，<code>str.format()</code> 接口或 模板字符串 有助于避免这样的错误。 这些替代方案中的每一种都更好地权衡并提供了简单、灵活以及可扩展性优势。</p>
<p>字符串具有一种特殊的内置操作：使用 <code>%</code> (取模) 运算符。 这也被称为字符串的 <em>格式化</em> 或 <em>插值</em> 运算符。 对于 <code>format % values</code> (其中 <em>format</em> 为一个字符串)，在 <em>format</em> 中的 <code>%</code> 转换标记符将被替换为零个或多个 <em>values</em> 条目。 其效果类似于在 C 语言中使用 <code>sprintf()</code>。</p>
<p>如果 <em>format</em> 要求一个单独参数，则 <em>values</em> 可以为一个非元组对象。 否则的话，<em>values</em> 必须或者是一个包含项数与格式字符串中指定的转换符项数相同的元组，或者是一个单独映射对象（例如字典）。</p>
<p>转换标记符包含两个或更多字符并具有以下组成，且必须遵循此处规定的顺序：</p>
<ol>
<li><code>'%'</code> 字符，用于标记转换符的起始。</li>
<li>映射键（可选），由加圆括号的字符序列组成 (例如 <code>(somename)</code>)。</li>
<li>转换旗标（可选），用于影响某些转换类型的结果。</li>
<li>最小字段宽度（可选）。 如果指定为 <code>'*'</code> (星号)，则实际宽度会从 <em>values</em> 元组的下一元素中读取，要转换的对象则为最小字段宽度和可选的精度之后的元素。</li>
<li>精度（可选），以在 <code>'.'</code> (点号) 之后加精度值的形式给出。 如果指定为 <code>'*'</code> (星号)，则实际精度会从 <em>values</em> 元组的下一元素中读取，要转换的对象则为精度之后的元素。</li>
<li>长度修饰符（可选）。</li>
<li>转换类型。</li>
</ol>
<p>当右边的参数为一个字典（或其他映射类型）时，字符串中的格式 <em>必须</em> 包含加圆括号的映射键，对应 <code>'%'</code> 字符之后字典中的每一项。 映射键将从映射中选取要格式化的值。 例如：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'%(language)s has %(number)03d quote types.'</span> <span class="token operator">%</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>       <span class="token punctuation">{</span><span class="token string">'language'</span><span class="token punctuation">:</span> <span class="token string">"Python"</span><span class="token punctuation">,</span> <span class="token string">"number"</span><span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
Python has <span class="token number">002</span> quote types<span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>在此情况下格式中不能出现 <code>*</code> 标记符（因其需要一个序列类的参数列表）。</p>
<p>转换旗标为：</p>
<table>
<thead>
<tr>
<th align="left">旗标</th>
<th align="left">含意</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>‘#’</code></td>
<td align="left">值的转换将使用“替代形式”（具体定义见下文）。</td>
</tr>
<tr>
<td align="left"><code>‘0’</code></td>
<td align="left">转换将为数字值填充零字符。</td>
</tr>
<tr>
<td align="left"><code>‘-‘</code></td>
<td align="left">转换值将靠左对齐（如果同时给出 <code>‘0’</code> 转换，则会覆盖后者）。</td>
</tr>
<tr>
<td align="left"><code>‘ ‘</code></td>
<td align="left">(空格) 符号位转换产生的正数（或空字符串）前将留出一个空格。</td>
</tr>
<tr>
<td align="left"><code>‘+’</code></td>
<td align="left">符号字符 (<code>‘+’</code> 或 <code>‘-‘</code>) 将显示于转换结果的开头（会覆盖 “空格” 旗标）。</td>
</tr>
</tbody></table>
<p>可以给出长度修饰符 (<code>h</code>, <code>l</code> 或 <code>L</code>)，但会被忽略，因为对 Python 来说没有必要 — 所以 <code>%ld</code> 等价于 <code>%d</code>。</p>
<p>转换类型为：</p>
<table>
<thead>
<tr>
<th align="left">转换符</th>
<th align="left">含意</th>
<th align="left">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>‘d’</code></td>
<td align="left">有符号十进制整数。</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>‘i’</code></td>
<td align="left">有符号十进制整数。</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>‘o’</code></td>
<td align="left">有符号八进制数。</td>
<td align="left">(1)</td>
</tr>
<tr>
<td align="left"><code>‘u’</code></td>
<td align="left">过时类型 — 等价于 <code>‘d’</code>。</td>
<td align="left">(6)</td>
</tr>
<tr>
<td align="left"><code>‘x’</code></td>
<td align="left">有符号十六进制数（小写）。</td>
<td align="left">(2)</td>
</tr>
<tr>
<td align="left"><code>‘X’</code></td>
<td align="left">有符号十六进制数（大写）。</td>
<td align="left">(2)</td>
</tr>
<tr>
<td align="left"><code>‘e’</code></td>
<td align="left">浮点指数格式（小写）。</td>
<td align="left">(3)</td>
</tr>
<tr>
<td align="left"><code>‘E’</code></td>
<td align="left">浮点指数格式（大写）。</td>
<td align="left">(3)</td>
</tr>
<tr>
<td align="left"><code>‘f’</code></td>
<td align="left">浮点十进制格式。</td>
<td align="left">(3)</td>
</tr>
<tr>
<td align="left"><code>‘F’</code></td>
<td align="left">浮点十进制格式。</td>
<td align="left">(3)</td>
</tr>
<tr>
<td align="left"><code>‘g’</code></td>
<td align="left">浮点格式。 如果指数小于 -4 或不小于精度则使用小写指数格式，否则使用十进制格式。</td>
<td align="left">(4)</td>
</tr>
<tr>
<td align="left"><code>‘G’</code></td>
<td align="left">浮点格式。 如果指数小于 -4 或不小于精度则使用大写指数格式，否则使用十进制格式。</td>
<td align="left">(4)</td>
</tr>
<tr>
<td align="left"><code>‘c’</code></td>
<td align="left">单个字符（接受整数或单个字符的字符串）。</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>‘r’</code></td>
<td align="left">字符串（使用 <code>repr()</code> 转换任何 Python 对象）。</td>
<td align="left">(5)</td>
</tr>
<tr>
<td align="left"><code>‘s’</code></td>
<td align="left">字符串（使用 <code>str()</code> 转换任何 Python 对象）。</td>
<td align="left">(5)</td>
</tr>
<tr>
<td align="left"><code>‘a’</code></td>
<td align="left">字符串（使用 <code>ascii()</code> 转换任何 Python 对象）。</td>
<td align="left">(5)</td>
</tr>
<tr>
<td align="left"><code>‘%’</code></td>
<td align="left">不转换参数，在结果中输出一个 <code>‘%’</code> 字符。</td>
<td align="left"></td>
</tr>
</tbody></table>
<p>注释：</p>
<ol>
<li><p>此替代形式会在第一个数码之前插入标示八进制数的前缀 (<code>'0o'</code>)。</p>
</li>
<li><p>此替代形式会在第一个数码之前插入 <code>'0x'</code> 或 <code>'0X'</code> 前缀（取决于是使用 <code>'x'</code> 还是 <code>'X'</code> 格式）。</p>
</li>
<li><p>此替代形式总是会在结果中包含一个小数点，即使其后并没有数码。</p>
<p>小数点后的数码位数由精度决定，默认为 6。</p>
</li>
<li><p>此替代形式总是会在结果中包含一个小数点，末尾各位的零不会如其他情况下那样被移除。</p>
<p>小数点前后的有效数码位数由精度决定，默认为 6。</p>
</li>
<li><p>如果精度为 <code>N</code>，输出将截短为 <code>N</code> 个字符。</p>
</li>
<li><p>参见 <a href="https://www.python.org/dev/peps/pep-0237" target="_blank" rel="noopener"><strong>PEP 237</strong></a>。</p>
</li>
</ol>
<p>由于 Python 字符串显式指明长度，<code>%s</code> 转换不会将 <code>'\0'</code> 视为字符串的结束。</p>
<p>在 3.1 版更改: 绝对值超过 1e50 的 <code>%f</code> 转换不会再被替换为 <code>%g</code> 转换。</p>
<h2 id="二进制序列类型-—-bytes-bytearray-memoryview"><a href="#二进制序列类型-—-bytes-bytearray-memoryview" class="headerlink" title="二进制序列类型 —- bytes, bytearray, memoryview"></a>二进制序列类型 —- <code>bytes</code>, <code>bytearray</code>, <code>memoryview</code></h2><p>操作二进制数据的核心内置类型是 <code>bytes</code> 和 <code>bytearray</code>。 它们由 <code>memoryview</code> 提供支持，该对象使用 缓冲区协议 来访问其他二进制对象所在内存，不需要创建对象的副本。</p>
<p><code>array</code> 模块支持高效地存储基本数据类型，例如 32 位整数和 IEEE754 双精度浮点值。</p>
<h3 id="bytes-对象"><a href="#bytes-对象" class="headerlink" title="bytes 对象"></a>bytes 对象</h3><p>bytes 对象是由单个字节构成的不可变序列。 由于许多主要二进制协议都基于 ASCII 文本编码，因此 bytes 对象提供了一些仅在处理 ASCII 兼容数据时可用，并且在许多特性上与字符串对象紧密相关的方法。</p>
<p><em>class</em> <code>bytes</code>([<em>source</em>[, <em>encoding</em>[, <em>errors</em>]]])</p>
<p>首先，表示 bytes 字面值的语法与字符串字面值的大致相同，只是添加了一个 <code>b</code> 前缀：</p>
<ul>
<li>单引号: <code>b'同样允许嵌入 "双" 引号'</code>。</li>
<li>双引号: <code>b"同样允许嵌入 '单' 引号"</code>。</li>
<li>三重引号: <code>b'''三重单引号'''</code>, <code>b"""三重双引号"""</code></li>
</ul>
<p>bytes 字面值中只允许 ASCII 字符（无论源代码声明的编码为何）。 任何超出 127 的二进制值必须使用相应的转义序列形式加入 bytes 字面值。</p>
<p>像字符串字面值一样，bytes 字面值也可以使用 <code>r</code> 前缀来禁用转义序列处理。 </p>
<p>虽然 bytes 字面值和表示法是基于 ASCII 文本的，但 bytes 对象的行为实际上更像是不可变的整数序列，序列中的每个值的大小被限制为 <code>0 &lt;= x &lt; 256</code> (如果违反此限制将引发 <code>ValueError</code>)。 这种限制是有意设计用以强调以下事实，虽然许多二进制格式都包含基于 ASCII 的元素，可以通过某些面向文本的算法进行有用的操作，但情况对于任意二进制数据来说通常却并非如此（盲目地将文本处理算法应用于不兼容 ASCII 的二进制数据格式往往将导致数据损坏）。</p>
<p>除了字面值形式，bytes 对象还可以通过其他几种方式来创建：</p>
<ul>
<li>指定长度的以零值填充的 bytes 对象: <code>bytes(10)</code></li>
<li>通过由整数组成的可迭代对象: <code>bytes(range(20))</code></li>
<li>通过缓冲区协议复制现有的二进制数据: <code>bytes(obj)</code></li>
</ul>
<p>由于两个十六进制数码精确对应一个字节，因此十六进制数是描述二进制数据的常用格式。 相应地，bytes 类型具有从此种格式读取数据的附加类方法：</p>
<ul>
<li><p><em>classmethod</em> <code>fromhex</code>(<em>string</em>)</p>
<p>此 <code>bytes</code> 类方法返回一个解码给定字符串的 bytes 对象。 字符串必须由表示每个字节的两个十六进制数码构成，其中的 ASCII 空白符会被忽略。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> bytes<span class="token punctuation">.</span>fromhex<span class="token punctuation">(</span><span class="token string">'2Ef0 F1f2  '</span><span class="token punctuation">)</span>
b<span class="token string">'.\xf0\xf1\xf2'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>在 3.7 版更改: <code>bytes.fromhex()</code> 现在会忽略所有 ASCII 空白符而不只是空格符。</p>
</li>
</ul>
<p>存在一个反向转换函数，可以将 bytes 对象转换为对应的十六进制表示。</p>
<ul>
<li><p><code>hex</code>([<em>sep</em>[, <em>bytes_per_sep</em>]])</p>
<p>返回一个字符串对象，该对象包含实例中每个字节的两个十六进制数字。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> b<span class="token string">'\xf0\xf1\xf2'</span><span class="token punctuation">.</span>hex<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token string">'f0f1f2'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>如果你希望令十六进制数字符串更易读，你可以指定单个字符分隔符作为 <em>sep</em> 形参包含于输出中。 默认会放在每个字节之间。 第二个可选的 <em>bytes_per_sep</em> 形参控制间距。 正值会从右开始计算分隔符的位置，负值则是从左开始。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> value <span class="token operator">=</span> b<span class="token string">'\xf0\xf1\xf2'</span>
<span class="token operator">>></span><span class="token operator">></span> value<span class="token punctuation">.</span>hex<span class="token punctuation">(</span><span class="token string">'-'</span><span class="token punctuation">)</span>
<span class="token string">'f0-f1-f2'</span>
<span class="token operator">>></span><span class="token operator">></span> value<span class="token punctuation">.</span>hex<span class="token punctuation">(</span><span class="token string">'_'</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>
<span class="token string">'f0_f1f2'</span>
<span class="token operator">>></span><span class="token operator">></span> b<span class="token string">'UUDDLRLRAB'</span><span class="token punctuation">.</span>hex<span class="token punctuation">(</span><span class="token string">' '</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">4</span><span class="token punctuation">)</span>
<span class="token string">'55554444 4c524c52 4142'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>3.5 新版功能.</p>
<p>在 3.8 版更改: <code>bytes.hex()</code> 现在支持可选的 <em>sep</em> 和 <em>bytes_per_sep</em> 形参以在十六进制输出的字节之间插入分隔符。</p>
</li>
</ul>
<p>由于 bytes 对象是由整数构成的序列（类似于元组），因此对于一个 bytes 对象 <em>b</em>，<code>b[0]</code> 将为一个整数，而 <code>b[0:1]</code> 将为一个长度为 1 的 bytes 对象。 （这与文本字符串不同，索引和切片所产生的将都是一个长度为 1 的字符串）。</p>
<p>bytes 对象的表示使用字面值格式 (<code>b'...'</code>)，因为它通常都要比像 <code>bytes([46, 46, 46])</code> 这样的格式更好用。 你总是可以使用 <code>list(b)</code> 将 bytes 对象转换为一个由整数构成的列表。</p>
<p>注解</p>
<p>针对 Python 2.x 用户的说明：在 Python 2.x 系列中，允许 8 位字符串（ 2.x 所提供的最接近内置二进制数据类型的对象）与 Unicode 字符串进行各种隐式转换。 这是为了实现向下兼容的变通做法，以适应 Python 最初只支持 8 位文本而 Unicode 文本是后来才被加入这一事实。 在 Python 3.x 中，这些隐式转换已被取消 —— 8 位二进制数据与 Unicode 文本间的转换必须显式地进行，bytes 与字符串对象的比较结果将总是不相等。</p>
<h3 id="bytearray-对象"><a href="#bytearray-对象" class="headerlink" title="bytearray 对象"></a>bytearray 对象</h3><p><code>bytearray</code> 对象是 <code>bytes</code> 对象的可变对应物。</p>
<p><em>class</em> <code>bytearray</code>([<em>source</em>[, <em>encoding</em>[, <em>errors</em>]]])</p>
<p>bytearray 对象没有专属的字面值语法，它们总是通过调用构造器来创建：</p>
<ul>
<li>创建一个空实例: <code>bytearray()</code></li>
<li>创建一个指定长度的以零值填充的实例: <code>bytearray(10)</code></li>
<li>通过由整数组成的可迭代对象: <code>bytearray(range(20))</code></li>
<li>通过缓冲区协议复制现有的二进制数据: <code>bytearray(b'Hi!')</code></li>
</ul>
<p>由于 bytearray 对象是可变的，该对象除了 bytes 和 bytearray 操作 中所描述的 bytes 和 bytearray 共有操作之外，还支持 可变 序列操作。</p>
<p>由于两个十六进制数码精确对应一个字节，因此十六进制数是描述二进制数据的常用格式。 相应地，bytearray 类型具有从此种格式读取数据的附加类方法：</p>
<ul>
<li><p><em>classmethod</em> <code>fromhex</code>(<em>string</em>)</p>
<p><code>bytearray</code> 类方法返回一个解码给定字符串的 bytearray 对象。 字符串必须由表示每个字节的两个十六进制数码构成，其中的 ASCII 空白符会被忽略。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> bytearray<span class="token punctuation">.</span>fromhex<span class="token punctuation">(</span><span class="token string">'2Ef0 F1f2  '</span><span class="token punctuation">)</span>
bytearray<span class="token punctuation">(</span>b<span class="token string">'.\xf0\xf1\xf2'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>在 3.7 版更改: <code>bytearray.fromhex()</code> 现在会忽略所有 ASCII 空白符而不只是空格符。</p>
</li>
</ul>
<p>存在一个反向转换函数，可以将 bytearray 对象转换为对应的十六进制表示。</p>
<ul>
<li><p><code>hex</code>([<em>sep</em>[, <em>bytes_per_sep</em>]])</p>
<p>返回一个字符串对象，该对象包含实例中每个字节的两个十六进制数字。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> bytearray<span class="token punctuation">(</span>b<span class="token string">'\xf0\xf1\xf2'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>hex<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token string">'f0f1f2'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>3.5 新版功能.</p>
<p>在 3.8 版更改: 与 <code>bytes.hex()</code> 相似， <code>bytearray.hex()</code> 现在支持可选的 <em>sep</em> 和 <em>bytes_per_sep</em> 参数以在十六进制输出的字节之间插入分隔符。</p>
</li>
</ul>
<p>由于 bytearray 对象是由整数构成的序列（类似于列表），因此对于一个 bytearray 对象 <em>b</em>，<code>b[0]</code> 将为一个整数，而 <code>b[0:1]</code> 将为一个长度为 1 的 bytearray 对象。 （这与文本字符串不同，索引和切片所产生的将都是一个长度为 1 的字符串）。</p>
<p>bytearray 对象的表示使用 bytes 对象字面值格式 (<code>bytearray(b'...')</code>)，因为它通常都要比 <code>bytearray([46, 46, 46])</code> 这样的格式更好用。 你总是可以使用 <code>list(b)</code> 将 bytearray 对象转换为一个由整数构成的列表。</p>
<h3 id="bytes-和-bytearray-操作"><a href="#bytes-和-bytearray-操作" class="headerlink" title="bytes 和 bytearray 操作"></a>bytes 和 bytearray 操作</h3><p>bytes 和 bytearray 对象都支持 通用 序列操作。 它们不仅能与相同类型的操作数，也能与任何 bytes-like object 进行互操作。 由于这样的灵活性，它们可以在操作中自由地混合而不会导致错误。 但是，操作结果的返回值类型可能取决于操作数的顺序。</p>
<p>注解</p>
<p>bytes 和 bytearray 对象的方法不接受字符串作为其参数，就像字符串的方法不接受 bytes 对象作为其参数一样。 例如，你必须使用以下写法:</p>
<pre class="line-numbers language-python"><code class="language-python">a <span class="token operator">=</span> <span class="token string">"abc"</span>
b <span class="token operator">=</span> a<span class="token punctuation">.</span>replace<span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token string">"f"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>和:</p>
<pre class="line-numbers language-python"><code class="language-python">a <span class="token operator">=</span> b<span class="token string">"abc"</span>
b <span class="token operator">=</span> a<span class="token punctuation">.</span>replace<span class="token punctuation">(</span>b<span class="token string">"a"</span><span class="token punctuation">,</span> b<span class="token string">"f"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>某些 bytes 和 bytearray 操作假定使用兼容 ASCII 的二进制格式，因此在处理任意二进数数据时应当避免使用。 这些限制会在下文中说明。</p>
<p>注解</p>
<p>使用这些基于 ASCII 的操作来处理未以基于 ASCII 的格式存储的二进制数据可能会导致数据损坏。</p>
<p>bytes 和 bytearray 对象的下列方法可以用于任意二进制数据。</p>
<p><code>bytes.count</code>(<em>sub</em>[, <em>start</em>[, <em>end</em>]])</p>
<p><code>bytearray.count</code>(<em>sub</em>[, <em>start</em>[, <em>end</em>]])</p>
<p>返回子序列 <em>sub</em> 在 [<em>start</em>, <em>end*] 范围内非重叠出现的次数。 可选参数 *start</em> 与 <em>end</em> 会被解读为切片表示法。</p>
<p>要搜索的子序列可以是任意 bytes-like object 或是 0 至 255 范围内的整数。</p>
<p>在 3.3 版更改: 也接受 0 至 255 范围内的整数作为子序列。</p>
<p><code>bytes.removeprefix</code>(<em>prefix</em>, <em>/</em>)</p>
<p><code>bytearray.removeprefix</code>(<em>prefix</em>, <em>/</em>)</p>
<p>如果二进制数据以 <em>前缀</em> 字符串开头，返回 <code>bytes[len(prefix):]</code> 。否则，返回原始二进制数据的副本：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> b<span class="token string">'TestHook'</span><span class="token punctuation">.</span>removeprefix<span class="token punctuation">(</span>b<span class="token string">'Test'</span><span class="token punctuation">)</span>
b<span class="token string">'Hook'</span>
<span class="token operator">>></span><span class="token operator">></span> b<span class="token string">'BaseTestCase'</span><span class="token punctuation">.</span>removeprefix<span class="token punctuation">(</span>b<span class="token string">'Test'</span><span class="token punctuation">)</span>
b<span class="token string">'BaseTestCase'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>前缀可以是任意 bytes-like object。</p>
<p>注解</p>
<p>此方法的 bytearray 版本 <em>并非</em> 原地操作 —— 它总是产生一个新对象，即便没有做任何改变。</p>
<p>3.9 新版功能.</p>
<p><code>bytes.removesuffix</code>(<em>suffix</em>, <em>/</em>)</p>
<p><code>bytearray.removesuffix</code>(<em>suffix</em>, <em>/</em>)</p>
<p>如果二进制数据以 <em>后缀</em> 字符串结尾，并且 <em>后缀</em> 非空，返回 <code>bytes[:-len(suffix)]</code> 。否则，返回原始二进制数据的副本：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> b<span class="token string">'MiscTests'</span><span class="token punctuation">.</span>removesuffix<span class="token punctuation">(</span>b<span class="token string">'Tests'</span><span class="token punctuation">)</span>
b<span class="token string">'Misc'</span>
<span class="token operator">>></span><span class="token operator">></span> b<span class="token string">'TmpDirMixin'</span><span class="token punctuation">.</span>removesuffix<span class="token punctuation">(</span>b<span class="token string">'Tests'</span><span class="token punctuation">)</span>
b<span class="token string">'TmpDirMixin'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>后缀可以是任意 bytes-like object。</p>
<p>注解</p>
<p>此方法的 bytearray 版本 <em>并非</em> 原地操作 —— 它总是产生一个新对象，即便没有做任何改变。</p>
<p>3.9 新版功能.</p>
<p><code>bytes.decode</code>(<em>encoding=’utf-8’</em>, <em>errors=’strict’</em>)</p>
<p><code>bytearray.decode</code>(<em>encoding=’utf-8’</em>, <em>errors=’strict’</em>)</p>
<p>返回从给定 bytes 解码出来的字符串。 默认编码为 <code>'utf-8'</code>。 可以给出 <em>errors</em> 来设置不同的错误处理方案。 <em>errors</em> 的默认值为 <code>'strict'</code>，表示编码错误会引发 <code>UnicodeError</code>。 其他可用的值为 <code>'ignore'</code>, <code>'replace'</code> 以及任何其他通过 <code>codecs.register_error()</code> 注册的名称。</p>
<p>By default, the <em>errors</em> argument is not checked for best performances, but only used at the first decoding error. Enable the Python Development Mode, or use a debug build to check <em>errors</em>.</p>
<p>注解</p>
<p>将 <em>encoding</em> 参数传给 <code>str</code> 允许直接解码任何 bytes-like object，无须创建临时的 bytes 或 bytearray 对象。</p>
<p>在 3.1 版更改: 加入了对关键字参数的支持。</p>
<p>在 3.9 版更改: The <em>errors</em> is now checked in development mode and in debug mode.</p>
<p><code>bytes.endswith</code>(<em>suffix</em>[, <em>start</em>[, <em>end</em>]])</p>
<p><code>bytearray.endswith</code>(<em>suffix</em>[, <em>start</em>[, <em>end</em>]])</p>
<p>如果二进制数据以指定的 <em>suffix</em> 结束则返回 <code>True</code>，否则返回 <code>False</code>。 <em>suffix</em> 也可以为由多个供查找的后缀构成的元组。 如果有可选项 <em>start</em>，将从所指定位置开始检查。 如果有可选项 <em>end</em>，将在所指定位置停止比较。</p>
<p>要搜索的后缀可以是任意 bytes-like object。</p>
<p><code>bytes.find</code>(<em>sub</em>[, <em>start</em>[, <em>end</em>]])</p>
<p><code>bytearray.find</code>(<em>sub</em>[, <em>start</em>[, <em>end</em>]])</p>
<p>返回子序列 <em>sub</em> 在数据中被找到的最小索引，<em>sub</em> 包含于切片 <code>s[start:end]</code> 之内。 可选参数 <em>start</em> 与 <em>end</em> 会被解读为切片表示法。 如果 <em>sub</em> 未被找到则返回 <code>-1</code>。</p>
<p>要搜索的子序列可以是任意 bytes-like object 或是 0 至 255 范围内的整数。</p>
<p>注解</p>
<p><code>find()</code> 方法应该只在你需要知道 <em>sub</em> 所在位置时使用。 要检查 <em>sub</em> 是否为子串，请使用 <code>in</code> 操作符:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> b<span class="token string">'Py'</span> <span class="token keyword">in</span> b<span class="token string">'Python'</span>
<span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>在 3.3 版更改: 也接受 0 至 255 范围内的整数作为子序列。</p>
<p><code>bytes.index</code>(<em>sub</em>[, <em>start</em>[, <em>end</em>]])</p>
<p><code>bytearray.index</code>(<em>sub</em>[, <em>start</em>[, <em>end</em>]])</p>
<p>类似于 <code>find()</code>，但在找不到子序列时会引发 <code>ValueError</code>。</p>
<p>要搜索的子序列可以是任意 bytes-like object 或是 0 至 255 范围内的整数。</p>
<p>在 3.3 版更改: 也接受 0 至 255 范围内的整数作为子序列。</p>
<p><code>bytes.join</code>(<em>iterable</em>)</p>
<p><code>bytearray.join</code>(<em>iterable</em>)</p>
<p>返回一个由 <em>iterable</em> 中的二进制数据序列拼接而成的 bytes 或 bytearray 对象。 如果 <em>iterable</em> 中存在任何非 字节类对象 包括存在 <code>str</code> 对象值则会引发 <code>TypeError</code>。 提供该方法的 bytes 或 bytearray 对象的内容将作为元素之间的分隔。</p>
<p><em>static</em> <code>bytes.maketrans</code>(<em>from</em>, <em>to</em>)</p>
<p><em>static</em> <code>bytearray.maketrans</code>(<em>from</em>, <em>to</em>)</p>
<p>此静态方法返回一个可用于 <code>bytes.translate()</code> 的转换对照表，它将把 <em>from</em> 中的每个字符映射为 <em>to</em> 中相同位置上的字符；<em>from</em> 与 <em>to</em> 必须都是 字节类对象 并且具有相同的长度。</p>
<p>3.1 新版功能.</p>
<p><code>bytes.partition</code>(<em>sep</em>)</p>
<p><code>bytearray.partition</code>(<em>sep</em>)</p>
<p>在 <em>sep</em> 首次出现的位置拆分序列，返回一个 3 元组，其中包含分隔符之前的部分、分隔符本身或其 bytearray 副本，以及分隔符之后的部分。 如果分隔符未找到，则返回的 3 元组中包含原序列以及两个空的 bytes 或 bytearray 对象。</p>
<p>要搜索的分隔符可以是任意 bytes-like object。</p>
<p><code>bytes.replace</code>(<em>old</em>, <em>new</em>[, <em>count</em>])</p>
<p><code>bytearray.replace</code>(<em>old</em>, <em>new</em>[, <em>count</em>])</p>
<p>返回序列的副本，其中出现的所有子序列 <em>old</em> 都将被替换为 <em>new<em>。 如果给出了可选参数 *count</em>，则只替换前 *count</em> 次出现。</p>
<p>要搜索的子序列及其替换序列可以是任意 bytes-like object。</p>
<p>注解</p>
<p>此方法的 bytearray 版本 <em>并非</em> 原地操作 —— 它总是产生一个新对象，即便没有做任何改变。</p>
<p><code>bytes.rfind</code>(<em>sub</em>[, <em>start</em>[, <em>end</em>]])</p>
<p><code>bytearray.rfind</code>(<em>sub</em>[, <em>start</em>[, <em>end</em>]])</p>
<p>返回子序列 <em>sub</em> 在序列内被找到的最大（最右）索引，这样 <em>sub</em> 将包含在 <code>s[start:end]</code> 当中。 可选参数 <em>start</em> 与 <em>end</em> 会被解读为切片表示法。 如果未找到则返回 <code>-1</code>。</p>
<p>要搜索的子序列可以是任意 bytes-like object 或是 0 至 255 范围内的整数。</p>
<p>在 3.3 版更改: 也接受 0 至 255 范围内的整数作为子序列。</p>
<p><code>bytes.rindex</code>(<em>sub</em>[, <em>start</em>[, <em>end</em>]])</p>
<p><code>bytearray.rindex</code>(<em>sub</em>[, <em>start</em>[, <em>end</em>]])</p>
<p>类似于 <code>rfind()</code>，但在子序列 <em>sub</em> 未找到时会引发 <code>ValueError</code>。</p>
<p>要搜索的子序列可以是任意 bytes-like object 或是 0 至 255 范围内的整数。</p>
<p>在 3.3 版更改: 也接受 0 至 255 范围内的整数作为子序列。</p>
<p><code>bytes.rpartition</code>(<em>sep</em>)</p>
<p><code>bytearray.rpartition</code>(<em>sep</em>)</p>
<p>在 <em>sep</em> 最后一次出现的位置拆分序列，返回一个 3 元组，其中包含分隔符之前的部分，分隔符本身或其 bytearray 副本，以及分隔符之后的部分。 如果分隔符未找到，则返回的 3 元组中包含两个空的 bytes 或 bytearray 对象以及原序列的副本。</p>
<p>要搜索的分隔符可以是任意 bytes-like object。</p>
<p><code>bytes.startswith</code>(<em>prefix</em>[, <em>start</em>[, <em>end</em>]])</p>
<p><code>bytearray.startswith</code>(<em>prefix</em>[, <em>start</em>[, <em>end</em>]])</p>
<p>如果二进制数据以指定的 <em>prefix</em> 开头则返回 <code>True</code>，否则返回 <code>False</code>。 <em>prefix</em> 也可以为由多个供查找的前缀构成的元组。 如果有可选项 <em>start</em>，将从所指定位置开始检查。 如果有可选项 <em>end</em>，将在所指定位置停止比较。</p>
<p>要搜索的前缀可以是任意 bytes-like object。</p>
<p><code>bytes.translate</code>(<em>table</em>, <em>/</em>, <em>delete=b’’</em>)</p>
<p><code>bytearray.translate</code>(<em>table</em>, <em>/</em>, <em>delete=b’’</em>)</p>
<p>返回原 bytes 或 bytearray 对象的副本，移除其中所有在可选参数 <em>delete</em> 中出现的 bytes，其余 bytes 将通过给定的转换表进行映射，该转换表必须是长度为 256 的 bytes 对象。</p>
<p>你可以使用 <code>bytes.maketrans()</code> 方法来创建转换表。</p>
<p>对于仅需移除字符的转换，请将 <em>table</em> 参数设为 <code>None</code>:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> b<span class="token string">'read this short text'</span><span class="token punctuation">.</span>translate<span class="token punctuation">(</span>None<span class="token punctuation">,</span> b<span class="token string">'aeiou'</span><span class="token punctuation">)</span>
b<span class="token string">'rd ths shrt txt'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>在 3.6 版更改: 现在支持将 <em>delete</em> 作为关键字参数。</p>
<p>以下 bytes 和 bytearray 对象的方法的默认行为会假定使用兼容 ASCII 的二进制格式，但通过传入适当的参数仍然可用于任意二进制数据。 请注意本小节中所有的 bytearray 方法都 <em>不是</em> 原地执行操作，而是会产生新的对象。</p>
<p><code>bytes.center</code>(<em>width</em>[, <em>fillbyte</em>])</p>
<p><code>bytearray.center</code>(<em>width</em>[, <em>fillbyte</em>])</p>
<p>返回原对象的副本，在长度为 <em>width</em> 的序列内居中，使用指定的 <em>fillbyte</em> 填充两边的空位（默认使用 ASCII 空格符）。 对于 <code>bytes</code> 对象，如果 <em>width</em> 小于等于 <code>len(s)</code> 则返回原序列的副本。</p>
<p>注解</p>
<p>此方法的 bytearray 版本 <em>并非</em> 原地操作 —— 它总是产生一个新对象，即便没有做任何改变。</p>
<p><code>bytes.ljust</code>(<em>width</em>[, <em>fillbyte</em>])</p>
<p><code>bytearray.ljust</code>(<em>width</em>[, <em>fillbyte</em>])</p>
<p>返回原对象的副本，在长度为 <em>width</em> 的序列中靠左对齐。 使用指定的 <em>fillbyte</em> 填充空位（默认使用 ASCII 空格符）。 对于 <code>bytes</code> 对象，如果 <em>width</em> 小于等于 <code>len(s)</code> 则返回原序列的副本。</p>
<p>注解</p>
<p>此方法的 bytearray 版本 <em>并非</em> 原地操作 —— 它总是产生一个新对象，即便没有做任何改变。</p>
<p><code>bytes.lstrip</code>([<em>chars</em>])</p>
<p><code>bytearray.lstrip</code>([<em>chars</em>])</p>
<p>返回原序列的副本，移除指定的前导字节。 <em>chars</em> 参数为指定要移除字节值集合的二进制序列 —— 这个名称表明此方法通常是用于 ASCII 字符。 如果省略或为 <code>None</code>，则 <em>chars</em> 参数默认移除 ASCII 空白符。 <em>chars</em> 参数并非指定单个前缀；而是会移除参数值的所有组合:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> b<span class="token string">'   spacious   '</span><span class="token punctuation">.</span>lstrip<span class="token punctuation">(</span><span class="token punctuation">)</span>
b<span class="token string">'spacious   '</span>
<span class="token operator">>></span><span class="token operator">></span> b<span class="token string">'www.example.com'</span><span class="token punctuation">.</span>lstrip<span class="token punctuation">(</span>b<span class="token string">'cmowz.'</span><span class="token punctuation">)</span>
b<span class="token string">'example.com'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>要移除的二进制序列可以是任意 bytes-like object 。 要删除单个前缀字符串，而不是全部给定集合中的字符，请参见 <code>str.removeprefix()</code> 方法。 例如:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> b<span class="token string">'Arthur: three!'</span><span class="token punctuation">.</span>lstrip<span class="token punctuation">(</span>b<span class="token string">'Arthur: '</span><span class="token punctuation">)</span>
b<span class="token string">'ee!'</span>
<span class="token operator">>></span><span class="token operator">></span> b<span class="token string">'Arthur: three!'</span><span class="token punctuation">.</span>removeprefix<span class="token punctuation">(</span>b<span class="token string">'Arthur: '</span><span class="token punctuation">)</span>
b<span class="token string">'three!'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>注解</p>
<p>此方法的 bytearray 版本 <em>并非</em> 原地操作 —— 它总是产生一个新对象，即便没有做任何改变。</p>
<p><code>bytes.rjust</code>(<em>width</em>[, <em>fillbyte</em>])</p>
<p><code>bytearray.rjust</code>(<em>width</em>[, <em>fillbyte</em>])</p>
<p>返回原对象的副本，在长度为 <em>width</em> 的序列中靠右对齐。 使用指定的 <em>fillbyte</em> 填充空位（默认使用 ASCII 空格符）。 对于 <code>bytes</code> 对象，如果 <em>width</em> 小于等于 <code>len(s)</code> 则返回原序列的副本。</p>
<p>注解</p>
<p>此方法的 bytearray 版本 <em>并非</em> 原地操作 —— 它总是产生一个新对象，即便没有做任何改变。</p>
<p><code>bytes.rsplit</code>(<em>sep=None</em>, <em>maxsplit=- 1</em>)</p>
<p><code>bytearray.rsplit</code>(<em>sep=None</em>, <em>maxsplit=- 1</em>)</p>
<p>将二进制序列拆分为相同类型的子序列，使用 <em>sep</em> 作为分隔符。 如果给出了 <em>maxsplit*，则最多进行 *maxsplit</em> 次拆分，从 <em>最右边</em> 开始。 如果 <em>sep</em> 未指定或为 <code>None</code>，任何只包含 ASCII 空白符的子序列都会被作为分隔符。 除了从右边开始拆分，<code>rsplit()</code> 的其他行为都类似于下文所述的 <code>split()</code>。</p>
<p><code>bytes.rstrip</code>([<em>chars</em>])</p>
<p><code>bytearray.rstrip</code>([<em>chars</em>])</p>
<p>返回原序列的副本，移除指定的末尾字节。 <em>chars</em> 参数为指定要移除字节值集合的二进制序列 —— 这个名称表明此方法通常是用于 ASCII 字符。 如果省略或为 <code>None</code>，则 <em>chars</em> 参数默认移除 ASCII 空白符。 <em>chars</em> 参数并非指定单个后缀；而是会移除参数值的所有组合:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> b<span class="token string">'   spacious   '</span><span class="token punctuation">.</span>rstrip<span class="token punctuation">(</span><span class="token punctuation">)</span>
b<span class="token string">'   spacious'</span>
<span class="token operator">>></span><span class="token operator">></span> b<span class="token string">'mississippi'</span><span class="token punctuation">.</span>rstrip<span class="token punctuation">(</span>b<span class="token string">'ipz'</span><span class="token punctuation">)</span>
b<span class="token string">'mississ'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>要移除的二进制序列可以是任意 bytes-like object 。 要删除单个后缀字符串，而不是全部给定集合中的字符，请参见 <code>str.removesuffix()</code> 方法。 例如:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> b<span class="token string">'Monty Python'</span><span class="token punctuation">.</span>rstrip<span class="token punctuation">(</span>b<span class="token string">' Python'</span><span class="token punctuation">)</span>
b<span class="token string">'M'</span>
<span class="token operator">>></span><span class="token operator">></span> b<span class="token string">'Monty Python'</span><span class="token punctuation">.</span>removesuffix<span class="token punctuation">(</span>b<span class="token string">' Python'</span><span class="token punctuation">)</span>
b<span class="token string">'Monty'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>注解</p>
<p>此方法的 bytearray 版本 <em>并非</em> 原地操作 —— 它总是产生一个新对象，即便没有做任何改变。</p>
<p><code>bytes.split</code>(<em>sep=None</em>, <em>maxsplit=- 1</em>)</p>
<p><code>bytearray.split</code>(<em>sep=None</em>, <em>maxsplit=- 1</em>)</p>
<p>将二进制序列拆分为相同类型的子序列，使用 <em>sep</em> 作为分隔符。 如果给出了 <em>maxsplit</em> 且非负值，则最多进行 <em>maxsplit</em> 次拆分（因此，列表最多会有 <code>maxsplit+1</code> 个元素）。 如果 <em>maxsplit</em> 未指定或为 <code>-1</code>，则不限制拆分次数（进行所有可能的拆分）。</p>
<p>如果给出了 <em>sep*，则连续的分隔符不会被组合在一起而是被视为分隔空子序列 (例如 <code>b'1,,2'.split(b',')</code> 将返回 <code>[b'1', b'', b'2']</code>)。 *sep</em> 参数可能为一个多字节序列 (例如 <code>b'1&lt;&gt;2&lt;&gt;3'.split(b'&lt;&gt;')</code> 将返回 <code>[b'1', b'2', b'3']</code>)。 使用指定的分隔符拆分空序列将返回 <code>[b'']</code> 或 <code>[bytearray(b'')]</code>，具体取决于被拆分对象的类型。 <em>sep</em> 参数可以是任意 bytes-like object。</p>
<p>例如：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> b<span class="token string">'1,2,3'</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span>b<span class="token string">','</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span>b<span class="token string">'1'</span><span class="token punctuation">,</span> b<span class="token string">'2'</span><span class="token punctuation">,</span> b<span class="token string">'3'</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> b<span class="token string">'1,2,3'</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span>b<span class="token string">','</span><span class="token punctuation">,</span> maxsplit<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span>b<span class="token string">'1'</span><span class="token punctuation">,</span> b<span class="token string">'2,3'</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> b<span class="token string">'1,2,,3,'</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span>b<span class="token string">','</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span>b<span class="token string">'1'</span><span class="token punctuation">,</span> b<span class="token string">'2'</span><span class="token punctuation">,</span> b<span class="token string">''</span><span class="token punctuation">,</span> b<span class="token string">'3'</span><span class="token punctuation">,</span> b<span class="token string">''</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果 <em>sep</em> 未指定或为 <code>None</code>，则会应用另一种拆分算法：连续的 ASCII 空白符会被视为单个分隔符，其结果将不包含序列开头或末尾的空白符。 因此，在不指定分隔符的情况下对空序列或仅包含 ASCII 空白符的序列进行拆分将返回 <code>[]</code>。</p>
<p>例如：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> b<span class="token string">'1 2 3'</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span>b<span class="token string">'1'</span><span class="token punctuation">,</span> b<span class="token string">'2'</span><span class="token punctuation">,</span> b<span class="token string">'3'</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> b<span class="token string">'1 2 3'</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span>maxsplit<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span>b<span class="token string">'1'</span><span class="token punctuation">,</span> b<span class="token string">'2 3'</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> b<span class="token string">'   1   2   3   '</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span>b<span class="token string">'1'</span><span class="token punctuation">,</span> b<span class="token string">'2'</span><span class="token punctuation">,</span> b<span class="token string">'3'</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>bytes.strip</code>([<em>chars</em>])</p>
<p><code>bytearray.strip</code>([<em>chars</em>])</p>
<p>返回原序列的副本，移除指定的开头和末尾字节。 <em>chars</em> 参数为指定要移除字节值集合的二进制序列 —— 这个名称表明此方法通常是用于 ASCII 字符。 如果省略或为 <code>None</code>，则 <em>chars</em> 参数默认移除 ASCII 空白符。 <em>chars</em> 参数并非指定单个前缀或后缀；而是会移除参数值的所有组合:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> b<span class="token string">'   spacious   '</span><span class="token punctuation">.</span>strip<span class="token punctuation">(</span><span class="token punctuation">)</span>
b<span class="token string">'spacious'</span>
<span class="token operator">>></span><span class="token operator">></span> b<span class="token string">'www.example.com'</span><span class="token punctuation">.</span>strip<span class="token punctuation">(</span>b<span class="token string">'cmowz.'</span><span class="token punctuation">)</span>
b<span class="token string">'example'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>要移除的字节值二进制序列可以是任意 bytes-like object。</p>
<p>注解</p>
<p>此方法的 bytearray 版本 <em>并非</em> 原地操作 —— 它总是产生一个新对象，即便没有做任何改变。</p>
<p>以下 bytes 和 bytearray 对象的方法会假定使用兼容 ASCII 的二进制格式，不应当被应用于任意二进制数据。 请注意本小节中所有的 bytearray 方法都 <em>不是</em> 原地执行操作，而是会产生新的对象。</p>
<p><code>bytes.capitalize</code>()</p>
<p><code>bytearray.capitalize</code>()</p>
<p>返回原序列的副本，其中每个字节将都将被解读为一个 ASCII 字符，并且第一个字节的字符大写而其余的小写。 非 ASCII 字节值将保持原样不变。</p>
<p>注解</p>
<p>此方法的 bytearray 版本 <em>并非</em> 原地操作 —— 它总是产生一个新对象，即便没有做任何改变。</p>
<p><code>bytes.expandtabs</code>(<em>tabsize=8</em>)</p>
<p><code>bytearray.expandtabs</code>(<em>tabsize=8</em>)</p>
<p>返回序列的副本，其中所有的 ASCII 制表符会由一个或多个 ASCII 空格替换，具体取决于当前列位置和给定的制表符宽度。 每 <em>tabsize</em> 个字节设为一个制表位（默认值 8 时设定的制表位在列 0, 8, 16 依次类推）。 要展开序列，当前列位置将被设为零并逐一检查序列中的每个字节。 如果字节为 ASCII 制表符 (<code>b'\t'</code>)，则并在结果中插入一个或多个空格符，直到当前列等于下一个制表位。 （制表符本身不会被复制。） 如果当前字节为 ASCII 换行符 (<code>b'\n'</code>) 或回车符 (<code>b'\r'</code>)，它会被复制并将当前列重设为零。 任何其他字节会被不加修改地复制并将当前列加一，不论该字节值在被打印时会如何显示:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> b<span class="token string">'01\t012\t0123\t01234'</span><span class="token punctuation">.</span>expandtabs<span class="token punctuation">(</span><span class="token punctuation">)</span>
b<span class="token string">'01      012     0123    01234'</span>
<span class="token operator">>></span><span class="token operator">></span> b<span class="token string">'01\t012\t0123\t01234'</span><span class="token punctuation">.</span>expandtabs<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span>
b<span class="token string">'01  012 0123    01234'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>注解</p>
<p>此方法的 bytearray 版本 <em>并非</em> 原地操作 —— 它总是产生一个新对象，即便没有做任何改变。</p>
<p><code>bytes.isalnum</code>()</p>
<p><code>bytearray.isalnum</code>()</p>
<p>如果序列中所有字节都是字母类 ASCII 字符或 ASCII 十进制数码并且序列非空则返回 <code>True</code> ，否则返回 <code>False</code> 。 字母类 ASCII 字符就是字节值包含在序列 <code>b'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'</code> 中的字符。 ASCII 十进制数码就是字节值包含在序列 <code>b'0123456789'</code> 中的字符。</p>
<p>例如：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> b<span class="token string">'ABCabc1'</span><span class="token punctuation">.</span>isalnum<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token boolean">True</span>
<span class="token operator">>></span><span class="token operator">></span> b<span class="token string">'ABC abc1'</span><span class="token punctuation">.</span>isalnum<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>bytes.isalpha</code>()</p>
<p><code>bytearray.isalpha</code>()</p>
<p>如果序列中所有字节都是字母类 ASCII 字符并且序列不非空则返回 <code>True</code> ，否则返回 <code>False</code> 。 字母类 ASCII 字符就是字节值包含在序列 <code>b'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'</code> 中的字符。</p>
<p>例如：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> b<span class="token string">'ABCabc'</span><span class="token punctuation">.</span>isalpha<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token boolean">True</span>
<span class="token operator">>></span><span class="token operator">></span> b<span class="token string">'ABCabc1'</span><span class="token punctuation">.</span>isalpha<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>bytes.isascii</code>()</p>
<p><code>bytearray.isascii</code>()</p>
<p>如果序列为空或序列中所有字节都是 ASCII 字节则返回 <code>True</code> ，否则返回 <code>False</code> 。 ASCII 字节的取值范围是 0-0x7F。</p>
<p>3.7 新版功能.</p>
<p><code>bytes.isdigit</code>()</p>
<p><code>bytearray.isdigit</code>()</p>
<p>如果序列中所有字节都是 ASCII 十进制数码并且序列非空则返回 <code>True</code> ，否则返回 <code>False</code> 。 ASCII 十进制数码就是字节值包含在序列 <code>b'0123456789'</code> 中的字符。</p>
<p>例如：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> b<span class="token string">'1234'</span><span class="token punctuation">.</span>isdigit<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token boolean">True</span>
<span class="token operator">>></span><span class="token operator">></span> b<span class="token string">'1.23'</span><span class="token punctuation">.</span>isdigit<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>bytes.islower</code>()</p>
<p><code>bytearray.islower</code>()</p>
<p>如果序列中至少有一个小写的 ASCII 字符并且没有大写的 ASCII 字符则返回 <code>True</code> ，否则返回 <code>False</code> 。</p>
<p>例如：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> b<span class="token string">'hello world'</span><span class="token punctuation">.</span>islower<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token boolean">True</span>
<span class="token operator">>></span><span class="token operator">></span> b<span class="token string">'Hello world'</span><span class="token punctuation">.</span>islower<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>小写 ASCII 字符就是字节值包含在序列 <code>b'abcdefghijklmnopqrstuvwxyz'</code> 中的字符。 大写 ASCII 字符就是字节值包含在序列 <code>b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'</code> 中的字符。</p>
<p><code>bytes.isspace</code>()</p>
<p><code>bytearray.isspace</code>()</p>
<p>如果序列中所有字节都是 ASCII 空白符并且序列非空则返回 <code>True</code> ，否则返回 <code>False</code> 。 ASCII 空白符就是字节值包含在序列 <code>b' \t\n\r\x0b\f'</code> (空格, 制表, 换行, 回车, 垂直制表, 进纸) 中的字符。</p>
<p><code>bytes.istitle</code>()</p>
<p><code>bytearray.istitle</code>()</p>
<p>如果序列为 ASCII 标题大小写形式并且序列非空则返回 <code>True</code> ，否则返回 <code>False</code> 。</p>
<p>例如：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> b<span class="token string">'Hello World'</span><span class="token punctuation">.</span>istitle<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token boolean">True</span>
<span class="token operator">>></span><span class="token operator">></span> b<span class="token string">'Hello world'</span><span class="token punctuation">.</span>istitle<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>bytes.isupper</code>()</p>
<p><code>bytearray.isupper</code>()</p>
<p>如果序列中至少有一个大写字母 ASCII 字符并且没有小写 ASCII 字符则返回 <code>True</code> ，否则返回 <code>False</code> 。</p>
<p>例如：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> b<span class="token string">'HELLO WORLD'</span><span class="token punctuation">.</span>isupper<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token boolean">True</span>
<span class="token operator">>></span><span class="token operator">></span> b<span class="token string">'Hello world'</span><span class="token punctuation">.</span>isupper<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>小写 ASCII 字符就是字节值包含在序列 <code>b'abcdefghijklmnopqrstuvwxyz'</code> 中的字符。 大写 ASCII 字符就是字节值包含在序列 <code>b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'</code> 中的字符。</p>
<p><code>bytes.lower</code>()</p>
<p><code>bytearray.lower</code>()</p>
<p>返回原序列的副本，其所有大写 ASCII 字符均转换为对应的小写形式。</p>
<p>例如：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> b<span class="token string">'Hello World'</span><span class="token punctuation">.</span>lower<span class="token punctuation">(</span><span class="token punctuation">)</span>
b<span class="token string">'hello world'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>小写 ASCII 字符就是字节值包含在序列 <code>b'abcdefghijklmnopqrstuvwxyz'</code> 中的字符。 大写 ASCII 字符就是字节值包含在序列 <code>b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'</code> 中的字符。</p>
<p>注解</p>
<p>此方法的 bytearray 版本 <em>并非</em> 原地操作 —— 它总是产生一个新对象，即便没有做任何改变。</p>
<p><code>bytes.splitlines</code>(<em>keepends=False</em>)</p>
<p><code>bytearray.splitlines</code>(<em>keepends=False</em>)</p>
<p>返回由原二进制序列中各行组成的列表，在 ASCII 行边界符的位置拆分。 此方法使用 universal newlines 方式来分行。 结果列表中不包含换行符，除非给出了 <em>keepends</em> 且为真值。</p>
<p>例如：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> b<span class="token string">'ab c\n\nde fg\rkl\r\n'</span><span class="token punctuation">.</span>splitlines<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span>b<span class="token string">'ab c'</span><span class="token punctuation">,</span> b<span class="token string">''</span><span class="token punctuation">,</span> b<span class="token string">'de fg'</span><span class="token punctuation">,</span> b<span class="token string">'kl'</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> b<span class="token string">'ab c\n\nde fg\rkl\r\n'</span><span class="token punctuation">.</span>splitlines<span class="token punctuation">(</span>keepends<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span>b<span class="token string">'ab c\n'</span><span class="token punctuation">,</span> b<span class="token string">'\n'</span><span class="token punctuation">,</span> b<span class="token string">'de fg\r'</span><span class="token punctuation">,</span> b<span class="token string">'kl\r\n'</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>不同于 <code>split()</code>，当给出了分隔符 <em>sep</em> 时，对于空字符串此方法将返回一个空列表，而末尾的换行不会令结果中增加额外的行:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> b<span class="token string">""</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span>b<span class="token string">'\n'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> b<span class="token string">"Two lines\n"</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span>b<span class="token string">'\n'</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token punctuation">[</span>b<span class="token string">''</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>b<span class="token string">'Two lines'</span><span class="token punctuation">,</span> b<span class="token string">''</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> b<span class="token string">""</span><span class="token punctuation">.</span>splitlines<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> b<span class="token string">"One line\n"</span><span class="token punctuation">.</span>splitlines<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>b<span class="token string">'One line'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>bytes.swapcase</code>()</p>
<p><code>bytearray.swapcase</code>()</p>
<p>返回原序列的副本，其所有小写 ASCII 字符均转换为对应的大写形式，反之亦反。</p>
<p>例如：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> b<span class="token string">'Hello World'</span><span class="token punctuation">.</span>swapcase<span class="token punctuation">(</span><span class="token punctuation">)</span>
b<span class="token string">'hELLO wORLD'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>小写 ASCII 字符就是字节值包含在序列 <code>b'abcdefghijklmnopqrstuvwxyz'</code> 中的字符。 大写 ASCII 字符就是字节值包含在序列 <code>b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'</code> 中的字符。</p>
<p>不同于 <code>str.swapcase()</code>，在些二进制版本下 <code>bin.swapcase().swapcase() == bin</code> 总是成立。 大小写转换在 ASCII 中是对称的，即使其对于任意 Unicode 码位来说并不总是成立。</p>
<p>注解</p>
<p>此方法的 bytearray 版本 <em>并非</em> 原地操作 —— 它总是产生一个新对象，即便没有做任何改变。</p>
<p><code>bytes.title</code>()</p>
<p><code>bytearray.title</code>()</p>
<p>返回原二进制序列的标题版本，其中每个单词以一个大写 ASCII 字符为开头，其余字母为小写。 不区别大小写的字节值将保持原样不变。</p>
<p>例如：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> b<span class="token string">'Hello world'</span><span class="token punctuation">.</span>title<span class="token punctuation">(</span><span class="token punctuation">)</span>
b<span class="token string">'Hello World'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>小写 ASCII 字符就是字节值包含在序列 <code>b'abcdefghijklmnopqrstuvwxyz'</code> 中的字符。 大写 ASCII 字符就是字节值包含在序列 <code>b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'</code> 中的字符。 所有其他字节值都不区分大小写。</p>
<p>该算法使用一种简单的与语言无关的定义，将连续的字母组合视为单词。 该定义在多数情况下都很有效，但它也意味着代表缩写形式与所有格的撇号也会成为单词边界，这可能导致不希望的结果:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> b<span class="token string">"they're bill's friends from the UK"</span><span class="token punctuation">.</span>title<span class="token punctuation">(</span><span class="token punctuation">)</span>
b<span class="token string">"They'Re Bill'S Friends From The Uk"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>可以使用正则表达式来构建针对撇号的特别处理:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> re
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">def</span> <span class="token function">titlecase</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">return</span> re<span class="token punctuation">.</span>sub<span class="token punctuation">(</span>rb<span class="token string">"[A-Za-z]+('[A-Za-z]+)?"</span><span class="token punctuation">,</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                   <span class="token keyword">lambda</span> mo<span class="token punctuation">:</span> mo<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>upper<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                              mo<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">.</span>lower<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                   s<span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> titlecase<span class="token punctuation">(</span>b<span class="token string">"they're bill's friends."</span><span class="token punctuation">)</span>
b<span class="token string">"They're Bill's Friends."</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>注解</p>
<p>此方法的 bytearray 版本 <em>并非</em> 原地操作 —— 它总是产生一个新对象，即便没有做任何改变。</p>
<p><code>bytes.upper</code>()</p>
<p><code>bytearray.upper</code>()</p>
<p>返回原序列的副本，其所有小写 ASCII 字符均转换为对应的大写形式。</p>
<p>例如：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> b<span class="token string">'Hello World'</span><span class="token punctuation">.</span>upper<span class="token punctuation">(</span><span class="token punctuation">)</span>
b<span class="token string">'HELLO WORLD'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>小写 ASCII 字符就是字节值包含在序列 <code>b'abcdefghijklmnopqrstuvwxyz'</code> 中的字符。 大写 ASCII 字符就是字节值包含在序列 <code>b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'</code> 中的字符。</p>
<p>注解</p>
<p>此方法的 bytearray 版本 <em>并非</em> 原地操作 —— 它总是产生一个新对象，即便没有做任何改变。</p>
<p><code>bytes.zfill</code>(<em>width</em>)</p>
<p><code>bytearray.zfill</code>(<em>width</em>)</p>
<p>返回原序列的副本，在左边填充 <code>b'0'</code> 数码使序列长度为 <em>width*。 正负值前缀 (<code>b'+'</code>/ <code>b'-'</code>) 的处理方式是在正负符号 *之后</em> 填充而非在之前。 对于 <code>bytes</code> 对象，如果 <em>width</em> 小于等于 <code>len(seq)</code> 则返回原序列。</p>
<p>例如：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> b<span class="token string">"42"</span><span class="token punctuation">.</span>zfill<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>
b<span class="token string">'00042'</span>
<span class="token operator">>></span><span class="token operator">></span> b<span class="token string">"-42"</span><span class="token punctuation">.</span>zfill<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>
b<span class="token string">'-0042'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>注解</p>
<p>此方法的 bytearray 版本 <em>并非</em> 原地操作 —— 它总是产生一个新对象，即便没有做任何改变。</p>
<h3 id="printf-风格的字节串格式化"><a href="#printf-风格的字节串格式化" class="headerlink" title="printf 风格的字节串格式化"></a><code>printf</code> 风格的字节串格式化</h3><p>注解</p>
<p>此处介绍的格式化操作具有多种怪异特性，可能导致许多常见错误（例如无法正确显示元组和字典）。 如果要打印的值可能为元组或字典，请将其放入一个元组中。</p>
<p>字节串对象 (<code>bytes</code>/<code>bytearray</code>) 具有一种特殊的内置操作：使用 <code>%</code> (取模) 运算符。 这也被称为字节串的 <em>格式化</em> 或 <em>插值</em> 运算符。 对于 <code>format % values</code> (其中 <em>format</em> 为一个字节串对象)，在 <em>format</em> 中的 <code>%</code> 转换标记符将被替换为零个或多个 <em>values</em> 条目。 其效果类似于在 C 语言中使用 <code>sprintf()</code>。</p>
<p>如果 <em>format</em> 要求一个单独参数，则 <em>values</em> 可以为一个非元组对象。否则的话，<em>values</em> 必须或是是一个包含项数与格式字节串对象中指定的转换符项数相同的元组，或者是一个单独的映射对象（例如元组）。</p>
<p>转换标记符包含两个或更多字符并具有以下组成，且必须遵循此处规定的顺序：</p>
<ol>
<li><code>'%'</code> 字符，用于标记转换符的起始。</li>
<li>映射键（可选），由加圆括号的字符序列组成 (例如 <code>(somename)</code>)。</li>
<li>转换旗标（可选），用于影响某些转换类型的结果。</li>
<li>最小字段宽度（可选）。 如果指定为 <code>'*'</code> (星号)，则实际宽度会从 <em>values</em> 元组的下一元素中读取，要转换的对象则为最小字段宽度和可选的精度之后的元素。</li>
<li>精度（可选），以在 <code>'.'</code> (点号) 之后加精度值的形式给出。 如果指定为 <code>'*'</code> (星号)，则实际精度会从 <em>values</em> 元组的下一元素中读取，要转换的对象则为精度之后的元素。</li>
<li>长度修饰符（可选）。</li>
<li>转换类型。</li>
</ol>
<p>当右边的参数为一个字典（或其他映射类型）时，字节串对象中的格式 <em>必须</em> 包含加圆括号的映射键，对应 <code>'%'</code> 字符之后字典中的每一项。 映射键将从映射中选取要格式化的值。 例如：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>b<span class="token string">'%(language)s has %(number)03d quote types.'</span> <span class="token operator">%</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>       <span class="token punctuation">{</span>b<span class="token string">'language'</span><span class="token punctuation">:</span> b<span class="token string">"Python"</span><span class="token punctuation">,</span> b<span class="token string">"number"</span><span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
b<span class="token string">'Python has 002 quote types.'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>在此情况下格式中不能出现 <code>*</code> 标记符（因其需要一个序列类的参数列表）。</p>
<p>转换旗标为：</p>
<table>
<thead>
<tr>
<th align="left">旗标</th>
<th align="left">含意</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>‘#’</code></td>
<td align="left">值的转换将使用“替代形式”（具体定义见下文）。</td>
</tr>
<tr>
<td align="left"><code>‘0’</code></td>
<td align="left">转换将为数字值填充零字符。</td>
</tr>
<tr>
<td align="left"><code>‘-‘</code></td>
<td align="left">转换值将靠左对齐（如果同时给出 <code>‘0’</code> 转换，则会覆盖后者）。</td>
</tr>
<tr>
<td align="left"><code>‘ ‘</code></td>
<td align="left">(空格) 符号位转换产生的正数（或空字符串）前将留出一个空格。</td>
</tr>
<tr>
<td align="left"><code>‘+’</code></td>
<td align="left">符号字符 (<code>‘+’</code> 或 <code>‘-‘</code>) 将显示于转换结果的开头（会覆盖 “空格” 旗标）。</td>
</tr>
</tbody></table>
<p>可以给出长度修饰符 (<code>h</code>, <code>l</code> 或 <code>L</code>)，但会被忽略，因为对 Python 来说没有必要 — 所以 <code>%ld</code> 等价于 <code>%d</code>。</p>
<p>转换类型为：</p>
<table>
<thead>
<tr>
<th align="left">转换符</th>
<th align="left">含意</th>
<th align="left">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>‘d’</code></td>
<td align="left">有符号十进制整数。</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>‘i’</code></td>
<td align="left">有符号十进制整数。</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>‘o’</code></td>
<td align="left">有符号八进制数。</td>
<td align="left">(1)</td>
</tr>
<tr>
<td align="left"><code>‘u’</code></td>
<td align="left">过时类型 — 等价于 <code>‘d’</code>。</td>
<td align="left">(8)</td>
</tr>
<tr>
<td align="left"><code>‘x’</code></td>
<td align="left">有符号十六进制数（小写）。</td>
<td align="left">(2)</td>
</tr>
<tr>
<td align="left"><code>‘X’</code></td>
<td align="left">有符号十六进制数（大写）。</td>
<td align="left">(2)</td>
</tr>
<tr>
<td align="left"><code>‘e’</code></td>
<td align="left">浮点指数格式（小写）。</td>
<td align="left">(3)</td>
</tr>
<tr>
<td align="left"><code>‘E’</code></td>
<td align="left">浮点指数格式（大写）。</td>
<td align="left">(3)</td>
</tr>
<tr>
<td align="left"><code>‘f’</code></td>
<td align="left">浮点十进制格式。</td>
<td align="left">(3)</td>
</tr>
<tr>
<td align="left"><code>‘F’</code></td>
<td align="left">浮点十进制格式。</td>
<td align="left">(3)</td>
</tr>
<tr>
<td align="left"><code>‘g’</code></td>
<td align="left">浮点格式。 如果指数小于 -4 或不小于精度则使用小写指数格式，否则使用十进制格式。</td>
<td align="left">(4)</td>
</tr>
<tr>
<td align="left"><code>‘G’</code></td>
<td align="left">浮点格式。 如果指数小于 -4 或不小于精度则使用大写指数格式，否则使用十进制格式。</td>
<td align="left">(4)</td>
</tr>
<tr>
<td align="left"><code>‘c’</code></td>
<td align="left">单个字节（接受整数或单个字节对象）。</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>‘b’</code></td>
<td align="left">字节串（任何遵循 缓冲区协议 或是具有 <code>**bytes**()</code> 的对象）。</td>
<td align="left">(5)</td>
</tr>
<tr>
<td align="left"><code>‘s’</code></td>
<td align="left"><code>‘s’</code> 是 <code>‘b’</code> 的一个别名，只应当在基于 Python2/3 的代码中使用。</td>
<td align="left">(6)</td>
</tr>
<tr>
<td align="left"><code>‘a’</code></td>
<td align="left">字节串（使用 <code>repr(obj).encode(‘ascii’,’backslashreplace)</code> 转换任何 Python 对象）。</td>
<td align="left">(5)</td>
</tr>
<tr>
<td align="left"><code>‘r’</code></td>
<td align="left"><code>‘r’</code> 是 <code>‘a’</code> 的一个别名，只应当在基于 Python2/3 的代码中使用。</td>
<td align="left">(7)</td>
</tr>
<tr>
<td align="left"><code>‘%’</code></td>
<td align="left">不转换参数，在结果中输出一个 <code>‘%’</code> 字符。</td>
<td align="left"></td>
</tr>
</tbody></table>
<p>注释：</p>
<ol>
<li><p>此替代形式会在第一个数码之前插入标示八进制数的前缀 (<code>'0o'</code>)。</p>
</li>
<li><p>此替代形式会在第一个数码之前插入 <code>'0x'</code> 或 <code>'0X'</code> 前缀（取决于是使用 <code>'x'</code> 还是 <code>'X'</code> 格式）。</p>
</li>
<li><p>此替代形式总是会在结果中包含一个小数点，即使其后并没有数码。</p>
<p>小数点后的数码位数由精度决定，默认为 6。</p>
</li>
<li><p>此替代形式总是会在结果中包含一个小数点，末尾各位的零不会如其他情况下那样被移除。</p>
<p>小数点前后的有效数码位数由精度决定，默认为 6。</p>
</li>
<li><p>如果精度为 <code>N</code>，输出将截短为 <code>N</code> 个字符。</p>
</li>
<li><p><code>b'%s'</code> 已弃用，但在 3.x 系列中将不会被移除。</p>
</li>
<li><p><code>b'%r'</code> 已弃用，但在 3.x 系列中将不会被移除。</p>
</li>
<li><p>参见 <a href="https://www.python.org/dev/peps/pep-0237" target="_blank" rel="noopener"><strong>PEP 237</strong></a>。</p>
</li>
</ol>
<p>注解</p>
<p>此方法的 bytearray 版本 <em>并非</em> 原地操作 —— 它总是产生一个新对象，即便没有做任何改变。</p>
<p>参见</p>
<p><a href="https://www.python.org/dev/peps/pep-0461" target="_blank" rel="noopener"><strong>PEP 461</strong></a> - 为 bytes 和 bytearray 添加 % 格式化</p>
<p>3.5 新版功能.</p>
<h3 id="内存视图"><a href="#内存视图" class="headerlink" title="内存视图"></a>内存视图</h3><p><code>memoryview</code> 对象允许 Python 代码访问一个对象的内部数据，只要该对象支持 缓冲区协议 而无需进行拷贝。</p>
<p><em>class</em> <code>memoryview</code>(<em>object</em>)</p>
<p>创建一个引用 <em>object</em> 的 <code>memoryview</code> 。 <em>object</em> 必须支持缓冲区协议。支持缓冲区协议的内置对象有 <code>bytes</code> 和 <code>bytearray</code> 。</p>
<p><code>memoryview</code> 有 <strong>元素</strong> 的概念， <strong>元素</strong> 指由原始 <em>object</em> 处理的原子内存单元。对于许多简单的类型，如 <code>bytes</code> 和 <code>bytearray</code> ，一个元素是一个字节，但其他类型，如 <code>array.array</code> 可能有更大的元素。</p>
<p><code>len(view)</code> 与 <code>tolist</code> 的长度相等。 如果 <code>view.ndim = 0</code>，则其长度为 1。 如果 <code>view.ndim = 1</code>，则其长度等于 view 中元素的数量。 对于更高的维度，其长度等于表示 view 的嵌套列表的长度。 <code>itemsize</code> 属性可向你给出单个元素所占的字节数。</p>
<p><code>memoryview</code> 支持通过切片和索引访问其元素。 一维切片的结果将是一个子视图:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> v <span class="token operator">=</span> memoryview<span class="token punctuation">(</span>b<span class="token string">'abcefg'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> v<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>
<span class="token number">98</span>
<span class="token operator">>></span><span class="token operator">></span> v<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>
<span class="token number">103</span>
<span class="token operator">>></span><span class="token operator">></span> v<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">]</span>
<span class="token operator">&lt;</span>memory at <span class="token number">0x7f3ddc9f4350</span><span class="token operator">></span>
<span class="token operator">>></span><span class="token operator">></span> bytes<span class="token punctuation">(</span>v<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
b<span class="token string">'bce'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果 <code>format</code> 是一个来自于 <code>struct</code> 模块的原生格式说明符，则也支持使用整数或由整数构成的元组进行索引，并返回具有正确类型的单个 <em>元素*。 一维内存视图可以使用一个整数或由一个整数构成的元组进行索引。 多维内存视图可以使用由恰好 *ndim</em> 个整数构成的元素进行索引，<em>ndim</em> 即其维度。 零维内存视图可以使用空元组进行索引。</p>
<p>这里是一个使用非字节格式的例子:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> array
<span class="token operator">>></span><span class="token operator">></span> a <span class="token operator">=</span> array<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token string">'l'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">11111111</span><span class="token punctuation">,</span> <span class="token number">22222222</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">33333333</span><span class="token punctuation">,</span> <span class="token number">44444444</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> m <span class="token operator">=</span> memoryview<span class="token punctuation">(</span>a<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> m<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
<span class="token operator">-</span><span class="token number">11111111</span>
<span class="token operator">>></span><span class="token operator">></span> m<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>
<span class="token number">44444444</span>
<span class="token operator">>></span><span class="token operator">></span> m<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">.</span>tolist<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">11111111</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">33333333</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果下层对象是可写的，则内存视图支持一维切片赋值。 改变大小则不被允许:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> data <span class="token operator">=</span> bytearray<span class="token punctuation">(</span>b<span class="token string">'abcefg'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> v <span class="token operator">=</span> memoryview<span class="token punctuation">(</span>data<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> v<span class="token punctuation">.</span>readonly
<span class="token boolean">False</span>
<span class="token operator">>></span><span class="token operator">></span> v<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> ord<span class="token punctuation">(</span>b<span class="token string">'z'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> data
bytearray<span class="token punctuation">(</span>b<span class="token string">'zbcefg'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> v<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> b<span class="token string">'123'</span>
<span class="token operator">>></span><span class="token operator">></span> data
bytearray<span class="token punctuation">(</span>b<span class="token string">'z123fg'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> v<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> b<span class="token string">'spam'</span>
Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>
  File <span class="token string">"&lt;stdin>"</span><span class="token punctuation">,</span> line <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">></span>
ValueError<span class="token punctuation">:</span> memoryview assignment<span class="token punctuation">:</span> lvalue <span class="token operator">and</span> rvalue have different structures
<span class="token operator">>></span><span class="token operator">></span> v<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token number">6</span><span class="token punctuation">]</span> <span class="token operator">=</span> b<span class="token string">'spam'</span>
<span class="token operator">>></span><span class="token operator">></span> data
bytearray<span class="token punctuation">(</span>b<span class="token string">'z1spam'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>由带有格式符号 ‘B’, ‘b’ 或 ‘c’ 的可哈希（只读）类型构成的一维内存视图同样是可哈希的。 哈希定义为 <code>hash(m) == hash(m.tobytes())</code>:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> v <span class="token operator">=</span> memoryview<span class="token punctuation">(</span>b<span class="token string">'abcefg'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> hash<span class="token punctuation">(</span>v<span class="token punctuation">)</span> <span class="token operator">==</span> hash<span class="token punctuation">(</span>b<span class="token string">'abcefg'</span><span class="token punctuation">)</span>
<span class="token boolean">True</span>
<span class="token operator">>></span><span class="token operator">></span> hash<span class="token punctuation">(</span>v<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> hash<span class="token punctuation">(</span>b<span class="token string">'ce'</span><span class="token punctuation">)</span>
<span class="token boolean">True</span>
<span class="token operator">>></span><span class="token operator">></span> hash<span class="token punctuation">(</span>v<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> hash<span class="token punctuation">(</span>b<span class="token string">'abcefg'</span><span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在 3.3 版更改: 一维内存视图现在可以被切片。 带有格式符号 ‘B’, ‘b’ 或 ‘c’ 的一维内存视图现在是可哈希的。</p>
<p>在 3.4 版更改: 内存视图现在会自动注册为 <code>collections.abc.Sequence</code></p>
<p>在 3.5 版更改: 内存视图现在可使用整数元组进行索引。</p>
<p><code>memoryview</code> 具有以下一些方法：</p>
<ul>
<li><p><code>__eq__</code>(<em>exporter</em>)</p>
<p>memoryview 与 <a href="https://www.python.org/dev/peps/pep-3118" target="_blank" rel="noopener"><strong>PEP 3118</strong></a> 中的导出器这两者如果形状相同，并且如果当使用 <code>struct</code> 语法解读操作数的相应格式代码时所有对应值都相同，则它们就是等价的。</p>
<p>对于 <code>tolist()</code> 当前所支持的 <code>struct</code> 格式字符串子集，如果 <code>v.tolist() == w.tolist()</code> 则 <code>v</code> 和 <code>w</code> 相等:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> array
<span class="token operator">>></span><span class="token operator">></span> a <span class="token operator">=</span> array<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token string">'I'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> b <span class="token operator">=</span> array<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token string">'d'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token number">3.0</span><span class="token punctuation">,</span> <span class="token number">4.0</span><span class="token punctuation">,</span> <span class="token number">5.0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> c <span class="token operator">=</span> array<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> x <span class="token operator">=</span> memoryview<span class="token punctuation">(</span>a<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> y <span class="token operator">=</span> memoryview<span class="token punctuation">(</span>b<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> x <span class="token operator">==</span> a <span class="token operator">==</span> y <span class="token operator">==</span> b
<span class="token boolean">True</span>
<span class="token operator">>></span><span class="token operator">></span> x<span class="token punctuation">.</span>tolist<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> a<span class="token punctuation">.</span>tolist<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> y<span class="token punctuation">.</span>tolist<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> b<span class="token punctuation">.</span>tolist<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token boolean">True</span>
<span class="token operator">>></span><span class="token operator">></span> z <span class="token operator">=</span> y<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> z <span class="token operator">==</span> c
<span class="token boolean">True</span>
<span class="token operator">>></span><span class="token operator">></span> z<span class="token punctuation">.</span>tolist<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> c<span class="token punctuation">.</span>tolist<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果两边的格式字符串都不被 <code>struct</code> 模块所支持，则两对象比较结果总是不相等（即使格式字符串和缓冲区内容相同）:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> ctypes <span class="token keyword">import</span> BigEndianStructure<span class="token punctuation">,</span> c_long
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">class</span> <span class="token class-name">BEPoint</span><span class="token punctuation">(</span>BigEndianStructure<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     _fields_ <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token string">"x"</span><span class="token punctuation">,</span> c_long<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">"y"</span><span class="token punctuation">,</span> c_long<span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> point <span class="token operator">=</span> BEPoint<span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> a <span class="token operator">=</span> memoryview<span class="token punctuation">(</span>point<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> b <span class="token operator">=</span> memoryview<span class="token punctuation">(</span>point<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> a <span class="token operator">==</span> point
<span class="token boolean">False</span>
<span class="token operator">>></span><span class="token operator">></span> a <span class="token operator">==</span> b
<span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>请注意，与浮点数的情况一样，对于内存视图对象来说，<code>v is w</code> 也 <em>并不</em> 意味着 <code>v == w</code>。</p>
<p>在 3.3 版更改: 之前的版本比较原始内存时会忽略条目的格式与逻辑数组结构。</p>
</li>
<li><p><code>tobytes</code>(<em>order=None</em>)</p>
<p>将缓冲区中的数据作为字节串返回。 这相当于在内存视图上调用 <code>bytes</code> 构造器。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> m <span class="token operator">=</span> memoryview<span class="token punctuation">(</span>b<span class="token string">"abc"</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> m<span class="token punctuation">.</span>tobytes<span class="token punctuation">(</span><span class="token punctuation">)</span>
b<span class="token string">'abc'</span>
<span class="token operator">>></span><span class="token operator">></span> bytes<span class="token punctuation">(</span>m<span class="token punctuation">)</span>
b<span class="token string">'abc'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>对于非连续数组，结果等于平面化表示的列表，其中所有元素都转换为字节串。 <code>tobytes()</code> 支持所有格式字符串，不符合 <code>struct</code> 模块语法的那些也包括在内。</p>
<p>3.8 新版功能: <em>order</em> 可以为 {‘C’, ‘F’, ‘A’}。 当 <em>order</em> 为 ‘C’ 或 ‘F’ 时，原始数组的数据会被转换至 C 或 Fortran 顺序。 对于连续视图，’A’ 会返回物理内存的精确副本。 特别地，内存中的 Fortran 顺序会被保留。对于非连续视图，数据会先被转换为 C 形式。 <em>order=None</em> 与 <em>order=’C’</em> 是相同的。</p>
</li>
<li><p><code>hex</code>([<em>sep</em>[, <em>bytes_per_sep</em>]])</p>
<p>返回一个字符串对象，其中分别以两个十六进制数码表示缓冲区里的每个字节。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> m <span class="token operator">=</span> memoryview<span class="token punctuation">(</span>b<span class="token string">"abc"</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> m<span class="token punctuation">.</span>hex<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token string">'616263'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>3.5 新版功能.</p>
<p>在 3.8 版更改: 与 <code>bytes.hex()</code> 相似， <code>memoryview.hex()</code> 现在支持可选的 <em>sep</em> 和 <em>bytes_per_sep</em> 参数以在十六进制输出的字节之间插入分隔符。</p>
</li>
<li><p><code>tolist</code>()</p>
<p>将缓冲区内的数据以一个元素列表的形式返回。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> memoryview<span class="token punctuation">(</span>b<span class="token string">'abc'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>tolist<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token number">97</span><span class="token punctuation">,</span> <span class="token number">98</span><span class="token punctuation">,</span> <span class="token number">99</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> array
<span class="token operator">>></span><span class="token operator">></span> a <span class="token operator">=</span> array<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token string">'d'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1.1</span><span class="token punctuation">,</span> <span class="token number">2.2</span><span class="token punctuation">,</span> <span class="token number">3.3</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> m <span class="token operator">=</span> memoryview<span class="token punctuation">(</span>a<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> m<span class="token punctuation">.</span>tolist<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token number">1.1</span><span class="token punctuation">,</span> <span class="token number">2.2</span><span class="token punctuation">,</span> <span class="token number">3.3</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在 3.3 版更改: <code>tolist()</code> 现在支持 <code>struct</code> 模块语法中的所有单字符原生格式以及多维表示形式。</p>
</li>
<li><p><code>toreadonly</code>()</p>
<p>返回 memoryview 对象的只读版本。 原始的 memoryview 对象不会被改变。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> m <span class="token operator">=</span> memoryview<span class="token punctuation">(</span>bytearray<span class="token punctuation">(</span>b<span class="token string">'abc'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> mm <span class="token operator">=</span> m<span class="token punctuation">.</span>toreadonly<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> mm<span class="token punctuation">.</span>tolist<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token number">89</span><span class="token punctuation">,</span> <span class="token number">98</span><span class="token punctuation">,</span> <span class="token number">99</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> mm<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">42</span>
Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>
  File <span class="token string">"&lt;stdin>"</span><span class="token punctuation">,</span> line <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">></span>
TypeError<span class="token punctuation">:</span> cannot modify read<span class="token operator">-</span>only memory
<span class="token operator">>></span><span class="token operator">></span> m<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">43</span>
<span class="token operator">>></span><span class="token operator">></span> mm<span class="token punctuation">.</span>tolist<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token number">43</span><span class="token punctuation">,</span> <span class="token number">98</span><span class="token punctuation">,</span> <span class="token number">99</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>3.8 新版功能.</p>
</li>
<li><p><code>release</code>()</p>
<p>释放由内存视图对象所公开的底层缓冲区。 许多对象在被视图所获取时都会采取特殊动作（例如，<code>bytearray</code> 将会暂时禁止调整大小）；因此，调用 release() 可以方便地尽早去除这些限制（并释放任何多余的资源）。</p>
<p>在此方法被调用后，任何对视图的进一步操作将引发 <code>ValueError</code> (<code>release()</code> 本身除外，它可以被多次调用):</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> m <span class="token operator">=</span> memoryview<span class="token punctuation">(</span>b<span class="token string">'abc'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> m<span class="token punctuation">.</span>release<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> m<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>
  File <span class="token string">"&lt;stdin>"</span><span class="token punctuation">,</span> line <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">></span>
ValueError<span class="token punctuation">:</span> operation forbidden on released memoryview object<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>使用 <code>with</code> 语句，可以通过上下文管理协议达到类似的效果:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">with</span> memoryview<span class="token punctuation">(</span>b<span class="token string">'abc'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> m<span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     m<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token number">97</span>
<span class="token operator">>></span><span class="token operator">></span> m<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>
  File <span class="token string">"&lt;stdin>"</span><span class="token punctuation">,</span> line <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">></span>
ValueError<span class="token punctuation">:</span> operation forbidden on released memoryview object<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>3.2 新版功能.</p>
</li>
<li><p><code>cast</code>(<em>format</em>[, <em>shape</em>])</p>
<p>将内存视图转化为新的格式或形状。 <em>shape</em> 默认为 <code>[byte_length//new_itemsize]</code>，这意味着结果视图将是一维的。 返回值是一个新的内存视图，但缓冲区本身不会被复制。 支持的转化有 1D -&gt; C-contiguous 和 C-contiguous -&gt; 1D。</p>
<p>目标格式仅限于 <code>struct</code> 语法中的单一元素原生格式。 其中一种格式必须为字节格式 (‘B’, ‘b’ 或 ‘c’)。 结果的字节长度必须与原始长度相同。</p>
<p>将 1D/long 转换为 1D/unsigned bytes:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> array
<span class="token operator">>></span><span class="token operator">></span> a <span class="token operator">=</span> array<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token string">'l'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> x <span class="token operator">=</span> memoryview<span class="token punctuation">(</span>a<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> x<span class="token punctuation">.</span>format
<span class="token string">'l'</span>
<span class="token operator">>></span><span class="token operator">></span> x<span class="token punctuation">.</span>itemsize
<span class="token number">8</span>
<span class="token operator">>></span><span class="token operator">></span> len<span class="token punctuation">(</span>x<span class="token punctuation">)</span>
<span class="token number">3</span>
<span class="token operator">>></span><span class="token operator">></span> x<span class="token punctuation">.</span>nbytes
<span class="token number">24</span>
<span class="token operator">>></span><span class="token operator">></span> y <span class="token operator">=</span> x<span class="token punctuation">.</span>cast<span class="token punctuation">(</span><span class="token string">'B'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> y<span class="token punctuation">.</span>format
<span class="token string">'B'</span>
<span class="token operator">>></span><span class="token operator">></span> y<span class="token punctuation">.</span>itemsize
<span class="token number">1</span>
<span class="token operator">>></span><span class="token operator">></span> len<span class="token punctuation">(</span>y<span class="token punctuation">)</span>
<span class="token number">24</span>
<span class="token operator">>></span><span class="token operator">></span> y<span class="token punctuation">.</span>nbytes
<span class="token number">24</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>将 1D/unsigned bytes 转换为 1D/char:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> b <span class="token operator">=</span> bytearray<span class="token punctuation">(</span>b<span class="token string">'zyz'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> x <span class="token operator">=</span> memoryview<span class="token punctuation">(</span>b<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> x<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> b<span class="token string">'a'</span>
Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>
  File <span class="token string">"&lt;stdin>"</span><span class="token punctuation">,</span> line <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">></span>
ValueError<span class="token punctuation">:</span> memoryview<span class="token punctuation">:</span> invalid value <span class="token keyword">for</span> format <span class="token string">"B"</span>
<span class="token operator">>></span><span class="token operator">></span> y <span class="token operator">=</span> x<span class="token punctuation">.</span>cast<span class="token punctuation">(</span><span class="token string">'c'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> y<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> b<span class="token string">'a'</span>
<span class="token operator">>></span><span class="token operator">></span> b
bytearray<span class="token punctuation">(</span>b<span class="token string">'ayz'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>将 1D/bytes 转换为 3D/ints 再转换为 1D/signed char:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> struct
<span class="token operator">>></span><span class="token operator">></span> buf <span class="token operator">=</span> struct<span class="token punctuation">.</span>pack<span class="token punctuation">(</span><span class="token string">"i"</span><span class="token operator">*</span><span class="token number">12</span><span class="token punctuation">,</span> <span class="token operator">*</span>list<span class="token punctuation">(</span>range<span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> x <span class="token operator">=</span> memoryview<span class="token punctuation">(</span>buf<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> y <span class="token operator">=</span> x<span class="token punctuation">.</span>cast<span class="token punctuation">(</span><span class="token string">'i'</span><span class="token punctuation">,</span> shape<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> y<span class="token punctuation">.</span>tolist<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> y<span class="token punctuation">.</span>format
<span class="token string">'i'</span>
<span class="token operator">>></span><span class="token operator">></span> y<span class="token punctuation">.</span>itemsize
<span class="token number">4</span>
<span class="token operator">>></span><span class="token operator">></span> len<span class="token punctuation">(</span>y<span class="token punctuation">)</span>
<span class="token number">2</span>
<span class="token operator">>></span><span class="token operator">></span> y<span class="token punctuation">.</span>nbytes
<span class="token number">48</span>
<span class="token operator">>></span><span class="token operator">></span> z <span class="token operator">=</span> y<span class="token punctuation">.</span>cast<span class="token punctuation">(</span><span class="token string">'b'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> z<span class="token punctuation">.</span>format
<span class="token string">'b'</span>
<span class="token operator">>></span><span class="token operator">></span> z<span class="token punctuation">.</span>itemsize
<span class="token number">1</span>
<span class="token operator">>></span><span class="token operator">></span> len<span class="token punctuation">(</span>z<span class="token punctuation">)</span>
<span class="token number">48</span>
<span class="token operator">>></span><span class="token operator">></span> z<span class="token punctuation">.</span>nbytes
<span class="token number">48</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>将 1D/unsigned long 转换为 2D/unsigned long:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> buf <span class="token operator">=</span> struct<span class="token punctuation">.</span>pack<span class="token punctuation">(</span><span class="token string">"L"</span><span class="token operator">*</span><span class="token number">6</span><span class="token punctuation">,</span> <span class="token operator">*</span>list<span class="token punctuation">(</span>range<span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> x <span class="token operator">=</span> memoryview<span class="token punctuation">(</span>buf<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> y <span class="token operator">=</span> x<span class="token punctuation">.</span>cast<span class="token punctuation">(</span><span class="token string">'L'</span><span class="token punctuation">,</span> shape<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> len<span class="token punctuation">(</span>y<span class="token punctuation">)</span>
<span class="token number">2</span>
<span class="token operator">>></span><span class="token operator">></span> y<span class="token punctuation">.</span>nbytes
<span class="token number">48</span>
<span class="token operator">>></span><span class="token operator">></span> y<span class="token punctuation">.</span>tolist<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>3.3 新版功能.</p>
<p>在 3.5 版更改: 当转换为字节视图时，源格式将不再受限。</p>
</li>
</ul>
<p>还存在一些可用的只读属性：</p>
<ul>
<li><p><code>obj</code></p>
<p>内存视图的下层对象:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> b  <span class="token operator">=</span> bytearray<span class="token punctuation">(</span>b<span class="token string">'xyz'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> m <span class="token operator">=</span> memoryview<span class="token punctuation">(</span>b<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> m<span class="token punctuation">.</span>obj <span class="token keyword">is</span> b
<span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>3.3 新版功能.</p>
</li>
<li><p><code>nbytes</code></p>
<p><code>nbytes == product(shape) * itemsize == len(m.tobytes())</code>。 这是数组在连续表示时将会占用的空间总字节数。 它不一定等于 <code>len(m)</code>:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> array
<span class="token operator">>></span><span class="token operator">></span> a <span class="token operator">=</span> array<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token string">'i'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> m <span class="token operator">=</span> memoryview<span class="token punctuation">(</span>a<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> len<span class="token punctuation">(</span>m<span class="token punctuation">)</span>
<span class="token number">5</span>
<span class="token operator">>></span><span class="token operator">></span> m<span class="token punctuation">.</span>nbytes
<span class="token number">20</span>
<span class="token operator">>></span><span class="token operator">></span> y <span class="token operator">=</span> m<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> len<span class="token punctuation">(</span>y<span class="token punctuation">)</span>
<span class="token number">3</span>
<span class="token operator">>></span><span class="token operator">></span> y<span class="token punctuation">.</span>nbytes
<span class="token number">12</span>
<span class="token operator">>></span><span class="token operator">></span> len<span class="token punctuation">(</span>y<span class="token punctuation">.</span>tobytes<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token number">12</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>多维数组:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> struct
<span class="token operator">>></span><span class="token operator">></span> buf <span class="token operator">=</span> struct<span class="token punctuation">.</span>pack<span class="token punctuation">(</span><span class="token string">"d"</span><span class="token operator">*</span><span class="token number">12</span><span class="token punctuation">,</span> <span class="token operator">*</span><span class="token punctuation">[</span><span class="token number">1.5</span><span class="token operator">*</span>x <span class="token keyword">for</span> x <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> x <span class="token operator">=</span> memoryview<span class="token punctuation">(</span>buf<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> y <span class="token operator">=</span> x<span class="token punctuation">.</span>cast<span class="token punctuation">(</span><span class="token string">'d'</span><span class="token punctuation">,</span> shape<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> y<span class="token punctuation">.</span>tolist<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">1.5</span><span class="token punctuation">,</span> <span class="token number">3.0</span><span class="token punctuation">,</span> <span class="token number">4.5</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">6.0</span><span class="token punctuation">,</span> <span class="token number">7.5</span><span class="token punctuation">,</span> <span class="token number">9.0</span><span class="token punctuation">,</span> <span class="token number">10.5</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">12.0</span><span class="token punctuation">,</span> <span class="token number">13.5</span><span class="token punctuation">,</span> <span class="token number">15.0</span><span class="token punctuation">,</span> <span class="token number">16.5</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> len<span class="token punctuation">(</span>y<span class="token punctuation">)</span>
<span class="token number">3</span>
<span class="token operator">>></span><span class="token operator">></span> y<span class="token punctuation">.</span>nbytes
<span class="token number">96</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>3.3 新版功能.</p>
</li>
<li><p><code>readonly</code></p>
<p>一个表明内存是否只读的布尔值。</p>
</li>
<li><p><code>format</code></p>
<p>一个字符串，包含视图中每个元素的格式（表示为 <code>struct</code> 模块样式）。 内存视图可以从具有任意格式字符串的导出器创建，但某些方法 (例如 <code>tolist()</code>) 仅限于原生的单元素格式。</p>
<p>在 3.3 版更改: 格式 <code>'B'</code> 现在会按照 struct 模块语法来处理。 这意味着 <code>memoryview(b'abc')[0] == b'abc'[0] == 97</code>。</p>
</li>
<li><p><code>itemsize</code></p>
<p>memoryview 中每个元素以字节表示的大小:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> array<span class="token punctuation">,</span> struct
<span class="token operator">>></span><span class="token operator">></span> m <span class="token operator">=</span> memoryview<span class="token punctuation">(</span>array<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token string">'H'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">32000</span><span class="token punctuation">,</span> <span class="token number">32001</span><span class="token punctuation">,</span> <span class="token number">32002</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> m<span class="token punctuation">.</span>itemsize
<span class="token number">2</span>
<span class="token operator">>></span><span class="token operator">></span> m<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
<span class="token number">32000</span>
<span class="token operator">>></span><span class="token operator">></span> struct<span class="token punctuation">.</span>calcsize<span class="token punctuation">(</span><span class="token string">'H'</span><span class="token punctuation">)</span> <span class="token operator">==</span> m<span class="token punctuation">.</span>itemsize
<span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><code>ndim</code></p>
<p>一个整数，表示内存所代表的多维数组具有多少个维度。</p>
</li>
<li><p><code>shape</code></p>
<p>一个整数元组，通过 <code>ndim</code> 的长度值给出内存所代表的 N 维数组的形状。</p>
<p>在 3.3 版更改: 当 ndim = 0 时值为空元组而不再为 <code>None</code>。</p>
</li>
<li><p><code>strides</code></p>
<p>一个整数元组，通过 <code>ndim</code> 的长度给出以字节表示的大小，以便访问数组中每个维度上的每个元素。</p>
<p>在 3.3 版更改: 当 ndim = 0 时值为空元组而不再为 <code>None</code>。</p>
</li>
<li><p><code>suboffsets</code></p>
<p>供 PIL 风格的数组内部使用。 该值仅作为参考信息。</p>
</li>
<li><p><code>c_contiguous</code></p>
<p>一个表明内存是否为 C-contiguous 的布尔值。</p>
<p>3.3 新版功能.</p>
</li>
<li><p><code>f_contiguous</code></p>
<p>一个表明内存是否为 Fortran contiguous 的布尔值。</p>
<p>3.3 新版功能.</p>
</li>
<li><p><code>contiguous</code></p>
<p>一个表明内存是否为 contiguous 的布尔值。</p>
<p>3.3 新版功能.</p>
</li>
</ul>
<h2 id="集合类型-—-set-frozenset"><a href="#集合类型-—-set-frozenset" class="headerlink" title="集合类型 —- set, frozenset"></a>集合类型 —- <code>set</code>, <code>frozenset</code></h2><p><em>set</em> 对象是由具有唯一性的 hashable 对象所组成的无序多项集。 常见的用途包括成员检测、从序列中去除重复项以及数学中的集合类计算，例如交集、并集、差集与对称差集等等。 </p>
<p>与其他多项集一样，集合也支持 <code>x in set</code>, <code>len(set)</code> 和 <code>for x in set</code>。 作为一种无序的多项集，集合并不记录元素位置或插入顺序。 相应地，集合不支持索引、切片或其他序列类的操作。</p>
<p>目前有两种内置集合类型，<code>set</code> 和 <code>frozenset</code>。 <code>set</code> 类型是可变的 —- 其内容可以使用 <code>add()</code> 和 <code>remove()</code> 这样的方法来改变。 由于是可变类型，它没有哈希值，且不能被用作字典的键或其他集合的元素。 <code>frozenset</code> 类型是不可变并且为 hashable —- 其内容在被创建后不能再改变；因此它可以被用作字典的键或其他集合的元素。</p>
<p>除了可以使用 <code>set</code> 构造器，非空的 set (不是 frozenset) 还可以通过将以逗号分隔的元素列表包含于花括号之内来创建，例如: <code>{'jack', 'sjoerd'}</code>。</p>
<p>两个类的构造器具有相同的作用方式：</p>
<p><em>class</em> <code>set</code>([<em>iterable</em>])</p>
<p><em>class</em> <code>frozenset</code>([<em>iterable</em>])</p>
<p>返回一个新的 set 或 frozenset 对象，其元素来自于 <em>iterable</em>。 集合的元素必须为 hashable。 要表示由集合对象构成的集合，所有的内层集合必须为 <code>frozenset</code> 对象。 如果未指定 <em>iterable</em>，则将返回一个新的空集合。</p>
<p>集合可用多种方式来创建:</p>
<ul>
<li>使用花括号内以逗号分隔元素的方式: <code>{'jack', 'sjoerd'}</code></li>
<li>使用集合推导式: <code>{c for c in 'abracadabra' if c not in 'abc'}</code></li>
<li>使用类型构造器: <code>set()</code>, <code>set('foobar')</code>, <code>set(['a', 'b', 'foo'])</code></li>
</ul>
<p><code>set</code> 和 <code>frozenset</code> 的实例提供以下操作：</p>
<ul>
<li><p><code>len(s)</code></p>
<p>返回集合 <em>s</em> 中的元素数量（即 <em>s</em> 的基数）。</p>
</li>
<li><p><code>x in s</code></p>
<p>检测 <em>x</em> 是否为 <em>s</em> 中的成员。</p>
</li>
<li><p><code>x not in s</code></p>
<p>检测 <em>x</em> 是否非 <em>s</em> 中的成员。</p>
</li>
<li><p><code>isdisjoint</code>(<em>other</em>)</p>
<p>如果集合中没有与 <em>other</em> 共有的元素则返回 <code>True</code>。 当且仅当两个集合的交集为空集合时，两者为不相交集合。</p>
</li>
<li><p><code>issubset</code>(<em>other</em>)</p>
<p><code>set &lt;= other</code></p>
<p>检测是否集合中的每个元素都在 <em>other</em> 之中。</p>
</li>
<li><p><code>set &lt; other</code></p>
<p>检测集合是否为 <em>other</em> 的真子集，即 <code>set &lt;= other and set != other</code>。</p>
</li>
<li><p><code>issuperset</code>(<em>other</em>)</p>
<p><code>set &gt;= other</code></p>
<p>检测是否 <em>other</em> 中的每个元素都在集合之中。</p>
</li>
<li><p><code>set &gt; other</code></p>
<p>检测集合是否为 <em>other</em> 的真超集，即 <code>set &gt;= other and set != other</code>。</p>
</li>
<li><p><code>union</code>(<em>\</em>others*)</p>
<p><code>set | other | ...</code></p>
<p>返回一个新集合，其中包含来自原集合以及 others 指定的所有集合中的元素。</p>
</li>
<li><p><code>intersection</code>(<em>\</em>others*)</p>
<p><code>set &amp; other &amp; ...</code></p>
<p>返回一个新集合，其中包含原集合以及 others 指定的所有集合中共有的元素。</p>
</li>
<li><p><code>difference</code>(<em>\</em>others*)</p>
<p><code>set - other - ...</code></p>
<p>返回一个新集合，其中包含原集合中在 others 指定的其他集合中不存在的元素。</p>
</li>
<li><p><code>symmetric_difference</code>(<em>other</em>)</p>
<p><code>set ^ other</code></p>
<p>返回一个新集合，其中的元素或属于原集合或属于 <em>other</em> 指定的其他集合，但不能同时属于两者。</p>
</li>
<li><p><code>copy</code>()</p>
<p>返回原集合的浅拷贝。</p>
</li>
</ul>
<p>Note, the non-operator versions of <code>union()</code>, <code>intersection()</code>, <code>difference()</code>, <code>symmetric_difference()</code>, <code>issubset()</code>, and <code>issuperset()</code> methods will accept any iterable as an argument. In contrast, their operator based counterparts require their arguments to be sets. This precludes error-prone constructions like <code>set('abc') &amp; 'cbs'</code> in favor of the more readable <code>set('abc').intersection('cbs')</code>.</p>
<p><code>set</code> 和 <code>frozenset</code> 均支持集合与集合的比较。 两个集合当且仅当每个集合中的每个元素均包含于另一个集合之内（即各为对方的子集）时则相等。 一个集合当且仅当其为另一个集合的真子集（即为后者的子集但两者不相等）时则小于另一个集合。 一个集合当且仅当其为另一个集合的真超集（即为后者的超集但两者不相等）时则大于另一个集合。</p>
<p><code>set</code> 的实例与 <code>frozenset</code> 的实例之间基于它们的成员进行比较。 例如 <code>set('abc') == frozenset('abc')</code> 返回 <code>True</code>，<code>set('abc') in set([frozenset('abc')])</code> 也一样。</p>
<p>子集与相等比较并不能推广为完全排序函数。 例如，任意两个非空且不相交的集合不相等且互不为对方的子集，因此以下 <em>所有</em> 比较均返回 <code>False</code>: <code>a&lt;b</code>, <code>a==b</code>, or <code>a&gt;b</code>。</p>
<p>由于集合仅定义了部分排序（子集关系），因此由集合构成的列表 <code>list.sort()</code> 方法的输出并无定义。</p>
<p>集合的元素，与字典的键类似，必须为 hashable。</p>
<p>混合了 <code>set</code> 实例与 <code>frozenset</code> 的二进制位运算将返回与第一个操作数相同的类型。例如: <code>frozenset('ab') | set('bc')</code> 将返回 <code>frozenset</code> 的实例。</p>
<p>下表列出了可用于 <code>set</code> 而不能用于不可变的 <code>frozenset</code> 实例的操作：</p>
<ul>
<li><p><code>update</code>(<em>\</em>others*)</p>
<p><code>set |= other | ...</code></p>
<p>更新集合，添加来自 others 中的所有元素。</p>
</li>
<li><p><code>intersection_update</code>(<em>\</em>others*)</p>
<p><code>set &amp;= other &amp; ...</code></p>
<p>更新集合，只保留其中在所有 others 中也存在的元素。</p>
</li>
<li><p><code>difference_update</code>(<em>\</em>others*)</p>
<p><code>set -= other | ...</code></p>
<p>更新集合，移除其中也存在于 others 中的元素。</p>
</li>
<li><p><code>symmetric_difference_update</code>(<em>other</em>)</p>
<p><code>set ^= other</code></p>
<p>更新集合，只保留存在于集合的一方而非共同存在的元素。</p>
</li>
<li><p><code>add</code>(<em>elem</em>)</p>
<p>将元素 <em>elem</em> 添加到集合中。</p>
</li>
<li><p><code>remove</code>(<em>elem</em>)</p>
<p>从集合中移除元素 <em>elem*。 如果 *elem</em> 不存在于集合中则会引发 <code>KeyError</code>。</p>
</li>
<li><p><code>discard</code>(<em>elem</em>)</p>
<p>如果元素 <em>elem</em> 存在于集合中则将其移除。</p>
</li>
<li><p><code>pop</code>()</p>
<p>从集合中移除并返回任意一个元素。 如果集合为空则会引发 <code>KeyError</code>。</p>
</li>
<li><p><code>clear</code>()</p>
<p>从集合中移除所有元素。</p>
</li>
</ul>
<p>请注意，非运算符版本的 <code>update()</code>, <code>intersection_update()</code>, <code>difference_update()</code> 和 <code>symmetric_difference_update()</code> 方法将接受任意可迭代对象作为参数。</p>
<p>请注意，<code>__contains__()</code>, <code>remove()</code> 和 <code>discard()</code> 方法的 <em>elem</em> 参数可能是一个 set。 为支持对一个等价的 frozenset 进行搜索，会根据 <em>elem</em> 临时创建一个该类型对象。</p>
<h2 id="映射类型-—-dict"><a href="#映射类型-—-dict" class="headerlink" title="映射类型 —- dict"></a>映射类型 —- <code>dict</code></h2><p>mapping 对象会将 hashable 值映射到任意对象。 映射属于可变对象。 目前仅有一种标准映射类型 <em>字典</em>。 </p>
<p>字典的键 <em>几乎</em> 可以是任何值。 非 hashable 的值，即包含列表、字典或其他可变类型的值（此类对象基于值而非对象标识进行比较）不可用作键。 数字类型用作键时遵循数字比较的一般规则：如果两个数值相等 (例如 <code>1</code> 和 <code>1.0</code>) 则两者可以被用来索引同一字典条目。 （但是请注意，由于计算机对于浮点数存储的只是近似值，因此将其用作字典键是不明智的。）</p>
<p>字典可以通过将以逗号分隔的 <code>键: 值</code> 对列表包含于花括号之内来创建，例如: <code>{'jack': 4098, 'sjoerd': 4127}</code> 或 <code>{4098: 'jack', 4127: 'sjoerd'}</code>，也可以通过 <code>dict</code> 构造器来创建。</p>
<p><em>class</em> <code>dict</code>(<em>**kwarg</em>)</p>
<p><em>class</em> <code>dict</code>(<em>mapping</em>, <em>**kwarg</em>)</p>
<p><em>class</em> <code>dict</code>(<em>iterable</em>, <em>**kwarg</em>)</p>
<p>返回一个新的字典，基于可选的位置参数和可能为空的关键字参数集来初始化。</p>
<p>字典可用多种方式来创建:</p>
<ul>
<li>使用花括号内以逗号分隔 <code>键: 值</code> 对的方式: <code>{'jack': 4098, 'sjoerd': 4127}</code> or <code>{4098: 'jack', 4127: 'sjoerd'}</code></li>
<li>使用字典推导式: <code>{}</code>, <code>{x: x ** 2 for x in range(10)}</code></li>
<li>使用类型构造器: <code>dict()</code>, <code>dict([('foo', 100), ('bar', 200)])</code>, <code>dict(foo=100, bar=200)</code></li>
</ul>
<p>如果没有给出位置参数，将创建一个空字典。 如果给出一个位置参数并且其属于映射对象，将创建一个具有与映射对象相同键值对的字典。 否则的话，位置参数必须为一个 iterable 对象。 该可迭代对象中的每一项本身必须为一个刚好包含两个元素的可迭代对象。 每一项中的第一个对象将成为新字典的一个键，第二个对象将成为其对应的值。 如果一个键出现一次以上，该键的最后一个值将成为其在新字典中对应的值。</p>
<p>如果给出了关键字参数，则关键字参数及其值会被加入到基于位置参数创建的字典。 如果要加入的键已存在，来自关键字参数的值将替代来自位置参数的值。</p>
<p>作为演示，以下示例返回的字典均等于 <code>{"one": 1, "two": 2, "three": 3}</code>:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> a <span class="token operator">=</span> dict<span class="token punctuation">(</span>one<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> two<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span> three<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> b <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'one'</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'two'</span><span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">'three'</span><span class="token punctuation">:</span> <span class="token number">3</span><span class="token punctuation">}</span>
<span class="token operator">>></span><span class="token operator">></span> c <span class="token operator">=</span> dict<span class="token punctuation">(</span>zip<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'one'</span><span class="token punctuation">,</span> <span class="token string">'two'</span><span class="token punctuation">,</span> <span class="token string">'three'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> d <span class="token operator">=</span> dict<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token string">'two'</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'one'</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'three'</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> e <span class="token operator">=</span> dict<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">'three'</span><span class="token punctuation">:</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">'one'</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'two'</span><span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> f <span class="token operator">=</span> dict<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">'one'</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'three'</span><span class="token punctuation">:</span> <span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">,</span> two<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> a <span class="token operator">==</span> b <span class="token operator">==</span> c <span class="token operator">==</span> d <span class="token operator">==</span> e <span class="token operator">==</span> f
<span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>像第一个例子那样提供关键字参数的方式只能使用有效的 Python 标识符作为键。 其他方式则可使用任何有效的键。</p>
<p>这些是字典所支持的操作（因而自定义的映射类型也应当支持）：</p>
<ul>
<li><p><code>list(d)</code></p>
<p>返回字典 <em>d</em> 中使用的所有键的列表。</p>
</li>
<li><p><code>len(d)</code></p>
<p>返回字典 <em>d</em> 中的项数。</p>
</li>
<li><p><code>d[key]</code></p>
<p>返回 <em>d</em> 中以 <em>key</em> 为键的项。 如果映射中不存在 <em>key</em> 则会引发 <code>KeyError</code>。</p>
<p>如果字典的子类定义了方法 <code>__missing__()</code> 并且 <em>key</em> 不存在，则 <code>d[key]</code> 操作将调用该方法并附带键 <em>key</em> 作为参数。 <code>d[key]</code> 随后将返回或引发 <code>__missing__(key)</code> 调用所返回或引发的任何对象或异常。 没有其他操作或方法会发起调用 <code>__missing__()</code>。 如果未定义 <code>__missing__()</code>，则会引发 <code>KeyError</code>。 <code>__missing__()</code> 必须是一个方法；它不能是一个实例变量:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">class</span> <span class="token class-name">Counter</span><span class="token punctuation">(</span>dict<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">def</span> <span class="token function">__missing__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         <span class="token keyword">return</span> <span class="token number">0</span>
<span class="token operator">>></span><span class="token operator">></span> c <span class="token operator">=</span> Counter<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> c<span class="token punctuation">[</span><span class="token string">'red'</span><span class="token punctuation">]</span>
<span class="token number">0</span>
<span class="token operator">>></span><span class="token operator">></span> c<span class="token punctuation">[</span><span class="token string">'red'</span><span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span>
<span class="token operator">>></span><span class="token operator">></span> c<span class="token punctuation">[</span><span class="token string">'red'</span><span class="token punctuation">]</span>
<span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>上面的例子显示了 <code>collections.Counter</code> 实现的部分代码。 还有另一个不同的 <code>__missing__</code> 方法是由 <code>collections.defaultdict</code> 所使用的。</p>
</li>
<li><p><code>d[key] = value</code></p>
<p>将 <code>d[key]</code> 设为 <em>value</em>。</p>
</li>
<li><p><code>del d[key]</code></p>
<p>将 <code>d[key]</code> 从 <em>d</em> 中移除。 如果映射中不存在 <em>key</em> 则会引发 <code>KeyError</code>。</p>
</li>
<li><p><code>key in d</code></p>
<p>如果 <em>d</em> 中存在键 <em>key</em> 则返回 <code>True</code>，否则返回 <code>False</code>。</p>
</li>
<li><p><code>key not in d</code></p>
<p>等价于 <code>not key in d</code>。</p>
</li>
<li><p><code>iter(d)</code></p>
<p>返回以字典的键为元素的迭代器。 这是 <code>iter(d.keys())</code> 的快捷方式。</p>
</li>
<li><p><code>clear</code>()</p>
<p>移除字典中的所有元素。</p>
</li>
<li><p><code>copy</code>()</p>
<p>返回原字典的浅拷贝。</p>
</li>
<li><p><em>classmethod</em> <code>fromkeys</code>(<em>iterable</em>[, <em>value</em>])</p>
<p>使用来自 <em>iterable</em> 的键创建一个新字典，并将键值设为 <em>value</em>。</p>
<p><code>fromkeys()</code> 是一个返回新字典的类方法。 <em>value</em> 默认为 <code>None</code>。 所有值都只引用一个单独的实例，因此让 <em>value</em> 成为一个可变对象例如空列表通常是没有意义的。 要获取不同的值，请改用 字典推导式。</p>
</li>
<li><p><code>get</code>(<em>key</em>[, <em>default</em>])</p>
<p>如果 <em>key</em> 存在于字典中则返回 <em>key</em> 的值，否则返回 <em>default*。 如果 *default</em> 未给出则默认为 <code>None</code>，因而此方法绝不会引发 <code>KeyError</code>。</p>
</li>
<li><p><code>items</code>()</p>
<p>返回由字典项 (<code>(键, 值)</code> 对) 组成的一个新视图。 </p>
</li>
<li><p><code>keys</code>()</p>
<p>返回由字典键组成的一个新视图。 </p>
</li>
<li><p><code>pop</code>(<em>key</em>[, <em>default</em>])</p>
<p>如果 <em>key</em> 存在于字典中则将其移除并返回其值，否则返回 <em>default*。 如果 *default</em> 未给出且 <em>key</em> 不存在于字典中，则会引发 <code>KeyError</code>。</p>
</li>
<li><p><code>popitem</code>()</p>
<p>从字典中移除并返回一个 <code>(键, 值)</code> 对。 键值对会按 LIFO 的顺序被返回。</p>
<p><code>popitem()</code> 适用于对字典进行消耗性的迭代，这在集合算法中经常被使用。 如果字典为空，调用 <code>popitem()</code> 将引发 <code>KeyError</code>。</p>
<p>在 3.7 版更改: 现在会确保采用 LIFO 顺序。 在之前的版本中，<code>popitem()</code> 会返回一个任意的键/值对。</p>
</li>
<li><p><code>reversed(d)</code></p>
<p>返回一个逆序获取字典键的迭代器。 这是 <code>reversed(d.keys())</code> 的快捷方式。</p>
<p>3.8 新版功能.</p>
</li>
<li><p><code>setdefault</code>(<em>key</em>[, <em>default</em>])</p>
<p>如果字典存在键 <em>key</em> ，返回它的值。如果不存在，插入值为 <em>default</em> 的键 <em>key</em> ，并返回 <em>default</em> 。 <em>default</em> 默认为 <code>None</code>。</p>
</li>
<li><p><code>update</code>([<em>other</em>])</p>
<p>使用来自 <em>other</em> 的键/值对更新字典，覆盖原有的键。 返回 <code>None</code>。</p>
<p><code>update()</code> 接受另一个字典对象，或者一个包含键/值对（以长度为二的元组或其他可迭代对象表示）的可迭代对象。 如果给出了关键字参数，则会以其所指定的键/值对更新字典: <code>d.update(red=1, blue=2)</code>。</p>
</li>
<li><p><code>values</code>()</p>
<p>返回由字典值组成的一个新视图。 </p>
<p>两个 <code>dict.values()</code> 视图之间的相等性比较将总是返回 <code>False</code>。 这在 <code>dict.values()</code> 与其自身比较时也同样适用:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> d <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'a'</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">}</span>
<span class="token operator">>></span><span class="token operator">></span> d<span class="token punctuation">.</span>values<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> d<span class="token punctuation">.</span>values<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><code>d | other</code></p>
<p>合并 <em>d</em> 和 <em>other</em> 中的键和值来创建一个新的字典，两者必须都是字典。当 <em>d</em> 和 <em>other</em> 有相同键时， <em>other</em> 的值优先。</p>
<p>3.9 新版功能.</p>
</li>
<li><p><code>d |= other</code></p>
<p>用 <em>other</em> 的键和值更新字典 <em>d</em> ，<em>other</em> 可以是 mapping 或 iterable 的键值对。当 <em>d</em> 和 <em>other</em> 有相同键时， <em>other</em> 的值优先。</p>
<p>3.9 新版功能.</p>
</li>
</ul>
<p>两个字典的比较当且仅当它们具有相同的 <code>(键, 值)</code> 对时才会相等（不考虑顺序）。 排序比较 (‘&lt;’, ‘&lt;=’, ‘&gt;=’, ‘&gt;’) 会引发 <code>TypeError</code>。</p>
<p>字典会保留插入时的顺序。 请注意对键的更新不会影响顺序。 删除并再次添加的键将被插入到末尾。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> d <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"one"</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"two"</span><span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">"three"</span><span class="token punctuation">:</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">"four"</span><span class="token punctuation">:</span> <span class="token number">4</span><span class="token punctuation">}</span>
<span class="token operator">>></span><span class="token operator">></span> d
<span class="token punctuation">{</span><span class="token string">'one'</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'two'</span><span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">'three'</span><span class="token punctuation">:</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">'four'</span><span class="token punctuation">:</span> <span class="token number">4</span><span class="token punctuation">}</span>
<span class="token operator">>></span><span class="token operator">></span> list<span class="token punctuation">(</span>d<span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token string">'one'</span><span class="token punctuation">,</span> <span class="token string">'two'</span><span class="token punctuation">,</span> <span class="token string">'three'</span><span class="token punctuation">,</span> <span class="token string">'four'</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> list<span class="token punctuation">(</span>d<span class="token punctuation">.</span>values<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> d<span class="token punctuation">[</span><span class="token string">"one"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">42</span>
<span class="token operator">>></span><span class="token operator">></span> d
<span class="token punctuation">{</span><span class="token string">'one'</span><span class="token punctuation">:</span> <span class="token number">42</span><span class="token punctuation">,</span> <span class="token string">'two'</span><span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">'three'</span><span class="token punctuation">:</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">'four'</span><span class="token punctuation">:</span> <span class="token number">4</span><span class="token punctuation">}</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">del</span> d<span class="token punctuation">[</span><span class="token string">"two"</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> d<span class="token punctuation">[</span><span class="token string">"two"</span><span class="token punctuation">]</span> <span class="token operator">=</span> None
<span class="token operator">>></span><span class="token operator">></span> d
<span class="token punctuation">{</span><span class="token string">'one'</span><span class="token punctuation">:</span> <span class="token number">42</span><span class="token punctuation">,</span> <span class="token string">'three'</span><span class="token punctuation">:</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">'four'</span><span class="token punctuation">:</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token string">'two'</span><span class="token punctuation">:</span> None<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在 3.7 版更改: 字典顺序会确保为插入顺序。 此行为是自 3.6 版开始的 CPython 实现细节。</p>
<p>字典和字典视图都是可逆的。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> d <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"one"</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"two"</span><span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">"three"</span><span class="token punctuation">:</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">"four"</span><span class="token punctuation">:</span> <span class="token number">4</span><span class="token punctuation">}</span>
<span class="token operator">>></span><span class="token operator">></span> d
<span class="token punctuation">{</span><span class="token string">'one'</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'two'</span><span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">'three'</span><span class="token punctuation">:</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">'four'</span><span class="token punctuation">:</span> <span class="token number">4</span><span class="token punctuation">}</span>
<span class="token operator">>></span><span class="token operator">></span> list<span class="token punctuation">(</span>reversed<span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token string">'four'</span><span class="token punctuation">,</span> <span class="token string">'three'</span><span class="token punctuation">,</span> <span class="token string">'two'</span><span class="token punctuation">,</span> <span class="token string">'one'</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> list<span class="token punctuation">(</span>reversed<span class="token punctuation">(</span>d<span class="token punctuation">.</span>values<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> list<span class="token punctuation">(</span>reversed<span class="token punctuation">(</span>d<span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token string">'four'</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'three'</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'two'</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'one'</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在 3.8 版更改: 字典现在是可逆的。</p>
<h3 id="字典视图对象"><a href="#字典视图对象" class="headerlink" title="字典视图对象"></a>字典视图对象</h3><p>由 <code>dict.keys()</code>, <code>dict.values()</code> 和 <code>dict.items()</code> 所返回的对象是 <em>视图对象</em>。 该对象提供字典条目的一个动态视图，这意味着当字典改变时，视图也会相应改变。</p>
<p>字典视图可以被迭代以产生与其对应的数据，并支持成员检测：</p>
<pre><code>len(dictview)</code></pre><p>返回字典中的条目数。</p>
<pre><code>iter(dictview)</code></pre><p>返回字典中的键、值或项（以 <code>(键, 值)</code> 为元素的元组表示）的迭代器。</p>
<p>键和值是按插入时的顺序进行迭代的。 这样就允许使用 <code>zip()</code> 来创建 <code>(值, 键)</code> 对: <code>pairs = zip(d.values(), d.keys())</code>。 另一个创建相同列表的方式是 <code>pairs = [(v, k) for (k, v) in d.items()]</code>.</p>
<p>在添加或删除字典中的条目期间对视图进行迭代可能引发 <code>RuntimeError</code> 或者无法完全迭代所有条目。</p>
<p>在 3.7 版更改: 字典顺序会确保为插入顺序。</p>
<pre><code>x in dictview</code></pre><p>如果 <em>x</em> 是对应字典中存在的键、值或项（在最后一种情况下 <em>x</em> 应为一个 <code>(键, 值)</code> 元组） 则返回 <code>True</code>。</p>
<pre><code>reversed(dictview)</code></pre><p>返回一个逆序获取字典键、值或项的迭代器。 视图将按与插入时相反的顺序进行迭代。</p>
<p>在 3.8 版更改: 字典视图现在是可逆的。</p>
<pre><code>dictview.mapping</code></pre><p>Return a <code>types.MappingProxyType</code> that wraps the original dictionary to which the view refers.</p>
<p>3.10 新版功能.</p>
<p>键视图类似于集合，因为其条目不重复且可哈希。 如果所有值都是可哈希的，即 <code>(键, 值)</code> 对也是不重复且可哈希的，那么条目视图也会类似于集合。 （值视图则不被视为类似于集合，因其条目通常都是有重复的。） 对于类似于集合的视图，为抽象基类 <code>collections.abc.Set</code> 所定义的全部操作都是有效的 (例如 <code>==</code>, <code>&lt;</code> 或 <code>^</code>)。</p>
<p>一个使用字典视图的示例:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> dishes <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'eggs'</span><span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">'sausage'</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'bacon'</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'spam'</span><span class="token punctuation">:</span> <span class="token number">500</span><span class="token punctuation">}</span>
<span class="token operator">>></span><span class="token operator">></span> keys <span class="token operator">=</span> dishes<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> values <span class="token operator">=</span> dishes<span class="token punctuation">.</span>values<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token comment" spellcheck="true"># iteration</span>
<span class="token operator">>></span><span class="token operator">></span> n <span class="token operator">=</span> <span class="token number">0</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">for</span> val <span class="token keyword">in</span> values<span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     n <span class="token operator">+=</span> val
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span>
<span class="token number">504</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token comment" spellcheck="true"># keys and values are iterated over in the same order (insertion order)</span>
<span class="token operator">>></span><span class="token operator">></span> list<span class="token punctuation">(</span>keys<span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token string">'eggs'</span><span class="token punctuation">,</span> <span class="token string">'sausage'</span><span class="token punctuation">,</span> <span class="token string">'bacon'</span><span class="token punctuation">,</span> <span class="token string">'spam'</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> list<span class="token punctuation">(</span>values<span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token comment" spellcheck="true"># view objects are dynamic and reflect dict changes</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">del</span> dishes<span class="token punctuation">[</span><span class="token string">'eggs'</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">del</span> dishes<span class="token punctuation">[</span><span class="token string">'sausage'</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> list<span class="token punctuation">(</span>keys<span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token string">'bacon'</span><span class="token punctuation">,</span> <span class="token string">'spam'</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token comment" spellcheck="true"># set operations</span>
<span class="token operator">>></span><span class="token operator">></span> keys <span class="token operator">&amp;</span> <span class="token punctuation">{</span><span class="token string">'eggs'</span><span class="token punctuation">,</span> <span class="token string">'bacon'</span><span class="token punctuation">,</span> <span class="token string">'salad'</span><span class="token punctuation">}</span>
<span class="token punctuation">{</span><span class="token string">'bacon'</span><span class="token punctuation">}</span>
<span class="token operator">>></span><span class="token operator">></span> keys <span class="token operator">^</span> <span class="token punctuation">{</span><span class="token string">'sausage'</span><span class="token punctuation">,</span> <span class="token string">'juice'</span><span class="token punctuation">}</span>
<span class="token punctuation">{</span><span class="token string">'juice'</span><span class="token punctuation">,</span> <span class="token string">'sausage'</span><span class="token punctuation">,</span> <span class="token string">'bacon'</span><span class="token punctuation">,</span> <span class="token string">'spam'</span><span class="token punctuation">}</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token comment" spellcheck="true"># get back a read-only proxy for the original dictionary</span>
<span class="token operator">>></span><span class="token operator">></span> values<span class="token punctuation">.</span>mapping
mappingproxy<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">'eggs'</span><span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">'sausage'</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'bacon'</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'spam'</span><span class="token punctuation">:</span> <span class="token number">500</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> values<span class="token punctuation">.</span>mapping<span class="token punctuation">[</span><span class="token string">'spam'</span><span class="token punctuation">]</span>
<span class="token number">500</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="上下文管理器类型"><a href="#上下文管理器类型" class="headerlink" title="上下文管理器类型"></a>上下文管理器类型</h2><p>Python 的 <code>with</code> 语句支持通过上下文管理器所定义的运行时上下文这一概念。 此对象的实现使用了一对专门方法，允许用户自定义类来定义运行时上下文，在语句体被执行前进入该上下文，并在语句执行完毕时退出该上下文：</p>
<p><code>contextmanager.__enter__</code>()</p>
<p>进入运行时上下文并返回此对象或关联到该运行时上下文的其他对象。 此方法的返回值会绑定到使用此上下文管理器的 <code>with</code> 语句的 <code>as</code> 子句中的标识符。</p>
<p>一个返回其自身的上下文管理器的例子是 file object。 文件对象会从 <strong>enter</strong>() 返回其自身，以允许 <code>open()</code> 被用作 <code>with</code> 语句中的上下文表达式。</p>
<p>一个返回关联对象的上下文管理器的例子是 <code>decimal.localcontext()</code> 所返回的对象。 此种管理器会将活动的 decimal 上下文设为原始 decimal 上下文的一个副本并返回该副本。 这允许对 <code>with</code> 语句的语句体中的当前 decimal 上下文进行更改，而不会影响 <code>with</code> 语句以外的代码。</p>
<p><code>contextmanager.__exit__</code>(<em>exc_type</em>, <em>exc_val</em>, <em>exc_tb</em>)</p>
<p>退出运行时上下文并返回一个布尔值旗标来表明所发生的任何异常是否应当被屏蔽。 如果在执行 <code>with</code> 语句的语句体期间发生了异常，则参数会包含异常的类型、值以及回溯信息。 在其他情况下三个参数均为 <code>None</code>。</p>
<p>自此方法返回一个真值将导致 <code>with</code> 语句屏蔽异常并继续执行紧随在 <code>with</code> 语句之后的语句。 否则异常将在此方法结束执行后继续传播。 在此方法执行期间发生的异常将会取代 <code>with</code> 语句的语句体中发生的任何异常。</p>
<p>传入的异常绝对不应当被显式地重新引发 —— 相反地，此方法应当返回一个假值以表明方法已成功完成并且不希望屏蔽被引发的异常。 这允许上下文管理代码方便地检测 <code>__exit__()</code> 方法是否确实已失败。</p>
<p>Python 定义了一些上下文管理器来支持简易的线程同步、文件或其他对象的快速关闭，以及更方便地操作活动的十进制算术上下文。 除了实现上下文管理协议以外，不同类型不会被特殊处理。 </p>
<p>Python 的 generator 和 <code>contextlib.contextmanager</code> 装饰器提供了实现这些协议的便捷方式。 如果使用 <code>contextlib.contextmanager</code> 装饰器来装饰一个生成器函数，它将返回一个实现了必要的 <code>__enter__()</code> and <code>__exit__()</code> 方法的上下文管理器，而不再是由未经装饰的生成器函数所产生的迭代器。</p>
<p>请注意，Python/C API 中 Python 对象的类型结构中并没有针对这些方法的专门槽位。 想要定义这些方法的扩展类型必须将它们作为普通的 Python 可访问方法来提供。 与设置运行时上下文的开销相比，单个类字典查找的开销可以忽略不计。</p>
<h2 id="Type-Annotation-Types-—-Generic-Alias-Union"><a href="#Type-Annotation-Types-—-Generic-Alias-Union" class="headerlink" title="Type Annotation Types —- Generic Alias, Union"></a>Type Annotation Types —- Generic Alias, Union</h2><p>The core built-in types for type annotations are Generic Alias and Union.</p>
<h3 id="Generic-Alias-Type"><a href="#Generic-Alias-Type" class="headerlink" title="Generic Alias Type"></a>Generic Alias Type</h3><p><code>GenericAlias</code> objects are created by subscripting a class (usually a container), such as <code>list[int]</code>. They are intended primarily for type annotations.</p>
<p>Usually, the subscription of container objects calls the method <code>__getitem__()</code> of the object. However, the subscription of some containers’ classes may call the classmethod <code>__class_getitem__()</code> of the class instead. The classmethod <code>__class_getitem__()</code> should return a <code>GenericAlias</code> object.</p>
<p>注解</p>
<p>If the <code>__getitem__()</code> of the class’ metaclass is present, it will take precedence over the <code>__class_getitem__()</code> defined in the class (see <a href="https://www.python.org/dev/peps/pep-0560" target="_blank" rel="noopener"><strong>PEP 560</strong></a> for more details).</p>
<p>The <code>GenericAlias</code> object acts as a proxy for generic types, implementing <em>parameterized generics</em> - a specific instance of a generic which provides the types for container elements.</p>
<p>The user-exposed type for the <code>GenericAlias</code> object can be accessed from <code>types.GenericAlias</code> and used for <code>isinstance()</code> checks. It can also be used to create <code>GenericAlias</code> objects directly.</p>
<pre><code>T[X, Y, ...]</code></pre><p>Creates a <code>GenericAlias</code> representing a type <code>T</code> containing elements of types <em>X</em>, <em>Y</em>, and more depending on the <code>T</code> used. For example, a function expecting a <code>list</code> containing <code>float</code> elements:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">average</span><span class="token punctuation">(</span>values<span class="token punctuation">:</span> list<span class="token punctuation">[</span>float<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> float<span class="token punctuation">:</span>
    <span class="token keyword">return</span> sum<span class="token punctuation">(</span>values<span class="token punctuation">)</span> <span class="token operator">/</span> len<span class="token punctuation">(</span>values<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>Another example for mapping objects, using a <code>dict</code>, which is a generic type expecting two type parameters representing the key type and the value type. In this example, the function expects a <code>dict</code> with keys of type <code>str</code> and values of type <code>int</code>:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">send_post_request</span><span class="token punctuation">(</span>url<span class="token punctuation">:</span> str<span class="token punctuation">,</span> body<span class="token punctuation">:</span> dict<span class="token punctuation">[</span>str<span class="token punctuation">,</span> int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> None<span class="token punctuation">:</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>The builtin functions <code>isinstance()</code> and <code>issubclass()</code> do not accept <code>GenericAlias</code> types for their second argument:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> isinstance<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> list<span class="token punctuation">[</span>str<span class="token punctuation">]</span><span class="token punctuation">)</span>
Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>
  File <span class="token string">"&lt;stdin>"</span><span class="token punctuation">,</span> line <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">></span>
TypeError<span class="token punctuation">:</span> isinstance<span class="token punctuation">(</span><span class="token punctuation">)</span> argument <span class="token number">2</span> cannot be a parameterized generic<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>The Python runtime does not enforce type annotations. This extends to generic types and their type parameters. When creating an object from a <code>GenericAlias</code>, container elements are not checked against their type. For example, the following code is discouraged, but will run without errors:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> t <span class="token operator">=</span> list<span class="token punctuation">[</span>str<span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> t<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>Furthermore, parameterized generics erase type parameters during object creation:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> t <span class="token operator">=</span> list<span class="token punctuation">[</span>str<span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> type<span class="token punctuation">(</span>t<span class="token punctuation">)</span>
<span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token string">'types.GenericAlias'</span><span class="token operator">></span>
<span class="token operator">>></span><span class="token operator">></span> l <span class="token operator">=</span> t<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> type<span class="token punctuation">(</span>l<span class="token punctuation">)</span>
<span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token string">'list'</span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>Calling <code>repr()</code> or <code>str()</code> on a generic shows the parameterized type:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> repr<span class="token punctuation">(</span>list<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token string">'list[int]'</span>
<span class="token operator">>></span><span class="token operator">></span> str<span class="token punctuation">(</span>list<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token string">'list[int]'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>The <code>__getitem__()</code> method of generics will raise an exception to disallow mistakes like <code>dict[str][str]</code>:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> dict<span class="token punctuation">[</span>str<span class="token punctuation">]</span><span class="token punctuation">[</span>str<span class="token punctuation">]</span>
Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>
  File <span class="token string">"&lt;stdin>"</span><span class="token punctuation">,</span> line <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">></span>
TypeError<span class="token punctuation">:</span> There are no type variables left <span class="token keyword">in</span> dict<span class="token punctuation">[</span>str<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>However, such expressions are valid when type variables are used. The index must have as many elements as there are type variable items in the <code>GenericAlias</code> object’s <code>__args__</code>.</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> typing <span class="token keyword">import</span> TypeVar
<span class="token operator">>></span><span class="token operator">></span> Y <span class="token operator">=</span> TypeVar<span class="token punctuation">(</span><span class="token string">'Y'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> dict<span class="token punctuation">[</span>str<span class="token punctuation">,</span> Y<span class="token punctuation">]</span><span class="token punctuation">[</span>int<span class="token punctuation">]</span>
dict<span class="token punctuation">[</span>str<span class="token punctuation">,</span> int<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="Standard-Generic-Collections"><a href="#Standard-Generic-Collections" class="headerlink" title="Standard Generic Collections"></a>Standard Generic Collections</h4><p>These standard library collections support parameterized generics.</p>
<ul>
<li><code>tuple</code></li>
<li><code>list</code></li>
<li><code>dict</code></li>
<li><code>set</code></li>
<li><code>frozenset</code></li>
<li><code>type</code></li>
<li><code>collections.deque</code></li>
<li><code>collections.defaultdict</code></li>
<li><code>collections.OrderedDict</code></li>
<li><code>collections.Counter</code></li>
<li><code>collections.ChainMap</code></li>
<li><code>collections.abc.Awaitable</code></li>
<li><code>collections.abc.Coroutine</code></li>
<li><code>collections.abc.AsyncIterable</code></li>
<li><code>collections.abc.AsyncIterator</code></li>
<li><code>collections.abc.AsyncGenerator</code></li>
<li><code>collections.abc.Iterable</code></li>
<li><code>collections.abc.Iterator</code></li>
<li><code>collections.abc.Generator</code></li>
<li><code>collections.abc.Reversible</code></li>
<li><code>collections.abc.Container</code></li>
<li><code>collections.abc.Collection</code></li>
<li><code>collections.abc.Callable</code></li>
<li><code>collections.abc.Set</code></li>
<li><code>collections.abc.MutableSet</code></li>
<li><code>collections.abc.Mapping</code></li>
<li><code>collections.abc.MutableMapping</code></li>
<li><code>collections.abc.Sequence</code></li>
<li><code>collections.abc.MutableSequence</code></li>
<li><code>collections.abc.ByteString</code></li>
<li><code>collections.abc.MappingView</code></li>
<li><code>collections.abc.KeysView</code></li>
<li><code>collections.abc.ItemsView</code></li>
<li><code>collections.abc.ValuesView</code></li>
<li><code>contextlib.AbstractContextManager</code></li>
<li><code>contextlib.AbstractAsyncContextManager</code></li>
<li>re.Pattern</li>
<li>re.Match</li>
</ul>
<h4 id="Special-Attributes-of-Generic-Alias"><a href="#Special-Attributes-of-Generic-Alias" class="headerlink" title="Special Attributes of Generic Alias"></a>Special Attributes of Generic Alias</h4><p>All parameterized generics implement special read-only attributes.</p>
<pre class="line-numbers language-python"><code class="language-python">genericalias<span class="token punctuation">.</span>__origin__<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>This attribute points at the non-parameterized generic class:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> list<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">.</span>__origin__
<span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token string">'list'</span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><code>genericalias.__args__</code></p>
<p>This attribute is a <code>tuple</code> (possibly of length 1) of generic types passed to the original <code>__class_getitem__()</code> of the generic container:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> dict<span class="token punctuation">[</span>str<span class="token punctuation">,</span> list<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">.</span>__args__
<span class="token punctuation">(</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token string">'str'</span><span class="token operator">></span><span class="token punctuation">,</span> list<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><code>genericalias.__parameters__</code></p>
<p>This attribute is a lazily computed tuple (possibly empty) of unique type variables found in <code>__args__</code>:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> typing <span class="token keyword">import</span> TypeVar
<span class="token operator">>></span><span class="token operator">></span> T <span class="token operator">=</span> TypeVar<span class="token punctuation">(</span><span class="token string">'T'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> list<span class="token punctuation">[</span>T<span class="token punctuation">]</span><span class="token punctuation">.</span>__parameters__
<span class="token punctuation">(</span><span class="token operator">~</span>T<span class="token punctuation">,</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>注解</p>
<p>A <code>GenericAlias</code> object with <code>typing.ParamSpec</code> parameters may not have correct <code>__parameters__</code> after substitution because <code>typing.ParamSpec</code> is intended primarily for static type checking.</p>
<p>参见</p>
<ul>
<li><a href="https://www.python.org/dev/peps/pep-0585" target="_blank" rel="noopener"><strong>PEP 585</strong></a> — “Type Hinting Generics In Standard Collections”</li>
<li><code>__class_getitem__()</code> — Used to implement parameterized generics.</li>
<li>泛型（Generic） — Generics in the <code>typing</code> module.</li>
</ul>
<p>3.9 新版功能.</p>
<h3 id="Union-Type"><a href="#Union-Type" class="headerlink" title="Union Type"></a>Union Type</h3><p>A union object holds the value of the <code>|</code> (bitwise or) operation on multiple type objects. These types are intended primarily for type annotations. The union type expression enables cleaner type hinting syntax compared to <code>typing.Union</code>.</p>
<pre><code>X | Y | ...</code></pre><p>Defines a union object which holds types <em>X</em>, <em>Y</em>, and so forth. <code>X | Y</code> means either X or Y. It is equivalent to <code>typing.Union[X, Y]</code>. For example, the following function expects an argument of type <code>int</code> or <code>float</code>:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">square</span><span class="token punctuation">(</span>number<span class="token punctuation">:</span> int <span class="token operator">|</span> float<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int <span class="token operator">|</span> float<span class="token punctuation">:</span>
    <span class="token keyword">return</span> number <span class="token operator">**</span> <span class="token number">2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><code>union_object == other</code></p>
<p>Union objects can be tested for equality with other union objects. Details:</p>
<ul>
<li><p>Unions of unions are flattened:</p>
<pre><code>(int | str) | float == int | str | float</code></pre></li>
<li><p>Redundant types are removed:</p>
<pre><code>int | str | int == int | str</code></pre></li>
<li><p>When comparing unions, the order is ignored:</p>
<pre><code>int | str == str | int</code></pre></li>
<li><p>It is compatible with <code>typing.Union</code>:</p>
<pre><code>int | str == typing.Union[int, str]</code></pre></li>
<li><p>Optional types can be spelled as a union with <code>None</code>:</p>
<pre><code>str | None == typing.Optional[str]</code></pre></li>
</ul>
<pre><code>isinstance(obj, union_object)
issubclass(obj, union_object)</code></pre><p>Calls to <code>isinstance()</code> and <code>issubclass()</code> are also supported with a union object:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> isinstance<span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">,</span> int <span class="token operator">|</span> str<span class="token punctuation">)</span>
<span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>However, union objects containing parameterized generics cannot be used:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> isinstance<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> int <span class="token operator">|</span> list<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span>
Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>
  File <span class="token string">"&lt;stdin>"</span><span class="token punctuation">,</span> line <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">></span>
TypeError<span class="token punctuation">:</span> isinstance<span class="token punctuation">(</span><span class="token punctuation">)</span> argument <span class="token number">2</span> cannot contain a parameterized generic<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>The user-exposed type for the union object can be accessed from <code>types.UnionType</code> and used for <code>isinstance()</code> checks. An object cannot be instantiated from the type:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> types
<span class="token operator">>></span><span class="token operator">></span> isinstance<span class="token punctuation">(</span>int <span class="token operator">|</span> str<span class="token punctuation">,</span> types<span class="token punctuation">.</span>UnionType<span class="token punctuation">)</span>
<span class="token boolean">True</span>
<span class="token operator">>></span><span class="token operator">></span> types<span class="token punctuation">.</span>UnionType<span class="token punctuation">(</span><span class="token punctuation">)</span>
Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>
  File <span class="token string">"&lt;stdin>"</span><span class="token punctuation">,</span> line <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">></span>
TypeError<span class="token punctuation">:</span> cannot create <span class="token string">'types.UnionType'</span> instances<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>注解</p>
<p>The <code>__or__()</code> method for type objects was added to support the syntax <code>X | Y</code>. If a metaclass implements <code>__or__()</code>, the Union may override it:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">class</span> <span class="token class-name">M</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">def</span> <span class="token function">__or__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> other<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         <span class="token keyword">return</span> <span class="token string">"Hello"</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">class</span> <span class="token class-name">C</span><span class="token punctuation">(</span>metaclass<span class="token operator">=</span>M<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">pass</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> C <span class="token operator">|</span> int
<span class="token string">'Hello'</span>
<span class="token operator">>></span><span class="token operator">></span> int <span class="token operator">|</span> C
int <span class="token operator">|</span> __main__<span class="token punctuation">.</span>C<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>参见</p>
<p><a href="https://www.python.org/dev/peps/pep-0604" target="_blank" rel="noopener"><strong>PEP 604</strong></a> — PEP proposing the <code>X | Y</code> syntax and the Union type.</p>
<p>3.10 新版功能.</p>
<h2 id="其他内置类型"><a href="#其他内置类型" class="headerlink" title="其他内置类型"></a>其他内置类型</h2><p>解释器支持一些其他种类的对象。 这些对象大都仅支持一两种操作。</p>
<h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><p>模块唯一的特殊操作是属性访问: <code>m.name</code>，这里 <em>m</em> 为一个模块而 <em>name</em> 访问定义在 <em>m</em> 的符号表中的一个名称。 模块属性可以被赋值。 （请注意 <code>import</code> 语句严格来说也是对模块对象的一种操作；<code>import foo</code> 不要求存在一个名为 <em>foo</em> 的模块对象，而是要求存在一个对于名为 <em>foo</em> 的模块的 (永久性) <em>定义</em>。）</p>
<p>每个模块都有一个特殊属性 <code>__dict__</code>。 这是包含模块的符号表的字典。 修改此字典将实际改变模块的符号表，但是无法直接对 <code>__dict__</code> 赋值 (你可以写 <code>m.__dict__['a'] = 1</code>，这会将 <code>m.a</code> 定义为 <code>1</code>，但是你不能写 <code>m.__dict__ = {}</code>)。 不建议直接修改 <code>__dict__</code>。</p>
<p>内置于解释器中的模块会写成这样: <code>&lt;module 'sys' (built-in)&gt;</code>。 如果是从一个文件加载，则会写成 <code>&lt;module 'os' from '/usr/local/lib/pythonX.Y/os.pyc'&gt;</code>。</p>
<h3 id="类与类实例"><a href="#类与类实例" class="headerlink" title="类与类实例"></a>类与类实例</h3><p>关于这些类型请参阅 对象、值与类型 和 类定义。</p>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>函数对象是通过函数定义创建的。 对函数对象的唯一操作是调用它: <code>func(argument-list)</code>。</p>
<p>实际上存在两种不同的函数对象：内置函数和用户自定义函数。 两者支持同样的操作（调用函数），但实现方式不同，因此对象类型也不同。</p>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>方法是使用属性表示法来调用的函数。 存在两种形式：内置方法（例如列表的 <code>append()</code> 方法）和类实例方法。 内置方法由支持它们的类型来描述。</p>
<p>如果你通过一个实例来访问方法（即定义在类命名空间内的函数），你会得到一个特殊对象: <em>绑定方法</em> (或称 <em>实例方法</em>) 对象。 当被调用时，它会将 <code>self</code> 参数添加到参数列表。 绑定方法具有两个特殊的只读属性: <code>m.__self__</code> 操作该方法的对象，而 <code>m.__func__</code> 是实现该方法的函数。 调用 <code>m(arg-1, arg-2, ..., arg-n)</code> 完全等价于调用 <code>m.__func__(m.__self__, arg-1, arg-2, ..., arg-n)</code>。</p>
<p>与函数对象类似，绑定方法对象也支持获取任意属性。 但是，由于方法属性实际上保存于下层的函数对象中 (<code>meth.__func__</code>)，因此不允许设置绑定方法的方法属性。 尝试设置方法的属性将会导致引发 <code>AttributeError</code>。 想要设置方法属性，你必须在下层的函数对象中显式地对其进行设置:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">class</span> <span class="token class-name">C</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">def</span> <span class="token function">method</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         <span class="token keyword">pass</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> c <span class="token operator">=</span> C<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> c<span class="token punctuation">.</span>method<span class="token punctuation">.</span>whoami <span class="token operator">=</span> <span class="token string">'my name is method'</span>  <span class="token comment" spellcheck="true"># can't set on the method</span>
Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>
  File <span class="token string">"&lt;stdin>"</span><span class="token punctuation">,</span> line <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">></span>
AttributeError<span class="token punctuation">:</span> <span class="token string">'method'</span> object has no attribute <span class="token string">'whoami'</span>
<span class="token operator">>></span><span class="token operator">></span> c<span class="token punctuation">.</span>method<span class="token punctuation">.</span>__func__<span class="token punctuation">.</span>whoami <span class="token operator">=</span> <span class="token string">'my name is method'</span>
<span class="token operator">>></span><span class="token operator">></span> c<span class="token punctuation">.</span>method<span class="token punctuation">.</span>whoami
<span class="token string">'my name is method'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="代码对象"><a href="#代码对象" class="headerlink" title="代码对象"></a>代码对象</h3><p>代码对象被具体实现用来表示“伪编译”的可执行 Python 代码，例如一个函数体。 它们不同于函数对象，因为它们不包含对其全局执行环境的引用。 代码对象由内置的 <code>compile()</code> 函数返回，并可通过从函数对象的 <code>__code__</code> 属性从中提取。 </p>
<p>Accessing <code>__code__</code> raises an auditing event <code>object.__getattr__</code> with arguments <code>obj</code> and <code>"__code__"</code>.</p>
<p>可以通过将代码对象（而非源码字符串）传给 <code>exec()</code> 或 <code>eval()</code> 内置函数来执行或求值。</p>
<h3 id="类型对象"><a href="#类型对象" class="headerlink" title="类型对象"></a>类型对象</h3><p>类型对象表示各种对象类型。 对象的类型可通过内置函数 <code>type()</code> 来获取。 类型没有特殊的操作。 标准库模块 <code>types</code> 定义了所有标准内置类型的名称。</p>
<p>类型以这样的写法来表示: <code>&lt;class 'int'&gt;</code>。</p>
<h3 id="空对象"><a href="#空对象" class="headerlink" title="空对象"></a>空对象</h3><p>此对象会由不显式地返回值的函数所返回。 它不支持任何特殊的操作。 空对象只有一种值 <code>None</code> (这是个内置名称)。 <code>type(None)()</code> 会生成同一个单例。</p>
<p>该对象的写法为 <code>None</code>。</p>
<h3 id="省略符对象"><a href="#省略符对象" class="headerlink" title="省略符对象"></a>省略符对象</h3><p>此对象常被用于切片。 它不支持任何特殊的操作。 省略符对象只有一种值 <code>Ellipsis</code> (这是个内置名称)。 <code>type(Ellipsis)()</code> 会生成 <code>Ellipsis</code> 单例。</p>
<p>该对象的写法为 <code>Ellipsis</code> 或 <code>...</code>。</p>
<h3 id="未实现对象"><a href="#未实现对象" class="headerlink" title="未实现对象"></a>未实现对象</h3><p>此对象会被作为比较和二元运算被应用于它们所不支持的类型时的返回值。未实现对象只有一种值 <code>NotImplemented</code>。 <code>type(NotImplemented)()</code> 会生成这个单例。</p>
<p>该对象的写法为 <code>NotImplemented</code>。</p>
<h3 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h3><p>布尔值是两个常量对象 <code>False</code> 和 <code>True</code>。 它们被用来表示逻辑上的真假（不过其他值也可被当作真值或假值）。 在数字类的上下文中（例如被用作算术运算符的参数时），它们的行为分别类似于整数 0 和 1。 内置函数 <code>bool()</code> 可被用来将任意值转换为布尔值，只要该值可被解析为一个逻辑值。</p>
<p>该对象的写法分别为 <code>False</code> 和 <code>True</code>。</p>
<h3 id="内部对象"><a href="#内部对象" class="headerlink" title="内部对象"></a>内部对象</h3><p>有关此对象的信息请参阅 标准类型层级结构。 其中描述了栈帧对象、回溯对象以及切片对象等等。</p>
<h2 id="特殊属性"><a href="#特殊属性" class="headerlink" title="特殊属性"></a>特殊属性</h2><p>语言实现为部分对象类型添加了一些特殊的只读属性，它们具有各自的作用。 其中一些并不会被 <code>dir()</code> 内置函数所列出。</p>
<pre><code>object.__dict__</code></pre><p>一个字典或其他类型的映射对象，用于存储对象的（可写）属性。</p>
<pre><code>instance.__class__</code></pre><p>类实例所属的类。</p>
<pre><code>class.__bases__</code></pre><p>由类对象的基类所组成的元组。</p>
<pre><code>definition.__name__</code></pre><p>类、函数、方法、描述器或生成器实例的名称。</p>
<pre><code>definition.__qualname__</code></pre><p>类、函数、方法、描述器或生成器实例的 qualified name。</p>
<p>3.3 新版功能.</p>
<pre><code>class.__mro__</code></pre><p>此属性是由类组成的元组，在方法解析期间会基于它来查找基类。</p>
<p><code>class.mro</code>()</p>
<p>此方法可被一个元类来重载，以为其实例定制方法解析顺序。 它会在类实例化时被调用，其结果存储于 <code>__mro__</code> 之中。</p>
<p><code>class.__subclasses__</code>()</p>
<p>Each class keeps a list of weak references to its immediate subclasses. This method returns a list of all those references still alive. The list is in definition order. Example:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> int<span class="token punctuation">.</span>__subclasses__<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token string">'bool'</span><span class="token operator">></span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h1 id="内置异常"><a href="#内置异常" class="headerlink" title="内置异常"></a>内置异常</h1><p>在 Python 中，所有异常必须为一个派生自 <code>BaseException</code> 的类的实例。 在带有提及一个特定类的 <code>except</code> 子句的 <code>try</code> 语句中，该子句也会处理任何派生自该类的异常类（但不处理 <em>它</em> 所派生出的异常类）。 通过子类化创建的两个不相关异常类永远是不等效的，既使它们具有相同的名称。</p>
<p>下面列出的内置异常可通过解释器或内置函数来生成。除非另有说明，它们都会具有一个提示导致错误详细原因的“关联值”。 这可以是一个字符串或由多个信息项（例如一个错误码和一个解释错误的字符串）组成的元组。 关联值通常会作为参数被传递给异常类的构造器。</p>
<p>用户代码可以引发内置异常。 这可被用于测试异常处理程序或报告错误条件，“就像” 在解释器引发了相同异常的情况时一样；但是请注意，没有任何机制能防止用户代码引发不适当的错误。</p>
<p>内置异常类可以被子类化以定义新的异常；鼓励程序员从 <code>Exception</code> 类或它的某个子类而不是从 <code>BaseException</code> 来派生新的异常。 </p>
<p>当在 <code>except</code> 或 <code>finally</code> 子句中引发（或重新引发）异常时，<code>__context__</code> 会被自动设为所捕获的最后一个异常；如果新的异常未被处理，则最终显示的回溯信息将包括原始的异常和最后的异常。</p>
<p>当引发一个新的异常（而不是简单地使用 <code>raise</code> 来重新引发 当前在处理的异常）时，隐式的异常上下文可以通过使用带有 <code>raise</code> 的 <code>from</code> 子句来补充一个显式的原因:</p>
<pre><code>raise new_exc from original_exc</code></pre><p>跟在 <code>from</code> 之后一表达式必须为一个异常或 <code>None</code>。 它将在所引发的异常上被设置为 <code>__cause__</code>。 设置 <code>__cause__</code> 还会隐式地将 <code>__suppress_context__</code> 属性设为 <code>True</code>，这样使用 <code>raise new_exc from None</code> 可以有效地将旧异常替换为新异常来显示其目的 (例如将 <code>KeyError</code> 转换为 <code>AttributeError</code>)，同时让旧异常在 <code>__context__</code> 中保持可用状态以便在调试时进行内省。</p>
<p>除了异常本身的回溯以外，默认的回溯还会显示这些串连的异常。 <code>__cause__</code> 中的显式串连异常如果存在将总是显示。 <code>__context__</code> 中的隐式串连异常仅在 <code>__cause__</code> 为 <code>None</code> 并且 <code>__suppress_context__</code> 为假值时显示。</p>
<p>不论在哪种情况下，异常本身总会在任何串连异常之后显示，以便回溯的最后一行总是显示所引发的最后一个异常。</p>
<h2 id="基类"><a href="#基类" class="headerlink" title="基类"></a>基类</h2><p>下列异常主要被用作其他异常的基类。</p>
<ul>
<li><em>exception</em> <code>BaseException</code></li>
</ul>
<p>所有内置异常的基类。 它不应该被用户自定义类直接继承 (这种情况请使用 <code>Exception</code>)。 如果在此类的实例上调用 <code>str()</code>，则会返回实例的参数表示，或者当没有参数时返回空字符串。</p>
<p>​    <code>args</code></p>
<p>传给异常构造器的参数元组。 某些内置异常 (例如 <code>OSError</code>) 接受特定数量的参数并赋予此元组中的元素特殊的含义，而其他异常通常只接受一个给出错误信息的单独字符串。</p>
<p>​    <code>with_traceback</code>(<em>tb</em>)</p>
<p>此方法会将 <em>tb</em> 设为新的异常回溯信息并返回异常对象。 它在 <a href="https://www.python.org/dev/peps/pep-3134" target="_blank" rel="noopener"><strong>PEP 3134</strong></a> 的异常链特性可用之前更为常用。 下面的例子演示了我们如何将一个 <code>SomeException</code> 实例转换为 <code>OtherException</code> 实例而保留回溯信息。 异常一旦被引发，当前帧会被推至 <code>OtherException</code> 的回溯栈顶端，就像当我们允许原始 <code>SomeException</code> 被传播给调用方时它的回溯栈将会发生的情形一样。:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">try</span><span class="token punctuation">:</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token keyword">except</span> SomeException<span class="token punctuation">:</span>
    tb <span class="token operator">=</span> sys<span class="token punctuation">.</span>exc_info<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span>
    <span class="token keyword">raise</span> OtherException<span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">.</span>with_traceback<span class="token punctuation">(</span>tb<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li><em>exception</em> <code>Exception</code></li>
</ul>
<p>所有内置的非系统退出类异常都派生自此类。 所有用户自定义异常也应当派生自此类。</p>
<ul>
<li><em>exception</em> <code>ArithmeticError</code></li>
</ul>
<p>此基类用于派生针对各种算术类错误而引发的内置异常: <code>OverflowError</code>, <code>ZeroDivisionError</code>, <code>FloatingPointError</code>。</p>
<ul>
<li><em>exception</em> <code>BufferError</code></li>
</ul>
<p>当与 缓冲区 相关的操作无法执行时将被引发。</p>
<ul>
<li><em>exception</em> <code>LookupError</code></li>
</ul>
<p>此基类用于派生当映射或序列所使用的键或索引无效时引发的异常: <code>IndexError</code>, <code>KeyError</code>。 这可以通过 <code>codecs.lookup()</code> 来直接引发。</p>
<h2 id="具体异常"><a href="#具体异常" class="headerlink" title="具体异常"></a>具体异常</h2><p>以下异常属于经常被引发的异常。</p>
<ul>
<li><em>exception</em> <code>AssertionError</code></li>
</ul>
<p>当 <code>assert</code> 语句失败时将被引发。</p>
<ul>
<li><em>exception</em> <code>AttributeError</code></li>
</ul>
<p>当属性引用 或赋值失败时将被引发。 （当一个对象根本不支持属性引用或属性赋值时则将引发 <code>TypeError</code>。）</p>
<p><code>name</code> 和 <code>obj</code> 属性可以使用构造器的仅限关键字参数来设置。 它们如果被设置则分别代表要尝试访问的属性名称以及所访问的该属性的对象。</p>
<p>在 3.10 版更改: 增加了 <code>name</code> 和 <code>obj</code> 属性。</p>
<ul>
<li><em>exception</em> <code>EOFError</code></li>
</ul>
<p>当 <code>input()</code> 函数未读取任何数据即达到文件结束条件 (EOF) 时将被引发。 （另外，<code>io.IOBase.read()</code> 和 <code>io.IOBase.readline()</code> 方法在遇到 EOF 则将返回一个空字符串。）</p>
<ul>
<li><em>exception</em> <code>FloatingPointError</code></li>
</ul>
<p>目前未被使用。</p>
<ul>
<li><em>exception</em> <code>GeneratorExit</code></li>
</ul>
<p>当一个 generator 或 coroutine 被关闭时将被引发；见 <code>generator.close()</code> 和 <code>coroutine.close()</code>。 它直接继承自 <code>BaseException</code> 而不是 <code>Exception</code>，因为从技术上来说它并不是一个错误。</p>
<ul>
<li><em>exception</em> <code>ImportError</code></li>
</ul>
<p>当 <code>import</code> 语句尝试加载模块遇到麻烦时将被引发。 并且当 <code>from ... import</code> 中的 “from list” 存在无法找到的名称时也会被引发。</p>
<p><code>name</code> 与 <code>path</code> 属性可通过对构造器使用仅关键字参数来设定。 设定后它们将分别表示被尝试导入的模块名称与触发异常的任意文件所在路径。</p>
<p>在 3.3 版更改: 添加了 <code>name</code> 与 <code>path</code> 属性。</p>
<ul>
<li><em>exception</em> <code>ModuleNotFoundError</code></li>
</ul>
<p><code>ImportError</code> 的子类，当一个模块无法被定位时将由 <code>import</code> 引发。 当在 <code>sys.modules</code> 中找到 <code>None</code> 时也会被引发。</p>
<p>3.6 新版功能.</p>
<ul>
<li><em>exception</em> <code>IndexError</code></li>
</ul>
<p>当序列抽取超出范围时将被引发。 （切片索引会被静默截短到允许的范围；如果指定索引不是整数则 <code>TypeError</code> 会被引发。）</p>
<ul>
<li><em>exception</em> <code>KeyError</code></li>
</ul>
<p>当在现有键集合中找不到指定的映射（字典）键时将被引发。</p>
<ul>
<li><em>exception</em> <code>KeyboardInterrupt</code></li>
</ul>
<p>当用户按下中断键 (通常为 Control-C 或 Delete) 时将被引发。 在执行期间，会定期检测中断信号。 该异常继承自 <code>BaseException</code> 以确保不会被处理 <code>Exception</code> 的代码意外捕获，这样可以避免退出解释器。</p>
<ul>
<li><em>exception</em> <code>MemoryError</code></li>
</ul>
<p>当一个操作耗尽内存但情况仍可（通过删除一些对象）进行挽救时将被引发。 关联的值是一个字符串，指明是哪种（内部）操作耗尽了内存。 请注意由于底层的内存管理架构（C 的 <code>malloc()</code> 函数），解释器也许并不总是能够从这种情况下完全恢复；但它毕竟可以引发一个异常，这样就能打印出栈回溯信息，以便找出导致问题的失控程序。</p>
<ul>
<li><em>exception</em> <code>NameError</code></li>
</ul>
<p>当某个局部或全局名称未找到时将被引发。 此异常仅用于非限定名称。 关联的值是一条错误信息，其中包含未找到的名称。</p>
<p><code>name</code> 属性可以使用构造器的仅限关键字参数来设置。 它如果被设置则代表要尝试访问的变量名称。</p>
<p>在 3.10 版更改: 增加了 <code>name</code> 属性。</p>
<ul>
<li><em>exception</em> <code>NotImplementedError</code></li>
</ul>
<p>此异常派生自 <code>RuntimeError</code>。 在用户自定义的基类中，抽象方法应当在其要求所派生类重载该方法，或是在其要求所开发的类提示具体实现尚待添加时引发此异常。</p>
<p>注解</p>
<p>它不应当用来表示一个运算符或方法根本不能被支持 — 在此情况下应当让特定运算符 / 方法保持未定义，或者在子类中将其设为 <code>None</code>。</p>
<p>注解</p>
<p><code>NotImplementedError</code> 和 <code>NotImplemented</code> 不可互换，即使它们有相似的名称和用途。 </p>
<ul>
<li><p><em>exception</em> <code>OSError</code>([<em>arg</em>])</p>
</li>
<li><p><em>exception</em> <code>OSError</code>(<em>errno</em>, <em>strerror</em>[, <em>filename</em>[, <em>winerror</em>[, <em>filename2</em>]]])</p>
<p>此异常在一个系统函数返回系统相关的错误时将被引发，此类错误包括 I/O 操作失败例如 “文件未找到” 或 “磁盘已满” 等（不包括非法参数类型或其他偶然性错误）。</p>
<p>构造器的第二种形式可设置如下所述的相应属性。 如果未指定这些属性则默认为 <code>None</code>。 为了能向下兼容，如果传入了三个参数，则 <code>args</code> 属性将仅包含由前两个构造器参数组成的 2 元组。</p>
<p>构造器实际返回的往往是 <code>OSError</code> 的某个子类，如下文 OS exceptions 中所描述的。 具体的子类取决于最终的 <code>errno</code> 值。 此行为仅在直接或通过别名来构造 <code>OSError</code> 时发生，并且在子类化时不会被继承。</p>
<ul>
<li><p><code>errno</code></p>
<p>来自于 C 变量 <code>errno</code> 的数字错误码。</p>
</li>
<li><p><code>winerror</code></p>
<p>在 Windows 下，此参数将给出原生的 Windows 错误码。 而 <code>errno</code> 属性将是该原生错误码在 POSIX 平台下的近似转换形式。</p>
<p>在 Windows 下，如果 <em>winerror</em> 构造器参数是一个整数，则 <code>errno</code> 属性会根据 Windows 错误码来确定，而 <em>errno</em> 参数会被忽略。 在其他平台上，<em>winerror</em> 参数会被忽略，并且 <code>winerror</code> 属性将不存在。</p>
</li>
<li><p><code>strerror</code></p>
<p>操作系统所提供的相应错误信息。 它在 POSIX 平台中由 C 函数 <code>perror()</code> 来格式化，在 Windows 中则是由 <code>FormatMessage()</code>。</p>
</li>
<li><p><code>filename</code></p>
<p><code>filename2</code></p>
<p>对于与文件系统路径有关 (例如 <code>open()</code> 或 <code>os.unlink()</code>) 的异常，<code>filename</code> 是传给函数的文件名。 对于涉及两个文件系统路径的函数 (例如 <code>os.rename()</code>)，<code>filename2</code> 将是传给函数的第二个文件名。</p>
</li>
</ul>
</li>
</ul>
<p>在 3.3 版更改: <code>EnvironmentError</code>, <code>IOError</code>, <code>WindowsError</code>, <code>socket.error</code>, <code>select.error</code> 与 <code>mmap.error</code> 已被合并到 <code>OSError</code>，构造器可能返回其中一个子类。</p>
<p>在 3.4 版更改: <code>filename</code> 属性现在是传给函数的原始文件名，而不是基于 filesystem encoding and error handler 进行编码或解码之后的名称。 此外，还添加了 <em>filename2</em> 构造器参数和属性。</p>
<ul>
<li><em>exception</em> <code>OverflowError</code></li>
</ul>
<p>当算术运算的结果大到无法表示时将被引发。 这对整数来说不可能发生（宁可引发 <code>MemoryError</code> 也不会放弃尝试）。 但是出于历史原因，有时也会在整数超出要求范围的情况下引发 OverflowError。 因为在 C 中缺少对浮点异常处理的标准化，大多数浮点运算都不会做检查。</p>
<ul>
<li><em>exception</em> <code>RecursionError</code></li>
</ul>
<p>此异常派生自 <code>RuntimeError</code>。 它会在解释器检测发现超过最大递归深度 时被引发。</p>
<p>3.5 新版功能: 在此之前将只引发 <code>RuntimeError</code>。</p>
<ul>
<li><em>exception</em> <code>ReferenceError</code></li>
</ul>
<p>此异常将在使用 <code>weakref.proxy()</code> 函数所创建的弱引用来访问该引用的某个已被作为垃圾回收的属性时被引发。 </p>
<ul>
<li><em>exception</em> <code>RuntimeError</code></li>
</ul>
<p>当检测到一个不归属于任何其他类别的错误时将被引发。 关联的值是一个指明究竟发生了什么问题的字符串。</p>
<ul>
<li><em>exception</em> <code>StopIteration</code></li>
</ul>
<p>由内置函数 <code>next()</code> 和 iterator 的 <code>__next__()</code> 方法所引发，用来表示该迭代器不能产生下一项。</p>
<p>该异常对象只有一个属性 <code>value</code>，它在构造该异常时作为参数给出，默认值为 <code>None</code>。</p>
<p>当一个 generator 或 coroutine 函数返回时，将引发一个新的 <code>StopIteration</code> 实例，函数返回的值将被用作异常构造器的 <code>value</code> 形参。</p>
<p>如果某个生成器代码直接或间接地引发了 <code>StopIteration</code>，它会被转换为 <code>RuntimeError</code> (并将 <code>StopIteration</code> 保留为导致新异常的原因)。</p>
<p>在 3.3 版更改: 添加了 <code>value</code> 属性及其被生成器函数用作返回值的功能。</p>
<p>在 3.5 版更改: 引入了通过 <code>from __future__ import generator_stop</code> 来实现 RuntimeError 转换，参见 <a href="https://www.python.org/dev/peps/pep-0479" target="_blank" rel="noopener"><strong>PEP 479</strong></a>。</p>
<p>在 3.7 版更改: 默认对所有代码启用 <a href="https://www.python.org/dev/peps/pep-0479" target="_blank" rel="noopener"><strong>PEP 479</strong></a>: 在生成器中引发的 <code>StopIteration</code> 错误将被转换为 <code>RuntimeError</code>。</p>
<ul>
<li><em>exception</em> <code>StopAsyncIteration</code></li>
</ul>
<p>必须由一个 asynchronous iterator 对象的 <code>__anext__()</code> 方法来引发以停止迭代操作。</p>
<p>3.5 新版功能.</p>
<ul>
<li><p><em>exception</em> <code>SyntaxError</code>(<em>message</em>, <em>details</em>)</p>
<p>当解析器遇到语法错误时引发。 这可以发生在 <code>import</code> 语句，对内置函数 <code>compile()</code>, <code>exec()</code> 或 <code>eval()</code> 的调用，或是读取原始脚本或标准输入（也包括交互模式）的时候。</p>
<p>异常实例的 <code>str()</code> 只返回错误消息。 错误详情为一个元组，其成员也可在单独的属性中分别获取。</p>
<ul>
<li><p><code>filename</code></p>
<p>发生语法错误所在文件的名称。</p>
</li>
<li><p><code>lineno</code></p>
<p>发生错误所在文件中的行号。 行号索引从 1 开始：文件中首行的 <code>lineno</code> 为 1。</p>
</li>
<li><p><code>offset</code></p>
<p>发生错误所在文件中的列号。 列号索引从 1 开始：行中首个字符的 <code>offset</code> 为 1。</p>
</li>
<li><p><code>text</code></p>
<p>错误所涉及的源代码文本。</p>
</li>
<li><p><code>end_lineno</code></p>
<p>发生的错误在文件中的末尾行号。 这个索引是从 1 开始的：文件中首行的 <code>lineno</code> 为 1。</p>
</li>
<li><p><code>end_offset</code></p>
<p>发生的错误在文件中的末尾列号。 这个索引是从 1 开始：行中首个字符的 <code>offset</code> 为 1。</p>
</li>
</ul>
</li>
</ul>
<p>对于 f-字符串字段中的错误，消息会带有 “f-string: “ 前缀并且其位置是基于替换表达式构建的文本中的位置。 例如，编译 f’Bad {a b} field’ 将产生这样的 args 属性: (‘f-string: …’, (‘’, 1, 2, ‘(a b)n’, 1, 5))。</p>
<p>在 3.10 版更改: 增加了 <code>end_lineno</code> 和 <code>end_offset</code> 属性。</p>
<ul>
<li><em>exception</em> <code>IndentationError</code></li>
</ul>
<p>与不正确的缩进相关的语法错误的基类。 这是 <code>SyntaxError</code> 的一个子类。</p>
<ul>
<li><em>exception</em> <code>TabError</code></li>
</ul>
<p>当缩进包含对制表符和空格符不一致的使用时将被引发。 这是 <code>IndentationError</code> 的一个子类。</p>
<ul>
<li><em>exception</em> <code>SystemError</code></li>
</ul>
<p>当解释器发现内部错误，但情况看起来尚未严重到要放弃所有希望时将被引发。 关联的值是一个指明发生了什么问题的字符串（表示为低层级的符号）。</p>
<p>你应当将此问题报告给你所用 Python 解释器的作者或维护人员。 请确认报告 Python 解释器的版本号 (<code>sys.version</code>; 它也会在交互式 Python 会话开始时被打印出来)，具体的错误消息（异常所关联的值）以及可能触发该错误的程序源码。</p>
<ul>
<li><em>exception</em> <code>SystemExit</code></li>
</ul>
<p>此异常由 <code>sys.exit()</code> 函数引发。 它继承自 <code>BaseException</code> 而不是 <code>Exception</code> 以确保不会被处理 <code>Exception</code> 的代码意外捕获。 这允许此异常正确地向上传播并导致解释器退出。 如果它未被处理，则 Python 解释器就将退出；不会打印任何栈回溯信息。 构造器接受的可选参数与传递给 <code>sys.exit()</code> 的相同。 如果该值为一个整数，则它指明系统退出状态码（会传递给 C 的 <code>exit()</code> 函数）；如果该值为 <code>None</code>，则退出状态码为零；如果该值为其他类型（例如字符串），则会打印对象的值并将退出状态码设为一。</p>
<p>对 <code>sys.exit()</code> 的调用会被转换为一个异常以便能执行清理处理程序 (<code>try</code> 语句的 <code>finally</code> 子句)，并且使得调试器可以执行一段脚本而不必冒失去控制的风险。 如果绝对确实地需要立即退出（例如在调用 <code>os.fork()</code> 之后的子进程中）则可使用 <code>os._exit()</code>.</p>
<p>​    <code>code</code></p>
<p>​    传给构造器的退出状态码或错误信息（默认为 <code>None</code>。）</p>
<ul>
<li><em>exception</em> <code>TypeError</code></li>
</ul>
<p>当一个操作或函数被应用于类型不适当的对象时将被引发。 关联的值是一个字符串，给出有关类型不匹配的详情。</p>
<p>此异常可以由用户代码引发，以表明尝试对某个对象进行的操作不受支持也不应当受支持。 如果某个对象应当支持给定的操作但尚未提供相应的实现，所要引发的适当异常应为 <code>NotImplementedError</code>。</p>
<p>传入参数的类型错误 (例如在要求 <code>int</code> 时却传入了 <code>list</code>) 应当导致 <code>TypeError</code>，但传入参数的值错误 (例如传入要求范围之外的数值) 则应当导致 <code>ValueError</code>。</p>
<ul>
<li><em>exception</em> <code>UnboundLocalError</code></li>
</ul>
<p>当在函数或方法中对某个局部变量进行引用，但该变量并未绑定任何值时将被引发。 此异常是 <code>NameError</code> 的一个子类。</p>
<ul>
<li><p><em>exception</em> <code>UnicodeError</code></p>
<p>当发生与 Unicode 相关的编码或解码错误时将被引发。 此异常是 <code>ValueError</code> 的一个子类。</p>
<p><code>UnicodeError</code> 具有一些描述编码或解码错误的属性。 例如 <code>err.object[err.start:err.end]</code> 会给出导致编解码器失败的特定无效输入。</p>
<ul>
<li><p><code>encoding</code></p>
<p>引发错误的编码名称。</p>
</li>
<li><p><code>reason</code></p>
<p>描述特定编解码器错误的字符串。</p>
</li>
<li><p><code>object</code></p>
<p>编解码器试图要编码或解码的对象。</p>
</li>
<li><p><code>start</code></p>
<p><code>object</code> 中无效数据的开始位置索引。</p>
</li>
<li><p><code>end</code></p>
<p><code>object</code> 中无效数据的末尾位置索引（不含）。</p>
</li>
</ul>
</li>
<li><p><em>exception</em> <code>UnicodeEncodeError</code></p>
</li>
</ul>
<p>当在编码过程中发生与 Unicode 相关的错误时将被引发。 此异常是 <code>UnicodeError</code> 的一个子类。</p>
<ul>
<li><em>exception</em> <code>UnicodeDecodeError</code></li>
</ul>
<p>当在解码过程中发生与 Unicode 相关的错误时将被引发。 此异常是 <code>UnicodeError</code> 的一个子类。</p>
<ul>
<li><em>exception</em> <code>UnicodeTranslateError</code></li>
</ul>
<p>在转写过程中发生与 Unicode 相关的错误时将被引发。 此异常是 <code>UnicodeError</code> 的一个子类。</p>
<ul>
<li><em>exception</em> <code>ValueError</code></li>
</ul>
<p>当操作或函数接收到具有正确类型但值不适合的参数，并且情况不能用更精确的异常例如 <code>IndexError</code> 来描述时将被引发。</p>
<ul>
<li><em>exception</em> <code>ZeroDivisionError</code></li>
</ul>
<p>当除法或取余运算的第二个参数为零时将被引发。 关联的值是一个字符串，指明操作数和运算的类型。</p>
<p>下列异常被保留以与之前的版本相兼容；从 Python 3.3 开始，它们都是 <code>OSError</code> 的别名。</p>
<ul>
<li><p><em>exception</em> <code>EnvironmentError</code></p>
</li>
<li><p><em>exception</em> <code>IOError</code></p>
</li>
<li><p><em>exception</em> <code>WindowsError</code></p>
</li>
</ul>
<p>限在 Windows 中可用。</p>
<h3 id="OS-异常"><a href="#OS-异常" class="headerlink" title="OS 异常"></a>OS 异常</h3><p>下列异常均为 <code>OSError</code> 的子类，它们将根据系统错误代码被引发。</p>
<ul>
<li><em>exception</em> <code>BlockingIOError</code></li>
</ul>
<p>当一个操作会被某个设置为非阻塞操作的对象（例如套接字）所阻塞时将被引发。 对应于 <code>errno</code> <code>EAGAIN</code>, <code>EALREADY</code>, <code>EWOULDBLOCK</code> 和 <code>EINPROGRESS</code>。</p>
<p>除了 <code>OSError</code> 已有的属性，<code>BlockingIOError</code> 还有一个额外属性：</p>
<ul>
<li><p><code>characters_written</code></p>
<p>一个整数，表示在被阻塞前已写入到流的字符数。 当使用来自 <code>io</code> 模块的带缓冲 I/O 类时此属性可用。</p>
</li>
<li><p><em>exception</em> <code>ChildProcessError</code></p>
</li>
</ul>
<p>当一个子进程上的操作失败时将被引发。 对应于 <code>errno</code> <code>ECHILD</code>。</p>
<ul>
<li><em>exception</em> <code>ConnectionError</code></li>
</ul>
<p>与连接相关问题的基类。</p>
<p>其子类有 <code>BrokenPipeError</code>, <code>ConnectionAbortedError</code>, <code>ConnectionRefusedError</code> 和 <code>ConnectionResetError</code>。</p>
<ul>
<li><em>exception</em> <code>BrokenPipeError</code></li>
</ul>
<p><code>ConnectionError</code> 的子类，当试图写入另一端已被关闭的管道，或是试图写入已关闭写入的套接字时将被引发。 对应于 <code>errno</code> <code>EPIPE</code> 和 <code>ESHUTDOWN</code>。</p>
<ul>
<li><em>exception</em> <code>ConnectionAbortedError</code></li>
</ul>
<p><code>ConnectionError</code> 的子类，当连接尝试被对端中止时将被引发。 对应于 <code>errno</code> <code>ECONNABORTED</code>。</p>
<ul>
<li><em>exception</em> <code>ConnectionRefusedError</code></li>
</ul>
<p><code>ConnectionError</code> 的子类，当连接尝试被对端拒绝时将被引发。 对应于 <code>errno</code> <code>ECONNREFUSED</code>。</p>
<ul>
<li><em>exception</em> <code>ConnectionResetError</code></li>
</ul>
<p><code>ConnectionError</code> 的子类，当连接被对端重置时将被引发。 对应于 <code>errno</code> <code>ECONNRESET</code>。</p>
<ul>
<li><em>exception</em> <code>FileExistsError</code></li>
</ul>
<p>当试图创建一个已存在的文件或目录时将被引发。 对应于 <code>errno</code> <code>EEXIST</code>。</p>
<ul>
<li><em>exception</em> <code>FileNotFoundError</code></li>
</ul>
<p>当所请求的文件或目录不存在时将被引发。 对应于 <code>errno</code> <code>ENOENT</code>。</p>
<ul>
<li><em>exception</em> <code>InterruptedError</code></li>
</ul>
<p>当系统调用被输入信号中断时将被引发。 对应于 <code>errno</code> <code>EINTR</code>。</p>
<p>在 3.5 版更改: 当系统调用被某个信号中断时，Python 现在会重试系统调用，除非该信号的处理程序引发了其它异常 (原理参见 <a href="https://www.python.org/dev/peps/pep-0475" target="_blank" rel="noopener"><strong>PEP 475</strong></a>) 而不是引发 <code>InterruptedError</code>。</p>
<ul>
<li><em>exception</em> <code>IsADirectoryError</code></li>
</ul>
<p>当请求对一个目录执行文件操作 (例如 <code>os.remove()</code>) 将被引发。 对应于 <code>errno</code> <code>EISDIR</code>。</p>
<ul>
<li><em>exception</em> <code>NotADirectoryError</code></li>
</ul>
<p>当在非目录上请求目录操作 (例如 <code>os.listdir()</code>) 时被引发。 在大多数 POSIX 平台上，它还可能在某个操作尝试以目录方式打开或遍历非目录时被引发。 对应于 <code>errno</code> <code>ENOTDIR</code>。</p>
<ul>
<li><em>exception</em> <code>PermissionError</code></li>
</ul>
<p>当在没有足够操作权限的情况下试图执行某个操作时将被引发 —— 例如缺少文件系统权限。 对应于 <code>errno</code> <code>EACCES</code> 和 <code>EPERM</code>。</p>
<ul>
<li><em>exception</em> <code>ProcessLookupError</code></li>
</ul>
<p>当给定的进程不存在时将被引发。 对应于 <code>errno</code> <code>ESRCH</code>。</p>
<ul>
<li><em>exception</em> <code>TimeoutError</code></li>
</ul>
<p>当一个系统函数发生系统级超时的情况下将被引发。 对应于 <code>errno</code> <code>ETIMEDOUT</code>。</p>
<p>3.3 新版功能: 添加了以上所有 <code>OSError</code> 的子类。</p>
<p>参见</p>
<p><a href="https://www.python.org/dev/peps/pep-3151" target="_blank" rel="noopener"><strong>PEP 3151</strong></a> - 重写 OS 和 IO 异常的层次结构</p>
<h2 id="警告"><a href="#警告" class="headerlink" title="警告"></a>警告</h2><p>下列异常被用作警告类别</p>
<ul>
<li><em>exception</em> <code>Warning</code></li>
</ul>
<p>警告类别的基类。</p>
<ul>
<li><em>exception</em> <code>UserWarning</code></li>
</ul>
<p>用户代码所产生警告的基类。</p>
<ul>
<li><em>exception</em> <code>DeprecationWarning</code></li>
</ul>
<p>如果所发出的警告是针对其他 Python 开发者的，则以此作为与已弃用特性相关警告的基类。</p>
<p>会被默认警告过滤器忽略，在 <code>__main__</code> 模块中的情况除外 (<a href="https://www.python.org/dev/peps/pep-0565" target="_blank" rel="noopener"><strong>PEP 565</strong></a>)。 启用 Python 开发模式 时会显示此警告。</p>
<p>The deprecation policy is described in <a href="https://www.python.org/dev/peps/pep-0387" target="_blank" rel="noopener"><strong>PEP 387</strong></a>.</p>
<ul>
<li><em>exception</em> <code>PendingDeprecationWarning</code></li>
</ul>
<p>对于已过时并预计在未来弃用，但目前尚未弃用的特性相关警告的基类。</p>
<p>这个类很少被使用，因为针对未来可能的弃用发出警告的做法并不常见，而针对当前已有的弃用则推荐使用 <code>DeprecationWarning</code>。</p>
<p>会被默认警告过滤器忽略。 启用 Python 开发模式 时会显示此警告。</p>
<p>The deprecation policy is described in <a href="https://www.python.org/dev/peps/pep-0387" target="_blank" rel="noopener"><strong>PEP 387</strong></a>.</p>
<ul>
<li><em>exception</em> <code>SyntaxWarning</code></li>
</ul>
<p>与模糊的语法相关的警告的基类。</p>
<ul>
<li><em>exception</em> <code>RuntimeWarning</code></li>
</ul>
<p>与模糊的运行时行为相关的警告的基类。</p>
<ul>
<li><em>exception</em> <code>FutureWarning</code></li>
</ul>
<p>如果所发出的警告是针对以 Python 所编写应用的最终用户的，则以此作为与已弃用特性相关警告的基类。</p>
<ul>
<li><em>exception</em> <code>ImportWarning</code></li>
</ul>
<p>与在模块导入中可能的错误相关的警告的基类。</p>
<p>会被默认警告过滤器忽略。 启用 Python 开发模式 时会显示此警告。</p>
<ul>
<li><em>exception</em> <code>UnicodeWarning</code></li>
</ul>
<p>与 Unicode 相关的警告的基类。</p>
<ul>
<li><em>exception</em> <code>EncodingWarning</code></li>
</ul>
<p>与编码格式相关的警告的基类。</p>
<p>3.10 新版功能.</p>
<ul>
<li><em>exception</em> <code>BytesWarning</code></li>
</ul>
<p>与 <code>bytes</code> 和 <code>bytearray</code> 相关的警告的基类。</p>
<ul>
<li><em>exception</em> <code>ResourceWarning</code></li>
</ul>
<p>资源使用相关警告的基类。</p>
<p>会被默认警告过滤器忽略。 启用 Python 开发模式 时会显示此警告。</p>
<p>3.2 新版功能.</p>
<h2 id="异常层次结构"><a href="#异常层次结构" class="headerlink" title="异常层次结构"></a>异常层次结构</h2><p>内置异常的类层级结构如下：</p>
<pre><code>BaseException
 +-- SystemExit
 +-- KeyboardInterrupt
 +-- GeneratorExit
 +-- Exception
      +-- StopIteration
      +-- StopAsyncIteration
      +-- ArithmeticError
      |    +-- FloatingPointError
      |    +-- OverflowError
      |    +-- ZeroDivisionError
      +-- AssertionError
      +-- AttributeError
      +-- BufferError
      +-- EOFError
      +-- ImportError
      |    +-- ModuleNotFoundError
      +-- LookupError
      |    +-- IndexError
      |    +-- KeyError
      +-- MemoryError
      +-- NameError
      |    +-- UnboundLocalError
      +-- OSError
      |    +-- BlockingIOError
      |    +-- ChildProcessError
      |    +-- ConnectionError
      |    |    +-- BrokenPipeError
      |    |    +-- ConnectionAbortedError
      |    |    +-- ConnectionRefusedError
      |    |    +-- ConnectionResetError
      |    +-- FileExistsError
      |    +-- FileNotFoundError
      |    +-- InterruptedError
      |    +-- IsADirectoryError
      |    +-- NotADirectoryError
      |    +-- PermissionError
      |    +-- ProcessLookupError
      |    +-- TimeoutError
      +-- ReferenceError
      +-- RuntimeError
      |    +-- NotImplementedError
      |    +-- RecursionError
      +-- SyntaxError
      |    +-- IndentationError
      |         +-- TabError
      +-- SystemError
      +-- TypeError
      +-- ValueError
      |    +-- UnicodeError
      |         +-- UnicodeDecodeError
      |         +-- UnicodeEncodeError
      |         +-- UnicodeTranslateError
      +-- Warning
           +-- DeprecationWarning
           +-- PendingDeprecationWarning
           +-- RuntimeWarning
           +-- SyntaxWarning
           +-- UserWarning
           +-- FutureWarning
           +-- ImportWarning
           +-- UnicodeWarning
           +-- BytesWarning
           +-- EncodingWarning
           +-- ResourceWarning</code></pre><h1 id="文本处理服务"><a href="#文本处理服务" class="headerlink" title="文本处理服务"></a>文本处理服务</h1><p>在 二进制数据服务 之下描述的 <code>codecs</code> 模块也与文本处理高度相关。</p>
<ul>
<li><code>string</code> —- 常见的字符串操作<ul>
<li>字符串常量</li>
<li>自定义字符串格式化</li>
<li>格式字符串语法<ul>
<li>格式规格迷你语言</li>
<li>格式示例</li>
</ul>
</li>
<li>模板字符串</li>
<li>辅助函数</li>
</ul>
</li>
<li><code>re</code> —- 正则表达式操作<ul>
<li>正则表达式语法</li>
<li>模块内容</li>
<li>正则表达式对象 （正则对象）</li>
<li>匹配对象</li>
<li>正则表达式例子<ul>
<li>检查对子</li>
<li>模拟 scanf()</li>
<li>search() vs. match()</li>
<li>制作一个电话本</li>
<li>文字整理</li>
<li>查找所有副词</li>
<li>查找所有的副词及其位置</li>
<li>原始字符串标记</li>
<li>写一个词法分析器</li>
</ul>
</li>
</ul>
</li>
<li><code>difflib</code> —- 计算差异的辅助工具<ul>
<li>SequenceMatcher 对象</li>
<li>SequenceMatcher 的示例</li>
<li>Differ 对象</li>
<li>Differ 示例</li>
<li>difflib 的命令行接口</li>
</ul>
</li>
<li><code>textwrap</code> —- 文本自动换行与填充</li>
<li><code>unicodedata</code> —- Unicode 数据库</li>
<li><code>stringprep</code> —- 因特网字符串预备</li>
<li><code>readline</code> —- GNU readline 接口<ul>
<li>初始化文件</li>
<li>行缓冲区</li>
<li>历史文件</li>
<li>历史列表</li>
<li>启动钩子</li>
<li>Completion</li>
<li>示例</li>
</ul>
</li>
<li><code>rlcompleter</code> —- GNU readline 的补全函数<ul>
<li>Completer 对象</li>
</ul>
</li>
</ul>
<h2 id="string-—-常见的字符串操作"><a href="#string-—-常见的字符串操作" class="headerlink" title="string —- 常见的字符串操作"></a><code>string</code> —- 常见的字符串操作</h2><p><strong>源代码：</strong> <a href="https://github.com/python/cpython/tree/3.10/Lib/string.py" target="_blank" rel="noopener">Lib/string.py</a></p>
<h3 id="字符串常量"><a href="#字符串常量" class="headerlink" title="字符串常量"></a>字符串常量</h3><p>此模块中定义的常量为：</p>
<pre><code>string.ascii_letters</code></pre><p>下文所述 <code>ascii_lowercase</code> 和 <code>ascii_uppercase</code> 常量的拼连。 该值不依赖于语言区域。</p>
<pre><code>string.ascii_lowercase</code></pre><p>小写字母 <code>'abcdefghijklmnopqrstuvwxyz'</code>。 该值不依赖于语言区域，不会发生改变。</p>
<pre><code>string.ascii_uppercase</code></pre><p>大写字母 <code>'ABCDEFGHIJKLMNOPQRSTUVWXYZ'</code>。 该值不依赖于语言区域，不会发生改变。</p>
<pre><code>string.digits</code></pre><p>字符串 <code>'0123456789'</code>。</p>
<pre><code>string.hexdigits</code></pre><p>字符串 <code>'0123456789abcdefABCDEF'</code>。</p>
<pre><code>string.octdigits</code></pre><p>字符串 <code>'01234567'</code>。</p>
<pre><code>string.punctuation</code></pre><p>由在 <code>C</code> 区域设置中被视为标点符号的 ASCII 字符所组成的字符串: <code>!"#$%&amp;'()*+,-./:;&lt;=&gt;?@[\]^_</code>{|}~`.</p>
<pre><code>string.printable</code></pre><p>由被视为可打印符号的 ASCII 字符组成的字符串。 这是 <code>digits</code>, <code>ascii_letters</code>, <code>punctuation</code> 和 <code>whitespace</code> 的总和。</p>
<pre><code>string.whitespace</code></pre><p>由被视为空白符号的 ASCII 字符组成的字符串。 其中包括空格、制表、换行、回车、进纸和纵向制表符。</p>
<h3 id="自定义字符串格式化"><a href="#自定义字符串格式化" class="headerlink" title="自定义字符串格式化"></a>自定义字符串格式化</h3><p>内置的字符串类提供了通过使用 <a href="https://www.python.org/dev/peps/pep-3101" target="_blank" rel="noopener"><strong>PEP 3101</strong></a> 所描述的 <code>format()</code> 方法进行复杂变量替换和值格式化的能力。 <code>string</code> 模块中的 <code>Formatter</code> 类允许你使用与内置 <code>format()</code> 方法相同的实现来创建并定制你自己的字符串格式化行为。</p>
<p><em>class</em> <code>string.Formatter</code></p>
<p><code>Formatter</code> 类包含下列公有方法：</p>
<ul>
<li><p><code>format</code>(<em>format_string</em>, <em>/</em>, <em>\</em>args<em>,</em> <em>*kwargs</em>)</p>
<p>首要的 API 方法。 它接受一个格式字符串和任意一组位置和关键字参数。 它只是一个调用 <code>vformat()</code> 的包装器。</p>
<p>在 3.7 版更改: 格式字符串参数现在是 仅限位置参数。</p>
</li>
<li><p><code>vformat</code>(<em>format_string</em>, <em>args</em>, <em>kwargs</em>)</p>
<p>此函数执行实际的格式化操作。 它被公开为一个单独的函数，用于需要传入一个预定义字母作为参数，而不是使用 <code>*args</code> 和 <code>**kwargs</code> 语法将字典解包为多个单独参数并重打包的情况。 <code>vformat()</code> 完成将格式字符串分解为字符数据和替换字段的工作。 它会调用下文所述的几种不同方法。</p>
</li>
</ul>
<p>此外，<code>Formatter</code> 还定义了一些旨在被子类替换的方法：</p>
<ul>
<li><p><code>parse</code>(<em>format_string</em>)</p>
<p>循环遍历 format_string 并返回一个由可迭代对象组成的元组 (<em>literal_text</em>, <em>field_name</em>, <em>format_spec</em>, <em>conversion</em>)。 它会被 <code>vformat()</code> 用来将字符串分解为文本字面值或替换字段。</p>
<p>元组中的值在概念上表示一段字面文本加上一个替换字段。 如果没有字面文本（如果连续出现两个替换字段就会发生这种情况），则 <em>literal_text</em> 将是一个长度为零的字符串。 如果没有替换字段，则 <em>field_name</em>, <em>format_spec</em> 和 <em>conversion</em> 的值将为 <code>None</code>。</p>
</li>
<li><p><code>get_field</code>(<em>field_name</em>, <em>args</em>, <em>kwargs</em>)</p>
<p>给定 <em>field_name</em> 作为 <code>parse()</code> (见上文) 的返回值，将其转换为要格式化的对象。 返回一个元组 (obj, used_key)。 默认版本接受在 <a href="https://www.python.org/dev/peps/pep-3101" target="_blank" rel="noopener"><strong>PEP 3101</strong></a> 所定义形式的字符串，例如 “0[name]“ 或 “label.title”。 <em>args</em> 和 <em>kwargs</em> 与传给 <code>vformat()</code> 的一样。 返回值 <em>used_key</em> 与 <code>get_value()</code> 的 <em>key</em> 形参具有相同的含义。</p>
</li>
<li><p><code>get_value</code>(<em>key</em>, <em>args</em>, <em>kwargs</em>)</p>
<p>提取给定的字段值。 <em>key</em> 参数将为整数或字符串。 如果是整数，它表示 <em>args</em> 中位置参数的索引；如果是字符串，它表示 <em>kwargs</em> 中的关键字参数名。</p>
<p><em>args</em> 形参会被设为 <code>vformat()</code> 的位置参数列表，而 <em>kwargs</em> 形参会被设为由关键字参数组成的字典。</p>
<p>对于复合字段名称，仅会为字段名称的第一个组件调用这些函数；后续组件会通过普通属性和索引操作来进行处理。</p>
<p>因此举例来说，字段表达式 ‘0.name’ 将导致调用 <code>get_value()</code> 时附带 <em>key</em> 参数值 0。 在 <code>get_value()</code> 通过调用内置的 <code>getattr()</code> 函数返回后将会查找 <code>name</code> 属性。</p>
<p>如果索引或关键字引用了一个不存在的项，则将引发 <code>IndexError</code> 或 <code>KeyError</code>。</p>
</li>
<li><p><code>check_unused_args</code>(<em>used_args</em>, <em>args</em>, <em>kwargs</em>)</p>
<p>在必要时实现对未使用参数进行检测。 此函数的参数是是格式字符串中实际引用的所有参数键的集合（整数表示位置参数，字符串表示名称参数），以及被传给 vformat 的 <em>args</em> 和 <em>kwargs</em> 的引用。 未使用参数的集合可以根据这些形参计算出来。 如果检测失败则 <code>check_unused_args()</code> 应会引发一个异常。</p>
</li>
<li><p><code>format_field</code>(<em>value</em>, <em>format_spec</em>)</p>
<p><code>format_field()</code> 会简单地调用内置全局函数 <code>format()</code>。 提供该方法是为了让子类能够重载它。</p>
</li>
<li><p><code>convert_field</code>(<em>value</em>, <em>conversion</em>)</p>
<p>使用给定的转换类型（来自 <code>parse()</code> 方法所返回的元组）来转换（由 <code>get_field()</code> 所返回的）值。 默认版本支持 ‘s’ (str), ‘r’ (repr) 和 ‘a’ (ascii) 等转换类型。</p>
</li>
</ul>
<h3 id="格式字符串语法"><a href="#格式字符串语法" class="headerlink" title="格式字符串语法"></a>格式字符串语法</h3><p><code>str.format()</code> 方法和 <code>Formatter</code> 类共享相同的格式字符串语法（虽然对于 <code>Formatter</code> 来说，其子类可以定义它们自己的格式字符串语法）。 具体语法与 格式化字符串字面值 相似，但较为简单一些，并且关键的一点是不支持任意表达式。</p>
<p>格式字符串包含有以花括号 <code>{}</code> 括起来的“替换字段”。 不在花括号之内的内容被视为字面文本，会不加修改地复制到输出中。 如果你需要在字面文本中包含花括号字符，可以通过重复来转义: <code>{{` and `}}</code>。</p>
<p>替换字段的语法如下：</p>
<blockquote>
<pre><code>replacement_field ::=  "{" [field_name] ["!" conversion] [":" format_spec] "}"
field_name        ::=  arg_name ("." attribute_name | "[" element_index "]")*
arg_name          ::=  [identifier | digit+]
attribute_name    ::=  identifier
element_index     ::=  digit+ | index_string
index_string      ::=  &lt;any source character except "]"&gt; +
conversion        ::=  "r" | "s" | "a"
format_spec       ::=  &lt;described in the next section&gt;</code></pre></blockquote>
<p>用不太正式的术语来描述，替换字段开头可以用一个 <em>field_name</em> 指定要对值进行格式化并取代替换字符被插入到输出结果的对象。 <em>field_name</em> 之后有可选的 <em>conversion</em> 字段，它是一个感叹号 <code>'!'</code> 加一个 <em>format_spec</em>，并以一个冒号 <code>':'</code> 打头。 这些指明了替换值的非默认格式。</p>
<p><em>field_name</em> 本身以一个数字或关键字 <em>arg_name</em> 打头。 如果为数字，则它指向一个位置参数，而如果为关键字，则它指向一个命名关键字参数。 如果格式字符串中的数字 arg_names 为 0, 1, 2, … 的序列，它们可以全部省略（而非部分省略），数字 0, 1, 2, … 将会按顺序自动插入。 由于 <em>arg_name</em> 不使用引号分隔，因此无法在格式字符串中指定任意的字典键 (例如字符串 <code>'10'</code> 或 <code>':-]'</code>)。 <em>arg_name</em> 之后可以带上任意数量的索引或属性表达式。 <code>'.name'</code> 形式的表达式会使用 <code>getattr()</code> 选择命名属性，而 <code>'[index]'</code> 形式的表达式会使用 <code>__getitem__()</code> 执行索引查找。</p>
<p>在 3.1 版更改: 位置参数说明符对于 <code>str.format()</code> 可以省略，因此 <code>'{} {}'.format(a, b)</code> 等价于 <code>'{0} {1}'.format(a, b)</code>。</p>
<p>在 3.4 版更改: 位置参数说明符对于 <code>Formatter</code> 可以省略。</p>
<p>一些简单的格式字符串示例</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token string">"First, thou shalt count to {0}"</span>  <span class="token comment" spellcheck="true"># References first positional argument</span>
<span class="token string">"Bring me a {}"</span>                   <span class="token comment" spellcheck="true"># Implicitly references the first positional argument</span>
<span class="token string">"From {} to {}"</span>                   <span class="token comment" spellcheck="true"># Same as "From {0} to {1}"</span>
<span class="token string">"My quest is {name}"</span>              <span class="token comment" spellcheck="true"># References keyword argument 'name'</span>
<span class="token string">"Weight in tons {0.weight}"</span>       <span class="token comment" spellcheck="true"># 'weight' attribute of first positional arg</span>
<span class="token string">"Units destroyed: {players[0]}"</span>   <span class="token comment" spellcheck="true"># First element of keyword argument 'players'.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>使用 <em>conversion</em> 字段在格式化之前进行类型强制转换。 通常，格式化值的工作由值本身的 <code>__format__()</code> 方法来完成。 但是，在某些情况下最好强制将类型格式化为一个字符串，覆盖其本身的格式化定义。 通过在调用 <code>__format__()</code> 之前将值转换为字符串，可以绕过正常的格式化逻辑。</p>
<p>目前支持的转换旗标有三种: <code>'!s'</code> 会对值调用 <code>str()</code>，<code>'!r'</code> 调用 <code>repr()</code> 而 <code>'!a'</code> 则调用 <code>ascii()</code>。</p>
<p>示例如下：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token string">"Harold's a clever {0!s}"</span>        <span class="token comment" spellcheck="true"># Calls str() on the argument first</span>
<span class="token string">"Bring out the holy {name!r}"</span>    <span class="token comment" spellcheck="true"># Calls repr() on the argument first</span>
<span class="token string">"More {!a}"</span>                      <span class="token comment" spellcheck="true"># Calls ascii() on the argument first</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p><em>format_spec</em> 字段包含值应如何呈现的规格描述，例如字段宽度、对齐、填充、小数精度等细节信息。 每种值类型可以定义自己的“格式化迷你语言”或对 <em>format_spec</em> 的解读方式。</p>
<p>大多数内置类型都支持同样的格式化迷你语言，具体描述见下一节。</p>
<p><em>format_spec</em> 字段还可以在其内部包含嵌套的替换字段。 这些嵌套的替换字段可能包括字段名称、转换旗标和格式规格描述，但是不再允许更深层的嵌套。 format_spec 内部的替换字段会在解读 <em>format_spec</em> 字符串之前先被解读。 这将允许动态地指定特定值的格式。</p>
<h4 id="格式规格迷你语言"><a href="#格式规格迷你语言" class="headerlink" title="格式规格迷你语言"></a>格式规格迷你语言</h4><p>“格式规格”在格式字符串所包含的替换字段内部使用，用于定义单个值应如何呈现 。 它们也可以被直接传给内置的 <code>format()</code> 函数。 每种可格式化的类型都可以自行定义如何对格式规格进行解读。</p>
<p>大多数内置类型都为格式规格实现了下列选项，不过某些格式化选项只被数值类型所支持。</p>
<p>一般约定空的格式描述将产生与在值上调用 <code>str()</code> 相同的结果。 非空格式描述通常会修改此结果。</p>
<p><em>标准格式说明符</em> 的一般形式如下：</p>
<pre><code>format_spec     ::=  [[fill]align][sign][#][0][width][grouping_option][.precision][type]
fill            ::=  &lt;any character&gt;
align           ::=  "&lt;" | "&gt;" | "=" | "^"
sign            ::=  "+" | "-" | " "
width           ::=  digit+
grouping_option ::=  "_" | ","
precision       ::=  digit+
type            ::=  "b" | "c" | "d" | "e" | "E" | "f" | "F" | "g" | "G" | "n" | "o" | "s" | "x" | "X" | "%"</code></pre><p>如果指定了一个有效的 <em>align</em> 值，则可以在该值前面加一个 <em>fill</em> 字符，它可以为任意字符，如果省略则默认为空格符。 在 格式化字符串字面值 或在使用 <code>str.format()</code> 方法时是无法使用花括号字面值 (“<code>{</code>“ or “<code>}</code>“) 作为 <em>fill</em> 字符的。 但是，通过嵌套替换字段插入花括号则是可以的。 这个限制不会影响 <code>format()</code> 函数。</p>
<p>各种对齐选项的含义如下：</p>
<blockquote>
<table>
<thead>
<tr>
<th align="left">选项</th>
<th align="left">含意</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>‘&lt;’</code></td>
<td align="left">强制字段在可用空间内左对齐（这是大多数对象的默认值）。</td>
</tr>
<tr>
<td align="left"><code>‘&gt;’</code></td>
<td align="left">强制字段在可用空间内右对齐（这是数字的默认值）。</td>
</tr>
<tr>
<td align="left"><code>‘=’</code></td>
<td align="left">强制在符号（如果有）之后数码之前放置填充。 这被用于以 ‘+000000120’ 形式打印字段。 这个对齐选项仅对数字类型有效。 这是当 ‘0’ 紧接在字段宽度之前时的默认选项。</td>
</tr>
<tr>
<td align="left"><code>‘^’</code></td>
<td align="left">强制字段在可用空间内居中。</td>
</tr>
</tbody></table>
</blockquote>
<p>请注意，除非定义了最小字段宽度，否则字段宽度将始终与填充它的数据大小相同，因此在这种情况下，对齐选项没有意义。</p>
<p><em>sign</em> 选项仅对数字类型有效，可以是以下之一：</p>
<blockquote>
<table>
<thead>
<tr>
<th align="left">选项</th>
<th align="left">含意</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>‘+’</code></td>
<td align="left">表示标志应该用于正数和负数。</td>
</tr>
<tr>
<td align="left"><code>‘-‘</code></td>
<td align="left">表示标志应仅用于负数（这是默认行为）。</td>
</tr>
<tr>
<td align="left">space</td>
<td align="left">表示应在正数上使用前导空格，在负数上使用减号。</td>
</tr>
</tbody></table>
</blockquote>
<p><code>'#'</code> 选项可让“替代形式”被用于执行转换。 替代形式会针对不同的类型分别定义。 此选项仅适用于整数、浮点数和复数类型。 对于整数类型，当使用二进制、八进制或十六进制输出时，此选项会为输出值分别添加相应的 <code>'0b'</code>, <code>'0o'</code>, <code>'0x'</code> 或 <code>'0X'</code> 前缀。 对于浮点数和复数类型，替代形式会使得转换结果总是包含小数点符号，即使其不带小数部分。 通常只有在带有小数部分的情况下，此类转换的结果中才会出现小数点符号。 此外，对于 <code>'g'</code> 和 <code>'G'</code> 转换，末尾的零不会从结果中被移除。</p>
<p><code>','</code> 选项表示使用逗号作为千位分隔符。 对于感应区域设置的分隔符，请改用 <code>'n'</code> 整数表示类型。</p>
<p>在 3.1 版更改: 添加了 <code>','</code> 选项 (另请参阅 <a href="https://www.python.org/dev/peps/pep-0378" target="_blank" rel="noopener"><strong>PEP 378</strong></a>)。</p>
<p><code>'_'</code> 选项表示对浮点表示类型和整数表示类型 <code>'d'</code> 使用下划线作为千位分隔符。 对于整数表示类型 <code>'b'</code>, <code>'o'</code>, <code>'x'</code> 和 <code>'X'</code>，将为每 4 个数位插入一个下划线。 对于其他表示类型指定此选项则将导致错误。</p>
<p>在 3.6 版更改: 添加了 <code>'_'</code> 选项 (另请参阅 <a href="https://www.python.org/dev/peps/pep-0515" target="_blank" rel="noopener"><strong>PEP 515</strong></a>)。</p>
<p><em>width</em> 是一个定义最小总字段宽度的十进制整数，包括任何前缀、分隔符和其他格式化字符。 如果未指定，则字段宽度将由内容确定。</p>
<p>当未显式给出对齐方式时，在 <em>width</em> 字段前加一个零 (<code>'0'</code>) 字段将为数字类型启用感知正负号的零填充。 这相当于设置 <em>fill</em> 字符为 <code>'0'</code> 且 <em>alignment</em> 类型为 <code>'='</code>。</p>
<p>在 3.10 版更改: 在 <em>width</em> 字段之前添加 <code>'0'</code> 不会再影响字符串的默认对齐。</p>
<p><em>precision</em> 是一个十进制数字，表示对于以 <code>'f'</code> and <code>'F'</code> 格式化的浮点数值要在小数点后显示多少个数位，或者对于以 <code>'g'</code> 或 <code>'G'</code> 格式化的浮点数值要在小数点前后共显示多少个数位。 对于非数字类型，该字段表示最大字段大小 —— 换句话说就是要使用多少个来自字段内容的字符。 对于整数值则不允许使用 <em>precision</em>。</p>
<p>最后，<em>type</em> 确定了数据应如何呈现。</p>
<p>可用的字符串表示类型是：</p>
<blockquote>
<table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">含意</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>‘s’</code></td>
<td align="left">字符串格式。这是字符串的默认类型，可以省略。</td>
</tr>
<tr>
<td align="left">None</td>
<td align="left">和 <code>‘s’</code> 一样。</td>
</tr>
</tbody></table>
</blockquote>
<p>可用的整数表示类型是：</p>
<blockquote>
<table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">含意</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>‘b’</code></td>
<td align="left">二进制格式。 输出以 2 为基数的数字。</td>
</tr>
<tr>
<td align="left"><code>‘c’</code></td>
<td align="left">字符。在打印之前将整数转换为相应的unicode字符。</td>
</tr>
<tr>
<td align="left"><code>‘d’</code></td>
<td align="left">十进制整数。 输出以 10 为基数的数字。</td>
</tr>
<tr>
<td align="left"><code>‘o’</code></td>
<td align="left">八进制格式。 输出以 8 为基数的数字。</td>
</tr>
<tr>
<td align="left"><code>‘x’</code></td>
<td align="left">十六进制格式。 输出以 16 为基数的数字，使用小写字母表示 9 以上的数码。</td>
</tr>
<tr>
<td align="left"><code>‘X’</code></td>
<td align="left">十六进制格式。 输出以 16 为基数的数字，使用大写字母表示 9 以上的数码。 在指定 <code>‘#’</code> 的情况下，前缀 <code>‘0x’</code> 也将被转为大写形式 <code>‘0X’</code>。</td>
</tr>
<tr>
<td align="left"><code>‘n’</code></td>
<td align="left">数字。 这与 <code>‘d’</code> 相似，不同之处在于它会使用当前区域设置来插入适当的数字分隔字符。</td>
</tr>
<tr>
<td align="left">None</td>
<td align="left">和 <code>‘d’</code> 相同。</td>
</tr>
</tbody></table>
</blockquote>
<p>在上述的表示类型之外，整数还可以通过下列的浮点表示类型来格式化 (除了 <code>'n'</code> 和 <code>None</code>)。 当这样做时，会在格式化之前使用 <code>float()</code> 将整数转换为浮点数。</p>
<p><code>float</code> 和 <code>Decimal</code> 值的可用表示类型有:</p>
<blockquote>
<table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">含意</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>‘e’</code></td>
<td align="left">科学计数法。 对于一个给定的精度 <code>p</code>，将数字格式化为以字母 ‘e’ 分隔系数和指数的科学计数法形式。 系数在小数点之前有一位，之后有 <code>p</code> 位，总计 <code>p + 1</code> 个有效数位。 如未指定精度，则会对 <code>float</code> 采用小数点之后 <code>6</code> 位精度，而对 <code>Decimal</code> 则显示所有系数位。 如果小数点之后没有数位，则小数点也会被略去，除非使用了 <code>#</code> 选项。</td>
</tr>
<tr>
<td align="left"><code>‘E’</code></td>
<td align="left">科学计数法。 与 <code>‘e’</code> 相似，不同之处在于它使用大写字母 ‘E’ 作为分隔字符。</td>
</tr>
<tr>
<td align="left"><code>‘f’</code></td>
<td align="left">定点表示法。 对于一个给定的精度 <code>p</code>，将数字格式化为在小数点之后恰好有 <code>p</code> 位的小数形式。 如未指定精度，则会对 <code>float</code> 采用小数点之后 <code>6</code> 位精度，而对 <code>Decimal</code> 则使用大到足够显示所有系数位的精度。 如果小数点之后没有数位，则小数点也会被略去，除非使用了 <code>#</code> 选项。</td>
</tr>
<tr>
<td align="left"><code>‘F’</code></td>
<td align="left">定点表示。 与 <code>‘f’</code> 相似，但会将 <code>nan</code> 转为 <code>NAN</code> 并将 <code>inf</code> 转为 <code>INF</code>。</td>
</tr>
<tr>
<td align="left"><code>‘g’</code></td>
<td align="left">常规格式。 对于给定精度 <code>p &gt;= 1</code>，这会将数值舍入到 <code>p</code> 个有效数位，再将结果以定点表示法或科学计数法进行格式化，具体取决于其值的大小。 精度 <code>0</code> 会被视为等价于精度 <code>1</code>。准确的规则如下：假设使用表示类型 <code>‘e’</code> 和精度 <code>p-1</code> 进行格式化的结果具有指数值 <code>exp</code>。 那么如果 <code>m &lt;= exp &lt; p</code>，其中 <code>m</code> 以 -4 表示浮点值而以 -6 表示 <code>Decimal</code> 值，该数字将使用类型 <code>‘f’</code> 和精度 <code>p-1-exp</code> 进行格式化。 否则的话，该数字将使用表示类型 <code>‘e’</code> 和精度 <code>p-1</code> 进行格式化。 在两种情况下，都会从有效数字中移除无意义的末尾零，如果小数点之后没有余下数字则小数点也会被移除，除非使用了 <code>‘#’</code> 选项。如未指定精度，会对 <code>float</code> 采用 <code>6</code> 个有效数位的精度。 对于 <code>Decimal</code>，结果的系数会沿用原值的系数数位；对于绝对值小于 <code>1e-6</code> 的值以及最小有效数位的位值大于 1 的数值将会使用科学计数法，在其他情况下则会使用定点表示法。正负无穷，正负零和 nan 会分别被格式化为 <code>inf</code>, <code>-inf</code>, <code>0</code>, <code>-0</code> 和 <code>nan</code>，无论精度如何设定。</td>
</tr>
<tr>
<td align="left"><code>‘G’</code></td>
<td align="left">常规格式。 类似于 <code>‘g’</code>，不同之处在于当数值非常大时会切换为 <code>‘E’</code>。 无穷与 NaN 也会表示为大写形式。</td>
</tr>
<tr>
<td align="left"><code>‘n’</code></td>
<td align="left">数字。 这与 <code>‘g’</code> 相似，不同之处在于它会使用当前区域设置来插入适当的数字分隔字符。</td>
</tr>
<tr>
<td align="left"><code>‘%’</code></td>
<td align="left">百分比。 将数字乘以 100 并显示为定点 (<code>‘f’</code>) 格式，后面带一个百分号。</td>
</tr>
<tr>
<td align="left">None</td>
<td align="left">对于 <code>float</code> 来说这类似于 <code>‘g’</code>，不同之处在于当使用定点表示法时，小数点之后将至少显示一位。 所用的精度会大到足以精确表示给定的值。对于 <code>Decimal</code> 来说这相当于 <code>‘g’</code> 或 <code>‘G’</code>，具体取决于当前 decimal 上下文的 <code>context.capitals</code> 值。总体效果是将 <code>str()</code> 的输出匹配为其他格式化因子所调整出的样子。</td>
</tr>
</tbody></table>
</blockquote>
<h4 id="格式示例"><a href="#格式示例" class="headerlink" title="格式示例"></a>格式示例</h4><p>本节包含 <code>str.format()</code> 语法的示例以及与旧式 <code>%</code> 格式化的比较。</p>
<p>该语法在大多数情况下与旧式的 <code>%</code> 格式化类似，只是增加了 <code>{}</code> 和 <code>:</code> 来取代 <code>%</code>。 例如，，<code>'%03.2f'</code> 可以被改写为 <code>'{:03.2f}'</code>。</p>
<p>新的格式语法还支持新增的不同选项，将在以下示例中说明。</p>
<p>按位置访问参数:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token string">'{0}, {1}, {2}'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token string">'c'</span><span class="token punctuation">)</span>
<span class="token string">'a, b, c'</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token string">'{}, {}, {}'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token string">'c'</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 3.1+ only</span>
<span class="token string">'a, b, c'</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token string">'{2}, {1}, {0}'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token string">'c'</span><span class="token punctuation">)</span>
<span class="token string">'c, b, a'</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token string">'{2}, {1}, {0}'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span><span class="token operator">*</span><span class="token string">'abc'</span><span class="token punctuation">)</span>      <span class="token comment" spellcheck="true"># unpacking argument sequence</span>
<span class="token string">'c, b, a'</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token string">'{0}{1}{0}'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span><span class="token string">'abra'</span><span class="token punctuation">,</span> <span class="token string">'cad'</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true"># arguments' indices can be repeated</span>
<span class="token string">'abracadabra'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>按名称访问参数:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token string">'Coordinates: {latitude}, {longitude}'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>latitude<span class="token operator">=</span><span class="token string">'37.24N'</span><span class="token punctuation">,</span> longitude<span class="token operator">=</span><span class="token string">'-115.81W'</span><span class="token punctuation">)</span>
<span class="token string">'Coordinates: 37.24N, -115.81W'</span>
<span class="token operator">>></span><span class="token operator">></span> coord <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'latitude'</span><span class="token punctuation">:</span> <span class="token string">'37.24N'</span><span class="token punctuation">,</span> <span class="token string">'longitude'</span><span class="token punctuation">:</span> <span class="token string">'-115.81W'</span><span class="token punctuation">}</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token string">'Coordinates: {latitude}, {longitude}'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span><span class="token operator">**</span>coord<span class="token punctuation">)</span>
<span class="token string">'Coordinates: 37.24N, -115.81W'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>访问参数的属性:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> c <span class="token operator">=</span> <span class="token number">3</span><span class="token operator">-</span><span class="token number">5j</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token punctuation">(</span><span class="token string">'The complex number {0} is formed from the real part {0.real} '</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  <span class="token string">'and the imaginary part {0.imag}.'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>c<span class="token punctuation">)</span>
<span class="token string">'The complex number (3-5j) is formed from the real part 3.0 and the imaginary part -5.0.'</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">class</span> <span class="token class-name">Point</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         self<span class="token punctuation">.</span>x<span class="token punctuation">,</span> self<span class="token punctuation">.</span>y <span class="token operator">=</span> x<span class="token punctuation">,</span> y
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">def</span> <span class="token function">__str__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         <span class="token keyword">return</span> <span class="token string">'Point({self.x}, {self.y})'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>self<span class="token operator">=</span>self<span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> str<span class="token punctuation">(</span>Point<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token string">'Point(4, 2)'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>访问参数的项:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> coord <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token string">'X: {0[0]};  Y: {0[1]}'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>coord<span class="token punctuation">)</span>
<span class="token string">'X: 3;  Y: 5'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>替代 <code>%s</code> 和 <code>%r</code>:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token string">"repr() shows quotes: {!r}; str() doesn't: {!s}"</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span><span class="token string">'test1'</span><span class="token punctuation">,</span> <span class="token string">'test2'</span><span class="token punctuation">)</span>
<span class="token string">"repr() shows quotes: 'test1'; str() doesn't: test2"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>对齐文本以及指定宽度:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token string">'{:&lt;30}'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span><span class="token string">'left aligned'</span><span class="token punctuation">)</span>
<span class="token string">'left aligned                  '</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token string">'{:>30}'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span><span class="token string">'right aligned'</span><span class="token punctuation">)</span>
<span class="token string">'                 right aligned'</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token string">'{:^30}'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span><span class="token string">'centered'</span><span class="token punctuation">)</span>
<span class="token string">'           centered           '</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token string">'{:*^30}'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span><span class="token string">'centered'</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># use '*' as a fill char</span>
<span class="token string">'***********centered***********'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>替代 <code>%+f</code>, <code>%-f</code> 和 <code>% f</code> 以及指定正负号:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token string">'{:+f}; {:+f}'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span><span class="token number">3.14</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">3.14</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># show it always</span>
<span class="token string">'+3.140000; -3.140000'</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token string">'{: f}; {: f}'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span><span class="token number">3.14</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">3.14</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># show a space for positive numbers</span>
<span class="token string">' 3.140000; -3.140000'</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token string">'{:-f}; {:-f}'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span><span class="token number">3.14</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">3.14</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># show only the minus -- same as '{:f}; {:f}'</span>
<span class="token string">'3.140000; -3.140000'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>替代 <code>%x</code> 和 <code>%o</code> 以及转换基于不同进位制的值:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token comment" spellcheck="true"># format also supports binary numbers</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token string">"int: {0:d};  hex: {0:x};  oct: {0:o};  bin: {0:b}"</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span>
<span class="token string">'int: 42;  hex: 2a;  oct: 52;  bin: 101010'</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token comment" spellcheck="true"># with 0x, 0o, or 0b as prefix:</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token string">"int: {0:d};  hex: {0:#x};  oct: {0:#o};  bin: {0:#b}"</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span>
<span class="token string">'int: 42;  hex: 0x2a;  oct: 0o52;  bin: 0b101010'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>使用逗号作为千位分隔符:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token string">'{:,}'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span><span class="token number">1234567890</span><span class="token punctuation">)</span>
<span class="token string">'1,234,567,890'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>表示为百分数:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> points <span class="token operator">=</span> <span class="token number">19</span>
<span class="token operator">>></span><span class="token operator">></span> total <span class="token operator">=</span> <span class="token number">22</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token string">'Correct answers: {:.2%}'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>points<span class="token operator">/</span>total<span class="token punctuation">)</span>
<span class="token string">'Correct answers: 86.36%'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>使用特定类型的专属格式化:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> datetime
<span class="token operator">>></span><span class="token operator">></span> d <span class="token operator">=</span> datetime<span class="token punctuation">.</span>datetime<span class="token punctuation">(</span><span class="token number">2010</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">,</span> <span class="token number">58</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token string">'{:%Y-%m-%d %H:%M:%S}'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>d<span class="token punctuation">)</span>
<span class="token string">'2010-07-04 12:15:58'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>嵌套参数以及更复杂的示例:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">for</span> align<span class="token punctuation">,</span> text <span class="token keyword">in</span> zip<span class="token punctuation">(</span><span class="token string">'&lt;^>'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'left'</span><span class="token punctuation">,</span> <span class="token string">'center'</span><span class="token punctuation">,</span> <span class="token string">'right'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token string">'{0:{fill}{align}16}'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>text<span class="token punctuation">,</span> fill<span class="token operator">=</span>align<span class="token punctuation">,</span> align<span class="token operator">=</span>align<span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token string">'left&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;'</span>
<span class="token string">'^^^^^center^^^^^'</span>
<span class="token string">'>>>>>>>>>>>right'</span>
<span class="token operator">>></span><span class="token operator">></span>
<span class="token operator">>></span><span class="token operator">></span> octets <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">192</span><span class="token punctuation">,</span> <span class="token number">168</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token string">'{:02X}{:02X}{:02X}{:02X}'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span><span class="token operator">*</span>octets<span class="token punctuation">)</span>
<span class="token string">'C0A80001'</span>
<span class="token operator">>></span><span class="token operator">></span> int<span class="token punctuation">(</span>_<span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">)</span>
<span class="token number">3232235521</span>
<span class="token operator">>></span><span class="token operator">></span>
<span class="token operator">>></span><span class="token operator">></span> width <span class="token operator">=</span> <span class="token number">5</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">for</span> num <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">:</span> 
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">for</span> base <span class="token keyword">in</span> <span class="token string">'dXob'</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'{0:{width}{base}}'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>num<span class="token punctuation">,</span> base<span class="token operator">=</span>base<span class="token punctuation">,</span> width<span class="token operator">=</span>width<span class="token punctuation">)</span><span class="token punctuation">,</span> end<span class="token operator">=</span><span class="token string">' '</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token number">5</span>     <span class="token number">5</span>     <span class="token number">5</span>   <span class="token number">101</span>
    <span class="token number">6</span>     <span class="token number">6</span>     <span class="token number">6</span>   <span class="token number">110</span>
    <span class="token number">7</span>     <span class="token number">7</span>     <span class="token number">7</span>   <span class="token number">111</span>
    <span class="token number">8</span>     <span class="token number">8</span>    <span class="token number">10</span>  <span class="token number">1000</span>
    <span class="token number">9</span>     <span class="token number">9</span>    <span class="token number">11</span>  <span class="token number">1001</span>
   <span class="token number">10</span>     A    <span class="token number">12</span>  <span class="token number">1010</span>
   <span class="token number">11</span>     B    <span class="token number">13</span>  <span class="token number">1011</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h3><p>模板字符串提供了由 <a href="https://www.python.org/dev/peps/pep-0292" target="_blank" rel="noopener"><strong>PEP 292</strong></a> 所描述的更简便的字符串替换方式。 模板字符串的一个主要用例是文本国际化 (i18n)，因为在此场景下，更简单的语法和功能使得文本翻译过程比使用 Python 的其他内置字符串格式化工具更为方便。 作为基于模板字符串构建以实现 i18n 的库的一个示例，请参看 <a href="http://flufli18n.readthedocs.io/en/latest/" target="_blank" rel="noopener">flufl.i18n</a> 包。</p>
<p>模板字符串支持基于 <code>$</code> 的替换，使用以下规则：</p>
<ul>
<li><code>$$</code> 为转义符号；它会被替换为单个的 <code>$</code>。</li>
<li><code>$identifier</code> 为替换占位符，它会匹配一个名为 <code>"identifier"</code> 的映射键。 在默认情况下，<code>"identifier"</code> 限制为任意 ASCII 字母数字（包括下划线）组成的字符串，不区分大小写，以下划线或 ASCII 字母开头。 在 <code>$</code> 字符之后的第一个非标识符字符将表明占位符的终结。</li>
<li><code>${identifier}</code> 等价于 <code>$identifier</code>。 当占位符之后紧跟着有效的但又不是占位符一部分的标识符字符时需要使用，例如 <code>"${noun}ification"</code>。</li>
</ul>
<p>在字符串的其他位置出现 <code>$</code> 将导致引发 <code>ValueError</code>。</p>
<p><code>string</code> 模块提供了实现这些规则的 <code>Template</code> 类。 <code>Template</code> 有下列方法：</p>
<p><em>class</em> <code>string.Template</code>(<em>template</em>)</p>
<p>该构造器接受一个参数作为模板字符串。</p>
<ul>
<li><p><code>substitute</code>(<em>mapping={}</em>, <em>/</em>, <em>**kwds</em>)</p>
<p>执行模板替换，返回一个新字符串。 <em>mapping</em> 为任意字典类对象，其中的键将匹配模板中的占位符。 或者你也可以提供一组关键字参数，其中的关键字即对应占位符。 当同时给出 <em>mapping</em> 和 <em>kwds</em> 并且存在重复时，则以 <em>kwds</em> 中的占位符为优先。</p>
</li>
<li><p><code>safe_substitute</code>(<em>mapping={}</em>, <em>/</em>, <em>**kwds</em>)</p>
<p>类似于 <code>substitute()</code>，不同之处是如果有占位符未在 <em>mapping</em> 和 <em>kwds</em> 中找到，不是引发 <code>KeyError</code> 异常，而是将原始占位符不加修改地显示在结果字符串中。 另一个与 <code>substitute()</code> 的差异是任何在其他情况下出现的 <code>$</code> 将简单地返回 <code>$</code> 而不是引发 <code>ValueError</code>。</p>
<p>此方法被认为“安全”，因为虽然仍有可能发生其他异常，但它总是尝试返回可用的字符串而不是引发一个异常。 从另一方面来说，<code>safe_substitute()</code> 也可能根本算不上安全，因为它将静默地忽略错误格式的模板，例如包含多余的分隔符、不成对的花括号或不是合法 Python 标识符的占位符等等。</p>
</li>
</ul>
<p><code>Template</code> 的实例还提供一个公有数据属性：</p>
<ul>
<li><p><code>template</code></p>
<p>这是作为构造器的 <em>template</em> 参数被传入的对象。 一般来说，你不应该修改它，但并不强制要求只读访问。</p>
</li>
</ul>
<p>以下是一个如何使用模版的示例：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> string <span class="token keyword">import</span> Template
<span class="token operator">>></span><span class="token operator">></span> s <span class="token operator">=</span> Template<span class="token punctuation">(</span><span class="token string">'$who likes $what'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> s<span class="token punctuation">.</span>substitute<span class="token punctuation">(</span>who<span class="token operator">=</span><span class="token string">'tim'</span><span class="token punctuation">,</span> what<span class="token operator">=</span><span class="token string">'kung pao'</span><span class="token punctuation">)</span>
<span class="token string">'tim likes kung pao'</span>
<span class="token operator">>></span><span class="token operator">></span> d <span class="token operator">=</span> dict<span class="token punctuation">(</span>who<span class="token operator">=</span><span class="token string">'tim'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> Template<span class="token punctuation">(</span><span class="token string">'Give $who $100'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>substitute<span class="token punctuation">(</span>d<span class="token punctuation">)</span>
Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
ValueError<span class="token punctuation">:</span> Invalid placeholder <span class="token keyword">in</span> string<span class="token punctuation">:</span> line <span class="token number">1</span><span class="token punctuation">,</span> col <span class="token number">11</span>
<span class="token operator">>></span><span class="token operator">></span> Template<span class="token punctuation">(</span><span class="token string">'$who likes $what'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>substitute<span class="token punctuation">(</span>d<span class="token punctuation">)</span>
Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
KeyError<span class="token punctuation">:</span> <span class="token string">'what'</span>
<span class="token operator">>></span><span class="token operator">></span> Template<span class="token punctuation">(</span><span class="token string">'$who likes $what'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>safe_substitute<span class="token punctuation">(</span>d<span class="token punctuation">)</span>
<span class="token string">'tim likes $what'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>进阶用法：你可以派生 <code>Template</code> 的子类来自定义占位符语法、分隔符，或用于解析模板字符串的整个正则表达式。 为此目的，你可以重载这些类属性：</p>
<ul>
<li><p><em>delimiter</em> — 这是用来表示占位符的起始的分隔符的字符串字面值。 默认值为 <code>$</code>。 请注意此参数 <em>不能</em> 为正则表达式，因为其实现将在必要时对此字符串调用 <code>re.escape()</code>。 还要注意你不能在创建类之后改变此分隔符（例如在子类的类命名空间中必须设置不同的分隔符）。</p>
</li>
<li><p><em>idpattern</em> — 这是用来描述不带花括号的占位符的模式的正则表达式。 默认值为正则表达式 <code>(?a:[_a-z][_a-z0-9]*)</code>。 如果给出了此属性并且 <em>braceidpattern</em> 为 <code>None</code> 则此模式也将作用于带花括号的占位符。</p>
<p>注解</p>
<p>由于默认的 <em>flags</em> 为 <code>re.IGNORECASE</code>，模式 <code>[a-z]</code> 可以匹配某些非 ASCII 字符。 因此我们在这里使用了局部旗标 <code>a</code>。</p>
<p>在 3.7 版更改: <em>braceidpattern</em> 可被用来定义对花括号内部和外部进行区分的模式。</p>
</li>
<li><p><em>braceidpattern</em> — 此属性类似于 <em>idpattern</em> 但是用来描述带花括号的占位符的模式。 默认值 <code>None</code> 意味着回退到 <em>idpattern</em> (即在花括号内部和外部使用相同的模式)。 如果给出此属性，这将允许你为带花括号和不带花括号的占位符定义不同的模式。</p>
<p>3.7 新版功能.</p>
</li>
<li><p><em>flags</em> — 将在编译用于识别替换内容的正则表达式被应用的正则表达式旗标。 默认值为 <code>re.IGNORECASE</code>。 请注意 <code>re.VERBOSE</code> 总是会被加为旗标，因此自定义的 <em>idpattern</em> 必须遵循详细正则表达式的约定。</p>
<p>3.2 新版功能.</p>
</li>
</ul>
<p>作为另一种选项，你可以通过重载类属性 <em>pattern</em> 来提供整个正则表达式模式。 如果你这样做，该值必须为一个具有四个命名捕获组的正则表达式对象。 这些捕获组对应于上面已经给出的规则，以及无效占位符的规则：</p>
<ul>
<li><em>escaped</em> — 这个组匹配转义序列，在默认模式中即 <code>$$</code>。</li>
<li><em>named</em> — 这个组匹配不带花括号的占位符名称；它不应当包含捕获组中的分隔符。</li>
<li><em>braced</em> — 这个组匹配带有花括号的占位符名称；它不应当包含捕获组中的分隔符或者花括号。</li>
<li><em>invalid</em> — 这个组匹配任何其他分隔符模式（通常为单个分隔符），并且它应当出现在正则表达式的末尾。</li>
</ul>
<h3 id="辅助函数"><a href="#辅助函数" class="headerlink" title="辅助函数"></a>辅助函数</h3><p><code>string.capwords</code>(<em>s</em>, <em>sep=None</em>)</p>
<p>使用 <code>str.split()</code> 将参数拆分为单词，使用 <code>str.capitalize()</code> 将单词转为大写形式，使用 <code>str.join()</code> 将大写的单词进行拼接。 如果可选的第二个参数 <em>sep</em> 被省略或为 <code>None</code>，则连续的空白字符会被替换为单个空格符并且开头和末尾的空白字符会被移除，否则 <em>sep</em> 会被用来拆分和拼接单词。</p>
<h2 id="re-—-正则表达式操作"><a href="#re-—-正则表达式操作" class="headerlink" title="re —- 正则表达式操作"></a><code>re</code> —- 正则表达式操作</h2><p><strong>源代码:</strong> <a href="https://github.com/python/cpython/tree/3.10/Lib/re.py" target="_blank" rel="noopener">Lib/re.py</a></p>
<hr>
<p>本模块提供了与 Perl 语言类似的正则表达式匹配操作。</p>
<p>模式和被搜索的字符串既可以是 Unicode 字符串 (<code>str</code>) ，也可以是8位字节串 (<code>bytes</code>)。 但是，Unicode 字符串与 8 位字节串不能混用：也就是说，不能用字节串模式匹配 Unicode 字符串，反之亦然；同理，替换操作时，替换字符串的类型也必须与所用的模式和搜索字符串的类型一致。</p>
<p>正则表达式用反斜杠字符 (<code>'\'</code>) 表示特殊形式，或是允许在使用特殊字符时，不引发它们的特殊含义。 这与 Python 的字符串字面值中对相同字符出于相同目的的用法产生冲突；例如，要匹配一个反斜杠字面值，用户可能必须写成 <code>'\\\\'</code> 来作为模式字符串，因为正则表达式必须为 <code>\\</code>，而每个反斜杠在普通 Python 字符串字面值中又必须表示为 <code>\\</code>。 而且还要注意，在 Python 的字符串字面值中使用的反斜杠如果有任何无效的转义序列，现在会触发 <code>DeprecationWarning</code>，但以后会改为 <code>SyntaxError</code>。 此行为即使对于正则表达式来说有效的转义字符同样会发生。</p>
<p>解决办法是对于正则表达式样式使用 Python 的原始字符串表示法；在带有 <code>'r'</code> 前缀的字符串字面值中，反斜杠不必做任何特殊处理。 因此 <code>r"\n"</code> 表示包含 <code>'\'</code> 和 <code>'n'</code> 两个字符的字符串，而 <code>"\n"</code> 则表示只包含一个换行符的字符串。 样式在 Python 代码中通常都使用原始字符串表示法。</p>
<p>绝大多数正则表达式操作都提供为模块函数和方法，在 编译正则表达式. 这些函数是一个捷径，不需要先编译正则对象，但是损失了一些优化参数。</p>
<p>参见</p>
<p>第三方模块 regex , 提供了与标准库 <code>re</code> 模块兼容的 API 接口，同时，还提供了更多功能和更全面的 Unicode 支持。</p>
<h3 id="正则表达式语法"><a href="#正则表达式语法" class="headerlink" title="正则表达式语法"></a>正则表达式语法</h3><p>正则表达式（或 RE）指定了一组与之匹配的字符串；模块内的函数可以检查某个字符串是否与给定的正则表达式匹配（或者正则表达式是否匹配到字符串，这两种说法含义相同）。</p>
<p>正则表达式可以拼接；如果 <em>A</em> 和 <em>B</em> 都是正则表达式，则 <em>AB</em> 也是正则表达式。通常，如果字符串 <em>p</em> 匹配 <em>A</em>，并且另一个字符串 <em>q</em> 匹配 <em>B</em>，那么 <em>pq</em> 可以匹配 AB。除非 <em>A</em> 或者 <em>B</em> 包含低优先级操作，<em>A</em> 和 <em>B</em> 存在边界条件；或者命名组引用。所以，复杂表达式可以很容易的从这里描述的简单源语表达式构建。</p>
<p>正则表达式可以包含普通或者特殊字符。绝大部分普通字符，比如 <code>'A'</code>, <code>'a'</code>, 或者 <code>'0'</code>，都是最简单的正则表达式。它们就匹配自身。你可以拼接普通字符，所以 <code>last</code> 匹配字符串 <code>'last'</code>. （在这一节的其他部分，我们将用 <code>this special style</code> 这种方式表示正则表达式，通常不带引号，要匹配的字符串用 <code>'in single quotes'</code> ，单引号形式。）</p>
<p>有些字符，比如 <code>'|'</code> 或者 <code>'('</code>，属于特殊字符。 特殊字符既可以表示它的普通含义， 也可以影响它旁边的正则表达式的解释。</p>
<p>重复修饰符 (<code>*</code>, <code>+</code>, <code>?</code>, <code>{m,n}</code>, 等) 不能直接嵌套。这样避免了非贪婪后缀 <code>?</code> 修饰符，和其他实现中的修饰符产生的多义性。要应用一个内层重复嵌套，可以使用括号。 比如，表达式 <code>(?:a{6})*</code> 匹配6个 <code>'a'</code> 字符重复任意次数。</p>
<p>特殊字符有：</p>
<pre><code>.</code></pre><p>(点) 在默认模式，匹配除了换行的任意字符。如果指定了标签 <code>DOTALL</code> ，它将匹配包括换行符的任意字符。</p>
<pre><code>^</code></pre><p>(插入符号) 匹配字符串的开头， 并且在 <code>MULTILINE</code> 模式也匹配换行后的首个符号。</p>
<pre><code>$</code></pre><p>匹配字符串尾或者在字符串尾的换行符的前一个字符，在 <code>MULTILINE</code> 模式下也会匹配换行符之前的文本。 <code>foo</code> 匹配 ‘foo’ 和 ‘foobar’，但正则表达式 <code>foo$</code> 只匹配 ‘foo’。 更有趣的是，在 <code>'foo1\nfoo2\n'</code> 中搜索 <code>foo.$</code>，通常匹配 ‘foo2’，但在 <code>MULTILINE</code> 模式下可以匹配到 ‘foo1’；在 <code>'foo\n'</code> 中搜索 <code>$</code> 会找到两个（空的）匹配：一个在换行符之前，一个在字符串的末尾。</p>
<pre><code>*</code></pre><p>对它前面的正则式匹配0到任意次重复， 尽量多的匹配字符串。 <code>ab*</code> 会匹配 <code>'a'</code>，<code>'ab'</code>，或者 <code>'a'</code> 后面跟随任意个 <code>'b'</code>。</p>
<pre><code>+</code></pre><p>对它前面的正则式匹配1到任意次重复。 <code>ab+</code> 会匹配 <code>'a'</code> 后面跟随1个以上到任意个 <code>'b'</code>，它不会匹配 <code>'a'</code>。</p>
<pre><code>?</code></pre><p>对它前面的正则式匹配0到1次重复。 <code>ab?</code> 会匹配 <code>'a'</code> 或者 <code>'ab'</code>。</p>
<pre><code>*?, +?, ??</code></pre><p><code>'*'</code>, <code>'+'</code>，和 <code>'?'</code> 修饰符都是 <em>贪婪的*；它们在字符串进行尽可能多的匹配。有时候并不需要这种行为。如果正则式 `&lt;.</em>&gt;<code>希望找到</code>‘<a> b <c>‘<code>，它将会匹配整个字符串，而不仅是</code>‘</c></a><a>‘<code>。在修饰符之后添加</code>?<code>将使样式以 *非贪婪</code>方式或者 :dfn:<code>最小* 方式进行匹配； 尽量 *少* 的字符将会被匹配。 使用正则式</code>&lt;.*?&gt;<code>将会仅仅匹配</code>‘</a><a>‘`。</a></p><a>
<pre><code>{m}</code></pre><p>对其之前的正则式指定匹配 <em>m</em> 个重复；少于 <em>m</em> 的话就会导致匹配失败。比如， <code>a{6}</code> 将匹配6个 <code>'a'</code> , 但是不能是5个。</p>
<pre><code>{m,n}</code></pre><p>对正则式进行 <em>m</em> 到 <em>n</em> 次匹配，在 <em>m</em> 和 <em>n</em> 之间取尽量多。 比如，<code>a{3,5}</code> 将匹配 3 到 5个 <code>'a'</code>。忽略 <em>m</em> 意为指定下界为0，忽略 <em>n</em> 指定上界为无限次。 比如 <code>a{4,}b</code> 将匹配 <code>'aaaab'</code> 或者1000个 <code>'a'</code> 尾随一个 <code>'b'</code>，但不能匹配 <code>'aaab'</code>。逗号不能省略，否则无法辨别修饰符应该忽略哪个边界。</p>
<pre><code>{m,n}?</code></pre><p>前一个修饰符的非贪婪模式，只匹配尽量少的字符次数。比如，对于 <code>'aaaaaa'</code>， <code>a{3,5}</code> 匹配 5个 <code>'a'</code> ，而 <code>a{3,5}?</code> 只匹配3个 <code>'a'</code>。</p>
<pre><code>\</code></pre><p>转义特殊字符（允许你匹配 <code>'*'</code>, <code>'?'</code>, 或者此类其他），或者表示一个特殊序列；特殊序列之后进行讨论。</p>
<p>如果你没有使用原始字符串（ <code>r'raw'</code> ）来表达样式，要牢记Python也使用反斜杠作为转义序列；如果转义序列不被Python的分析器识别，反斜杠和字符才能出现在字符串中。如果Python可以识别这个序列，那么反斜杠就应该重复两次。这将导致理解障碍，所以高度推荐，就算是最简单的表达式，也要使用原始字符串。</p>
<pre><code>[]</code></pre><p>用于表示一个字符集合。在一个集合中：</p>
</a><ul><a>
<li>字符可以单独列出，比如 <code>[amk]</code> 匹配 <code>'a'</code>， <code>'m'</code>， 或者 <code>'k'</code>。</li>
<li>可以表示字符范围，通过用 <code>'-'</code> 将两个字符连起来。比如 <code>[a-z]</code> 将匹配任何小写ASCII字符， <code>[0-5][0-9]</code> 将匹配从 <code>00</code> 到 <code>59</code> 的两位数字， <code>[0-9A-Fa-f]</code> 将匹配任何十六进制数位。 如果 <code>-</code> 进行了转义 （比如 <code>[a\-z]</code>）或者它的位置在首位或者末尾（如 <code>[-a]</code> 或 <code>[a-]</code>），它就只表示普通字符 <code>'-'</code>。</li>
<li>特殊字符在集合中，失去它的特殊含义。比如 <code>[(+*)]</code> 只会匹配这几个文法字符 <code>'('</code>, <code>'+'</code>, <code>'*'</code>, or <code>')'</code>。</li>
<li>字符类如 <code>\w</code> 或者 <code>\S</code> (如下定义) 在集合内可以接受，它们可以匹配的字符由 <code>ASCII</code> 或者 <code>LOCALE</code> 模式决定。</li>
<li>不在集合范围内的字符可以通过 <em>取反</em> 来进行匹配。如果集合首字符是 <code>'^'</code> ，所有 <em>不</em> 在集合内的字符将会被匹配，比如 <code>[^5]</code> 将匹配所有字符，除了 <code>'5'</code>， <code>[^^]</code> 将匹配所有字符，除了 <code>'^'</code>. <code>^</code> 如果不在集合首位，就没有特殊含义。</li>
<li>在集合内要匹配一个字符 <code>']'</code>，有两种方法，要么就在它之前加上反斜杠，要么就把它放到集合首位。比如， <code>[()[\]{}]</code> 和 <code>[]()[{}]</code> 都可以匹配括号。</li>
</a><li><a></a><a href="https://unicode.org/reports/tr18/" target="_blank" rel="noopener">Unicode Technical Standard #18</a> 里的嵌套集合和集合操作支持可能在未来添加。这将会改变语法，所以为了帮助这个改变，一个 <code>FutureWarning</code> 将会在有多义的情况里被 <code>raise</code>，包含以下几种情况，集合由 <code>'['</code> 开始，或者包含下列字符序列 <code>'--'</code>, <code>'&amp;&amp;'</code>, <code>'~~'</code>, 和 <code>'||'</code>。为了避免警告，需要将它们用反斜杠转义。</li>
</ul>
<p>在 3.7 版更改: 如果一个字符串构建的语义在未来会改变的话，一个 <code>FutureWarning</code> 会 <code>raise</code> 。</p>
<pre><code>|</code></pre><p><code>A|B</code>， <em>A</em> 和 <em>B</em> 可以是任意正则表达式，创建一个正则表达式，匹配 <em>A</em> 或者 <em>B</em>. 任意个正则表达式可以用 <code>'|'</code> 连接。它也可以在组合（见下列）内使用。扫描目标字符串时， <code>'|'</code> 分隔开的正则样式从左到右进行匹配。当一个样式完全匹配时，这个分支就被接受。意思就是，一旦 <em>A</em> 匹配成功， <em>B</em> 就不再进行匹配，即便它能产生一个更好的匹配。或者说，<code>'|'</code> 操作符绝不贪婪。 如果要匹配 <code>'|'</code> 字符，使用 <code>\|</code>， 或者把它包含在字符集里，比如 <code>[|]</code>.</p>
<pre><code>(...)</code></pre><p>（组合），匹配括号内的任意正则表达式，并标识出组合的开始和结尾。匹配完成后，组合的内容可以被获取，并可以在之后用 <code>\number</code> 转义序列进行再次匹配，之后进行详细说明。要匹配字符 <code>'('</code> 或者 <code>')'</code>, 用 <code>\(</code> 或 <code>\)</code>, 或者把它们包含在字符集合里: <code>[(]</code>, <code>[)]</code>.</p>
<pre><code>(?…)</code></pre><p>这是个扩展标记法 （一个 <code>'?'</code> 跟随 <code>'('</code> 并无含义）。 <code>'?'</code> 后面的第一个字符决定了这个构建采用什么样的语法。这种扩展通常并不创建新的组合； <code>(?P&lt;name&gt;...)</code> 是唯一的例外。 以下是目前支持的扩展。</p>
<pre><code>(?aiLmsux)</code></pre><p>( <code>'a'</code>, <code>'i'</code>, <code>'L'</code>, <code>'m'</code>, <code>'s'</code>, <code>'u'</code>, <code>'x'</code> 中的一个或多个) 这个组合匹配一个空字符串；这些字符对正则表达式设置以下标记 <code>re.A</code> (只匹配ASCII字符), <code>re.I</code> (忽略大小写), <code>re.L</code> (语言依赖), <code>re.M</code> (多行模式), <code>re.S</code> (点dot匹配全部字符), <code>re.U</code> (Unicode匹配), and <code>re.X</code> (冗长模式)。 如果你想将这些标记包含在正则表达式中，这个方法就很有用，免去了在 <code>re.compile()</code> 中传递 <em>flag</em> 参数。标记应该在表达式字符串首位表示。</p>
<pre><code>(?:…)</code></pre><p>正则括号的非捕获版本。 匹配在括号内的任何正则表达式，但该分组所匹配的子字符串 <em>不能</em> 在执行匹配后被获取或是之后在模式中被引用。</p>
<pre><code>(?aiLmsux-imsx:…)</code></pre><p>(<code>'a'</code>, <code>'i'</code>, <code>'L'</code>, <code>'m'</code>, <code>'s'</code>, <code>'u'</code>, <code>'x'</code> 中的0或者多个， 之后可选跟随 <code>'-'</code> 在后面跟随 <code>'i'</code> , <code>'m'</code> , <code>'s'</code> , <code>'x'</code> 中的一到多个 .) 这些字符为表达式的其中一部分 <em>设置</em> 或者 <em>去除</em> 相应标记 <code>re.A</code> (只匹配ASCII), <code>re.I</code> (忽略大小写), <code>re.L</code> (语言依赖), <code>re.M</code> (多行), <code>re.S</code> (点匹配所有字符), <code>re.U</code> (Unicode匹配), and <code>re.X</code> (冗长模式)。</p>
<p><code>'a'</code>, <code>'L'</code> and <code>'u'</code> 作为内联标记是相互排斥的， 所以它们不能结合在一起，或者跟随 <code>'-'</code> 。 当他们中的某个出现在内联组中，它就覆盖了括号组内的匹配模式。在Unicode样式中， <code>(?a:...)</code> 切换为 只匹配ASCII， <code>(?u:...)</code> 切换为Unicode匹配 (默认). 在byte样式中 <code>(?L:...)</code> 切换为语言依赖模式， <code>(?a:...)</code> 切换为 只匹配ASCII (默认)。这种方式只覆盖组合内匹配，括号外的匹配模式不受影响。</p>
<p>3.6 新版功能.</p>
<p>在 3.7 版更改: 符号 <code>'a'</code>, <code>'L'</code> 和 <code>'u'</code> 同样可以用在一个组合内。</p>
<pre><code>(?P&lt;name&gt;…)</code></pre><p>（命名组合）类似正则组合，但是匹配到的子串组在外部是通过定义的 <em>name</em> 来获取的。组合名必须是有效的Python标识符，并且每个组合名只能用一个正则表达式定义，只能定义一次。一个符号组合同样是一个数字组合，就像这个组合没有被命名一样。</p>
<p>命名组合可以在三种上下文中引用。如果样式是 <code>(?P&lt;quote&gt;['"]).*?(?P=quote)</code> （也就是说，匹配单引号或者双引号括起来的字符串)：</p>
<table>
<thead>
<tr>
<th align="left">引用组合 “quote” 的上下文</th>
<th align="left">引用方法</th>
</tr>
</thead>
<tbody><tr>
<td align="left">在正则式自身内</td>
<td align="left"><code>(?P=quote)</code> (如示) <code>\1</code></td>
</tr>
<tr>
<td align="left">处理匹配对象 <em>m</em></td>
<td align="left"><code>m.group(‘quote’)</code> <code>m.end(‘quote’)</code> (等)</td>
</tr>
<tr>
<td align="left">传递到 <code>re.sub()</code> 里的 <em>repl</em> 参数中</td>
<td align="left"><code>\g&lt;quote&gt;</code> <code>\g&lt;1&gt;</code> <code>\1</code></td>
</tr>
</tbody></table>
<pre><code>(?P=name)</code></pre><p>反向引用一个命名组合；它匹配前面那个叫 <em>name</em> 的命名组中匹配到的串同样的字串。</p>
<pre><code>(?#…)</code></pre><p>注释；里面的内容会被忽略。</p>
<pre><code>(?=…)</code></pre><p>匹配 <code>…</code> 的内容，但是并不消费样式的内容。这个叫做 <em>lookahead assertion</em>。比如， <code>Isaac (?=Asimov)</code> 匹配 <code>'Isaac '</code> 只有在后面是 <code>'Asimov'</code> 的时候。</p>
<pre><code>(?!…)</code></pre><p>匹配 <code>…</code> 不符合的情况。这个叫 <em>negative lookahead assertion</em> （前视取反）。比如说， <code>Isaac (?!Asimov)</code> 只有后面 <em>不</em> 是 <code>'Asimov'</code> 的时候才匹配 <code>'Isaac '</code> 。</p>
<pre><code>(?&lt;=…)</code></pre><p>匹配字符串的当前位置，它的前面匹配 <code>...</code> 的内容到当前位置。这叫 <em>positive lookbehind assertion</em> （正向后视断定）。 <code>(?&lt;=abc)def</code> 会在 <code>'abcdef'</code> 中找到一个匹配，因为后视会往后看3个字符并检查是否包含匹配的样式。包含的匹配样式必须是定长的，意思就是 <code>abc</code> 或 <code>a|b</code> 是允许的，但是 <code>a*</code> 和 <code>a{3,4}</code> 不可以。注意以 positive lookbehind assertions 开始的样式，如 <code>(?&lt;=abc)def</code> ，并不是从 a 开始搜索，而是从 d 往回看的。你可能更加愿意使用 <code>search()</code> 函数，而不是 <code>match()</code> 函数：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> re
<span class="token operator">>></span><span class="token operator">></span> m <span class="token operator">=</span> re<span class="token punctuation">.</span>search<span class="token punctuation">(</span><span class="token string">'(?&lt;=abc)def'</span><span class="token punctuation">,</span> <span class="token string">'abcdef'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> m<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
<span class="token string">'def'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>这个例子搜索一个跟随在连字符后的单词：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> m <span class="token operator">=</span> re<span class="token punctuation">.</span>search<span class="token punctuation">(</span>r<span class="token string">'(?&lt;=-)\w+'</span><span class="token punctuation">,</span> <span class="token string">'spam-egg'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> m<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
<span class="token string">'egg'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>在 3.5 版更改: 添加定长组合引用的支持。</p>
<pre><code>(?&lt;!…)</code></pre><p>匹配当前位置之前不是 <code>...</code> 的样式。这个叫 <em>negative lookbehind assertion</em> （后视断定取非）。类似正向后视断定，包含的样式匹配必须是定长的。由 negative lookbehind assertion 开始的样式可以从字符串搜索开始的位置进行匹配。</p>
<pre><code>(?(id/name)yes-pattern|no-pattern)</code></pre><p>如果给定的 <em>id</em> 或 <em>name</em> 存在，将会尝试匹配 <code>yes-pattern</code> ，否则就尝试匹配 <code>no-pattern</code>，<code>no-pattern</code> 可选，也可以被忽略。比如， <code>(&lt;)?(\w+@\w+(?:\.\w+)+)(?(1)&gt;|$)</code> 是一个email样式匹配，将匹配 <code>'&lt;user@host.com&gt;'</code> 或 <code>'user@host.com'</code> ，但不会匹配 <code>'&lt;user@host.com'</code> ，也不会匹配 <code>'user@host.com&gt;'</code>。</p>
<p>由 <code>'\'</code> 和一个字符组成的特殊序列在以下列出。 如果普通字符不是ASCII数位或者ASCII字母，那么正则样式将匹配第二个字符。比如，<code>\$</code> 匹配字符 <code>'$'</code>.</p>
<pre><code>\number</code></pre><p>匹配数字代表的组合。每个括号是一个组合，组合从1开始编号。比如 <code>(.+) \1</code> 匹配 <code>'the the'</code> 或者 <code>'55 55'</code>, 但不会匹配 <code>'thethe'</code> (注意组合后面的空格)。这个特殊序列只能用于匹配前面99个组合。如果 <em>number</em> 的第一个数位是0， 或者 <em>number</em> 是三个八进制数，它将不会被看作是一个组合，而是八进制的数字值。在 <code>'['</code> 和 <code>']'</code> 字符集合内，任何数字转义都被看作是字符。</p>
<pre><code>\A</code></pre><p>只匹配字符串开始。</p>
<pre><code>\b</code></pre><p>匹配空字符串，但只在单词开始或结尾的位置。一个单词被定义为一个单词字符的序列。注意，通常 <code>\b</code> 定义为 <code>\w</code> 和 <code>\W</code> 字符之间，或者 <code>\w</code> 和字符串开始/结尾的边界， 意思就是 <code>r'\bfoo\b'</code> 匹配 <code>'foo'</code>, <code>'foo.'</code>, <code>'(foo)'</code>, <code>'bar foo baz'</code> 但不匹配 <code>'foobar'</code> 或者 <code>'foo3'</code>。</p>
<p>默认情况下，Unicode字母和数字是在Unicode样式中使用的，但是可以用 <code>ASCII</code> 标记来更改。如果 <code>LOCALE</code> 标记被设置的话，词的边界是由当前语言区域设置决定的，<code>\b</code> 表示退格字符，以便与Python字符串文本兼容。</p>
<pre><code>\B</code></pre><p>匹配空字符串，但 <em>不</em> 能在词的开头或者结尾。意思就是 <code>r'py\B'</code> 匹配 <code>'python'</code>, <code>'py3'</code>, <code>'py2'</code>, 但不匹配 <code>'py'</code>, <code>'py.'</code>, 或者 <code>'py!'</code>. <code>\B</code> 是 <code>\b</code> 的取非，所以Unicode样式的词语是由Unicode字母，数字或下划线构成的，虽然可以用 <code>ASCII</code> 标志来改变。如果使用了 <code>LOCALE</code> 标志，则词的边界由当前语言区域设置。</p>
<pre><code>\d</code></pre><ul>
<li><p>对于 Unicode (str) 样式：</p>
<p>匹配任何Unicode十进制数（就是在Unicode字符目录[Nd]里的字符）。这包括了 <code>[0-9]</code> ，和很多其他的数字字符。如果设置了 <code>ASCII</code> 标志，就只匹配 <code>[0-9]</code> 。</p>
<p>对于8位(bytes)样式：</p>
<p>匹配任何十进制数，就是 <code>[0-9]</code>。</p>
</li>
</ul>
<pre><code>\D</code></pre><p>匹配任何非十进制数字的字符。就是 <code>\d</code> 取非。 如果设置了 <code>ASCII</code> 标志，就相当于 <code>[^0-9]</code> 。</p>
<pre><code>\s</code></pre><ul>
<li><p>对于 Unicode (str) 样式：</p>
<p>匹配任何Unicode空白字符（包括 <code>[ \t\n\r\f\v]</code> ，还有很多其他字符，比如不同语言排版规则约定的不换行空格）。如果 <code>ASCII</code> 被设置，就只匹配 <code>[ \t\n\r\f\v]</code> 。</p>
<p>对于8位(bytes)样式：</p>
<p>匹配ASCII中的空白字符，就是 <code>[ \t\n\r\f\v]</code> 。</p>
</li>
</ul>
<pre><code>\S</code></pre><p>匹配任何非空白字符。就是 <code>\s</code> 取非。如果设置了 <code>ASCII</code> 标志，就相当于 <code>[^ \t\n\r\f\v]</code> 。</p>
<pre><code>\w</code></pre><ul>
<li><p>对于 Unicode (str) 样式：</p>
<p>匹配Unicode词语的字符，包含了可以构成词语的绝大部分字符，也包括数字和下划线。如果设置了 <code>ASCII</code> 标志，就只匹配 <code>[a-zA-Z0-9_]</code> 。</p>
<p>对于8位(bytes)样式：</p>
<p>匹配ASCII字符中的数字和字母和下划线，就是 <code>[a-zA-Z0-9_]</code> 。如果设置了 <code>LOCALE</code> 标记，就匹配当前语言区域的数字和字母和下划线。</p>
</li>
</ul>
<pre><code>\W</code></pre><p>匹配非单词字符的字符。这与 <code>\w</code> 正相反。如果使用了 <code>ASCII</code> 旗标，这就等价于 <code>[^a-zA-Z0-9_]</code>。如果使用了 <code>LOCALE</code> 旗标，则会匹配当前区域中既非字母数字也非下划线的字符。</p>
<pre><code>\Z</code></pre><p>只匹配字符串尾。</p>
<p>绝大部分Python的标准转义字符也被正则表达式分析器支持。:</p>
<pre><code>\a      \b      \f      \n\N      \r      \t      \u\U      \v      \x      \\</code></pre><p>（注意 <code>\b</code> 被用于表示词语的边界，它只在字符集合内表示退格，比如 <code>[\b]</code> 。）</p>
<p><code>'\u'</code>, <code>'\U'</code> 和 <code>'\N'</code> 转义序列只在 Unicode 模式中可被识别。 在 bytes 模式中它们会导致错误。 未知的 ASCII 字母转义序列保留在未来使用，会被当作错误来处理。</p>
<p>八进制转义包含为一个有限形式。如果首位数字是 0， 或者有三个八进制数位，那么就认为它是八进制转义。其他的情况，就看作是组引用。对于字符串文本，八进制转义最多有三个数位长。</p>
<p>在 3.3 版更改: 增加了 <code>'\u'</code> 和 <code>'\U'</code> 转义序列。</p>
<p>在 3.6 版更改: 由 <code>'\'</code> 和一个ASCII字符组成的未知转义会被看成错误。</p>
<p>在 3.8 版更改: 添加了 <code>'\N{name}'</code> 转义序列。 与在字符串字面值中一样，它扩展了命名 Unicode 字符 (例如 <code>'\N{EM DASH}'</code>)。</p>
<h3 id="模块内容"><a href="#模块内容" class="headerlink" title="模块内容"></a>模块内容</h3><p>模块定义了几个函数、常量，和一个异常。有些函数是编译后的正则表达式方法的简化版本（少了一些特性）。重要的应用程序大多会在使用前先编译正则表达式。</p>
<p>在 3.6 版更改: 标志常量现在是 <code>RegexFlag</code> 类的实例，这个类是 <code>enum.IntFlag</code> 的子类。</p>
<p><code>re.compile</code>(<em>pattern</em>, <em>flags=0</em>)</p>
<p>将正则表达式的样式编译为一个 正则表达式对象 （正则对象），可以用于匹配，通过这个对象的方法 <code>match()</code>, <code>search()</code> 以及其他如下描述。</p>
<p>这个表达式的行为可以通过指定 <em>标记</em> 的值来改变。值可以是以下任意变量，可以通过位的OR操作来结合（ <code>|</code> 操作符）。</p>
<p>序列</p>
<pre class="line-numbers language-python"><code class="language-python">prog <span class="token operator">=</span> re<span class="token punctuation">.</span>compile<span class="token punctuation">(</span>pattern<span class="token punctuation">)</span>
result <span class="token operator">=</span> prog<span class="token punctuation">.</span>match<span class="token punctuation">(</span>string<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>等价于</p>
<pre class="line-numbers language-python"><code class="language-python">result <span class="token operator">=</span> re<span class="token punctuation">.</span>match<span class="token punctuation">(</span>pattern<span class="token punctuation">,</span> string<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>如果需要多次使用这个正则表达式的话，使用 <code>re.compile()</code> 和保存这个正则对象以便复用，可以让程序更加高效。</p>
<p>注解</p>
<p>通过 <code>re.compile()</code> 编译后的样式，和模块级的函数会被缓存， 所以少数的正则表达式使用无需考虑编译的问题。</p>
<pre><code>re.A
re.ASCII</code></pre><p>让 <code>\w</code>, <code>\W</code>, <code>\b</code>, <code>\B</code>, <code>\d</code>, <code>\D</code>, <code>\s</code> 和 <code>\S</code> 只匹配ASCII，而不是Unicode。这只对Unicode样式有效，会被byte样式忽略。相当于前面语法中的内联标志 <code>(?a)</code> 。</p>
<p>注意，为了保持向后兼容， <code>re.U</code> 标记依然存在（还有他的同义 <code>re.UNICODE</code> 和嵌入形式 <code>(?u)</code> ) ， 但是这些在 Python 3 是冗余的，因为默认字符串已经是Unicode了（并且Unicode匹配不允许byte出现)。</p>
<pre><code>re.DEBUG</code></pre><p>显示编译时的debug信息，没有内联标记。</p>
<pre><code>re.I
re.IGNORECASE</code></pre><p>进行忽略大小写匹配；表达式如 <code>[A-Z]</code> 也会匹配小写字符。Unicode匹配（比如 <code>Ü</code> 匹配 <code>ü</code>）同样有用，除非设置了 <code>re.ASCII</code> 标记来禁用非ASCII匹配。当前语言区域不会改变这个标记，除非设置了 <code>re.LOCALE</code> 标记。这个相当于内联标记 <code>(?i)</code> 。</p>
<p>注意，当设置了 <code>IGNORECASE</code> 标记，搜索Unicode样式 <code>[a-z]</code> 或 <code>[A-Z]</code> 的结合时，它将会匹配52个ASCII字符和4个额外的非ASCII字符： ‘İ’ (U+0130, 拉丁大写的 I 带个点在上面), ‘ı’ (U+0131, 拉丁小写没有点的 I ), ‘ſ’ (U+017F, 拉丁小写长 s) and ‘K’ (U+212A, 开尔文符号).如果使用 <code>ASCII</code> 标记，就只匹配 ‘a’ 到 ‘z’ 和 ‘A’ 到 ‘Z’ 。</p>
<pre><code>re.L
re.LOCALE</code></pre><p>由当前语言区域决定 <code>\w</code>, <code>\W</code>, <code>\b</code>, <code>\B</code> 和大小写敏感匹配。这个标记只能对byte样式有效。这个标记不推荐使用，因为语言区域机制很不可靠，它一次只能处理一个 “习惯”，而且只对8位字节有效。Unicode匹配在Python 3 里默认启用，并可以处理不同语言。 这个对应内联标记 <code>(?L)</code> 。</p>
<p>在 3.6 版更改: <code>re.LOCALE</code> 只能用于byte样式，而且不能和 <code>re.ASCII</code> 一起用。</p>
<p>在 3.7 版更改: 设置了 <code>re.LOCALE</code> 标记的编译正则对象不再在编译时依赖语言区域设置。语言区域设置只在匹配的时候影响其结果。</p>
<pre><code>re.M
re.MULTILINE</code></pre><p>设置以后，样式字符 <code>'^'</code> 匹配字符串的开始，和每一行的开始（换行符后面紧跟的符号）；样式字符 <code>'$'</code> 匹配字符串尾，和每一行的结尾（换行符前面那个符号）。默认情况下，<code>’^’</code> 匹配字符串头，<code>'$'</code> 匹配字符串尾。对应内联标记 <code>(?m)</code> 。</p>
<pre><code>re.S
re.DOTALL</code></pre><p>让 <code>'.'</code> 特殊字符匹配任何字符，包括换行符；如果没有这个标记，<code>'.'</code> 就匹配 <em>除了</em> 换行符的其他任意字符。对应内联标记 <code>(?s)</code> 。</p>
<pre><code>re.X
re.VERBOSE</code></pre><p>这个标记允许你编写更具可读性更友好的正则表达式。通过分段和添加注释。空白符号会被忽略，除非在一个字符集合当中或者由反斜杠转义，或者在 <code>*?</code>, <code>(?:</code> or <code>(?P&lt;…&gt;</code> 分组之内。当一个行内有 <code>#</code> 不在字符集和转义序列，那么它之后的所有字符都是注释。</p>
<p>意思就是下面两个正则表达式等价地匹配一个十进制数字：</p>
<pre class="line-numbers language-python"><code class="language-python">a <span class="token operator">=</span> re<span class="token punctuation">.</span>compile<span class="token punctuation">(</span>r<span class="token triple-quoted-string string">"""\d +  # the integral part
                   \.    # the decimal point
                   \d *  # some fractional digits"""</span><span class="token punctuation">,</span> re<span class="token punctuation">.</span>X<span class="token punctuation">)</span>
b <span class="token operator">=</span> re<span class="token punctuation">.</span>compile<span class="token punctuation">(</span>r<span class="token string">"\d+\.\d*"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>对应内联标记 <code>(?x)</code> 。</p>
<p><code>re.search</code>(<em>pattern</em>, <em>string</em>, <em>flags=0</em>)</p>
<p>扫描整个 <em>字符串</em> 找到匹配样式的第一个位置，并返回一个相应的 匹配对象。如果没有匹配，就返回一个 <code>None</code> ； 注意这和找到一个零长度匹配是不同的。</p>
<p><code>re.match</code>(<em>pattern</em>, <em>string</em>, <em>flags=0</em>)</p>
<p>如果 <em>string</em> 开始的0或者多个字符匹配到了正则表达式样式，就返回一个相应的 匹配对象 。 如果没有匹配，就返回 <code>None</code> ；注意它跟零长度匹配是不同的。</p>
<p>注意即便是 <code>MULTILINE</code> 多行模式， <code>re.match()</code> 也只匹配字符串的开始位置，而不匹配每行开始。</p>
<p>如果你想定位 <em>string</em> 的任何位置，使用 <code>search()</code> 来替代</p>
<p><code>re.fullmatch</code>(<em>pattern</em>, <em>string</em>, <em>flags=0</em>)</p>
<p>如果整个 <em>string</em> 匹配到正则表达式样式，就返回一个相应的 匹配对象 。 否则就返回一个 <code>None</code> ；注意这跟零长度匹配是不同的。</p>
<p>3.4 新版功能.</p>
<p><code>re.split</code>(<em>pattern</em>, <em>string</em>, <em>maxsplit=0</em>, <em>flags=0</em>)</p>
<p>用 <em>pattern</em> 分开 <em>string</em> 。 如果在 <em>pattern</em> 中捕获到括号，那么所有的组里的文字也会包含在列表里。如果 <em>maxsplit</em> 非零， 最多进行 <em>maxsplit</em> 次分隔， 剩下的字符全部返回到列表的最后一个元素。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> re<span class="token punctuation">.</span>split<span class="token punctuation">(</span>r<span class="token string">'\W+'</span><span class="token punctuation">,</span> <span class="token string">'Words, words, words.'</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token string">'Words'</span><span class="token punctuation">,</span> <span class="token string">'words'</span><span class="token punctuation">,</span> <span class="token string">'words'</span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> re<span class="token punctuation">.</span>split<span class="token punctuation">(</span>r<span class="token string">'(\W+)'</span><span class="token punctuation">,</span> <span class="token string">'Words, words, words.'</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token string">'Words'</span><span class="token punctuation">,</span> <span class="token string">', '</span><span class="token punctuation">,</span> <span class="token string">'words'</span><span class="token punctuation">,</span> <span class="token string">', '</span><span class="token punctuation">,</span> <span class="token string">'words'</span><span class="token punctuation">,</span> <span class="token string">'.'</span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> re<span class="token punctuation">.</span>split<span class="token punctuation">(</span>r<span class="token string">'\W+'</span><span class="token punctuation">,</span> <span class="token string">'Words, words, words.'</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token string">'Words'</span><span class="token punctuation">,</span> <span class="token string">'words, words.'</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> re<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">'[a-f]+'</span><span class="token punctuation">,</span> <span class="token string">'0a3B9'</span><span class="token punctuation">,</span> flags<span class="token operator">=</span>re<span class="token punctuation">.</span>IGNORECASE<span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token string">'0'</span><span class="token punctuation">,</span> <span class="token string">'3'</span><span class="token punctuation">,</span> <span class="token string">'9'</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果分隔符里有捕获组合，并且匹配到字符串的开始，那么结果将会以一个空字符串开始。对于结尾也是一样</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> re<span class="token punctuation">.</span>split<span class="token punctuation">(</span>r<span class="token string">'(\W+)'</span><span class="token punctuation">,</span> <span class="token string">'...words, words...'</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token string">''</span><span class="token punctuation">,</span> <span class="token string">'...'</span><span class="token punctuation">,</span> <span class="token string">'words'</span><span class="token punctuation">,</span> <span class="token string">', '</span><span class="token punctuation">,</span> <span class="token string">'words'</span><span class="token punctuation">,</span> <span class="token string">'...'</span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>这样的话，分隔组将会出现在结果列表中同样的位置。</p>
<p>样式的空匹配仅在与前一个空匹配不相邻时才会拆分字符串。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> re<span class="token punctuation">.</span>split<span class="token punctuation">(</span>r<span class="token string">'\b'</span><span class="token punctuation">,</span> <span class="token string">'Words, words, words.'</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token string">''</span><span class="token punctuation">,</span> <span class="token string">'Words'</span><span class="token punctuation">,</span> <span class="token string">', '</span><span class="token punctuation">,</span> <span class="token string">'words'</span><span class="token punctuation">,</span> <span class="token string">', '</span><span class="token punctuation">,</span> <span class="token string">'words'</span><span class="token punctuation">,</span> <span class="token string">'.'</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> re<span class="token punctuation">.</span>split<span class="token punctuation">(</span>r<span class="token string">'\W*'</span><span class="token punctuation">,</span> <span class="token string">'...words...'</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token string">''</span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">,</span> <span class="token string">'w'</span><span class="token punctuation">,</span> <span class="token string">'o'</span><span class="token punctuation">,</span> <span class="token string">'r'</span><span class="token punctuation">,</span> <span class="token string">'d'</span><span class="token punctuation">,</span> <span class="token string">'s'</span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> re<span class="token punctuation">.</span>split<span class="token punctuation">(</span>r<span class="token string">'(\W*)'</span><span class="token punctuation">,</span> <span class="token string">'...words...'</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token string">''</span><span class="token punctuation">,</span> <span class="token string">'...'</span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">,</span> <span class="token string">'w'</span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">,</span> <span class="token string">'o'</span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">,</span> <span class="token string">'r'</span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">,</span> <span class="token string">'d'</span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">,</span> <span class="token string">'s'</span><span class="token punctuation">,</span> <span class="token string">'...'</span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在 3.1 版更改: 增加了可选标记参数。</p>
<p>在 3.7 版更改: 增加了空字符串的样式分隔。</p>
<p><code>re.findall</code>(<em>pattern</em>, <em>string</em>, <em>flags=0</em>)</p>
<p>Return all non-overlapping matches of <em>pattern</em> in <em>string</em>, as a list of strings or tuples. The <em>string</em> is scanned left-to-right, and matches are returned in the order found. Empty matches are included in the result.</p>
<p>The result depends on the number of capturing groups in the pattern. If there are no groups, return a list of strings matching the whole pattern. If there is exactly one group, return a list of strings matching that group. If multiple groups are present, return a list of tuples of strings matching the groups. Non-capturing groups do not affect the form of the result.</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> re<span class="token punctuation">.</span>findall<span class="token punctuation">(</span>r<span class="token string">'\bf[a-z]*'</span><span class="token punctuation">,</span> <span class="token string">'which foot or hand fell fastest'</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token string">'foot'</span><span class="token punctuation">,</span> <span class="token string">'fell'</span><span class="token punctuation">,</span> <span class="token string">'fastest'</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> re<span class="token punctuation">.</span>findall<span class="token punctuation">(</span>r<span class="token string">'(\w+)=(\d+)'</span><span class="token punctuation">,</span> <span class="token string">'set width=20 and height=10'</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token string">'width'</span><span class="token punctuation">,</span> <span class="token string">'20'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'height'</span><span class="token punctuation">,</span> <span class="token string">'10'</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>在 3.7 版更改: 非空匹配现在可以在前一个空匹配之后出现了。</p>
<p><code>re.finditer</code>(<em>pattern</em>, <em>string</em>, <em>flags=0</em>)</p>
<p><em>pattern</em> 在 <em>string</em> 里所有的非重复匹配，返回为一个迭代器 iterator 保存了 匹配对象 。 <em>string</em> 从左到右扫描，匹配按顺序排列。空匹配也包含在结果里。</p>
<p>在 3.7 版更改: 非空匹配现在可以在前一个空匹配之后出现了。</p>
<p><code>re.sub</code>(<em>pattern</em>, <em>repl</em>, <em>string</em>, <em>count=0</em>, <em>flags=0</em>)</p>
<p>返回通过使用 <em>repl</em> 替换在 <em>string</em> 最左边非重叠出现的 <em>pattern</em> 而获得的字符串。 如果样式没有找到，则不加改变地返回 <em>string*。 *repl</em> 可以是字符串或函数；如为字符串，则其中任何反斜杠转义序列都会被处理。 也就是说，<code>\n</code> 会被转换为一个换行符，<code>\r</code> 会被转换为一个回车符，依此类推。 未知的 ASCII 字符转义序列保留在未来使用，会被当作错误来处理。 其他未知转义序列例如 <code>\&amp;</code> 会保持原样。 向后引用像是 <code>\6</code> 会用样式中第 6 组所匹配到的子字符串来替换。 例如:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> re<span class="token punctuation">.</span>sub<span class="token punctuation">(</span>r<span class="token string">'def\s+([a-zA-Z_][a-zA-Z_0-9]*)\s*\(\s*\):'</span><span class="token punctuation">,</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        r<span class="token string">'static PyObject*\npy_\1(void)\n{'</span><span class="token punctuation">,</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token string">'def myfunc():'</span><span class="token punctuation">)</span>
<span class="token string">'static PyObject*\npy_myfunc(void)\n{'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果 <em>repl</em> 是一个函数，那它会对每个非重复的 <em>pattern</em> 的情况调用。这个函数只能有一个 匹配对象 参数，并返回一个替换后的字符串。比如</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">def</span> <span class="token function">dashrepl</span><span class="token punctuation">(</span>matchobj<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">if</span> matchobj<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">'-'</span><span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token string">' '</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">else</span><span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token string">'-'</span>
<span class="token operator">>></span><span class="token operator">></span> re<span class="token punctuation">.</span>sub<span class="token punctuation">(</span><span class="token string">'-{1,2}'</span><span class="token punctuation">,</span> dashrepl<span class="token punctuation">,</span> <span class="token string">'pro----gram-files'</span><span class="token punctuation">)</span>
<span class="token string">'pro--gram files'</span>
<span class="token operator">>></span><span class="token operator">></span> re<span class="token punctuation">.</span>sub<span class="token punctuation">(</span>r<span class="token string">'\sAND\s'</span><span class="token punctuation">,</span> <span class="token string">' &amp; '</span><span class="token punctuation">,</span> <span class="token string">'Baked Beans And Spam'</span><span class="token punctuation">,</span> flags<span class="token operator">=</span>re<span class="token punctuation">.</span>IGNORECASE<span class="token punctuation">)</span>
<span class="token string">'Baked Beans &amp; Spam'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>样式可以是一个字符串或者一个 样式对象 。</p>
<p>可选参数 <em>count</em> 是要替换的最大次数；<em>count</em> 必须是非负整数。如果省略这个参数或设为 0，所有的匹配都会被替换。 样式的空匹配仅在与前一个空匹配不相邻时才会被替换，所以 <code>sub('x*', '-', 'abxd')</code> 返回 <code>'-a-b--d-'</code> 。</p>
<p>在字符串类型的 <em>repl</em> 参数里，如上所述的转义和向后引用中，<code>\g&lt;name&gt;</code> 会使用命名组合 <code>name</code>，（在 <code>(?P&lt;name&gt;…)</code> 语法中定义） <code>\g&lt;number&gt;</code> 会使用数字组；<code>\g&lt;2&gt;</code> 就是 <code>\2</code>，但它避免了二义性，如 <code>\g&lt;2&gt;0</code>。 <code>\20</code> 就会被解释为组20，而不是组2后面跟随一个字符 <code>'0'</code>。向后引用 <code>\g&lt;0&gt;</code> 把 <em>pattern</em> 作为一整个组进行引用。</p>
<p>在 3.1 版更改: 增加了可选标记参数。</p>
<p>在 3.5 版更改: 不匹配的组合替换为空字符串。</p>
<p>在 3.6 版更改: <em>pattern</em> 中的未知转义（由 <code>'\'</code> 和一个 ASCII 字符组成）被视为错误。</p>
<p>在 3.7 版更改: <em>repl</em> 中的未知转义（由 <code>'\'</code> 和一个 ASCII 字符组成）被视为错误。</p>
<p>在 3.7 版更改: 样式中的空匹配相邻接时会被替换。</p>
<p><code>re.subn</code>(<em>pattern</em>, <em>repl</em>, <em>string</em>, <em>count=0</em>, <em>flags=0</em>)</p>
<p>行为与 <code>sub()</code> 相同，但是返回一个元组 <code>(字符串, 替换次数)</code>.</p>
<p>在 3.1 版更改: 增加了可选标记参数。</p>
<p>在 3.5 版更改: 不匹配的组合替换为空字符串。</p>
<p><code>re.escape</code>(<em>pattern</em>)</p>
<p>转义 <em>pattern</em> 中的特殊字符。如果你想对任意可能包含正则表达式元字符的文本字符串进行匹配，它就是有用的。比如</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>re<span class="token punctuation">.</span>escape<span class="token punctuation">(</span><span class="token string">'https://www.python.org'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
https<span class="token punctuation">:</span><span class="token operator">//</span>www\<span class="token punctuation">.</span>python\<span class="token punctuation">.</span>org
<span class="token operator">>></span><span class="token operator">></span> legal_chars <span class="token operator">=</span> string<span class="token punctuation">.</span>ascii_lowercase <span class="token operator">+</span> string<span class="token punctuation">.</span>digits <span class="token operator">+</span> <span class="token string">"!#$%&amp;'*+-.^_`|~:"</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'[%s]+'</span> <span class="token operator">%</span> re<span class="token punctuation">.</span>escape<span class="token punctuation">(</span>legal_chars<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span>abcdefghijklmnopqrstuvwxyz0123456789!\#\$<span class="token operator">%</span>\<span class="token operator">&amp;</span>'\<span class="token operator">*</span>\<span class="token operator">+</span>\<span class="token operator">-</span>\<span class="token punctuation">.</span>\<span class="token operator">^</span>_`\<span class="token operator">|</span>\<span class="token operator">~</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token operator">+</span>
<span class="token operator">>></span><span class="token operator">></span> operators <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'+'</span><span class="token punctuation">,</span> <span class="token string">'-'</span><span class="token punctuation">,</span> <span class="token string">'*'</span><span class="token punctuation">,</span> <span class="token string">'/'</span><span class="token punctuation">,</span> <span class="token string">'**'</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'|'</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>map<span class="token punctuation">(</span>re<span class="token punctuation">.</span>escape<span class="token punctuation">,</span> sorted<span class="token punctuation">(</span>operators<span class="token punctuation">,</span> reverse<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token operator">/</span><span class="token operator">|</span>\<span class="token operator">-</span><span class="token operator">|</span>\<span class="token operator">+</span><span class="token operator">|</span>\<span class="token operator">*</span>\<span class="token operator">*</span><span class="token operator">|</span>\<span class="token operator">*</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这个函数不能被用于 <code>sub()</code> 和 <code>subn()</code> 的替换字符串，只有反斜杠应该被转义。 例如:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> digits_re <span class="token operator">=</span> r<span class="token string">'\d+'</span>
<span class="token operator">>></span><span class="token operator">></span> sample <span class="token operator">=</span> <span class="token string">'/usr/sbin/sendmail - 0 errors, 12 warnings'</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>re<span class="token punctuation">.</span>sub<span class="token punctuation">(</span>digits_re<span class="token punctuation">,</span> digits_re<span class="token punctuation">.</span>replace<span class="token punctuation">(</span><span class="token string">'\\'</span><span class="token punctuation">,</span> r<span class="token string">'\\'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> sample<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token operator">/</span>usr<span class="token operator">/</span>sbin<span class="token operator">/</span>sendmail <span class="token operator">-</span> \d<span class="token operator">+</span> errors<span class="token punctuation">,</span> \d<span class="token operator">+</span> warnings<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>在 3.3 版更改: <code>'_'</code> 不再被转义。</p>
<p>在 3.7 版更改: 只有在正则表达式中具有特殊含义的字符才会被转义。 因此， <code>'!'</code>, <code>'"'</code>, <code>'%'</code>, <code>"'"</code>, <code>','</code>, <code>'/'</code>, <code>':'</code>, <code>';'</code>, <code>'&lt;'</code>, <code>'='</code>, <code>'&gt;'</code>, <code>'@'</code> 和 <code>"</code>“` 将不再会被转义。</p>
<p><code>re.purge</code>()</p>
<p>清除正则表达式的缓存。</p>
<p><em>exception</em> <code>re.error</code>(<em>msg</em>, <em>pattern=None</em>, <em>pos=None</em>)</p>
<p>当传递给函数的正则表达式不合法（比如括号不匹配），或者在编译或匹配过程中出现其他错误时，会引发异常。所给字符串不匹配所给模式不会引发异常。异常实例有以下附加属性：</p>
<ul>
<li><p><code>msg</code></p>
<p>未格式化的错误消息。</p>
</li>
<li><p><code>pattern</code></p>
<p>正则表达式的模式串。</p>
</li>
<li><p><code>pos</code></p>
<p>编译失败的 <em>pattern</em> 的位置索引（可以是 <code>None</code> ）。</p>
</li>
<li><p><code>lineno</code></p>
<p>对应 <em>pos</em> (可以是 <code>None</code>) 的行号。</p>
</li>
<li><p><code>colno</code></p>
<p>对应 <em>pos</em> (可以是 <code>None</code>) 的列号。</p>
</li>
</ul>
<p>在 3.5 版更改: 增加了额外的属性。</p>
<h3 id="正则表达式对象-（正则对象）"><a href="#正则表达式对象-（正则对象）" class="headerlink" title="正则表达式对象 （正则对象）"></a>正则表达式对象 （正则对象）</h3><p>编译后的正则表达式对象支持以下方法和属性：</p>
<p><code>Pattern.search</code>(<em>string</em>[, <em>pos</em>[, <em>endpos</em>]])</p>
<p>扫描整个 <em>string</em> 寻找第一个匹配的位置， 并返回一个相应的 匹配对象。如果没有匹配，就返回 <code>None</code> ；注意它和零长度匹配是不同的。</p>
<p>可选的第二个参数 <em>pos</em> 给出了字符串中开始搜索的位置索引；默认为 <code>0</code>，它不完全等价于字符串切片； <code>'^'</code> 样式字符匹配字符串真正的开头，和换行符后面的第一个字符，但不会匹配索引规定开始的位置。</p>
<p>可选参数 <em>endpos</em> 限定了字符串搜索的结束；它假定字符串长度到 <em>endpos</em> ， 所以只有从 <code>pos</code> 到 <code>endpos - 1</code> 的字符会被匹配。如果 <em>endpos</em> 小于 <em>pos*，就不会有匹配产生；另外，如果 *rx</em> 是一个编译后的正则对象， <code>rx.search(string, 0, 50)</code> 等价于 <code>rx.search(string[:50], 0)</code>。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> pattern <span class="token operator">=</span> re<span class="token punctuation">.</span>compile<span class="token punctuation">(</span><span class="token string">"d"</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> pattern<span class="token punctuation">.</span>search<span class="token punctuation">(</span><span class="token string">"dog"</span><span class="token punctuation">)</span>     <span class="token comment" spellcheck="true"># Match at index 0</span>
<span class="token operator">&lt;</span>re<span class="token punctuation">.</span>Match object<span class="token punctuation">;</span> span<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> match<span class="token operator">=</span><span class="token string">'d'</span><span class="token operator">></span>
<span class="token operator">>></span><span class="token operator">></span> pattern<span class="token punctuation">.</span>search<span class="token punctuation">(</span><span class="token string">"dog"</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># No match; search doesn't include the "d"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>Pattern.match</code>(<em>string</em>[, <em>pos</em>[, <em>endpos</em>]])</p>
<p>如果 <em>string</em> 的 <em>开始位置</em> 能够找到这个正则样式的任意个匹配，就返回一个相应的 匹配对象。如果不匹配，就返回 <code>None</code> ；注意它与零长度匹配是不同的。</p>
<p>可选参数 <em>pos</em> 和 <em>endpos</em> 与 <code>search()</code> 含义相同。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> pattern <span class="token operator">=</span> re<span class="token punctuation">.</span>compile<span class="token punctuation">(</span><span class="token string">"o"</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> pattern<span class="token punctuation">.</span>match<span class="token punctuation">(</span><span class="token string">"dog"</span><span class="token punctuation">)</span>      <span class="token comment" spellcheck="true"># No match as "o" is not at the start of "dog".</span>
<span class="token operator">>></span><span class="token operator">></span> pattern<span class="token punctuation">.</span>match<span class="token punctuation">(</span><span class="token string">"dog"</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true"># Match as "o" is the 2nd character of "dog".</span>
<span class="token operator">&lt;</span>re<span class="token punctuation">.</span>Match object<span class="token punctuation">;</span> span<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> match<span class="token operator">=</span><span class="token string">'o'</span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果你想定位匹配在 <em>string</em> 中的位置，使用 <code>search()</code> 来替代。</p>
<p><code>Pattern.fullmatch</code>(<em>string</em>[, <em>pos</em>[, <em>endpos</em>]])</p>
<p>如果整个 <em>string</em> 匹配这个正则表达式，就返回一个相应的 匹配对象 。 否则就返回 <code>None</code> ； 注意跟零长度匹配是不同的。</p>
<p>可选参数 <em>pos</em> 和 <em>endpos</em> 与 <code>search()</code> 含义相同。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> pattern <span class="token operator">=</span> re<span class="token punctuation">.</span>compile<span class="token punctuation">(</span><span class="token string">"o[gh]"</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> pattern<span class="token punctuation">.</span>fullmatch<span class="token punctuation">(</span><span class="token string">"dog"</span><span class="token punctuation">)</span>      <span class="token comment" spellcheck="true"># No match as "o" is not at the start of "dog".</span>
<span class="token operator">>></span><span class="token operator">></span> pattern<span class="token punctuation">.</span>fullmatch<span class="token punctuation">(</span><span class="token string">"ogre"</span><span class="token punctuation">)</span>     <span class="token comment" spellcheck="true"># No match as not the full string matches.</span>
<span class="token operator">>></span><span class="token operator">></span> pattern<span class="token punctuation">.</span>fullmatch<span class="token punctuation">(</span><span class="token string">"doggie"</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true"># Matches within given limits.</span>
<span class="token operator">&lt;</span>re<span class="token punctuation">.</span>Match object<span class="token punctuation">;</span> span<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span> match<span class="token operator">=</span><span class="token string">'og'</span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>3.4 新版功能.</p>
<p><code>Pattern.split</code>(<em>string</em>, <em>maxsplit=0</em>)</p>
<p>等价于 <code>split()</code> 函数，使用了编译后的样式。</p>
<p><code>Pattern.findall</code>(<em>string</em>[, <em>pos</em>[, <em>endpos</em>]])</p>
<p>类似函数 <code>findall()</code> ， 使用了编译后样式，但也可以接收可选参数 <em>pos</em> 和 <em>endpos</em> ，限制搜索范围，就像 <code>search()</code>。</p>
<p><code>Pattern.finditer</code>(<em>string</em>[, <em>pos</em>[, <em>endpos</em>]])</p>
<p>类似函数 <code>finditer()</code> ， 使用了编译后样式，但也可以接收可选参数 <em>pos</em> 和 <em>endpos</em> ，限制搜索范围，就像 <code>search()</code>。</p>
<p><code>Pattern.sub</code>(<em>repl</em>, <em>string</em>, <em>count=0</em>)</p>
<p>等价于 <code>sub()</code> 函数，使用了编译后的样式。</p>
<p><code>Pattern.subn</code>(<em>repl</em>, <em>string</em>, <em>count=0</em>)</p>
<p>等价于 <code>subn()</code> 函数，使用了编译后的样式。</p>
<pre><code>Pattern.flags</code></pre><p>正则匹配标记。这是可以传递给 <code>compile()</code> 的参数，任何 <code>(?…)</code> 内联标记，隐性标记比如 <code>UNICODE</code> 的结合。</p>
<pre><code>Pattern.groups</code></pre><p>捕获到的模式串中组的数量。</p>
<pre><code>Pattern.groupindex</code></pre><p>映射由 <code>(?P&lt;id&gt;)</code> 定义的命名符号组合和数字组合的字典。如果没有符号组，那字典就是空的。</p>
<pre><code>Pattern.pattern</code></pre><p>编译对象的原始样式字符串。</p>
<p>在 3.7 版更改: 添加 <code>copy.copy()</code> 和 <code>copy.deepcopy()</code> 函数的支持。编译后的正则表达式对象被认为是原子性的。</p>
<h3 id="匹配对象"><a href="#匹配对象" class="headerlink" title="匹配对象"></a>匹配对象</h3><p>匹配对象总是有一个布尔值 <code>True</code>。如果没有匹配的话 <code>match()</code> 和 <code>search()</code> 返回 <code>None</code> 所以你可以简单的用 <code>if</code> 语句来判断是否匹配</p>
<pre class="line-numbers language-python"><code class="language-python">match <span class="token operator">=</span> re<span class="token punctuation">.</span>search<span class="token punctuation">(</span>pattern<span class="token punctuation">,</span> string<span class="token punctuation">)</span>
<span class="token keyword">if</span> match<span class="token punctuation">:</span>
    process<span class="token punctuation">(</span>match<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>匹配对象支持以下方法和属性：</p>
<p><code>Match.expand</code>(<em>template</em>)</p>
<p>对 <em>template</em> 进行反斜杠转义替换并且返回，就像 <code>sub()</code> 方法中一样。转义如同 <code>\n</code> 被转换成合适的字符，数字引用(<code>\1</code>, <code>\2</code>)和命名组合(<code>\g&lt;1&gt;</code>, <code>\g&lt;name&gt;</code>) 替换为相应组合的内容。</p>
<p>在 3.5 版更改: 不匹配的组合替换为空字符串。</p>
<p><code>Match.group</code>([<em>group1</em>, <em>…</em>])</p>
<p>返回一个或者多个匹配的子组。如果只有一个参数，结果就是一个字符串，如果有多个参数，结果就是一个元组（每个参数对应一个项），如果没有参数，组1默认到0（整个匹配都被返回）。 如果一个组N 参数值为 0，相应的返回值就是整个匹配字符串；如果它是一个范围 [1..99]，结果就是相应的括号组字符串。如果一个组号是负数，或者大于样式中定义的组数，就引发一个 <code>IndexError</code> 异常。如果一个组包含在样式的一部分，并被匹配多次，就返回最后一个匹配。:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> m <span class="token operator">=</span> re<span class="token punctuation">.</span>match<span class="token punctuation">(</span>r<span class="token string">"(\w+) (\w+)"</span><span class="token punctuation">,</span> <span class="token string">"Isaac Newton, physicist"</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> m<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>       <span class="token comment" spellcheck="true"># The entire match</span>
<span class="token string">'Isaac Newton'</span>
<span class="token operator">>></span><span class="token operator">></span> m<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>       <span class="token comment" spellcheck="true"># The first parenthesized subgroup.</span>
<span class="token string">'Isaac'</span>
<span class="token operator">>></span><span class="token operator">></span> m<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>       <span class="token comment" spellcheck="true"># The second parenthesized subgroup.</span>
<span class="token string">'Newton'</span>
<span class="token operator">>></span><span class="token operator">></span> m<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># Multiple arguments give us a tuple.</span>
<span class="token punctuation">(</span><span class="token string">'Isaac'</span><span class="token punctuation">,</span> <span class="token string">'Newton'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果正则表达式使用了 <code>(?P&lt;name&gt;...)</code> 语法， <em>groupN</em> 参数就也可能是命名组合的名字。如果一个字符串参数在样式中未定义为组合名，就引发一个 <code>IndexError</code> 异常。</p>
<p>一个相对复杂的例子</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> m <span class="token operator">=</span> re<span class="token punctuation">.</span>match<span class="token punctuation">(</span>r<span class="token string">"(?P&lt;first_name>\w+) (?P&lt;last_name>\w+)"</span><span class="token punctuation">,</span> <span class="token string">"Malcolm Reynolds"</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> m<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token string">'first_name'</span><span class="token punctuation">)</span>
<span class="token string">'Malcolm'</span>
<span class="token operator">>></span><span class="token operator">></span> m<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token string">'last_name'</span><span class="token punctuation">)</span>
<span class="token string">'Reynolds'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>命名组合同样可以通过索引值引用</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> m<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token string">'Malcolm'</span>
<span class="token operator">>></span><span class="token operator">></span> m<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>
<span class="token string">'Reynolds'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果一个组匹配成功多次，就只返回最后一个匹配</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> m <span class="token operator">=</span> re<span class="token punctuation">.</span>match<span class="token punctuation">(</span>r<span class="token string">"(..)+"</span><span class="token punctuation">,</span> <span class="token string">"a1b2c3"</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># Matches 3 times.</span>
<span class="token operator">>></span><span class="token operator">></span> m<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>                        <span class="token comment" spellcheck="true"># Returns only the last match.</span>
<span class="token string">'c3'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p><code>Match.__getitem__</code>(<em>g</em>)</p>
<p>这个等价于 <code>m.group(g)</code>。这允许更方便的引用一个匹配</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> m <span class="token operator">=</span> re<span class="token punctuation">.</span>match<span class="token punctuation">(</span>r<span class="token string">"(\w+) (\w+)"</span><span class="token punctuation">,</span> <span class="token string">"Isaac Newton, physicist"</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> m<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>       <span class="token comment" spellcheck="true"># The entire match</span>
<span class="token string">'Isaac Newton'</span>
<span class="token operator">>></span><span class="token operator">></span> m<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>       <span class="token comment" spellcheck="true"># The first parenthesized subgroup.</span>
<span class="token string">'Isaac'</span>
<span class="token operator">>></span><span class="token operator">></span> m<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span>       <span class="token comment" spellcheck="true"># The second parenthesized subgroup.</span>
<span class="token string">'Newton'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>3.6 新版功能.</p>
<p><code>Match.groups</code>(<em>default=None</em>)</p>
<p>返回一个元组，包含所有匹配的子组，在样式中出现的从1到任意多的组合。 <em>default</em> 参数用于不参与匹配的情况，默认为 <code>None</code>。</p>
<p>例如：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> m <span class="token operator">=</span> re<span class="token punctuation">.</span>match<span class="token punctuation">(</span>r<span class="token string">"(\d+)\.(\d+)"</span><span class="token punctuation">,</span> <span class="token string">"24.1632"</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> m<span class="token punctuation">.</span>groups<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token string">'24'</span><span class="token punctuation">,</span> <span class="token string">'1632'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>如果我们使小数点可选，那么不是所有的组都会参与到匹配当中。这些组合默认会返回一个 <code>None</code> ，除非指定了 <em>default</em> 参数。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> m <span class="token operator">=</span> re<span class="token punctuation">.</span>match<span class="token punctuation">(</span>r<span class="token string">"(\d+)\.?(\d+)?"</span><span class="token punctuation">,</span> <span class="token string">"24"</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> m<span class="token punctuation">.</span>groups<span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token comment" spellcheck="true"># Second group defaults to None.</span>
<span class="token punctuation">(</span><span class="token string">'24'</span><span class="token punctuation">,</span> None<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> m<span class="token punctuation">.</span>groups<span class="token punctuation">(</span><span class="token string">'0'</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true"># Now, the second group defaults to '0'.</span>
<span class="token punctuation">(</span><span class="token string">'24'</span><span class="token punctuation">,</span> <span class="token string">'0'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>Match.groupdict</code>(<em>default=None</em>)</p>
<p>返回一个字典，包含了所有的 <em>命名</em> 子组。key就是组名。 <em>default</em> 参数用于不参与匹配的组合；默认为 <code>None</code>。 例如</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> m <span class="token operator">=</span> re<span class="token punctuation">.</span>match<span class="token punctuation">(</span>r<span class="token string">"(?P&lt;first_name>\w+) (?P&lt;last_name>\w+)"</span><span class="token punctuation">,</span> <span class="token string">"Malcolm Reynolds"</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> m<span class="token punctuation">.</span>groupdict<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span><span class="token string">'first_name'</span><span class="token punctuation">:</span> <span class="token string">'Malcolm'</span><span class="token punctuation">,</span> <span class="token string">'last_name'</span><span class="token punctuation">:</span> <span class="token string">'Reynolds'</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p><code>Match.start</code>([<em>group</em>])</p>
<p><code>Match.end</code>([<em>group</em>])</p>
<p>返回 <em>group</em> 匹配到的字串的开始和结束标号。<em>group</em> 默认为0（意思是整个匹配的子串）。如果 <em>group</em> 存在，但未产生匹配，就返回 <code>-1</code> 。对于一个匹配对象 <em>m</em>， 和一个未参与匹配的组 <em>g</em> ，组 <em>g</em> (等价于 <code>m.group(g)</code>)产生的匹配是</p>
<pre><code>m.string[m.start(g):m.end(g)]</code></pre><p>注意 <code>m.start(group)</code> 将会等于 <code>m.end(group)</code> ，如果 <em>group</em> 匹配一个空字符串的话。比如，在 <code>m = re.search('b(c?)', 'cba')</code> 之后，<code>m.start(0)</code> 为 1, <code>m.end(0)</code> 为 2, <code>m.start(1)</code> 和 <code>m.end(1)</code> 都是 2, <code>m.start(2)</code> 引发一个 <code>IndexError</code> 异常。</p>
<p>这个例子会从email地址中移除掉 <em>remove_this</em></p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> email <span class="token operator">=</span> <span class="token string">"tony@tiremove_thisger.net"</span>
<span class="token operator">>></span><span class="token operator">></span> m <span class="token operator">=</span> re<span class="token punctuation">.</span>search<span class="token punctuation">(</span><span class="token string">"remove_this"</span><span class="token punctuation">,</span> email<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> email<span class="token punctuation">[</span><span class="token punctuation">:</span>m<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">+</span> email<span class="token punctuation">[</span>m<span class="token punctuation">.</span>end<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token punctuation">]</span>
<span class="token string">'tony@tiger.net'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>Match.span</code>([<em>group</em>])</p>
<p>对于一个匹配 <em>m</em> ， 返回一个二元组 <code>(m.start(group), m.end(group))</code> 。 注意如果 <em>group</em> 没有在这个匹配中，就返回 <code>(-1, -1)</code> 。<em>group</em> 默认为0，就是整个匹配。</p>
<pre><code>Match.pos</code></pre><p><em>pos</em> 的值，会传递给 <code>search()</code> 或 <code>match()</code> 的方法 a 正则对象 。这个是正则引擎开始在字符串搜索一个匹配的索引位置。</p>
<pre><code>Match.endpos</code></pre><p><em>endpos</em> 的值，会传递给 <code>search()</code> 或 <code>match()</code> 的方法 a 正则对象 。这个是正则引擎停止在字符串搜索一个匹配的索引位置。</p>
<pre><code>Match.lastindex</code></pre><p>捕获组的最后一个匹配的整数索引值，或者 <code>None</code> 如果没有匹配产生的话。比如，对于字符串 <code>'ab'</code>，表达式 <code>(a)b</code>, <code>((a)(b))</code>, 和 <code>((ab))</code> 将得到 <code>lastindex == 1</code> ， 而 <code>(a)(b)</code> 会得到 <code>lastindex == 2</code> 。</p>
<pre><code>Match.lastgroup</code></pre><p>最后一个匹配的命名组名字，或者 <code>None</code> 如果没有产生匹配的话。</p>
<pre><code>Match.re</code></pre><p>返回产生这个实例的 正则对象 ， 这个实例是由 正则对象的 <code>match()</code> 或 <code>search()</code> 方法产生的。</p>
<pre><code>Match.string</code></pre><p>传递到 <code>match()</code> 或 <code>search()</code> 的字符串。</p>
<p>在 3.7 版更改: 添加了对 <code>copy.copy()</code> 和 <code>copy.deepcopy()</code> 的支持。匹配对象被看作是原子性的。</p>
<h3 id="正则表达式例子"><a href="#正则表达式例子" class="headerlink" title="正则表达式例子"></a>正则表达式例子</h3><h4 id="检查对子"><a href="#检查对子" class="headerlink" title="检查对子"></a>检查对子</h4><p>在这个例子里，我们使用以下辅助函数来更好地显示匹配对象:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">displaymatch</span><span class="token punctuation">(</span>match<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> match <span class="token keyword">is</span> None<span class="token punctuation">:</span>
        <span class="token keyword">return</span> None
    <span class="token keyword">return</span> <span class="token string">'&lt;Match: %r, groups=%r>'</span> <span class="token operator">%</span> <span class="token punctuation">(</span>match<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> match<span class="token punctuation">.</span>groups<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>假设你在写一个扑克程序，一个玩家的一手牌为五个字符的串，每个字符表示一张牌，”a” 就是 A, “k” K， “q” Q, “j” J, “t” 为 10, “2” 到 “9” 表示2 到 9。</p>
<p>要看给定的字符串是否有效，我们可以按照以下步骤</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> valid <span class="token operator">=</span> re<span class="token punctuation">.</span>compile<span class="token punctuation">(</span>r<span class="token string">"^[a2-9tjqk]{5}$"</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> displaymatch<span class="token punctuation">(</span>valid<span class="token punctuation">.</span>match<span class="token punctuation">(</span><span class="token string">"akt5q"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># Valid.</span>
<span class="token string">"&lt;Match: 'akt5q', groups=()>"</span>
<span class="token operator">>></span><span class="token operator">></span> displaymatch<span class="token punctuation">(</span>valid<span class="token punctuation">.</span>match<span class="token punctuation">(</span><span class="token string">"akt5e"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># Invalid.</span>
<span class="token operator">>></span><span class="token operator">></span> displaymatch<span class="token punctuation">(</span>valid<span class="token punctuation">.</span>match<span class="token punctuation">(</span><span class="token string">"akt"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># Invalid.</span>
<span class="token operator">>></span><span class="token operator">></span> displaymatch<span class="token punctuation">(</span>valid<span class="token punctuation">.</span>match<span class="token punctuation">(</span><span class="token string">"727ak"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># Valid.</span>
<span class="token string">"&lt;Match: '727ak', groups=()>"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>最后一手牌，<code>"727ak"</code> ，包含了一个对子，或者两张同样数值的牌。要用正则表达式匹配它，应该使用向后引用如下</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> pair <span class="token operator">=</span> re<span class="token punctuation">.</span>compile<span class="token punctuation">(</span>r<span class="token string">".*(.).*\1"</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> displaymatch<span class="token punctuation">(</span>pair<span class="token punctuation">.</span>match<span class="token punctuation">(</span><span class="token string">"717ak"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>     <span class="token comment" spellcheck="true"># Pair of 7s.</span>
<span class="token string">"&lt;Match: '717', groups=('7',)>"</span>
<span class="token operator">>></span><span class="token operator">></span> displaymatch<span class="token punctuation">(</span>pair<span class="token punctuation">.</span>match<span class="token punctuation">(</span><span class="token string">"718ak"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>     <span class="token comment" spellcheck="true"># No pairs.</span>
<span class="token operator">>></span><span class="token operator">></span> displaymatch<span class="token punctuation">(</span>pair<span class="token punctuation">.</span>match<span class="token punctuation">(</span><span class="token string">"354aa"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>     <span class="token comment" spellcheck="true"># Pair of aces.</span>
<span class="token string">"&lt;Match: '354aa', groups=('a',)>"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>要找出对子由什么牌组成，开发者可以按照下面的方式来使用匹配对象的 <code>group()</code> 方法:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> pair <span class="token operator">=</span> re<span class="token punctuation">.</span>compile<span class="token punctuation">(</span>r<span class="token string">".*(.).*\1"</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> pair<span class="token punctuation">.</span>match<span class="token punctuation">(</span><span class="token string">"717ak"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token string">'7'</span>
<span class="token comment" spellcheck="true"># Error because re.match() returns None, which doesn't have a group() method:</span>
<span class="token operator">>></span><span class="token operator">></span> pair<span class="token punctuation">.</span>match<span class="token punctuation">(</span><span class="token string">"718ak"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>
  File <span class="token string">"&lt;pyshell#23>"</span><span class="token punctuation">,</span> line <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">></span>
    re<span class="token punctuation">.</span>match<span class="token punctuation">(</span>r<span class="token string">".*(.).*\1"</span><span class="token punctuation">,</span> <span class="token string">"718ak"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
AttributeError<span class="token punctuation">:</span> <span class="token string">'NoneType'</span> object has no attribute <span class="token string">'group'</span>
<span class="token operator">>></span><span class="token operator">></span> pair<span class="token punctuation">.</span>match<span class="token punctuation">(</span><span class="token string">"354aa"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token string">'a'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="模拟-scanf"><a href="#模拟-scanf" class="headerlink" title="模拟 scanf()"></a>模拟 scanf()</h4><p>Python 目前没有一个类似c函数 <code>scanf()</code> 的替代品。正则表达式通常比 <code>scanf()</code> 格式字符串要更强大一些，但也带来更多复杂性。下面的表格提供了 <code>scanf()</code> 格式符和正则表达式大致相同的映射。</p>
<table>
<thead>
<tr>
<th align="left"><code>scanf()</code> 格式符</th>
<th align="left">正则表达式</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>%c</code></td>
<td align="left"><code>.</code></td>
</tr>
<tr>
<td align="left"><code>%5c</code></td>
<td align="left"><code>.{5}</code></td>
</tr>
<tr>
<td align="left"><code>%d</code></td>
<td align="left"><code>[-+]?\d+</code></td>
</tr>
<tr>
<td align="left"><code>%e</code>, <code>%E</code>, <code>%f</code>, <code>%g</code></td>
<td align="left">`[-+]?(\d+(.\d*)?</td>
</tr>
<tr>
<td align="left"><code>%i</code></td>
<td align="left">`[-+]?(0[xX][\dA-Fa-f]+</td>
</tr>
<tr>
<td align="left"><code>%o</code></td>
<td align="left"><code>[-+]?[0-7]+</code></td>
</tr>
<tr>
<td align="left"><code>%s</code></td>
<td align="left"><code>\S+</code></td>
</tr>
<tr>
<td align="left"><code>%u</code></td>
<td align="left"><code>\d+</code></td>
</tr>
<tr>
<td align="left"><code>%x</code>, <code>%X</code></td>
<td align="left"><code>[-+]?(0[xX])?[\dA-Fa-f]+</code></td>
</tr>
</tbody></table>
<p>从文件名和数字提取字符串</p>
<pre><code>/usr/sbin/sendmail - 0 errors, 4 warnings</code></pre><p>你可以使用 <code>scanf()</code> 格式化</p>
<pre><code>%s - %d errors, %d warnings</code></pre><p>等价的正则表达式是：</p>
<pre><code>(\S+) - (\d+) errors, (\d+) warnings</code></pre><h4 id="search-vs-match"><a href="#search-vs-match" class="headerlink" title="search() vs. match()"></a>search() vs. match()</h4><p>Python 提供了两种不同的操作：基于 <code>re.match()</code> 检查字符串开头，或者 <code>re.search()</code> 检查字符串的任意位置（默认Perl中的行为）。</p>
<p>例如：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> re<span class="token punctuation">.</span>match<span class="token punctuation">(</span><span class="token string">"c"</span><span class="token punctuation">,</span> <span class="token string">"abcdef"</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># No match</span>
<span class="token operator">>></span><span class="token operator">></span> re<span class="token punctuation">.</span>search<span class="token punctuation">(</span><span class="token string">"c"</span><span class="token punctuation">,</span> <span class="token string">"abcdef"</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true"># Match</span>
<span class="token operator">&lt;</span>re<span class="token punctuation">.</span>Match object<span class="token punctuation">;</span> span<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span> match<span class="token operator">=</span><span class="token string">'c'</span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>在 <code>search()</code> 中，可以用 <code>'^'</code> 作为开始来限制匹配到字符串的首位</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> re<span class="token punctuation">.</span>match<span class="token punctuation">(</span><span class="token string">"c"</span><span class="token punctuation">,</span> <span class="token string">"abcdef"</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># No match</span>
<span class="token operator">>></span><span class="token operator">></span> re<span class="token punctuation">.</span>search<span class="token punctuation">(</span><span class="token string">"^c"</span><span class="token punctuation">,</span> <span class="token string">"abcdef"</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># No match</span>
<span class="token operator">>></span><span class="token operator">></span> re<span class="token punctuation">.</span>search<span class="token punctuation">(</span><span class="token string">"^a"</span><span class="token punctuation">,</span> <span class="token string">"abcdef"</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># Match</span>
<span class="token operator">&lt;</span>re<span class="token punctuation">.</span>Match object<span class="token punctuation">;</span> span<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> match<span class="token operator">=</span><span class="token string">'a'</span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>注意 <code>MULTILINE</code> 多行模式中函数 <code>match()</code> 只匹配字符串的开始，但使用 <code>search()</code> 和以 <code>'^'</code> 开始的正则表达式会匹配每行的开始</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> re<span class="token punctuation">.</span>match<span class="token punctuation">(</span><span class="token string">'X'</span><span class="token punctuation">,</span> <span class="token string">'A\nB\nX'</span><span class="token punctuation">,</span> re<span class="token punctuation">.</span>MULTILINE<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># No match</span>
<span class="token operator">>></span><span class="token operator">></span> re<span class="token punctuation">.</span>search<span class="token punctuation">(</span><span class="token string">'^X'</span><span class="token punctuation">,</span> <span class="token string">'A\nB\nX'</span><span class="token punctuation">,</span> re<span class="token punctuation">.</span>MULTILINE<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># Match</span>
<span class="token operator">&lt;</span>re<span class="token punctuation">.</span>Match object<span class="token punctuation">;</span> span<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">,</span> match<span class="token operator">=</span><span class="token string">'X'</span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h4 id="制作一个电话本"><a href="#制作一个电话本" class="headerlink" title="制作一个电话本"></a>制作一个电话本</h4><p><code>split()</code> 将字符串用参数传递的样式分隔开。这个方法对于转换文本数据到易读而且容易修改的数据结构，是很有用的，如下面的例子证明。</p>
<p>首先，这里是输入。 它通常来自一个文件，这里我们使用三重引号字符串语法</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> text <span class="token operator">=</span> <span class="token triple-quoted-string string">"""Ross McFluff: 834.345.1254 155 Elm Street
...
... Ronald Heathmore: 892.345.3428 436 Finley Avenue
... Frank Burger: 925.541.7625 662 South Dogwood Way
...
...
... Heather Albrecht: 548.326.4584 919 Park Place"""</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>条目用一个或者多个换行符分开。现在我们将字符串转换为一个列表，每个非空行都有一个条目:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> entries <span class="token operator">=</span> re<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">"\n+"</span><span class="token punctuation">,</span> text<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> entries
<span class="token punctuation">[</span><span class="token string">'Ross McFluff: 834.345.1254 155 Elm Street'</span><span class="token punctuation">,</span>
<span class="token string">'Ronald Heathmore: 892.345.3428 436 Finley Avenue'</span><span class="token punctuation">,</span>
<span class="token string">'Frank Burger: 925.541.7625 662 South Dogwood Way'</span><span class="token punctuation">,</span>
<span class="token string">'Heather Albrecht: 548.326.4584 919 Park Place'</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>最终，将每个条目分割为一个由名字、姓氏、电话号码和地址组成的列表。我们为 <code>split()</code> 使用了 <code>maxsplit</code> 形参，因为地址中包含有被我们作为分割模式的空格符:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token punctuation">[</span>re<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">":? "</span><span class="token punctuation">,</span> entry<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token keyword">for</span> entry <span class="token keyword">in</span> entries<span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token string">'Ross'</span><span class="token punctuation">,</span> <span class="token string">'McFluff'</span><span class="token punctuation">,</span> <span class="token string">'834.345.1254'</span><span class="token punctuation">,</span> <span class="token string">'155 Elm Street'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">[</span><span class="token string">'Ronald'</span><span class="token punctuation">,</span> <span class="token string">'Heathmore'</span><span class="token punctuation">,</span> <span class="token string">'892.345.3428'</span><span class="token punctuation">,</span> <span class="token string">'436 Finley Avenue'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">[</span><span class="token string">'Frank'</span><span class="token punctuation">,</span> <span class="token string">'Burger'</span><span class="token punctuation">,</span> <span class="token string">'925.541.7625'</span><span class="token punctuation">,</span> <span class="token string">'662 South Dogwood Way'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">[</span><span class="token string">'Heather'</span><span class="token punctuation">,</span> <span class="token string">'Albrecht'</span><span class="token punctuation">,</span> <span class="token string">'548.326.4584'</span><span class="token punctuation">,</span> <span class="token string">'919 Park Place'</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>:?</code> 样式匹配姓后面的冒号，因此它不出现在结果列表中。如果 <code>maxsplit</code> 设置为 <code>4</code> ，我们还可以从地址中获取到房间号:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token punctuation">[</span>re<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">":? "</span><span class="token punctuation">,</span> entry<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token keyword">for</span> entry <span class="token keyword">in</span> entries<span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token string">'Ross'</span><span class="token punctuation">,</span> <span class="token string">'McFluff'</span><span class="token punctuation">,</span> <span class="token string">'834.345.1254'</span><span class="token punctuation">,</span> <span class="token string">'155'</span><span class="token punctuation">,</span> <span class="token string">'Elm Street'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">[</span><span class="token string">'Ronald'</span><span class="token punctuation">,</span> <span class="token string">'Heathmore'</span><span class="token punctuation">,</span> <span class="token string">'892.345.3428'</span><span class="token punctuation">,</span> <span class="token string">'436'</span><span class="token punctuation">,</span> <span class="token string">'Finley Avenue'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">[</span><span class="token string">'Frank'</span><span class="token punctuation">,</span> <span class="token string">'Burger'</span><span class="token punctuation">,</span> <span class="token string">'925.541.7625'</span><span class="token punctuation">,</span> <span class="token string">'662'</span><span class="token punctuation">,</span> <span class="token string">'South Dogwood Way'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">[</span><span class="token string">'Heather'</span><span class="token punctuation">,</span> <span class="token string">'Albrecht'</span><span class="token punctuation">,</span> <span class="token string">'548.326.4584'</span><span class="token punctuation">,</span> <span class="token string">'919'</span><span class="token punctuation">,</span> <span class="token string">'Park Place'</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="文字整理"><a href="#文字整理" class="headerlink" title="文字整理"></a>文字整理</h4><p><code>sub()</code> 替换字符串中出现的样式的每一个实例。这个例子证明了使用 <code>sub()</code> 来整理文字，或者随机化每个字符的位置，除了首位和末尾字符</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">def</span> <span class="token function">repl</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     inner_word <span class="token operator">=</span> list<span class="token punctuation">(</span>m<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     random<span class="token punctuation">.</span>shuffle<span class="token punctuation">(</span>inner_word<span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">return</span> m<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">""</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>inner_word<span class="token punctuation">)</span> <span class="token operator">+</span> m<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> text <span class="token operator">=</span> <span class="token string">"Professor Abdolmalek, please report your absences promptly."</span>
<span class="token operator">>></span><span class="token operator">></span> re<span class="token punctuation">.</span>sub<span class="token punctuation">(</span>r<span class="token string">"(\w)(\w+)(\w)"</span><span class="token punctuation">,</span> repl<span class="token punctuation">,</span> text<span class="token punctuation">)</span>
<span class="token string">'Poefsrosr Aealmlobdk, pslaee reorpt your abnseces plmrptoy.'</span>
<span class="token operator">>></span><span class="token operator">></span> re<span class="token punctuation">.</span>sub<span class="token punctuation">(</span>r<span class="token string">"(\w)(\w+)(\w)"</span><span class="token punctuation">,</span> repl<span class="token punctuation">,</span> text<span class="token punctuation">)</span>
<span class="token string">'Pofsroser Aodlambelk, plasee reoprt yuor asnebces potlmrpy.'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="查找所有副词"><a href="#查找所有副词" class="headerlink" title="查找所有副词"></a>查找所有副词</h4><p><code>findall()</code> 匹配样式 <em>所有</em> 的出现，不仅是像 <code>search()</code> 中的第一个匹配。比如，如果一个作者希望找到文字中的所有副词，他可能会按照以下方法用 <code>findall()</code></p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> text <span class="token operator">=</span> <span class="token string">"He was carefully disguised but captured quickly by police."</span>
<span class="token operator">>></span><span class="token operator">></span> re<span class="token punctuation">.</span>findall<span class="token punctuation">(</span>r<span class="token string">"\w+ly"</span><span class="token punctuation">,</span> text<span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token string">'carefully'</span><span class="token punctuation">,</span> <span class="token string">'quickly'</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h4 id="查找所有的副词及其位置"><a href="#查找所有的副词及其位置" class="headerlink" title="查找所有的副词及其位置"></a>查找所有的副词及其位置</h4><p>如果需要匹配样式的更多信息， <code>finditer()</code> 可以起到作用，它提供了 匹配对象 作为返回值，而不是字符串。继续上面的例子，如果一个作者希望找到所有副词和它的位置，可以按照下面方法使用 <code>finditer()</code></p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> text <span class="token operator">=</span> <span class="token string">"He was carefully disguised but captured quickly by police."</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">for</span> m <span class="token keyword">in</span> re<span class="token punctuation">.</span>finditer<span class="token punctuation">(</span>r<span class="token string">"\w+ly"</span><span class="token punctuation">,</span> text<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'%02d-%02d: %s'</span> <span class="token operator">%</span> <span class="token punctuation">(</span>m<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> m<span class="token punctuation">.</span>end<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> m<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token number">07</span><span class="token operator">-</span><span class="token number">16</span><span class="token punctuation">:</span> carefully
<span class="token number">40</span><span class="token operator">-</span><span class="token number">47</span><span class="token punctuation">:</span> quickly<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="原始字符串标记"><a href="#原始字符串标记" class="headerlink" title="原始字符串标记"></a>原始字符串标记</h4><p>原始字符串记法 (<code>r"text"</code>) 保持正则表达式正常。否则，每个正则式里的反斜杠(<code>'\'</code>) 都必须前缀一个反斜杠来转义。比如，下面两行代码功能就是完全一致的</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> re<span class="token punctuation">.</span>match<span class="token punctuation">(</span>r<span class="token string">"\W(.)\1\W"</span><span class="token punctuation">,</span> <span class="token string">" ff "</span><span class="token punctuation">)</span>
<span class="token operator">&lt;</span>re<span class="token punctuation">.</span>Match object<span class="token punctuation">;</span> span<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span> match<span class="token operator">=</span><span class="token string">' ff '</span><span class="token operator">></span>
<span class="token operator">>></span><span class="token operator">></span> re<span class="token punctuation">.</span>match<span class="token punctuation">(</span><span class="token string">"\\W(.)\\1\\W"</span><span class="token punctuation">,</span> <span class="token string">" ff "</span><span class="token punctuation">)</span>
<span class="token operator">&lt;</span>re<span class="token punctuation">.</span>Match object<span class="token punctuation">;</span> span<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span> match<span class="token operator">=</span><span class="token string">' ff '</span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>当需要匹配一个字符反斜杠，它必须在正则表达式中转义。在原始字符串记法，就是 <code>r"\\"</code>。否则就必须用 <code>"\\\\"</code>，来表示同样的意思</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> re<span class="token punctuation">.</span>match<span class="token punctuation">(</span>r<span class="token string">"\\"</span><span class="token punctuation">,</span> r<span class="token string">"\\"</span><span class="token punctuation">)</span>
<span class="token operator">&lt;</span>re<span class="token punctuation">.</span>Match object<span class="token punctuation">;</span> span<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> match<span class="token operator">=</span><span class="token string">'\\'</span><span class="token operator">></span>
<span class="token operator">>></span><span class="token operator">></span> re<span class="token punctuation">.</span>match<span class="token punctuation">(</span><span class="token string">"\\\\"</span><span class="token punctuation">,</span> r<span class="token string">"\\"</span><span class="token punctuation">)</span>
<span class="token operator">&lt;</span>re<span class="token punctuation">.</span>Match object<span class="token punctuation">;</span> span<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> match<span class="token operator">=</span><span class="token string">'\\'</span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="写一个词法分析器"><a href="#写一个词法分析器" class="headerlink" title="写一个词法分析器"></a>写一个词法分析器</h4><p>一个 词法器或词法分析器 分析字符串，并分类成目录组。 这是写一个编译器或解释器的第一步。</p>
<p>文字目录是由正则表达式指定的。这个技术是通过将这些样式合并为一个主正则式，并且循环匹配来实现的</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> typing <span class="token keyword">import</span> NamedTuple
<span class="token keyword">import</span> re
<span class="token keyword">class</span> <span class="token class-name">Token</span><span class="token punctuation">(</span>NamedTuple<span class="token punctuation">)</span><span class="token punctuation">:</span>
    type<span class="token punctuation">:</span> str
    value<span class="token punctuation">:</span> str
    line<span class="token punctuation">:</span> int
    column<span class="token punctuation">:</span> int
<span class="token keyword">def</span> <span class="token function">tokenize</span><span class="token punctuation">(</span>code<span class="token punctuation">)</span><span class="token punctuation">:</span>
    keywords <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'IF'</span><span class="token punctuation">,</span> <span class="token string">'THEN'</span><span class="token punctuation">,</span> <span class="token string">'ENDIF'</span><span class="token punctuation">,</span> <span class="token string">'FOR'</span><span class="token punctuation">,</span> <span class="token string">'NEXT'</span><span class="token punctuation">,</span> <span class="token string">'GOSUB'</span><span class="token punctuation">,</span> <span class="token string">'RETURN'</span><span class="token punctuation">}</span>
    token_specification <span class="token operator">=</span> <span class="token punctuation">[</span>
        <span class="token punctuation">(</span><span class="token string">'NUMBER'</span><span class="token punctuation">,</span>   r<span class="token string">'\d+(\.\d*)?'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token comment" spellcheck="true"># Integer or decimal number</span>
        <span class="token punctuation">(</span><span class="token string">'ASSIGN'</span><span class="token punctuation">,</span>   r<span class="token string">':='</span><span class="token punctuation">)</span><span class="token punctuation">,</span>           <span class="token comment" spellcheck="true"># Assignment operator</span>
        <span class="token punctuation">(</span><span class="token string">'END'</span><span class="token punctuation">,</span>      r<span class="token string">';'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            <span class="token comment" spellcheck="true"># Statement terminator</span>
        <span class="token punctuation">(</span><span class="token string">'ID'</span><span class="token punctuation">,</span>       r<span class="token string">'[A-Za-z]+'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true"># Identifiers</span>
        <span class="token punctuation">(</span><span class="token string">'OP'</span><span class="token punctuation">,</span>       r<span class="token string">'[+\-*/]'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>      <span class="token comment" spellcheck="true"># Arithmetic operators</span>
        <span class="token punctuation">(</span><span class="token string">'NEWLINE'</span><span class="token punctuation">,</span>  r<span class="token string">'\n'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>           <span class="token comment" spellcheck="true"># Line endings</span>
        <span class="token punctuation">(</span><span class="token string">'SKIP'</span><span class="token punctuation">,</span>     r<span class="token string">'[ \t]+'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>       <span class="token comment" spellcheck="true"># Skip over spaces and tabs</span>
        <span class="token punctuation">(</span><span class="token string">'MISMATCH'</span><span class="token punctuation">,</span> r<span class="token string">'.'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            <span class="token comment" spellcheck="true"># Any other character</span>
    <span class="token punctuation">]</span>
    tok_regex <span class="token operator">=</span> <span class="token string">'|'</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token string">'(?P&lt;%s>%s)'</span> <span class="token operator">%</span> pair <span class="token keyword">for</span> pair <span class="token keyword">in</span> token_specification<span class="token punctuation">)</span>
    line_num <span class="token operator">=</span> <span class="token number">1</span>
    line_start <span class="token operator">=</span> <span class="token number">0</span>
    <span class="token keyword">for</span> mo <span class="token keyword">in</span> re<span class="token punctuation">.</span>finditer<span class="token punctuation">(</span>tok_regex<span class="token punctuation">,</span> code<span class="token punctuation">)</span><span class="token punctuation">:</span>
        kind <span class="token operator">=</span> mo<span class="token punctuation">.</span>lastgroup
        value <span class="token operator">=</span> mo<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token punctuation">)</span>
        column <span class="token operator">=</span> mo<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> line_start
        <span class="token keyword">if</span> kind <span class="token operator">==</span> <span class="token string">'NUMBER'</span><span class="token punctuation">:</span>
            value <span class="token operator">=</span> float<span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token keyword">if</span> <span class="token string">'.'</span> <span class="token keyword">in</span> value <span class="token keyword">else</span> int<span class="token punctuation">(</span>value<span class="token punctuation">)</span>
        <span class="token keyword">elif</span> kind <span class="token operator">==</span> <span class="token string">'ID'</span> <span class="token operator">and</span> value <span class="token keyword">in</span> keywords<span class="token punctuation">:</span>
            kind <span class="token operator">=</span> value
        <span class="token keyword">elif</span> kind <span class="token operator">==</span> <span class="token string">'NEWLINE'</span><span class="token punctuation">:</span>
            line_start <span class="token operator">=</span> mo<span class="token punctuation">.</span>end<span class="token punctuation">(</span><span class="token punctuation">)</span>
            line_num <span class="token operator">+=</span> <span class="token number">1</span>
            <span class="token keyword">continue</span>
        <span class="token keyword">elif</span> kind <span class="token operator">==</span> <span class="token string">'SKIP'</span><span class="token punctuation">:</span>
            <span class="token keyword">continue</span>
        <span class="token keyword">elif</span> kind <span class="token operator">==</span> <span class="token string">'MISMATCH'</span><span class="token punctuation">:</span>
            <span class="token keyword">raise</span> RuntimeError<span class="token punctuation">(</span>f<span class="token string">'{value!r} unexpected on line {line_num}'</span><span class="token punctuation">)</span>
        <span class="token keyword">yield</span> Token<span class="token punctuation">(</span>kind<span class="token punctuation">,</span> value<span class="token punctuation">,</span> line_num<span class="token punctuation">,</span> column<span class="token punctuation">)</span>
statements <span class="token operator">=</span> <span class="token triple-quoted-string string">'''
    IF quantity THEN
        total := total + price * quantity;
        tax := price * 0.05;
    ENDIF;
'''</span>
<span class="token keyword">for</span> token <span class="token keyword">in</span> tokenize<span class="token punctuation">(</span>statements<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>token<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>该词法器产生以下的输出</p>
<pre class="line-numbers language-python"><code class="language-python">Token<span class="token punctuation">(</span>type<span class="token operator">=</span><span class="token string">'IF'</span><span class="token punctuation">,</span> value<span class="token operator">=</span><span class="token string">'IF'</span><span class="token punctuation">,</span> line<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span> column<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">)</span>
Token<span class="token punctuation">(</span>type<span class="token operator">=</span><span class="token string">'ID'</span><span class="token punctuation">,</span> value<span class="token operator">=</span><span class="token string">'quantity'</span><span class="token punctuation">,</span> line<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span> column<span class="token operator">=</span><span class="token number">7</span><span class="token punctuation">)</span>
Token<span class="token punctuation">(</span>type<span class="token operator">=</span><span class="token string">'THEN'</span><span class="token punctuation">,</span> value<span class="token operator">=</span><span class="token string">'THEN'</span><span class="token punctuation">,</span> line<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span> column<span class="token operator">=</span><span class="token number">16</span><span class="token punctuation">)</span>
Token<span class="token punctuation">(</span>type<span class="token operator">=</span><span class="token string">'ID'</span><span class="token punctuation">,</span> value<span class="token operator">=</span><span class="token string">'total'</span><span class="token punctuation">,</span> line<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">,</span> column<span class="token operator">=</span><span class="token number">8</span><span class="token punctuation">)</span>
Token<span class="token punctuation">(</span>type<span class="token operator">=</span><span class="token string">'ASSIGN'</span><span class="token punctuation">,</span> value<span class="token operator">=</span><span class="token string">':='</span><span class="token punctuation">,</span> line<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">,</span> column<span class="token operator">=</span><span class="token number">14</span><span class="token punctuation">)</span>
Token<span class="token punctuation">(</span>type<span class="token operator">=</span><span class="token string">'ID'</span><span class="token punctuation">,</span> value<span class="token operator">=</span><span class="token string">'total'</span><span class="token punctuation">,</span> line<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">,</span> column<span class="token operator">=</span><span class="token number">17</span><span class="token punctuation">)</span>
Token<span class="token punctuation">(</span>type<span class="token operator">=</span><span class="token string">'OP'</span><span class="token punctuation">,</span> value<span class="token operator">=</span><span class="token string">'+'</span><span class="token punctuation">,</span> line<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">,</span> column<span class="token operator">=</span><span class="token number">23</span><span class="token punctuation">)</span>
Token<span class="token punctuation">(</span>type<span class="token operator">=</span><span class="token string">'ID'</span><span class="token punctuation">,</span> value<span class="token operator">=</span><span class="token string">'price'</span><span class="token punctuation">,</span> line<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">,</span> column<span class="token operator">=</span><span class="token number">25</span><span class="token punctuation">)</span>
Token<span class="token punctuation">(</span>type<span class="token operator">=</span><span class="token string">'OP'</span><span class="token punctuation">,</span> value<span class="token operator">=</span><span class="token string">'*'</span><span class="token punctuation">,</span> line<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">,</span> column<span class="token operator">=</span><span class="token number">31</span><span class="token punctuation">)</span>
Token<span class="token punctuation">(</span>type<span class="token operator">=</span><span class="token string">'ID'</span><span class="token punctuation">,</span> value<span class="token operator">=</span><span class="token string">'quantity'</span><span class="token punctuation">,</span> line<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">,</span> column<span class="token operator">=</span><span class="token number">33</span><span class="token punctuation">)</span>
Token<span class="token punctuation">(</span>type<span class="token operator">=</span><span class="token string">'END'</span><span class="token punctuation">,</span> value<span class="token operator">=</span><span class="token string">';'</span><span class="token punctuation">,</span> line<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">,</span> column<span class="token operator">=</span><span class="token number">41</span><span class="token punctuation">)</span>
Token<span class="token punctuation">(</span>type<span class="token operator">=</span><span class="token string">'ID'</span><span class="token punctuation">,</span> value<span class="token operator">=</span><span class="token string">'tax'</span><span class="token punctuation">,</span> line<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">,</span> column<span class="token operator">=</span><span class="token number">8</span><span class="token punctuation">)</span>
Token<span class="token punctuation">(</span>type<span class="token operator">=</span><span class="token string">'ASSIGN'</span><span class="token punctuation">,</span> value<span class="token operator">=</span><span class="token string">':='</span><span class="token punctuation">,</span> line<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">,</span> column<span class="token operator">=</span><span class="token number">12</span><span class="token punctuation">)</span>
Token<span class="token punctuation">(</span>type<span class="token operator">=</span><span class="token string">'ID'</span><span class="token punctuation">,</span> value<span class="token operator">=</span><span class="token string">'price'</span><span class="token punctuation">,</span> line<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">,</span> column<span class="token operator">=</span><span class="token number">15</span><span class="token punctuation">)</span>
Token<span class="token punctuation">(</span>type<span class="token operator">=</span><span class="token string">'OP'</span><span class="token punctuation">,</span> value<span class="token operator">=</span><span class="token string">'*'</span><span class="token punctuation">,</span> line<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">,</span> column<span class="token operator">=</span><span class="token number">21</span><span class="token punctuation">)</span>
Token<span class="token punctuation">(</span>type<span class="token operator">=</span><span class="token string">'NUMBER'</span><span class="token punctuation">,</span> value<span class="token operator">=</span><span class="token number">0.05</span><span class="token punctuation">,</span> line<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">,</span> column<span class="token operator">=</span><span class="token number">23</span><span class="token punctuation">)</span>
Token<span class="token punctuation">(</span>type<span class="token operator">=</span><span class="token string">'END'</span><span class="token punctuation">,</span> value<span class="token operator">=</span><span class="token string">';'</span><span class="token punctuation">,</span> line<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">,</span> column<span class="token operator">=</span><span class="token number">27</span><span class="token punctuation">)</span>
Token<span class="token punctuation">(</span>type<span class="token operator">=</span><span class="token string">'ENDIF'</span><span class="token punctuation">,</span> value<span class="token operator">=</span><span class="token string">'ENDIF'</span><span class="token punctuation">,</span> line<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">,</span> column<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">)</span>
Token<span class="token punctuation">(</span>type<span class="token operator">=</span><span class="token string">'END'</span><span class="token punctuation">,</span> value<span class="token operator">=</span><span class="token string">';'</span><span class="token punctuation">,</span> line<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">,</span> column<span class="token operator">=</span><span class="token number">9</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>Frie09</p>
<p>Friedl, Jeffrey. Mastering Regular Expressions. 3rd ed., O’Reilly Media, 2009. 该书的第三版不再包含 Python，但第一版极详细地覆盖了正则表达式模式串的编写。</p>
<h2 id="difflib-—-计算差异的辅助工具"><a href="#difflib-—-计算差异的辅助工具" class="headerlink" title="difflib —- 计算差异的辅助工具"></a><code>difflib</code> —- 计算差异的辅助工具</h2><p><strong>源代码:</strong> <a href="https://github.com/python/cpython/tree/3.10/Lib/difflib.py" target="_blank" rel="noopener">Lib/difflib.py</a></p>
<p>此模块提供用于比较序列的类和函数。 例如，它可被用于比较文件，并可产生多种格式的不同文件差异信息，包括 HTML 和上下文以及统一的 diff 数据。 </p>
<p><em>class</em> <code>difflib.SequenceMatcher</code></p>
<p>这是一个灵活的类，可用于比较任何类型的序列对，只要序列元素为 hashable 对象。 其基本算法要早于由 Ratcliff 和 Obershelp 于 1980 年代末期发表并以“格式塔模式匹配”的夸张名称命名的算法，并且更加有趣一些。 其思路是找到不包含“垃圾”元素的最长连续匹配子序列；所谓“垃圾”元素是指其在某种意义上没有价值，例如空白行或空白符。 （处理垃圾元素是对 Ratcliff 和 Obershelp 算法的一个扩展。） 然后同样的思路将递归地应用于匹配序列的左右序列片段。 这并不能产生最小编辑序列，但确实能产生在人们看来“正确”的匹配。</p>
<p><strong>耗时:</strong> 基本 Ratcliff-Obershelp 算法在最坏情况下为立方时间而在一般情况下为平方时间。 <code>SequenceMatcher</code> 在最坏情况下为平方时间而在一般情况下的行为受到序列中有多少相同元素这一因素的微妙影响；在最佳情况下则为线性时间。</p>
<p><strong>自动垃圾启发式计算:</strong> <code>SequenceMatcher</code> 支持使用启发式计算来自动将特定序列项视为垃圾。 这种启发式计算会统计每个单独项在序列中出现的次数。 如果某一项（在第一项之后）的重复次数超过序列长度的 1% 并且序列长度至少有 200 项，该项会被标记为“热门”并被视为序列匹配中的垃圾。 这种启发式计算可以通过在创建 <code>SequenceMatcher</code> 时将 <code>autojunk</code> 参数设为 <code>False</code> 来关闭。</p>
<p>3.2 新版功能: <em>autojunk</em> 形参。</p>
<p><em>class</em> <code>difflib.Differ</code></p>
<p>这个类的作用是比较由文本行组成的序列，并产生可供人阅读的差异或增量信息。 Differ 统一使用 <code>SequenceMatcher</code> 来完成行序列的比较以及相似（接近匹配）行内部字符序列的比较。</p>
<p><code>Differ</code> 增量的每一行均以双字母代码打头：</p>
<table>
<thead>
<tr>
<th align="left">双字母代码</th>
<th align="left">含意</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>‘- ‘</code></td>
<td align="left">行为序列 1 所独有</td>
</tr>
<tr>
<td align="left"><code>‘+ ‘</code></td>
<td align="left">行为序列 2 所独有</td>
</tr>
<tr>
<td align="left"><code>‘ ‘</code></td>
<td align="left">行在两序列中相同</td>
</tr>
<tr>
<td align="left"><code>‘? ‘</code></td>
<td align="left">行不存在于任一输入序列</td>
</tr>
</tbody></table>
<p>以 ‘<code>?</code>‘ 打头的行尝试将视线引至行以外而不存在于任一输入序列的差异。 如果序列包含制表符则这些行可能会令人感到迷惑。</p>
<p><em>class</em> <code>difflib.HtmlDiff</code></p>
<p>这个类可用于创建 HTML 表格（或包含表格的完整 HTML 文件）以并排地逐行显示文本比较，行间与行外的更改将突出显示。 此表格可以基于完全或上下文差异模式来生成。</p>
<p>这个类的构造函数：</p>
<ul>
<li><p><code>__init__</code>(<em>tabsize=8</em>, <em>wrapcolumn=None</em>, <em>linejunk=None</em>, <em>charjunk=IS_CHARACTER_JUNK</em>)</p>
<p>初始化 <code>HtmlDiff</code> 的实例。</p>
<p><em>tabsize</em> 是一个可选关键字参数，指定制表位的间隔，默认值为 <code>8</code>。</p>
<p><em>wrapcolumn</em> 是一个可选关键字参数，指定行文本自动打断并换行的列位置，默认值为 <code>None</code> 表示不自动换行。</p>
<p><em>linejunk</em> 和 <em>charjunk</em> 均是可选关键字参数，会传入 <code>ndiff()</code> (被 <code>HtmlDiff</code> 用来生成并排显示的 HTML 差异)。 </p>
</li>
</ul>
<p>下列是公开的方法</p>
<ul>
<li><p><code>make_file</code>(<em>fromlines</em>, <em>tolines</em>, <em>fromdesc=’’</em>, <em>todesc=’’</em>, <em>context=False</em>, <em>numlines=5</em>, <em>**,</em> charset=’utf-8’*)</p>
<p>比较 <em>fromlines</em> 和 <em>tolines</em> (字符串列表) 并返回一个字符串，表示一个完整 HTML 文件，其中包含各行差异的表格，行间与行外的更改将突出显示。</p>
<p><em>fromdesc</em> 和 <em>todesc</em> 均是可选关键字参数，指定来源/目标文件的列标题字符串（默认均为空白字符串）。</p>
<p><em>context</em> 和 <em>numlines</em> 均是可选关键字参数。 当只要显示上下文差异时就将 <em>context</em> 设为 <code>True</code>，否则默认值 <code>False</code> 为显示完整文件。 <em>numlines</em> 默认为 <code>5</code>。 当 <em>context</em> 为 <code>True</code> 时 <em>numlines</em> 将控制围绕突出显示差异部分的上下文行数。 当 <em>context</em> 为 <code>False</code> 时 <em>numlines</em> 将控制在使用 “next” 超链接时突出显示差异部分之前所显示的行数（设为零则会导致 “next” 超链接将下一个突出显示差异部分放在浏览器顶端，不添加任何前导上下文）。</p>
<p>注解</p>
<p><em>fromdesc</em> 和 <em>todesc</em> 会被当作未转义的 HTML 来解读，当接收不可信来源的输入时应该适当地进行转义。</p>
<p>在 3.5 版更改: 增加了 <em>charset</em> 关键字参数。 HTML 文档的默认字符集从 <code>'ISO-8859-1'</code> 更改为 <code>'utf-8'</code>。</p>
</li>
<li><p><code>make_table</code>(<em>fromlines</em>, <em>tolines</em>, <em>fromdesc=’’</em>, <em>todesc=’’</em>, <em>context=False</em>, <em>numlines=5</em>)</p>
<p>比较 <em>fromlines</em> 和 <em>tolines</em> (字符串列表) 并返回一个字符串，表示一个包含各行差异的完整 HTML 表格，行间与行外的更改将突出显示。</p>
</li>
</ul>
<p><code>Tools/scripts/diff.py</code> 是这个类的命令行前端，其中包含一个很好的使用示例。</p>
<p><code>difflib.context_diff</code>(<em>a</em>, <em>b</em>, <em>fromfile=’’</em>, <em>tofile=’’</em>, <em>fromfiledate=’’</em>, <em>tofiledate=’’</em>, <em>n=3</em>, <em>lineterm=’\n’</em>)</p>
<p>比较 <em>a</em> 和 <em>b</em> (字符串列表)；返回上下文差异格式的增量信息 (一个产生增量行的 generator)。</p>
<p>所谓上下文差异是一种只显示有更改的行再加几个上下文行的紧凑形式。 更改被显示为之前/之后的样式。 上下文行数由 <em>n</em> 设定，默认为三行。</p>
<p>默认情况下，差异控制行（以 <code>***</code> or <code>---</code> 表示）是通过末尾换行符来创建的。 这样做的好处是从 <code>io.IOBase.readlines()</code> 创建的输入将得到适用于 <code>io.IOBase.writelines()</code> 的差异信息，因为输入和输出都带有末尾换行符。</p>
<p>对于没有末尾换行符的输入，应将 <em>lineterm</em> 参数设为 <code>""</code>，这样输出内容将统一不带换行符。</p>
<p>上下文差异格式通常带有一个记录文件名和修改时间的标头。 这些信息的部分或全部可以使用字符串 <em>fromfile</em>, <em>tofile</em>, <em>fromfiledate</em> 和 <em>tofiledate</em> 来指定。 修改时间通常以 ISO 8601 格式表示。 如果未指定，这些字符串默认为空。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> s1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'bacon\n'</span><span class="token punctuation">,</span> <span class="token string">'eggs\n'</span><span class="token punctuation">,</span> <span class="token string">'ham\n'</span><span class="token punctuation">,</span> <span class="token string">'guido\n'</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> s2 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'python\n'</span><span class="token punctuation">,</span> <span class="token string">'eggy\n'</span><span class="token punctuation">,</span> <span class="token string">'hamster\n'</span><span class="token punctuation">,</span> <span class="token string">'guido\n'</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> sys<span class="token punctuation">.</span>stdout<span class="token punctuation">.</span>writelines<span class="token punctuation">(</span>context_diff<span class="token punctuation">(</span>s1<span class="token punctuation">,</span> s2<span class="token punctuation">,</span> fromfile<span class="token operator">=</span><span class="token string">'before.py'</span><span class="token punctuation">,</span> tofile<span class="token operator">=</span><span class="token string">'after.py'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token operator">**</span><span class="token operator">*</span> before<span class="token punctuation">.</span>py
<span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span> after<span class="token punctuation">.</span>py
<span class="token operator">**</span><span class="token operator">**</span><span class="token operator">**</span><span class="token operator">**</span><span class="token operator">**</span><span class="token operator">**</span><span class="token operator">**</span><span class="token operator">*</span>
<span class="token operator">**</span><span class="token operator">*</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">4</span> <span class="token operator">**</span><span class="token operator">**</span>
! bacon
! eggs
! ham
  guido
<span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">4</span> <span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span>
! python
! eggy
! hamster
  guido<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>difflib.get_close_matches</code>(<em>word</em>, <em>possibilities</em>, <em>n=3</em>, <em>cutoff=0.6</em>)</p>
<p>返回由最佳“近似”匹配构成的列表。 <em>word</em> 为一个指定目标近似匹配的序列（通常为字符串），<em>possibilities</em> 为一个由用于匹配 <em>word</em> 的序列构成的列表（通常为字符串列表）。</p>
<p>可选参数 <em>n</em> (默认为 <code>3</code>) 指定最多返回多少个近似匹配； <em>n</em> 必须大于 <code>0</code>.</p>
<p>可选参数 <em>cutoff</em> (默认为 <code>0.6</code>) 是一个 [0, 1] 范围内的浮点数。 与 <em>word</em> 相似度得分未达到该值的候选匹配将被忽略。</p>
<p>候选匹配中（不超过 <em>n</em> 个）的最佳匹配将以列表形式返回，按相似度得分排序，最相似的排在最前面。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> get_close_matches<span class="token punctuation">(</span><span class="token string">'appel'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'ape'</span><span class="token punctuation">,</span> <span class="token string">'apple'</span><span class="token punctuation">,</span> <span class="token string">'peach'</span><span class="token punctuation">,</span> <span class="token string">'puppy'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token string">'apple'</span><span class="token punctuation">,</span> <span class="token string">'ape'</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> keyword
<span class="token operator">>></span><span class="token operator">></span> get_close_matches<span class="token punctuation">(</span><span class="token string">'wheel'</span><span class="token punctuation">,</span> keyword<span class="token punctuation">.</span>kwlist<span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token string">'while'</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> get_close_matches<span class="token punctuation">(</span><span class="token string">'pineapple'</span><span class="token punctuation">,</span> keyword<span class="token punctuation">.</span>kwlist<span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> get_close_matches<span class="token punctuation">(</span><span class="token string">'accept'</span><span class="token punctuation">,</span> keyword<span class="token punctuation">.</span>kwlist<span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token string">'except'</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>difflib.ndiff</code>(<em>a</em>, <em>b</em>, <em>linejunk=None</em>, <em>charjunk=IS_CHARACTER_JUNK</em>)</p>
<p>比较 <em>a</em> 和 <em>b</em> (字符串列表)；返回 <code>Differ</code> 形式的增量信息 (一个产生增量行的 generator)。</p>
<p>可选关键字形参 <em>linejunk</em> 和 <em>charjunk</em> 均为过滤函数 (或为 <code>None</code>)：</p>
<p><em>linejunk</em>: 此函数接受单个字符串参数，如果其为垃圾字符串则返回真值，否则返回假值。 默认为 <code>None</code>。 此外还有一个模块层级的函数 <code>IS_LINE_JUNK()</code>，它会过滤掉没有可见字符的行，除非该行添加了至多一个井号符 (<code>'#'</code>) — 但是下层的 <code>SequenceMatcher</code> 类会动态分析哪些行的重复频繁到足以形成噪音，这通常会比使用此函数的效果更好。</p>
<p><em>charjunk</em>: 此函数接受一个字符（长度为 1 的字符串)，如果其为垃圾字符则返回真值，否则返回假值。 默认为模块层级的函数 <code>IS_CHARACTER_JUNK()</code>，它会过滤掉空白字符（空格符或制表符；但包含换行符可不是个好主意！）。</p>
<p><code>Tools/scripts/ndiff.py</code> 是这个函数的命令行前端。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> diff <span class="token operator">=</span> ndiff<span class="token punctuation">(</span><span class="token string">'one\ntwo\nthree\n'</span><span class="token punctuation">.</span>splitlines<span class="token punctuation">(</span>keepends<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>              <span class="token string">'ore\ntree\nemu\n'</span><span class="token punctuation">.</span>splitlines<span class="token punctuation">(</span>keepends<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>diff<span class="token punctuation">)</span><span class="token punctuation">,</span> end<span class="token operator">=</span><span class="token string">""</span><span class="token punctuation">)</span>
<span class="token operator">-</span> one
?  <span class="token operator">^</span>
<span class="token operator">+</span> ore
?  <span class="token operator">^</span>
<span class="token operator">-</span> two
<span class="token operator">-</span> three
?  <span class="token operator">-</span>
<span class="token operator">+</span> tree
<span class="token operator">+</span> emu<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>difflib.restore</code>(<em>sequence</em>, <em>which</em>)</p>
<p>返回两个序列中产生增量的那一个。</p>
<p>给出一个由 <code>Differ.compare()</code> 或 <code>ndiff()</code> 产生的 <em>序列<em>，提取出来自文件 1 或 2 (</em>which</em> 形参) 的行，去除行前缀。</p>
<p>示例:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> diff <span class="token operator">=</span> ndiff<span class="token punctuation">(</span><span class="token string">'one\ntwo\nthree\n'</span><span class="token punctuation">.</span>splitlines<span class="token punctuation">(</span>keepends<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>              <span class="token string">'ore\ntree\nemu\n'</span><span class="token punctuation">.</span>splitlines<span class="token punctuation">(</span>keepends<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> diff <span class="token operator">=</span> list<span class="token punctuation">(</span>diff<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># materialize the generated delta into a list</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>restore<span class="token punctuation">(</span>diff<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> end<span class="token operator">=</span><span class="token string">""</span><span class="token punctuation">)</span>
one
two
three
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>restore<span class="token punctuation">(</span>diff<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> end<span class="token operator">=</span><span class="token string">""</span><span class="token punctuation">)</span>
ore
tree
emu<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>difflib.unified_diff</code>(<em>a</em>, <em>b</em>, <em>fromfile=’’</em>, <em>tofile=’’</em>, <em>fromfiledate=’’</em>, <em>tofiledate=’’</em>, <em>n=3</em>, <em>lineterm=’\n’</em>)</p>
<p>比较 <em>a</em> 和 <em>b</em> (字符串列表)；返回统一差异格式的增量信息 (一个产生增量行的 generator)。</p>
<p>所以统一差异是一种只显示有更改的行再加几个上下文行的紧凑形式。 更改被显示为内联的样式（而不是分开的之前/之后文本块）。 上下文行数由 <em>n</em> 设定，默认为三行。</p>
<p>默认情况下，差异控制行 (以 <code>---</code>, <code>+++</code> 或 <code>@@</code> 表示) 是通过末尾换行符来创建的。 这样做的好处是从 <code>io.IOBase.readlines()</code> 创建的输入将得到适用于 <code>io.IOBase.writelines()</code> 的差异信息，因为输入和输出都带有末尾换行符。</p>
<p>对于没有末尾换行符的输入，应将 <em>lineterm</em> 参数设为 <code>""</code>，这样输出内容将统一不带换行符。</p>
<p>上下文差异格式通常带有一个记录文件名和修改时间的标头。 这些信息的部分或全部可以使用字符串 <em>fromfile</em>, <em>tofile</em>, <em>fromfiledate</em> 和 <em>tofiledate</em> 来指定。 修改时间通常以 ISO 8601 格式表示。 如果未指定，这些字符串默认为空。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> s1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'bacon\n'</span><span class="token punctuation">,</span> <span class="token string">'eggs\n'</span><span class="token punctuation">,</span> <span class="token string">'ham\n'</span><span class="token punctuation">,</span> <span class="token string">'guido\n'</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> s2 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'python\n'</span><span class="token punctuation">,</span> <span class="token string">'eggy\n'</span><span class="token punctuation">,</span> <span class="token string">'hamster\n'</span><span class="token punctuation">,</span> <span class="token string">'guido\n'</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> sys<span class="token punctuation">.</span>stdout<span class="token punctuation">.</span>writelines<span class="token punctuation">(</span>unified_diff<span class="token punctuation">(</span>s1<span class="token punctuation">,</span> s2<span class="token punctuation">,</span> fromfile<span class="token operator">=</span><span class="token string">'before.py'</span><span class="token punctuation">,</span> tofile<span class="token operator">=</span><span class="token string">'after.py'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span> before<span class="token punctuation">.</span>py
<span class="token operator">+</span><span class="token operator">+</span><span class="token operator">+</span> after<span class="token punctuation">.</span>py
@@ <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">4</span> <span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">4</span> @@
<span class="token operator">-</span>bacon
<span class="token operator">-</span>eggs
<span class="token operator">-</span>ham
<span class="token operator">+</span>python
<span class="token operator">+</span>eggy
<span class="token operator">+</span>hamster
 guido<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>difflib.diff_bytes</code>(<em>dfunc</em>, <em>a</em>, <em>b</em>, <em>fromfile=b’’</em>, <em>tofile=b’’</em>, <em>fromfiledate=b’’</em>, <em>tofiledate=b’’</em>, <em>n=3</em>, <em>lineterm=b’\n’</em>)</p>
<p>使用 <em>dfunc</em> 比较 <em>a</em> 和 <em>b</em> (字节串对象列表)；产生以 <em>dfunc</em> 所返回格式表示的差异行列表（也是字节串）。 <em>dfunc</em> 必须是可调用对象，通常为 <code>unified_diff()</code> 或 <code>context_diff()</code>。</p>
<p>允许你比较编码未知或不一致的数据。 除 <em>n</em> 之外的所有输入都必须为字节串对象而非字符串。 作用方式为无损地将所有输入 (除 <em>n</em> 之外) 转换为字符串，并调用 <code>dfunc(a, b, fromfile, tofile, fromfiledate, tofiledate, n, lineterm)</code>。 <em>dfunc</em> 的输出会被随即转换回字节串，这样你所得到的增量行将具有与 <em>a</em> 和 <em>b</em> 相同的未知/不一致编码。</p>
<p>3.5 新版功能.</p>
<p><code>difflib.IS_LINE_JUNK</code>(<em>line</em>)</p>
<p>对于可忽略的行返回 <code>True</code>。 如果 <em>line</em> 为空行或只包含单个 <code>'#'</code> 则 <em>line</em> 行就是可忽略的，否则就是不可忽略的。 此函数被用作较旧版本 <code>ndiff()</code> 中 <em>linejunk</em> 形参的默认值。</p>
<p><code>difflib.IS_CHARACTER_JUNK</code>(<em>ch</em>)</p>
<p>对于可忽略的字符返回 <code>True</code>。 字符 <em>ch</em> 如果为空格符或制表符则 <em>ch</em> 就是可忽略的，否则就是不可忽略的。 此函数被用作 <code>ndiff()</code> 中 <em>charjunk</em> 形参的默认值。</p>
<h3 id="SequenceMatcher-对象"><a href="#SequenceMatcher-对象" class="headerlink" title="SequenceMatcher 对象"></a>SequenceMatcher 对象</h3><p><code>SequenceMatcher</code> 类具有这样的构造器：</p>
<p><em>class</em> <code>difflib.SequenceMatcher</code>(<em>isjunk=None</em>, <em>a=’’</em>, <em>b=’’</em>, <em>autojunk=True</em>)</p>
<p>可选参数 <em>isjunk</em> 必须为 <code>None</code> (默认值) 或为接受一个序列元素并当且仅当其为应忽略的“垃圾”元素时返回真值的单参数函数。 传入 <code>None</code> 作为 <em>isjunk</em> 的值就相当于传入 <code>lambda x: False</code>；也就是说不忽略任何值。 例如，传入:</p>
<pre><code>lambda x: x in " \t"</code></pre><p>如果你以字符序列的形式对行进行比较，并且不希望区分空格符或硬制表符。</p>
<p>可选参数 <em>a</em> 和 <em>b</em> 为要比较的序列；两者默认为空字符串。 两个序列的元素都必须为 hashable。</p>
<p>可选参数 <em>autojunk</em> 可用于启用自动垃圾启发式计算。</p>
<p>3.2 新版功能: <em>autojunk</em> 形参。</p>
<p>SequenceMatcher 对象接受三个数据属性: <em>bjunk</em> 是 <em>b</em> 当中 <em>isjunk</em> 为 <code>True</code> 的元素集合；<em>bpopular</em> 是被启发式计算（如果其未被禁用）视为热门候选的非垃圾元素集合；<em>b2j</em> 是将 <em>b</em> 当中剩余元素映射到一个它们出现位置列表的字典。 所有三个数据属性将在 <em>b</em> 通过 <code>set_seqs()</code> 或 <code>set_seq2()</code> 重置时被重置。</p>
<p>3.2 新版功能: <em>bjunk</em> 和 <em>bpopular</em> 属性。</p>
<p><code>SequenceMatcher</code> 对象具有以下方法：</p>
<ul>
<li><p><code>set_seqs</code>(<em>a</em>, <em>b</em>)</p>
<p>设置要比较的两个序列。</p>
</li>
</ul>
<p><code>SequenceMatcher</code> 计算并缓存有关第二个序列的详细信息，这样如果你想要将一个序列与多个序列进行比较，可使用 <code>set_seq2()</code> 一次性地设置该常用序列并重复地对每个其他序列各调用一次 <code>set_seq1()</code>。</p>
<ul>
<li><p><code>set_seq1</code>(<em>a</em>)</p>
<p>设置要比较的第一个序列。 要比较的第二个序列不会改变。</p>
</li>
<li><p><code>set_seq2</code>(<em>b</em>)</p>
<p>设置要比较的第二个序列。 要比较的第一个序列不会改变。</p>
</li>
<li><p><code>find_longest_match</code>(<em>alo=0</em>, <em>ahi=None</em>, <em>blo=0</em>, <em>bhi=None</em>)</p>
<p>找出 <code>a[alo:ahi]</code> 和 <code>b[blo:bhi]</code> 中的最长匹配块。</p>
<p>如果 <em>isjunk</em> 被省略或为 <code>None</code>，<code>find_longest_match()</code> 将返回 <code>(i, j, k)</code> 使得 <code>a[i:i+k]</code> 等于 <code>b[j:j+k]</code>，其中 <code>alo &lt;= i &lt;= i+k &lt;= ahi</code> 并且 <code>blo &lt;= j &lt;= j+k &lt;= bhi</code>。 对于所有满足这些条件的 <code>(i', j', k')</code>，如果 <code>i == i'</code>, <code>j &lt;= j'</code> 也被满足，则附加条件 <code>k &gt;= k'</code>, <code>i &lt;= i'</code>。 换句话说，对于所有最长匹配块，返回在 <em>a</em> 当中最先出现的一个，而对于在 <em>a</em> 当中最先出现的所有最长匹配块，则返回在 <em>b</em> 当中最先出现的一个。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> s <span class="token operator">=</span> SequenceMatcher<span class="token punctuation">(</span>None<span class="token punctuation">,</span> <span class="token string">" abcd"</span><span class="token punctuation">,</span> <span class="token string">"abcd abcd"</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> s<span class="token punctuation">.</span>find_longest_match<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">)</span>
Match<span class="token punctuation">(</span>a<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> b<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">,</span> size<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>如果提供了 <em>isjunk</em>，将按上述规则确定第一个最长匹配块，但额外附加不允许块内出现垃圾元素的限制。 然后将通过（仅）匹配两边的垃圾元素来尽可能地扩展该块。 这样结果块绝对不会匹配垃圾元素，除非同样的垃圾元素正好与有意义的匹配相邻。</p>
<p>这是与之前相同的例子，但是将空格符视为垃圾。 这将防止 <code>' abcd'</code> 直接与第二个序列末尾的 <code>' abcd'</code> 相匹配。 而只可以匹配 <code>'abcd'</code>，并且是匹配第二个序列最左边的 <code>'abcd'</code>：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> s <span class="token operator">=</span> SequenceMatcher<span class="token punctuation">(</span><span class="token keyword">lambda</span> x<span class="token punctuation">:</span> x<span class="token operator">==</span><span class="token string">" "</span><span class="token punctuation">,</span> <span class="token string">" abcd"</span><span class="token punctuation">,</span> <span class="token string">"abcd abcd"</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> s<span class="token punctuation">.</span>find_longest_match<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">)</span>
Match<span class="token punctuation">(</span>a<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> b<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> size<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>如果未找到匹配块，此方法将返回 <code>(alo, blo, 0)</code>。</p>
<p>此方法将返回一个 named tuple <code>Match(a, b, size)</code>。</p>
<p>在 3.9 版更改: 加入默认参数。</p>
</li>
<li><p><code>get_matching_blocks</code>()</p>
<p>返回描述非重叠匹配子序列的三元组列表。 每个三元组的形式为 <code>(i, j, n)</code>，其含义为 <code>a[i:i+n] == b[j:j+n]</code>。 这些三元组按 <em>i</em> 和 <em>j</em> 单调递增排列。</p>
<p>最后一个三元组用于占位，其值为 <code>(len(a), len(b), 0)</code>。 它是唯一 <code>n == 0</code> 的三元组。 如果 <code>(i, j, n)</code> 和 <code>(i', j', n')</code> 是在列表中相邻的三元组，且后者不是列表中的最后一个三元组，则 <code>i+n &lt; i'</code> 或 <code>j+n &lt; j'</code>；换句话说，相邻的三元组总是描述非相邻的相等块。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> s <span class="token operator">=</span> SequenceMatcher<span class="token punctuation">(</span>None<span class="token punctuation">,</span> <span class="token string">"abxcd"</span><span class="token punctuation">,</span> <span class="token string">"abcd"</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> s<span class="token punctuation">.</span>get_matching_blocks<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span>Match<span class="token punctuation">(</span>a<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> b<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> size<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> Match<span class="token punctuation">(</span>a<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">,</span> b<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span> size<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> Match<span class="token punctuation">(</span>a<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">,</span> b<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">,</span> size<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><code>get_opcodes</code>()</p>
<p>返回描述如何将 <em>a</em> 变为 <em>b</em> 的 5 元组列表，每个元组的形式为 <code>(tag, i1, i2, j1, j2)</code>。 在第一个元组中 <code>i1 == j1 == 0</code>，而在其余的元组中 <em>i1</em> 等于前一个元组的 <em>i2*，并且 *j1</em> 也等于前一个元组的 <em>j2</em>。</p>
<p><em>tag</em> 值为字符串，其含义如下：</p>
<table>
<thead>
<tr>
<th align="left">值</th>
<th align="left">含意</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>‘replace’</code></td>
<td align="left"><code>a[i1:i2]</code> 应由 <code>b[j1:j2]</code> 替换。</td>
</tr>
<tr>
<td align="left"><code>‘delete’</code></td>
<td align="left"><code>a[i1:i2]</code> 应被删除。 请注意在此情况下 <code>j1 == j2</code>。</td>
</tr>
<tr>
<td align="left"><code>‘insert’</code></td>
<td align="left"><code>b[j1:j2]</code> 应插入到 <code>a[i1:i1]</code>。 请注意在此情况下 <code>i1 == i2</code>。</td>
</tr>
<tr>
<td align="left"><code>‘equal’</code></td>
<td align="left"><code>a[i1:i2] == b[j1:j2]</code> (两个子序列相同)。</td>
</tr>
</tbody></table>
<p>例如：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> a <span class="token operator">=</span> <span class="token string">"qabxcd"</span>
<span class="token operator">>></span><span class="token operator">></span> b <span class="token operator">=</span> <span class="token string">"abycdf"</span>
<span class="token operator">>></span><span class="token operator">></span> s <span class="token operator">=</span> SequenceMatcher<span class="token punctuation">(</span>None<span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">for</span> tag<span class="token punctuation">,</span> i1<span class="token punctuation">,</span> i2<span class="token punctuation">,</span> j1<span class="token punctuation">,</span> j2 <span class="token keyword">in</span> s<span class="token punctuation">.</span>get_opcodes<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'{:7}   a[{}:{}] --> b[{}:{}] {!r:>8} --> {!r}'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         tag<span class="token punctuation">,</span> i1<span class="token punctuation">,</span> i2<span class="token punctuation">,</span> j1<span class="token punctuation">,</span> j2<span class="token punctuation">,</span> a<span class="token punctuation">[</span>i1<span class="token punctuation">:</span>i2<span class="token punctuation">]</span><span class="token punctuation">,</span> b<span class="token punctuation">[</span>j1<span class="token punctuation">:</span>j2<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
delete    a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span><span class="token operator">-</span><span class="token operator">></span> b<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span>      <span class="token string">'q'</span> <span class="token operator">-</span><span class="token operator">-</span><span class="token operator">></span> <span class="token string">''</span>
equal     a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">-</span><span class="token operator">-</span><span class="token operator">></span> b<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">]</span>     <span class="token string">'ab'</span> <span class="token operator">-</span><span class="token operator">-</span><span class="token operator">></span> <span class="token string">'ab'</span>
replace   a<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">-</span><span class="token operator">-</span><span class="token operator">></span> b<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span>      <span class="token string">'x'</span> <span class="token operator">-</span><span class="token operator">-</span><span class="token operator">></span> <span class="token string">'y'</span>
equal     a<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">:</span><span class="token number">6</span><span class="token punctuation">]</span> <span class="token operator">-</span><span class="token operator">-</span><span class="token operator">></span> b<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">5</span><span class="token punctuation">]</span>     <span class="token string">'cd'</span> <span class="token operator">-</span><span class="token operator">-</span><span class="token operator">></span> <span class="token string">'cd'</span>
insert    a<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">:</span><span class="token number">6</span><span class="token punctuation">]</span> <span class="token operator">-</span><span class="token operator">-</span><span class="token operator">></span> b<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">:</span><span class="token number">6</span><span class="token punctuation">]</span>       <span class="token string">''</span> <span class="token operator">-</span><span class="token operator">-</span><span class="token operator">></span> <span class="token string">'f'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><code>get_grouped_opcodes</code>(<em>n=3</em>)</p>
<p>返回一个带有最多 <em>n</em> 行上下文的分组的 generator。</p>
<p>从 <code>get_opcodes()</code> 所返回的组开始，此方法会拆分出较小的更改簇并消除没有更改的间隔区域。</p>
<p>这些分组以与 <code>get_opcodes()</code> 相同的格式返回。</p>
</li>
<li><p><code>ratio</code>()</p>
<p>返回一个取值范围 [0, 1] 的浮点数作为序列相似性度量。</p>
<p>其中 T 是两个序列中元素的总数量，M 是匹配的数量，即 2.0*M / T。 请注意如果两个序列完全相同则该值为 <code>1.0</code>，如果两者完全不同则为 <code>0.0</code>。</p>
<p>如果 <code>get_matching_blocks()</code> 或 <code>get_opcodes()</code> 尚未被调用则此方法运算消耗较大，在此情况下你可能需要先调用 <code>quick_ratio()</code> 或 <code>real_quick_ratio()</code> 来获取一个上界。</p>
<p>注解</p>
<p>注意: <code>ratio()</code> 调用的结果可能会取决于参数的顺序。 例如:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> SequenceMatcher<span class="token punctuation">(</span>None<span class="token punctuation">,</span> <span class="token string">'tide'</span><span class="token punctuation">,</span> <span class="token string">'diet'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>ratio<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token number">0.25</span>
<span class="token operator">>></span><span class="token operator">></span> SequenceMatcher<span class="token punctuation">(</span>None<span class="token punctuation">,</span> <span class="token string">'diet'</span><span class="token punctuation">,</span> <span class="token string">'tide'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>ratio<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token number">0.5</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><code>quick_ratio</code>()</p>
<p>相对快速地返回一个 <code>ratio()</code> 的上界。</p>
</li>
<li><p><code>real_quick_ratio</code>()</p>
<p>非常快速地返回一个 <code>ratio()</code> 的上界。</p>
</li>
</ul>
<p>这三个返回匹配部分占字符总数的比率的方法可能由于不同的近似级别而给出不一样的结果，但是 <code>quick_ratio()</code> 和 <code>real_quick_ratio()</code> 总是会至少与 <code>ratio()</code> 一样大：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> s <span class="token operator">=</span> SequenceMatcher<span class="token punctuation">(</span>None<span class="token punctuation">,</span> <span class="token string">"abcd"</span><span class="token punctuation">,</span> <span class="token string">"bcde"</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> s<span class="token punctuation">.</span>ratio<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token number">0.75</span>
<span class="token operator">>></span><span class="token operator">></span> s<span class="token punctuation">.</span>quick_ratio<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token number">0.75</span>
<span class="token operator">>></span><span class="token operator">></span> s<span class="token punctuation">.</span>real_quick_ratio<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token number">1.0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="SequenceMatcher-的示例"><a href="#SequenceMatcher-的示例" class="headerlink" title="SequenceMatcher 的示例"></a>SequenceMatcher 的示例</h3><p>以下示例比较两个字符串，并将空格视为“垃圾”：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> s <span class="token operator">=</span> SequenceMatcher<span class="token punctuation">(</span><span class="token keyword">lambda</span> x<span class="token punctuation">:</span> x <span class="token operator">==</span> <span class="token string">" "</span><span class="token punctuation">,</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                     <span class="token string">"private Thread currentThread;"</span><span class="token punctuation">,</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                     <span class="token string">"private volatile Thread currentThread;"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p><code>ratio()</code> 返回一个 [0, 1] 范围内的整数作为两个序列相似性的度量。 根据经验，<code>ratio()</code> 值超过 0.6 就意味着两个序列是近似匹配的：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>round<span class="token punctuation">(</span>s<span class="token punctuation">.</span>ratio<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token number">0.866</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>如果你只对两个序列相匹配的位置感兴趣，则 <code>get_matching_blocks()</code> 就很方便：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">for</span> block <span class="token keyword">in</span> s<span class="token punctuation">.</span>get_matching_blocks<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"a[%d] and b[%d] match for %d elements"</span> <span class="token operator">%</span> block<span class="token punctuation">)</span>
a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">and</span> b<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> match <span class="token keyword">for</span> <span class="token number">8</span> elements
a<span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span> <span class="token operator">and</span> b<span class="token punctuation">[</span><span class="token number">17</span><span class="token punctuation">]</span> match <span class="token keyword">for</span> <span class="token number">21</span> elements
a<span class="token punctuation">[</span><span class="token number">29</span><span class="token punctuation">]</span> <span class="token operator">and</span> b<span class="token punctuation">[</span><span class="token number">38</span><span class="token punctuation">]</span> match <span class="token keyword">for</span> <span class="token number">0</span> elements<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>请注意 <code>get_matching_blocks()</code> 返回的最后一个元组总是只用于占位的 <code>(len(a), len(b), 0)</code>，这也是元组末尾元素（匹配的元素数量）为 <code>0</code> 的唯一情况。</p>
<p>如果你想要知道如何将第一个序列转成第二个序列，可以使用 <code>get_opcodes()</code>:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">for</span> opcode <span class="token keyword">in</span> s<span class="token punctuation">.</span>get_opcodes<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"%6s a[%d:%d] b[%d:%d]"</span> <span class="token operator">%</span> opcode<span class="token punctuation">)</span>
 equal a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token number">8</span><span class="token punctuation">]</span> b<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token number">8</span><span class="token punctuation">]</span>
insert a<span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">:</span><span class="token number">8</span><span class="token punctuation">]</span> b<span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">:</span><span class="token number">17</span><span class="token punctuation">]</span>
 equal a<span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">:</span><span class="token number">29</span><span class="token punctuation">]</span> b<span class="token punctuation">[</span><span class="token number">17</span><span class="token punctuation">:</span><span class="token number">38</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>参见</p>
<ul>
<li>此模块中的 <code>get_close_matches()</code> 函数显示了如何基于 <code>SequenceMatcher</code> 构建简单的代码来执行有用的功能。</li>
<li>使用 <code>SequenceMatcher</code> 构建小型应用的 简易版本控制方案。</li>
</ul>
<h3 id="Differ-对象"><a href="#Differ-对象" class="headerlink" title="Differ 对象"></a>Differ 对象</h3><p>请注意 <code>Differ</code> 所生成的增量并不保证是 <strong>最小</strong> 差异。 相反，最小差异往往是违反直觉的，因为它们会同步任何可能的地方，有时甚至意外产生相距 100 页的匹配。 将同步点限制为连续匹配保留了一些局部性概念，这偶尔会带来产生更长差异的代价。</p>
<p><code>Differ</code> 类具有这样的构造器：</p>
<p><em>class</em> <code>difflib.Differ</code>(<em>linejunk=None</em>, <em>charjunk=None</em>)</p>
<p>可选关键字形参 <em>linejunk</em> 和 <em>charjunk</em> 均为过滤函数 (或为 <code>None</code>)：</p>
<p><em>linejunk</em>: 接受单个字符串作为参数的函数，如果其为垃圾字符串则返回真值。 默认值为 <code>None</code>，意味着没有任何行会被视为垃圾行。</p>
<p><em>charjunk</em>: 接受单个字符（长度为 1 的字符串）作为参数的函数，如果其为垃圾字符则返回真值。 默认值为 <code>None</code>，意味着没有任何字符会被视为垃圾字符。</p>
<p>这些垃圾过滤函数可加快查找差异的匹配速度，并且不会导致任何差异行或字符被忽略。 </p>
<p><code>Differ</code> 对象是通过一个单独方法来使用（生成增量）的：</p>
<ul>
<li><p><code>compare</code>(<em>a</em>, <em>b</em>)</p>
<p>比较两个由行组成的序列，并生成增量（一个由行组成的序列）。</p>
<p>每个序列必须包含一个以换行符结尾的单行字符串。 这样的序列可以通过文件类对象的 <code>readlines()</code> 方法来获取。 所生成的增量同样由以换行符结尾的字符串构成，可以通过文件类对象的 <code>writelines()</code> 方法原样打印出来。</p>
</li>
</ul>
<h3 id="Differ-示例"><a href="#Differ-示例" class="headerlink" title="Differ 示例"></a>Differ 示例</h3><p>此示例比较两段文本。 首先我们设置文本为以换行符结尾的单行字符串构成的序列（这样的序列也可以通过文件类对象的 <code>readlines()</code> 方法来获取）：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> text1 <span class="token operator">=</span> <span class="token triple-quoted-string string">'''  1. Beautiful is better than ugly.
...   2. Explicit is better than implicit.
...   3. Simple is better than complex.
...   4. Complex is better than complicated.
... '''</span><span class="token punctuation">.</span>splitlines<span class="token punctuation">(</span>keepends<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> len<span class="token punctuation">(</span>text1<span class="token punctuation">)</span>
<span class="token number">4</span>
<span class="token operator">>></span><span class="token operator">></span> text1<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>
<span class="token string">'\n'</span>
<span class="token operator">>></span><span class="token operator">></span> text2 <span class="token operator">=</span> <span class="token triple-quoted-string string">'''  1. Beautiful is better than ugly.
...   3.   Simple is better than complex.
...   4. Complicated is better than complex.
...   5. Flat is better than nested.
... '''</span><span class="token punctuation">.</span>splitlines<span class="token punctuation">(</span>keepends<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>接下来我们实例化一个 Differ 对象：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> d <span class="token operator">=</span> Differ<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>请注意在实例化 <code>Differ</code> 对象时我们可以传入函数来过滤掉“垃圾”行和字符。 </p>
<p>最后，我们比较两个序列：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> result <span class="token operator">=</span> list<span class="token punctuation">(</span>d<span class="token punctuation">.</span>compare<span class="token punctuation">(</span>text1<span class="token punctuation">,</span> text2<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><code>result</code> 是一个字符串列表，让我们将其美化打印出来：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> pprint <span class="token keyword">import</span> pprint
<span class="token operator">>></span><span class="token operator">></span> pprint<span class="token punctuation">(</span>result<span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token string">'    1. Beautiful is better than ugly.\n'</span><span class="token punctuation">,</span>
 <span class="token string">'-   2. Explicit is better than implicit.\n'</span><span class="token punctuation">,</span>
 <span class="token string">'-   3. Simple is better than complex.\n'</span><span class="token punctuation">,</span>
 <span class="token string">'+   3.   Simple is better than complex.\n'</span><span class="token punctuation">,</span>
 <span class="token string">'?     ++\n'</span><span class="token punctuation">,</span>
 <span class="token string">'-   4. Complex is better than complicated.\n'</span><span class="token punctuation">,</span>
 <span class="token string">'?            ^                     ---- ^\n'</span><span class="token punctuation">,</span>
 <span class="token string">'+   4. Complicated is better than complex.\n'</span><span class="token punctuation">,</span>
 <span class="token string">'?           ++++ ^                      ^\n'</span><span class="token punctuation">,</span>
 <span class="token string">'+   5. Flat is better than nested.\n'</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>作为单独的多行字符串显示出来则是这样：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> sys
<span class="token operator">>></span><span class="token operator">></span> sys<span class="token punctuation">.</span>stdout<span class="token punctuation">.</span>writelines<span class="token punctuation">(</span>result<span class="token punctuation">)</span>
    <span class="token number">1</span><span class="token punctuation">.</span> Beautiful <span class="token keyword">is</span> better than ugly<span class="token punctuation">.</span>
<span class="token operator">-</span>   <span class="token number">2</span><span class="token punctuation">.</span> Explicit <span class="token keyword">is</span> better than implicit<span class="token punctuation">.</span>
<span class="token operator">-</span>   <span class="token number">3</span><span class="token punctuation">.</span> Simple <span class="token keyword">is</span> better than complex<span class="token punctuation">.</span>
<span class="token operator">+</span>   <span class="token number">3</span><span class="token punctuation">.</span>   Simple <span class="token keyword">is</span> better than complex<span class="token punctuation">.</span>
?     <span class="token operator">+</span><span class="token operator">+</span>
<span class="token operator">-</span>   <span class="token number">4</span><span class="token punctuation">.</span> Complex <span class="token keyword">is</span> better than complicated<span class="token punctuation">.</span>
?            <span class="token operator">^</span>                     <span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span> <span class="token operator">^</span>
<span class="token operator">+</span>   <span class="token number">4</span><span class="token punctuation">.</span> Complicated <span class="token keyword">is</span> better than complex<span class="token punctuation">.</span>
?           <span class="token operator">+</span><span class="token operator">+</span><span class="token operator">+</span><span class="token operator">+</span> <span class="token operator">^</span>                      <span class="token operator">^</span>
<span class="token operator">+</span>   <span class="token number">5</span><span class="token punctuation">.</span> Flat <span class="token keyword">is</span> better than nested<span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="difflib-的命令行接口"><a href="#difflib-的命令行接口" class="headerlink" title="difflib 的命令行接口"></a>difflib 的命令行接口</h3><p>这个实例演示了如何使用 difflib 来创建一个类似于 <code>diff</code> 的工具。 它同样包含在 Python 源码发布包中，文件名为 <code>Tools/scripts/diff.py</code>。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true">#!/usr/bin/env python3</span>
<span class="token triple-quoted-string string">""" Command line interface to difflib.py providing diffs in four formats:
* ndiff:    lists every line and highlights interline changes.
* context:  highlights clusters of changes in a before/after format.
* unified:  highlights clusters of changes in an inline format.
* html:     generates side by side comparison with change highlights.
"""</span>
<span class="token keyword">import</span> sys<span class="token punctuation">,</span> os<span class="token punctuation">,</span> difflib<span class="token punctuation">,</span> argparse
<span class="token keyword">from</span> datetime <span class="token keyword">import</span> datetime<span class="token punctuation">,</span> timezone
<span class="token keyword">def</span> <span class="token function">file_mtime</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">:</span>
    t <span class="token operator">=</span> datetime<span class="token punctuation">.</span>fromtimestamp<span class="token punctuation">(</span>os<span class="token punctuation">.</span>stat<span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">.</span>st_mtime<span class="token punctuation">,</span>
                               timezone<span class="token punctuation">.</span>utc<span class="token punctuation">)</span>
    <span class="token keyword">return</span> t<span class="token punctuation">.</span>astimezone<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>isoformat<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    parser <span class="token operator">=</span> argparse<span class="token punctuation">.</span>ArgumentParser<span class="token punctuation">(</span><span class="token punctuation">)</span>
    parser<span class="token punctuation">.</span>add_argument<span class="token punctuation">(</span><span class="token string">'-c'</span><span class="token punctuation">,</span> action<span class="token operator">=</span><span class="token string">'store_true'</span><span class="token punctuation">,</span> default<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">,</span>
                        help<span class="token operator">=</span><span class="token string">'Produce a context format diff (default)'</span><span class="token punctuation">)</span>
    parser<span class="token punctuation">.</span>add_argument<span class="token punctuation">(</span><span class="token string">'-u'</span><span class="token punctuation">,</span> action<span class="token operator">=</span><span class="token string">'store_true'</span><span class="token punctuation">,</span> default<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">,</span>
                        help<span class="token operator">=</span><span class="token string">'Produce a unified format diff'</span><span class="token punctuation">)</span>
    parser<span class="token punctuation">.</span>add_argument<span class="token punctuation">(</span><span class="token string">'-m'</span><span class="token punctuation">,</span> action<span class="token operator">=</span><span class="token string">'store_true'</span><span class="token punctuation">,</span> default<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">,</span>
                        help<span class="token operator">=</span><span class="token string">'Produce HTML side by side diff '</span>
                             <span class="token string">'(can use -c and -l in conjunction)'</span><span class="token punctuation">)</span>
    parser<span class="token punctuation">.</span>add_argument<span class="token punctuation">(</span><span class="token string">'-n'</span><span class="token punctuation">,</span> action<span class="token operator">=</span><span class="token string">'store_true'</span><span class="token punctuation">,</span> default<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">,</span>
                        help<span class="token operator">=</span><span class="token string">'Produce a ndiff format diff'</span><span class="token punctuation">)</span>
    parser<span class="token punctuation">.</span>add_argument<span class="token punctuation">(</span><span class="token string">'-l'</span><span class="token punctuation">,</span> <span class="token string">'--lines'</span><span class="token punctuation">,</span> type<span class="token operator">=</span>int<span class="token punctuation">,</span> default<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">,</span>
                        help<span class="token operator">=</span><span class="token string">'Set number of context lines (default 3)'</span><span class="token punctuation">)</span>
    parser<span class="token punctuation">.</span>add_argument<span class="token punctuation">(</span><span class="token string">'fromfile'</span><span class="token punctuation">)</span>
    parser<span class="token punctuation">.</span>add_argument<span class="token punctuation">(</span><span class="token string">'tofile'</span><span class="token punctuation">)</span>
    options <span class="token operator">=</span> parser<span class="token punctuation">.</span>parse_args<span class="token punctuation">(</span><span class="token punctuation">)</span>
    n <span class="token operator">=</span> options<span class="token punctuation">.</span>lines
    fromfile <span class="token operator">=</span> options<span class="token punctuation">.</span>fromfile
    tofile <span class="token operator">=</span> options<span class="token punctuation">.</span>tofile
    fromdate <span class="token operator">=</span> file_mtime<span class="token punctuation">(</span>fromfile<span class="token punctuation">)</span>
    todate <span class="token operator">=</span> file_mtime<span class="token punctuation">(</span>tofile<span class="token punctuation">)</span>
    <span class="token keyword">with</span> open<span class="token punctuation">(</span>fromfile<span class="token punctuation">)</span> <span class="token keyword">as</span> ff<span class="token punctuation">:</span>
        fromlines <span class="token operator">=</span> ff<span class="token punctuation">.</span>readlines<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">with</span> open<span class="token punctuation">(</span>tofile<span class="token punctuation">)</span> <span class="token keyword">as</span> tf<span class="token punctuation">:</span>
        tolines <span class="token operator">=</span> tf<span class="token punctuation">.</span>readlines<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> options<span class="token punctuation">.</span>u<span class="token punctuation">:</span>
        diff <span class="token operator">=</span> difflib<span class="token punctuation">.</span>unified_diff<span class="token punctuation">(</span>fromlines<span class="token punctuation">,</span> tolines<span class="token punctuation">,</span> fromfile<span class="token punctuation">,</span> tofile<span class="token punctuation">,</span> fromdate<span class="token punctuation">,</span> todate<span class="token punctuation">,</span> n<span class="token operator">=</span>n<span class="token punctuation">)</span>
    <span class="token keyword">elif</span> options<span class="token punctuation">.</span>n<span class="token punctuation">:</span>
        diff <span class="token operator">=</span> difflib<span class="token punctuation">.</span>ndiff<span class="token punctuation">(</span>fromlines<span class="token punctuation">,</span> tolines<span class="token punctuation">)</span>
    <span class="token keyword">elif</span> options<span class="token punctuation">.</span>m<span class="token punctuation">:</span>
        diff <span class="token operator">=</span> difflib<span class="token punctuation">.</span>HtmlDiff<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>make_file<span class="token punctuation">(</span>fromlines<span class="token punctuation">,</span>tolines<span class="token punctuation">,</span>fromfile<span class="token punctuation">,</span>tofile<span class="token punctuation">,</span>context<span class="token operator">=</span>options<span class="token punctuation">.</span>c<span class="token punctuation">,</span>numlines<span class="token operator">=</span>n<span class="token punctuation">)</span>
    <span class="token keyword">else</span><span class="token punctuation">:</span>
        diff <span class="token operator">=</span> difflib<span class="token punctuation">.</span>context_diff<span class="token punctuation">(</span>fromlines<span class="token punctuation">,</span> tolines<span class="token punctuation">,</span> fromfile<span class="token punctuation">,</span> tofile<span class="token punctuation">,</span> fromdate<span class="token punctuation">,</span> todate<span class="token punctuation">,</span> n<span class="token operator">=</span>n<span class="token punctuation">)</span>
    sys<span class="token punctuation">.</span>stdout<span class="token punctuation">.</span>writelines<span class="token punctuation">(</span>diff<span class="token punctuation">)</span>
<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>
    main<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="textwrap-—-文本自动换行与填充"><a href="#textwrap-—-文本自动换行与填充" class="headerlink" title="textwrap —- 文本自动换行与填充"></a><code>textwrap</code> —- 文本自动换行与填充</h2><p><strong>源代码:</strong> <a href="https://github.com/python/cpython/tree/3.10/Lib/textwrap.py" target="_blank" rel="noopener">Lib/textwrap.py</a></p>
<hr>
<p><code>textwrap</code> 模块提供了一些快捷函数，以及可以完成所有工作的类 <code>TextWrapper</code>。 如果你只是要对一两个文本字符串进行自动换行或填充，快捷函数应该就够用了；否则的话，你应该使用 <code>TextWrapper</code> 的实例来提高效率。</p>
<p><code>textwrap.wrap</code>(<em>text</em>, <em>width=70</em>, <em>**,</em> initial_indent=’’<em>,</em> subsequent_indent=’’<em>,</em> expand_tabs=True<em>,</em> replace_whitespace=True<em>,</em> fix_sentence_endings=False<em>,</em> break_long_words=True<em>,</em> drop_whitespace=True<em>,</em> break_on_hyphens=True<em>,</em> tabsize=8<em>,</em> max_lines=None*)</p>
<p>对 <em>text</em> (字符串) 中的单独段落自动换行以使每行长度最多为 <em>width</em> 个字符。 返回由输出行组成的列表，行尾不带换行符。</p>
<p>与 <code>TextWrapper</code> 的实例属性对应的可选的关键字参数，具体文档见下。</p>
<p><code>textwrap.fill</code>(<em>text</em>, <em>width=70</em>, <em>**,</em> initial_indent=’’<em>,</em> subsequent_indent=’’<em>,</em> expand_tabs=True<em>,</em> replace_whitespace=True<em>,</em> fix_sentence_endings=False<em>,</em> break_long_words=True<em>,</em> drop_whitespace=True<em>,</em> break_on_hyphens=True<em>,</em> tabsize=8<em>,</em> max_lines=None*)</p>
<p>对 <em>text</em> 中的单独段落自动换行，并返回一个包含被自动换行段落的单独字符串。 <code>fill()</code> 是以下语句的快捷方式</p>
<pre><code>"\n".join(wrap(text, ...))</code></pre><p>特别要说明的是，<code>fill()</code> 接受与 <code>wrap()</code> 完全相同的关键字参数。</p>
<p><code>textwrap.shorten</code>(<em>text</em>, <em>width</em>, <em>**,</em> fix_sentence_endings=False<em>,</em> break_long_words=True<em>,</em> break_on_hyphens=True<em>,</em> placeholder=’ […]‘*)</p>
<p>折叠并截短给定的 <em>text</em> 以符合给定的 <em>width</em>。</p>
<p>首先，将折叠 <em>text</em> 中的空格（所有连续空格替换为单个空格）。 如果结果能适合 <em>width</em> 则将其返回。 否则将丢弃足够数量的末尾单词以使得剩余单词加 <code>placeholder</code> 能适合 <code>width</code>：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> textwrap<span class="token punctuation">.</span>shorten<span class="token punctuation">(</span><span class="token string">"Hello  world!"</span><span class="token punctuation">,</span> width<span class="token operator">=</span><span class="token number">12</span><span class="token punctuation">)</span>
<span class="token string">'Hello world!'</span>
<span class="token operator">>></span><span class="token operator">></span> textwrap<span class="token punctuation">.</span>shorten<span class="token punctuation">(</span><span class="token string">"Hello  world!"</span><span class="token punctuation">,</span> width<span class="token operator">=</span><span class="token number">11</span><span class="token punctuation">)</span>
<span class="token string">'Hello [...]'</span>
<span class="token operator">>></span><span class="token operator">></span> textwrap<span class="token punctuation">.</span>shorten<span class="token punctuation">(</span><span class="token string">"Hello world"</span><span class="token punctuation">,</span> width<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">,</span> placeholder<span class="token operator">=</span><span class="token string">"..."</span><span class="token punctuation">)</span>
<span class="token string">'Hello...'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可选的关键字参数对应于 <code>TextWrapper</code> 的实际属性，具体见下文。 请注意文本在被传入 <code>TextWrapper</code> 的 <code>fill()</code> 函数之前会被折叠，因此改变 <code>tabsize</code>, <code>expand_tabs</code>, <code>drop_whitespace</code> 和 <code>replace_whitespace</code> 的值将没有任何效果。</p>
<p>3.4 新版功能.</p>
<p><code>textwrap.dedent</code>(<em>text</em>)</p>
<p>移除 <em>text</em> 中每一行的任何相同前缀空白符。</p>
<p>这可以用来清除三重引号字符串行左侧空格，而仍然在源码中显示为缩进格式。</p>
<p>请注意制表符和空格符都被视为是空白符，但它们并不相等：以下两行 <code>" hello"</code> 和 <code>"\thello"</code> 不会被视为具有相同的前缀空白符。</p>
<p>只包含空白符的行会在输入时被忽略并在输出时被标准化为单个换行符。</p>
<p>例如：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token comment" spellcheck="true"># end first line with \ to avoid the empty line!</span>
    s <span class="token operator">=</span> <span class="token triple-quoted-string string">'''\
    hello
      world
    '''</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>repr<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span>          <span class="token comment" spellcheck="true"># prints '    hello\n      world\n    '</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>repr<span class="token punctuation">(</span>dedent<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># prints 'hello\n  world\n'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>textwrap.indent</code>(<em>text</em>, <em>prefix</em>, <em>predicate=None</em>)</p>
<p>将 <em>prefix</em> 添加到 <em>text</em> 中选定行的开头。</p>
<p>通过调用 <code>text.splitlines(True)</code> 来对行进行拆分。</p>
<p>默认情况下，<em>prefix</em> 会被添加到所有不是只由空白符（包括任何行结束符）组成的行。</p>
<p>例如：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> s <span class="token operator">=</span> <span class="token string">'hello\n\n \nworld'</span>
<span class="token operator">>></span><span class="token operator">></span> indent<span class="token punctuation">(</span>s<span class="token punctuation">,</span> <span class="token string">'  '</span><span class="token punctuation">)</span>
<span class="token string">'  hello\n\n \n  world'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>可选的 <em>predicate</em> 参数可用来控制哪些行要缩进。 例如，可以很容易地为空行或只有空白符的行添加 <em>prefix</em>:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>indent<span class="token punctuation">(</span>s<span class="token punctuation">,</span> <span class="token string">'+ '</span><span class="token punctuation">,</span> <span class="token keyword">lambda</span> line<span class="token punctuation">:</span> <span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token operator">+</span> hello
<span class="token operator">+</span>
<span class="token operator">+</span>
<span class="token operator">+</span> world<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>3.3 新版功能.</p>
<p><code>wrap()</code>, <code>fill()</code> 和 <code>shorten()</code> 的作用方式为创建一个 <code>TextWrapper</code> 实例并在其上调用单个方法。 该实例不会被重用，因此对于要使用 <code>wrap()</code> 和/或 <code>fill()</code> 来处理许多文本字符串的应用来说，创建你自己的 <code>TextWrapper</code> 对象可能会更有效率。</p>
<p>文本最好在空白符位置自动换行，包括带连字符单词的连字符之后；长单词仅在必要时会被拆分，除非 <code>TextWrapper.break_long_words</code> 被设为假值。</p>
<p><em>class</em> <code>textwrap.TextWrapper</code>(<em>**kwargs</em>)</p>
<p><code>TextWrapper</code> 构造器接受多个可选的关键字参数。 每个关键字参数对应一个实例属性，比如说</p>
<pre class="line-numbers language-python"><code class="language-python">wrapper <span class="token operator">=</span> TextWrapper<span class="token punctuation">(</span>initial_indent<span class="token operator">=</span><span class="token string">"* "</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>相当于：</p>
<pre class="line-numbers language-python"><code class="language-python">wrapper <span class="token operator">=</span> TextWrapper<span class="token punctuation">(</span><span class="token punctuation">)</span>
wrapper<span class="token punctuation">.</span>initial_indent <span class="token operator">=</span> <span class="token string">"* "</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>你可以多次重用相同的 <code>TextWrapper</code> 对象，并且你也可以在使用期间通过直接向实例属性赋值来修改它的任何选项。</p>
<p><code>TextWrapper</code> 的实例属性（以及构造器的关键字参数）如下所示：</p>
<ul>
<li><p><code>width</code></p>
<p>(默认: <code>70</code>) 自动换行的最大行长度。 只要输入文本中没有长于 <code>width</code> 的单个单词，<code>TextWrapper</code> 就能保证没有长于 <code>width</code> 个字符的输出行。</p>
</li>
<li><p><code>expand_tabs</code></p>
<p>(默认: <code>True</code>) 如果为真值，则 <em>text</em> 中所有的制表符将使用 <em>text</em> 的 <code>expandtabs()</code> 方法扩展为空格符。</p>
</li>
<li><p><code>tabsize</code></p>
<p>(默认: <code>8</code>) 如果 <code>expand_tabs</code> 为真值，则 <em>text</em> 中所有的制表符将扩展为零个或多个空格，具体取决于当前列位置和给定的制表宽度。</p>
<p>3.3 新版功能.</p>
</li>
<li><p><code>replace_whitespace</code></p>
<p>(default: <code>True</code>) 如果为真值，在制表符扩展之后、自动换行之前，<code>wrap()</code> 方法将把每个空白字符都替换为单个空格。 会被替换的空白字符如下：制表，换行，垂直制表，进纸和回车 (<code>'\t\n\v\f\r'</code>)。</p>
<p>注解</p>
<p>如果 <code>expand_tabs</code> 为假值且 <code>replace_whitespace</code> 为真值，每个制表符将被替换为单个空格，这与制表符扩展是 <em>不</em> 一样的。</p>
<p>注解</p>
<p>如果 <code>replace_whitespace</code> 为假值，在一行的中间有可能出现换行符并导致怪异的输出。 因此，文本应当（使用 <code>str.splitlines()</code> 或类似方法）拆分为段落并分别进行自动换行。</p>
</li>
<li><p><code>drop_whitespace</code></p>
<p>(默认: <code>True</code>) 如果为真值，每一行开头和末尾的空白字符（在包装之后、缩进之前）会被丢弃。 但是段落开头的空白字符如果后面不带任何非空白字符则不会被丢弃。 如果被丢弃的空白字符占据了一个整行，则该整行将被丢弃。</p>
</li>
<li><p><code>initial_indent</code></p>
<p>(默认: <code>''</code>) 将被添加到被自动换行输出内容的第一行的字符串。 其长度会被计入第一行的长度。 空字符串不会被缩进。</p>
</li>
<li><p><code>subsequent_indent</code></p>
<p>(default: <code>''</code>) 将被添加到被自动换行输出内容除第一行外的所有行的字符串。 其长度会被计入除行一行外的所有行的长度。</p>
</li>
<li><p><code>fix_sentence_endings</code></p>
<p>(默认: <code>False</code>) 如果为真值，<code>TextWrapper</code> 将尝试检测句子结尾并确保句子间总是以恰好两个空格符分隔。 对于使用等宽字体的文本来说通常都需要这样。 但是，句子检测算法并不完美：它假定句子结尾是一个小写字母加字符 <code>'.'</code>, <code>'!'</code> 或 <code>'?'</code> 中的一个，并可能带有字符 <code>'"'</code> 或 <code>"'"</code>，最后以一个空格结束。 此算法的问题之一是它无法区分以下文本中的 “Dr.”</p>
<pre><code>[...] Dr. Frankenstein's monster [...]</code></pre><p>和以下文本中的 “Spot.”</p>
<pre><code>[...] See Spot. See Spot run [...]</code></pre><p><code>fix_sentence_endings</code> 默认为假值。</p>
<p>由于句子检测算法依赖于 <code>string.lowercase</code> 来确定“小写字母”，以及约定在句点后使用两个空格来分隔处于同一行的句子，因此只适用于英语文本。</p>
</li>
<li><p><code>break_long_words</code></p>
<p>(默认: <code>True</code>) 如果为真值，则长度超过 <code>width</code> 的单词将被分开以保证行的长度不会超过 <code>width</code>。 如果为假值，超长单词不会被分开，因而某些行的长度可能会超过 <code>width</code>。 （超长单词将被单独作为一行，以尽量减少超出 <code>width</code> 的情况。）</p>
</li>
<li><p><code>break_on_hyphens</code></p>
<p>(默认: <code>True</code>) 如果为真值，将根据英语的惯例首选在空白符和复合词的连字符之后自动换行。 如果为假值，则只有空白符会被视为合适的潜在断行位置，但如果你确实不希望出现分开的单词则你必须将 <code>break_long_words</code> 设为假值。 之前版本的默认行为总是允许分开带有连字符的单词。</p>
</li>
<li><p><code>max_lines</code></p>
<p>(默认: <code>None</code>) 如果不为 <code>None</code>，则输出内容将最多包含 <em>max_lines</em> 行，并使 <em>placeholder</em> 出现在输出内容的末尾。</p>
<p>3.4 新版功能.</p>
</li>
<li><p><code>placeholder</code></p>
<p>(默认: <code>' [...]'</code>) 该文本将在输出文本被截短时出现在文本末尾。</p>
<p>3.4 新版功能.</p>
</li>
</ul>
<p><code>TextWrapper</code> 还提供了一些公有方法，类似于模块层级的便捷函数：</p>
<ul>
<li><p><code>wrap</code>(<em>text</em>)</p>
<p>对 <em>text</em> (字符串) 中的单独段落自动换行以使每行长度最多为 <code>width</code> 个字符。 所有自动换行选项均获取自 <code>TextWrapper</code> 实例的实例属性。 返回由输出行组成的列表，行尾不带换行符。 如果自动换行输出结果没有任何内容，则返回空列表。</p>
</li>
<li><p><code>fill</code>(<em>text</em>)</p>
<p>对 <em>text</em> 中的单独段落自动换行并返回包含被自动换行段落的单独字符串。</p>
</li>
</ul>
<h2 id="unicodedata-—-Unicode-数据库"><a href="#unicodedata-—-Unicode-数据库" class="headerlink" title="unicodedata —- Unicode 数据库"></a><code>unicodedata</code> —- Unicode 数据库</h2><p>此模块提供了对 Unicode Character Database (UCD) 的访问，其中定义了所有 Unicode 字符的字符属性。 此数据库中包含的数据编译自 <a href="https://www.unicode.org/Public/13.0.0/ucd" target="_blank" rel="noopener">UCD 版本 13.0.0</a>。</p>
<p>该模块使用与 Unicode 标准附件 #44 <a href="https://www.unicode.org/reports/tr44/" target="_blank" rel="noopener">“Unicode 字符数据库”</a> 中所定义的相同名称和符号。 它定义了以下函数：</p>
<p><code>unicodedata.lookup</code>(<em>name</em>)</p>
<p>按名称查找字符。如果找到具有给定名称的字符，则返回相应的字符。 如果没有找到，则 <code>KeyError</code> 被引发。</p>
<p>在 3.3 版更改: 已添加对名称<a href="https://www.unicode.org/Public/13.0.0/ucd/NameAliases.txt" target="_blank" rel="noopener">别名</a> 和<a href="https://www.unicode.org/Public/13.0.0/ucd/NamedSequences.txt" target="_blank" rel="noopener">命名序列</a> 的支持。</p>
<p><code>unicodedata.name</code>(<em>chr</em>[, <em>default</em>])</p>
<p>返回分配给字符 <em>chr</em> 的名称作为字符串。如果没有定义名称，则返回 <em>default</em> ，如果没有给出，则 <code>ValueError</code> 被引发。</p>
<p><code>unicodedata.decimal</code>(<em>chr</em>[, <em>default</em>])</p>
<p>返回分配给字符 <em>chr</em> 的十进制值作为整数。 如果没有定义这样的值，则返回 <em>default</em> ，如果没有给出，则 <code>ValueError</code> 被引发。</p>
<p><code>unicodedata.digit</code>(<em>chr</em>[, <em>default</em>])</p>
<p>返回分配给字符 <em>chr</em> 的数字值作为整数。 如果没有定义这样的值，则返回 <em>default</em> ，如果没有给出，则 <code>ValueError</code> 被引发。</p>
<p><code>unicodedata.numeric</code>(<em>chr</em>[, <em>default</em>])</p>
<p>返回分配给字符 <em>chr</em> 的数值作为浮点数。 如果没有定义这样的值，则返回 <em>default</em> ，如果没有给出，则 <code>ValueError</code> 被引发。</p>
<p><code>unicodedata.category</code>(<em>chr</em>)</p>
<p>返回分配给字符 <em>chr</em> 的常规类别为字符串。</p>
<p><code>unicodedata.bidirectional</code>(<em>chr</em>)</p>
<p>返回分配给字符 <em>chr</em> 的双向类作为字符串。如果未定义此类值，则返回空字符串。</p>
<p><code>unicodedata.combining</code>(<em>chr</em>)</p>
<p>返回分配给字符 <em>chr</em> 的规范组合类作为整数。如果没有定义组合类，则返回 <code>0</code> 。</p>
<p><code>unicodedata.east_asian_width</code>(<em>chr</em>)</p>
<p>返回分配给字符 <em>chr</em> 的东亚宽度作为字符串。</p>
<p><code>unicodedata.mirrored</code>(<em>chr</em>)</p>
<p>返回分配给字符 <em>chr</em> 的镜像属性为整数。如果字符在双向文本中被识别为“镜像”字符，则返回 <code>1</code> ，否则返回 <code>0</code> 。</p>
<p><code>unicodedata.decomposition</code>(<em>chr</em>)</p>
<p>返回分配给字符 <em>chr</em> 的字符分解映射作为字符串。如果未定义此类映射，则返回空字符串。</p>
<p><code>unicodedata.normalize</code>(<em>form</em>, <em>unistr</em>)</p>
<p>返回 Unicode 字符串 <em>unistr</em> 的正常形式 <em>form</em> 。 <em>form</em> 的有效值为 ‘NFC’ 、 ‘NFKC’ 、 ‘NFD’ 和 ‘NFKD’ 。</p>
<p>Unicode 标准基于规范等价和兼容性等效的定义定义了 Unicode 字符串的各种规范化形式。在 Unicode 中，可以以各种方式表示多个字符。 例如，字符 U+00C7 （带有 CEDILLA 的 LATIN CAPITAL LETTER C ）也可以表示为序列 U+0043（ LATIN CAPITAL LETTER C ）U+0327（ COMBINING CEDILLA ）。</p>
<p>对于每个字符，有两种正规形式：正规形式 C 和正规形式 D 。正规形式D（NFD）也称为规范分解，并将每个字符转换为其分解形式。 正规形式C（NFC）首先应用规范分解，然后再次组合预组合字符。</p>
<p>除了这两种形式之外，还有两种基于兼容性等效的其他常规形式。 在 Unicode 中，支持某些字符，这些字符通常与其他字符统一。 例如， U+2160（ROMAN NUMERAL ONE）与 U+0049（LATIN CAPITAL LETTER I）完全相同。 但是， Unicode 支持它与现有字符集（例如 gb2312 ）的兼容性。</p>
<p>正规形式KD（NFKD）将应用兼容性分解，即用其等价项替换所有兼容性字符。 正规形式KC（NFKC）首先应用兼容性分解，然后是规范组合。</p>
<p>即使两个 unicode 字符串被规范化并且人类读者看起来相同，如果一个具有组合字符而另一个没有，则它们可能无法相等。</p>
<p><code>unicodedata.is_normalized</code>(<em>form</em>, <em>unistr</em>)</p>
<p>判断 Unicode 字符串 <em>unistr</em> 是否为正规形式 <em>form*。 *form</em> 的有效值为 ‘NFC’, ‘NFKC’, ‘NFD’ 和 ‘NFKD’。</p>
<p>3.8 新版功能.</p>
<p>此外，该模块暴露了以下常量：</p>
<pre><code>unicodedata.unidata_version</code></pre><p>此模块中使用的 Unicode 数据库的版本。</p>
<pre><code>unicodedata.ucd_3_2_0</code></pre><p>这是一个与整个模块具有相同方法的对象，但对于需要此特定版本的 Unicode 数据库（如 IDNA ）的应用程序，则使用 Unicode 数据库版本 3.2 。</p>
<p>示例：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> unicodedata
<span class="token operator">>></span><span class="token operator">></span> unicodedata<span class="token punctuation">.</span>lookup<span class="token punctuation">(</span><span class="token string">'LEFT CURLY BRACKET'</span><span class="token punctuation">)</span>
<span class="token string">'{'</span>
<span class="token operator">>></span><span class="token operator">></span> unicodedata<span class="token punctuation">.</span>name<span class="token punctuation">(</span><span class="token string">'/'</span><span class="token punctuation">)</span>
<span class="token string">'SOLIDUS'</span>
<span class="token operator">>></span><span class="token operator">></span> unicodedata<span class="token punctuation">.</span>decimal<span class="token punctuation">(</span><span class="token string">'9'</span><span class="token punctuation">)</span>
<span class="token number">9</span>
<span class="token operator">>></span><span class="token operator">></span> unicodedata<span class="token punctuation">.</span>decimal<span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">)</span>
Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>
  File <span class="token string">"&lt;stdin>"</span><span class="token punctuation">,</span> line <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">></span>
ValueError<span class="token punctuation">:</span> <span class="token operator">not</span> a decimal
<span class="token operator">>></span><span class="token operator">></span> unicodedata<span class="token punctuation">.</span>category<span class="token punctuation">(</span><span class="token string">'A'</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 'L'etter, 'u'ppercase</span>
<span class="token string">'Lu'</span>
<span class="token operator">>></span><span class="token operator">></span> unicodedata<span class="token punctuation">.</span>bidirectional<span class="token punctuation">(</span><span class="token string">'\u0660'</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 'A'rabic, 'N'umber</span>
<span class="token string">'AN'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="stringprep-—-因特网字符串预备"><a href="#stringprep-—-因特网字符串预备" class="headerlink" title="stringprep —- 因特网字符串预备"></a><code>stringprep</code> —- 因特网字符串预备</h2><p><strong>源代码:</strong> <a href="https://github.com/python/cpython/tree/3.10/Lib/stringprep.py" target="_blank" rel="noopener">Lib/stringprep.py</a></p>
<hr>
<p>在标识因特网上的事物（例如主机名），经常需要比较这些标识是否（相等）。 这种比较的具体执行可能会取决于应用域的不同，例如是否要区分大小写等等。 有时也可能需要限制允许的标识为仅由“可打印”字符组成。</p>
<p><a href="https://tools.ietf.org/html/rfc3454.html" target="_blank" rel="noopener"><strong>RFC 3454</strong></a> 定义了在因特网协议中 Unicode 字符串的“预备”过程。 在将字符串连线传输之前，它们会先使用预备过程进行处理，之后它们将具有特定的标准形式。 该 RFC 定义了一系列表格，它们可以被组合为选项配置。 每个配置必须定义所使用的表格，<code>stringprep</code> 过程的其他可选项也是配置的组成部分。 <code>stringprep</code> 配置的一个例子是 <code>nameprep</code>，它被用于国际化域名。</p>
<p>模块 <code>stringprep</code> 仅公开了来自 <a href="https://tools.ietf.org/html/rfc3454.html" target="_blank" rel="noopener"><strong>RFC 3454</strong></a> 的表格。 由于这些如果表格如果表示为字典或列表将会非常庞大，该模块在内部使用 Unicode 字符数据库。 该模块本身的源代码是使用 <code>mkstringprep.py</code> 工具生成的。</p>
<p>因此，这些表格以函数而非数据结构的形式公开。 在 RFC 中有两种表格：集合与映射。 对于集合，<code>stringprep</code> 提供了“特征函数”，即如果形参是集合的一部分则返回值为 <code>True</code> 的函数。 对于映射，它提供了映射函数：它会根据给定的键返回所关联的值。 以下是模块中所有可用函数的列表。</p>
<p><code>stringprep.in_table_a1</code>(<em>code</em>)</p>
<p>确定 <em>code</em> 是否属于 tableA.1 (Unicode 3.2 中的未分配码位)。</p>
<p><code>stringprep.in_table_b1</code>(<em>code</em>)</p>
<p>确定 <em>code</em> 是否属于 tableB.1 (通常映射为空值)。</p>
<p><code>stringprep.map_table_b2</code>(<em>code</em>)</p>
<p>返回 <em>code</em> 依据 tableB.2 (配合 NFKC 使用的大小写转换映射) 所映射的值。</p>
<p><code>stringprep.map_table_b3</code>(<em>code</em>)</p>
<p>返回 <em>code</em> 依据 tableB.3 (不附带正规化的大小写折叠映射) 所映射的值。</p>
<p><code>stringprep.in_table_c11</code>(<em>code</em>)</p>
<p>确定 <em>code</em> 是否属于 tableC.1.1 (ASCII 空白字符)。</p>
<p><code>stringprep.in_table_c12</code>(<em>code</em>)</p>
<p>确定 <em>code</em> 是否属于 tableC.1.2 (非 ASCII 空白字符)。</p>
<p><code>stringprep.in_table_c11_c12</code>(<em>code</em>)</p>
<p>确定 <em>code</em> 是否属于 tableC.1 (空白字符，C.1.1 和 C.1.2 的并集)。</p>
<p><code>stringprep.in_table_c21</code>(<em>code</em>)</p>
<p>确定 <em>code</em> 是否属于 tableC.2.1 (ASCII 控制字符)。</p>
<p><code>stringprep.in_table_c22</code>(<em>code</em>)</p>
<p>确定 <em>code</em> 是否属于 tableC.2.2 (非 ASCII 控制字符)。</p>
<p><code>stringprep.in_table_c21_c22</code>(<em>code</em>)</p>
<p>确定 <em>code</em> 是否属于 tableC.2 (控制字符，C.2.1 和 C.2.2 的并集)。</p>
<p><code>stringprep.in_table_c3</code>(<em>code</em>)</p>
<p>确定 <em>code</em> 是否属于 tableC.3 (私有使用)。</p>
<p><code>stringprep.in_table_c4</code>(<em>code</em>)</p>
<p>确定 <em>code</em> 是否属于 tableC.4 (非字符码位)。</p>
<p><code>stringprep.in_table_c5</code>(<em>code</em>)</p>
<p>确定 <em>code</em> 是否属于 tableC.5 (替代码)。</p>
<p><code>stringprep.in_table_c6</code>(<em>code</em>)</p>
<p>确定 <em>code</em> 是否属于 tableC.6 (不适用于纯文本)。</p>
<p><code>stringprep.in_table_c7</code>(<em>code</em>)</p>
<p>确定 <em>code</em> 是否属于 tableC.7 (不适用于规范表示)。</p>
<p><code>stringprep.in_table_c8</code>(<em>code</em>)</p>
<p>确定 <em>code</em> 是否属于 tableC.8 (改变显示属性或已弃用)。</p>
<p><code>stringprep.in_table_c9</code>(<em>code</em>)</p>
<p>确定 <em>code</em> 是否属于 tableC.9 (标记字符)。</p>
<p><code>stringprep.in_table_d1</code>(<em>code</em>)</p>
<p>确定 <em>code</em> 是否属于 tableD.1 (带有双向属性 “R” 或 “AL” 的字符)。</p>
<p><code>stringprep.in_table_d2</code>(<em>code</em>)</p>
<p>确定 <em>code</em> 是否属于 tableD.2 (带有双向属性 “L” 的字符)。</p>
<h2 id="readline-—-GNU-readline-接口"><a href="#readline-—-GNU-readline-接口" class="headerlink" title="readline —- GNU readline 接口"></a><code>readline</code> —- GNU readline 接口</h2><hr>
<p><code>readline</code> 模块定义了许多方便从 Python 解释器完成和读取/写入历史文件的函数。 此模块可以直接使用，或通过支持在交互提示符下完成 Python 标识符的 <code>rlcompleter</code> 模块使用。 使用此模块进行的设置会同时影响解释器的交互提示符以及内置 <code>input()</code> 函数提供的提示符。</p>
<p>Readline keybindings may be configured via an initialization file, typically <code>.inputrc</code> in your home directory. See Readline Init File in the GNU Readline manual for information about the format and allowable constructs of that file, and the capabilities of the Readline library in general.</p>
<p>注解</p>
<p>底层的 Readline 库 API 可能使用 <code>libedit</code> 库来实现而不是 GNU readline。 在 macOS 上 <code>readline</code> 模块会在运行时检测所使用的是哪个库。</p>
<p><code>libedit</code> 所用的配置文件与 GNU readline 的不同。 如果你要在程序中载入配置字符串你可以在 <code>readline.__doc__</code> 中检测文本 “libedit” 来区分 GNU readline 和 libedit。</p>
<p>如果你是在 macOS 上使用 <em>editline</em>/<code>libedit</code> readline 模拟，则位于你的主目录中的初始化文件名称为 <code>.editrc</code>。 例如，<code>~/.editrc</code> 中的以下内容将开启 <em>vi</em> 按键绑定以及 TAB 补全:</p>
<pre><code>python:bind -vpython:bind ^I rl_complete</code></pre><h3 id="初始化文件"><a href="#初始化文件" class="headerlink" title="初始化文件"></a>初始化文件</h3><p>下列函数与初始化文件和用户配置有关：</p>
<p><code>readline.parse_and_bind</code>(<em>string</em>)</p>
<p>执行在 <em>string</em> 参数中提供的初始化行。 此函数会调用底层库中的 <code>rl_parse_and_bind()</code>。</p>
<p><code>readline.read_init_file</code>([<em>filename</em>])</p>
<p>执行一个 readline 初始化文件。 默认文件名为最近所使用的文件名。 此函数会调用底层库中的 <code>rl_read_init_file()</code>。</p>
<h3 id="行缓冲区"><a href="#行缓冲区" class="headerlink" title="行缓冲区"></a>行缓冲区</h3><p>下列函数会在行缓冲区上操作。</p>
<p><code>readline.get_line_buffer</code>()</p>
<p>返回行缓冲区的当前内容 (底层库中的 <code>rl_line_buffer</code>)。</p>
<p><code>readline.insert_text</code>(<em>string</em>)</p>
<p>将文本插入行缓冲区的当前游标位置。 该函数会调用底层库中的 <code>rl_insert_text()</code>，但会忽略其返回值。</p>
<p><code>readline.redisplay</code>()</p>
<p>改变屏幕的显示以反映行缓冲区的当前内容。 该函数会调用底层库中的 <code>rl_redisplay()</code>。</p>
<h3 id="历史文件"><a href="#历史文件" class="headerlink" title="历史文件"></a>历史文件</h3><p>下列函数会在历史文件上操作：</p>
<p><code>readline.read_history_file</code>([<em>filename</em>])</p>
<p>载入一个 readline 历史文件，并将其添加到历史列表。 默认文件名为 <code>~/.history</code>。 此函数会调用底层库中的 <code>read_history()</code>。</p>
<p><code>readline.write_history_file</code>([<em>filename</em>])</p>
<p>将历史列表保存为 readline 历史文件，覆盖任何现有文件。 默认文件名为 <code>~/.history</code>。 此函数会调用底层库中的 <code>write_history()</code>。</p>
<p><code>readline.append_history_file</code>(<em>nelements</em>[, <em>filename</em>])</p>
<p>将历史列表的最后 <em>nelements</em> 项添加到历史文件。 默认文件名为 <code>~/.history</code>。 文件必须已存在。 此函数会调用底层库中的 <code>append_history()</code>。 此函数仅当 Python 编译包带有支持此功能的库版本时才会存在。</p>
<p>3.5 新版功能.</p>
<p><code>readline.get_history_length</code>()</p>
<p><code>readline.set_history_length</code>(<em>length</em>)</p>
<p>设置或返回需要保存到历史文件的行数。 <code>write_history_file()</code> 函数会通过调用底层库中的 <code>history_truncate_file()</code> 以使用该值来截取历史文件。 负值意味着不限制历史文件的大小。</p>
<h3 id="历史列表"><a href="#历史列表" class="headerlink" title="历史列表"></a>历史列表</h3><p>以下函数会在全局历史列表上操作：</p>
<p><code>readline.clear_history</code>()</p>
<p>清除当前历史。 此函数会调用底层库的 <code>clear_history()</code>。 此 Python 函数仅当 Python 编译包带有支持此功能的库版本时才会存在。</p>
<p><code>readline.get_current_history_length</code>()</p>
<p>返回历史列表的当前项数。 （此函数不同于 <code>get_history_length()</code>，后者是返回将被写入历史文件的最大行数。）</p>
<p><code>readline.get_history_item</code>(<em>index</em>)</p>
<p>返回序号为 <em>index</em> 的历史条目的当前内容。 条目序号从一开始。 此函数会调用底层库中的 <code>history_get()</code>。</p>
<p><code>readline.remove_history_item</code>(<em>pos</em>)</p>
<p>从历史列表中移除指定位置上的历史条目。 条目位置从零开始。 此函数会调用底层库中的 <code>remove_history()</code>。</p>
<p><code>readline.replace_history_item</code>(<em>pos</em>, <em>line</em>)</p>
<p>将指定位置上的历史条目替换为 <em>line</em>。 条目位置从零开始。 此函数会调用底层库中的 <code>replace_history_entry()</code>。</p>
<p><code>readline.add_history</code>(<em>line</em>)</p>
<p>将 <em>line</em> 添加到历史缓冲区，相当于是最近输入的一行。 此函数会调用底层库中的 <code>add_history()</code>。</p>
<p><code>readline.set_auto_history</code>(<em>enabled</em>)</p>
<p>启用或禁用当通过 readline 读取输入时自动调用 <code>add_history()</code>。 <em>enabled</em> 参数应为一个布尔值，当其为真值时启用自动历史，当其为假值时禁用自动历史。</p>
<p>3.6 新版功能.</p>
<p><strong>CPython implementation detail:</strong> Auto history is enabled by default, and changes to this do not persist across multiple sessions.</p>
<h3 id="启动钩子"><a href="#启动钩子" class="headerlink" title="启动钩子"></a>启动钩子</h3><p><code>readline.set_startup_hook</code>([<em>function</em>])</p>
<p>设置或移除底层库的 <code>rl_startup_hook</code> 回调所发起调用的函数。 如果指定了 <em>function</em>，它将被用作新的钩子函数；如果省略或为 <code>None</code>，任何已安装的函数将被移除。 钩子函数将在 readline 打印第一个提示信息之前不带参数地被调用。</p>
<p><code>readline.set_pre_input_hook</code>([<em>function</em>])</p>
<p>设置或移除底层库的 <code>rl_pre_input_hook</code> 回调所发起调用的函数。 如果指定了 <em>function</em>，它将被用作新的钩子函数；如果省略或为 <code>None</code>，任何已安装的函数将被移除。 钩子函数将在打印第一个提示信息之后、readline 开始读取输入字符之前不带参数地被调用。 此函数仅当 Python 编译包带有支持此功能的库版本时才会存在。</p>
<h3 id="Completion"><a href="#Completion" class="headerlink" title="Completion"></a>Completion</h3><p>以下函数与自定义单词补全函数的实现有关。 这通常使用 Tab 键进行操作，能够提示并自动补全正在输入的单词。 默认情况下，Readline 设置为由 <code>rlcompleter</code> 来补全交互模式解释器的 Python 标识符。 如果 <code>readline</code> 模块要配合自定义的补全函数来使用，则需要设置不同的单词分隔符。</p>
<p><code>readline.set_completer</code>([<em>function</em>])</p>
<p>设置或移除补全函数。 如果指定了 <em>function*，它将被用作新的补全函数；如果省略或为 <code>None</code>，任何已安装的补全函数将被移除。 补全函数的调用形式为 <code>function(text, state)</code>，其中 *state</em> 为 <code>0</code>, <code>1</code>, <code>2</code>, …, 直至其返回一个非字符串值。 它应当返回下一个以 <em>text</em> 开头的候选补全内容。</p>
<p>已安装的补全函数将由传递给底层库中 <code>rl_completion_matches()</code> 的 <em>entry_func</em> 回调函数来发起调用。 <em>text</em> 字符串来自于底层库中 <code>rl_attempted_completion_function</code> 回调函数的第一个形参。</p>
<p><code>readline.get_completer</code>()</p>
<p>获取补全函数，如果没有设置补全函数则返回 <code>None</code>。</p>
<p><code>readline.get_completion_type</code>()</p>
<p>获取正在尝试的补全类型。 此函数会将底层库中的 <code>rl_completion_type</code> 变量作为一个整数返回。</p>
<p><code>readline.get_begidx</code>()</p>
<p><code>readline.get_endidx</code>()</p>
<p>获取完全范围的开始和结束索引号。 这些索引号就是传递给下层库的 <code>rl_attempted_completion_function</code> 回调的 <em>start</em> 和 <em>end</em> 参数。 具体值在同一个输入编辑场景中可能不同，具体取决于下层的 C readline 实现。 例如：已知 libedit 的行为就不同于 libreadline。</p>
<p><code>readline.set_completer_delims</code>(<em>string</em>)</p>
<p><code>readline.get_completer_delims</code>()</p>
<p>设置或获取补全的单词分隔符。 此分隔符确定了要考虑补全的单词的开始和结束位置（补全域）。 这些函数会访问底层库的 <code>rl_completer_word_break_characters</code> 变量。</p>
<p><code>readline.set_completion_display_matches_hook</code>([<em>function</em>])</p>
<p>设置或移除补全显示函数。 如果指定了 <em>function</em>，它将被用作新的补全显示函数；如果省略或为 <code>None</code>，任何已安装的补全显示函数将被移除。 此函数会设置或清除底层库的 <code>rl_completion_display_matches_hook</code> 回调函数。 补全显示函数会在每次需要显示匹配项时以 <code>function(substitution, [matches], longest_match_length)</code> 的形式被调用。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>以下示例演示了如何使用 <code>readline</code> 模块的历史读取或写入函数来自动加载和保存用户主目录下名为 <code>.python_history</code> 的历史文件。 以下代码通常应当在交互会话期间从用户的 <code>PYTHONSTARTUP</code> 文件自动执行。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> atexit
<span class="token keyword">import</span> os
<span class="token keyword">import</span> readline
histfile <span class="token operator">=</span> os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>join<span class="token punctuation">(</span>os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>expanduser<span class="token punctuation">(</span><span class="token string">"~"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">".python_history"</span><span class="token punctuation">)</span>
<span class="token keyword">try</span><span class="token punctuation">:</span>
    readline<span class="token punctuation">.</span>read_history_file<span class="token punctuation">(</span>histfile<span class="token punctuation">)</span>
    <span class="token comment" spellcheck="true"># default history len is -1 (infinite), which may grow unruly</span>
    readline<span class="token punctuation">.</span>set_history_length<span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span>
<span class="token keyword">except</span> FileNotFoundError<span class="token punctuation">:</span>
    <span class="token keyword">pass</span>
atexit<span class="token punctuation">.</span>register<span class="token punctuation">(</span>readline<span class="token punctuation">.</span>write_history_file<span class="token punctuation">,</span> histfile<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>此代码实际上会在 Python 运行于 交互模式 时自动运行。</p>
<p>以下示例实现了同样的目标，但是通过只添加新历史的方式来支持并发的交互会话。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> atexit
<span class="token keyword">import</span> os
<span class="token keyword">import</span> readline
histfile <span class="token operator">=</span> os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>join<span class="token punctuation">(</span>os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>expanduser<span class="token punctuation">(</span><span class="token string">"~"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">".python_history"</span><span class="token punctuation">)</span>
<span class="token keyword">try</span><span class="token punctuation">:</span>
    readline<span class="token punctuation">.</span>read_history_file<span class="token punctuation">(</span>histfile<span class="token punctuation">)</span>
    h_len <span class="token operator">=</span> readline<span class="token punctuation">.</span>get_current_history_length<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">except</span> FileNotFoundError<span class="token punctuation">:</span>
    open<span class="token punctuation">(</span>histfile<span class="token punctuation">,</span> <span class="token string">'wb'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>
    h_len <span class="token operator">=</span> <span class="token number">0</span>
<span class="token keyword">def</span> <span class="token function">save</span><span class="token punctuation">(</span>prev_h_len<span class="token punctuation">,</span> histfile<span class="token punctuation">)</span><span class="token punctuation">:</span>
    new_h_len <span class="token operator">=</span> readline<span class="token punctuation">.</span>get_current_history_length<span class="token punctuation">(</span><span class="token punctuation">)</span>
    readline<span class="token punctuation">.</span>set_history_length<span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span>
    readline<span class="token punctuation">.</span>append_history_file<span class="token punctuation">(</span>new_h_len <span class="token operator">-</span> prev_h_len<span class="token punctuation">,</span> histfile<span class="token punctuation">)</span>
atexit<span class="token punctuation">.</span>register<span class="token punctuation">(</span>save<span class="token punctuation">,</span> h_len<span class="token punctuation">,</span> histfile<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>以下示例扩展了 <code>code.InteractiveConsole</code> 类以支持历史保存/恢复。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> atexit
<span class="token keyword">import</span> code
<span class="token keyword">import</span> os
<span class="token keyword">import</span> readline
<span class="token keyword">class</span> <span class="token class-name">HistoryConsole</span><span class="token punctuation">(</span>code<span class="token punctuation">.</span>InteractiveConsole<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> locals<span class="token operator">=</span>None<span class="token punctuation">,</span> filename<span class="token operator">=</span><span class="token string">"&lt;console>"</span><span class="token punctuation">,</span>
                 histfile<span class="token operator">=</span>os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>expanduser<span class="token punctuation">(</span><span class="token string">"~/.console-history"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        code<span class="token punctuation">.</span>InteractiveConsole<span class="token punctuation">.</span>__init__<span class="token punctuation">(</span>self<span class="token punctuation">,</span> locals<span class="token punctuation">,</span> filename<span class="token punctuation">)</span>
        self<span class="token punctuation">.</span>init_history<span class="token punctuation">(</span>histfile<span class="token punctuation">)</span>
    <span class="token keyword">def</span> <span class="token function">init_history</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> histfile<span class="token punctuation">)</span><span class="token punctuation">:</span>
        readline<span class="token punctuation">.</span>parse_and_bind<span class="token punctuation">(</span><span class="token string">"tab: complete"</span><span class="token punctuation">)</span>
        <span class="token keyword">if</span> hasattr<span class="token punctuation">(</span>readline<span class="token punctuation">,</span> <span class="token string">"read_history_file"</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">try</span><span class="token punctuation">:</span>
                readline<span class="token punctuation">.</span>read_history_file<span class="token punctuation">(</span>histfile<span class="token punctuation">)</span>
            <span class="token keyword">except</span> FileNotFoundError<span class="token punctuation">:</span>
                <span class="token keyword">pass</span>
            atexit<span class="token punctuation">.</span>register<span class="token punctuation">(</span>self<span class="token punctuation">.</span>save_history<span class="token punctuation">,</span> histfile<span class="token punctuation">)</span>
    <span class="token keyword">def</span> <span class="token function">save_history</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> histfile<span class="token punctuation">)</span><span class="token punctuation">:</span>
        readline<span class="token punctuation">.</span>set_history_length<span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span>
        readline<span class="token punctuation">.</span>write_history_file<span class="token punctuation">(</span>histfile<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="rlcompleter-—-GNU-readline-的补全函数"><a href="#rlcompleter-—-GNU-readline-的补全函数" class="headerlink" title="rlcompleter —- GNU readline 的补全函数"></a><code>rlcompleter</code> —- GNU readline 的补全函数</h2><p><strong>源代码:</strong> <a href="https://github.com/python/cpython/tree/3.10/Lib/rlcompleter.py" target="_blank" rel="noopener">Lib/rlcompleter.py</a></p>
<hr>
<p><code>rlcompeleter</code> 通过补全有效的 Python 标识符和关键字定义了一个适用于 <code>readline</code> 模块的补全函数。</p>
<p>当此模块在具有可用的 <code>readline</code> 模块的 Unix 平台被导入, 一个 <code>Completer</code> 实例将被自动创建并且它的 <code>complete()</code> 方法将设置为 <code>readline</code> 的补全器.</p>
<p>示例:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> rlcompleter
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> readline
<span class="token operator">>></span><span class="token operator">></span> readline<span class="token punctuation">.</span>parse_and_bind<span class="token punctuation">(</span><span class="token string">"tab: complete"</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> readline<span class="token punctuation">.</span> <span class="token operator">&lt;</span>TAB PRESSED<span class="token operator">></span>
readline<span class="token punctuation">.</span>__doc__          readline<span class="token punctuation">.</span>get_line_buffer<span class="token punctuation">(</span>  readline<span class="token punctuation">.</span>read_init_file<span class="token punctuation">(</span>
readline<span class="token punctuation">.</span>__file__         readline<span class="token punctuation">.</span>insert_text<span class="token punctuation">(</span>      readline<span class="token punctuation">.</span>set_completer<span class="token punctuation">(</span>
readline<span class="token punctuation">.</span>__name__         readline<span class="token punctuation">.</span>parse_and_bind<span class="token punctuation">(</span>
<span class="token operator">>></span><span class="token operator">></span> readline<span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>rlcompleter</code> 模块是为了使用 Python 的 交互模式 而设计的。 除非 Python 是通过 <code>-S</code> 选项运行, 这个模块总是自动地被导入且配置 。</p>
<p>在没有 <code>readline</code> 的平台, 此模块定义的 <code>Completer</code> 类仍然可以用于自定义行为.</p>
<h3 id="Completer-对象"><a href="#Completer-对象" class="headerlink" title="Completer 对象"></a>Completer 对象</h3><p>Completer 对象具有以下方法：</p>
<p><code>Completer.complete</code>(<em>text</em>, <em>state</em>)</p>
<p>为 <em>text</em> 返回第 <em>state</em> 项补全。</p>
<p>如果指定的 <em>text</em> 不包含句点字符 (<code>'.'</code>)，它将根据当前 <code>__main__</code>, <code>builtins</code> 和保留关键字（定义于 <code>keyword</code> 模块）所定义的名称进行补全。</p>
<p>如果为带有句点的名称执行调用，它将尝试尽量求值直到最后一部分为止而不产生附带影响（函数不会被求值，但它可以生成对 <code>__getattr__()</code> 的调用），并通过 <code>dir()</code> 函数来匹配剩余部分。 在对表达式求值期间引发的任何异常都会被捕获、静默处理并返回 <code>None</code>。</p>
<h1 id="二进制数据服务"><a href="#二进制数据服务" class="headerlink" title="二进制数据服务"></a>二进制数据服务</h1><p>下面描述的一些库 文本处理服务 也可以使用 ASCII 兼容的二进制格式（例如 <code>re</code> ）或所有二进制数据（例如 <code>difflib</code> ）。</p>
<ul>
<li><code>struct</code> —- 将字节串解读为打包的二进制数据<ul>
<li>函数和异常</li>
<li>格式字符串<ul>
<li>字节顺序，大小和对齐方式</li>
<li>格式字符</li>
<li>例子</li>
</ul>
</li>
<li>类</li>
</ul>
</li>
<li><code>codecs</code> —- 编解码器注册和相关基类<ul>
<li>编解码器基类<ul>
<li>错误处理方案</li>
<li>无状态的编码和解码</li>
<li>增量式的编码和解码<ul>
<li>IncrementalEncoder 对象</li>
<li>IncrementalDecoder 对象</li>
</ul>
</li>
<li>流式的编码和解码<ul>
<li>StreamWriter 对象</li>
<li>StreamReader 对象</li>
<li>StreamReaderWriter 对象</li>
<li>StreamRecoder 对象</li>
</ul>
</li>
</ul>
</li>
<li>编码格式与 Unicode</li>
<li>标准编码</li>
<li>Python 专属的编码格式<ul>
<li>文字编码</li>
<li>二进制转换</li>
<li>文字转换</li>
</ul>
</li>
<li><code>encodings.idna</code> —- 应用程序中的国际化域名</li>
<li><code>encodings.mbcs</code> —- Windows ANSI代码页</li>
<li><code>encodings.utf_8_sig</code> —- 带BOM签名的UTF-8编解码器</li>
</ul>
</li>
</ul>
<h2 id="struct-—-将字节串解读为打包的二进制数据"><a href="#struct-—-将字节串解读为打包的二进制数据" class="headerlink" title="struct —- 将字节串解读为打包的二进制数据"></a><code>struct</code> —- 将字节串解读为打包的二进制数据</h2><p><strong>源代码：</strong> <a href="https://github.com/python/cpython/tree/3.10/Lib/struct.py" target="_blank" rel="noopener">Lib/struct.py</a></p>
<hr>
<p>此模块可以执行 Python 值和以 Python <code>bytes</code> 对象表示的 C 结构之间的转换。 这可以被用来处理存储在文件中或是从网络连接等其他来源获取的二进制数据。 它使用 格式字符串 作为 C 结构布局的精简描述以及与 Python 值的双向转换。</p>
<p>注解</p>
<p>默认情况下，打包给定 C 结构的结果会包含填充字节以使得所涉及的 C 类型保持正确的对齐；类似地，对齐在解包时也会被纳入考虑。 选择此种行为的目的是使得被打包结构的字节能与相应 C 结构在内存中的布局完全一致。 要处理平台独立的数据格式或省略隐式的填充字节，请使用 <code>standard</code> 大小和对齐而不是 <code>native</code> 大小和对齐。</p>
<p>某些 <code>struct</code> 的函数（以及 <code>Struct</code> 的方法）接受一个 <em>buffer</em> 参数。 这将指向实现了 缓冲协议 并提供只读或是可读写缓冲的对象。 用于此目的的最常见类型为 <code>bytes</code> 和 <code>bytearray</code>，但许多其他可被视为字节数组的类型也实现了缓冲协议，因此它们无需额外从 <code>bytes</code> 对象复制即可被读取或填充。</p>
<h3 id="函数和异常"><a href="#函数和异常" class="headerlink" title="函数和异常"></a>函数和异常</h3><p>此模块定义了下列异常和函数：</p>
<p><em>exception</em> <code>struct.error</code></p>
<p>会在多种场合下被引发的异常；其参数为一个描述错误信息的字符串。</p>
<p><code>struct.pack</code>(<em>format</em>, <em>v1</em>, <em>v2</em>, <em>…</em>)</p>
<p>返回一个 bytes 对象，其中包含根据格式字符串 <em>format</em> 打包的值 <em>v1</em>, <em>v2</em>, … 参数个数必须与格式字符串所要求的值完全匹配。</p>
<p><code>struct.pack_into</code>(<em>format</em>, <em>buffer</em>, <em>offset</em>, <em>v1</em>, <em>v2</em>, <em>…</em>)</p>
<p>根据格式字符串 <em>format</em> 打包 <em>v1</em>, <em>v2</em>, … 等值并将打包的字节串写入可写缓冲区 <em>buffer</em> 从 <em>offset</em> 开始的位置。 请注意 <em>offset</em> 是必需的参数。</p>
<p><code>struct.unpack</code>(<em>format</em>, <em>buffer</em>)</p>
<p>根据格式字符串 <em>format</em> 从缓冲区 <em>buffer</em> 解包（假定是由 <code>pack(format, ...)</code> 打包）。 结果为一个元组，即使其只包含一个条目。 缓冲区的字节大小必须匹配格式所要求的大小，如 <code>calcsize()</code> 所示。</p>
<p><code>struct.unpack_from</code>(<em>format</em>, <em>/</em>, <em>buffer</em>, <em>offset=0</em>)</p>
<p>对 <em>buffer</em> 从位置 <em>offset</em> 开始根据格式字符串 <em>format</em> 进行解包。 结果为一个元组，即使其中只包含一个条目。 缓冲区的字节大小从位置 <em>offset</em> 开始必须至少为 <code>calcsize()</code> 显示的格式所要求的大小。</p>
<p><code>struct.iter_unpack</code>(<em>format</em>, <em>buffer</em>)</p>
<p>根据格式字符串 <em>format</em> 以迭代方式从缓冲区 <em>buffer</em> 解包。 此函数返回一个迭代器，它将从缓冲区读取相同大小的块直至其内容全部耗尽。 缓冲区的字节大小必须整数倍于格式所要求的大小，如 <code>calcsize()</code> 所示。</p>
<p>每次迭代将产生一个如格式字符串所指定的元组。</p>
<p>3.4 新版功能.</p>
<p><code>struct.calcsize</code>(<em>format</em>)</p>
<p>返回与格式字符串 <em>format</em> 相对应的结构的大小（亦即 <code>pack(format, ...)</code> 所产生的字节串对象的大小）。</p>
<h3 id="格式字符串"><a href="#格式字符串" class="headerlink" title="格式字符串"></a>格式字符串</h3><p>格式字符串是用来在打包和解包数据时指定预期布局的机制。 它们使用指定被打包/解包数据类型的 格式字符 进行构建。 此外，还有一些特殊字符用来控制 字节顺序，大小和对齐方式。</p>
<h4 id="字节顺序，大小和对齐方式"><a href="#字节顺序，大小和对齐方式" class="headerlink" title="字节顺序，大小和对齐方式"></a>字节顺序，大小和对齐方式</h4><p>默认情况下，C类型以机器的本机格式和字节顺序表示，并在必要时通过跳过填充字节进行正确对齐（根据C编译器使用的规则）。</p>
<p>或者，根据下表，格式字符串的第一个字符可用于指示打包数据的字节顺序，大小和对齐方式：</p>
<table>
<thead>
<tr>
<th align="left">字符</th>
<th align="left">字节顺序</th>
<th align="left">大小</th>
<th align="left">对齐方式</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>@</code></td>
<td align="left">按原字节</td>
<td align="left">按原字节</td>
<td align="left">按原字节</td>
</tr>
<tr>
<td align="left"><code>=</code></td>
<td align="left">按原字节</td>
<td align="left">标准</td>
<td align="left">无</td>
</tr>
<tr>
<td align="left"><code>&lt;</code></td>
<td align="left">小端</td>
<td align="left">标准</td>
<td align="left">无</td>
</tr>
<tr>
<td align="left"><code>&gt;</code></td>
<td align="left">大端</td>
<td align="left">标准</td>
<td align="left">无</td>
</tr>
<tr>
<td align="left"><code>!</code></td>
<td align="left">网络（=大端）</td>
<td align="left">标准</td>
<td align="left">无</td>
</tr>
</tbody></table>
<p>如果第一个字符不是其中之一，则假定为 <code>'@'</code> 。</p>
<p>本机字节顺序可能为大端或是小端，取决于主机系统的不同。 例如， Intel x86 和 AMD64 (x86-64) 是小端的；Motorola 68000 和 PowerPC G5 是大端的；ARM 和 Intel Itanium 具有可切换的字节顺序（双端）。 请使用 <code>sys.byteorder</code> 来检查你的系统字节顺序。</p>
<p>本机大小和对齐方式是使用 C 编译器的 <code>sizeof</code> 表达式来确定的。 这总是会与本机字节顺序相绑定。</p>
<p>标准大小仅取决于格式字符。</p>
<p>请注意 <code>'@'</code> 和 <code>'='</code> 之间的区别：两个都使用本机字节顺序，但后者的大小和对齐方式是标准化的。</p>
<p>形式 <code>'!'</code> 代表网络字节顺序总是使用在 <a href="https://tools.ietf.org/html/rfc1700" target="_blank" rel="noopener">IETF RFC 1700</a> 中所定义的大端序。</p>
<p>没有什么方式能指定非本机字节顺序（强制字节对调）；请正确选择使用 <code>'&lt;'</code> 或 <code>'&gt;'</code>。</p>
<p>注释：</p>
<ol>
<li>填充只会在连续结构成员之间自动添加。 填充不会添加到已编码结构的开头和末尾。</li>
<li>当使用非本机大小和对齐方式即 ‘&lt;’, ‘&gt;’, ‘=’, and ‘!’ 时不会添加任何填充。</li>
<li>要将结构的末尾对齐到符合特定类型的对齐要求，请以该类型代码加重复计数的零作为格式结束。 </li>
</ol>
<h4 id="格式字符"><a href="#格式字符" class="headerlink" title="格式字符"></a>格式字符</h4><p>格式字符具有以下含义；C 和 Python 值之间的按其指定类型的转换应当是相当明显的。 ‘标准大小’列是指当使用标准大小时以字节表示的已打包值大小；也就是当格式字符串以 <code>'&lt;'</code>, <code>'&gt;'</code>, <code>'!'</code> 或 <code>'='</code> 之一开头的情况。 当使用本机大小时，已打包值的大小取决于具体的平台。</p>
<table>
<thead>
<tr>
<th align="left">格式</th>
<th align="left">C 类型</th>
<th align="left">Python 类型</th>
<th align="left">标准大小</th>
<th align="left">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>x</code></td>
<td align="left">填充字节</td>
<td align="left">无</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>c</code></td>
<td align="left">char</td>
<td align="left">长度为 1 的字节串</td>
<td align="left">1</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>b</code></td>
<td align="left">signed char</td>
<td align="left">整数</td>
<td align="left">1</td>
<td align="left">(1), (2)</td>
</tr>
<tr>
<td align="left"><code>B</code></td>
<td align="left">unsigned char</td>
<td align="left">整数</td>
<td align="left">1</td>
<td align="left">(2)</td>
</tr>
<tr>
<td align="left"><code>?</code></td>
<td align="left">_Bool</td>
<td align="left">bool</td>
<td align="left">1</td>
<td align="left">(1)</td>
</tr>
<tr>
<td align="left"><code>h</code></td>
<td align="left">short</td>
<td align="left">整数</td>
<td align="left">2</td>
<td align="left">(2)</td>
</tr>
<tr>
<td align="left"><code>H</code></td>
<td align="left">unsigned short</td>
<td align="left">整数</td>
<td align="left">2</td>
<td align="left">(2)</td>
</tr>
<tr>
<td align="left"><code>i</code></td>
<td align="left">int</td>
<td align="left">整数</td>
<td align="left">4</td>
<td align="left">(2)</td>
</tr>
<tr>
<td align="left"><code>I</code></td>
<td align="left">unsigned int</td>
<td align="left">整数</td>
<td align="left">4</td>
<td align="left">(2)</td>
</tr>
<tr>
<td align="left"><code>l</code></td>
<td align="left">long</td>
<td align="left">整数</td>
<td align="left">4</td>
<td align="left">(2)</td>
</tr>
<tr>
<td align="left"><code>L</code></td>
<td align="left">unsigned long</td>
<td align="left">整数</td>
<td align="left">4</td>
<td align="left">(2)</td>
</tr>
<tr>
<td align="left"><code>q</code></td>
<td align="left">long long</td>
<td align="left">整数</td>
<td align="left">8</td>
<td align="left">(2)</td>
</tr>
<tr>
<td align="left"><code>Q</code></td>
<td align="left">unsigned long long</td>
<td align="left">整数</td>
<td align="left">8</td>
<td align="left">(2)</td>
</tr>
<tr>
<td align="left"><code>n</code></td>
<td align="left"><code>ssize_t</code></td>
<td align="left">整数</td>
<td align="left"></td>
<td align="left">(3)</td>
</tr>
<tr>
<td align="left"><code>N</code></td>
<td align="left"><code>size_t</code></td>
<td align="left">整数</td>
<td align="left"></td>
<td align="left">(3)</td>
</tr>
<tr>
<td align="left"><code>e</code></td>
<td align="left">(6)</td>
<td align="left">float</td>
<td align="left">2</td>
<td align="left">(4)</td>
</tr>
<tr>
<td align="left"><code>f</code></td>
<td align="left">float</td>
<td align="left">float</td>
<td align="left">4</td>
<td align="left">(4)</td>
</tr>
<tr>
<td align="left"><code>d</code></td>
<td align="left">double</td>
<td align="left">float</td>
<td align="left">8</td>
<td align="left">(4)</td>
</tr>
<tr>
<td align="left"><code>s</code></td>
<td align="left">char[]</td>
<td align="left">字节串</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>p</code></td>
<td align="left">char[]</td>
<td align="left">字节串</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>P</code></td>
<td align="left">void*</td>
<td align="left">整数</td>
<td align="left"></td>
<td align="left">(5)</td>
</tr>
</tbody></table>
<p>在 3.3 版更改: 增加了对 <code>'n'</code> 和 <code>'N'</code> 格式的支持</p>
<p>在 3.6 版更改: 添加了对 <code>'e'</code> 格式的支持。</p>
<p>注释：</p>
<ol>
<li><p><code>'?'</code> 转换码对应于 C99 定义的 _Bool 类型。 如果此类型不可用，则使用 char 来模拟。 在标准模式下，它总是以一个字节表示。</p>
</li>
<li><p>当尝试使用任何整数转换码打包一个非整数时，如果该非整数具有 <code>__index__()</code> 方法，则会在打包之前调用该方法将参数转换为一个整数。</p>
<p>在 3.2 版更改: 增加了针对非整数使用 <code>__index__()</code> 方法的特性。</p>
</li>
<li><p><code>'n'</code> 和 <code>'N'</code> 转换码仅对本机大小可用（选择为默认或使用 <code>'@'</code> 字节顺序字符）。 对于标准大小，你可以使用适合你的应用的任何其他整数格式。</p>
</li>
<li><p>对于 <code>'f'</code>, <code>'d'</code> 和 <code>'e'</code> 转换码，打包表示形式将使用 IEEE 754 binary32, binary64 或 binary16 格式 (分别对应于 <code>'f'</code>, <code>'d'</code> 或 <code>'e'</code>)，无论平台使用何种浮点格式。</p>
</li>
<li><p><code>'P'</code> 格式字符仅对本机字节顺序可用（选择为默认或使用 <code>'@'</code> 字节顺序字符）。 字节顺序字符 <code>'='</code> 选择使用基于主机系统的小端或大端排序。 struct 模块不会将其解读为本机排序，因此 <code>'P'</code> 格式将不可用。</p>
</li>
<li><p>IEEE 754 binary16 “半精度” 类型是在 <a href="https://en.wikipedia.org/wiki/IEEE_floating_point#IEEE_754-2008" target="_blank" rel="noopener">IEEE 754 标准</a> 的 2008 修订版中引入的。 它包含一个符号位，5 个指数位和 11 个精度位（明确存储 10 位），可以完全精确地表示大致范围在 <code>6.1e-05</code> 和 <code>6.5e+04</code> 之间的数字。 此类型并不被 C 编译器广泛支持：在一台典型的机器上，可以使用 unsigned short 进行存储，但不会被用于数学运算。 请参阅维基百科页面 <a href="https://en.wikipedia.org/wiki/Half-precision_floating-point_format" target="_blank" rel="noopener">half-precision floating-point format</a> 了解详情。</p>
</li>
</ol>
<p>格式字符之前可以带有整数重复计数。 例如，格式字符串 <code>'4h'</code> 的含义与 <code>'hhhh'</code> 完全相同。</p>
<p>格式之间的空白字符会被忽略；但是计数及其格式字符中不可有空白字符。</p>
<p>对于 <code>'s'</code> 格式字符，计数会被解析为字节的长度，而不是像其他格式字符那样的重复计数；例如，<code>'10s'</code> 表示一个 10 字节的字节串，而 <code>'10c'</code> 表示 10 个字符。 如果未给出计数，则默认值为 1。 对于打包操作，字节串会被适当地截断或填充空字节以符合要求。 对于解包操作，结果字节对象总是恰好具有指定数量的字节。 作为特殊情况，<code>'0s'</code> 表示一个空字符串（而 <code>'0c'</code> 表示 0 个字符）。</p>
<p>当使用某一种整数格式 (<code>'b'</code>, <code>'B'</code>, <code>'h'</code>, <code>'H'</code>, <code>'i'</code>, <code>'I'</code>, <code>'l'</code>, <code>'L'</code>, <code>'q'</code>, <code>'Q'</code>) 打包值 <code>x</code> 时，如果 <code>x</code> 在该格式的有效范围之外则将引发 <code>struct.error</code>。</p>
<p>在 3.1 版更改: 在之前版本中，某些整数格式包装了超范围的值并会引发 <code>DeprecationWarning</code> 而不是 <code>struct.error</code>。</p>
<p><code>'p'</code> 格式字符用于编码“Pascal 字符串”，即存储在由计数指定的 <em>固定长度字节</em> 中的可变长度短字符串。 所存储的第一个字节为字符串长度或 255 中的较小值。 之后是字符串对应的字节。 如果传入 <code>pack()</code> 的字符串过长（超过计数值减 1），则只有字符串前 <code>count-1</code> 个字节会被存储。 如果字符串短于 <code>count-1</code>，则会填充空字节以使得恰好使用了 count 个字节。 请注意对于 <code>unpack()</code>，<code>'p'</code> 格式字符会消耗 <code>count</code> 个字节，但返回的字符串永远不会包含超过 255 个字节。</p>
<p>对于 <code>'?'</code> 格式字符，返回值为 <code>True</code> 或 <code>False</code>。 在打包时将会使用参数对象的逻辑值。 以本机或标准 bool 类型表示的 0 或 1 将被打包，任何非零值在解包时将为 <code>True</code>。</p>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>注解</p>
<p>所有示例都假定使用一台大端机器的本机字节顺序、大小和对齐方式。</p>
<p>打包/解包三个整数的基础示例:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> struct <span class="token keyword">import</span> <span class="token operator">*</span>
<span class="token operator">>></span><span class="token operator">></span> pack<span class="token punctuation">(</span><span class="token string">'hhl'</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span>
b<span class="token string">'\x00\x01\x00\x02\x00\x00\x00\x03'</span>
<span class="token operator">>></span><span class="token operator">></span> unpack<span class="token punctuation">(</span><span class="token string">'hhl'</span><span class="token punctuation">,</span> b<span class="token string">'\x00\x01\x00\x02\x00\x00\x00\x03'</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> calcsize<span class="token punctuation">(</span><span class="token string">'hhl'</span><span class="token punctuation">)</span>
<span class="token number">8</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>解包的字段可通过将它们赋值给变量或将结果包装为一个具名元组来命名:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> record <span class="token operator">=</span> b<span class="token string">'raymond   \x32\x12\x08\x01\x08'</span>
<span class="token operator">>></span><span class="token operator">></span> name<span class="token punctuation">,</span> serialnum<span class="token punctuation">,</span> school<span class="token punctuation">,</span> gradelevel <span class="token operator">=</span> unpack<span class="token punctuation">(</span><span class="token string">'&lt;10sHHb'</span><span class="token punctuation">,</span> record<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> collections <span class="token keyword">import</span> namedtuple
<span class="token operator">>></span><span class="token operator">></span> Student <span class="token operator">=</span> namedtuple<span class="token punctuation">(</span><span class="token string">'Student'</span><span class="token punctuation">,</span> <span class="token string">'name serialnum school gradelevel'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> Student<span class="token punctuation">.</span>_make<span class="token punctuation">(</span>unpack<span class="token punctuation">(</span><span class="token string">'&lt;10sHHb'</span><span class="token punctuation">,</span> record<span class="token punctuation">)</span><span class="token punctuation">)</span>
Student<span class="token punctuation">(</span>name<span class="token operator">=</span>b<span class="token string">'raymond   '</span><span class="token punctuation">,</span> serialnum<span class="token operator">=</span><span class="token number">4658</span><span class="token punctuation">,</span> school<span class="token operator">=</span><span class="token number">264</span><span class="token punctuation">,</span> gradelevel<span class="token operator">=</span><span class="token number">8</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>格式字符的顺序可能对大小产生影响，因为满足对齐要求所需的填充是不同的:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> pack<span class="token punctuation">(</span><span class="token string">'ci'</span><span class="token punctuation">,</span> b<span class="token string">'*'</span><span class="token punctuation">,</span> <span class="token number">0x12131415</span><span class="token punctuation">)</span>
b<span class="token string">'*\x00\x00\x00\x12\x13\x14\x15'</span>
<span class="token operator">>></span><span class="token operator">></span> pack<span class="token punctuation">(</span><span class="token string">'ic'</span><span class="token punctuation">,</span> <span class="token number">0x12131415</span><span class="token punctuation">,</span> b<span class="token string">'*'</span><span class="token punctuation">)</span>
b<span class="token string">'\x12\x13\x14\x15*'</span>
<span class="token operator">>></span><span class="token operator">></span> calcsize<span class="token punctuation">(</span><span class="token string">'ci'</span><span class="token punctuation">)</span>
<span class="token number">8</span>
<span class="token operator">>></span><span class="token operator">></span> calcsize<span class="token punctuation">(</span><span class="token string">'ic'</span><span class="token punctuation">)</span>
<span class="token number">5</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>以下格式 <code>'llh0l'</code> 指定在末尾有两个填充字节，假定 long 类型按 4 个字节的边界对齐:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> pack<span class="token punctuation">(</span><span class="token string">'llh0l'</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span>
b<span class="token string">'\x00\x00\x00\x01\x00\x00\x00\x02\x00\x03\x00\x00'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>这仅当本机大小和对齐方式生效时才会起作用；标准大小和对齐方式并不会强制进行任何对齐。</p>
<h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p><code>struct</code> 模块还定义了以下类型：</p>
<p><em>class</em> <code>struct.Struct</code>(<em>format</em>)</p>
<p>返回一个新的 Struct 对象，它会根据格式字符串 <em>format</em> 来写入和读取二进制数据。 一次性地创建 Struct 对象并调用其方法相比使用同样的格式调用 <code>struct</code> 函数更为高效，因为这样格式字符串只需被编译一次。</p>
<p>注解</p>
<p>传递给 <code>Struct</code> 和模块层级函数的已编译版最新格式字符串会被缓存，因此只使用少量格式字符串的程序无需担心重用单独的 <code>Struct</code> 实例。</p>
<p>已编译的 Struct 对象支持以下方法和属性：</p>
<ul>
<li><p><code>pack</code>(<em>v1</em>, <em>v2</em>, <em>…</em>)</p>
<p>等价于 <code>pack()</code> 函数，使用了已编译的格式。 (<code>len(result)</code> 将等于 <code>size</code>。)</p>
</li>
<li><p><code>pack_into</code>(<em>buffer</em>, <em>offset</em>, <em>v1</em>, <em>v2</em>, <em>…</em>)</p>
<p>等价于 <code>pack_into()</code> 函数，使用了已编译的格式。</p>
</li>
<li><p><code>unpack</code>(<em>buffer</em>)</p>
<p>等价于 <code>unpack()</code> 函数，使用了已编译的格式。 缓冲区的字节大小必须等于 <code>size</code>。</p>
</li>
<li><p><code>unpack_from</code>(<em>buffer</em>, <em>offset=0</em>)</p>
<p>等价于 <code>unpack_from()</code> 函数，使用了已编译的格式。 缓冲区的字节大小从位置 <em>offset</em> 开始必须至少为 <code>size</code>。</p>
</li>
<li><p><code>iter_unpack</code>(<em>buffer</em>)</p>
<p>等价于 <code>iter_unpack()</code> 函数，使用了已编译的格式。 缓冲区的大小必须为 <code>size</code> 的整数倍。</p>
<p>3.4 新版功能.</p>
</li>
<li><p><code>format</code></p>
<p>用于构造此 Struct 对象的格式字符串。</p>
<p>在 3.7 版更改: 格式字符串类型现在是 <code>str</code> 而不再是 <code>bytes</code>。</p>
</li>
<li><p><code>size</code></p>
<p>计算出对应于 <code>format</code> 的结构大小（亦即 <code>pack()</code> 方法所产生的字节串对象的大小）。</p>
</li>
</ul>
<h2 id="codecs-—-编解码器注册和相关基类"><a href="#codecs-—-编解码器注册和相关基类" class="headerlink" title="codecs —- 编解码器注册和相关基类"></a><code>codecs</code> —- 编解码器注册和相关基类</h2><p><strong>源代码：</strong> <a href="https://github.com/python/cpython/tree/3.10/Lib/codecs.py" target="_blank" rel="noopener">Lib/codecs.py</a></p>
<hr>
<p>这个模块定义了标准 Python 编解码器（编码器和解码器）的基类，并提供接口用来访问内部的 Python 编解码器注册表，该注册表负责管理编解码器和错误处理的查找过程。 大多数标准编解码器都属于 文本编码，它们可将文本编码为字节串，但也提供了一些编解码器可将文本编码为文本，以及字节串编码为字节串。 自定义编解码器可以在任意类型间进行编码和解码，但某些模块特性仅适用于 文本编码 或将数据编码为 <code>字节串</code> 的编解码器。</p>
<p>该模块定义了以下用于使用任何编解码器进行编码和解码的函数:</p>
<p><code>codecs.encode</code>(<em>obj</em>, <em>encoding=’utf-8’</em>, <em>errors=’strict’</em>)</p>
<p>使用为 <em>encoding</em> 注册的编解码器对 <em>obj</em> 进行编码。</p>
<p>可以给定 <em>Errors</em> 以设置所需要的错误处理方案。 默认的错误处理方案 <code>'strict'</code> 表示编码错误将引发 <code>ValueError</code> (或更特定编解码器相关的子类，例如 <code>UnicodeEncodeError</code>)。 </p>
<p><code>codecs.decode</code>(<em>obj</em>, <em>encoding=’utf-8’</em>, <em>errors=’strict’</em>)</p>
<p>使用为 <em>encoding</em> 注册的编解码器对 <em>obj</em> 进行解码。</p>
<p>可以给定 <em>Errors</em> 以设置所需要的错误处理方案。 默认的错误处理方案 <code>'strict'</code> 表示编码错误将引发 <code>ValueError</code> (或更特定编解码器相关的子类，例如 <code>UnicodeDecodeError</code>)。 </p>
<p>每种编解码器的完整细节也可以直接查找获取：</p>
<p><code>codecs.lookup</code>(<em>encoding</em>)</p>
<p>在 Python 编解码器注册表中查找编解码器信息，并返回一个 <code>CodecInfo</code> 对象，其定义见下文。</p>
<p>首先将会在注册表缓存中查找编码，如果未找到，则会扫描注册的搜索函数列表。 如果没有找到 <code>CodecInfo</code> 对象，则将引发 <code>LookupError</code>。 否则，<code>CodecInfo</code> 对象将被存入缓存并返回给调用者。</p>
<p><em>class</em> <code>codecs.CodecInfo</code>(<em>encode</em>, <em>decode</em>, <em>streamreader=None</em>, <em>streamwriter=None</em>, <em>incrementalencoder=None</em>, <em>incrementaldecoder=None</em>, <em>name=None</em>)</p>
<p>查找编解码器注册表所得到的编解码器细节信息。 构造器参数将保存为同名的属性：</p>
<ul>
<li><p><code>name</code></p>
<p>编码名称</p>
</li>
<li><p><code>encode</code></p>
<p><code>decode</code></p>
<p>无状态的编码和解码函数。 它们必须是具有与 Codec 的 <code>encode()</code> 和 <code>decode()</code> 方法相同接口的函数或方法。 这些函数或方法应当工作于无状态的模式。</p>
</li>
<li><p><code>incrementalencoder</code></p>
<p><code>incrementaldecoder</code></p>
<p>增量式的编码器和解码器类或工厂函数。 这些函数必须分别提供由基类 <code>IncrementalEncoder</code> 和 <code>IncrementalDecoder</code> 所定义的接口。 增量式编解码器可以保持状态。</p>
</li>
<li><p><code>streamwriter</code></p>
<p><code>streamreader</code></p>
<p>流式写入器和读取器类或工厂函数。 这些函数必须分别提供由基类 <code>StreamWriter</code> 和 <code>StreamReader</code> 所定义的接口。 流式编解码器可以保持状态。</p>
</li>
</ul>
<p>为了简化对各种编解码器组件的访问，本模块提供了以下附加函数，它们使用 <code>lookup()</code> 来执行编解码器查找：</p>
<p><code>codecs.getencoder</code>(<em>encoding</em>)</p>
<p>查找给定编码的编解码器并返回其编码器函数。</p>
<p>在编码无法找到时将引发 <code>LookupError</code>。</p>
<p><code>codecs.getdecoder</code>(<em>encoding</em>)</p>
<p>查找给定编码的编解码器并返回其解码器函数。</p>
<p>在编码无法找到时将引发 <code>LookupError</code>。</p>
<p><code>codecs.getincrementalencoder</code>(<em>encoding</em>)</p>
<p>查找给定编码的编解码器并返回其增量式编码器类或工厂函数。</p>
<p>在编码无法找到或编解码器不支持增量式编码器时将引发 <code>LookupError</code>。</p>
<p><code>codecs.getincrementaldecoder</code>(<em>encoding</em>)</p>
<p>查找给定编码的编解码器并返回其增量式解码器类或工厂函数。</p>
<p>在编码无法找到或编解码器不支持增量式解码器时将引发 <code>LookupError</code>。</p>
<p><code>codecs.getreader</code>(<em>encoding</em>)</p>
<p>查找给定编码的编解码器并返回其 <code>StreamReader</code> 类或工厂函数。</p>
<p>在编码无法找到时将引发 <code>LookupError</code>。</p>
<p><code>codecs.getwriter</code>(<em>encoding</em>)</p>
<p>查找给定编码的编解码器并返回其 <code>StreamWriter</code> 类或工厂函数。</p>
<p>在编码无法找到时将引发 <code>LookupError</code>。</p>
<p>自定义编解码器的启用是通过注册适当的编解码器搜索函数：</p>
<p><code>codecs.register</code>(<em>search_function</em>)</p>
<p>注册一个编解码器搜索函数。 搜索函数预期接收一个参数，即全部以小写字母表示的编码格式名称，其中中连字符和空格会被转换为下划线，并返回一个 <code>CodecInfo</code> 对象。 在搜索函数无法找到给定编码格式的情况下，它应当返回 <code>None</code>。</p>
<p>在 3.9 版更改: 连字符和空格会被转换为下划线。</p>
<p><code>codecs.unregister</code>(<em>search_function</em>)</p>
<p>注销一个编解码器搜索函数并清空注册表缓存。 如果指定搜索函数未被注册，则不做任何操作。</p>
<p>3.10 新版功能.</p>
<p>虽然内置的 <code>open()</code> 和相关联的 <code>io</code> 模块是操作已编码文本文件的推荐方式，但本模块也提供了额外的工具函数和类，允许在操作二进制文件时使用更多各类的编解码器：</p>
<p><code>codecs.open</code>(<em>filename</em>, <em>mode=’r’</em>, <em>encoding=None</em>, <em>errors=’strict’</em>, <em>buffering=- 1</em>)</p>
<p>使用给定的 <em>mode</em> 打开已编码的文件并返回一个 <code>StreamReaderWriter</code> 的实例，提供透明的编码/解码。 默认的文件模式为 <code>'r'</code>，表示以读取模式打开文件。</p>
<p>注解</p>
<p>下层的已编码文件总是以二进制模式打开。 在读取和写入时不会自动执行 <code>'\n'</code> 的转换。 <em>mode</em> 参数可以是内置 <code>open()</code> 函数所接受的任意二进制模式；<code>'b'</code> 会被自动添加。</p>
<p><em>encoding</em> 指定文件所要使用的编码格式。 允许任何编码为字节串或从字节串解码的编码格式，而文件方法所支持的数据类型则取决于所使用的编解码器。</p>
<p>可以指定 <em>errors</em> 来定义错误处理方案。 默认值 <code>'strict'</code> 表示在出现编码错误时引发 <code>ValueError</code>。</p>
<p><em>buffering</em> 的含义与内置 <code>open()</code> 函数中的相同。 默认值 -1 表示将使用默认的缓冲区大小。</p>
<p><code>codecs.EncodedFile</code>(<em>file</em>, <em>data_encoding</em>, <em>file_encoding=None</em>, <em>errors=’strict’</em>)</p>
<p>返回一个 <code>StreamRecoder</code> 实例，它提供了 <em>file</em> 的透明转码包装版本。 当包装版本被关闭时原始文件也会被关闭。</p>
<p>写入已包装文件的数据会根据给定的 <em>data_encoding</em> 解码，然后以使用 <em>file_encoding</em> 的字节形式写入原始文件。 从原始文件读取的字节串将根据 <em>file_encoding</em> 解码，其结果将使用 <em>data_encoding</em> 进行编码。</p>
<p>如果 <em>file_encoding</em> 未给定，则默认为 <em>data_encoding</em>。</p>
<p>可以指定 <em>errors</em> 来定义错误处理方案。 默认值 <code>'strict'</code> 表示在出现编码错误时引发 <code>ValueError</code>。</p>
<p><code>codecs.iterencode</code>(<em>iterator</em>, <em>encoding</em>, <em>errors=’strict’</em>, <em>**kwargs</em>)</p>
<p>使用增量式编码器通过迭代来编码由 <em>iterator</em> 所提供的输入。 此函数属于 generator。 <em>errors</em> 参数（以及任何其他关键字参数）会被传递给增量式编码器。</p>
<p>此函数要求编解码器接受 <code>str</code> 对象形式的文本进行编码。 因此它不支持字节到字节的编码器，例如 <code>base64_codec</code>。</p>
<p><code>codecs.iterdecode</code>(<em>iterator</em>, <em>encoding</em>, <em>errors=’strict’</em>, <em>**kwargs</em>)</p>
<p>使用增量式解码器通过迭代来解码由 <em>iterator</em> 所提供的输入。 此函数属于 generator。 <em>errors</em> 参数（以及任何其他关键字参数）会被传递给增量式解码器。</p>
<p>此函数要求编解码器接受 <code>bytes</code> 对象进行解码。 因此它不支持文本到文本的编码器，例如 <code>rot_13</code>，但是 <code>rot_13</code> 可以通过同样效果的 <code>iterencode()</code> 来使用。</p>
<p>本模块还提供了以下常量，适用于读取和写入依赖于平台的文件：</p>
<pre><code>codecs.BOM
codecs.BOM_BE
codecs.BOM_LE
codecs.BOM_UTF8
codecs.BOM_UTF16
codecs.BOM_UTF16_BE
codecs.BOM_UTF16_LE
codecs.BOM_UTF32
codecs.BOM_UTF32_BE
codecs.BOM_UTF32_LE</code></pre><p>这些常量定义了多种字节序列，即一些编码格式的 Unicode 字节顺序标记（BOM）。 它们在 UTF-16 和 UTF-32 数据流中被用以指明所使用的字节顺序，并在 UTF-8 中被用作 Unicode 签名。 <code>BOM_UTF16</code> 是 <code>BOM_UTF16_BE</code> 或 <code>BOM_UTF16_LE</code>，具体取决于平台的本机字节顺序，<code>BOM</code> 是 <code>BOM_UTF16</code> 的别名, <code>BOM_LE</code> 是 <code>BOM_UTF16_LE</code> 的别名，<code>BOM_BE</code> 是 <code>BOM_UTF16_BE</code> 的别名。 其他序列则表示 UTF-8 和 UTF-32 编码格式中的 BOM。</p>
<h3 id="编解码器基类"><a href="#编解码器基类" class="headerlink" title="编解码器基类"></a>编解码器基类</h3><p><code>codecs</code> 模块定义了一系列基类用来定义配合编解码器对象进行工作的接口，并且也可用作定制编解码器实现的基础。</p>
<p>每种编解码器必须定义四个接口以便用作 Python 中的编解码器：无状态编码器、无状态解码器、流读取器和流写入器。 流读取器和写入器通常会重用无状态编码器/解码器来实现文件协议。 编解码器作者还需要定义编解码器将如何处理编码和解码错误。</p>
<h4 id="错误处理方案"><a href="#错误处理方案" class="headerlink" title="错误处理方案"></a>错误处理方案</h4><p>为了简化和标准化错误处理，编解码器可以通过接受 <em>errors</em> 字符串参数来实现不同的错误处理方案。 所有标准的 Python 编解码器都定义并实现了以下字符串值：</p>
<table>
<thead>
<tr>
<th align="left">值</th>
<th align="left">含意</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>‘strict’</code></td>
<td align="left">引发 <code>UnicodeError</code> (或其子类)；这是默认的方案。 在 <code>strict_errors()</code> 中实现。</td>
</tr>
<tr>
<td align="left"><code>‘ignore’</code></td>
<td align="left">忽略错误格式的数据并且不加进一步通知就继续执行。 在 <code>ignore_errors()</code> 中实现。</td>
</tr>
</tbody></table>
<p>以下错误处理方案仅适用于 文本编码:</p>
<table>
<thead>
<tr>
<th align="left">值</th>
<th align="left">含意</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>‘replace’</code></td>
<td align="left">使用适当的替换标记进行替换；Python 内置编解码器将在解码时使用官方 <code>U+FFFD</code> 替换字符，而在编码时使用 ‘?’ 。 在 <code>replace_errors()</code> 中实现。</td>
</tr>
<tr>
<td align="left"><code>‘xmlcharrefreplace’</code></td>
<td align="left">使用适当的 XML 字符引用进行替换（仅在编码时）。 在 <code>xmlcharrefreplace_errors()</code> 中实现。</td>
</tr>
<tr>
<td align="left"><code>‘backslashreplace’</code></td>
<td align="left">使用带反斜杠的转义序列进行替换。 在 <code>backslashreplace_errors()</code> 中实现。</td>
</tr>
<tr>
<td align="left"><code>‘namereplace’</code></td>
<td align="left">使用 <code>\N{…}</code> 转义序列进行替换（仅在编码时）。 在 <code>namereplace_errors()</code> 中实现。</td>
</tr>
<tr>
<td align="left"><code>‘surrogateescape’</code></td>
<td align="left">在解码时，将字节替换为 <code>U+DC80</code> 至 <code>U+DCFF</code> 范围内的单个代理代码。 当在编码数据时使用 <code>‘surrogateescape’</code> 错误处理方案时，此代理将被转换回相同的字节。 （请参阅 <a href="https://www.python.org/dev/peps/pep-0383" target="_blank" rel="noopener"><strong>PEP 383</strong></a> 了解详情。）</td>
</tr>
</tbody></table>
<p>此外，以下错误处理方案被专门用于指定的编解码器：</p>
<table>
<thead>
<tr>
<th align="left">值</th>
<th align="left">编解码器</th>
<th align="left">含意</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>‘surrogatepass’</code></td>
<td align="left">utf-8, utf-16, utf-32, utf-16-be, utf-16-le, utf-32-be, utf-32-le</td>
<td align="left">允许编码和解码代理代码。 这些编解码器通常会将出现的代理代码视为错误。</td>
</tr>
</tbody></table>
<p>3.1 新版功能: <code>'surrogateescape'</code> 和 <code>'surrogatepass'</code> 错误处理方案。</p>
<p>在 3.4 版更改: <code>'surrogatepass'</code> 错误处理方案现在适用于 utf-16* 和 utf-32* 编解码器。</p>
<p>3.5 新版功能: <code>'namereplace'</code> 错误处理方案。</p>
<p>在 3.5 版更改: <code>'backslashreplace'</code> 错误处理方案现在适用于解码和转换。</p>
<p>允许的值集合可以通过注册新命名的错误处理方案来扩展：</p>
<p><code>codecs.register_error</code>(<em>name</em>, <em>error_handler</em>)</p>
<p>在名称 <em>name</em> 之下注册错误处理函数 <em>error_handler*。 当 *name</em> 被指定为错误形参时，<em>error_handler</em> 参数所指定的对象将在编码和解码期间发生错误的情况下被调用，</p>
<p>对于编码操作，将会调用 <em>error_handler</em> 并传入一个 <code>UnicodeEncodeError</code> 实例，其中包含有关错误位置的信息。 错误处理程序必须引发此异常或别的异常，或者也可以返回一个元组，其中包含输入的不可编码部分的替换对象，以及应当继续进行编码的位置。 替换对象可以为 <code>str</code> 或 <code>bytes</code> 类型。 如果替换对象为字节串，编码器将简单地将其复制到输出缓冲区。 如果替换对象为字符串，编码器将对替换对象进行编码。 对原始输入的编码操作会在指定位置继续进行。 负的位置值将被视为相对于输入字符串的末尾。 如果结果位置超出范围则将引发 <code>IndexError</code>。</p>
<p>解码和转换的做法很相似，不同之处在于将把 <code>UnicodeDecodeError</code> 或 <code>UnicodeTranslateError</code> 传给处理程序，并且来自错误处理程序的替换对象将被直接放入输出。</p>
<p>之前注册的错误处理方案（包括标准错误处理方案）可通过名称进行查找：</p>
<p><code>codecs.lookup_error</code>(<em>name</em>)</p>
<p>返回之前在名称 <em>name</em> 之下注册的错误处理方案。</p>
<p>在处理方案无法找到时将引发 <code>LookupError</code>。</p>
<p>以下标准错误处理方案也可通过模块层级函数的方式来使用：</p>
<p><code>codecs.strict_errors</code>(<em>exception</em>)</p>
<p>实现 <code>'strict'</code> 错误处理方案：每个编码或解码错误都会引发 <code>UnicodeError</code>。</p>
<p><code>codecs.replace_errors</code>(<em>exception</em>)</p>
<p>实现 <code>'replace'</code> 错误处理方案 (仅用于 文本编码)：编码错误替换为 <code>'?'</code> (并由编解码器编码)，解码错误替换为 <code>'\ufffd'</code> (Unicode 替换字符)。</p>
<p><code>codecs.ignore_errors</code>(<em>exception</em>)</p>
<p>实现 <code>'ignore'</code> 错误处理方案：忽略错误格式的数据并且不加进一步通知就继续执行。</p>
<p><code>codecs.xmlcharrefreplace_errors</code>(<em>exception</em>)</p>
<p>实现 <code>'xmlcharrefreplace'</code> 错误处理方案 (仅用于 文本编码 的编码过程)：不可编码的字符将以适当的 XML 字符引用进行替换。</p>
<p><code>codecs.backslashreplace_errors</code>(<em>exception</em>)</p>
<p>实现 <code>'backslashreplace'</code> 错误处理方案 (仅用于 文本编码)：错误格式的数据将以带反斜杠的转义序列进行替换。</p>
<p><code>codecs.namereplace_errors</code>(<em>exception</em>)</p>
<p>实现 <code>'namereplace'</code> 错误处理方案 (仅用于 文本编码 的编码过程)：不可编码的字符将以 <code>\N{...}</code> 转义序列进行替换。</p>
<p>3.5 新版功能.</p>
<h4 id="无状态的编码和解码"><a href="#无状态的编码和解码" class="headerlink" title="无状态的编码和解码"></a>无状态的编码和解码</h4><p>基本 <code>Codec</code> 类定义了这些方法，同时还定义了无状态编码器和解码器的函数接口：</p>
<p><code>Codec.encode</code>(<em>input</em>[, <em>errors</em>])</p>
<p>编码 <em>input</em> 对象并返回一个元组 (输出对象, 消耗长度)。 例如，text encoding 会使用特定的字符集编码格式 (例如 <code>cp1252</code> 或 <code>iso-8859-1</code>) 将字符串转换为字节串对象。</p>
<p><em>errors</em> 参数定义了要应用的错误处理方案。 默认为 <code>'strict'</code> 处理方案。</p>
<p>此方法不一定会在 <code>Codec</code> 实例中保存状态。 可使用必须保存状态的 <code>StreamWriter</code> 作为编解码器以便高效地进行编码。</p>
<p>编码器必须能够处理零长度的输入并在此情况下返回输出对象类型的空对象。</p>
<p><code>Codec.decode</code>(<em>input</em>[, <em>errors</em>])</p>
<p>解码 <em>input</em> 对象并返回一个元组 (输出对象, 消耗长度)。 例如，text encoding 的解码操作会使用特定的字符集编码格式将字节串对象转换为字符串对象。</p>
<p>对于文本编码格式和字节到字节编解码器，<em>input</em> 必须为一个字节串对象或提供了只读缓冲区接口的对象 — 例如，缓冲区对象和映射到内存的文件。</p>
<p><em>errors</em> 参数定义了要应用的错误处理方案。 默认为 <code>'strict'</code> 处理方案。</p>
<p>此方法不一定会在 <code>Codec</code> 实例中保存状态。 可使用必须保存状态的 <code>StreamReader</code> 作为编解码器以便高效地进行解码。</p>
<p>解码器必须能够处理零长度的输入并在此情况下返回输出对象类型的空对象。</p>
<h4 id="增量式的编码和解码"><a href="#增量式的编码和解码" class="headerlink" title="增量式的编码和解码"></a>增量式的编码和解码</h4><p><code>IncrementalEncoder</code> 和 <code>IncrementalDecoder</code> 类提供了增量式编码和解码的基本接口。 对输入的编码/解码不是通过对无状态编码器/解码器的一次调用，而是通过对增量式编码器/解码器的 <code>encode()</code>/<code>decode()</code> 方法的多次调用。 增量式编码器/解码器会在方法调用期间跟踪编码/解码过程。</p>
<p>调用 <code>encode()</code>/<code>decode()</code> 方法后的全部输出相当于将所有通过无状态编码器/解码器进行编码/解码的单个输入连接在一起所得到的输出。</p>
<h5 id="IncrementalEncoder-对象"><a href="#IncrementalEncoder-对象" class="headerlink" title="IncrementalEncoder 对象"></a>IncrementalEncoder 对象</h5><p><code>IncrementalEncoder</code> 类用来对一个输入进行分步编码。 它定义了以下方法，每个增量式编码器都必须定义这些方法以便与 Python 编解码器注册表相兼容。</p>
<p><em>class</em> <code>codecs.IncrementalEncoder</code>(<em>errors=’strict’</em>)</p>
<p><code>IncrementalEncoder</code> 实例的构造器。</p>
<p>所有增量式编码器必须提供此构造器接口。 它们可以自由地添加额外的关键字参数，但只有在这里定义的参数才会被 Python 编解码器注册表所使用。</p>
<p><code>IncrementalEncoder</code> 可以通过提供 <em>errors</em> 关键字参数来实现不同的错误处理方案。 </p>
<p><em>errors</em> 参数将被赋值给一个同名的属性。 通过对此属性赋值就可以在 <code>IncrementalEncoder</code> 对象的生命期内在不同的错误处理策略之间进行切换。</p>
<ul>
<li><p><code>encode</code>(<em>object</em>[, <em>final</em>])</p>
<p>编码 <em>object</em> (会将编码器的当前状态纳入考虑) 并返回已编码的结果对象。 如果这是对 <code>encode()</code> 的最终调用则 <em>final</em> 必须为真值（默认为假值）。</p>
</li>
<li><p><code>reset</code>()</p>
<p>将编码器重置为初始状态。 输出将被丢弃：调用 <code>.encode(object, final=True)</code>，在必要时传入一个空字节串或字符串，重置编码器并得到输出。</p>
</li>
<li><p><code>getstate</code>()</p>
<p>返回编码器的当前状态，该值必须为一个整数。 实现应当确保 <code>0</code> 是最常见的状态。 （比整数更复杂的状态表示可以通过编组/选择状态并将结果字符串的字节数据编码为整数来转换为一个整数值）。</p>
</li>
<li><p><code>setstate</code>(<em>state</em>)</p>
<p>将编码器的状态设为 <em>state*。 *state</em> 必须为 <code>getstate()</code> 所返回的一个编码器状态。</p>
</li>
</ul>
<h5 id="IncrementalDecoder-对象"><a href="#IncrementalDecoder-对象" class="headerlink" title="IncrementalDecoder 对象"></a>IncrementalDecoder 对象</h5><p><code>IncrementalDecoder</code> 类用来对一个输入进行分步解码。 它定义了以下方法，每个增量式解码器都必须定义这些方法以便与 Python 编解码器注册表相兼容。</p>
<p><em>class</em> <code>codecs.IncrementalDecoder</code>(<em>errors=’strict’</em>)</p>
<p><code>IncrementalDecoder</code> 实例的构造器。</p>
<p>所有增量式解码器必须提供此构造器接口。 它们可以自由地添加额外的关键字参数，但只有在这里定义的参数才会被 Python 编解码器注册表所使用。</p>
<p><code>IncrementalDecoder</code> 可以通过提供 <em>errors</em> 关键字参数来实现不同的错误处理方案。 </p>
<p><em>errors</em> 参数将被赋值给一个同名的属性。 通过对此属性赋值就可以在 <code>IncrementalDecoder</code> 对象的生命期内在不同的错误处理策略之间进行切换。</p>
<ul>
<li><p><code>decode</code>(<em>object</em>[, <em>final</em>])</p>
<p>解码 <em>object</em> (会将解码器的当前状态纳入考虑) 并返回已解码的结果对象。 如果这是对 <code>decode()</code> 的最终调用则 <em>final</em> 必须为真值（默认为假值）。 如果 <em>final</em> 为真值则解码器必须对输入进行完全解码并且必须 刷新所有缓冲区。 如果这无法做到（例如由于在输入结束时字节串序列不完整）则它必须像在无状态的情况下那样初始化错误处理（这可能引发一个异常）。</p>
</li>
<li><p><code>reset</code>()</p>
<p>将解码器重置为初始状态。</p>
</li>
<li><p><code>getstate</code>()</p>
<p>返回解码器的当前状态。 这必须为一个二元组，第一项必须是包含尚未解码的输入的缓冲区。 第二项必须为一个整数，可以表示附加状态信息。 （实现应当确保 <code>0</code> 是最常见的附加状态信息。） 如果此附加状态信息为 <code>0</code> 则必须可以将解码器设为没有已缓冲输入并且以 <code>0</code> 作为附加状态信息，以便将先前已缓冲的输入馈送到解码器使其返回到先前的状态而不产生任何输出。 （比整数更复杂的附加状态信息可以通过编组/选择状态信息并将结果字符串的字节数据编码为整数来转换为一个整数值。）</p>
</li>
<li><p><code>setstate</code>(<em>state</em>)</p>
<p>将解码器的状态设为 <em>state*。 *state</em> 必须为 <code>getstate()</code> 所返回的一个解码器状态。</p>
</li>
</ul>
<h4 id="流式的编码和解码"><a href="#流式的编码和解码" class="headerlink" title="流式的编码和解码"></a>流式的编码和解码</h4><p><code>StreamWriter</code> 和 <code>StreamReader</code> 类提供了一些泛用工作接口，可被用来非常方便地实现新的编码格式子模块。 </p>
<h5 id="StreamWriter-对象"><a href="#StreamWriter-对象" class="headerlink" title="StreamWriter 对象"></a>StreamWriter 对象</h5><p><code>StreamWriter</code> 类是 <code>Codec</code> 的子类，它定义了以下方法，每个流式写入器都必须定义这些方法以便与 Python 编解码器注册表相兼容。</p>
<p><em>class</em> <code>codecs.StreamWriter</code>(<em>stream</em>, <em>errors=’strict’</em>)</p>
<p><code>StreamWriter</code> 实例的构造器。</p>
<p>所有流式写入器必须提供此构造器接口。 它们可以自由地添加额外的关键字参数，但只有在这里定义的参数才会被 Python 编解码器注册表所使用。</p>
<p><em>stream</em> 参数必须为一个基于特定编解码器打开用于写入文本或二进制数据的文件类对象。</p>
<p><code>StreamWriter</code> 可以通过提供 <em>errors</em> 关键字参数来实现不同的错误处理方案。 </p>
<p><em>errors</em> 参数将被赋值给一个同名的属性。 通过对此属性赋值就可以在 <code>StreamWriter</code> 对象的生命期内在不同的错误处理策略之间进行切换。</p>
<ul>
<li><p><code>write</code>(<em>object</em>)</p>
<p>将编码后的对象内容写入到流。</p>
</li>
<li><p><code>writelines</code>(<em>list</em>)</p>
<p>将拼接后的字符串列表写入到流（可能通过重用 <code>write()</code> 方法）。 标准的字节到字节编解码器不支持此方法。</p>
</li>
<li><p><code>reset</code>()</p>
<p>重置用于保持内部状态的编解码器缓冲区。</p>
<p>调用此方法应当确保在干净的状态下放入输出数据，以允许直接添加新的干净数据而无须重新扫描整个流来恢复状态。</p>
</li>
</ul>
<p>除了上述的方法，<code>StreamWriter</code> 还必须继承来自下层流的所有其他方法和属性。</p>
<h5 id="StreamReader-对象"><a href="#StreamReader-对象" class="headerlink" title="StreamReader 对象"></a>StreamReader 对象</h5><p><code>StreamReader</code> 类是 <code>Codec</code> 的子类，它定义了以下方法，每个流式读取器都必须定义这些方法以便与 Python 编解码器注册表相兼容。</p>
<p><em>class</em> <code>codecs.StreamReader</code>(<em>stream</em>, <em>errors=’strict’</em>)</p>
<p><code>StreamReader</code> 实例的构造器。</p>
<p>所有流式读取器必须提供此构造器接口。 它们可以自由地添加额外的关键字参数，但只有在这里定义的参数才会被 Python 编解码器注册表所使用。</p>
<p><em>stream</em> 参数必须为一个基于特定编解码器打开用于读取文本或二进制数据的文件类对象。</p>
<p><code>StreamReader</code> 可以通过提供 <em>errors</em> 关键字参数来实现不同的错误处理方案。</p>
<p><em>errors</em> 参数将被赋值给一个同名的属性。 通过对此属性赋值就可以在 <code>StreamReader</code> 对象的生命期内在不同的错误处理策略之间进行切换。</p>
<p><em>errors</em> 参数所允许的值集合可以使用 <code>register_error()</code> 来扩展。</p>
<ul>
<li><p><code>read</code>([<em>size</em>[, <em>chars</em>[, <em>firstline</em>]]])</p>
<p>解码来自流的数据并返回结果对象。</p>
<p><em>chars</em> 参数指明要返回的解码后码位或字节数量。 <code>read()</code> 方法绝不会返回超出请求数量的数据，但如果可用数量不足，它可能返回少于请求数量的数据。</p>
<p><em>size</em> 参数指明要读取并解码的已编码字节或码位的最大数量近似值。 解码器可以适当地修改此设置。 默认值 -1 表示尽可能多地读取并解码。 此形参的目的是防止一次性解码过于巨大的文件。</p>
<p><em>firstline</em> 旗标指明如果在后续行发生解码错误，则仅返回第一行就足够了。</p>
<p>此方法应当使用“贪婪”读取策略，这意味着它应当在编码格式定义和给定大小所允许的情况下尽可能多地读取数据，例如，如果在流上存在可选的编码结束或状态标记，这些内容也应当被读取。</p>
</li>
<li><p><code>readline</code>([<em>size</em>[, <em>keepends</em>]])</p>
<p>从输入流读取一行并返回解码后的数据。</p>
<p>如果给定了 <em>size</em>，则将其作为 size 参数传递给流的 <code>read()</code> 方法。</p>
<p>如果 <em>keepends</em> 为假值，则行结束符将从返回的行中去除。</p>
</li>
<li><p><code>readlines</code>([<em>sizehint</em>[, <em>keepends</em>]])</p>
<p>从输入流读取所有行并将其作为一个行列表返回。</p>
<p>行结束符会使用编解码器的 <code>decode()</code> 方法来实现，并且如果 <em>keepends</em> 为真值则会将其包含在列表条目中。</p>
<p>如果给定了 <em>sizehint*，则将其作为 *size</em> 参数传递给流的 <code>read()</code> 方法。</p>
</li>
<li><p><code>reset</code>()</p>
<p>重置用于保持内部状态的编解码器缓冲区。</p>
<p>请注意不应当对流进行重定位。 使用此方法的主要目的是为了能够从解码错误中恢复。</p>
</li>
</ul>
<p>除了上述的方法，<code>StreamReader</code> 还必须继承来自下层流的所有其他方法和属性。</p>
<h5 id="StreamReaderWriter-对象"><a href="#StreamReaderWriter-对象" class="headerlink" title="StreamReaderWriter 对象"></a>StreamReaderWriter 对象</h5><p><code>StreamReaderWriter</code> 是一个方便的类，允许对同时工作于读取和写入模式的流进行包装。</p>
<p>其设计使得开发者可以使用 <code>lookup()</code> 函数所返回的工厂函数来构造实例。</p>
<p><em>class</em> <code>codecs.StreamReaderWriter</code>(<em>stream</em>, <em>Reader</em>, <em>Writer</em>, <em>errors=’strict’</em>)</p>
<p>创建一个 <code>StreamReaderWriter</code> 实例。 <em>stream</em> 必须为一个文件类对象。 <em>Reader</em> 和 <em>Writer</em> 必须为分别提供了 <code>StreamReader</code> 和 <code>StreamWriter</code> 接口的工厂函数或类。 错误处理通过与流式读取器和写入器所定义的相同方式来完成。</p>
<p><code>StreamReaderWriter</code> 实例定义了 <code>StreamReader</code> 和 <code>StreamWriter</code> 类的组合接口。 它们还继承了来自下层流的所有其他方法和属性。</p>
<h5 id="StreamRecoder-对象"><a href="#StreamRecoder-对象" class="headerlink" title="StreamRecoder 对象"></a>StreamRecoder 对象</h5><p><code>StreamRecoder</code> 将数据从一种编码格式转换为另一种，这对于处理不同编码环境的情况有时会很有用。</p>
<p>其设计使得开发者可以使用 <code>lookup()</code> 函数所返回的工厂函数来构造实例。</p>
<p><em>class</em> <code>codecs.StreamRecoder</code>(<em>stream</em>, <em>encode</em>, <em>decode</em>, <em>Reader</em>, <em>Writer</em>, <em>errors=’strict’</em>)</p>
<p>创建一个实现了双向转换的 <code>StreamRecoder</code> 实例: <em>encode</em> 和 <em>decode</em> 工作于前端 — 对代码可见的数据调用 <code>read()</code> 和 <code>write()</code>，而 <em>Reader</em> 和 <em>Writer</em> 工作于后端 — <em>stream</em> 中的数据。</p>
<p>你可以使用这些对象来进行透明转码，例如从 Latin-1 转为 UTF-8 以及反向转换。</p>
<p><em>stream</em> 参数必须为一个文件类对象。</p>
<p><em>encode</em> 和 <em>decode</em> 参数必须遵循 <code>Codec</code> 接口。 <em>Reader</em> 和 <em>Writer</em> 必须为分别提供了 <code>StreamReader</code> 和 <code>StreamWriter</code> 接口对象的工厂函数或类。</p>
<p>错误处理通过与流式读取器和写入器所定义的相同方式来完成。</p>
<p><code>StreamRecoder</code> 实例定义了 <code>StreamReader</code> 和 <code>StreamWriter</code> 类的组合接口。 它们还继承了来自下层流的所有其他方法和属性。</p>
<h3 id="编码格式与-Unicode"><a href="#编码格式与-Unicode" class="headerlink" title="编码格式与 Unicode"></a>编码格式与 Unicode</h3><p>字符串在系统内部存储为 <code>0x0</code>–<code>0x10FFFF</code> 范围内的码位序列。 （请参阅 <a href="https://www.python.org/dev/peps/pep-0393" target="_blank" rel="noopener"><strong>PEP 393</strong></a> 了解有关实现的详情。） 一旦字符串对象要在 CPU 和内存以外使用，字节的大小端顺序和字节数组的存储方式就成为一个关键问题。 如同使用其他编解码器一样，将字符串序列化为字节序列被称为 <em>编码</em>，而从字节序列重建字符串被称为 <em>解码</em>。 存在许多不同的文本序列化编解码器，它们被统称为 文本编码。</p>
<p>最简单的文本编码格式 (称为 <code>'latin-1'</code> 或 <code>'iso-8859-1'</code>) 将码位 0—255 映射为字节值 <code>0x0</code>–<code>0xff</code>，这意味着包含 <code>U+00FF</code> 以上码位的字符串对象无法使用此编解码器进行编码。 这样做将引发 <code>UnicodeEncodeError</code>，其形式类似下面这样（不过详细的错误信息可能会有所不同）: <code>UnicodeEncodeError: 'latin-1' codec can't encode character '\u1234' in position 3: ordinal not in range(256)</code>。</p>
<p>还有另外一组编码格式（所谓的字符映射编码）会选择全部 Unicode 码位的不同子集并设定如何将这些码位映射为字节值 <code>0x0</code>–<code>0xff</code>。 要查看这是如何实现的，只需简单地打开相应源码例如 <code>encodings/cp1252.py</code> (这是一个主要在 Windows 上使用的编码格式)。 其中会有一个包含 256 个字符的字符串常量，指明每个字符所映射的字节值。</p>
<p>所有这些编码格式只能对 Unicode 所定义的 1114112 个码位中的 256 个进行编码。 一种能够存储每个 Unicode 码位的简单而直接的办法就是将每个码位存储为四个连续的字节。 存在两种不同的可能性：以大端序存储或以小端序存储。 这两种编码格式分别被称为 <code>UTF-32-BE</code> 和 <code>UTF-32-LE</code>。 它们的缺点可以举例说明：如果你在一台小端序的机器上使用 <code>UTF-32-BE</code> 则你将必须在编码和解码时翻转字节。 <code>UTF-32</code> 避免了这个问题：字节的排列将总是使用自然顺序。 当这些字节被具有不同字节顺序的 CPU 读取时，则必须进行字节翻转。 为了能够检测 <code>UTF-16</code> 或 <code>UTF-32</code> 字节序列的大小端序，可以使用所谓的 BOM (“字节顺序标记”)。 这对应于 Unicode 字符 <code>U+FEFF</code>。 此字符可添加到每个 <code>UTF-16</code> 或 <code>UTF-32</code> 字节序列的开头。 此字符的字节翻转版本 (<code>0xFFFE</code>) 是一个不可出现于 Unicode 文本中的非法字符。 因此当发现一个 <code>UTF-16</code> 或 <code>UTF-32</code> 字节序列的首个字符是 <code>U+FFFE</code> 时，就必须在解码时进行字节翻转。 不幸的是字符 <code>U+FEFF</code> 还有第二个含义 <code>ZERO WIDTH NO-BREAK SPACE</code>: 即宽度为零并且不允许用来拆分单词的字符。 它可以被用来为语言分析算法提供提示。 在 Unicode 4.0 中用 <code>U+FEFF</code> 表示 <code>ZERO WIDTH NO-BREAK SPACE</code> 已被弃用（改用 <code>U+2060</code> (<code>WORD JOINER</code>) 负责此任务）。 然而 Unicode 软件仍然必须能够处理 <code>U+FEFF</code> 的两个含义：作为 BOM 它被用来确定已编码字节的存储布局，并在字节序列被解码为字符串后将其去除；作为 <code>ZERO WIDTH NO-BREAK SPACE</code> 它是一个普通字符，将像其他字符一样被解码。</p>
<p>There’s another encoding that is able to encode the full range of Unicode characters: UTF-8. UTF-8 is an 8-bit encoding, which means there are no issues with byte order in UTF-8. Each byte in a UTF-8 byte sequence consists of two parts: marker bits (the most significant bits) and payload bits. The marker bits are a sequence of zero to four <code>1</code> bits followed by a <code>0</code> bit. Unicode characters are encoded like this (with x being payload bits, which when concatenated give the Unicode character):</p>
<table>
<thead>
<tr>
<th align="left">范围</th>
<th align="left">编码</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>U-00000000</code> … <code>U-0000007F</code></td>
<td align="left">0xxxxxxx</td>
</tr>
<tr>
<td align="left"><code>U-00000080</code> … <code>U-000007FF</code></td>
<td align="left">110xxxxx 10xxxxxx</td>
</tr>
<tr>
<td align="left"><code>U-00000800</code> … <code>U-0000FFFF</code></td>
<td align="left">1110xxxx 10xxxxxx 10xxxxxx</td>
</tr>
<tr>
<td align="left"><code>U-00010000</code> … <code>U-0010FFFF</code></td>
<td align="left">11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</td>
</tr>
</tbody></table>
<p>Unicode 字符最不重要的一个位就是最右侧的二进制位 x。</p>
<p>由于 UTF-8 是一种 8 位编码格式，因此 BOM 是不必要的，并且已编码字符串中的任何 <code>U+FEFF</code> 字符（即使是作为第一个字符）都会被视为是 <code>ZERO WIDTH NO-BREAK SPACE</code>。</p>
<p>在没有外部信息的情况下，就不可能毫无疑义地确定一个字符串使用了何种编码格式。 每种字符映射编码格式都可以解码任意的随机字节序列。 然而对 UTF-8 来说这却是不可能的，因为 UTF-8 字节序列具有不允许任意字节序列的特别结构。 为了提升 UTF-8 编码检测的可靠性，Microsoft 发明了一种 UTF-8 变体形式 (Python 2.5 称之为 <code>"utf-8-sig"</code>) 专门用于其 Notepad 程序：在任何 Unicode 字符在被写入文件之前，会先写入一个 UTF-8 编码的 BOM (它看起来是这样一个字节序列: <code>0xef</code>, <code>0xbb</code>, <code>0xbf</code>)。 由于任何字符映射编码后的文件都不大可能以这些字节值开头（例如它们会映射为</p>
<blockquote>
<p>LATIN SMALL LETTER I WITH DIAERESIS</p>
<p>RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK</p>
<p>INVERTED QUESTION MARK</p>
</blockquote>
<p>对于 iso-8859-1 编码格式来说），这提升了根据字节序列来正确猜测 <code>utf-8-sig</code> 编码格式的成功率。 所以在这里 BOM 的作用并不是帮助确定生成字节序列所使用的字节顺序，而是作为帮助猜测编码格式的记号。 在进行编码时 utf-8-sig 编解码器将把 <code>0xef</code>, <code>0xbb</code>, <code>0xbf</code> 作为头三个字节写入文件。 在进行解码时 <code>utf-8-sig</code> 将跳过这三个字节，如果它们作为文件的头三个字节出现的话。 在 UTF-8 中并不推荐使用 BOM，通常应当避免它们的出现。</p>
<h3 id="标准编码"><a href="#标准编码" class="headerlink" title="标准编码"></a>标准编码</h3><p>Python 自带了许多内置的编解码器，它们的实现或者是通过 C 函数，或者是通过映射表。 以下表格是按名称排序的编解码器列表，并提供了一些常见别名以及编码格式通常针对的语言。 别名和语言列表都不是详尽无遗的。 请注意仅有大小写区别或使用连字符替代下划线的拼写形式也都是有效的别名；因此，<code>'utf-8'</code> 是 <code>'utf_8'</code> 编解码器的有效别名。</p>
<p><strong>CPython implementation detail:</strong> 有些常见编码格式可以绕过编解码器查找机制来提升性能。 这些优化机会对于 CPython 来说仅能通过一组有限的别名（大小写不敏感）来识别：utf-8, utf8, latin-1, latin1, iso-8859-1, iso8859-1, mbcs (Windows 专属), ascii, us-ascii, utf-16, utf16, utf-32, utf32, 也包括使用下划线替代连字符的的形式。 使用这些编码格式的其他别名可能会导致更慢的执行速度。</p>
<p>在 3.6 版更改: 可识别针对 us-ascii 的优化机会。</p>
<p>许多字符集都支持相同的语言。 它们在个别字符（例如是否支持 EURO SIGN 等）以及给字符所分配的码位方面存在差异。 特别是对于欧洲语言来说，通常存在以下几种变体：</p>
<ul>
<li>某个 ISO 8859 编码集</li>
<li>某个 Microsoft Windows 编码页，通常是派生自某个 8859 编码集，但会用附加的图形字符来替换控制字符。</li>
<li>某个 IBM EBCDIC 编码页</li>
<li>某个 IBM PC 编码页，通常会兼容 ASCII</li>
</ul>
<table>
<thead>
<tr>
<th align="left">编码</th>
<th align="left">别名</th>
<th align="left">语言</th>
</tr>
</thead>
<tbody><tr>
<td align="left">ascii</td>
<td align="left">646, us-ascii</td>
<td align="left">英语</td>
</tr>
<tr>
<td align="left">big5</td>
<td align="left">big5-tw, csbig5</td>
<td align="left">繁体中文</td>
</tr>
<tr>
<td align="left">big5hkscs</td>
<td align="left">big5-hkscs, hkscs</td>
<td align="left">繁体中文</td>
</tr>
<tr>
<td align="left">cp037</td>
<td align="left">IBM037, IBM039</td>
<td align="left">英语</td>
</tr>
<tr>
<td align="left">cp273</td>
<td align="left">273, IBM273, csIBM273</td>
<td align="left">德语3.4 新版功能.</td>
</tr>
<tr>
<td align="left">cp424</td>
<td align="left">EBCDIC-CP-HE, IBM424</td>
<td align="left">希伯来语</td>
</tr>
<tr>
<td align="left">cp437</td>
<td align="left">437, IBM437</td>
<td align="left">英语</td>
</tr>
<tr>
<td align="left">cp500</td>
<td align="left">EBCDIC-CP-BE, EBCDIC-CP-CH, IBM500</td>
<td align="left">西欧</td>
</tr>
<tr>
<td align="left">cp720</td>
<td align="left"></td>
<td align="left">阿拉伯语</td>
</tr>
<tr>
<td align="left">cp737</td>
<td align="left"></td>
<td align="left">希腊语</td>
</tr>
<tr>
<td align="left">cp775</td>
<td align="left">IBM775</td>
<td align="left">波罗的海语言</td>
</tr>
<tr>
<td align="left">cp850</td>
<td align="left">850, IBM850</td>
<td align="left">西欧</td>
</tr>
<tr>
<td align="left">cp852</td>
<td align="left">852, IBM852</td>
<td align="left">中欧和东欧</td>
</tr>
<tr>
<td align="left">cp855</td>
<td align="left">855, IBM855</td>
<td align="left">保加利亚语，白俄罗斯语，马其顿语，俄语，塞尔维亚语</td>
</tr>
<tr>
<td align="left">cp856</td>
<td align="left"></td>
<td align="left">希伯来语</td>
</tr>
<tr>
<td align="left">cp857</td>
<td align="left">857, IBM857</td>
<td align="left">土耳其语</td>
</tr>
<tr>
<td align="left">cp858</td>
<td align="left">858, IBM858</td>
<td align="left">西欧</td>
</tr>
<tr>
<td align="left">cp860</td>
<td align="left">860, IBM860</td>
<td align="left">葡萄牙语</td>
</tr>
<tr>
<td align="left">cp861</td>
<td align="left">861, CP-IS, IBM861</td>
<td align="left">冰岛语</td>
</tr>
<tr>
<td align="left">cp862</td>
<td align="left">862, IBM862</td>
<td align="left">希伯来语</td>
</tr>
<tr>
<td align="left">cp863</td>
<td align="left">863, IBM863</td>
<td align="left">加拿大语</td>
</tr>
<tr>
<td align="left">cp864</td>
<td align="left">IBM864</td>
<td align="left">阿拉伯语</td>
</tr>
<tr>
<td align="left">cp865</td>
<td align="left">865, IBM865</td>
<td align="left">丹麦语/挪威语</td>
</tr>
<tr>
<td align="left">cp866</td>
<td align="left">866, IBM866</td>
<td align="left">俄语</td>
</tr>
<tr>
<td align="left">cp869</td>
<td align="left">869, CP-GR, IBM869</td>
<td align="left">希腊语</td>
</tr>
<tr>
<td align="left">cp874</td>
<td align="left"></td>
<td align="left">泰语</td>
</tr>
<tr>
<td align="left">cp875</td>
<td align="left"></td>
<td align="left">希腊语</td>
</tr>
<tr>
<td align="left">cp932</td>
<td align="left">932, ms932, mskanji, ms-kanji</td>
<td align="left">日语</td>
</tr>
<tr>
<td align="left">cp949</td>
<td align="left">949, ms949, uhc</td>
<td align="left">韩语</td>
</tr>
<tr>
<td align="left">cp950</td>
<td align="left">950, ms950</td>
<td align="left">繁体中文</td>
</tr>
<tr>
<td align="left">cp1006</td>
<td align="left"></td>
<td align="left">乌尔都语</td>
</tr>
<tr>
<td align="left">cp1026</td>
<td align="left">ibm1026</td>
<td align="left">土耳其语</td>
</tr>
<tr>
<td align="left">cp1125</td>
<td align="left">1125, ibm1125, cp866u, ruscii</td>
<td align="left">乌克兰语3.4 新版功能.</td>
</tr>
<tr>
<td align="left">cp1140</td>
<td align="left">ibm1140</td>
<td align="left">西欧</td>
</tr>
<tr>
<td align="left">cp1250</td>
<td align="left">windows-1250</td>
<td align="left">中欧和东欧</td>
</tr>
<tr>
<td align="left">cp1251</td>
<td align="left">windows-1251</td>
<td align="left">保加利亚语，白俄罗斯语，马其顿语，俄语，塞尔维亚语</td>
</tr>
<tr>
<td align="left">cp1252</td>
<td align="left">windows-1252</td>
<td align="left">西欧</td>
</tr>
<tr>
<td align="left">cp1253</td>
<td align="left">windows-1253</td>
<td align="left">希腊语</td>
</tr>
<tr>
<td align="left">cp1254</td>
<td align="left">windows-1254</td>
<td align="left">土耳其语</td>
</tr>
<tr>
<td align="left">cp1255</td>
<td align="left">windows-1255</td>
<td align="left">希伯来语</td>
</tr>
<tr>
<td align="left">cp1256</td>
<td align="left">windows-1256</td>
<td align="left">阿拉伯语</td>
</tr>
<tr>
<td align="left">cp1257</td>
<td align="left">windows-1257</td>
<td align="left">波罗的海语言</td>
</tr>
<tr>
<td align="left">cp1258</td>
<td align="left">windows-1258</td>
<td align="left">越南语</td>
</tr>
<tr>
<td align="left">euc_jp</td>
<td align="left">eucjp, ujis, u-jis</td>
<td align="left">日语</td>
</tr>
<tr>
<td align="left">euc_jis_2004</td>
<td align="left">jisx0213, eucjis2004</td>
<td align="left">日语</td>
</tr>
<tr>
<td align="left">euc_jisx0213</td>
<td align="left">eucjisx0213</td>
<td align="left">日语</td>
</tr>
<tr>
<td align="left">euc_kr</td>
<td align="left">euckr, korean, ksc5601, ks_c-5601, ks_c-5601-1987, ksx1001, ks_x-1001</td>
<td align="left">韩语</td>
</tr>
<tr>
<td align="left">gb2312</td>
<td align="left">chinese, csiso58gb231280, euc-cn, euccn, eucgb2312-cn, gb2312-1980, gb2312-80, iso-ir-58</td>
<td align="left">简体中文</td>
</tr>
<tr>
<td align="left">gbk</td>
<td align="left">936, cp936, ms936</td>
<td align="left">统一汉语</td>
</tr>
<tr>
<td align="left">gb18030</td>
<td align="left">gb18030-2000</td>
<td align="left">统一汉语</td>
</tr>
<tr>
<td align="left">hz</td>
<td align="left">hzgb, hz-gb, hz-gb-2312</td>
<td align="left">简体中文</td>
</tr>
<tr>
<td align="left">iso2022_jp</td>
<td align="left">csiso2022jp, iso2022jp, iso-2022-jp</td>
<td align="left">日语</td>
</tr>
<tr>
<td align="left">iso2022_jp_1</td>
<td align="left">iso2022jp-1, iso-2022-jp-1</td>
<td align="left">日语</td>
</tr>
<tr>
<td align="left">iso2022_jp_2</td>
<td align="left">iso2022jp-2, iso-2022-jp-2</td>
<td align="left">日语，韩语，简体中文，西欧，希腊语</td>
</tr>
<tr>
<td align="left">iso2022_jp_2004</td>
<td align="left">iso2022jp-2004, iso-2022-jp-2004</td>
<td align="left">日语</td>
</tr>
<tr>
<td align="left">iso2022_jp_3</td>
<td align="left">iso2022jp-3, iso-2022-jp-3</td>
<td align="left">日语</td>
</tr>
<tr>
<td align="left">iso2022_jp_ext</td>
<td align="left">iso2022jp-ext, iso-2022-jp-ext</td>
<td align="left">日语</td>
</tr>
<tr>
<td align="left">iso2022_kr</td>
<td align="left">csiso2022kr, iso2022kr, iso-2022-kr</td>
<td align="left">韩语</td>
</tr>
<tr>
<td align="left">latin_1</td>
<td align="left">iso-8859-1, iso8859-1, 8859, cp819, latin, latin1, L1</td>
<td align="left">西欧</td>
</tr>
<tr>
<td align="left">iso8859_2</td>
<td align="left">iso-8859-2, latin2, L2</td>
<td align="left">中欧和东欧</td>
</tr>
<tr>
<td align="left">iso8859_3</td>
<td align="left">iso-8859-3, latin3, L3</td>
<td align="left">世界语，马耳他语</td>
</tr>
<tr>
<td align="left">iso8859_4</td>
<td align="left">iso-8859-4, latin4, L4</td>
<td align="left">波罗的海语言</td>
</tr>
<tr>
<td align="left">iso8859_5</td>
<td align="left">iso-8859-5, cyrillic</td>
<td align="left">保加利亚语，白俄罗斯语，马其顿语，俄语，塞尔维亚语</td>
</tr>
<tr>
<td align="left">iso8859_6</td>
<td align="left">iso-8859-6, arabic</td>
<td align="left">阿拉伯语</td>
</tr>
<tr>
<td align="left">iso8859_7</td>
<td align="left">iso-8859-7, greek, greek8</td>
<td align="left">希腊语</td>
</tr>
<tr>
<td align="left">iso8859_8</td>
<td align="left">iso-8859-8, hebrew</td>
<td align="left">希伯来语</td>
</tr>
<tr>
<td align="left">iso8859_9</td>
<td align="left">iso-8859-9, latin5, L5</td>
<td align="left">土耳其语</td>
</tr>
<tr>
<td align="left">iso8859_10</td>
<td align="left">iso-8859-10, latin6, L6</td>
<td align="left">北欧语言</td>
</tr>
<tr>
<td align="left">iso8859_11</td>
<td align="left">iso-8859-11, thai</td>
<td align="left">泰语</td>
</tr>
<tr>
<td align="left">iso8859_13</td>
<td align="left">iso-8859-13, latin7, L7</td>
<td align="left">波罗的海语言</td>
</tr>
<tr>
<td align="left">iso8859_14</td>
<td align="left">iso-8859-14, latin8, L8</td>
<td align="left">凯尔特语</td>
</tr>
<tr>
<td align="left">iso8859_15</td>
<td align="left">iso-8859-15, latin9, L9</td>
<td align="left">西欧</td>
</tr>
<tr>
<td align="left">iso8859_16</td>
<td align="left">iso-8859-16, latin10, L10</td>
<td align="left">东南欧</td>
</tr>
<tr>
<td align="left">johab</td>
<td align="left">cp1361, ms1361</td>
<td align="left">韩语</td>
</tr>
<tr>
<td align="left">koi8_r</td>
<td align="left"></td>
<td align="left">俄语</td>
</tr>
<tr>
<td align="left">koi8_t</td>
<td align="left"></td>
<td align="left">塔吉克3.5 新版功能.</td>
</tr>
<tr>
<td align="left">koi8_u</td>
<td align="left"></td>
<td align="left">乌克兰语</td>
</tr>
<tr>
<td align="left">kz1048</td>
<td align="left">kz_1048, strk1048_2002, rk1048</td>
<td align="left">哈萨克语3.5 新版功能.</td>
</tr>
<tr>
<td align="left">mac_cyrillic</td>
<td align="left">maccyrillic</td>
<td align="left">保加利亚语，白俄罗斯语，马其顿语，俄语，塞尔维亚语</td>
</tr>
<tr>
<td align="left">mac_greek</td>
<td align="left">macgreek</td>
<td align="left">希腊语</td>
</tr>
<tr>
<td align="left">mac_iceland</td>
<td align="left">maciceland</td>
<td align="left">冰岛语</td>
</tr>
<tr>
<td align="left">mac_latin2</td>
<td align="left">maclatin2, maccentraleurope, mac_centeuro</td>
<td align="left">中欧和东欧</td>
</tr>
<tr>
<td align="left">mac_roman</td>
<td align="left">macroman, macintosh</td>
<td align="left">西欧</td>
</tr>
<tr>
<td align="left">mac_turkish</td>
<td align="left">macturkish</td>
<td align="left">土耳其语</td>
</tr>
<tr>
<td align="left">ptcp154</td>
<td align="left">csptcp154, pt154, cp154, cyrillic-asian</td>
<td align="left">哈萨克语</td>
</tr>
<tr>
<td align="left">shift_jis</td>
<td align="left">csshiftjis, shiftjis, sjis, s_jis</td>
<td align="left">日语</td>
</tr>
<tr>
<td align="left">shift_jis_2004</td>
<td align="left">shiftjis2004, sjis_2004, sjis2004</td>
<td align="left">日语</td>
</tr>
<tr>
<td align="left">shift_jisx0213</td>
<td align="left">shiftjisx0213, sjisx0213, s_jisx0213</td>
<td align="left">日语</td>
</tr>
<tr>
<td align="left">utf_32</td>
<td align="left">U32, utf32</td>
<td align="left">所有语言</td>
</tr>
<tr>
<td align="left">utf_32_be</td>
<td align="left">UTF-32BE</td>
<td align="left">所有语言</td>
</tr>
<tr>
<td align="left">utf_32_le</td>
<td align="left">UTF-32LE</td>
<td align="left">所有语言</td>
</tr>
<tr>
<td align="left">utf_16</td>
<td align="left">U16, utf16</td>
<td align="left">所有语言</td>
</tr>
<tr>
<td align="left">utf_16_be</td>
<td align="left">UTF-16BE</td>
<td align="left">所有语言</td>
</tr>
<tr>
<td align="left">utf_16_le</td>
<td align="left">UTF-16LE</td>
<td align="left">所有语言</td>
</tr>
<tr>
<td align="left">utf_7</td>
<td align="left">U7, unicode-1-1-utf-7</td>
<td align="left">所有语言</td>
</tr>
<tr>
<td align="left">utf_8</td>
<td align="left">U8, UTF, utf8, cp65001</td>
<td align="left">所有语言</td>
</tr>
<tr>
<td align="left">utf_8_sig</td>
<td align="left"></td>
<td align="left">所有语言</td>
</tr>
</tbody></table>
<p>在 3.4 版更改: utf-16* 和 utf-32* 编码器将不再允许编码代理码位 (<code>U+D800</code>–<code>U+DFFF</code>)。 utf-32* 解码器将不再解码与代理码位相对应的字节序列。</p>
<p>在 3.8 版更改: <code>cp65001</code> 现在是 <code>utf_8</code> 的一个别名。</p>
<h3 id="Python-专属的编码格式"><a href="#Python-专属的编码格式" class="headerlink" title="Python 专属的编码格式"></a>Python 专属的编码格式</h3><p>有一些预定义编解码器是 Python 专属的，因此它们在 Python 之外没有意义。 这些编解码器按其所预期的输入和输出类型在下表中列出（请注意虽然文本编码是编解码器最常见的使用场景，但下层的编解码器架构支持任意数据转换而不仅是文本编码）。 对于非对称编解码器，该列描述的含义是编码方向。</p>
<h4 id="文字编码"><a href="#文字编码" class="headerlink" title="文字编码"></a>文字编码</h4><p>以下编解码器提供了 <code>str</code> 到 <code>bytes</code> 的编码和 bytes-like object 到 <code>str</code> 的解码，类似于 Unicode 文本编码。</p>
<table>
<thead>
<tr>
<th align="left">编码</th>
<th align="left">别名</th>
<th align="left">含意</th>
</tr>
</thead>
<tbody><tr>
<td align="left">idna</td>
<td align="left"></td>
<td align="left">实现 <a href="https://tools.ietf.org/html/rfc3490.html" target="_blank" rel="noopener"><strong>RFC 3490</strong></a>。仅支持 <code>errors=’strict’</code> 。</td>
</tr>
<tr>
<td align="left">mbcs</td>
<td align="left">ansi, dbcs</td>
<td align="left">Windows 专属：根据 ANSI 代码页（CP_ACP）对操作数进行编码。</td>
</tr>
<tr>
<td align="left">oem</td>
<td align="left"></td>
<td align="left">Windows 专属：根据 OEM 代码页（CP_OEMCP）对操作数进行编码。3.6 新版功能.</td>
</tr>
<tr>
<td align="left">palmos</td>
<td align="left"></td>
<td align="left">PalmOS 3.5 的编码格式</td>
</tr>
<tr>
<td align="left">punycode</td>
<td align="left"></td>
<td align="left">实现 <a href="https://tools.ietf.org/html/rfc3492.html" target="_blank" rel="noopener"><strong>RFC 3492</strong></a>。 不支持有状态编解码器。</td>
</tr>
<tr>
<td align="left">raw_unicode_escape</td>
<td align="left"></td>
<td align="left">Latin-1 编码格式附带对其他码位以 <code>\uXXXX</code> 和 <code>\UXXXXXXXX</code> 进行编码。 现有反斜杠不会以任何方式转义。 它被用于 Python 的 pickle 协议。</td>
</tr>
<tr>
<td align="left">undefined</td>
<td align="left"></td>
<td align="left">所有转换都将引发异常，甚至对空字符串也不例外。 错误处理方案会被忽略。</td>
</tr>
<tr>
<td align="left">unicode_escape</td>
<td align="left"></td>
<td align="left">适合用于以 ASCII 编码的 Python 源代码中的 Unicode 字面值内容的编码格式，但引号不会被转义。 对 Latin-1 源代码进行解码。 请注意 Python 源代码实际上默认使用 UTF-8。</td>
</tr>
</tbody></table>
<p>在 3.8 版更改: “unicode_internal” 编解码器已被移除。</p>
<h4 id="二进制转换"><a href="#二进制转换" class="headerlink" title="二进制转换"></a>二进制转换</h4><p>以下编解码器提供了二进制转换: bytes-like object 到 <code>bytes</code> 的映射。 它们不被 <code>bytes.decode()</code> 所支持（该方法只生成 <code>str</code> 类型的输出）。</p>
<table>
<thead>
<tr>
<th align="left">编码</th>
<th align="left">别名</th>
<th align="left">含意</th>
<th align="left">编码器/解码器</th>
</tr>
</thead>
<tbody><tr>
<td align="left">base64_codec</td>
<td align="left">base64, base_64</td>
<td align="left">将操作数转换为多行 MIME base64 (结果总是包含一个末尾的 <code>‘\n’</code>)在 3.4 版更改: 接受任意 bytes-like object 作为输入用于编码和解码</td>
<td align="left"><code>base64.encodebytes()</code> / <code>base64.decodebytes()</code></td>
</tr>
<tr>
<td align="left">bz2_codec</td>
<td align="left">bz2</td>
<td align="left">使用bz2压缩操作数</td>
<td align="left"><code>bz2.compress()</code> / <code>bz2.decompress()</code></td>
</tr>
<tr>
<td align="left">hex_codec</td>
<td align="left">hex</td>
<td align="left">将操作数转换为十六进制表示，每个字节有两位数</td>
<td align="left"><code>binascii.b2a_hex()</code> / <code>binascii.a2b_hex()</code></td>
</tr>
<tr>
<td align="left">quopri_codec</td>
<td align="left">quopri, quotedprintable, quoted_printable</td>
<td align="left">将操作数转换为 MIME 带引号的可打印数据</td>
<td align="left"><code>quopri.encode()</code> 且 <code>quotetabs=True</code> / <code>quopri.decode()</code></td>
</tr>
<tr>
<td align="left">uu_codec</td>
<td align="left">uu</td>
<td align="left">使用uuencode转换操作数</td>
<td align="left"><code>uu.encode()</code> / <code>uu.decode()</code></td>
</tr>
<tr>
<td align="left">zlib_codec</td>
<td align="left">zip, zlib</td>
<td align="left">使用gzip压缩操作数</td>
<td align="left"><code>zlib.compress()</code> / <code>zlib.decompress()</code></td>
</tr>
</tbody></table>
<p>除了 字节类对象，<code>'base64_codec'</code> 也接受仅包含 ASCII 的 <code>str</code> 实例用于解码</p>
<p>3.2 新版功能: 恢复二进制转换。</p>
<p>在 3.4 版更改: 恢复二进制转换的别名。</p>
<h4 id="文字转换"><a href="#文字转换" class="headerlink" title="文字转换"></a>文字转换</h4><p>以下编解码器提供了文本转换: <code>str</code> 到 <code>str</code> 的映射。 它不被 <code>str.encode()</code> 所支持（该方法只生成 <code>bytes</code> 类型的输出）。</p>
<table>
<thead>
<tr>
<th align="left">编码</th>
<th align="left">别名</th>
<th align="left">含意</th>
</tr>
</thead>
<tbody><tr>
<td align="left">rot_13</td>
<td align="left">rot13</td>
<td align="left">返回操作数的凯撒密码加密结果</td>
</tr>
</tbody></table>
<p>3.2 新版功能: 恢复 <code>rot_13</code> 文本转换。</p>
<p>在 3.4 版更改: 恢复 <code>rot13</code> 别名。</p>
<h3 id="encodings-idna-—-应用程序中的国际化域名"><a href="#encodings-idna-—-应用程序中的国际化域名" class="headerlink" title="encodings.idna —- 应用程序中的国际化域名"></a><code>encodings.idna</code> —- 应用程序中的国际化域名</h3><p>此模块实现了 <a href="https://tools.ietf.org/html/rfc3490.html" target="_blank" rel="noopener"><strong>RFC 3490</strong></a> (应用程序中的国际化域名) 和 <a href="https://tools.ietf.org/html/rfc3492.html" target="_blank" rel="noopener"><strong>RFC 3492</strong></a> (Nameprep: 用于国际化域名 (IDN) 的 Stringprep 配置文件)。 它是在 <code>punycode</code> 编码格式和 <code>stringprep</code> 的基础上构建的。</p>
<p>如果你需要来自 <a href="https://tools.ietf.org/html/rfc5891.html" target="_blank" rel="noopener"><strong>RFC 5891</strong></a> 和 <a href="https://tools.ietf.org/html/rfc5895.html" target="_blank" rel="noopener"><strong>RFC 5895</strong></a> 的 IDNA 2008 标准，请使用第三方 idna 模块 <a href="https://pypi.org/project/idna/" target="_blank" rel="noopener">https://pypi.org/project/idna/</a></p>
<p>这些 RFC 共同定义了一个在域名中支持非 ASCII 字符的协议。 一个包含非 ASCII 字符的域名 (例如 <code>www.Alliancefrançaise.nu</code>) 会被转换为兼容 ASCII 的编码格式 (简称 ACE，例如 <code>www.xn--alliancefranaise-npb.nu</code>)。 随后此域名的 ACE 形式可以用于所有由于特定协议而不允许使用任意字符的场合，例如 DNS 查询，HTTP <em>Host</em> 字段等等。 此转换是在应用中进行的；如有可能将对用户可见：应用应当透明地将 Unicode 域名标签转换为线上的 IDNA，并在 ACE 标签被呈现给用户之前将其转换回 Unicode。</p>
<p>Python 以多种方式支持这种转换: <code>idna</code> 编解码器执行 Unicode 和 ACE 之间的转换，基于在 <a href="https://tools.ietf.org/html/rfc3490.html#section-3.1" target="_blank" rel="noopener"><strong>section 3.1 of RFC 3490</strong></a> 中定义的分隔字符将输入字符串拆分为标签，再根据需要将每个标签转换为 ACE，相反地又会基于 <code>.</code> 分隔符将输入字节串拆分为标签，再将找到的任何 ACE 标签转换为 Unicode。 此外，<code>socket</code> 模块可透明地将 Unicode 主机名转换为 ACE，以便应用在将它们传给 socket 模块时无须自行转换主机名。 除此之外，许多包含以主机名作为函数参数的模块例如 <code>http.client</code> 和 <code>ftplib</code> 都接受 Unicode 主机名（并且 <code>http.client</code> 也会在 <em>Host</em> 字段中透明地发送 IDNA 主机名，如果它需要发送该字段的话）。</p>
<p>当从线路接收主机名时（例如反向名称查找），到 Unicode 的转换不会自动被执行：希望向用户提供此种主机名的应用应当将它们解码为 Unicode。</p>
<p><code>encodings.idna</code> 模块还实现了 nameprep 过程，该过程会对主机名执行特定的规范化操作，以实现国际域名的大小写不敏感特性与合并相似的字符。 如果有需要可以直接使用 nameprep 函数。</p>
<p><code>encodings.idna.nameprep</code>(<em>label</em>)</p>
<p>返回 <em>label</em> 经过名称处理操作的版本。 该实现目前基于查询字符串，因此 <code>AllowUnassigned</code> 为真值。</p>
<p><code>encodings.idna.ToASCII</code>(<em>label</em>)</p>
<p>将标签转换为 ASCII，规则定义见 <a href="https://tools.ietf.org/html/rfc3490.html" target="_blank" rel="noopener"><strong>RFC 3490</strong></a>。 <code>UseSTD3ASCIIRules</code> 预设为假值。</p>
<p><code>encodings.idna.ToUnicode</code>(<em>label</em>)</p>
<p>将标签转换为 Unicode，规则定义见 <a href="https://tools.ietf.org/html/rfc3490.html" target="_blank" rel="noopener"><strong>RFC 3490</strong></a>。</p>
<h3 id="encodings-mbcs-—-Windows-ANSI代码页"><a href="#encodings-mbcs-—-Windows-ANSI代码页" class="headerlink" title="encodings.mbcs —- Windows ANSI代码页"></a><code>encodings.mbcs</code> —- Windows ANSI代码页</h3><p>此模块实现ANSI代码页（CP_ACP）。</p>
<p>Availability: 仅Windows可用</p>
<p>在 3.3 版更改: 支持任何错误处理</p>
<p>在 3.2 版更改: 在 3.2 版之前， <em>errors</em> 参数会被忽略；总是会使用 <code>'replace'</code> 进行编码，并使用 <code>'ignore'</code> 进行解码。</p>
<h3 id="encodings-utf-8-sig-—-带BOM签名的UTF-8编解码器"><a href="#encodings-utf-8-sig-—-带BOM签名的UTF-8编解码器" class="headerlink" title="encodings.utf_8_sig —- 带BOM签名的UTF-8编解码器"></a><code>encodings.utf_8_sig</code> —- 带BOM签名的UTF-8编解码器</h3><p>此模块实现了 UTF-8 编解码器的一个变种：在编码时将把 UTF-8 已编码 BOM 添加到 UTF-8 编码字节数据的开头。 对于有状态编码器此操作只执行一次（当首次写入字节流时）。 在解码时将跳过数据开头作为可选项的 UTF-8 已编码 BOM。</p>
<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>Python也提供一些内置数据类型，特别是，<code>dict</code>、 <code>list</code>、<code>set</code>、<code>frozenset</code>、以及 <code>tuple</code>。<code>str</code> 这个类是用来存储Unicode字符串的，而 <code>bytes</code> 和 <code>bytearray</code> 这两个类是用来存储二进制数据的。</p>
<p>本章包含以下模块的文档：</p>
<ul>
<li><code>datetime</code> —- 基本日期和时间类型<ul>
<li>感知型对象和简单型对象</li>
<li>常量</li>
<li>有效的类型<ul>
<li>通用的特征属性</li>
<li>确定一个对象是感知型还是简单型</li>
</ul>
</li>
<li><code>timedelta</code> 类对象<ul>
<li>class:timedelta 用法示例</li>
</ul>
</li>
<li><code>date</code> 对象<ul>
<li>class:date 用法示例</li>
</ul>
</li>
<li><code>datetime</code> 对象<ul>
<li>用法示例: <code>datetime</code></li>
</ul>
</li>
<li><code>time</code> 对象<ul>
<li>用法示例: <code>time</code></li>
</ul>
</li>
<li><code>tzinfo</code> 对象</li>
<li><code>timezone</code> 对象</li>
<li><code>strftime()</code> 和 <code>strptime()</code> 的行为<ul>
<li><code>strftime()</code> 和 <code>strptime()</code> Format Codes</li>
<li>技术细节</li>
</ul>
</li>
</ul>
</li>
<li><code>zoneinfo</code> —- IANA 时区支持<ul>
<li>使用 <code>ZoneInfo</code></li>
<li>数据源<ul>
<li>配置数据源<ul>
<li>编译时配置</li>
<li>环境配置</li>
<li>运行时配置</li>
</ul>
</li>
</ul>
</li>
<li><code>ZoneInfo</code> 类<ul>
<li>字符串表示</li>
<li>封存序列化</li>
</ul>
</li>
<li>函数</li>
<li>全局变量</li>
<li>异常与警告</li>
</ul>
</li>
<li><code>calendar</code> —- 日历相关函数</li>
<li><code>collections</code> —- 容器数据类型<ul>
<li><code>ChainMap</code> 对象<ul>
<li><code>ChainMap</code> 例子和方法</li>
</ul>
</li>
<li><code>Counter</code> 对象</li>
<li><code>deque</code> 对象<ul>
<li><code>deque</code> 用法</li>
</ul>
</li>
<li><code>defaultdict</code> 对象<ul>
<li><code>defaultdict</code> 例子</li>
</ul>
</li>
<li><code>namedtuple()</code> 命名元组的工厂函数</li>
<li><code>OrderedDict</code> 对象<ul>
<li><code>OrderedDict</code> 例子和用法</li>
</ul>
</li>
<li><code>UserDict</code> 对象</li>
<li><code>UserList</code> 对象</li>
<li><code>UserString</code> 对象</li>
</ul>
</li>
<li><code>collections.abc</code> —- 容器的抽象基类<ul>
<li>容器抽象基类</li>
<li>Collections Abstract Base Classes — Detailed Descriptions</li>
<li>Examples and Recipes</li>
</ul>
</li>
<li><code>heapq</code> —- 堆队列算法<ul>
<li>基本示例</li>
<li>优先队列实现说明</li>
<li>理论</li>
</ul>
</li>
<li><code>bisect</code> —- 数组二分查找算法<ul>
<li>性能说明</li>
<li>搜索有序列表</li>
<li>例子</li>
</ul>
</li>
<li><code>array</code> —- 高效的数值数组</li>
<li><code>weakref</code> —- 弱引用<ul>
<li>弱引用对象</li>
<li>示例</li>
<li>终结器对象</li>
<li>比较终结器与 <code>__del__()</code> 方法</li>
</ul>
</li>
<li><code>types</code> —- 动态类型创建和内置类型名称<ul>
<li>动态类型创建</li>
<li>标准解释器类型</li>
<li>附加工具类和函数</li>
<li>协程工具函数</li>
</ul>
</li>
<li><code>copy</code> —- 浅层 (shallow) 和深层 (deep) 复制操作</li>
<li><code>pprint</code> —- 数据美化输出<ul>
<li>PrettyPrinter 对象</li>
<li>示例</li>
</ul>
</li>
<li><code>reprlib</code> —- 另一种 <code>repr()</code> 实现<ul>
<li>Repr 对象</li>
<li>子类化 Repr 对象</li>
</ul>
</li>
<li><code>enum</code> —- 对枚举的支持<ul>
<li>模块内容</li>
<li>创建 Enum</li>
<li>枚举成员及其属性的编程访问</li>
<li>重复的枚举成员和值</li>
<li>确保唯一枚举值</li>
<li>使用自动设定的值</li>
<li>迭代</li>
<li>比较运算</li>
<li>允许的枚举成员和属性</li>
<li>受限的 Enum 子类化</li>
<li>封存</li>
<li>功能性 API</li>
<li>派生的枚举<ul>
<li>IntEnum</li>
<li>IntFlag</li>
<li>旗标</li>
<li>其他事项</li>
</ul>
</li>
<li>何时使用 <code>__new__()</code> 与 <code>__init__()</code></li>
<li>有趣的示例<ul>
<li>省略值<ul>
<li>使用 <code>auto</code></li>
<li>使用 <code>object</code></li>
<li>使用描述性字符串</li>
<li>使用自定义的 <code>__new__()</code></li>
</ul>
</li>
<li>OrderedEnum</li>
<li>DuplicateFreeEnum</li>
<li>Planet</li>
<li>TimePeriod</li>
</ul>
</li>
<li>各种枚举有何区别？<ul>
<li>枚举类</li>
<li>枚举成员（即实例）</li>
<li>细节要点<ul>
<li>支持的 <code>__dunder__</code> 名称</li>
<li>支持的 <code>_sunder_</code> 名称</li>
<li>_Private__names</li>
<li><code>Enum</code> 成员类型</li>
<li><code>Enum</code> 类和成员的布尔值</li>
<li>带有方法的 <code>Enum</code> 类</li>
<li>组合 <code>Flag</code> 的成员</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><code>graphlib</code> —- 操作类似图的结构的功能<ul>
<li>异常</li>
</ul>
</li>
</ul>
<h2 id="datetime-—-基本日期和时间类型"><a href="#datetime-—-基本日期和时间类型" class="headerlink" title="datetime —- 基本日期和时间类型"></a><code>datetime</code> —- 基本日期和时间类型</h2><p><strong>源代码：</strong><a href="https://github.com/python/cpython/tree/3.10/Lib/datetime.py" target="_blank" rel="noopener">Lib/datetime.py</a></p>
<hr>
<p><code>datetime</code> 模块提供用于处理日期和时间的类。</p>
<p>在支持日期时间数学运算的同时，实现的关注点更着重于如何能够更有效地解析其属性用于格式化输出和数据操作。</p>
<h3 id="感知型对象和简单型对象"><a href="#感知型对象和简单型对象" class="headerlink" title="感知型对象和简单型对象"></a>感知型对象和简单型对象</h3><p>日期和时间对象可以根据它们是否包含时区信息而分为“感知型”和“简单型”两类。</p>
<p>充分掌握应用性算法和政治性时间调整信息例如时区和夏令时的情况下，一个 <strong>感知型</strong> 对象就能相对于其他感知型对象来精确定位自身时间点。 感知型对象是用来表示一个没有解释空间的固定时间点。</p>
<p><strong>简单型</strong> 对象没有包含足够多的信息来无歧义地相对于其他 date/time 对象来定位自身时间点。 不论一个简单型对象所代表的是世界标准时间（UTC）、当地时间还是某个其他时区的时间完全取决于具体程序，就像一个特定数字所代表的是米、英里还是质量完全取决于具体程序一样。 简单型对象更易于理解和使用，代价则是忽略了某些现实性考量。</p>
<p>对于要求感知型对象的应用，<code>datetime</code> 和 <code>time</code> 对象具有一个可选的时区信息属性 <code>tzinfo</code>，它可被设为抽象类 <code>tzinfo</code> 的子类的一个实例。 这些 <code>tzinfo</code> 对象会捕获与 UTC 时间的差值、时区名称以及夏令时是否生效等信息。</p>
<p><code>datetime</code> 模块只提供了一个具体的 <code>tzinfo</code> 类，即 <code>timezone</code> 类。 <code>timezone</code> 类可以表示具有相对于 UTC 的固定时差的简单时区，例如 UTC 本身或北美的 EST 和 EDT 时区等。 支持时间的详细程度取决于具体的应用。 世界各地的时间调整规则往往是政治性多于合理性，经常会发生变化，除了 UTC 之外并没有一个能适合所有应用的标准。</p>
<h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>The <code>datetime</code> module exports the following constants:</p>
<pre><code>datetime.MINYEAR</code></pre><p><code>date</code> 或者 <code>datetime</code> 对象允许的最小年份。 常量 <code>MINYEAR</code> 是 <code>1</code> 。</p>
<pre><code>datetime.MAXYEAR</code></pre><p><code>date</code> 或 <code>datetime</code> 对象允许最大的年份。常量 <code>MAXYEAR</code> 是 <code>9999</code> 。</p>
<h3 id="有效的类型"><a href="#有效的类型" class="headerlink" title="有效的类型"></a>有效的类型</h3><p><em>class</em><code>datetime.date</code></p>
<p>一个理想化的简单型日期，它假设当今的公历在过去和未来永远有效。 属性: <code>year</code>, <code>month</code>, and <code>day</code>。</p>
<p><em>class</em><code>datetime.time</code></p>
<p>一个独立于任何特定日期的理想化时间，它假设每一天都恰好等于 24<em>60</em>60 秒。 （这里没有“闰秒”的概念。） 包含属性: <code>hour</code>, <code>minute</code>, <code>second</code>, <code>microsecond</code> 和 <code>tzinfo</code>。</p>
<p><em>class</em><code>datetime.datetime</code></p>
<p>日期和时间的结合。属性：<code>year</code>, <code>month</code>, <code>day</code>, <code>hour</code>, <code>minute</code>, <code>second</code>, <code>microsecond</code>, and <code>tzinfo</code>.</p>
<p><em>class</em><code>datetime.timedelta</code></p>
<p>表示两个 <code>date</code> 对象或 <code>time</code> 对象，或者 <code>datetime</code> 对象之间的时间间隔，精确到微秒。</p>
<p><em>class</em><code>datetime.tzinfo</code></p>
<p>一个描述时区信息对象的抽象基类。 用来给 <code>datetime</code> 和 <code>time</code> 类提供自定义的时间调整概念（例如处理时区和/或夏令时）。</p>
<p><em>class</em><code>datetime.timezone</code></p>
<p>一个实现了 <code>tzinfo</code> 抽象基类的子类，用于表示相对于 世界标准时间（UTC）的偏移量。</p>
<p>3.2 新版功能.</p>
<p>这些类型的对象都是不可变的。</p>
<p>子类关系</p>
<pre><code>object
    timedelta
    tzinfo
        timezone
    time
    date
        datetime</code></pre><h4 id="通用的特征属性"><a href="#通用的特征属性" class="headerlink" title="通用的特征属性"></a>通用的特征属性</h4><p><code>date</code>, <code>datetime</code>, <code>time</code> 和 <code>timezone</code> 类型共享这些通用特性:</p>
<ul>
<li>这些类型的对象都是不可变的。</li>
<li>这些类型的对象是可哈希的，这意味着它们可被作为字典的键。</li>
<li>这些类型的对象支持通过 <code>pickle</code> 模块进行高效的封存。</li>
</ul>
<h4 id="确定一个对象是感知型还是简单型"><a href="#确定一个对象是感知型还是简单型" class="headerlink" title="确定一个对象是感知型还是简单型"></a>确定一个对象是感知型还是简单型</h4><p><code>date</code> 类型的对象都是简单型的。</p>
<p><code>time</code> 或 <code>datetime</code> 类型的对象可以是感知型或者简单型。</p>
<p>一个 <code>datetime</code> 对象 <em>d</em> 在以下条件同时成立时将是感知型的：</p>
<ol>
<li><code>d.tzinfo</code> 不为 <code>None</code></li>
<li><code>d.tzinfo.utcoffset(d)</code> 不返回 <code>None</code></li>
</ol>
<p>在其他情况下，<em>d</em> 将是简单型的。</p>
<p>一个 <code>time</code> 对象 <em>t</em> 在以下条件同时成立时将是感知型的：</p>
<ol>
<li><code>t.tzinfo</code> 不为 <code>None</code></li>
<li><code>t.tzinfo.utcoffset(None)</code> 不返回 <code>None</code>。</li>
</ol>
<p>在其他情况下，<em>t</em> 将是简单型的。</p>
<p>感知型和简单型之间的区别不适用于 <code>timedelta</code> 对象。</p>
<h3 id="timedelta-类对象"><a href="#timedelta-类对象" class="headerlink" title="timedelta 类对象"></a><code>timedelta</code> 类对象</h3><p><code>timedelta</code> 对象表示两个 date 或者 time 的时间间隔。</p>
<p><em>class<em><code>datetime.timedelta</code>(</em>days=0</em>, <em>seconds=0</em>, <em>microseconds=0</em>, <em>milliseconds=0</em>, <em>minutes=0</em>, <em>hours=0</em>, <em>weeks=0</em>)</p>
<p>所有参数都是可选的并且默认为 <code>0</code>。 这些参数可以是整数或者浮点数，也可以是正数或者负数。</p>
<p>只有 <em>days</em>, <em>seconds</em> 和 <em>microseconds</em> 会存储在内部。 参数单位的换算规则如下：</p>
<ul>
<li>1毫秒会转换成1000微秒。</li>
<li>1分钟会转换成60秒。</li>
<li>1小时会转换成3600秒。</li>
<li>1星期会转换成7天。</li>
</ul>
<p>日期、秒、微秒都是标准化的，所以它们的表达方式也是唯一的，例：</p>
<ul>
<li><code>0 &lt;= microseconds &lt; 1000000</code></li>
<li><code>0 &lt;= seconds &lt; 3600*24</code> (一天的秒数)</li>
<li><code>-999999999 &lt;= days &lt;= 999999999</code></li>
</ul>
<p>下面的例子演示了如何对 <em>days</em>, <em>seconds</em> 和 <em>microseconds</em> 以外的任意参数执行“合并”操作并标准化为以上三个结果属性:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span><span class="token keyword">from</span> datetime <span class="token keyword">import</span> timedelta
<span class="token operator">>></span><span class="token operator">></span> delta <span class="token operator">=</span> timedelta<span class="token punctuation">(</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     days<span class="token operator">=</span><span class="token number">50</span><span class="token punctuation">,</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     seconds<span class="token operator">=</span><span class="token number">27</span><span class="token punctuation">,</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     microseconds<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">,</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     milliseconds<span class="token operator">=</span><span class="token number">29000</span><span class="token punctuation">,</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     minutes<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">,</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     hours<span class="token operator">=</span><span class="token number">8</span><span class="token punctuation">,</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     weeks<span class="token operator">=</span><span class="token number">2</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span><span class="token comment" spellcheck="true"># Only days, seconds, and microseconds remain</span>
<span class="token operator">>></span><span class="token operator">></span> delta
datetime<span class="token punctuation">.</span>timedelta<span class="token punctuation">(</span>days<span class="token operator">=</span><span class="token number">64</span><span class="token punctuation">,</span> seconds<span class="token operator">=</span><span class="token number">29156</span><span class="token punctuation">,</span> microseconds<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在有任何参数为浮点型并且 microseconds 值为小数的情况下，从所有参数中余下的微秒数将被合并，并使用四舍五入偶不入奇的规则将总计值舍入到最接近的整数微秒值。 如果没有任何参数为浮点型的情况下，则转换和标准化过程将是完全精确的（不会丢失信息）。</p>
<p>如果标准化后的 days 数值超过了指定范围，将会抛出 <code>OverflowError</code> 异常。</p>
<p>请注意对负数值进行标准化的结果可能会令人感到惊讶。 例如:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span><span class="token keyword">from</span> datetime <span class="token keyword">import</span> timedelta
<span class="token operator">>></span><span class="token operator">></span> d <span class="token operator">=</span> timedelta<span class="token punctuation">(</span>microseconds<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span><span class="token punctuation">(</span>d<span class="token punctuation">.</span>days<span class="token punctuation">,</span> d<span class="token punctuation">.</span>seconds<span class="token punctuation">,</span> d<span class="token punctuation">.</span>microseconds<span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">86399</span><span class="token punctuation">,</span><span class="token number">999999</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>类属性：</p>
<pre><code>timedelta.min</code></pre><p>The most negative <code>timedelta</code> object, <code>timedelta(-999999999)</code>.</p>
<pre><code>timedelta.max</code></pre><p>The most positive <code>timedelta</code> object, <code>timedelta(days=999999999, hours=23, minutes=59, seconds=59, microseconds=999999)</code>.</p>
<pre><code>timedelta.resolution</code></pre><p>两个不相等的 <code>timedelta</code> 类对象最小的间隔为 <code>timedelta(microseconds=1)</code>。</p>
<p>需要注意的是，因为标准化的缘故，<code>timedelta.max</code> &gt; <code>-timedelta.min</code>，<code>-timedelta.max</code> 不可以表示一个 <code>timedelta</code> 类对象。</p>
<p>实例属性（只读）：</p>
<table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">值</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>days</code></td>
<td align="left">-999999999 至 999999999 ，含999999999</td>
</tr>
<tr>
<td align="left"><code>seconds</code></td>
<td align="left">0 至 86399，包含86399</td>
</tr>
<tr>
<td align="left"><code>microseconds</code></td>
<td align="left">0 至 999999，包含999999</td>
</tr>
</tbody></table>
<p>支持的运算：</p>
<table>
<thead>
<tr>
<th align="left">运算</th>
<th align="left">结果：</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>t1 = t2 + t3</code></td>
<td align="left"><em>t2</em> 和 <em>t3</em> 的和。 运算后 <em>t1</em>-<em>t2</em> == <em>t3</em> and <em>t1</em>-<em>t3</em> == <em>t2</em> 必为真值。(1)</td>
</tr>
<tr>
<td align="left"><code>t1 = t2 - t3</code></td>
<td align="left"><em>t2</em> 减 <em>t3</em> 的差。 运算后 <em>t1</em> == <em>t2</em> - <em>t3</em> and <em>t2</em> == <em>t1</em> + <em>t3</em> 必为真值。 (1)(6)</td>
</tr>
<tr>
<td align="left"><code>t1 = t2 *i or t1 = i* t2</code></td>
<td align="left">乘以一个整数。运算后假如 <code>i != 0</code> 则 <em>t1</em> // i == <em>t2</em> 必为真值。</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">In general, <em>t1</em> <em>i == *t1** (i-1) + *t1</em> is true. (1)</td>
</tr>
<tr>
<td align="left"><code>t1 = t2 *f or t1 = f* t2</code></td>
<td align="left">乘以一个浮点数，结果会被舍入到 timedelta 最接近的整数倍。 精度使用四舍五偶入奇不入规则。</td>
</tr>
<tr>
<td align="left"><code>f = t2 / t3</code></td>
<td align="left">总时间 <em>t2</em> 除以间隔单位 <em>t3</em> (3)。 返回一个 <code>float</code> 对象。</td>
</tr>
<tr>
<td align="left"><code>t1 = t2 / f or t1 = t2 / i</code></td>
<td align="left">除以一个浮点数或整数。 结果会被舍入到 timedelta 最接近的整数倍。 精度使用四舍五偶入奇不入规则。</td>
</tr>
<tr>
<td align="left"><code>t1 = t2 // i</code> or <code>t1 = t2 // t3</code></td>
<td align="left">计算底数，其余部分（如果有）将被丢弃。在第二种情况下，将返回整数。 （3）</td>
</tr>
<tr>
<td align="left"><code>t1 = t2 % t3</code></td>
<td align="left">余数为一个 <code>timedelta</code> 对象。(3)</td>
</tr>
<tr>
<td align="left"><code>q, r = divmod(t1, t2)</code></td>
<td align="left">通过 : <code>q = t1 // t2</code> (3) and <code>r = t1 % t2</code> 计算出商和余数。q是一个整数，r是一个 <code>timedelta</code> 对象。</td>
</tr>
<tr>
<td align="left"><code>+t1</code></td>
<td align="left">返回一个相同数值的 <code>timedelta</code> 对象。</td>
</tr>
<tr>
<td align="left"><code>-t1</code></td>
<td align="left">等价于 <code>timedelta</code>(-<em>t1.days</em>, -<em>t1.seconds</em>, -<em>t1.microseconds</em>), 和 <em>t1</em> <em>-1. (1)(4)</em></td>
</tr>
<tr>
<td align="left"><code>abs(t)</code></td>
<td align="left">当 <code>t.days &gt;= 0``时等于 +\ t*, 当 ``t.days &lt; 0</code> 时 -<em>t</em> 。 (2)</td>
</tr>
<tr>
<td align="left"><code>str(t)</code></td>
<td align="left">返回一个形如 <code>[D day[s], ][H]H:MM:SS[.UUUUUU]</code> 的字符串，当 <code>t</code> 为负数的时候， D 也为负数。 (5)</td>
</tr>
<tr>
<td align="left"><code>repr(t)</code></td>
<td align="left">返回一个 <code>timedelta</code> 对象的字符串表示形式，作为附带正规属性值的构造器调用。</td>
</tr>
</tbody></table>
<p>注释：</p>
<ol>
<li><p>结果正确，但可能会溢出。</p>
</li>
<li><p>结果正确，不会溢出。</p>
</li>
<li><p>除以0将会抛出异常 <code>ZeroDivisionError</code> 。</p>
</li>
<li><p>-<em>timedelta.max</em> 不是一个 <code>timedelta</code> 类对象。</p>
</li>
<li><p><code>timedelta</code> 对象的字符串表示形式类似于其内部表示形式被规范化。对于负时间增量，这会导致一些不寻常的结果。例如:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> timedelta<span class="token punctuation">(</span>hours<span class="token operator">=</span><span class="token operator">-</span><span class="token number">5</span><span class="token punctuation">)</span>
datetime<span class="token punctuation">.</span>timedelta<span class="token punctuation">(</span>days<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> seconds<span class="token operator">=</span><span class="token number">68400</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span><span class="token keyword">print</span><span class="token punctuation">(</span>_<span class="token punctuation">)</span>
<span class="token operator">-</span><span class="token number">1</span> day<span class="token punctuation">,</span><span class="token number">19</span><span class="token punctuation">:</span><span class="token number">00</span><span class="token punctuation">:</span><span class="token number">00</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>表达式 <code>t2 - t3</code> 通常与 <code>t2 + (-t3)</code> 是等价的，除非 t3 等于 <code>timedelta.max</code>; 在这种情况下前者会返回结果，而后者则会溢出。</p>
</li>
</ol>
<p>除了上面列举的操作以外，<code>timedelta</code> 对象还支持与 <code>date</code> 和 <code>datetime</code> 对象进行特定的相加和相减运算（见下文）。</p>
<p>在 3.2 版更改: 现在已支持 <code>timedelta</code> 对象与另一个 <code>timedelta</code> 对象相整除或相除，包括求余运算和 <code>divmod()</code> 函数。 现在也支持 <code>timedelta</code> 对象加上或乘以一个 <code>float</code> 对象。</p>
<p>支持 <code>timedelta</code> 对象之间进行比较，但其中有一些注意事项。</p>
<p><code>==</code> 或 <code>!=</code> 比较 <em>总是</em> 返回一个 <code>bool</code> 对象，无论被比较的对象是什么类型:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span><span class="token keyword">from</span> datetime <span class="token keyword">import</span> timedelta
<span class="token operator">>></span><span class="token operator">></span> delta1 <span class="token operator">=</span> timedelta<span class="token punctuation">(</span>seconds<span class="token operator">=</span><span class="token number">57</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> delta2 <span class="token operator">=</span> timedelta<span class="token punctuation">(</span>hours<span class="token operator">=</span><span class="token number">25</span><span class="token punctuation">,</span> seconds<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> delta2 <span class="token operator">!=</span> delta1
<span class="token boolean">True</span>
<span class="token operator">>></span><span class="token operator">></span> delta2 <span class="token operator">==</span><span class="token number">5</span>
<span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>对于所有其他比较 (例如 <code>&lt;</code> 和 <code>&gt;</code>)，当一个 <code>timedelta</code> 对象与其他类型的对象比较时，将引发 <code>TypeError</code>:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> delta2 <span class="token operator">></span> delta1
<span class="token boolean">True</span>
<span class="token operator">>></span><span class="token operator">></span> delta2 <span class="token operator">></span><span class="token number">5</span>
Traceback<span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>
File<span class="token string">"&lt;stdin>"</span><span class="token punctuation">,</span> line <span class="token number">1</span><span class="token punctuation">,</span><span class="token keyword">in</span><span class="token operator">&lt;</span>module<span class="token operator">></span>
TypeError<span class="token punctuation">:</span><span class="token string">'>'</span><span class="token operator">not</span> supported between instances of <span class="token string">'datetime.timedelta'</span><span class="token operator">and</span><span class="token string">'int'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在布尔运算中，<code>timedelta</code> 对象当且仅当其不等于 <code>timedelta(0)</code> 时则会被视为真值。</p>
<p>实例方法：</p>
<p><code>timedelta.total_seconds</code>()</p>
<p>返回时间间隔包含了多少秒。造价于 <code>td / timedelta(seconds=1)</code>。对于其它单位可以直接使用除法的形式 (例如 <code>td / timedelta(microseconds=1)</code>)。</p>
<p>需要注意的是，时间间隔较大时，这个方法的结果中的微秒将会失真（大多数平台上大于270年视为一个较大的时间间隔）。</p>
<p>3.2 新版功能.</p>
<h4 id="class-timedelta-用法示例"><a href="#class-timedelta-用法示例" class="headerlink" title="class:timedelta 用法示例"></a>class:timedelta 用法示例</h4><p>一个标准化的附加示例:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span><span class="token comment" spellcheck="true"># Components of another_year add up to exactly 365 days</span>
<span class="token operator">>></span><span class="token operator">></span><span class="token keyword">from</span> datetime <span class="token keyword">import</span> timedelta
<span class="token operator">>></span><span class="token operator">></span> year <span class="token operator">=</span> timedelta<span class="token punctuation">(</span>days<span class="token operator">=</span><span class="token number">365</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> another_year <span class="token operator">=</span> timedelta<span class="token punctuation">(</span>weeks<span class="token operator">=</span><span class="token number">40</span><span class="token punctuation">,</span> days<span class="token operator">=</span><span class="token number">84</span><span class="token punctuation">,</span> hours<span class="token operator">=</span><span class="token number">23</span><span class="token punctuation">,</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                          minutes<span class="token operator">=</span><span class="token number">50</span><span class="token punctuation">,</span> seconds<span class="token operator">=</span><span class="token number">600</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> year <span class="token operator">==</span> another_year
<span class="token boolean">True</span>
<span class="token operator">>></span><span class="token operator">></span> year<span class="token punctuation">.</span>total_seconds<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token number">31536000.0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>timedelta</code> 算术运算的示例:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span><span class="token keyword">from</span> datetime <span class="token keyword">import</span> timedelta
<span class="token operator">>></span><span class="token operator">></span> year <span class="token operator">=</span> timedelta<span class="token punctuation">(</span>days<span class="token operator">=</span><span class="token number">365</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> ten_years <span class="token operator">=</span><span class="token number">10</span><span class="token operator">*</span> year
<span class="token operator">>></span><span class="token operator">></span> ten_years
datetime<span class="token punctuation">.</span>timedelta<span class="token punctuation">(</span>days<span class="token operator">=</span><span class="token number">3650</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> ten_years<span class="token punctuation">.</span>days <span class="token operator">//</span> <span class="token number">365</span>
<span class="token number">10</span>
<span class="token operator">>></span><span class="token operator">></span> nine_years <span class="token operator">=</span> ten_years <span class="token operator">-</span> year
<span class="token operator">>></span><span class="token operator">></span> nine_years
datetime<span class="token punctuation">.</span>timedelta<span class="token punctuation">(</span>days<span class="token operator">=</span><span class="token number">3285</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> three_years <span class="token operator">=</span> nine_years <span class="token operator">//</span> <span class="token number">3</span>
<span class="token operator">>></span><span class="token operator">></span> three_years<span class="token punctuation">,</span> three_years<span class="token punctuation">.</span>days <span class="token operator">//</span> <span class="token number">365</span>
<span class="token punctuation">(</span>datetime<span class="token punctuation">.</span>timedelta<span class="token punctuation">(</span>days<span class="token operator">=</span><span class="token number">1095</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="date-对象"><a href="#date-对象" class="headerlink" title="date 对象"></a><code>date</code> 对象</h3><p><code>date</code> 对象代表一个理想化历法中的日期（年、月和日），即当今的格列高利历向前后两个方向无限延伸。</p>
<p>公元 1 年 1 月 1日是第 1 日，公元 1 年 1 月 2 日是第 2 日，依此类推。 </p>
<p><em>class<em><code>datetime.date</code>(</em>year</em>, <em>month</em>, <em>day</em>)</p>
<p>所有参数都是必要的。 参数必须是在下面范围内的整数：</p>
<ul>
<li><code>MINYEAR &lt;= year &lt;= MAXYEAR</code></li>
<li><code>1 &lt;= month &lt;= 12</code></li>
<li><code>1 &lt;= 日期 &lt;= 给定年月对应的天数</code></li>
</ul>
<p>如果参数不在这些范围内，则抛出 <code>ValueError</code> 异常。</p>
<p>其它构造器，所有的类方法：</p>
<p><em>classmethod</em><code>date.today</code>()</p>
<p>返回当前的本地日期。</p>
<p>这等价于 <code>date.fromtimestamp(time.time())</code>。</p>
<p><em>classmethod<em><code>date.fromtimestamp</code>(</em>timestamp</em>)</p>
<p>返回对应于 POSIX 时间戳的当地时间，例如 <code>time.time()</code> 返回的就是时间戳。</p>
<p>这可能引发 <code>OverflowError</code>，如果时间戳数值超出所在平台 C <code>localtime()</code> 函数的支持范围的话，并且会在 <code>localtime()</code> 出错时引发 <code>OSError</code>。 通常该数值会被限制在 1970 年至 2038 年之间。 请注意在时间戳概念包含闰秒的非 POSIX 系统上，闰秒会被 <code>fromtimestamp()</code> 所忽略。</p>
<p>在 3.3 版更改: 引发 <code>OverflowError</code> 而不是 <code>ValueError</code>，如果时间戳数值超出所在平台 C <code>localtime()</code> 函数的支持范围的话，并会在 <code>localtime()</code> 出错时引发 <code>OSError</code> 而不是 <code>ValueError</code>。</p>
<p><em>classmethod<em><code>date.fromordinal</code>(</em>ordinal</em>)</p>
<p>返回对应于预期格列高利历序号的日期，其中公元 1 年 1 月 1 日的序号为 1。</p>
<p>除非 <code>1 &lt;= ordinal &lt;= date.max.toordinal()</code> 否则会引发 <code>ValueError</code>。对于任意日期 <em>d</em>，<code>date.fromordinal(d.toordinal()) == d</code>。</p>
<p><em>classmethod<em><code>date.fromisoformat</code>(</em>date_string</em>)</p>
<p>返回一个对应于以 <code>YYYY-MM-DD</code> 格式给出的 <em>date_string</em> 的 <code>date</code> 对象:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span><span class="token keyword">from</span> datetime <span class="token keyword">import</span> date
<span class="token operator">>></span><span class="token operator">></span> date<span class="token punctuation">.</span>fromisoformat<span class="token punctuation">(</span><span class="token string">'2019-12-04'</span><span class="token punctuation">)</span>
datetime<span class="token punctuation">.</span>date<span class="token punctuation">(</span><span class="token number">2019</span><span class="token punctuation">,</span><span class="token number">12</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>这是 <code>date.isoformat()</code> 的逆操作。 它只支持 <code>YYYY-MM-DD</code> 格式。</p>
<p>3.7 新版功能.</p>
<p><em>classmethod<em><code>date.fromisocalendar</code>(</em>year</em>, <em>week</em>, <em>day</em>)</p>
<p>返回指定 year, week 和 day 所对应 ISO 历法日期的 <code>date</code>。 这是函数 <code>date.isocalendar()</code> 的逆操作。</p>
<p>3.8 新版功能.</p>
<p>类属性：</p>
<pre><code>date.min</code></pre><p>最小的日期 <code>date(MINYEAR, 1, 1)</code> 。</p>
<pre><code>date.max</code></pre><p>最大的日期 ，<code>date(MAXYEAR, 12, 31)</code>。</p>
<pre><code>date.resolution</code></pre><p>两个日期对象的最小间隔，<code>timedelta(days=1)</code>。</p>
<p>实例属性（只读）：</p>
<pre><code>date.year</code></pre><p>在 <code>MINYEAR</code> 和 <code>MAXYEAR</code> 之间，包含边界。</p>
<pre><code>date.month</code></pre><p>1 至 12（含）</p>
<pre><code>date.day</code></pre><p>返回1到指定年月的天数间的数字。</p>
<p>支持的运算：</p>
<table>
<thead>
<tr>
<th align="left">运算</th>
<th align="left">结果：</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>date2 = date1 + timedelta</code></td>
<td align="left"><em>date2</em> 等于从 <em>date1</em> 减去 <code>timedelta.days</code> 天。 (1)</td>
</tr>
<tr>
<td align="left"><code>date2 = date1 - timedelta</code></td>
<td align="left">计算 <em>date2</em> 的值使得 <code>date2 + timedelta == date1</code>。 (2)</td>
</tr>
<tr>
<td align="left"><code>timedelta = date1 - date2</code></td>
<td align="left">(3)</td>
</tr>
<tr>
<td align="left"><code>date1 &lt; date2</code></td>
<td align="left">如果 <em>date1</em> 的时间在 <em>date2</em> 之前则认为 <em>date1</em> 小于 <em>date2</em> 。 (4)</td>
</tr>
</tbody></table>
<p>注释：</p>
<ol>
<li>如果 <code>timedelta.days &gt; 0</code> 则 <em>date2</em> 将在时间线上前进，如果 <code>timedelta.days &lt; 0</code> 则将后退。 操作完成后 <code>date2 - date1 == timedelta.days</code>。 <code>timedelta.seconds</code> 和 <code>timedelta.microseconds</code> 会被忽略。 如果 <code>date2.year</code> 将小于 <code>MINYEAR</code> 或大于 <code>MAXYEAR</code> 则会引发 <code>OverflowError</code>。</li>
<li><code>timedelta.seconds</code> 和 <code>timedelta.microseconds</code> 会被忽略。</li>
<li>此值完全精确且不会溢出。 操作完成后 timedelta.seconds 和 timedelta.microseconds 均为 0，并且 date2 + timedelta == date1。</li>
<li>换句话说，当且仅当 <code>date1.toordinal() &lt; date2.toordinal()</code> 时 <code>date1 &lt; date2</code>。 日期比较会引发 <code>TypeError</code>，如果比较目标不为 <code>date</code> 对象的话。 不过也可能会返回 <code>NotImplemented</code>，如果比较目标具有 <code>timetuple()</code> 属性的话。 这个钩子给予其他日期对象类型实现混合类型比较的机会。 否则，当 <code>date</code> 对象与不同类型的对象比较时将会引发 <code>TypeError</code>，除非是 <code>==</code> 或 <code>!=</code> 比较。 后两种情况将分别返回 <code>False</code> 或 <code>True</code>。</li>
</ol>
<p>在布尔运算中，所有 <code>date</code> 对象都会被视为真值。</p>
<p>实例方法：</p>
<p><code>date.replace</code>(<em>year=self.year</em>, <em>month=self.month</em>, <em>day=self.day</em>)</p>
<p>返回一个具有同样值的日期，除非通过任何关键字参数给出了某些形参的新值。</p>
<p>示例:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span><span class="token keyword">from</span> datetime <span class="token keyword">import</span> date
<span class="token operator">>></span><span class="token operator">></span> d <span class="token operator">=</span> date<span class="token punctuation">(</span><span class="token number">2002</span><span class="token punctuation">,</span><span class="token number">12</span><span class="token punctuation">,</span><span class="token number">31</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> d<span class="token punctuation">.</span>replace<span class="token punctuation">(</span>day<span class="token operator">=</span><span class="token number">26</span><span class="token punctuation">)</span>
datetime<span class="token punctuation">.</span>date<span class="token punctuation">(</span><span class="token number">2002</span><span class="token punctuation">,</span><span class="token number">12</span><span class="token punctuation">,</span><span class="token number">26</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>date.timetuple</code>()</p>
<p>返回一个 <code>time.struct_time</code>，即 <code>time.localtime()</code> 所返回的类型。</p>
<p>hours, minutes 和 seconds 值均为 0，且 DST 旗标值为 -1。</p>
<p><code>d.timetuple()</code> 等价于:</p>
<pre class="line-numbers language-python"><code class="language-python">time<span class="token punctuation">.</span>struct_time<span class="token punctuation">(</span><span class="token punctuation">(</span>d<span class="token punctuation">.</span>year<span class="token punctuation">,</span> d<span class="token punctuation">.</span>month<span class="token punctuation">,</span> d<span class="token punctuation">.</span>day<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span> d<span class="token punctuation">.</span>weekday<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> yday<span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>其中 <code>yday = d.toordinal() - date(d.year, 1, 1).toordinal() + 1</code> 是当前年份中的日期序号，1 月 1 日的序号为 <code>1</code>。</p>
<p><code>date.toordinal</code>()</p>
<p>返回日期的预期格列高利历序号，其中公元 1 年 1 月 1 日的序号为 1。 对于任意 <code>date</code> 对象 <em>d</em>，<code>date.fromordinal(d.toordinal()) == d</code>。</p>
<p><code>date.weekday</code>()</p>
<p>返回一个整数代表星期几，星期一为0，星期天为6。例如， <code>date(2002, 12, 4).weekday() == 2</code>，表示的是星期三。</p>
<p>返回一个整数代表星期几，星期一为1，星期天为7。例如：<code>date(2002, 12, 4).isoweekday() == 3</code>,表示星期三。</p>
<p><code>date.isocalendar</code>()</p>
<p>返回一个由三部分组成的 named tuple 对象: <code>year</code>, <code>week</code> 和 <code>weekday</code>。</p>
<p>ISO 历法是一种被广泛使用的格列高利历。</p>
<p>ISO 年由 52 或 53 个完整星期构成，每个星期开始于星期一结束于星期日。 一个 ISO 年的第一个星期就是（格列高利）历法的一年中第一个包含星期四的星期。 这被称为 1 号星期，这个星期四所在的 ISO 年与其所在的格列高利年相同。</p>
<p>例如，2004 年的第一天是星期四，因此 ISO 2004 年的第一个星期开始于 2003 年 12 月 29 日星期一，结束于 2004 年 1 月 4 日星期日:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span><span class="token keyword">from</span> datetime <span class="token keyword">import</span> date
<span class="token operator">>></span><span class="token operator">></span> date<span class="token punctuation">(</span><span class="token number">2003</span><span class="token punctuation">,</span><span class="token number">12</span><span class="token punctuation">,</span><span class="token number">29</span><span class="token punctuation">)</span><span class="token punctuation">.</span>isocalendar<span class="token punctuation">(</span><span class="token punctuation">)</span>
datetime<span class="token punctuation">.</span>IsoCalendarDate<span class="token punctuation">(</span>year<span class="token operator">=</span><span class="token number">2004</span><span class="token punctuation">,</span> week<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> weekday<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> date<span class="token punctuation">(</span><span class="token number">2004</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">.</span>isocalendar<span class="token punctuation">(</span><span class="token punctuation">)</span>
datetime<span class="token punctuation">.</span>IsoCalendarDate<span class="token punctuation">(</span>year<span class="token operator">=</span><span class="token number">2004</span><span class="token punctuation">,</span> week<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> weekday<span class="token operator">=</span><span class="token number">7</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在 3.9 版更改: 结果由元组改为 named tuple。</p>
<p><code>date.isoformat</code>()</p>
<p>返回一个以 ISO 8601 格式 <code>YYYY-MM-DD</code> 来表示日期的字符串:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span><span class="token keyword">from</span> datetime <span class="token keyword">import</span> date
<span class="token operator">>></span><span class="token operator">></span> date<span class="token punctuation">(</span><span class="token number">2002</span><span class="token punctuation">,</span><span class="token number">12</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">.</span>isoformat<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token string">'2002-12-04'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>这是 <code>date.fromisoformat()</code> 的逆操作。</p>
<p><code>date.__str__</code>()</p>
<p>对于日期对象 <em>d</em>, <code>str(d)</code> 等价于 <code>d.isoformat()</code> 。</p>
<p><code>date.ctime</code>()</p>
<p>返回一个表示日期的字符串:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span><span class="token keyword">from</span> datetime <span class="token keyword">import</span> date
<span class="token operator">>></span><span class="token operator">></span> date<span class="token punctuation">(</span><span class="token number">2002</span><span class="token punctuation">,</span><span class="token number">12</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">.</span>ctime<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token string">'Wed Dec  4 00:00:00 2002'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p><code>d.ctime()</code> 等效于:</p>
<pre><code>time.ctime(time.mktime(d.timetuple()))</code></pre><p>在原生 C <code>ctime()</code> 函数 (<code>time.ctime()</code> 会发起调用该函数，但 <code>date.ctime()</code> 则不会) 遵循 C 标准的平台上。</p>
<p><code>date.strftime</code>(<em>format</em>)</p>
<p>返回一个由显式格式字符串所指明的代表日期的字符串。 表示时、分或秒的格式代码值将为 0。 </p>
<p><code>date.__format__</code>(<em>format</em>)</p>
<p>与 <code>date.strftime()</code> 相同。 此方法使得为 <code>date</code> 对象指定以 格式化字符串字面值 表示的格式化字符串以及使用 <code>str.format()</code> 进行格式化成为可能。</p>
<h4 id="class-date-用法示例"><a href="#class-date-用法示例" class="headerlink" title="class:date 用法示例"></a>class:date 用法示例</h4><p>计算距离特定事件天数的例子:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span><span class="token keyword">import</span> time
<span class="token operator">>></span><span class="token operator">></span><span class="token keyword">from</span> datetime <span class="token keyword">import</span> date
<span class="token operator">>></span><span class="token operator">></span> today <span class="token operator">=</span> date<span class="token punctuation">.</span>today<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> today
datetime<span class="token punctuation">.</span>date<span class="token punctuation">(</span><span class="token number">2007</span><span class="token punctuation">,</span><span class="token number">12</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> today <span class="token operator">==</span> date<span class="token punctuation">.</span>fromtimestamp<span class="token punctuation">(</span>time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token boolean">True</span>
<span class="token operator">>></span><span class="token operator">></span> my_birthday <span class="token operator">=</span> date<span class="token punctuation">(</span>today<span class="token punctuation">.</span>year<span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">24</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span><span class="token keyword">if</span> my_birthday <span class="token operator">&lt;</span> today<span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     my_birthday <span class="token operator">=</span> my_birthday<span class="token punctuation">.</span>replace<span class="token punctuation">(</span>year<span class="token operator">=</span>today<span class="token punctuation">.</span>year <span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> my_birthday
datetime<span class="token punctuation">.</span>date<span class="token punctuation">(</span><span class="token number">2008</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">24</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> time_to_birthday <span class="token operator">=</span> abs<span class="token punctuation">(</span>my_birthday <span class="token operator">-</span> today<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> time_to_birthday<span class="token punctuation">.</span>days
<span class="token number">202</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>使用 <code>date</code> 的更多例子：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span><span class="token keyword">from</span> datetime <span class="token keyword">import</span> date
<span class="token operator">>></span><span class="token operator">></span> d <span class="token operator">=</span> date<span class="token punctuation">.</span>fromordinal<span class="token punctuation">(</span><span class="token number">730920</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 730920th day after 1. 1. 0001</span>
<span class="token operator">>></span><span class="token operator">></span> d
datetime<span class="token punctuation">.</span>date<span class="token punctuation">(</span><span class="token number">2002</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">11</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span><span class="token comment" spellcheck="true"># Methods related to formatting string output</span>
<span class="token operator">>></span><span class="token operator">></span> d<span class="token punctuation">.</span>isoformat<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token string">'2002-03-11'</span>
<span class="token operator">>></span><span class="token operator">></span> d<span class="token punctuation">.</span>strftime<span class="token punctuation">(</span><span class="token string">"%d/%m/%y"</span><span class="token punctuation">)</span>
<span class="token string">'11/03/02'</span>
<span class="token operator">>></span><span class="token operator">></span> d<span class="token punctuation">.</span>strftime<span class="token punctuation">(</span><span class="token string">"%A %d. %B %Y"</span><span class="token punctuation">)</span>
<span class="token string">'Monday 11. March 2002'</span>
<span class="token operator">>></span><span class="token operator">></span> d<span class="token punctuation">.</span>ctime<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token string">'Mon Mar 11 00:00:00 2002'</span>
<span class="token operator">>></span><span class="token operator">></span><span class="token string">'The {1} is {0:%d}, the {2} is {0:%B}.'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>d<span class="token punctuation">,</span><span class="token string">"day"</span><span class="token punctuation">,</span><span class="token string">"month"</span><span class="token punctuation">)</span>
<span class="token string">'The day is 11, the month is March.'</span>
<span class="token operator">>></span><span class="token operator">></span><span class="token comment" spellcheck="true"># Methods for to extracting 'components' under different calendars</span>
<span class="token operator">>></span><span class="token operator">></span> t <span class="token operator">=</span> d<span class="token punctuation">.</span>timetuple<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span><span class="token keyword">for</span> i <span class="token keyword">in</span> t<span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">print</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>
<span class="token number">2002</span><span class="token comment" spellcheck="true"># year</span>
<span class="token number">3</span><span class="token comment" spellcheck="true"># month</span>
<span class="token number">11</span><span class="token comment" spellcheck="true"># day</span>
<span class="token number">0</span>
<span class="token number">0</span>
<span class="token number">0</span>
<span class="token number">0</span><span class="token comment" spellcheck="true"># weekday (0 = Monday)</span>
<span class="token number">70</span><span class="token comment" spellcheck="true"># 70th day in the year</span>
<span class="token operator">-</span><span class="token number">1</span>
<span class="token operator">>></span><span class="token operator">></span> ic <span class="token operator">=</span> d<span class="token punctuation">.</span>isocalendar<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span><span class="token keyword">for</span> i <span class="token keyword">in</span> ic<span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">print</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>
<span class="token number">2002</span><span class="token comment" spellcheck="true"># ISO year</span>
<span class="token number">11</span><span class="token comment" spellcheck="true"># ISO week number</span>
<span class="token number">1</span><span class="token comment" spellcheck="true"># ISO day number ( 1 = Monday )</span>
<span class="token operator">>></span><span class="token operator">></span><span class="token comment" spellcheck="true"># A date object is immutable; all operations produce a new object</span>
<span class="token operator">>></span><span class="token operator">></span> d<span class="token punctuation">.</span>replace<span class="token punctuation">(</span>year<span class="token operator">=</span><span class="token number">2005</span><span class="token punctuation">)</span>
datetime<span class="token punctuation">.</span>date<span class="token punctuation">(</span><span class="token number">2005</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">11</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="datetime-对象"><a href="#datetime-对象" class="headerlink" title="datetime 对象"></a><code>datetime</code> 对象</h3><p><code>datetime</code> 对象是包含来自 <code>date</code> 对象和 <code>time</code> 对象的所有信息的单一对象。</p>
<p>与 <code>date</code> 对象一样，<code>datetime</code> 假定当前的格列高利历向前后两个方向无限延伸；与 <code>time</code> 对象一样，<code>datetime</code> 假定每一天恰好有 3600*24 秒。</p>
<p>构造器 ：</p>
<p><em>class<em><code>datetime.datetime</code>(</em>year</em>, <em>month</em>, <em>day</em>, <em>hour=0</em>, <em>minute=0</em>, <em>second=0</em>, <em>microsecond=0</em>, <em>tzinfo=None</em>, <em>**,</em> fold=0*)</p>
<p><em>year</em>, <em>month</em> 和 <em>day</em> 参数是必须的。 <em>tzinfo</em> 可以是 <code>None</code> 或者是一个 <code>tzinfo</code> 子类的实例。 其余的参数必须是在下面范围内的整数：</p>
<ul>
<li><code>MINYEAR &lt;= year &lt;= MAXYEAR</code>,</li>
<li><code>1 &lt;= month &lt;= 12</code>,</li>
<li><code>1 &lt;= day &lt;= 指定年月的天数</code>,</li>
<li><code>0 &lt;= hour &lt; 24</code>,</li>
<li><code>0 &lt;= minute &lt; 60</code>,</li>
<li><code>0 &lt;= second &lt; 60</code>,</li>
<li><code>0 &lt;= microsecond &lt; 1000000</code>,</li>
<li><code>fold in [0, 1]</code>.</li>
</ul>
<p>如果参数不在这些范围内，则抛出 <code>ValueError</code> 异常。</p>
<p>3.6 新版功能: 增加了 <code>fold</code> 参数。</p>
<p>其它构造器，所有的类方法：</p>
<p><em>classmethod</em><code>datetime.today</code>()</p>
<p>返回表示当前地方时的 datetime 对象，其中 <code>tzinfo</code> 为 <code>None</code>。</p>
<p>等价于:</p>
<pre><code>datetime.fromtimestamp(time.time())</code></pre><p>此方法的功能等价于 <code>now()</code>，但是不带 <code>tz</code> 形参。</p>
<p><em>classmethod<em><code>datetime.now</code>(</em>tz=None</em>)</p>
<p>返回表示当前地方时的 date 和 time 对象。</p>
<p>如果可选参数 <em>tz</em> 为 <code>None</code> 或未指定，这就类似于 <code>today()</code>，但该方法会在可能的情况下提供比通过 <code>time.time()</code> 时间戳所获时间值更高的精度（例如，在提供了 C <code>gettimeofday()</code> 函数的平台上就可以做到这一点）。</p>
<p>如果 <em>tz</em> 不为 <code>None</code>，它必须是 <code>tzinfo</code> 子类的一个实例，并且当前日期和时间将被转换到 <em>tz</em> 时区。</p>
<p>此函数可以替代 <code>today()</code> 和 <code>utcnow()</code>。</p>
<p><em>classmethod</em><code>datetime.utcnow</code>()</p>
<p>返回表示当前 UTC 时间的 date 和 time，其中 <code>tzinfo</code> 为 <code>None</code>。</p>
<p>这类似于 <code>now()</code>，但返回的是当前 UTC 日期和时间，类型为简单型 <code>datetime</code> 对象。 感知型的当前 UTC 日期时间可通过调用 <code>datetime.now(timezone.utc)</code> 来获得。 </p>
<p>警告</p>
<p>由于简单型 <code>datetime</code> 对象会被许多 <code>datetime</code> 方法当作本地时间来处理，最好是使用感知型日期时间对象来表示 UTC 时间。 因此，创建表示当前 UTC 时间的对象的推荐方式是通过调用 <code>datetime.now(timezone.utc)</code>。</p>
<p><em>classmethod<em><code>datetime.fromtimestamp</code>(</em>timestamp</em>, <em>tz=None</em>)</p>
<p>返回对应于 POSIX 时间戳例如 <code>time.time()</code> 的返回值的本地日期和时间。 如果可选参数 <em>tz</em> 为 <code>None</code> 或未指定，时间戳会被转换为所在平台的本地日期和时间，返回的 <code>datetime</code> 对象将为天真型。</p>
<p>如果 <em>tz</em> 不为 <code>None</code>，它必须是 <code>tzinfo</code> 子类的一个实例，并且时间戳将被转换到 <em>tz</em> 指定的时区。</p>
<p><code>fromtimestamp()</code> 可能会引发 <code>OverflowError</code>，如果时间戳数值超出所在平台 C <code>localtime()</code> 或 <code>gmtime()</code> 函数的支持范围的话，并会在 <code>localtime()</code> 或 <code>gmtime()</code> 报错时引发 <code>OSError</code>。 通常该数值会被限制在 1970 年至 2038 年之间。 请注意在时间戳概念包含闰秒的非 POSIX 系统上，闰秒会被 <code>fromtimestamp()</code> 所忽略，结果可能导致两个相差一秒的时间戳产生相同的 <code>datetime</code> 对象。 相比 <code>utcfromtimestamp()</code> 更推荐使用此方法。</p>
<p>在 3.3 版更改: 引发 <code>OverflowError</code> 而不是 <code>ValueError</code>，如果时间戳数值超出所在平台 C <code>localtime()</code> 或 <code>gmtime()</code> 函数的支持范围的话。 并会在 <code>localtime()</code> 或 <code>gmtime()</code> 出错时引发 <code>OSError</code> 而不是 <code>ValueError</code>。</p>
<p>在 3.6 版更改: <code>fromtimestamp()</code> 可能返回 <code>fold</code> 值设为 1 的实例。</p>
<p><em>classmethod<em><code>datetime.utcfromtimestamp</code>(</em>timestamp</em>)</p>
<p>返回对应于 POSIX 时间戳的 UTC <code>datetime</code>，其中 <code>tzinfo</code> 值为 <code>None</code>。 （结果为简单型对象。）</p>
<p>这可能引发 <code>OverflowError</code>，如果时间戳数值超出所在平台 C <code>gmtime()</code> 函数的支持范围的话，并会在 <code>gmtime()</code> 报错时引发 <code>OSError</code>。 通常该数值会被限制在 1970 至 2038 年之间。</p>
<p>要得到一个感知型 <code>datetime</code> 对象，应调用 <code>fromtimestamp()</code>:</p>
<pre><code>datetime.fromtimestamp(timestamp, timezone.utc)</code></pre><p>在 POSIX 兼容的平台上，它等价于以下表达式:</p>
<pre><code>datetime(1970,1,1, tzinfo=timezone.utc)+ timedelta(seconds=timestamp)</code></pre><p>不同之处在于后一种形式总是支持完整年份范围：从 <code>MINYEAR</code> 到 <code>MAXYEAR</code> 的开区间。</p>
<p>警告</p>
<p>由于简单型 <code>datetime</code> 对象会被许多 <code>datetime</code> 方法当作本地时间来处理，最好是使用感知型日期时间对象来表示 UTC 时间。 因此，创建表示特定 UTC 时间戳的日期时间对象的推荐方式是通过调用 <code>datetime.fromtimestamp(timestamp, tz=timezone.utc)</code>。</p>
<p>在 3.3 版更改: 引发 <code>OverflowError</code> 而不是 <code>ValueError</code>，如果时间戳数值超出所在平台 C <code>gmtime()</code> 函数的支持范围的话。 并会在 <code>gmtime()</code> 出错时引发 <code>OSError</code> 而不是 <code>ValueError</code>。</p>
<p><em>classmethod<em><code>datetime.fromordinal</code>(</em>ordinal</em>)</p>
<p>返回对应于预期格列高利历序号的 <code>datetime</code>，其中公元 1 年 1 月 1 日的序号为 1。 除非 <code>1 &lt;= ordinal &lt;= datetime.max.toordinal()</code> 否则会引发 <code>ValueError</code>。 结果的 hour, minute, second 和 microsecond 值均为 0，并且 <code>tzinfo</code> 值为 <code>None</code>。</p>
<p><em>classmethod<em><code>datetime.combine</code>(</em>date</em>, <em>time</em>, <em>tzinfo=self.tzinfo</em>)</p>
<p>返回一个新的 <code>datetime</code> 对象，对象的日期部分等于给定的 <code>date</code> 对象的值，而其时间部分等于给定的 <code>time</code> 对象的值。 如果提供了 <em>tzinfo</em> 参数，其值会被用来设置结果的 <code>tzinfo</code> 属性，否则将使用 <em>time</em> 参数的 <code>tzinfo</code> 属性。</p>
<p>对于任意 <code>datetime</code> 对象 <em>d</em>，<code>d == datetime.combine(d.date(), d.time(), d.tzinfo)</code>。 如果 date 是一个 <code>datetime</code> 对象，它的时间部分和 <code>tzinfo</code> 属性会被忽略。</p>
<p>在 3.6 版更改: 增加了 <em>tzinfo</em> 参数。</p>
<p><em>classmethod<em><code>datetime.fromisoformat</code>(</em>date_string</em>)</p>
<p>返回一个对应于 <code>date.isoformat()</code> 和 <code>datetime.isoformat()</code> 所提供的某一种 <em>date_string</em> 的 <code>datetime</code> 对象。</p>
<p>特别地，此函数支持以下格式的字符串：</p>
<pre><code>YYYY-MM-DD[*HH[:MM[:SS[.fff[fff]]]][+HH:MM[:SS[.ffffff]]]]</code></pre><p>其中 <code>*</code> 可以匹配任意的单个字符。</p>
<p>警告</p>
<p>此函数 <em>并不</em> 支持解析任意 ISO 8601 字符串 —— 它的目的只是作为 <code>datetime.isoformat()</code> 的逆操作。 在第三方包 dateutil 中提供了一个更完善的 ISO 8601 解析器 <code>dateutil.parser.isoparse</code>。</p>
<p>示例:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span><span class="token keyword">from</span> datetime <span class="token keyword">import</span> datetime
<span class="token operator">>></span><span class="token operator">></span> datetime<span class="token punctuation">.</span>fromisoformat<span class="token punctuation">(</span><span class="token string">'2011-11-04'</span><span class="token punctuation">)</span>
datetime<span class="token punctuation">.</span>datetime<span class="token punctuation">(</span><span class="token number">2011</span><span class="token punctuation">,</span><span class="token number">11</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> datetime<span class="token punctuation">.</span>fromisoformat<span class="token punctuation">(</span><span class="token string">'2011-11-04T00:05:23'</span><span class="token punctuation">)</span>
datetime<span class="token punctuation">.</span>datetime<span class="token punctuation">(</span><span class="token number">2011</span><span class="token punctuation">,</span><span class="token number">11</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">23</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> datetime<span class="token punctuation">.</span>fromisoformat<span class="token punctuation">(</span><span class="token string">'2011-11-04 00:05:23.283'</span><span class="token punctuation">)</span>
datetime<span class="token punctuation">.</span>datetime<span class="token punctuation">(</span><span class="token number">2011</span><span class="token punctuation">,</span><span class="token number">11</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">23</span><span class="token punctuation">,</span><span class="token number">283000</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> datetime<span class="token punctuation">.</span>fromisoformat<span class="token punctuation">(</span><span class="token string">'2011-11-04 00:05:23.283+00:00'</span><span class="token punctuation">)</span>
datetime<span class="token punctuation">.</span>datetime<span class="token punctuation">(</span><span class="token number">2011</span><span class="token punctuation">,</span><span class="token number">11</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">23</span><span class="token punctuation">,</span><span class="token number">283000</span><span class="token punctuation">,</span> tzinfo<span class="token operator">=</span>datetime<span class="token punctuation">.</span>timezone<span class="token punctuation">.</span>utc<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> datetime<span class="token punctuation">.</span>fromisoformat<span class="token punctuation">(</span><span class="token string">'2011-11-04T00:05:23+04:00'</span><span class="token punctuation">)</span>
datetime<span class="token punctuation">.</span>datetime<span class="token punctuation">(</span><span class="token number">2011</span><span class="token punctuation">,</span><span class="token number">11</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">23</span><span class="token punctuation">,</span>
    tzinfo<span class="token operator">=</span>datetime<span class="token punctuation">.</span>timezone<span class="token punctuation">(</span>datetime<span class="token punctuation">.</span>timedelta<span class="token punctuation">(</span>seconds<span class="token operator">=</span><span class="token number">14400</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>3.7 新版功能.</p>
<p><em>classmethod<em><code>datetime.fromisocalendar</code>(</em>year</em>, <em>week</em>, <em>day</em>)</p>
<p>返回以 year, week 和 day 值指明的 ISO 历法日期所对应的 <code>datetime</code>。 该datetime 对象的非日期部分将使用其标准默认值来填充。 这是函数 <code>datetime.isocalendar()</code> 的逆操作。</p>
<p>3.8 新版功能.</p>
<p><em>classmethod<em><code>datetime.strptime</code>(</em>date_string</em>, <em>format</em>)</p>
<p>返回一个对应于 <em>date_string*，根据 *format</em> 进行解析得到的 <code>datetime</code> 对象。</p>
<p>这相当于：</p>
<pre><code>datetime(*(time.strptime(date_string, format)[0:6]))</code></pre><p>如果 date_string 和 format 无法被 <code>time.strptime()</code> 解析或它返回一个不是时间元组的值，则将引发 <code>ValueError</code>。</p>
<p>类属性：</p>
<pre><code>datetime.min</code></pre><p>最早的可表示 <code>datetime</code>，<code>datetime(MINYEAR, 1, 1, tzinfo=None)</code>。</p>
<pre><code>datetime.max</code></pre><p>最晚的可表示 <code>datetime</code>，<code>datetime(MAXYEAR, 12, 31, 23, 59, 59, 999999, tzinfo=None)</code>。</p>
<pre><code>datetime.resolution</code></pre><p>两个不相等的 <code>datetime</code> 对象之间可能的最小间隔，<code>timedelta(microseconds=1)</code>。</p>
<p>实例属性（只读）：</p>
<pre><code>datetime.year</code></pre><p>在 <code>MINYEAR</code> 和 <code>MAXYEAR</code> 之间，包含边界。</p>
<pre><code>datetime.month</code></pre><p>1 至 12（含）</p>
<pre><code>datetime.day</code></pre><p>返回1到指定年月的天数间的数字。</p>
<pre><code>datetime.hour</code></pre><p>取值范围是 <code>range(24)</code>。</p>
<pre><code>datetime.minute</code></pre><p>取值范围是 <code>range(60)</code>。</p>
<pre><code>datetime.second</code></pre><p>取值范围是 <code>range(60)</code>。</p>
<pre><code>datetime.microsecond</code></pre><p>取值范围是 <code>range(1000000)</code>。</p>
<pre><code>datetime.tzinfo</code></pre><p>作为 <em>tzinfo</em> 参数被传给 <code>datetime</code> 构造器的对象，如果没有传入值则为 <code>None</code>。</p>
<pre><code>datetime.fold</code></pre><p>取值范围是 <code>[0, 1]</code>。 用于在重复的时间段中消除边界时间歧义。 （当夏令时结束时回拨时钟或由于政治原因导致当明时区的 UTC 时差减少就会出现重复的时间段。） 取值 0 (1) 表示两个时刻早于（晚于）所代表的同一边界时间。</p>
<p>3.6 新版功能.</p>
<p>支持的运算：</p>
<table>
<thead>
<tr>
<th align="left">运算</th>
<th align="left">结果：</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>datetime2 = datetime1 + timedelta</code></td>
<td align="left">(1)</td>
</tr>
<tr>
<td align="left"><code>datetime2 = datetime1 - timedelta</code></td>
<td align="left">(2)</td>
</tr>
<tr>
<td align="left"><code>timedelta = datetime1 - datetime2</code></td>
<td align="left">(3)</td>
</tr>
<tr>
<td align="left"><code>datetime1 &lt; datetime2</code></td>
<td align="left">比较 <code>datetime</code> 与 <code>datetime</code>。 (4)</td>
</tr>
</tbody></table>
<ol>
<li><p>datetime2 是从 datetime1 去掉了一段 timedelta 的结果，如果 <code>timedelta.days</code> &gt; 0 则是在时间线上前进，如果 <code>timedelta.days</code> &lt; 0 则是在时间线上后退。 该结果具有与输入的 datetime 相同的 <code>tzinfo</code> 属性，并且操作完成后 datetime2 - datetime1 == timedelta。 如果 datetime2.year 将要小于 <code>MINYEAR</code> 或大于 <code>MAXYEAR</code> 则会引发 <code>OverflowError</code>。 请注意即使输入的是一个感知型对象，该方法也不会进行时区调整。</p>
</li>
<li><p>计算 datetime2 使得 datetime2 + timedelta == datetime1。 与相加操作一样，结果具有与输入的 datetime 相同的 <code>tzinfo</code> 属性，即使输入的是一个感知型对象，该方法也不会进行时区调整。</p>
</li>
<li><p>从一个 <code>datetime</code> 减去一个 <code>datetime</code> 仅对两个操作数均为简单型或均为感知型时有定义。 如果一个是感知型而另一个是简单型，则会引发 <code>TypeError</code>。</p>
<p>如果两个操作数都是简单型，或都是感知型并且具有相同的 <code>tzinfo</code> 属性，则 <code>tzinfo</code> 属性会被忽略，并且结果会是一个使得 <code>datetime2 + t == datetime1</code> 的 <code>timedelta</code> 对象 <em>t</em>。 在此情况下不会进行时区调整。</p>
<p>如果两个操作数都是感知型且具有不同的 <code>tzinfo</code> 属性，<code>a-b</code> 操作的效果就如同 <em>a</em> 和 <em>b</em> 首先被转换为简单型 UTC 日期时间。 结果将是 <code>(a.replace(tzinfo=None) - a.utcoffset()) - (b.replace(tzinfo=None) - b.utcoffset())</code>，除非具体实现绝对不溢出。</p>
</li>
<li><p>当 <em>datetime1</em> 的时间在 <em>datetime2</em> 之前则认为 <em>datetime1</em> 小于 <em>datetime2</em>。</p>
<p>如果比较的一方是简单型而另一方是感知型，则如果尝试进行顺序比较将引发 <code>TypeError</code>。 对于相等比较，简单型实例将永远不等于感知型实例。</p>
<p>如果两个比较方都是感知型，且具有相同的 <code>tzinfo</code> 属性，则相同的 <code>tzinfo</code> 属性会被忽略并对基本日期时间值进行比较。 如果两个比较方都是感知型且具有不同的 <code>tzinfo</code> 属性，则两个比较方将首先通过减去它们的 UTC 差值（使用 <code>self.utcoffset()</code> 获取）来进行调整。</p>
<p>在 3.3 版更改: 感知型和简单型 <code>datetime</code> 实例之间的相等比较不会引发 <code>TypeError</code>。</p>
<p>注解</p>
<p>为了防止比较操作回退为默认的对象地址比较方式，datetime 比较通常会引发 <code>TypeError</code>，如果比较目标不同样为 <code>datetime</code> 对象的话。 不过也可能会返回 <code>NotImplemented</code>，如果比较目标具有 <code>timetuple()</code> 属性的话。 这个钩子给予其他种类的日期对象实现混合类型比较的机会。 如果未实现，则当 <code>datetime</code> 对象与不同类型比较时将会引发 <code>TypeError</code>，除非是 <code>==</code> 或 <code>!=</code> 比较。 后两种情况将分别返回 <code>False</code> 或 <code>True</code>。</p>
</li>
</ol>
<p>实例方法：</p>
<p><code>datetime.date</code>()</p>
<p>返回具有同样 year, month 和 day 值的 <code>date</code> 对象。</p>
<p><code>datetime.time</code>()</p>
<p>返回具有同样 hour, minute, second, microsecond 和 fold 值的 <code>time</code> 对象。 <code>tzinfo</code> 值为 <code>None</code>。</p>
<p>在 3.6 版更改: fold 值会被复制给返回的 <code>time</code> 对象。</p>
<p><code>datetime.timetz</code>()</p>
<p>返回具有同样 hour, minute, second, microsecond, fold 和 tzinfo 属性性的 <code>time</code> 对象。 </p>
<p>在 3.6 版更改: fold 值会被复制给返回的 <code>time</code> 对象。</p>
<p><code>datetime.replace</code>(<em>year=self.year</em>, <em>month=self.month</em>, <em>day=self.day</em>, <em>hour=self.hour</em>, <em>minute=self.minute</em>, <em>second=self.second</em>, <em>microsecond=self.microsecond</em>, <em>tzinfo=self.tzinfo</em>, <em>**,</em> fold=0*)</p>
<p>返回一个具有同样属性值的 datetime，除非通过任何关键字参数为某些属性指定了新值。 请注意可以通过指定 <code>tzinfo=None</code> 来从一个感知型 datetime 创建一个简单型 datetime 而不必转换日期和时间数据。</p>
<p>3.6 新版功能: 增加了 <code>fold</code> 参数。</p>
<p><code>datetime.astimezone</code>(<em>tz=None</em>)</p>
<p>返回一个具有新的 <code>tzinfo</code> 属性 <em>tz</em> 的 <code>datetime</code> 对象，并会调整日期和时间数据使得结果对应的 UTC 时间与 <em>self</em> 相同，但为 <em>tz</em> 时区的本地时间。</p>
<p>如果给出了 <em>tz*，则它必须是一个 <code>tzinfo</code> 子类的实例，并且其 <code>utcoffset()</code> 和 <code>dst()</code> 方法不可返回 <code>None</code>。 如果 *self</em> 为简单型，它会被假定为基于系统时区表示的时间。</p>
<p>如果调用时不传入参数 (或传入 <code>tz=None</code>) 则将假定目标时区为系统的本地时区。 转换后 datetime 实例的 <code>.tzinfo</code> 属性将被设为一个 <code>timezone</code> 实例，时区名称和时差值将从 OS 获取。</p>
<p>如果 <code>self.tzinfo</code> 为 <em>tz*，<code>self.astimezone(tz)</code> 等于 *self</em>: 不会对日期或时间数据进行调整。 否则结果为 <em>tz</em> 时区的本地时间，代表的 UTC 时间与 <em>self</em> 相同：在 <code>astz = dt.astimezone(tz)</code> 之后，<code>astz - astz.utcoffset()</code> 将具有与 <code>dt - dt.utcoffset()</code> 相同的日期和时间数据。</p>
<p>如果你只是想要附加一个时区对象 <em>tz</em> 到一个 datetime 对象 <em>dt</em> 而不调整日期和时间数据，请使用 <code>dt.replace(tzinfo=tz)</code>。 如果你只想从一个感知型 datetime 对象 <em>dt</em> 移除时区对象，请使用 <code>dt.replace(tzinfo=None)</code>。</p>
<p>请注意默认的 <code>tzinfo.fromutc()</code> 方法在 <code>tzinfo</code> 的子类中可以被重载，从而影响 <code>astimezone()</code> 的返回结果。 如果忽略出错的情况，<code>astimezone()</code> 的行为就类似于:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">astimezone</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> tz<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> self<span class="token punctuation">.</span>tzinfo <span class="token keyword">is</span> tz<span class="token punctuation">:</span>
    <span class="token keyword">return</span> self
<span class="token comment" spellcheck="true"># Convert self to UTC, and attach the new time zone object.</span>
    utc <span class="token operator">=</span><span class="token punctuation">(</span>self<span class="token operator">-</span>self<span class="token punctuation">.</span>utcoffset<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>replace<span class="token punctuation">(</span>tzinfo<span class="token operator">=</span>tz<span class="token punctuation">)</span>
<span class="token comment" spellcheck="true"># Convert from UTC to tz's local time.</span>
<span class="token keyword">return</span> tz<span class="token punctuation">.</span>fromutc<span class="token punctuation">(</span>utc<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在 3.3 版更改: <em>tz</em> 现在可以被省略。</p>
<p>在 3.6 版更改: <code>astimezone()</code> 方法可以由简单型实例调用，这将假定其表示本地时间。</p>
<p><code>datetime.utcoffset</code>()</p>
<p>如果 <code>tzinfo</code> 为 <code>None</code>，则返回 <code>None</code>，否则返回 <code>self.tzinfo.utcoffset(self)</code>，并且在后者不返回 <code>None</code> 或者一个幅度小于一天的 <code>timedelta</code> 对象时将引发异常。</p>
<p>在 3.7 版更改: UTC 时差不再限制为一个整数分钟值。</p>
<p><code>datetime.dst</code>()</p>
<p>如果 <code>tzinfo</code> 为 <code>None</code>，则返回 <code>None</code>，否则返回 <code>self.tzinfo.dst(self)</code>，并且在后者不返回 <code>None</code> 或者一个幅度小于一天的 <code>timedelta</code> 对象时将引发异常。</p>
<p>在 3.7 版更改: DST 差值不再限制为一个整数分钟值。</p>
<p><code>datetime.tzname</code>()</p>
<p>如果 <code>tzinfo</code> 为 <code>None</code>，则返回 <code>None</code>，否则返回 <code>self.tzinfo.tzname(self)</code>，如果后者不返回 <code>None</code> 或者一个字符串对象则将引发异常。</p>
<p><code>datetime.timetuple</code>()</p>
<p>返回一个 <code>time.struct_time</code>，即 <code>time.localtime()</code> 所返回的类型。</p>
<p><code>d.timetuple()</code> 等价于:</p>
<pre class="line-numbers language-python"><code class="language-python">time<span class="token punctuation">.</span>struct_time<span class="token punctuation">(</span><span class="token punctuation">(</span>d<span class="token punctuation">.</span>year<span class="token punctuation">,</span> d<span class="token punctuation">.</span>month<span class="token punctuation">,</span> d<span class="token punctuation">.</span>day<span class="token punctuation">,</span>
                  d<span class="token punctuation">.</span>hour<span class="token punctuation">,</span> d<span class="token punctuation">.</span>minute<span class="token punctuation">,</span> d<span class="token punctuation">.</span>second<span class="token punctuation">,</span>
                  d<span class="token punctuation">.</span>weekday<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> yday<span class="token punctuation">,</span> dst<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>其中 <code>yday = d.toordinal() - date(d.year, 1, 1).toordinal() + 1</code> 是日期在当前年份中的序号，起始序号 <code>1</code> 表示 1 月 1 日。 结果的 <code>tm_isdst</code> 旗标的设定会依据 <code>dst()</code> 方法：如果 <code>tzinfo</code> 为 <code>None</code> 或 <code>dst()</code> 返回 <code>None</code>，则 <code>tm_isdst</code> 将设为 <code>-1</code>；否则如果 <code>dst()</code> 返回一个非零值，则 <code>tm_isdst</code> 将设为 <code>1</code>；在其他情况下 <code>tm_isdst</code> 将设为 <code>0</code>。</p>
<p><code>datetime.utctimetuple</code>()</p>
<p>如果 <code>datetime</code> 实例 <em>d</em> 为简单型，这类似于 <code>d.timetuple()</code>，不同之处在于 <code>tm_isdst</code> 会强制设为 0，无论 <code>d.dst()</code> 返回什么结果。 DST 对于 UTC 时间永远无效。</p>
<p>如果 <em>d</em> 为感知型， <em>d</em> 会通过减去 <code>d.utcoffset()</code> 来标准化为 UTC 时间，并返回该标准化时间所对应的 <code>time.struct_time</code>。 <code>tm_isdst</code> 会强制设为 0。 请注意如果 <em>d</em>.year 为 <code>MINYEAR</code> 或 <code>MAXYEAR</code> 并且 UTC 调整超出一年的边界则可能引发 <code>OverflowError</code>。</p>
<p>警告</p>
<p>由于简单型 <code>datetime</code> 对象会被许多 <code>datetime</code> 方法当作本地时间来处理，最好是使用感知型日期时间来表示 UTC 时间；因此，使用 <code>utcfromtimetuple</code> 可能会给出误导性的结果。 如果你有一个表示 UTC 的简单型 <code>datetime</code>，请使用 <code>datetime.replace(tzinfo=timezone.utc)</code> 将其改为感知型，这样你才能使用 <code>datetime.timetuple()</code>。</p>
<p><code>datetime.toordinal</code>()</p>
<p>返回日期的预期格列高利历序号。 与 <code>self.date().toordinal()</code> 相同。</p>
<p><code>datetime.timestamp</code>()</p>
<p>返回对应于 <code>datetime</code> 实例的 POSIX 时间戳。 此返回值是与 <code>time.time()</code> 返回值类似的 <code>float</code> 对象。</p>
<p>简单型 <code>datetime</code> 实例会假定为代表本地时间，并且此方法依赖于平台的 C <code>mktime()</code> 函数来执行转换。 由于在许多平台上 <code>datetime</code> 支持的范围比 <code>mktime()</code> 更广，对于极其遥远的过去或未来此方法可能引发 <code>OverflowError</code>。</p>
<p>对于感知型 <code>datetime</code> 实例，返回值的计算方式为:</p>
<pre><code>(dt - datetime(1970,1,1, tzinfo=timezone.utc)).total_seconds()</code></pre><p>3.3 新版功能.</p>
<p>在 3.6 版更改: <code>timestamp()</code> 方法使用 <code>fold</code> 属性来消除重复间隔中的时间歧义。</p>
<p>注解</p>
<p>没有一个方法能直接从表示 UTC 时间的简单型 <code>datetime</code> 实例获取 POSIX 时间戳。 如果你的应用程序使用此惯例并且你的系统时区不是设为 UTC，你可以通过提供 <code>tzinfo=timezone.utc</code> 来获取 POSIX 时间戳:</p>
<pre><code>timestamp = dt.replace(tzinfo=timezone.utc).timestamp()</code></pre><p>或者通过直接计算时间戳:</p>
<pre><code>timestamp =(dt - datetime(1970,1,1))/ timedelta(seconds=1)</code></pre><p><code>datetime.weekday</code>()</p>
<p>返回一个整数代表星期几，星期一为 0，星期天为 6。 相当于 <code>self.date().weekday()</code>。 </p>
<p><code>datetime.isoweekday</code>()</p>
<p>返回一个整数代表星期几，星期一为 1，星期天为 7。 相当于 <code>self.date().isoweekday()</code>。</p>
<p><code>datetime.isocalendar</code>()</p>
<p>返回一个由三部分组成的 named tuple: <code>year</code>, <code>week</code> 和 <code>weekday</code>。 等同于 <code>self.date().isocalendar()</code>。</p>
<p><code>datetime.isoformat</code>(<em>sep=’T’</em>, <em>timespec=’auto’</em>)</p>
<p>返回一个以 ISO 8601 格式表示的日期和时间字符串：</p>
<ul>
<li><code>YYYY-MM-DDTHH:MM:SS.ffffff</code>，如果 <code>microsecond</code> 不为 0</li>
<li><code>YYYY-MM-DDTHH:MM:SS</code>，如果 <code>microsecond</code> 为 0</li>
</ul>
<p>如果 <code>utcoffset()</code> 返回值不为 <code>None</code>，则添加一个字符串来给出 UTC 时差：</p>
<ul>
<li><code>YYYY-MM-DDTHH:MM:SS.ffffff+HH:MM[:SS[.ffffff]]</code>，如果 <code>microsecond</code> 不为 0</li>
<li><code>YYYY-MM-DDTHH:MM:SS+HH:MM[:SS[.ffffff]]</code>，如果 <code>microsecond</code> 为 0</li>
</ul>
<p>示例:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span><span class="token keyword">from</span> datetime <span class="token keyword">import</span> datetime<span class="token punctuation">,</span> timezone
<span class="token operator">>></span><span class="token operator">></span> datetime<span class="token punctuation">(</span><span class="token number">2019</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">18</span><span class="token punctuation">,</span><span class="token number">15</span><span class="token punctuation">,</span><span class="token number">17</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">132263</span><span class="token punctuation">)</span><span class="token punctuation">.</span>isoformat<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token string">'2019-05-18T15:17:08.132263'</span>
<span class="token operator">>></span><span class="token operator">></span> datetime<span class="token punctuation">(</span><span class="token number">2019</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">18</span><span class="token punctuation">,</span><span class="token number">15</span><span class="token punctuation">,</span><span class="token number">17</span><span class="token punctuation">,</span> tzinfo<span class="token operator">=</span>timezone<span class="token punctuation">.</span>utc<span class="token punctuation">)</span><span class="token punctuation">.</span>isoformat<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token string">'2019-05-18T15:17:00+00:00'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可选参数 <em>sep</em> (默认为 <code>'T'</code>) 为单个分隔字符，会被放在结果的日期和时间两部分之间。 例如:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span><span class="token keyword">from</span> datetime <span class="token keyword">import</span> tzinfo<span class="token punctuation">,</span> timedelta<span class="token punctuation">,</span> datetime
<span class="token operator">>></span><span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">TZ</span><span class="token punctuation">(</span>tzinfo<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token triple-quoted-string string">"""A time zone with an arbitrary, constant -06:39 offset."""</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">def</span> utcoffset<span class="token punctuation">(</span>self<span class="token punctuation">,</span> dt<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">return</span> timedelta<span class="token punctuation">(</span>hours<span class="token operator">=</span><span class="token operator">-</span><span class="token number">6</span><span class="token punctuation">,</span> minutes<span class="token operator">=</span><span class="token operator">-</span><span class="token number">39</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> datetime<span class="token punctuation">(</span><span class="token number">2002</span><span class="token punctuation">,</span><span class="token number">12</span><span class="token punctuation">,</span><span class="token number">25</span><span class="token punctuation">,</span> tzinfo<span class="token operator">=</span>TZ<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>isoformat<span class="token punctuation">(</span><span class="token string">' '</span><span class="token punctuation">)</span>
<span class="token string">'2002-12-25 00:00:00-06:39'</span>
<span class="token operator">>></span><span class="token operator">></span> datetime<span class="token punctuation">(</span><span class="token number">2009</span><span class="token punctuation">,</span><span class="token number">11</span><span class="token punctuation">,</span><span class="token number">27</span><span class="token punctuation">,</span> microsecond<span class="token operator">=</span><span class="token number">100</span><span class="token punctuation">,</span> tzinfo<span class="token operator">=</span>TZ<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>isoformat<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token string">'2009-11-27T00:00:00.000100-06:39'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可选参数 <em>timespec</em> 要包含的额外时间组件值 (默认为 <code>'auto'</code>)。它可以是以下值之一：</p>
<ul>
<li><code>'auto'</code>: 如果 <code>microsecond</code> 为 0 则与 <code>'seconds'</code> 相同，否则与 <code>'microseconds'</code> 相同。</li>
<li><code>'hours'</code>: 以两个数码的 <code>HH</code> 格式 包含 <code>hour</code>。</li>
<li><code>'minutes'</code>: 以 <code>HH:MM</code> 格式包含 <code>hour</code> 和 <code>minute</code>。</li>
<li><code>'seconds'</code>: 以 <code>HH:MM:SS</code> 格式包含 <code>hour</code>, <code>minute</code> 和 <code>second</code>。</li>
<li><code>'milliseconds'</code>: 包含完整时间，但将秒值的小数部分截断至微秒。 格式为 <code>HH:MM:SS.sss</code></li>
<li><code>'microseconds'</code>: 以 <code>HH:MM:SS.ffffff</code> 格式包含完整时间。</li>
</ul>
<p>注解</p>
<p>排除掉的时间部分将被截断，而不是被舍入。</p>
<p>对于无效的 <em>timespec</em> 参数将引发 <code>ValueError</code>:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span><span class="token keyword">from</span> datetime <span class="token keyword">import</span> datetime
<span class="token operator">>></span><span class="token operator">></span> datetime<span class="token punctuation">.</span>now<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>isoformat<span class="token punctuation">(</span>timespec<span class="token operator">=</span><span class="token string">'minutes'</span><span class="token punctuation">)</span>
<span class="token string">'2002-12-25T00:00'</span>
<span class="token operator">>></span><span class="token operator">></span> dt <span class="token operator">=</span> datetime<span class="token punctuation">(</span><span class="token number">2015</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">12</span><span class="token punctuation">,</span><span class="token number">30</span><span class="token punctuation">,</span><span class="token number">59</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> dt<span class="token punctuation">.</span>isoformat<span class="token punctuation">(</span>timespec<span class="token operator">=</span><span class="token string">'microseconds'</span><span class="token punctuation">)</span>
<span class="token string">'2015-01-01T12:30:59.000000'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>3.6 新版功能: 增加了 <em>timespec</em> 参数。</p>
<p><code>datetime.__str__</code>()</p>
<p>对于 <code>datetime</code> 实例 <em>d</em>，<code>str(d)</code> 等价于 <code>d.isoformat(' ')</code>。</p>
<p><code>datetime.ctime</code>()</p>
<p>返回一个表示日期和时间的字符串:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span><span class="token keyword">from</span> datetime <span class="token keyword">import</span> datetime
<span class="token operator">>></span><span class="token operator">></span> datetime<span class="token punctuation">(</span><span class="token number">2002</span><span class="token punctuation">,</span><span class="token number">12</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">,</span><span class="token number">30</span><span class="token punctuation">,</span><span class="token number">40</span><span class="token punctuation">)</span><span class="token punctuation">.</span>ctime<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token string">'Wed Dec  4 20:30:40 2002'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>输出字符串将 <em>并不</em> 包括时区信息，无论输入的是感知型还是简单型。</p>
<p><code>d.ctime()</code> 等效于:</p>
<pre><code>time.ctime(time.mktime(d.timetuple()))</code></pre><p>在原生 C <code>ctime()</code> 函数 (<code>time.ctime()</code> 会发起调用该函数，但 <code>datetime.ctime()</code> 则不会) 遵循 C 标准的平台上。</p>
<p><code>datetime.strftime</code>(<em>format</em>)</p>
<p>返回一个由显式格式字符串所指明的代表日期和时间的字符串，要获取格式指令的完整列表。</p>
<p><code>datetime.__format__</code>(<em>format</em>)</p>
<p>与 <code>datetime.strftime()</code> 相同。 此方法使得为 <code>datetime</code> 对象指定以 格式化字符串字面值 表示的格式化字符串以及使用 <code>str.format()</code> 进行格式化成为可能。 要获取格式指令的完整列表。</p>
<h4 id="用法示例-datetime"><a href="#用法示例-datetime" class="headerlink" title="用法示例: datetime"></a>用法示例: <code>datetime</code></h4><p>使用 <code>datetime</code> 对象的例子：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span><span class="token keyword">from</span> datetime <span class="token keyword">import</span> datetime<span class="token punctuation">,</span> date<span class="token punctuation">,</span> time<span class="token punctuation">,</span> timezone
<span class="token operator">>></span><span class="token operator">></span><span class="token comment" spellcheck="true"># Using datetime.combine()</span>
<span class="token operator">>></span><span class="token operator">></span> d <span class="token operator">=</span> date<span class="token punctuation">(</span><span class="token number">2005</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">14</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> t <span class="token operator">=</span> time<span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">,</span><span class="token number">30</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> datetime<span class="token punctuation">.</span>combine<span class="token punctuation">(</span>d<span class="token punctuation">,</span> t<span class="token punctuation">)</span>
datetime<span class="token punctuation">.</span>datetime<span class="token punctuation">(</span><span class="token number">2005</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">14</span><span class="token punctuation">,</span><span class="token number">12</span><span class="token punctuation">,</span><span class="token number">30</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span><span class="token comment" spellcheck="true"># Using datetime.now()</span>
<span class="token operator">>></span><span class="token operator">></span> datetime<span class="token punctuation">.</span>now<span class="token punctuation">(</span><span class="token punctuation">)</span>
datetime<span class="token punctuation">.</span>datetime<span class="token punctuation">(</span><span class="token number">2007</span><span class="token punctuation">,</span><span class="token number">12</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">16</span><span class="token punctuation">,</span><span class="token number">29</span><span class="token punctuation">,</span><span class="token number">43</span><span class="token punctuation">,</span><span class="token number">79043</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># GMT +1</span>
<span class="token operator">>></span><span class="token operator">></span> datetime<span class="token punctuation">.</span>now<span class="token punctuation">(</span>timezone<span class="token punctuation">.</span>utc<span class="token punctuation">)</span>
datetime<span class="token punctuation">.</span>datetime<span class="token punctuation">(</span><span class="token number">2007</span><span class="token punctuation">,</span><span class="token number">12</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">15</span><span class="token punctuation">,</span><span class="token number">29</span><span class="token punctuation">,</span><span class="token number">43</span><span class="token punctuation">,</span><span class="token number">79060</span><span class="token punctuation">,</span> tzinfo<span class="token operator">=</span>datetime<span class="token punctuation">.</span>timezone<span class="token punctuation">.</span>utc<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span><span class="token comment" spellcheck="true"># Using datetime.strptime()</span>
<span class="token operator">>></span><span class="token operator">></span> dt <span class="token operator">=</span> datetime<span class="token punctuation">.</span>strptime<span class="token punctuation">(</span><span class="token string">"21/11/06 16:30"</span><span class="token punctuation">,</span><span class="token string">"%d/%m/%y %H:%M"</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> dt
datetime<span class="token punctuation">.</span>datetime<span class="token punctuation">(</span><span class="token number">2006</span><span class="token punctuation">,</span><span class="token number">11</span><span class="token punctuation">,</span><span class="token number">21</span><span class="token punctuation">,</span><span class="token number">16</span><span class="token punctuation">,</span><span class="token number">30</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span><span class="token comment" spellcheck="true"># Using datetime.timetuple() to get tuple of all attributes</span>
<span class="token operator">>></span><span class="token operator">></span> tt <span class="token operator">=</span> dt<span class="token punctuation">.</span>timetuple<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span><span class="token keyword">for</span> it <span class="token keyword">in</span> tt<span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">print</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token number">2006</span><span class="token comment" spellcheck="true"># year</span>
<span class="token number">11</span><span class="token comment" spellcheck="true"># month</span>
<span class="token number">21</span><span class="token comment" spellcheck="true"># day</span>
<span class="token number">16</span><span class="token comment" spellcheck="true"># hour</span>
<span class="token number">30</span><span class="token comment" spellcheck="true"># minute</span>
<span class="token number">0</span><span class="token comment" spellcheck="true"># second</span>
<span class="token number">1</span><span class="token comment" spellcheck="true"># weekday (0 = Monday)</span>
<span class="token number">325</span><span class="token comment" spellcheck="true"># number of days since 1st January</span>
<span class="token operator">-</span><span class="token number">1</span><span class="token comment" spellcheck="true"># dst - method tzinfo.dst() returned None</span>
<span class="token operator">>></span><span class="token operator">></span><span class="token comment" spellcheck="true"># Date in ISO format</span>
<span class="token operator">>></span><span class="token operator">></span> ic <span class="token operator">=</span> dt<span class="token punctuation">.</span>isocalendar<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span><span class="token keyword">for</span> it <span class="token keyword">in</span> ic<span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">print</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token number">2006</span><span class="token comment" spellcheck="true"># ISO year</span>
<span class="token number">47</span><span class="token comment" spellcheck="true"># ISO week</span>
<span class="token number">2</span><span class="token comment" spellcheck="true"># ISO weekday</span>
<span class="token operator">>></span><span class="token operator">></span><span class="token comment" spellcheck="true"># Formatting a datetime</span>
<span class="token operator">>></span><span class="token operator">></span> dt<span class="token punctuation">.</span>strftime<span class="token punctuation">(</span><span class="token string">"%A, %d. %B %Y %I:%M%p"</span><span class="token punctuation">)</span>
<span class="token string">'Tuesday, 21. November 2006 04:30PM'</span>
<span class="token operator">>></span><span class="token operator">></span><span class="token string">'The {1} is {0:%d}, the {2} is {0:%B}, the {3} is {0:%I:%M%p}.'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>dt<span class="token punctuation">,</span><span class="token string">"day"</span><span class="token punctuation">,</span><span class="token string">"month"</span><span class="token punctuation">,</span><span class="token string">"time"</span><span class="token punctuation">)</span>
<span class="token string">'The day is 21, the month is November, the time is 04:30PM.'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>以下示例定义了一个 <code>tzinfo</code> 子类，它捕获 Kabul, Afghanistan 时区的信息，该时区使用 +4 UTC 直到 1945 年，之后则使用 +4:30 UTC:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> datetime <span class="token keyword">import</span> timedelta<span class="token punctuation">,</span> datetime<span class="token punctuation">,</span> tzinfo<span class="token punctuation">,</span> timezone
classKabulTz<span class="token punctuation">(</span>tzinfo<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token comment" spellcheck="true"># Kabul used +4 until 1945, when they moved to +4:30</span>
    UTC_MOVE_DATE <span class="token operator">=</span> datetime<span class="token punctuation">(</span><span class="token number">1944</span><span class="token punctuation">,</span><span class="token number">12</span><span class="token punctuation">,</span><span class="token number">31</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">,</span> tzinfo<span class="token operator">=</span>timezone<span class="token punctuation">.</span>utc<span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">utcoffset</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> dt<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token keyword">if</span> dt<span class="token punctuation">.</span>year <span class="token operator">&lt;</span><span class="token number">1945</span><span class="token punctuation">:</span>
<span class="token keyword">return</span> timedelta<span class="token punctuation">(</span>hours<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">)</span>
<span class="token keyword">elif</span><span class="token punctuation">(</span><span class="token number">1945</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">&lt;=</span> dt<span class="token punctuation">.</span>timetuple<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token operator">&lt;</span><span class="token punctuation">(</span><span class="token number">1945</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token comment" spellcheck="true"># An ambiguous ("imaginary") half-hour range representing</span>
<span class="token comment" spellcheck="true"># a 'fold' in time due to the shift from +4 to +4:30.</span>
<span class="token comment" spellcheck="true"># If dt falls in the imaginary range, use fold to decide how</span>
<span class="token comment" spellcheck="true"># to resolve. See PEP495.</span>
<span class="token keyword">return</span> timedelta<span class="token punctuation">(</span>hours<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">,</span> minutes<span class="token operator">=</span><span class="token punctuation">(</span>30if dt<span class="token punctuation">.</span>fold else0<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">else</span><span class="token punctuation">:</span>
<span class="token keyword">return</span> timedelta<span class="token punctuation">(</span>hours<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">,</span> minutes<span class="token operator">=</span><span class="token number">30</span><span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">fromutc</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> dt<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token comment" spellcheck="true"># Follow same validations as in datetime.tzinfo</span>
ifnot isinstance<span class="token punctuation">(</span>dt<span class="token punctuation">,</span> datetime<span class="token punctuation">)</span><span class="token punctuation">:</span>
raiseTypeError<span class="token punctuation">(</span><span class="token string">"fromutc() requires a datetime argument"</span><span class="token punctuation">)</span>
<span class="token keyword">if</span> dt<span class="token punctuation">.</span>tzinfo isnotself<span class="token punctuation">:</span>
raiseValueError<span class="token punctuation">(</span><span class="token string">"dt.tzinfo is not self"</span><span class="token punctuation">)</span>
<span class="token comment" spellcheck="true"># A custom implementation is required for fromutc as</span>
<span class="token comment" spellcheck="true"># the input to this function is a datetime with utc values</span>
<span class="token comment" spellcheck="true"># but with a tzinfo set to self.</span>
<span class="token comment" spellcheck="true"># See datetime.astimezone or fromtimestamp.</span>
<span class="token keyword">if</span> dt<span class="token punctuation">.</span>replace<span class="token punctuation">(</span>tzinfo<span class="token operator">=</span>timezone<span class="token punctuation">.</span>utc<span class="token punctuation">)</span><span class="token operator">>=</span>self<span class="token punctuation">.</span>UTC_MOVE_DATE<span class="token punctuation">:</span>
<span class="token keyword">return</span> dt <span class="token operator">+</span> timedelta<span class="token punctuation">(</span>hours<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">,</span> minutes<span class="token operator">=</span><span class="token number">30</span><span class="token punctuation">)</span>
<span class="token keyword">else</span><span class="token punctuation">:</span>
<span class="token keyword">return</span> dt <span class="token operator">+</span> timedelta<span class="token punctuation">(</span>hours<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">dst</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> dt<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token comment" spellcheck="true"># Kabul does not observe daylight saving time.</span>
<span class="token keyword">return</span> timedelta<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">tzname</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> dt<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token keyword">if</span> dt <span class="token operator">>=</span>self<span class="token punctuation">.</span>UTC_MOVE_DATE<span class="token punctuation">:</span>
<span class="token keyword">return</span><span class="token string">"+04:30"</span>
<span class="token keyword">return</span><span class="token string">"+04"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>上述 <code>KabulTz</code> 的用法:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> tz1 <span class="token operator">=</span>KabulTz<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span><span class="token comment" spellcheck="true"># Datetime before the change</span>
<span class="token operator">>></span><span class="token operator">></span> dt1 <span class="token operator">=</span> datetime<span class="token punctuation">(</span><span class="token number">1900</span><span class="token punctuation">,</span><span class="token number">11</span><span class="token punctuation">,</span><span class="token number">21</span><span class="token punctuation">,</span><span class="token number">16</span><span class="token punctuation">,</span><span class="token number">30</span><span class="token punctuation">,</span> tzinfo<span class="token operator">=</span>tz1<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span><span class="token keyword">print</span><span class="token punctuation">(</span>dt1<span class="token punctuation">.</span>utcoffset<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token number">4</span><span class="token punctuation">:</span><span class="token number">00</span><span class="token punctuation">:</span><span class="token number">00</span>
<span class="token operator">>></span><span class="token operator">></span><span class="token comment" spellcheck="true"># Datetime after the change</span>
<span class="token operator">>></span><span class="token operator">></span> dt2 <span class="token operator">=</span> datetime<span class="token punctuation">(</span><span class="token number">2006</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">14</span><span class="token punctuation">,</span><span class="token number">13</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span> tzinfo<span class="token operator">=</span>tz1<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span><span class="token keyword">print</span><span class="token punctuation">(</span>dt2<span class="token punctuation">.</span>utcoffset<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token number">4</span><span class="token punctuation">:</span><span class="token number">30</span><span class="token punctuation">:</span><span class="token number">00</span>
<span class="token operator">>></span><span class="token operator">></span><span class="token comment" spellcheck="true"># Convert datetime to another time zone</span>
<span class="token operator">>></span><span class="token operator">></span> dt3 <span class="token operator">=</span> dt2<span class="token punctuation">.</span>astimezone<span class="token punctuation">(</span>timezone<span class="token punctuation">.</span>utc<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> dt3
datetime<span class="token punctuation">.</span>datetime<span class="token punctuation">(</span><span class="token number">2006</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">14</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">30</span><span class="token punctuation">,</span> tzinfo<span class="token operator">=</span>datetime<span class="token punctuation">.</span>timezone<span class="token punctuation">.</span>utc<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> dt2
datetime<span class="token punctuation">.</span>datetime<span class="token punctuation">(</span><span class="token number">2006</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">14</span><span class="token punctuation">,</span><span class="token number">13</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span> tzinfo<span class="token operator">=</span>KabulTz<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> dt2 <span class="token operator">==</span> dt3
<span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="time-对象"><a href="#time-对象" class="headerlink" title="time 对象"></a><code>time</code> 对象</h3><p>一个 <code>time</code> 对象代表某日的（本地）时间，它独立于任何特定日期，并可通过 <code>tzinfo</code> 对象来调整。</p>
<p><em>class<em><code>datetime.time</code>(</em>hour=0</em>, <em>minute=0</em>, <em>second=0</em>, <em>microsecond=0</em>, <em>tzinfo=None</em>, <em>**,</em> fold=0*)</p>
<p>所有参数都是可选的。 <em>tzinfo</em> 可以是 <code>None</code>，或者是一个 <code>tzinfo</code> 子类的实例。 其余的参数必须是在下面范围内的整数：</p>
<ul>
<li><code>0 &lt;= hour &lt; 24</code>,</li>
<li><code>0 &lt;= minute &lt; 60</code>,</li>
<li><code>0 &lt;= second &lt; 60</code>,</li>
<li><code>0 &lt;= microsecond &lt; 1000000</code>,</li>
<li><code>fold in [0, 1]</code>.</li>
</ul>
<p>如果给出一个此范围以外的参数，则会引发 <code>ValueError</code>。 所有参数值默认为 <code>0</code>，只有 <em>tzinfo</em> 默认为 <code>None</code>。</p>
<p>类属性：</p>
<pre><code>time.min</code></pre><p>早最的可表示 <code>time</code>, <code>time(0, 0, 0, 0)</code>。</p>
<pre><code>time.max</code></pre><p>最晚的可表示 <code>time</code>, <code>time(23, 59, 59, 999999)</code>。</p>
<pre><code>time.resolution</code></pre><p>两个不相等的 <code>time</code> 对象之间可能的最小间隔，<code>timedelta(microseconds=1)</code>，但是请注意 <code>time</code> 对象并不支持算术运算。</p>
<p>实例属性（只读）：</p>
<pre><code>time.hour</code></pre><p>取值范围是 <code>range(24)</code>。</p>
<pre><code>time.minute</code></pre><p>取值范围是 <code>range(60)</code>。</p>
<pre><code>time.second</code></pre><p>取值范围是 <code>range(60)</code>。</p>
<pre><code>time.microsecond</code></pre><p>取值范围是 <code>range(1000000)</code>。</p>
<pre><code>time.tzinfo</code></pre><p>作为 tzinfo 参数被传给 <code>time</code> 构造器的对象，如果没有传入值则为 <code>None</code>。</p>
<pre><code>time.fold</code></pre><p>取值范围是 <code>[0, 1]</code>。 用于在重复的时间段中消除边界时间歧义。 （当夏令时结束时回拨时钟或由于政治原因导致当明时区的 UTC 时差减少就会出现重复的时间段。） 取值 0 (1) 表示两个时刻早于（晚于）所代表的同一边界时间。</p>
<p>3.6 新版功能.</p>
<p><code>time</code> 对象支持 <code>time</code> 与 <code>time</code> 的比较，当 <em>a</em> 时间在 <em>b</em> 之前时，则认为 <em>a</em> 小于 <em>b</em>。 如果比较的一方是简单型而另一方是感知型，则如果尝试进行顺序比较将引发 <code>TypeError</code>。 对于相等比较，简单型实例将永远不等于感知型实例。</p>
<p>如果两个比较方都是感知型，且具有相同的 <code>tzinfo</code> 属性，相同的 <code>tzinfo</code> 属性会被忽略并对基本时间值进行比较。 如果两个比较方都是感知型且具有不同的 <code>tzinfo</code> 属性，两个比较方将首先通过减去它们的 UTC 时差（从 <code>self.utcoffset()</code> 获取）来进行调整。 为了防止将混合类型比较回退为基于对象地址的默认比较，当 <code>time</code> 对象与不同类型的对象比较时，将会引发 <code>TypeError</code>，除非比较运算符是 <code>==</code> 或 <code>!=</code>。 在后两种情况下将分别返回 <code>False</code> 或 <code>True</code>。</p>
<p>在 3.3 版更改: 感知型和简单型 <code>time</code> 实例之间的相等比较不会引发 <code>TypeError</code>。</p>
<p>在布尔运算时，<code>time</code> 对象总是被视为真值。</p>
<p>在 3.5 版更改: 在 Python 3.5 之前，如果一个 <code>time</code> 对象代表 UTC 午夜零时则会被视为假值。 此行为被认为容易引发困惑和错误，因此从 Python 3.5 起已被去除。</p>
<p>其他构造方法：</p>
<p><em>classmethod<em><code>time.fromisoformat</code>(</em>time_string</em>)</p>
<p>返回对应于 <code>time.isoformat()</code> 所提供的某种 <em>time_string</em> 格式的 <code>time</code>。 特别地，此函数支持以下格式的字符串：</p>
<pre><code>HH[:MM[:SS[.fff[fff]]]][+HH:MM[:SS[.ffffff]]]</code></pre><p>警告</p>
<p>此方法 <em>并不</em> 支持解析任意 ISO 8601 字符串。 它的目的只是作为 <code>time.isoformat()</code> 的逆操作。</p>
<p>示例:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span><span class="token keyword">from</span> datetime <span class="token keyword">import</span> time
<span class="token operator">>></span><span class="token operator">></span> time<span class="token punctuation">.</span>fromisoformat<span class="token punctuation">(</span><span class="token string">'04:23:01'</span><span class="token punctuation">)</span>
datetime<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">23</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> time<span class="token punctuation">.</span>fromisoformat<span class="token punctuation">(</span><span class="token string">'04:23:01.000384'</span><span class="token punctuation">)</span>
datetime<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">23</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">384</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> time<span class="token punctuation">.</span>fromisoformat<span class="token punctuation">(</span><span class="token string">'04:23:01+04:00'</span><span class="token punctuation">)</span>
datetime<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">23</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span> tzinfo<span class="token operator">=</span>datetime<span class="token punctuation">.</span>timezone<span class="token punctuation">(</span>datetime<span class="token punctuation">.</span>timedelta<span class="token punctuation">(</span>seconds<span class="token operator">=</span><span class="token number">14400</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>3.7 新版功能.</p>
<p>实例方法：</p>
<p><code>time.replace</code>(<em>hour=self.hour</em>, <em>minute=self.minute</em>, <em>second=self.second</em>, <em>microsecond=self.microsecond</em>, <em>tzinfo=self.tzinfo</em>, <em>**,</em> fold=0*)</p>
<p>返回一个具有同样属性值的 <code>time</code>，除非通过任何关键字参数指定了某些属性值。 请注意可以通过指定 <code>tzinfo=None</code> 从一个感知型 <code>time</code> 创建一个简单型 <code>time</code>，而不必转换时间数据。</p>
<p>3.6 新版功能: 增加了 <code>fold</code> 参数。</p>
<p><code>time.isoformat</code>(<em>timespec=’auto’</em>)</p>
<p>返回表示为下列 ISO 8601 格式之一的时间字符串：</p>
<ul>
<li><code>HH:MM:SS.ffffff</code>，如果 <code>microsecond</code> 不为 0</li>
<li><code>HH:MM:SS</code>，如果 <code>microsecond</code> 为 0</li>
<li><code>HH:MM:SS.ffffff+HH:MM[:SS[.ffffff]]</code>，如果 <code>utcoffset()</code> 不返回 <code>None</code></li>
<li><code>HH:MM:SS+HH:MM[:SS[.ffffff]]</code>，如果 <code>microsecond</code> 为 0 并且 <code>utcoffset()</code> 不返回 <code>None</code></li>
</ul>
<p>可选参数 <em>timespec</em> 要包含的额外时间组件值 (默认为 <code>'auto'</code>)。它可以是以下值之一：</p>
<ul>
<li><code>'auto'</code>: 如果 <code>microsecond</code> 为 0 则与 <code>'seconds'</code> 相同，否则与 <code>'microseconds'</code> 相同。</li>
<li><code>'hours'</code>: 以两个数码的 <code>HH</code> 格式 包含 <code>hour</code>。</li>
<li><code>'minutes'</code>: 以 <code>HH:MM</code> 格式包含 <code>hour</code> 和 <code>minute</code>。</li>
<li><code>'seconds'</code>: 以 <code>HH:MM:SS</code> 格式包含 <code>hour</code>, <code>minute</code> 和 <code>second</code>。</li>
<li><code>'milliseconds'</code>: 包含完整时间，但将秒值的小数部分截断至微秒。 格式为 <code>HH:MM:SS.sss</code></li>
<li><code>'microseconds'</code>: 以 <code>HH:MM:SS.ffffff</code> 格式包含完整时间。</li>
</ul>
<p>注解</p>
<p>排除掉的时间部分将被截断，而不是被舍入。</p>
<p>对于无效的 <em>timespec</em> 参数将引发 <code>ValueError</code>。</p>
<p>示例:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span><span class="token keyword">from</span> datetime <span class="token keyword">import</span> time
<span class="token operator">>></span><span class="token operator">></span> time<span class="token punctuation">(</span>hour<span class="token operator">=</span><span class="token number">12</span><span class="token punctuation">,</span> minute<span class="token operator">=</span><span class="token number">34</span><span class="token punctuation">,</span> second<span class="token operator">=</span><span class="token number">56</span><span class="token punctuation">,</span> microsecond<span class="token operator">=</span><span class="token number">123456</span><span class="token punctuation">)</span><span class="token punctuation">.</span>isoformat<span class="token punctuation">(</span>timespec<span class="token operator">=</span><span class="token string">'minutes'</span><span class="token punctuation">)</span>
<span class="token string">'12:34'</span>
<span class="token operator">>></span><span class="token operator">></span> dt <span class="token operator">=</span> time<span class="token punctuation">(</span>hour<span class="token operator">=</span><span class="token number">12</span><span class="token punctuation">,</span> minute<span class="token operator">=</span><span class="token number">34</span><span class="token punctuation">,</span> second<span class="token operator">=</span><span class="token number">56</span><span class="token punctuation">,</span> microsecond<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> dt<span class="token punctuation">.</span>isoformat<span class="token punctuation">(</span>timespec<span class="token operator">=</span><span class="token string">'microseconds'</span><span class="token punctuation">)</span>
<span class="token string">'12:34:56.000000'</span>
<span class="token operator">>></span><span class="token operator">></span> dt<span class="token punctuation">.</span>isoformat<span class="token punctuation">(</span>timespec<span class="token operator">=</span><span class="token string">'auto'</span><span class="token punctuation">)</span>
<span class="token string">'12:34:56'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>3.6 新版功能: 增加了 <em>timespec</em> 参数。</p>
<p><code>time.__str__</code>()</p>
<p>对于时间对象 <em>t</em>, <code>str(t)</code> 等价于 <code>t.isoformat()</code>。</p>
<p><code>time.strftime</code>(<em>format</em>)</p>
<p>返回一个由显式格式字符串所指明的代表时间的字符串。</p>
<p><code>time.__format__</code>(<em>format</em>)</p>
<p>与 <code>time.strftime()</code> 相同。 此方法使得为 <code>time</code> 对象指定以 格式化字符串字面值 表示的格式化字符串以及使用 <code>str.format()</code> 进行格式化成为可能。</p>
<p><code>time.utcoffset</code>()</p>
<p>如果 <code>tzinfo</code> 为 <code>None</code>，则返回 <code>None</code>，否则返回 <code>self.tzinfo.utcoffset(None)</code>，并且在后者不返回 <code>None</code> 或一个幅度小于一天的 a <code>timedelta</code> 对象时将引发异常。</p>
<p>在 3.7 版更改: UTC 时差不再限制为一个整数分钟值。</p>
<p><code>time.dst</code>()</p>
<p>如果 <code>tzinfo</code> 为 <code>None</code>，则返回 <code>None</code>，否则返回 <code>self.tzinfo.dst(None)</code>，并且在后者不返回 <code>None</code> 或者一个幅度小于一天的 <code>timedelta</code> 对象时将引发异常。</p>
<p>在 3.7 版更改: DST 差值不再限制为一个整数分钟值。</p>
<p><code>time.tzname</code>()</p>
<p>如果 <code>tzinfo</code> 为 <code>None</code>，则返回 <code>None</code>，否则返回 <code>self.tzinfo.tzname(None)</code>，如果后者不返回 <code>None</code> 或者一个字符串对象则将引发异常。</p>
<h4 id="用法示例-time"><a href="#用法示例-time" class="headerlink" title="用法示例: time"></a>用法示例: <code>time</code></h4><p>使用 <code>time</code> 对象的例子:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span><span class="token keyword">from</span> datetime <span class="token keyword">import</span> time<span class="token punctuation">,</span> tzinfo<span class="token punctuation">,</span> timedelta
<span class="token operator">>></span><span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">TZ1</span><span class="token punctuation">(</span>tzinfo<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">def</span> utcoffset<span class="token punctuation">(</span>self<span class="token punctuation">,</span> dt<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">return</span> timedelta<span class="token punctuation">(</span>hours<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">def</span> dst<span class="token punctuation">(</span>self<span class="token punctuation">,</span> dt<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">return</span> timedelta<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">def</span> tzname<span class="token punctuation">(</span>self<span class="token punctuation">,</span>dt<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">return</span><span class="token string">"+01:00"</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">def</span>  __repr__<span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">return</span> f<span class="token string">"{self.__class__.__name__}()"</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> t <span class="token operator">=</span> time<span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">30</span><span class="token punctuation">,</span> tzinfo<span class="token operator">=</span>TZ1<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> t
datetime<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">30</span><span class="token punctuation">,</span> tzinfo<span class="token operator">=</span>TZ1<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> t<span class="token punctuation">.</span>isoformat<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token string">'12:10:30+01:00'</span>
<span class="token operator">>></span><span class="token operator">></span> t<span class="token punctuation">.</span>dst<span class="token punctuation">(</span><span class="token punctuation">)</span>
datetime<span class="token punctuation">.</span>timedelta<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> t<span class="token punctuation">.</span>tzname<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token string">'+01:00'</span>
<span class="token operator">>></span><span class="token operator">></span> t<span class="token punctuation">.</span>strftime<span class="token punctuation">(</span><span class="token string">"%H:%M:%S %Z"</span><span class="token punctuation">)</span>
<span class="token string">'12:10:30 +01:00'</span>
<span class="token operator">>></span><span class="token operator">></span><span class="token string">'The {} is {:%H:%M}.'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span><span class="token string">"time"</span><span class="token punctuation">,</span> t<span class="token punctuation">)</span>
<span class="token string">'The time is 12:10.'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="tzinfo-对象"><a href="#tzinfo-对象" class="headerlink" title="tzinfo 对象"></a><code>tzinfo</code> 对象</h3><p><em>class</em><code>datetime.tzinfo</code></p>
<p>这是一个抽象基类，也就是说该类不应被直接实例化。 请定义 <code>tzinfo</code> 的子类来捕获有关特定时区的信息。</p>
<p><code>tzinfo</code> 的（某个实体子类）的实例可以被传给 <code>datetime</code> 和 <code>time</code> 对象的构造器。 这些对象会将它们的属性视为对应于本地时间，并且 <code>tzinfo</code> 对象支持展示本地时间与 UTC 的差值、时区名称以及 DST 差值的方法，都是与传给它们的日期或时间对象的相对值。</p>
<p>你需要派生一个实体子类，并且（至少）提供你使用 <code>datetime</code> 方法所需要的标准 <code>tzinfo</code> 方法的实现。 <code>datetime</code> 模块提供了 <code>timezone</code>，这是 <code>tzinfo</code> 的一个简单实体子类，它能以与 UTC 的固定差值来表示不同的时区，例如 UTC 本身或北美的 EST 和 EDT。</p>
<p>对于封存操作的特殊要求：一个 <code>tzinfo</code> 子类必须具有可不带参数调用的 <code>__init__()</code> 方法，否则它虽然可以被封存，但可能无法再次解封。 这是个技术性要求，在未来可能会被取消。</p>
<p>一个 <code>tzinfo</code> 的实体子类可能需要实现以下方法。 具体需要实现的方法取决于感知型 <code>datetime</code> 对象如何使用它。 如果有疑问，可以简单地全都实现。</p>
<p><code>tzinfo.utcoffset</code>(<em>dt</em>)</p>
<p>将本地时间与 UTC 时差返回为一个 <code>timedelta</code> 对象，如果本地时区在 UTC 以东则为正值。 如果本地时区在 UTC 以西则为负值。</p>
<p>这表示与 UTC 的 <em>总计</em> 时差；举例来说，如果一个 <code>tzinfo</code> 对象同时代表时区和 DST 调整，则 <code>utcoffset()</code> 应当返回两者的和。 如果 UTC 时差不确定则返回 <code>None</code>。 在其他情况下返回值必须为一个 <code>timedelta</code> 对象，其取值严格限制于 <code>-timedelta(hours=24)</code> 和 <code>timedelta(hours=24)</code> 之间（差值的幅度必须小于一天）。 大多数 <code>utcoffset()</code> 的实现看起来可能像是以下两者之一:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">return</span> CONSTANT                 <span class="token comment" spellcheck="true"># fixed-offset class</span>
<span class="token keyword">return</span> CONSTANT <span class="token operator">+</span>self<span class="token punctuation">.</span>dst<span class="token punctuation">(</span>dt<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># daylight-aware class</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>如果 <code>utcoffset()</code> 返回值不为 <code>None</code>，则 <code>dst()</code> 也不应返回 <code>None</code>。</p>
<p>默认的 <code>utcoffset()</code> 实现会引发 <code>NotImplementedError</code>。</p>
<p>在 3.7 版更改: UTC 时差不再限制为一个整数分钟值。</p>
<p><code>tzinfo.dst</code>(<em>dt</em>)</p>
<p>将夏令时（DST）调整返回为一个 <code>timedelta</code> 对象，如果 DST 信息未知则返回 <code>None</code>。</p>
<p>如果 DST 未启用则返回 <code>timedelta(0)</code>。 如果 DST 已启用则将差值作为一个 <code>timedelta</code> 对象返回。 请注意 DST 差值如果可用，就会直接被加入 <code>utcoffset()</code> 所返回的 UTC 时差，因此无需额外查询 <code>dst()</code> 除非你希望单独获取 DST 信息。 例如，<code>datetime.timetuple()</code> 会调用其 <code>tzinfo</code> 属性的 <code>dst()</code> 方法来确定应该如何设置 <code>tm_isdst</code> 旗标，而 <code>tzinfo.fromutc()</code> 会调用 <code>dst()</code> 来在跨越时区时处理 DST 的改变。</p>
<p>一个可以同时处理标准时和夏令时的 <code>tzinfo</code> 子类的实例 <em>tz</em> 必须在此情形中保持一致：</p>
<pre><code>tz.utcoffset(dt) - tz.dst(dt)</code></pre><p>必须为具有同样的 <code>tzinfo</code> 子类实例且 <code>dt.tzinfo == tz</code> 的每个 <code>datetime</code> 对象 <em>dt</em> 返回同样的结果，此表达式会产生时区的“标准时差”，它不应取决于具体日期或时间，只取决于地理位置。 <code>datetime.astimezone()</code> 的实现依赖此方法，但无法检测违反规则的情况；确保符合规则是程序员的责任。 如果一个 <code>tzinfo</code> 子类不能保证这一点，也许可以重载 <code>tzinfo.fromutc()</code> 的默认实现以便在任何情况下与 <code>astimezone()</code> 正确配合。</p>
<p>大多数 <code>dst()</code> 的实现可能会如以下两者之一:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">dst</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> dt<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token comment" spellcheck="true"># a fixed-offset class:  doesn't account for DST</span>
<span class="token keyword">return</span> timedelta<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>或者：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">dst</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> dt<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token comment" spellcheck="true"># Code to set dston and dstoff to the time zone's DST</span>
<span class="token comment" spellcheck="true"># transition times based on the input dt.year, and expressed</span>
<span class="token comment" spellcheck="true"># in standard local time.</span>
<span class="token keyword">if</span> dston <span class="token operator">&lt;=</span> dt<span class="token punctuation">.</span>replace<span class="token punctuation">(</span>tzinfo<span class="token operator">=</span>None<span class="token punctuation">)</span><span class="token operator">&lt;</span> dstoff<span class="token punctuation">:</span>
<span class="token keyword">return</span> timedelta<span class="token punctuation">(</span>hours<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token keyword">else</span><span class="token punctuation">:</span>
<span class="token keyword">return</span> timedelta<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>默认的 <code>dst()</code> 实现会引发 <code>NotImplementedError</code>。</p>
<p>在 3.7 版更改: DST 差值不再限制为一个整数分钟值。</p>
<p><code>tzinfo.tzname</code>(<em>dt</em>)</p>
<p>将对应于 <code>datetime</code> 对象 <em>dt</em> 的时区名称作为字符串返回。 <code>datetime</code> 模块没有定义任何字符串名称相关内容，也不要求名称有任何特定含义。 例如 “GMT”, “UTC”, “-500”, “-5:00”, “EDT”, “US/Eastern”, “America/New York” 都是有效的返回值。 如果字符串名称未知则返回 <code>None</code>。 请注意这是一个方法而不是一个固定的字符串，这主要是因为某些 <code>tzinfo</code> 子类可能需要根据所传入的特定 <em>dt</em> 值返回不同的名称，特别是当 <code>tzinfo</code> 类要负责处理夏令时的时候。</p>
<p>默认的 <code>tzname()</code> 实现会引发 <code>NotImplementedError</code>。</p>
<p>这些方法会被 <code>datetime</code> 或 <code>time</code> 对象调用，用来与它们的同名方法相对应。 <code>datetime</code> 对象会将自身作为传入参数，而 <code>time</code> 对象会将 <code>None</code> 作为传入参数。 这样 <code>tzinfo</code> 子类的方法应当准备好接受 <em>dt</em> 参数值为 <code>None</code> 或是 <code>datetime</code> 类的实例。</p>
<p>当传入 <code>None</code> 时，应当由类的设计者来决定最佳回应方式。 例如，返回 <code>None</code> 适用于希望该类提示时间对象不参与 <code>tzinfo</code> 协议处理。 让 <code>utcoffset(None)</code> 返回标准 UTC 时差也许会更有用处，因为并没有其他可用于发现标准时差的约定惯例。</p>
<p>当传入一个 <code>datetime</code> 对象来回应 <code>datetime</code> 方法时，<code>dt.tzinfo</code> 与 <em>self</em> 是同一对象。 <code>tzinfo</code> 方法可以依赖这一点，除非用户代码直接调用了 <code>tzinfo</code> 方法。 此行为的目的是使得 <code>tzinfo</code> 方法将 <em>dt</em> 解读为本地时间，而不需要担心其他时区的相关对象。</p>
<p>还有一个额外的 <code>tzinfo</code> 方法，某个子类可能会希望重载它：</p>
<p><code>tzinfo.fromutc</code>(<em>dt</em>)</p>
<p>此方法会由默认的 <code>datetime.astimezone()</code> 实现来调用。 当被其调用时，<code>dt.tzinfo</code> 为 <em>self*，并且 *dt</em> 的日期和时间数据会被视为表示 UTC 时间，<code>fromutc()</code> 的目标是调整日期和时间数据，返回一个等价的 datetime 来表示 <em>self</em> 的本地时间。</p>
<p>大多数 <code>tzinfo</code> 子类应该能够毫无问题地继承默认的 <code>fromutc()</code> 实现。 它的健壮性足以处理固定差值的时区以及同时负责标准时和夏令时的时区，对于后者甚至还能处理 DST 转换时间在各个年份有变化的情况。 一个默认 <code>fromutc()</code> 实现可能无法在所有情况下正确处理的例子是（与 UTC 的）标准时差取决于所经过的特定日期和时间，这种情况可能由于政治原因而出现。 默认的 <code>astimezone()</code> 和 <code>fromutc()</code> 实现可能无法生成你希望的结果，如果这个结果恰好是跨越了标准时差发生改变的时刻当中的某个小时值的话。</p>
<p>忽略针对错误情况的代码，默认 <code>fromutc()</code> 实现的行为方式如下:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">fromutc</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> dt<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token comment" spellcheck="true"># raise ValueError error if dt.tzinfo is not self</span>
    dtoff <span class="token operator">=</span> dt<span class="token punctuation">.</span>utcoffset<span class="token punctuation">(</span><span class="token punctuation">)</span>
    dtdst <span class="token operator">=</span> dt<span class="token punctuation">.</span>dst<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment" spellcheck="true"># raise ValueError if dtoff is None or dtdst is None</span>
    delta <span class="token operator">=</span> dtoff <span class="token operator">-</span> dtdst  <span class="token comment" spellcheck="true"># this is self's standard offset</span>
<span class="token keyword">if</span> delta<span class="token punctuation">:</span>
        dt <span class="token operator">+=</span> delta   <span class="token comment" spellcheck="true"># convert to standard local time</span>
        dtdst <span class="token operator">=</span> dt<span class="token punctuation">.</span>dst<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment" spellcheck="true"># raise ValueError if dtdst is None</span>
<span class="token keyword">if</span> dtdst<span class="token punctuation">:</span>
<span class="token keyword">return</span> dt <span class="token operator">+</span> dtdst
<span class="token keyword">else</span><span class="token punctuation">:</span>
<span class="token keyword">return</span> dt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在以下 <a href="https://docs.python.org/zh-cn/3.10/_downloads/6b45dc135219d1404be49d606589a11d/tzinfo_examples.py" target="_blank" rel="noopener"><code>tzinfo_examples.py</code></a> 文件中有一些 <code>tzinfo</code> 类的例子：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> datetime <span class="token keyword">import</span> tzinfo<span class="token punctuation">,</span> timedelta<span class="token punctuation">,</span> datetime
ZERO <span class="token operator">=</span> timedelta<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
HOUR <span class="token operator">=</span> timedelta<span class="token punctuation">(</span>hours<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>
SECOND <span class="token operator">=</span> timedelta<span class="token punctuation">(</span>seconds<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token comment" spellcheck="true"># A class capturing the platform's idea of local time.</span>
<span class="token comment" spellcheck="true"># (May result in wrong values on historical times in</span>
<span class="token comment" spellcheck="true">#  timezones where UTC offset and/or the DST rules had</span>
<span class="token comment" spellcheck="true">#  changed in the past.)</span>
<span class="token keyword">import</span> time <span class="token keyword">as</span> _time
STDOFFSET <span class="token operator">=</span> timedelta<span class="token punctuation">(</span>seconds <span class="token operator">=</span><span class="token operator">-</span>_time<span class="token punctuation">.</span>timezone<span class="token punctuation">)</span>
<span class="token keyword">if</span> _time<span class="token punctuation">.</span>daylight<span class="token punctuation">:</span>
    DSTOFFSET <span class="token operator">=</span> timedelta<span class="token punctuation">(</span>seconds <span class="token operator">=</span><span class="token operator">-</span>_time<span class="token punctuation">.</span>altzone<span class="token punctuation">)</span>
<span class="token keyword">else</span><span class="token punctuation">:</span>
    DSTOFFSET <span class="token operator">=</span> STDOFFSET
DSTDIFF <span class="token operator">=</span> DSTOFFSET <span class="token operator">-</span> STDOFFSET
classLocalTimezone<span class="token punctuation">(</span>tzinfo<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token keyword">def</span> <span class="token function">fromutc</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> dt<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token keyword">assert</span> dt<span class="token punctuation">.</span>tzinfo isself
        stamp <span class="token operator">=</span><span class="token punctuation">(</span>dt <span class="token operator">-</span> datetime<span class="token punctuation">(</span><span class="token number">1970</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span> tzinfo<span class="token operator">=</span>self<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">//</span> SECOND
        args <span class="token operator">=</span> _time<span class="token punctuation">.</span>localtime<span class="token punctuation">(</span>stamp<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">6</span><span class="token punctuation">]</span>
        dst_diff <span class="token operator">=</span> DSTDIFF <span class="token operator">//</span> SECOND
<span class="token comment" spellcheck="true"># Detect fold</span>
        fold <span class="token operator">=</span><span class="token punctuation">(</span>args <span class="token operator">==</span> _time<span class="token punctuation">.</span>localtime<span class="token punctuation">(</span>stamp <span class="token operator">-</span> dst_diff<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">return</span> datetime<span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> microsecond<span class="token operator">=</span>dt<span class="token punctuation">.</span>microsecond<span class="token punctuation">,</span>
                        tzinfo<span class="token operator">=</span>self<span class="token punctuation">,</span> fold<span class="token operator">=</span>fold<span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">utcoffset</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> dt<span class="token punctuation">)</span><span class="token punctuation">:</span>
ifself<span class="token punctuation">.</span>_isdst<span class="token punctuation">(</span>dt<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token keyword">return</span> DSTOFFSET
<span class="token keyword">else</span><span class="token punctuation">:</span>
<span class="token keyword">return</span> STDOFFSET
<span class="token keyword">def</span> <span class="token function">dst</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> dt<span class="token punctuation">)</span><span class="token punctuation">:</span>
ifself<span class="token punctuation">.</span>_isdst<span class="token punctuation">(</span>dt<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token keyword">return</span> DSTDIFF
<span class="token keyword">else</span><span class="token punctuation">:</span>
<span class="token keyword">return</span> ZERO
<span class="token keyword">def</span> <span class="token function">tzname</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> dt<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token keyword">return</span> _time<span class="token punctuation">.</span>tzname<span class="token punctuation">[</span>self<span class="token punctuation">.</span>_isdst<span class="token punctuation">(</span>dt<span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token keyword">def</span> <span class="token function">_isdst</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> dt<span class="token punctuation">)</span><span class="token punctuation">:</span>
        tt <span class="token operator">=</span><span class="token punctuation">(</span>dt<span class="token punctuation">.</span>year<span class="token punctuation">,</span> dt<span class="token punctuation">.</span>month<span class="token punctuation">,</span> dt<span class="token punctuation">.</span>day<span class="token punctuation">,</span>
              dt<span class="token punctuation">.</span>hour<span class="token punctuation">,</span> dt<span class="token punctuation">.</span>minute<span class="token punctuation">,</span> dt<span class="token punctuation">.</span>second<span class="token punctuation">,</span>
              dt<span class="token punctuation">.</span>weekday<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span>
        stamp <span class="token operator">=</span> _time<span class="token punctuation">.</span>mktime<span class="token punctuation">(</span>tt<span class="token punctuation">)</span>
        tt <span class="token operator">=</span> _time<span class="token punctuation">.</span>localtime<span class="token punctuation">(</span>stamp<span class="token punctuation">)</span>
<span class="token keyword">return</span> tt<span class="token punctuation">.</span>tm_isdst <span class="token operator">></span><span class="token number">0</span>
Local<span class="token operator">=</span>LocalTimezone<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment" spellcheck="true"># A complete implementation of current DST rules for major US time zones.</span>
<span class="token keyword">def</span> <span class="token function">first_sunday_on_or_after</span><span class="token punctuation">(</span>dt<span class="token punctuation">)</span><span class="token punctuation">:</span>
    days_to_go <span class="token operator">=</span><span class="token number">6</span><span class="token operator">-</span> dt<span class="token punctuation">.</span>weekday<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">if</span> days_to_go<span class="token punctuation">:</span>
        dt <span class="token operator">+=</span> timedelta<span class="token punctuation">(</span>days_to_go<span class="token punctuation">)</span>
<span class="token keyword">return</span> dt
<span class="token comment" spellcheck="true"># US DST Rules</span>
<span class="token comment" spellcheck="true">#</span>
<span class="token comment" spellcheck="true"># This is a simplified (i.e., wrong for a few cases) set of rules for US</span>
<span class="token comment" spellcheck="true"># DST start and end times. For a complete and up-to-date set of DST rules</span>
<span class="token comment" spellcheck="true"># and timezone definitions, visit the Olson Database (or try pytz):</span>
<span class="token comment" spellcheck="true"># http://www.twinsun.com/tz/tz-link.htm</span>
<span class="token comment" spellcheck="true"># http://sourceforge.net/projects/pytz/ (might not be up-to-date)</span>
<span class="token comment" spellcheck="true">#</span>
<span class="token comment" spellcheck="true"># In the US, since 2007, DST starts at 2am (standard time) on the second</span>
<span class="token comment" spellcheck="true"># Sunday in March, which is the first Sunday on or after Mar 8.</span>
DSTSTART_2007 <span class="token operator">=</span> datetime<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span>
<span class="token comment" spellcheck="true"># and ends at 2am (DST time) on the first Sunday of Nov.</span>
DSTEND_2007 <span class="token operator">=</span> datetime<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">11</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span>
<span class="token comment" spellcheck="true"># From 1987 to 2006, DST used to start at 2am (standard time) on the first</span>
<span class="token comment" spellcheck="true"># Sunday in April and to end at 2am (DST time) on the last</span>
<span class="token comment" spellcheck="true"># Sunday of October, which is the first Sunday on or after Oct 25.</span>
DSTSTART_1987_2006 <span class="token operator">=</span> datetime<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span>
DSTEND_1987_2006 <span class="token operator">=</span> datetime<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">25</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span>
<span class="token comment" spellcheck="true"># From 1967 to 1986, DST used to start at 2am (standard time) on the last</span>
<span class="token comment" spellcheck="true"># Sunday in April (the one on or after April 24) and to end at 2am (DST time)</span>
<span class="token comment" spellcheck="true"># on the last Sunday of October, which is the first Sunday</span>
<span class="token comment" spellcheck="true"># on or after Oct 25.</span>
DSTSTART_1967_1986 <span class="token operator">=</span> datetime<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">24</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span>
DSTEND_1967_1986 <span class="token operator">=</span> DSTEND_1987_2006
<span class="token keyword">def</span> <span class="token function">us_dst_range</span><span class="token punctuation">(</span>year<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token comment" spellcheck="true"># Find start and end times for US DST. For years before 1967, return</span>
<span class="token comment" spellcheck="true"># start = end for no DST.</span>
if2006<span class="token operator">&lt;</span> year<span class="token punctuation">:</span>
        dststart<span class="token punctuation">,</span> dstend <span class="token operator">=</span> DSTSTART_2007<span class="token punctuation">,</span> DSTEND_2007
elif1986<span class="token operator">&lt;</span> year <span class="token operator">&lt;</span><span class="token number">2007</span><span class="token punctuation">:</span>
        dststart<span class="token punctuation">,</span> dstend <span class="token operator">=</span> DSTSTART_1987_2006<span class="token punctuation">,</span> DSTEND_1987_2006
elif1966<span class="token operator">&lt;</span> year <span class="token operator">&lt;</span><span class="token number">1987</span><span class="token punctuation">:</span>
        dststart<span class="token punctuation">,</span> dstend <span class="token operator">=</span> DSTSTART_1967_1986<span class="token punctuation">,</span> DSTEND_1967_1986
<span class="token keyword">else</span><span class="token punctuation">:</span>
<span class="token keyword">return</span><span class="token punctuation">(</span>datetime<span class="token punctuation">(</span>year<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">2</span>
    start <span class="token operator">=</span> first_sunday_on_or_after<span class="token punctuation">(</span>dststart<span class="token punctuation">.</span>replace<span class="token punctuation">(</span>year<span class="token operator">=</span>year<span class="token punctuation">)</span><span class="token punctuation">)</span>
end<span class="token operator">=</span> first_sunday_on_or_after<span class="token punctuation">(</span>dstend<span class="token punctuation">.</span>replace<span class="token punctuation">(</span>year<span class="token operator">=</span>year<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">return</span> start<span class="token punctuation">,</span>end
classUSTimeZone<span class="token punctuation">(</span>tzinfo<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> hours<span class="token punctuation">,</span> reprname<span class="token punctuation">,</span> stdname<span class="token punctuation">,</span> dstname<span class="token punctuation">)</span><span class="token punctuation">:</span>
self<span class="token punctuation">.</span>stdoffset <span class="token operator">=</span> timedelta<span class="token punctuation">(</span>hours<span class="token operator">=</span>hours<span class="token punctuation">)</span>
self<span class="token punctuation">.</span>reprname <span class="token operator">=</span> reprname
self<span class="token punctuation">.</span>stdname <span class="token operator">=</span> stdname
self<span class="token punctuation">.</span>dstname <span class="token operator">=</span> dstname
<span class="token keyword">def</span> <span class="token function">__repr__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
returnself<span class="token punctuation">.</span>reprname
<span class="token keyword">def</span> <span class="token function">tzname</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> dt<span class="token punctuation">)</span><span class="token punctuation">:</span>
ifself<span class="token punctuation">.</span>dst<span class="token punctuation">(</span>dt<span class="token punctuation">)</span><span class="token punctuation">:</span>
returnself<span class="token punctuation">.</span>dstname
<span class="token keyword">else</span><span class="token punctuation">:</span>
returnself<span class="token punctuation">.</span>stdname
<span class="token keyword">def</span> <span class="token function">utcoffset</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> dt<span class="token punctuation">)</span><span class="token punctuation">:</span>
returnself<span class="token punctuation">.</span>stdoffset <span class="token operator">+</span>self<span class="token punctuation">.</span>dst<span class="token punctuation">(</span>dt<span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">dst</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> dt<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token keyword">if</span> dt isNoneor dt<span class="token punctuation">.</span>tzinfo isNone<span class="token punctuation">:</span>
<span class="token comment" spellcheck="true"># An exception may be sensible here, in one or both cases.</span>
<span class="token comment" spellcheck="true"># It depends on how you want to treat them.  The default</span>
<span class="token comment" spellcheck="true"># fromutc() implementation (called by the default astimezone()</span>
<span class="token comment" spellcheck="true"># implementation) passes a datetime with dt.tzinfo is self.</span>
<span class="token keyword">return</span> ZERO
<span class="token keyword">assert</span> dt<span class="token punctuation">.</span>tzinfo isself
        start<span class="token punctuation">,</span>end<span class="token operator">=</span> us_dst_range<span class="token punctuation">(</span>dt<span class="token punctuation">.</span>year<span class="token punctuation">)</span>
<span class="token comment" spellcheck="true"># Can't compare naive to aware objects, so strip the timezone from</span>
<span class="token comment" spellcheck="true"># dt first.</span>
        dt <span class="token operator">=</span> dt<span class="token punctuation">.</span>replace<span class="token punctuation">(</span>tzinfo<span class="token operator">=</span>None<span class="token punctuation">)</span>
<span class="token keyword">if</span> start <span class="token operator">+</span> HOUR <span class="token operator">&lt;=</span> dt <span class="token operator">&lt;</span>end<span class="token operator">-</span> HOUR<span class="token punctuation">:</span>
<span class="token comment" spellcheck="true"># DST is in effect.</span>
<span class="token keyword">return</span> HOUR
ifend<span class="token operator">-</span> HOUR <span class="token operator">&lt;=</span> dt <span class="token operator">&lt;</span>end<span class="token punctuation">:</span>
<span class="token comment" spellcheck="true"># Fold (an ambiguous hour): use dt.fold to disambiguate.</span>
<span class="token keyword">return</span> ZERO <span class="token keyword">if</span> dt<span class="token punctuation">.</span>fold <span class="token keyword">else</span> HOUR
<span class="token keyword">if</span> start <span class="token operator">&lt;=</span> dt <span class="token operator">&lt;</span> start <span class="token operator">+</span> HOUR<span class="token punctuation">:</span>
<span class="token comment" spellcheck="true"># Gap (a non-existent hour): reverse the fold rule.</span>
<span class="token keyword">return</span> HOUR <span class="token keyword">if</span> dt<span class="token punctuation">.</span>fold <span class="token keyword">else</span> ZERO
<span class="token comment" spellcheck="true"># DST is off.</span>
<span class="token keyword">return</span> ZERO
<span class="token keyword">def</span> <span class="token function">fromutc</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> dt<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token keyword">assert</span> dt<span class="token punctuation">.</span>tzinfo isself
        start<span class="token punctuation">,</span>end<span class="token operator">=</span> us_dst_range<span class="token punctuation">(</span>dt<span class="token punctuation">.</span>year<span class="token punctuation">)</span>
        start <span class="token operator">=</span> start<span class="token punctuation">.</span>replace<span class="token punctuation">(</span>tzinfo<span class="token operator">=</span>self<span class="token punctuation">)</span>
end<span class="token operator">=</span>end<span class="token punctuation">.</span>replace<span class="token punctuation">(</span>tzinfo<span class="token operator">=</span>self<span class="token punctuation">)</span>
        std_time <span class="token operator">=</span> dt <span class="token operator">+</span>self<span class="token punctuation">.</span>stdoffset
        dst_time <span class="token operator">=</span> std_time <span class="token operator">+</span> HOUR
ifend<span class="token operator">&lt;=</span> dst_time <span class="token operator">&lt;</span>end<span class="token operator">+</span> HOUR<span class="token punctuation">:</span>
<span class="token comment" spellcheck="true"># Repeated hour</span>
<span class="token keyword">return</span> std_time<span class="token punctuation">.</span>replace<span class="token punctuation">(</span>fold<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token keyword">if</span> std_time <span class="token operator">&lt;</span> start <span class="token operator">or</span> dst_time <span class="token operator">>=</span>end<span class="token punctuation">:</span>
<span class="token comment" spellcheck="true"># Standard time</span>
<span class="token keyword">return</span> std_time
<span class="token keyword">if</span> start <span class="token operator">&lt;=</span> std_time <span class="token operator">&lt;</span>end<span class="token operator">-</span> HOUR<span class="token punctuation">:</span>
<span class="token comment" spellcheck="true"># Daylight saving time</span>
<span class="token keyword">return</span> dst_time
Eastern<span class="token operator">=</span>USTimeZone<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token string">"Eastern"</span><span class="token punctuation">,</span><span class="token string">"EST"</span><span class="token punctuation">,</span><span class="token string">"EDT"</span><span class="token punctuation">)</span>
Central<span class="token operator">=</span>USTimeZone<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token string">"Central"</span><span class="token punctuation">,</span><span class="token string">"CST"</span><span class="token punctuation">,</span><span class="token string">"CDT"</span><span class="token punctuation">)</span>
Mountain<span class="token operator">=</span>USTimeZone<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token string">"Mountain"</span><span class="token punctuation">,</span><span class="token string">"MST"</span><span class="token punctuation">,</span><span class="token string">"MDT"</span><span class="token punctuation">)</span>
Pacific<span class="token operator">=</span>USTimeZone<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token string">"Pacific"</span><span class="token punctuation">,</span><span class="token string">"PST"</span><span class="token punctuation">,</span><span class="token string">"PDT"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>请注意同时负责标准时和夏令时的 <code>tzinfo</code> 子类在每年两次的 DST 转换点上会出现不可避免的微妙问题。具体而言，考虑美国东部时区 (UTC -0500)，它的 EDT 从三月的第二个星期天 1:59 (EST) 之后一分钟开始，并在十一月的第一天星期天 1:59 (EDT) 之后一分钟结束:</p>
<pre><code>  UTC   3:MM  4:MM  5:MM  6:MM  7:MM  8:MM
  EST  22:MM 23:MM  0:MM  1:MM  2:MM  3:MM
  EDT  23:MM  0:MM  1:MM  2:MM  3:MM  4:MM
start  22:MM 23:MM  0:MM  1:MM  3:MM  4:MM
end23:MM  0:MM  1:MM  1:MM  2:MM  3:MM</code></pre><p>当 DST 开始时（即 “start” 行），本地时钟从 1:59 跳到 3:00。 形式为 2:MM 的时间值在那一天是没有意义的，因此在 DST 开始那一天 <code>astimezone(Eastern)</code> 不会输出包含 <code>hour == 2</code> 的结果。 例如，在 2016 年春季时钟向前调整时，我们得到:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span><span class="token keyword">from</span> datetime <span class="token keyword">import</span> datetime<span class="token punctuation">,</span> timezone
<span class="token operator">>></span><span class="token operator">></span><span class="token keyword">from</span> tzinfo_examples <span class="token keyword">import</span> HOUR<span class="token punctuation">,</span>Eastern
<span class="token operator">>></span><span class="token operator">></span> u0 <span class="token operator">=</span> datetime<span class="token punctuation">(</span><span class="token number">2016</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">13</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span> tzinfo<span class="token operator">=</span>timezone<span class="token punctuation">.</span>utc<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span><span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     u <span class="token operator">=</span> u0 <span class="token operator">+</span> i<span class="token operator">*</span>HOUR
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     t <span class="token operator">=</span> u<span class="token punctuation">.</span>astimezone<span class="token punctuation">(</span>Eastern<span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">print</span><span class="token punctuation">(</span>u<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">'UTC ='</span><span class="token punctuation">,</span> t<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> t<span class="token punctuation">.</span>tzname<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token number">05</span><span class="token punctuation">:</span><span class="token number">00</span><span class="token punctuation">:</span><span class="token number">00</span> UTC <span class="token operator">=</span><span class="token number">00</span><span class="token punctuation">:</span><span class="token number">00</span><span class="token punctuation">:</span><span class="token number">00</span> EST
<span class="token number">06</span><span class="token punctuation">:</span><span class="token number">00</span><span class="token punctuation">:</span><span class="token number">00</span> UTC <span class="token operator">=</span><span class="token number">01</span><span class="token punctuation">:</span><span class="token number">00</span><span class="token punctuation">:</span><span class="token number">00</span> EST
<span class="token number">07</span><span class="token punctuation">:</span><span class="token number">00</span><span class="token punctuation">:</span><span class="token number">00</span> UTC <span class="token operator">=</span><span class="token number">03</span><span class="token punctuation">:</span><span class="token number">00</span><span class="token punctuation">:</span><span class="token number">00</span> EDT
<span class="token number">08</span><span class="token punctuation">:</span><span class="token number">00</span><span class="token punctuation">:</span><span class="token number">00</span> UTC <span class="token operator">=</span><span class="token number">04</span><span class="token punctuation">:</span><span class="token number">00</span><span class="token punctuation">:</span><span class="token number">00</span> EDT<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>当 DST 结束时（见 “end” 行），会有更糟糕的潜在问题：本地时间值中有一个小时是不可能没有歧义的：夏令时的最后一小时。 即以北美东部时间表示当天夏令时结束时的形式为 5:MM UTC 的时间。 本地时钟从 1:59 (夏令时) 再次跳回到 1:00 (标准时)。 形式为 1:MM 的本地时间就是有歧义的。 此时 <code>astimezone()</code> 是通过将两个相邻的 UTC 小时映射到两个相同的本地小时来模仿本地时钟的行为。 在这个北美东部时间的示例中，形式为 5:MM 和 6:MM 的 UTC 时间在转换为北美东部时间时都将被映射到 1:MM，但前一个时间会将 <code>fold</code> 属性设为 0 而后一个时间会将其设为 1。 例如，在 2016 年秋季时钟往回调整时，我们得到:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> u0 <span class="token operator">=</span> datetime<span class="token punctuation">(</span><span class="token number">2016</span><span class="token punctuation">,</span><span class="token number">11</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span> tzinfo<span class="token operator">=</span>timezone<span class="token punctuation">.</span>utc<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span><span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     u <span class="token operator">=</span> u0 <span class="token operator">+</span> i<span class="token operator">*</span>HOUR
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     t <span class="token operator">=</span> u<span class="token punctuation">.</span>astimezone<span class="token punctuation">(</span>Eastern<span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">print</span><span class="token punctuation">(</span>u<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">'UTC ='</span><span class="token punctuation">,</span> t<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> t<span class="token punctuation">.</span>tzname<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> t<span class="token punctuation">.</span>fold<span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token number">04</span><span class="token punctuation">:</span><span class="token number">00</span><span class="token punctuation">:</span><span class="token number">00</span> UTC <span class="token operator">=</span><span class="token number">00</span><span class="token punctuation">:</span><span class="token number">00</span><span class="token punctuation">:</span><span class="token number">00</span> EDT <span class="token number">0</span>
<span class="token number">05</span><span class="token punctuation">:</span><span class="token number">00</span><span class="token punctuation">:</span><span class="token number">00</span> UTC <span class="token operator">=</span><span class="token number">01</span><span class="token punctuation">:</span><span class="token number">00</span><span class="token punctuation">:</span><span class="token number">00</span> EDT <span class="token number">0</span>
<span class="token number">06</span><span class="token punctuation">:</span><span class="token number">00</span><span class="token punctuation">:</span><span class="token number">00</span> UTC <span class="token operator">=</span><span class="token number">01</span><span class="token punctuation">:</span><span class="token number">00</span><span class="token punctuation">:</span><span class="token number">00</span> EST <span class="token number">1</span>
<span class="token number">07</span><span class="token punctuation">:</span><span class="token number">00</span><span class="token punctuation">:</span><span class="token number">00</span> UTC <span class="token operator">=</span><span class="token number">02</span><span class="token punctuation">:</span><span class="token number">00</span><span class="token punctuation">:</span><span class="token number">00</span> EST <span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>请注意不同的 <code>datetime</code> 实例仅通过 <code>fold</code> 属性值来加以区分，它们在比较时会被视为相等。</p>
<p>不允许时间显示存在歧义的应用需要显式地检查 <code>fold</code> 属性的值，或者避免使用混合式的 <code>tzinfo</code> 子类；当使用 <code>timezone</code> 或者任何其他固定差值的 <code>tzinfo</code> 子类例如仅表示 EST（固定差值 -5 小时）或仅表示 EDT（固定差值 -4 小时）的类时是不会有歧义的。</p>
<p><code>datetime</code> 模块有一个基本 <code>timezone</code> 类（用来处理任意与 UTC 的固定时差）及其 <code>timezone.utc</code> 属性（一个 UTC 时区实例）。</p>
<p><em>dateutil.tz</em> 库将 <em>IANA 时区数据库</em> (又名 Olson 数据库) 引入 Python 并推荐使用。</p>
<p><a href="https://www.iana.org/time-zones" target="_blank" rel="noopener">IANA 时区数据库</a></p>
<p>该时区数据库 (通常称为 tz, tzdata 或 zoneinfo) 包含大量代码和数据用来表示全球许多有代表性的地点的本地时间的历史信息。 它会定期进行更新以反映各政治实体对时区边界、UTC 差值和夏令时规则的更改。</p>
<h3 id="timezone-对象"><a href="#timezone-对象" class="headerlink" title="timezone 对象"></a><code>timezone</code> 对象</h3><p><code>timezone</code> 类是 <code>tzinfo</code> 的子类，它的每个实例都代表一个以与 UTC 的固定时差来定义的时区。</p>
<p>此类的对象不可被用于代表某些特殊地点的时区信息，这些地点在一年的不同日期会使用不同的时差，或是在历史上对民用时间进行过调整。</p>
<p><em>class<em><code>datetime.timezone</code>(</em>offset</em>, <em>name=None</em>)</p>
<p><em>offset</em> 参数必须指定为一个 <code>timedelta</code> 对象，表示本地时间与 UTC 的时差。 它必须严格限制于 <code>-timedelta(hours=24)</code> 和 <code>timedelta(hours=24)</code> 之间，否则会引发 <code>ValueError</code>。</p>
<p><em>name</em> 参数是可选的。 如果指定则必须为一个字符串，它将被用作 <code>datetime.tzname()</code> 方法的返回值。</p>
<p>3.2 新版功能.</p>
<p>在 3.7 版更改: UTC 时差不再限制为一个整数分钟值。</p>
<p><code>timezone.utcoffset</code>(<em>dt</em>)</p>
<p>返回当 <code>timezone</code> 实例被构造时指定的固定值。</p>
<p><em>dt</em> 参数会被忽略。 返回值是一个 <code>timedelta</code> 实例，其值等于本地时间与 UTC 之间的时差。</p>
<p>在 3.7 版更改: UTC 时差不再限制为一个整数分钟值。</p>
<p><code>timezone.tzname</code>(<em>dt</em>)</p>
<p>返回当 <code>timezone</code> 实例被构造时指定的固定值。</p>
<p>如果没有在构造器中提供 <em>name*，则 <code>tzname(dt)</code> 所返回的名称将根据 <code>offset</code> 值按以下规则生成。 如果 *offset</em> 为 <code>timedelta(0)</code>，则名称为“UTC”，否则为字符串 <code>UTC±HH:MM</code>，其中 ± 为 <code>offset</code> 的正负符号，HH 和 MM 分别为表示 <code>offset.hours</code> 和 <code>offset.minutes</code> 的两个数码。</p>
<p>在 3.6 版更改: 由 <code>offset=timedelta(0)</code> 生成的名称现在为简单的 ‘UTC’ 而不再是 <code>'UTC+00:00'</code>。</p>
<p><code>timezone.dst</code>(<em>dt</em>)</p>
<p>总是返回 <code>None</code>。</p>
<p><code>timezone.fromutc</code>(<em>dt</em>)</p>
<p>返回 <code>dt + offset</code>。 <em>dt</em> 参数必须为一个感知型 <code>datetime</code> 实例，其中 <code>tzinfo</code> 值设为 <code>self</code>。</p>
<p>类属性：</p>
<pre><code>timezone.utc</code></pre><p>UTC 时区，<code>timezone(timedelta(0))</code>。</p>
<h3 id="strftime-和-strptime-的行为"><a href="#strftime-和-strptime-的行为" class="headerlink" title="strftime() 和 strptime() 的行为"></a><code>strftime()</code> 和 <code>strptime()</code> 的行为</h3><p><code>date</code>, <code>datetime</code> 和 <code>time</code> 对象都支持 <code>strftime(format)</code> 方法，可用来创建由一个显式格式字符串所控制的表示时间的字符串。</p>
<p>相反地，<code>datetime.strptime()</code> 类会根据表示日期和时间的字符串和相应的格式字符串来创建一个 <code>datetime</code> 对象。</p>
<p>下表提供了 <code>strftime()</code> 与 <code>strptime()</code> 的高层级比较：</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left"><code>strftime</code></th>
<th align="left"><code>strptime</code></th>
</tr>
</thead>
<tbody><tr>
<td align="left">用法</td>
<td align="left">根据给定的格式将对象转换为字符串</td>
<td align="left">将字符串解析为给定相应格式的 <code>datetime</code> 对象</td>
</tr>
<tr>
<td align="left">方法类型</td>
<td align="left">实例方法</td>
<td align="left">类方法</td>
</tr>
<tr>
<td align="left">方法</td>
<td align="left"><code>date</code>; <code>datetime</code>; <code>time</code></td>
<td align="left"><code>datetime</code></td>
</tr>
<tr>
<td align="left">签名</td>
<td align="left"><code>strftime(format)</code></td>
<td align="left"><code>strptime(date_string, format)</code></td>
</tr>
</tbody></table>
<h4 id="strftime-和-strptime-Format-Codes"><a href="#strftime-和-strptime-Format-Codes" class="headerlink" title="strftime() 和 strptime() Format Codes"></a><code>strftime()</code> 和 <code>strptime()</code> Format Codes</h4><p>以下列表显示了 1989 版 C 标准所要求的全部格式代码，它们在带有标准 C 实现的所有平台上均可用。</p>
<table>
<thead>
<tr>
<th align="left">指令</th>
<th align="left">含意</th>
<th align="left">示例</th>
<th align="left">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>%a</code></td>
<td align="left">当地工作日的缩写。</td>
<td align="left">Sun, Mon, …, Sat (en_US);So, Mo, …, Sa (de_DE)</td>
<td align="left">(1)</td>
</tr>
<tr>
<td align="left"><code>%A</code></td>
<td align="left">本地化的星期中每日的完整名称。</td>
<td align="left">Sunday, Monday, …, Saturday (en_US);Sonntag, Montag, …, Samstag (de_DE)</td>
<td align="left">(1)</td>
</tr>
<tr>
<td align="left"><code>%w</code></td>
<td align="left">以十进制数显示的工作日，其中0表示星期日，6表示星期六。</td>
<td align="left">0, 1, …, 6</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>%d</code></td>
<td align="left">补零后，以十进制数显示的月份中的一天。</td>
<td align="left">01, 02, …, 31</td>
<td align="left">(9)</td>
</tr>
<tr>
<td align="left"><code>%b</code></td>
<td align="left">当地月份的缩写。</td>
<td align="left">Jan, Feb, …, Dec (en_US);Jan, Feb, …, Dez (de_DE)</td>
<td align="left">(1)</td>
</tr>
<tr>
<td align="left"><code>%B</code></td>
<td align="left">本地化的月份全名。</td>
<td align="left">January, February, …, December (en_US);Januar, Februar, …, Dezember (de_DE)</td>
<td align="left">(1)</td>
</tr>
<tr>
<td align="left"><code>%m</code></td>
<td align="left">补零后，以十进制数显示的月份。</td>
<td align="left">01, 02, …, 12</td>
<td align="left">(9)</td>
</tr>
<tr>
<td align="left"><code>%y</code></td>
<td align="left">补零后，以十进制数表示的，不带世纪的年份。</td>
<td align="left">00, 01, …, 99</td>
<td align="left">(9)</td>
</tr>
<tr>
<td align="left"><code>%Y</code></td>
<td align="left">十进制数表示的带世纪的年份。</td>
<td align="left">0001, 0002, …, 2013, 2014, …, 9998, 9999</td>
<td align="left">(2)</td>
</tr>
<tr>
<td align="left"><code>%H</code></td>
<td align="left">以补零后的十进制数表示的小时（24 小时制）。</td>
<td align="left">00, 01, …, 23</td>
<td align="left">(9)</td>
</tr>
<tr>
<td align="left"><code>%I</code></td>
<td align="left">以补零后的十进制数表示的小时（12 小时制）。</td>
<td align="left">01, 02, …, 12</td>
<td align="left">(9)</td>
</tr>
<tr>
<td align="left"><code>%p</code></td>
<td align="left">本地化的 AM 或 PM 。</td>
<td align="left">AM, PM (en_US);am, pm (de_DE)</td>
<td align="left">(1), (3)</td>
</tr>
<tr>
<td align="left"><code>%M</code></td>
<td align="left">补零后，以十进制数显示的分钟。</td>
<td align="left">00, 01, …, 59</td>
<td align="left">(9)</td>
</tr>
<tr>
<td align="left"><code>%S</code></td>
<td align="left">补零后，以十进制数显示的秒。</td>
<td align="left">00, 01, …, 59</td>
<td align="left">(4), (9)</td>
</tr>
<tr>
<td align="left"><code>%f</code></td>
<td align="left">以十进制数表示的微秒，在左侧补零。</td>
<td align="left">000000, 000001, …, 999999</td>
<td align="left">(5)</td>
</tr>
<tr>
<td align="left"><code>%z</code></td>
<td align="left">UTC 偏移量，格式为 <code>±HHMM[SS[.ffffff]]</code> （如果是简单型对象则为空字符串）。</td>
<td align="left">(空), +0000, -0400, +1030, +063415, -030712.345216</td>
<td align="left">(6)</td>
</tr>
<tr>
<td align="left"><code>%Z</code></td>
<td align="left">时区名称（如果对象为简单型则为空字符串）。</td>
<td align="left">(空), UTC, GMT</td>
<td align="left">(6)</td>
</tr>
<tr>
<td align="left"><code>%j</code></td>
<td align="left">以补零后的十进制数表示的一年中的日序号。</td>
<td align="left">001, 002, …, 366</td>
<td align="left">(9)</td>
</tr>
<tr>
<td align="left"><code>%U</code></td>
<td align="left">以补零后的十进制数表示的一年中的周序号（星期日作为每周的第一天）。 在新的一年中第一个星期日之前的所有日子都被视为是在第 0 周。</td>
<td align="left">00, 01, …, 53</td>
<td align="left">(7), (9)</td>
</tr>
<tr>
<td align="left"><code>%W</code></td>
<td align="left">以十进制数表示的一年中的周序号（星期一作为每周的第一天）。 在新的一年中第一个第期一之前的所有日子都被视为是在第 0 周。</td>
<td align="left">00, 01, …, 53</td>
<td align="left">(7), (9)</td>
</tr>
<tr>
<td align="left"><code>%c</code></td>
<td align="left">本地化的适当日期和时间表示。</td>
<td align="left">Tue Aug 16 21:30:00 1988 (en_US);Di 16 Aug 21:30:00 1988 (de_DE)</td>
<td align="left">(1)</td>
</tr>
<tr>
<td align="left"><code>%x</code></td>
<td align="left">本地化的适当日期表示。</td>
<td align="left">08/16/88 (None);08/16/1988 (en_US);16.08.1988 (de_DE)</td>
<td align="left">(1)</td>
</tr>
<tr>
<td align="left"><code>%X</code></td>
<td align="left">本地化的适当时间表示。</td>
<td align="left">21:30:00 (en_US);21:30:00 (de_DE)</td>
<td align="left">(1)</td>
</tr>
<tr>
<td align="left"><code>%%</code></td>
<td align="left">字面的 <code>‘%’</code> 字符。</td>
<td align="left">%</td>
<td align="left"></td>
</tr>
</tbody></table>
<p>为了方便起见，还包括了C89标准不需要的其他一些指令。这些参数都对应于ISO 8601日期值。</p>
<table>
<thead>
<tr>
<th align="left">指令</th>
<th align="left">含意</th>
<th align="left">示例</th>
<th align="left">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>%G</code></td>
<td align="left">带有世纪的 ISO 8601 年份，表示包含大部分 ISO 星期 (<code>%V</code>) 的年份。</td>
<td align="left">0001, 0002, …, 2013, 2014, …, 9998, 9999</td>
<td align="left">(8)</td>
</tr>
<tr>
<td align="left"><code>%u</code></td>
<td align="left">以十进制数显示的 ISO 8601 星期中的日序号，其中 1 表示星期一。</td>
<td align="left">1, 2, …, 7</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>%V</code></td>
<td align="left">以十进制数显示的 ISO 8601 星期，以星期一作为每周的第一天。 第 01 周为包含 1 月 4 日的星期。</td>
<td align="left">01, 02, …, 53</td>
<td align="left">(8), (9)</td>
</tr>
</tbody></table>
<p>这些代码可能不是在所有平台上都可与 <code>strftime()</code> 方法配合使用。 ISO 8601 年份和 ISO 8601 星期指令并不能与上面的年份和星期序号指令相互替代。 调用 <code>strptime()</code> 时传入不完整或有歧义的 ISO 8601 指令将引发 <code>ValueError</code>。</p>
<p>The full set of format codes supported varies across platforms, because Python calls the platform C library’s <code>strftime()</code> function, and platform variations are common. To see the full set of format codes supported on your platform, consult the <em>strftime(3)</em> documentation. There are also differences between platforms in handling of unsupported format specifiers.</p>
<p>3.6 新版功能: 增加了 <code>%G</code>, <code>%u</code> 和 <code>%V</code>。</p>
<h4 id="技术细节"><a href="#技术细节" class="headerlink" title="技术细节"></a>技术细节</h4><p>总体而言，<code>d.strftime(fmt)</code> 类似于 <code>time</code> 模块的 <code>time.strftime(fmt, d.timetuple())</code>，但是并非所有对象都支持 <code>timetuple()</code> 方法。</p>
<p>对于 <code>datetime.strptime()</code> 类方法，默认值为 <code>1900-01-01T00:00:00.000</code>: 任何未在格式字符串中指定的部分都将从默认值中提取。 </p>
<p>使用 <code>datetime.strptime(date_string, format)</code> 等价于:</p>
<pre><code>datetime(*(time.strptime(date_string, format)[0:6]))</code></pre><p>除非格式中包含秒以下的部分或时区差值信息，它们在 <code>datetime.strptime</code> 中受支持但会被 <code>time.strptime</code> 所丢弃。</p>
<p>对于 <code>time</code> 对象，年、月、日的格式代码不应被使用，因为 <code>time</code> 对象没有这些值。 如果它们被使用，则年份将被替换为 <code>1900</code>，而月和日将被替换为 <code>1</code>。</p>
<p>对于 <code>date</code> 对象，时、分、秒和微秒的格式代码不应被使用，因为 <code>date</code> 对象没有这些值。 如果它们被使用，则它们都将被替换为 <code>0</code>。</p>
<p>出于相同的原因，对于包含当前区域设置字符集所无法表示的 Unicode 码位的格式字符串的处理方式也取决于具体平台。 在某些平台上这样的码位会不加修改地原样输出，而在其他平台上 <code>strftime</code> 则可能引发 <code>UnicodeError</code> 或只返回一个空字符串。</p>
<p>注释：</p>
<ol>
<li><p>由于此格式依赖于当前区域设置，因此对具体输出值应当保持谨慎预期。 字段顺序会发生改变（例如 “month/day/year” 与 “day/month/year”），并且输出可能包含使用区域设置所指定的默认编码格式的 Unicode 字符（例如如果当前区域为 <code>ja_JP</code>，则默认编码格式可能为 <code>eucJP</code>, <code>SJIS</code> 或 <code>utf-8</code> 中的一个；使用 <code>locale.getlocale()</code> 可确定当前区域设置的编码格式）。</p>
</li>
<li><p><code>strptime()</code> 方法能够解析整个 [1, 9999] 范围内的年份，但 &lt; 1000 的年份必须加零填充为 4 位数字宽度。</p>
<p>在 3.2 版更改: 在之前的版本中，<code>strftime()</code> 方法只限于 &gt;= 1900 的年份。</p>
<p>在 3.3 版更改: 在版本3.2中，<code>strftime()</code> 方法只限于 years &gt;= 1000。</p>
</li>
<li><p>当与 <code>strptime()</code> 方法一起使用时，如果使用 <code>%I</code> 指令来解析小时，<code>%p</code> 指令只影响输出小时字段。</p>
</li>
<li><p>与 <code>time</code> 模块不同的是， <code>datetime</code> 模块不支持闰秒。</p>
</li>
<li><p>当与 <code>strptime()</code> 方法一起使用时，<code>%f</code> 指令可接受一至六个数码及左边的零填充。 <code>%f</code> 是对 C 标准中格式字符集的扩展（但单独在 datetime 对象中实现，因此它总是可用）。</p>
</li>
<li><p>对于简单型对象，<code>%z</code> and <code>%Z</code> 格式代码会被替换为空字符串。</p>
<p>对于一个感知型对象而言：</p>
<p><code>%z</code></p>
<p><code>utcoffset()</code> 会被转换为 <code>±HHMM[SS[.ffffff]]</code> 形式的字符串，其中 <code>HH</code> 为给出 UTC 时差的小时部分的 2 位数码字符串，<code>MM</code> 为给出 UTC 时差的分钟部分的 2 位数码字符串，<code>SS</code> 为给出 UTC 时差的秒部分的 2 位数码字符串，而 <code>ffffff</code> 为给出 UTC 时差的微秒部分的 6 位数码字符串。 当时差为整数秒时 <code>ffffff</code> 部分将被省略，而当时差为整数分钟时 <code>ffffff</code> 和 <code>SS</code> 部分都将被省略。 例如，如果 <code>utcoffset()</code> 返回 <code>timedelta(hours=-3, minutes=-30)</code>，则 <code>%z</code> 会被替换为字符串 <code>'-0330'</code>。</p>
<p>在 3.7 版更改: UTC 时差不再限制为一个整数分钟值。</p>
<p>在 3.7 版更改: 当提供 <code>%z</code> 指令给 <code>strptime()</code> 方法时，UTC 差值可以在时、分和秒之间使用冒号分隔符。 例如，<code>'+01:00:00'</code> 将被解读为一小时的差值。 此外，提供 <code>'Z'</code> 就相当于 <code>'+00:00'</code>。</p>
<p><code>%Z</code></p>
<p>在 <code>strftime()</code> 中，如果 <code>tzname()</code> 返回 <code>None</code> 则 <code>%Z</code> 会被替换为一个空字符串；在其他情况下 <code>%Z</code> 会被替换为返回值，该值必须为一个字符串。</p>
<p><code>strptime()</code> 仅接受特定的 <code>%Z</code> 值:</p>
<ol>
<li>你的机器的区域设置可以是 <code>time.tzname</code> 中的任何值</li>
<li>硬编码的值 <code>UTC</code> 和 <code>GMT</code></li>
</ol>
<p>这样生活在日本的人可用的值为 <code>JST</code>, <code>UTC</code> 和 <code>GMT</code>，但可能没有 <code>EST</code>。 它将引发 <code>ValueError</code> 表示无效的值。</p>
<p>在 3.2 版更改: 当提供 <code>%z</code> 指令给 <code>strptime()</code> 方法时，将产生一个感知型 <code>datetime</code> 对象。 结果的 <code>tzinfo</code> 将被设为一个 <code>timezone</code> 实例。</p>
</li>
<li><p>当与 <code>strptime()</code> 方法一起使用时，<code>%U</code> 和 <code>%W</code> 仅用于指定星期几和日历年份 (<code>%Y</code>) 的计算。</p>
</li>
<li><p>类似于 <code>%U</code> 和 <code>%W</code>，<code>%V</code> 仅用于在 <code>strptime()</code> 格式字符串中指定星期几和 ISO 年份 (<code>%G</code>) 的计算。 还要注意 <code>%G</code> 和 <code>%Y</code> 是不可交换的。</p>
</li>
<li><p>当于 <code>strptime()</code> 方法一起使用时，前导的零在格式 <code>%d</code>, <code>%m</code>, <code>%H</code>, <code>%I</code>, <code>%M</code>, <code>%S</code>, <code>%J</code>, <code>%U</code>, <code>%W</code> 和 <code>%V</code> 中是可选的。 格式 <code>%y</code> 不要求有前导的零。</p>
</li>
</ol>
<h2 id="zoneinfo-—-IANA-时区支持"><a href="#zoneinfo-—-IANA-时区支持" class="headerlink" title="zoneinfo —- IANA 时区支持"></a><code>zoneinfo</code> —- IANA 时区支持</h2><p>3.9 新版功能.</p>
<hr>
<p><code>zoneinfo</code> 模块根据 <a href="https://www.python.org/dev/peps/pep-0615" target="_blank" rel="noopener"><strong>PEP 615</strong></a> 的最初说明提供了具体的时区实现来支持 IANA 时区数据库。 按照默认设置，<code>zoneinfo</code> 会在可能的情况下使用系统的时区数据；如果系统时区数据不可用，该库将回退为使用 PyPI 上提供的 tzdata 第一方包。</p>
<p>由 CPython 核心开发者维护以通过 PyPI 提供时区数据的第一方包。</p>
<h3 id="使用-ZoneInfo"><a href="#使用-ZoneInfo" class="headerlink" title="使用 ZoneInfo"></a>使用 <code>ZoneInfo</code></h3><p><code>ZoneInfo</code> 是 <code>datetime.tzinfo</code> 抽象基类的具体实现，其目标是通过构造器、 <code>datetime.replace</code> 方法或 <code>datetime.astimezone</code> 来与 <code>tzinfo</code> 建立关联:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> zoneinfo <span class="token keyword">import</span> ZoneInfo
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> datetime <span class="token keyword">import</span> datetime<span class="token punctuation">,</span> timedelta
<span class="token operator">>></span><span class="token operator">></span> dt <span class="token operator">=</span> datetime<span class="token punctuation">(</span><span class="token number">2020</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">31</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">,</span> tzinfo<span class="token operator">=</span>ZoneInfo<span class="token punctuation">(</span><span class="token string">"America/Los_Angeles"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>dt<span class="token punctuation">)</span>
<span class="token number">2020</span><span class="token operator">-</span><span class="token number">10</span><span class="token operator">-</span><span class="token number">31</span> <span class="token number">12</span><span class="token punctuation">:</span><span class="token number">00</span><span class="token punctuation">:</span><span class="token number">00</span><span class="token operator">-</span><span class="token number">07</span><span class="token punctuation">:</span><span class="token number">00</span>
<span class="token operator">>></span><span class="token operator">></span> dt<span class="token punctuation">.</span>tzname<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token string">'PDT'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>以此方式构造的日期时间对象可兼容日期时间运算并可在无需进一步干预的情况下处理夏令时转换:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> dt_add <span class="token operator">=</span> dt <span class="token operator">+</span> timedelta<span class="token punctuation">(</span>days<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>dt_add<span class="token punctuation">)</span>
<span class="token number">2020</span><span class="token operator">-</span><span class="token number">11</span><span class="token operator">-</span><span class="token number">01</span> <span class="token number">12</span><span class="token punctuation">:</span><span class="token number">00</span><span class="token punctuation">:</span><span class="token number">00</span><span class="token operator">-</span><span class="token number">08</span><span class="token punctuation">:</span><span class="token number">00</span>
<span class="token operator">>></span><span class="token operator">></span> dt_add<span class="token punctuation">.</span>tzname<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token string">'PST'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这些时区还支持在 <a href="https://www.python.org/dev/peps/pep-0495" target="_blank" rel="noopener"><strong>PEP 495</strong></a> 中引入的 <code>fold</code>。 在可能导致时间歧义的时差转换中（例如夏令时到标准时的转换），当 <code>fold=0</code> 时会使用转换 <em>之前</em> 的时差，而当 <code>fold=1</code> 时则使用转换 <em>之后</em> 的时差，例如:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> dt <span class="token operator">=</span> datetime<span class="token punctuation">(</span><span class="token number">2020</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> tzinfo<span class="token operator">=</span>ZoneInfo<span class="token punctuation">(</span><span class="token string">"America/Los_Angeles"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>dt<span class="token punctuation">)</span>
<span class="token number">2020</span><span class="token operator">-</span><span class="token number">11</span><span class="token operator">-</span><span class="token number">01</span> <span class="token number">01</span><span class="token punctuation">:</span><span class="token number">00</span><span class="token punctuation">:</span><span class="token number">00</span><span class="token operator">-</span><span class="token number">07</span><span class="token punctuation">:</span><span class="token number">00</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>dt<span class="token punctuation">.</span>replace<span class="token punctuation">(</span>fold<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token number">2020</span><span class="token operator">-</span><span class="token number">11</span><span class="token operator">-</span><span class="token number">01</span> <span class="token number">01</span><span class="token punctuation">:</span><span class="token number">00</span><span class="token punctuation">:</span><span class="token number">00</span><span class="token operator">-</span><span class="token number">08</span><span class="token punctuation">:</span><span class="token number">00</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>当执行来自另一时区的转换时，fold 将被设置为正确的值:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> datetime <span class="token keyword">import</span> timezone
<span class="token operator">>></span><span class="token operator">></span> LOS_ANGELES <span class="token operator">=</span> ZoneInfo<span class="token punctuation">(</span><span class="token string">"America/Los_Angeles"</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> dt_utc <span class="token operator">=</span> datetime<span class="token punctuation">(</span><span class="token number">2020</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> tzinfo<span class="token operator">=</span>timezone<span class="token punctuation">.</span>utc<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token comment" spellcheck="true"># Before the PDT -> PST transition</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>dt_utc<span class="token punctuation">.</span>astimezone<span class="token punctuation">(</span>LOS_ANGELES<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token number">2020</span><span class="token operator">-</span><span class="token number">11</span><span class="token operator">-</span><span class="token number">01</span> <span class="token number">01</span><span class="token punctuation">:</span><span class="token number">00</span><span class="token punctuation">:</span><span class="token number">00</span><span class="token operator">-</span><span class="token number">07</span><span class="token punctuation">:</span><span class="token number">00</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token comment" spellcheck="true"># After the PDT -> PST transition</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token punctuation">(</span>dt_utc <span class="token operator">+</span> timedelta<span class="token punctuation">(</span>hours<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>astimezone<span class="token punctuation">(</span>LOS_ANGELES<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token number">2020</span><span class="token operator">-</span><span class="token number">11</span><span class="token operator">-</span><span class="token number">01</span> <span class="token number">01</span><span class="token punctuation">:</span><span class="token number">00</span><span class="token punctuation">:</span><span class="token number">00</span><span class="token operator">-</span><span class="token number">08</span><span class="token punctuation">:</span><span class="token number">00</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="数据源"><a href="#数据源" class="headerlink" title="数据源"></a>数据源</h3><p><code>zoneinfo</code> 模块不直接提供时区数据，而是在可能的情况下从系统时区数据库或 PyPI 上的第一方包 tzdata 获取时区信息。 某些系统，重要的一点是 Windows 系统也包括在内，并没有可用的 IANA 数据库，因此对于要保证获取时区信息的跨平台兼容性的项目，推荐对 tzdata 声明依赖。 如果系统数据和 tzdata 均不可用，则所有对 <code>ZoneInfo</code> 的调用都将引发 <code>ZoneInfoNotFoundError</code>。</p>
<h4 id="配置数据源"><a href="#配置数据源" class="headerlink" title="配置数据源"></a>配置数据源</h4><p>当 <code>ZoneInfo(key)</code> 被调用时，此构造器首先会在 <code>TZPATH</code> 所指定的目录下搜索匹配 <code>key</code> 的文件，失败时则会在 tzdata 包中查找匹配。 此行为可通过三种方式来配置:</p>
<ol>
<li>默认的 <code>TZPATH</code> 未通过其他方式指定时可在 编译时 进行配置。</li>
<li><code>TZPATH</code> 可使用 环境变量 进行配置。</li>
<li>在 运行时，搜索路径可使用 <code>reset_tzpath()</code> 函数来修改。</li>
</ol>
<h5 id="编译时配置"><a href="#编译时配置" class="headerlink" title="编译时配置"></a>编译时配置</h5><p>默认的 <code>TZPATH</code> 包括一些时区数据库的通用部署位置（Windows 除外，该系统没有时区数据的“通用”位置）。 在 POSIX 系统中，下游分发者和从源码编译 Python 的开发者知道系统时区数据部署位置，它们可以通过指定编译时选项 <code>TZPATH</code> (或者更常见的是通过 <code>配置旗标 --with-tzpath</code>) 来改变默认的时区路径，该选项应当是一个由 <code>os.pathsep</code> 分隔的字符串。</p>
<p>在所有平台上，配置值会在 <code>sysconfig.get_config_var()</code> 中以 <code>TZPATH</code> 键的形式提供。</p>
<h5 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h5><p>当初始化 <code>TZPATH</code> 时（在导入时或不带参数调用 <code>reset_tzpath()</code> 时），<code>zoneinfo</code> 模块将使用环境变量 <code>PYTHONTZPATH</code>，如果变量存在则会设置搜索路径。</p>
<pre><code>PYTHONTZPATH</code></pre><p>这是一个以 <code>os.pathsep</code> 分隔的字符串，其中包含要使用的时区搜索路径。 它必须仅由绝对路径而非相对路径组成。 在 <code>PYTHONTZPATH</code> 中指定的相对路径部分将不会被使用，但在其他情况下当指定相对路径时的行为该实现是有定义的；CPython 将引发 <code>InvalidTZPathWarning</code>，而其他实现可自由地忽略错误部分或是引发异常。</p>
<p>要设置让系统忽略系统数据并改用 tzdata 包，请设置 <code>PYTHONTZPATH=""</code>。</p>
<h5 id="运行时配置"><a href="#运行时配置" class="headerlink" title="运行时配置"></a>运行时配置</h5><p>TZ 搜索路径也可在运行时使用 <code>reset_tzpath()</code> 函数来配置。 通常并不建议如此操作，不过在需要使用指定时区路径（或者需要禁止访问系统时区）的测试函数中使用它则是合理的。</p>
<h3 id="ZoneInfo-类"><a href="#ZoneInfo-类" class="headerlink" title="ZoneInfo 类"></a><code>ZoneInfo</code> 类</h3><p><em>class</em> <code>zoneinfo.ZoneInfo</code>(<em>key</em>)</p>
<p>一个具体的 <code>datetime.tzinfo</code> 子类，它代表一个由字符串 <code>key</code> 所指定的 IANA 时区。 对主构造器的调用将总是返回可进行标识比较的对象；但是另一种方式，对所有的 <code>key</code> 值通过 <code>ZoneInfo.clear_cache()</code> 禁止缓存失效，对以下断言将总是为真值:</p>
<pre class="line-numbers language-python"><code class="language-python">a <span class="token operator">=</span> ZoneInfo<span class="token punctuation">(</span>key<span class="token punctuation">)</span>
b <span class="token operator">=</span> ZoneInfo<span class="token punctuation">(</span>key<span class="token punctuation">)</span>
<span class="token keyword">assert</span> a <span class="token keyword">is</span> b<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p><code>key</code> 必须采用相对的标准化 POSIX 路径的形式，其中没有对上一层级的引用。 如果传入了不合要求的键则构造器将引发 <code>ValueError</code>。</p>
<p>如果没有找到匹配 <code>key</code> 的文件，构造器将引发 <code>ZoneInfoNotFoundError</code>。</p>
<p><code>ZoneInfo</code> 类具有两个替代构造器:</p>
<p><em>classmethod</em> <code>ZoneInfo.from_file</code>(<em>fobj</em>, <em>/</em>, <em>key=None</em>)</p>
<p>基于一个返回字节串的文件类对象（例如一个以二进制模式打开的文件或是一个 <code>io.BytesIO</code> 对象）构造 <code>ZoneInfo</code> 对象。 不同于主构造器，此构造器总是会构造一个新对象。</p>
<p><code>key</code> 形参设置时区名称以供 <code>__str__()</code> 和 <code>__repr__()</code> 使用。</p>
<p>由此构造器创建的对象不可被封存。</p>
<p><em>classmethod</em> <code>ZoneInfo.no_cache</code>(<em>key</em>)</p>
<p>一个绕过构造器缓存的替代构造器。 它与主构造器很相似，但每次调用都会返回一个新对象。 此构造器在进行测试或演示时最为适用，但它也可以被用来创建具有不同缓存失效策略的系统。</p>
<p>由此构造器创建的对象在被解封时也会绕过反序列化进程的缓存。</p>
<p>警告</p>
<p>使用此构造器可以会以令人惊讶的方式改变日期时间对象的语义，只有在你确定你的需求时才使用它。</p>
<p>也可以使用以下的类方法:</p>
<p><em>classmethod</em> <code>ZoneInfo.clear_cache</code>(<em>**,</em> only_keys=None*)</p>
<p>一个可在 <code>ZoneInfo</code> 类上禁用缓存的方法。 如果不传入参数，则会禁用所有缓存并且下次对每个键调用主构造器将返回一个新实例。</p>
<p>如果将一个键名称的可迭代对象传给 <code>only_keys</code> 形参，则将只有指定的键会被从缓存中移除。 传给 <code>only_keys</code> 但在缓存中找不到的键会被忽略。</p>
<p>警告</p>
<p>发起调用此函数可能会以令人惊讶的方式改变使用 <code>ZoneInfo</code> 的日期时间对象的语义；这会修改进程范围内的全局状态并因此可能产生大范围的影响。 只有在你确定你的需求时才使用它。</p>
<p>该类具有一个属性:</p>
<pre><code>ZoneInfo.key</code></pre><p>这是一个只读的 attribute，它返回传给构造器的 <code>key</code> 的值，该值应为一个 IANA 时区数据库的查找键 (例如 <code>America/New_York</code>, <code>Europe/Paris</code> 或 <code>Asia/Tokyo</code>)。</p>
<p>对于不指定 <code>key</code> 形参而是基于文件构造时区，该属性将设为 <code>None</code>。</p>
<p>注解</p>
<p>尽管将这些信息暴露给最终用户是一种比较普通的做法，但是这些值被设计作为代表相关时区的主键而不一定是面向用户的元素。 CLDR (Unicode 通用区域数据存储库) 之类的项目可被用来根据这些键获取更为用户友好的字符串。</p>
<h4 id="字符串表示"><a href="#字符串表示" class="headerlink" title="字符串表示"></a>字符串表示</h4><p>当在 <code>ZoneInfo</code> 对象上调用 <code>str</code> 时返回的字符串表示默认会使用 <code>ZoneInfo.key</code> 属性（参见该属性文档中的用法注释）:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> zone <span class="token operator">=</span> ZoneInfo<span class="token punctuation">(</span><span class="token string">"Pacific/Kwajalein"</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> str<span class="token punctuation">(</span>zone<span class="token punctuation">)</span>
<span class="token string">'Pacific/Kwajalein'</span>
<span class="token operator">>></span><span class="token operator">></span> dt <span class="token operator">=</span> datetime<span class="token punctuation">(</span><span class="token number">2020</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">,</span> tzinfo<span class="token operator">=</span>zone<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> f<span class="token string">"{dt.isoformat()} [{dt.tzinfo}]"</span>
<span class="token string">'2020-04-01T03:15:00+12:00 [Pacific/Kwajalein]'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>对于基于文件而非指定 <code>key</code> 形参所构建的对象，<code>str</code> 会回退为调用 <code>repr()</code>。 <code>ZoneInfo</code> 的 <code>repr</code> 是由具体实现定义的并且不一定会在不同版本间保持稳定，但它保证不会是一个有效的 <code>ZoneInfo</code> 键。</p>
<h4 id="封存序列化"><a href="#封存序列化" class="headerlink" title="封存序列化"></a>封存序列化</h4><p><code>ZoneInfo</code> 对象的序列化是基于键的，而不是序列化所有过渡数据，并且基于文件构造的 <code>ZoneInfo</code> 对象（即使是指定了 <code>key</code> 值的对象）不能被封存。</p>
<p><code>ZoneInfo</code> 文件的行为取决于它的构造方式:</p>
<ol>
<li><p><code>ZoneInfo(key)</code>: 当使用主构造器构造时，会基于键序列化一个 <code>ZoneInfo</code> 对象，而当反序列化时，反序列化过程会使用主构造器，因此预期它们与其他对同一时区的引用会是同一对象。 例如，如果 <code>europe_berlin_pkl</code> 是一个包含基于 <code>ZoneInfo("Europe/Berlin")</code> 构建的封存数据的字符串，你可以预期出现以下的行为:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> a <span class="token operator">=</span> ZoneInfo<span class="token punctuation">(</span><span class="token string">"Europe/Berlin"</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> b <span class="token operator">=</span> pickle<span class="token punctuation">.</span>loads<span class="token punctuation">(</span>europe_berlin_pkl<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> a <span class="token keyword">is</span> b
<span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><code>ZoneInfo.no_cache(key)</code>: 当通过绕过缓存的构造器构造时，<code>ZoneInfo</code> 对象也会基于键序列化，但当反序列化时，反序列化过程会使用绕过缓存的构造器。 如果 <code>europe_berlin_pkl_nc</code> 是一个包含基于 <code>ZoneInfo.no_cache("Europe/Berlin")</code> 构造的封存数据的字符串，你可以预期出现以下的行为:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> a <span class="token operator">=</span> ZoneInfo<span class="token punctuation">(</span><span class="token string">"Europe/Berlin"</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> b <span class="token operator">=</span> pickle<span class="token punctuation">.</span>loads<span class="token punctuation">(</span>europe_berlin_pkl_nc<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> a <span class="token keyword">is</span> b
<span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><code>ZoneInfo.from_file(fobj, /, key=None)</code>: 当通过文件构造时，<code>ZoneInfo</code> 对象会在封存时引发异常。 如果最终用户想要封存通过文件构造的 <code>ZoneInfo</code>，则推荐他们使用包装类型或自定义序列化函数：或者基于键序列化，或者存储文件对象的内容并将其序列化。</p>
</li>
</ol>
<p>该序列化方法要求所需键的时区数据在序列化和反序列化中均可用，类似于在序列化和反序列化环境中都预期存在对类和函数的引用的方式。 这还意味着在具有不同时区数据版本的环境中当解封被封存的 <code>ZoneInfo</code> 时并不会保证结果的一致性。</p>
<h3 id="函数-1"><a href="#函数-1" class="headerlink" title="函数"></a>函数</h3><p><code>zoneinfo.available_timezones</code>()</p>
<p>获取一个包含可用 IANA 时区的在时区路径的任何位置均可用的全部有效键的集合。 每次调用该函数时都会重新计算。</p>
<p>此函数仅包括规范时区名称而不包括“特殊”时区如位于 <code>posix/</code> 和 <code>right/</code> 目录下的时区或 <code>posixrules</code> 时区。</p>
<p>警告</p>
<p>此函数可能会打开大量的文件，因为确定时区路径上某个文件是否为有效时区的最佳方式是读取开头位置的“魔术字符串”。</p>
<p>注解</p>
<p>这些值并不被设计用来对外公开给最终用户；对于面向用户的元素，应用程序应当使用 CLDR (Unicode 通用区域数据存储库) 之类来获取更为用户友好的字符串。 </p>
<p><code>zoneinfo.reset_tzpath</code>(<em>to=None</em>)</p>
<p>设置或重置模块的时区搜索路径 (<code>TZPATH</code>)。 当不带参数调用时，<code>TZPATH</code> 会被设为默认值。</p>
<p>调用 <code>reset_tzpath</code> 将不会使 <code>ZoneInfo</code> 缓存失效，因而在缓存未命中的情况下对主 <code>ZoneInfo</code> 构造器的调用将只使用新的 <code>TZPATH</code>。</p>
<p><code>to</code> 形参必须是由字符串或 <code>os.PathLike</code> 组成的 sequence 或而不是字符串，它们必须都是绝对路径。 如果所传入的不是绝对路径则将引发 <code>ValueError</code>。</p>
<h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h3><pre><code>zoneinfo.TZPATH</code></pre><p>一个表示时区搜索路径的只读序列 — 当通过键构造 <code>ZoneInfo</code> 时，键会与 <code>TZPATH</code> 中的每个条目进行合并，并使用所找到的第一个文件。</p>
<p><code>TZPATH</code> 可以只包含绝对路径，绝不包含相对路径，无论它是如何配置的。</p>
<p><code>zoneinfo.TZPATH</code> 所指向的对象可能随着对 <code>reset_tzpath()</code> 的调用而改变，因此推荐使用 <code>zoneinfo.TZPATH</code> 而不是从 <code>zoneinfo</code> 导入 <code>TZPATH</code> 或是将 <code>zoneinfo.TZPATH</code> 赋值给一个长期变量。</p>
<h3 id="异常与警告"><a href="#异常与警告" class="headerlink" title="异常与警告"></a>异常与警告</h3><p><em>exception</em> <code>zoneinfo.ZoneInfoNotFoundError</code></p>
<p>当一个 <code>ZoneInfo</code> 对象的构造由于在系统中找不到指定的键而失败时引发。 这是 <code>KeyError</code> 的一个子类。</p>
<p><em>exception</em> <code>zoneinfo.InvalidTZPathWarning</code></p>
<p>当 <code>PYTHONTZPATH</code> 包含将被过滤掉的无效组件，例如一个相对路径时引发。</p>
<h2 id="calendar-—-日历相关函数"><a href="#calendar-—-日历相关函数" class="headerlink" title="calendar —- 日历相关函数"></a><code>calendar</code> —- 日历相关函数</h2><p><strong>源代码：</strong> <a href="https://github.com/python/cpython/tree/3.10/Lib/calendar.py" target="_blank" rel="noopener">Lib/calendar.py</a></p>
<hr>
<p>这个模块让你可以输出像 Unix <strong>cal</strong> 那样的日历，它还提供了其它与日历相关的实用函数。 默认情况下，这些日历把星期一当作一周的第一天，星期天为一周的最后一天（按照欧洲惯例）。 可以使用 <code>setfirstweekday()</code> 方法设置一周的第一天为星期天 (6) 或者其它任意一天。 使用整数作为指定日期的参数。</p>
<p>在这个模块中定义的函数和类都基于一个理想化的日历，现行公历向过去和未来两个方向无限扩展。这与 Dershowitz 和 Reingold 的书 “历法计算” 中所有计算的基本日历 — “proleptic Gregorian” 日历的定义相符合。 ISO 8601标准还规定了 0 和 负数年份。0年指公元前1年， -1年指公元前2年，依此类推。</p>
<p><em>class</em> <code>calendar.Calendar</code>(<em>firstweekday=0</em>)</p>
<p>创建一个 <code>Calendar</code> 对象。 <em>firstweekday</em> 是一个整数，用于指定一周的第一天。 <code>0</code> 是星期一（默认值），<code>6</code> 是星期天。</p>
<p><code>Calendar</code> 对象提供了一些可被用于准备日历数据格式化的方法。 这个类本身不执行任何格式化操作。 这部分任务应由子类来完成。</p>
<p><code>Calendar</code> 类的实例有下列方法：</p>
<ul>
<li><p><code>iterweekdays</code>()</p>
<p>返回一个迭代器，迭代器的内容为一星期的数字。迭代器的第一个值与 <code>firstweekday</code> 属性的值一至。</p>
</li>
<li><p><code>itermonthdates</code>(<em>year</em>, <em>month</em>)</p>
<p>返回一个迭代器，迭代器的内容为 <em>year</em> 年 <em>month</em> 月(1-12)的日期。这个迭代器返回当月的所有日期 ( <code>datetime.date</code> 对象)，日期包含了本月头尾用于组成完整一周的日期。</p>
</li>
<li><p><code>itermonthdays</code>(<em>year</em>, <em>month</em>)</p>
<p>返回一个迭代器，迭代器的内容与 <code>itermonthdates()</code> 类似，为 <em>year</em> 年 <em>month</em> 月的日期，但不受 <code>datetime.date</code> 范围限制。返回的日期为当月每一天的日期对应的天数。对于不在当月的日期，显示为 <code>0</code>。</p>
</li>
<li><p><code>itermonthdays2</code>(<em>year</em>, <em>month</em>)</p>
<p>返回一个迭代器，迭代器的内容与 <code>itermonthdates()</code> 类似为 <em>year</em> 年 <em>month</em> 月的日期，但不受 <code>datetime.date</code> 范围的限制。迭代器中的元素为一个由日期和代表星期几的数字组成的的元组。</p>
</li>
<li><p><code>itermonthdays3</code>(<em>year</em>, <em>month</em>)</p>
<p>返回一个迭代器，迭代器的内容与 <code>itermonthdates()</code> 类似为 <em>year</em> 年 <em>month</em> 月的日期，但不受 <code>datetime.date</code> 范围的限制。迭代器的元素为一个由年，月，日组成的元组。</p>
<p>3.7 新版功能.</p>
</li>
<li><p><code>itermonthdays4</code>(<em>year</em>, <em>month</em>)</p>
<p>返回一个迭代器，迭代器的内容与 <code>itermonthdates()</code> 类似为 <em>year</em> 年 <em>month</em> 月的日期，但不受 <code>datetime.date</code> 范围的限制。迭代器的元素为一个由年，月，日和代表星期几的数字组成的元组。</p>
<p>3.7 新版功能.</p>
</li>
<li><p><code>monthdatescalendar</code>(<em>year</em>, <em>month</em>)</p>
<p>返回一个表示指定年月的周列表。周列表由七个 <code>datetime.date</code> 对象组成。</p>
</li>
<li><p><code>monthdays2calendar</code>(<em>year</em>, <em>month</em>)</p>
<p>返回一个表示指定年月的周列表。周列表由七个代表日期的数字和代表周几的数字组成的二元元组。</p>
</li>
<li><p><code>monthdayscalendar</code>(<em>year</em>, <em>month</em>)</p>
<p>返回一个表示指定年月的周列表。周列表由七个代表日期的数字组成。</p>
</li>
<li><p><code>yeardatescalendar</code>(<em>year</em>, <em>width=3</em>)</p>
<p>返回可以用来格式化的指定年月的数据。返回的值是一个列表，列表是月份组成的行。每一行包含了最多 <em>width</em> 个月(默认为3)。每个月包含了4到6周，每周包含1—7天。每一天使用 <code>datetime.date</code> 对象。</p>
</li>
<li><p><code>yeardays2calendar</code>(<em>year</em>, <em>width=3</em>)</p>
<p>返回可以用来模式化的指定年月的数据(与 <code>yeardatescalendar()</code> 类似)。周列表的元素是由表示日期的数字和表示星期几的数字组成的元组。不在这个月的日子为0。</p>
</li>
<li><p><code>yeardayscalendar</code>(<em>year</em>, <em>width=3</em>)</p>
<p>返回可以用来模式化的指定年月的数据(与 <code>yeardatescalendar()</code> 类似)。周列表的元素是表示日期的数字。不在这个月的日子为0。</p>
</li>
</ul>
<p><em>class</em> <code>calendar.TextCalendar</code>(<em>firstweekday=0</em>)</p>
<p>可以使用这个类生成纯文本日历。</p>
<p><code>TextCalendar</code> 实例有以下方法：</p>
<ul>
<li><p><code>formatmonth</code>(<em>theyear</em>, <em>themonth</em>, <em>w=0</em>, <em>l=0</em>)</p>
<p>返回一个多行字符串来表示指定年月的日历。<em>w</em> 为日期的宽度，但始终保持日期居中。<em>l</em> 指定了每星期占用的行数。以上这些还依赖于构造器或者 <code>setfirstweekday()</code> 方法指定的周的第一天是哪一天。</p>
</li>
<li><p><code>prmonth</code>(<em>theyear</em>, <em>themonth</em>, <em>w=0</em>, <em>l=0</em>)</p>
<p>与 <code>formatmonth()</code> 方法一样，返回一个月的日历。</p>
</li>
<li><p><code>formatyear</code>(<em>theyear</em>, <em>w=2</em>, <em>l=1</em>, <em>c=6</em>, <em>m=3</em>)</p>
<p>返回一个多行字符串，这个字符串为一个 <em>m</em> 列日历。可选参数 <em>w</em>, <em>l</em>, 和 <em>c</em> 分别表示日期列数， 周的行数， 和月之间的间隔。同样，以上这些还依赖于构造器或者 <code>setfirstweekday()</code> 指定哪一天为一周的第一天。日历的第一年由平台依赖于使用的平台。</p>
</li>
<li><p><code>pryear</code>(<em>theyear</em>, <em>w=2</em>, <em>l=1</em>, <em>c=6</em>, <em>m=3</em>)</p>
<p>与 <code>formatyear()</code> 方法一样，返回一整年的日历。</p>
</li>
</ul>
<p><em>class</em> <code>calendar.HTMLCalendar</code>(<em>firstweekday=0</em>)</p>
<p>可以使用这个类生成 HTML 日历。</p>
<p><code>HTMLCalendar</code> 实例有以下方法：</p>
<ul>
<li><p><code>formatmonth</code>(<em>theyear</em>, <em>themonth</em>, <em>withyear=True</em>)</p>
<p>返回一个 HTML 表格作为指定年月的日历。 <em>withyear</em> 为真，则年份将会包含在表头，否则只显示月份。</p>
</li>
<li><p><code>formatyear</code>(<em>theyear</em>, <em>width=3</em>)</p>
<p>返回一个 HTML 表格作为指定年份的日历。 <em>width</em> (默认为3) 用于规定每一行显示月份的数量。</p>
</li>
<li><p><code>formatyearpage</code>(<em>theyear</em>, <em>width=3</em>, <em>css=’calendar.css’</em>, <em>encoding=None</em>)</p>
<p>返回一个完整的 HTML 页面作为指定年份的日历。 <em>width\</em>(默认为3) 用于规定每一行显示的月份数量。 <em>css *为层叠样式表的名字。如果不使用任何层叠样式表，可以使用 <code>None</code> 。</em> encoding* 为输出页面的编码 (默认为系统的默认编码)。</p>
</li>
</ul>
<p><code>HTMLCalendar</code> 有以下属性，你可以重载它们来自定义应用日历的样式。</p>
<ul>
<li><p><code>cssclasses</code></p>
<p>一个对应星期一到星期天的 CSS class 列表。默认列表为</p>
<pre><code>cssclasses = ["mon", "tue", "wed", "thu", "fri", "sat", "sun"]</code></pre><p>可以向每天加入其它样式</p>
<pre><code>cssclasses = ["mon text-bold", "tue", "wed", "thu", "fri", "sat", "sun red"]</code></pre><p>需要注意的是，列表的长度必须为7。</p>
</li>
<li><p><code>cssclass_noday</code></p>
<p>工作日的 CSS 类在上个月或下个月发生。</p>
<p>3.7 新版功能.</p>
</li>
<li><p><code>cssclasses_weekday_head</code></p>
<p>用于标题行中的工作日名称的 CSS 类 列表。默认值与 <code>cssclasses</code> 相同。</p>
<p>3.7 新版功能.</p>
</li>
<li><p><code>cssclass_month_head</code></p>
<p>月份的头 CSS 类（由 <code>formatmonthname()</code> 使用）。默认值为 <code>"month"</code> 。</p>
<p>3.7 新版功能.</p>
</li>
<li><p><code>cssclass_month</code></p>
<p>某个月的月历的 CSS 类（由 <code>formatmonth()</code> 使用）。默认值为 <code>"month"</code> 。</p>
<p>3.7 新版功能.</p>
</li>
<li><p><code>cssclass_year</code></p>
<p>某年的年历的 CSS 类（由 <code>formatyear()</code> 使用）。默认值为 <code>"year"</code> 。</p>
<p>3.7 新版功能.</p>
</li>
<li><p><code>cssclass_year_head</code></p>
<p>年历的·表头 CSS 类（由 <code>formatyear()</code> 使用）。默认值为 <code>"year"</code> 。</p>
<p>3.7 新版功能.</p>
</li>
</ul>
<p>需要注意的是，尽管上面命名的样式类都是单独出现的(如： <code>cssclass_month</code> <code>cssclass_noday</code>), 但我们可以使用空格将样式类列表中的多个元素分隔开，例如：</p>
<pre><code>"text-bold text-red"</code></pre><p>下面是一个如何自定义 <code>HTMLCalendar</code> 的示例</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">CustomHTMLCal</span><span class="token punctuation">(</span>calendar<span class="token punctuation">.</span>HTMLCalendar<span class="token punctuation">)</span><span class="token punctuation">:</span>
    cssclasses <span class="token operator">=</span> <span class="token punctuation">[</span>style <span class="token operator">+</span> <span class="token string">" text-nowrap"</span> <span class="token keyword">for</span> style <span class="token keyword">in</span>
                  calendar<span class="token punctuation">.</span>HTMLCalendar<span class="token punctuation">.</span>cssclasses<span class="token punctuation">]</span>
    cssclass_month_head <span class="token operator">=</span> <span class="token string">"text-center month-head"</span>
    cssclass_month <span class="token operator">=</span> <span class="token string">"text-center month"</span>
    cssclass_year <span class="token operator">=</span> <span class="token string">"text-italic lead"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><em>class</em> <code>calendar.LocaleTextCalendar</code>(<em>firstweekday=0</em>, <em>locale=None</em>)</p>
<p>这个子类 <code>TextCalendar</code> 可以在构造函数中传递一个语言环境名称，并且返回月份和星期几的名称在特定语言环境中。如果此语言环境包含编码，则包含月份和工作日名称的所有字符串将作为 unicode 返回。</p>
<p><em>class</em> <code>calendar.LocaleHTMLCalendar</code>(<em>firstweekday=0</em>, <em>locale=None</em>)</p>
<p>This subclass of <code>HTMLCalendar</code> can be passed a locale name in the constructor and will return month and weekday names in the specified locale. If this locale includes an encoding all strings containing month and weekday names will be returned as unicode.</p>
<p>注解</p>
<p>这两个类的 <code>formatweekday()</code> 和 <code>formatmonthname()</code> 方法临时更改dang当前区域至给定 <em>locale</em> 。由于当前的区域设置是进程范围的设置，因此它们不是线程安全的。</p>
<p>对于简单的文本日历，这个模块提供了以下方法。</p>
<p><code>calendar.setfirstweekday</code>(<em>weekday</em>)</p>
<p>设置每一周的开始(<code>0</code> 表示星期一，<code>6</code> 表示星期天)。calendar还提供了 <code>MONDAY</code>, <code>TUESDAY</code>, <code>WEDNESDAY</code>, <code>THURSDAY</code>, <code>FRIDAY</code>, <code>SATURDAY</code> 和 <code>SUNDAY</code> 几个常量方便使用。例如，设置每周的第一天为星期天</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> calendar
calendar<span class="token punctuation">.</span>setfirstweekday<span class="token punctuation">(</span>calendar<span class="token punctuation">.</span>SUNDAY<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><code>calendar.firstweekday</code>()</p>
<p>返回当前设置的每星期的第一天的数值。</p>
<p><code>calendar.isleap</code>(<em>year</em>)</p>
<p>如果 <em>year</em> 是闰年则返回 <code>True</code> ,否则返回 <code>False</code>。</p>
<p><code>calendar.leapdays</code>(<em>y1</em>, <em>y2</em>)</p>
<p>返回在范围 <em>y1</em> 至 <em>y2</em> （包含 y1 和 y2 ）之间的闰年的年数，其中 <em>y1</em> 和 <em>y2</em> 是年份。</p>
<p>此函数适用于跨越一个世纪变化的范围。</p>
<p><code>calendar.weekday</code>(<em>year</em>, <em>month</em>, <em>day</em>)</p>
<p>返回某年（ <code>1970</code> — …），某月（ <code>1</code> — <code>12</code> ），某日（ <code>1</code> — <code>31</code> ）是星期几（ <code>0</code> 是星期一）。</p>
<p><code>calendar.weekheader</code>(<em>n</em>)</p>
<p>返回一个包含星期几的缩写名的头。 <em>n</em> 指定星期几缩写的字符宽度。</p>
<p><code>calendar.monthrange</code>(<em>year</em>, <em>month</em>)</p>
<p>返回指定 <em>年份</em> 的指定 <em>月份</em> 的第一天是星期几和这个月的天数。</p>
<p><code>calendar.monthcalendar</code>(<em>year</em>, <em>month</em>)</p>
<p>返回表示一个月的日历的矩阵。 每一行代表一周；此月份外的日子由零表示。 每周从周一开始，除非使用 <code>setfirstweekday()</code> 改变设置。</p>
<p><code>calendar.prmonth</code>(<em>theyear</em>, <em>themonth</em>, <em>w=0</em>, <em>l=0</em>)</p>
<p>打印由 <code>month()</code> 返回的一个月的日历。</p>
<p><code>calendar.month</code>(<em>theyear</em>, <em>themonth</em>, <em>w=0</em>, <em>l=0</em>)</p>
<p>使用 <code>TextCalendar</code> 类的 <code>formatmonth()</code> 以多行字符串形式返回月份日历。</p>
<p><code>calendar.prcal</code>(<em>year</em>, <em>w=0</em>, <em>l=0</em>, <em>c=6</em>, <em>m=3</em>)</p>
<p>打印由 <code>calendar()</code> 返回的整年的日历。</p>
<p><code>calendar.calendar</code>(<em>year</em>, <em>w=2</em>, <em>l=1</em>, <em>c=6</em>, <em>m=3</em>)</p>
<p>使用 <code>TextCalendar</code> 类的 <code>formatyear()</code> 返回整年的3列的日历以多行字符串的形式。</p>
<p><code>calendar.timegm</code>(<em>tuple</em>)</p>
<p>一个不相关但很好用的函数，它接受一个时间元组例如 <code>time</code> 模块中的 <code>gmtime()</code> 函数的返回并返回相应的 Unix 时间戳值，假定 1970 年开始计数， POSIX 编码。实际上， <code>time.gmtime()</code> 和 <code>timegm()</code> 是彼此相反的。</p>
<p><code>calendar</code> 模块导出以下数据属性：</p>
<pre><code>calendar.day_name</code></pre><p>在当前语言环境下表示星期几的数组。</p>
<pre><code>calendar.day_abbr</code></pre><p>在当前语言环境下表示星期几缩写的数组。</p>
<pre><code>calendar.month_name</code></pre><p>在当前语言环境下表示一年中月份的数组。这遵循一月的月号为 1 的通常惯例，所以它的长度为 13 且 <code>month_name[0]</code> 是空字符串。</p>
<pre><code>calendar.month_abbr</code></pre><p>在当前语言环境下表示月份简写的数组。这遵循一月的月号为 1 的通常惯例，所以它的长度为 13 且 <code>month_abbr[0]</code> 是空字符串。</p>
<h2 id="collections-—-容器数据类型"><a href="#collections-—-容器数据类型" class="headerlink" title="collections —- 容器数据类型"></a><code>collections</code> —- 容器数据类型</h2><p><strong>Source code:</strong> <a href="https://github.com/python/cpython/tree/3.10/Lib/collections/__init__.py" target="_blank" rel="noopener">Lib/collections/<strong>init</strong>.py</a></p>
<hr>
<p>这个模块实现了特定目标的容器，以提供Python标准内建容器 <code>dict</code> , <code>list</code> , <code>set</code> , 和 <code>tuple</code> 的替代选择。</p>
<table>
<thead>
<tr>
<th><code>namedtuple()</code></th>
<th>创建命名元组子类的工厂函数</th>
</tr>
</thead>
<tbody><tr>
<td><code>deque</code></td>
<td>类似列表(list)的容器，实现了在两端快速添加(append)和弹出(pop)</td>
</tr>
<tr>
<td><code>ChainMap</code></td>
<td>类似字典(dict)的容器类，将多个映射集合到一个视图里面</td>
</tr>
<tr>
<td><code>Counter</code></td>
<td>字典的子类，提供了可哈希对象的计数功能</td>
</tr>
<tr>
<td><code>OrderedDict</code></td>
<td>字典的子类，保存了他们被添加的顺序</td>
</tr>
<tr>
<td><code>defaultdict</code></td>
<td>字典的子类，提供了一个工厂函数，为字典查询提供一个默认值</td>
</tr>
<tr>
<td><code>UserDict</code></td>
<td>封装了字典对象，简化了字典子类化</td>
</tr>
<tr>
<td><code>UserList</code></td>
<td>封装了列表对象，简化了列表子类化</td>
</tr>
<tr>
<td><code>UserString</code></td>
<td>封装了字符串对象，简化了字符串子类化</td>
</tr>
</tbody></table>
<h3 id="ChainMap-对象"><a href="#ChainMap-对象" class="headerlink" title="ChainMap 对象"></a><code>ChainMap</code> 对象</h3><p>3.3 新版功能.</p>
<p>一个 <code>ChainMap</code> 类是为了将多个映射快速的链接到一起，这样它们就可以作为一个单元处理。它通常比创建一个新字典和多次调用 <code>update()</code> 要快很多。</p>
<p>这个类可以用于模拟嵌套作用域，并且在模版化的时候比较有用。</p>
<p><em>class</em> <code>collections.ChainMap</code>(<em>\</em>maps*)</p>
<p>一个 <code>ChainMap</code> 将多个字典或者其他映射组合在一起，创建一个单独的可更新的视图。 如果没有 <em>maps</em> 被指定，就提供一个默认的空字典，这样一个新链至少有一个映射。</p>
<p>底层映射被存储在一个列表中。这个列表是公开的，可以通过 <em>maps</em> 属性存取和更新。没有其他的状态。</p>
<p>搜索查询底层映射，直到一个键被找到。不同的是，写，更新和删除只操作第一个映射。</p>
<p>一个 <code>ChainMap</code> 通过引用合并底层映射。 所以，如果一个底层映射更新了，这些更改会反映到 <code>ChainMap</code> 。</p>
<p>支持所有常用字典方法。另外还有一个 <em>maps</em> 属性(attribute)，一个创建子上下文的方法(method)， 一个存取它们首个映射的属性(property):</p>
<ul>
<li><p><code>maps</code></p>
<p>一个可以更新的映射列表。这个列表是按照第一次搜索到最后一次搜索的顺序组织的。它是仅有的存储状态，可以被修改。列表最少包含一个映射。</p>
</li>
<li><p><code>new_child</code>(<em>m=None</em>, <em>**kwargs</em>)</p>
<p>返回一个新的 <code>ChainMap</code>，其中包含一个新的映射，后面跟随当前实例中的所有映射。 如果指定了 <code>m</code>，它会成为新的映射加在映射列表的前面；如果未指定，则会使用一个空字典，因此调用 <code>d.new_child()</code> 就等价于 <code>ChainMap({}, *d.maps)</code>。 如果指定了任何关键字参数，它们会更新所传入的映射或新的空字典。 此方法被用于创建子上下文，它可在不改变任何上级映射的情况下被更新。</p>
<p>在 3.4 版更改: 添加了 <code>m</code> 可选参数。</p>
<p>在 3.10 版更改: 增加了对关键字参数的支持。</p>
</li>
<li><p><code>parents</code></p>
<p>属性返回一个新的 <code>ChainMap</code> 包含所有的当前实例的映射，除了第一个。这样可以在搜索的时候跳过第一个映射。 使用的场景类似在 nested scopes 嵌套作用域中使用 <code>nonlocal</code> 关键词。用例也可以类比内建函数 <code>super()</code> 。一个 <code>d.parents</code> 的引用等价于 <code>ChainMap(*d.maps[1:])</code> 。</p>
</li>
</ul>
<p>注意，一个 <code>ChainMap()</code> 的迭代顺序是通过从后往前扫描所有映射来确定的:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> baseline <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'music'</span><span class="token punctuation">:</span> <span class="token string">'bach'</span><span class="token punctuation">,</span> <span class="token string">'art'</span><span class="token punctuation">:</span> <span class="token string">'rembrandt'</span><span class="token punctuation">}</span>
<span class="token operator">>></span><span class="token operator">></span> adjustments <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'art'</span><span class="token punctuation">:</span> <span class="token string">'van gogh'</span><span class="token punctuation">,</span> <span class="token string">'opera'</span><span class="token punctuation">:</span> <span class="token string">'carmen'</span><span class="token punctuation">}</span>
<span class="token operator">>></span><span class="token operator">></span> list<span class="token punctuation">(</span>ChainMap<span class="token punctuation">(</span>adjustments<span class="token punctuation">,</span> baseline<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token string">'music'</span><span class="token punctuation">,</span> <span class="token string">'art'</span><span class="token punctuation">,</span> <span class="token string">'opera'</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>这给出了与 <code>dict.update()</code> 调用序列相同的顺序，从最后一个映射开始:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> combined <span class="token operator">=</span> baseline<span class="token punctuation">.</span>copy<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> combined<span class="token punctuation">.</span>update<span class="token punctuation">(</span>adjustments<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> list<span class="token punctuation">(</span>combined<span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token string">'music'</span><span class="token punctuation">,</span> <span class="token string">'art'</span><span class="token punctuation">,</span> <span class="token string">'opera'</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>在 3.9 版更改: 增加了对 <code>|</code> 和 <code>|=</code> 运算符的支持，相关说明见 <a href="https://www.python.org/dev/peps/pep-0584" target="_blank" rel="noopener"><strong>PEP 584</strong></a>。</p>
<h4 id="ChainMap-例子和方法"><a href="#ChainMap-例子和方法" class="headerlink" title="ChainMap 例子和方法"></a><code>ChainMap</code> 例子和方法</h4><p>这一节提供了多个使用链映射的案例。</p>
<p>模拟Python内部lookup链的例子</p>
<pre><code>import builtins
pylookup = ChainMap(locals(), globals(), vars(builtins))</code></pre><p>让用户指定的命令行参数优先于环境变量，优先于默认值的例子</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> os<span class="token punctuation">,</span> argparse
defaults <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'color'</span><span class="token punctuation">:</span> <span class="token string">'red'</span><span class="token punctuation">,</span> <span class="token string">'user'</span><span class="token punctuation">:</span> <span class="token string">'guest'</span><span class="token punctuation">}</span>
parser <span class="token operator">=</span> argparse<span class="token punctuation">.</span>ArgumentParser<span class="token punctuation">(</span><span class="token punctuation">)</span>
parser<span class="token punctuation">.</span>add_argument<span class="token punctuation">(</span><span class="token string">'-u'</span><span class="token punctuation">,</span> <span class="token string">'--user'</span><span class="token punctuation">)</span>
parser<span class="token punctuation">.</span>add_argument<span class="token punctuation">(</span><span class="token string">'-c'</span><span class="token punctuation">,</span> <span class="token string">'--color'</span><span class="token punctuation">)</span>
namespace <span class="token operator">=</span> parser<span class="token punctuation">.</span>parse_args<span class="token punctuation">(</span><span class="token punctuation">)</span>
command_line_args <span class="token operator">=</span> <span class="token punctuation">{</span>k<span class="token punctuation">:</span> v <span class="token keyword">for</span> k<span class="token punctuation">,</span> v <span class="token keyword">in</span> vars<span class="token punctuation">(</span>namespace<span class="token punctuation">)</span><span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">if</span> v <span class="token keyword">is</span> <span class="token operator">not</span> None<span class="token punctuation">}</span>
combined <span class="token operator">=</span> ChainMap<span class="token punctuation">(</span>command_line_args<span class="token punctuation">,</span> os<span class="token punctuation">.</span>environ<span class="token punctuation">,</span> defaults<span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>combined<span class="token punctuation">[</span><span class="token string">'color'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>combined<span class="token punctuation">[</span><span class="token string">'user'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>用 <code>ChainMap</code> 类模拟嵌套上下文的例子</p>
<pre class="line-numbers language-python"><code class="language-python">c <span class="token operator">=</span> ChainMap<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># Create root context</span>
d <span class="token operator">=</span> c<span class="token punctuation">.</span>new_child<span class="token punctuation">(</span><span class="token punctuation">)</span>     <span class="token comment" spellcheck="true"># Create nested child context</span>
e <span class="token operator">=</span> c<span class="token punctuation">.</span>new_child<span class="token punctuation">(</span><span class="token punctuation">)</span>     <span class="token comment" spellcheck="true"># Child of c, independent from d</span>
e<span class="token punctuation">.</span>maps<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>             <span class="token comment" spellcheck="true"># Current context dictionary -- like Python's locals()</span>
e<span class="token punctuation">.</span>maps<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>            <span class="token comment" spellcheck="true"># Root context -- like Python's globals()</span>
e<span class="token punctuation">.</span>parents             <span class="token comment" spellcheck="true"># Enclosing context chain -- like Python's nonlocals</span>
d<span class="token punctuation">[</span><span class="token string">'x'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>            <span class="token comment" spellcheck="true"># Set value in current context</span>
d<span class="token punctuation">[</span><span class="token string">'x'</span><span class="token punctuation">]</span>                <span class="token comment" spellcheck="true"># Get first key in the chain of contexts</span>
<span class="token keyword">del</span> d<span class="token punctuation">[</span><span class="token string">'x'</span><span class="token punctuation">]</span>            <span class="token comment" spellcheck="true"># Delete from current context</span>
list<span class="token punctuation">(</span>d<span class="token punctuation">)</span>               <span class="token comment" spellcheck="true"># All nested values</span>
k <span class="token keyword">in</span> d                <span class="token comment" spellcheck="true"># Check all nested values</span>
len<span class="token punctuation">(</span>d<span class="token punctuation">)</span>                <span class="token comment" spellcheck="true"># Number of nested values</span>
d<span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span>             <span class="token comment" spellcheck="true"># All nested items</span>
dict<span class="token punctuation">(</span>d<span class="token punctuation">)</span>               <span class="token comment" spellcheck="true"># Flatten into a regular dictionary</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>ChainMap</code> 类只更新链中的第一个映射，但lookup会搜索整个链。 然而，如果需要深度写和删除，也可以很容易的通过定义一个子类来实现它</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">DeepChainMap</span><span class="token punctuation">(</span>ChainMap<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token string">'Variant of ChainMap that allows direct updates to inner scopes'</span>
    <span class="token keyword">def</span> <span class="token function">__setitem__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">for</span> mapping <span class="token keyword">in</span> self<span class="token punctuation">.</span>maps<span class="token punctuation">:</span>
            <span class="token keyword">if</span> key <span class="token keyword">in</span> mapping<span class="token punctuation">:</span>
                mapping<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> value
                <span class="token keyword">return</span>
        self<span class="token punctuation">.</span>maps<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> value
    <span class="token keyword">def</span> <span class="token function">__delitem__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">for</span> mapping <span class="token keyword">in</span> self<span class="token punctuation">.</span>maps<span class="token punctuation">:</span>
            <span class="token keyword">if</span> key <span class="token keyword">in</span> mapping<span class="token punctuation">:</span>
                <span class="token keyword">del</span> mapping<span class="token punctuation">[</span>key<span class="token punctuation">]</span>
                <span class="token keyword">return</span>
        <span class="token keyword">raise</span> KeyError<span class="token punctuation">(</span>key<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> d <span class="token operator">=</span> DeepChainMap<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">'zebra'</span><span class="token punctuation">:</span> <span class="token string">'black'</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token string">'elephant'</span><span class="token punctuation">:</span> <span class="token string">'blue'</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token string">'lion'</span><span class="token punctuation">:</span> <span class="token string">'yellow'</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> d<span class="token punctuation">[</span><span class="token string">'lion'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'orange'</span>         <span class="token comment" spellcheck="true"># update an existing key two levels down</span>
<span class="token operator">>></span><span class="token operator">></span> d<span class="token punctuation">[</span><span class="token string">'snake'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'red'</span>           <span class="token comment" spellcheck="true"># new keys get added to the topmost dict</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">del</span> d<span class="token punctuation">[</span><span class="token string">'elephant'</span><span class="token punctuation">]</span>            <span class="token comment" spellcheck="true"># remove an existing key one level down</span>
<span class="token operator">>></span><span class="token operator">></span> d                            <span class="token comment" spellcheck="true"># display result</span>
DeepChainMap<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">'zebra'</span><span class="token punctuation">:</span> <span class="token string">'black'</span><span class="token punctuation">,</span> <span class="token string">'snake'</span><span class="token punctuation">:</span> <span class="token string">'red'</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token string">'lion'</span><span class="token punctuation">:</span> <span class="token string">'orange'</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="Counter-对象"><a href="#Counter-对象" class="headerlink" title="Counter 对象"></a><code>Counter</code> 对象</h3><p>一个计数器工具提供快速和方便的计数。比如</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token comment" spellcheck="true"># Tally occurrences of words in a list</span>
<span class="token operator">>></span><span class="token operator">></span> cnt <span class="token operator">=</span> Counter<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">for</span> word <span class="token keyword">in</span> <span class="token punctuation">[</span><span class="token string">'red'</span><span class="token punctuation">,</span> <span class="token string">'blue'</span><span class="token punctuation">,</span> <span class="token string">'red'</span><span class="token punctuation">,</span> <span class="token string">'green'</span><span class="token punctuation">,</span> <span class="token string">'blue'</span><span class="token punctuation">,</span> <span class="token string">'blue'</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     cnt<span class="token punctuation">[</span>word<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span>
<span class="token operator">>></span><span class="token operator">></span> cnt
Counter<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">'blue'</span><span class="token punctuation">:</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">'red'</span><span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">'green'</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token comment" spellcheck="true"># Find the ten most common words in Hamlet</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> re
<span class="token operator">>></span><span class="token operator">></span> words <span class="token operator">=</span> re<span class="token punctuation">.</span>findall<span class="token punctuation">(</span>r<span class="token string">'\w+'</span><span class="token punctuation">,</span> open<span class="token punctuation">(</span><span class="token string">'hamlet.txt'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>lower<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> Counter<span class="token punctuation">(</span>words<span class="token punctuation">)</span><span class="token punctuation">.</span>most_common<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token string">'the'</span><span class="token punctuation">,</span> <span class="token number">1143</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'and'</span><span class="token punctuation">,</span> <span class="token number">966</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'to'</span><span class="token punctuation">,</span> <span class="token number">762</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'of'</span><span class="token punctuation">,</span> <span class="token number">669</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'i'</span><span class="token punctuation">,</span> <span class="token number">631</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
 <span class="token punctuation">(</span><span class="token string">'you'</span><span class="token punctuation">,</span> <span class="token number">554</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token number">546</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'my'</span><span class="token punctuation">,</span> <span class="token number">514</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'hamlet'</span><span class="token punctuation">,</span> <span class="token number">471</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'in'</span><span class="token punctuation">,</span> <span class="token number">451</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><em>class</em> <code>collections.Counter</code>([<em>iterable-or-mapping</em>])</p>
<p>一个 <code>Counter</code> 是一个 <code>dict</code> 的子类，用于计数可哈希对象。它是一个集合，元素像字典键(key)一样存储，它们的计数存储为值。计数可以是任何整数值，包括0和负数。 <code>Counter</code> 类有点像其他语言中的 bags或multisets。</p>
<p>元素从一个 <em>iterable</em> 被计数或从其他的 <em>mapping</em> (or counter)初始化：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> c <span class="token operator">=</span> Counter<span class="token punctuation">(</span><span class="token punctuation">)</span>                           <span class="token comment" spellcheck="true"># a new, empty counter</span>
<span class="token operator">>></span><span class="token operator">></span> c <span class="token operator">=</span> Counter<span class="token punctuation">(</span><span class="token string">'gallahad'</span><span class="token punctuation">)</span>                 <span class="token comment" spellcheck="true"># a new counter from an iterable</span>
<span class="token operator">>></span><span class="token operator">></span> c <span class="token operator">=</span> Counter<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">'red'</span><span class="token punctuation">:</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token string">'blue'</span><span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">)</span>      <span class="token comment" spellcheck="true"># a new counter from a mapping</span>
<span class="token operator">>></span><span class="token operator">></span> c <span class="token operator">=</span> Counter<span class="token punctuation">(</span>cats<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">,</span> dogs<span class="token operator">=</span><span class="token number">8</span><span class="token punctuation">)</span>             <span class="token comment" spellcheck="true"># a new counter from keyword args</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>Counter对象有一个字典接口，如果引用的键没有任何记录，就返回一个0，而不是弹出一个 <code>KeyError</code> :</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> c <span class="token operator">=</span> Counter<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'eggs'</span><span class="token punctuation">,</span> <span class="token string">'ham'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> c<span class="token punctuation">[</span><span class="token string">'bacon'</span><span class="token punctuation">]</span>                              <span class="token comment" spellcheck="true"># count of a missing element is zero</span>
<span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>设置一个计数为0不会从计数器中移去一个元素。使用 <code>del</code> 来删除它:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> c<span class="token punctuation">[</span><span class="token string">'sausage'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>                        <span class="token comment" spellcheck="true"># counter entry with a zero count</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">del</span> c<span class="token punctuation">[</span><span class="token string">'sausage'</span><span class="token punctuation">]</span>                        <span class="token comment" spellcheck="true"># del actually removes the entry</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>3.1 新版功能.</p>
<p>在 3.7 版更改: 作为 <code>dict</code> 的子类，<code>Counter</code> 继承了记住插入顺序的功能。 <em>Counter</em> 对象进行数学运算时同样会保持顺序。 结果会先按每个元素在运算符左边的出现时间排序，然后再按其在运算符右边的出现时间排序。</p>
<p>计数器对象除了字典方法以外，还提供了三个其他的方法：</p>
<ul>
<li><p><code>elements</code>()</p>
<p>返回一个迭代器，其中每个元素将重复出现计数值所指定次。 元素会按首次出现的顺序返回。 如果一个元素的计数值小于一，<code>elements()</code> 将会忽略它。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> c <span class="token operator">=</span> Counter<span class="token punctuation">(</span>a<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">,</span> b<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span> c<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> d<span class="token operator">=</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> sorted<span class="token punctuation">(</span>c<span class="token punctuation">.</span>elements<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><code>most_common</code>([<em>n</em>])</p>
<p>返回一个列表，其中包含 <em>n</em> 个最常见的元素及出现次数，按常见程度由高到低排序。 如果 <em>n</em> 被省略或为 <code>None</code>，<code>most_common()</code> 将返回计数器中的 <em>所有</em> 元素。 计数值相等的元素按首次出现的顺序排序：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> Counter<span class="token punctuation">(</span><span class="token string">'abracadabra'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>most_common<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'r'</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li><p><code>subtract</code>([<em>iterable-or-mapping</em>])</p>
<p>从 <em>迭代对象</em> 或 <em>映射对象</em> 减去元素。像 <code>dict.update()</code> 但是是减去，而不是替换。输入和输出都可以是0或者负数。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> c <span class="token operator">=</span> Counter<span class="token punctuation">(</span>a<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">,</span> b<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span> c<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> d<span class="token operator">=</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> d <span class="token operator">=</span> Counter<span class="token punctuation">(</span>a<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> b<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span> c<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">,</span> d<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> c<span class="token punctuation">.</span>subtract<span class="token punctuation">(</span>d<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> c
Counter<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">'a'</span><span class="token punctuation">:</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">'c'</span><span class="token punctuation">:</span> <span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">'d'</span><span class="token punctuation">:</span> <span class="token operator">-</span><span class="token number">6</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>3.2 新版功能.</p>
</li>
<li><p><code>total</code>()</p>
<p>计算总计数值。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> c <span class="token operator">=</span> Counter<span class="token punctuation">(</span>a<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">,</span> b<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">,</span> c<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> c<span class="token punctuation">.</span>total<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token number">15</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>3.10 新版功能.</p>
</li>
</ul>
<p>通常字典方法都可用于 <code>Counter</code> 对象，除了有两个方法工作方式与字典并不相同。</p>
<ul>
<li><p><code>fromkeys</code>(<em>iterable</em>)</p>
<p>这个类方法没有在 <code>Counter</code> 中实现。</p>
</li>
<li><p><code>update</code>([<em>iterable-or-mapping</em>])</p>
<p>从 <em>迭代对象</em> 计数元素或者 从另一个 <em>映射对象</em> (或计数器) 添加。 像 <code>dict.update()</code> 但是是加上，而不是替换。另外，<em>迭代对象</em> 应该是序列元素，而不是一个 <code>(key, value)</code> 对。</p>
</li>
</ul>
<p>计数对象支持相等性、子集和超集关系等富比较运算符: <code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code>。 所有这些检测会将不存在的元素当作计数值为零，因此 <code>Counter(a=1) == Counter(a=1, b=0)</code> 将返回真值。</p>
<p>3.10 新版功能: 增加了富比较运算</p>
<p>在 3.10 版更改: 在相等性检测中，不存在的元素会被当作计数值为零。 在此之前，<code>Counter(a=3)</code> 和 <code>Counter(a=3, b=0)</code> 会被视为不同。</p>
<p><code>Counter</code> 对象的常用案例</p>
<pre class="line-numbers language-python"><code class="language-python">c<span class="token punctuation">.</span>total<span class="token punctuation">(</span><span class="token punctuation">)</span>                       <span class="token comment" spellcheck="true"># total of all counts</span>
c<span class="token punctuation">.</span>clear<span class="token punctuation">(</span><span class="token punctuation">)</span>                       <span class="token comment" spellcheck="true"># reset all counts</span>
list<span class="token punctuation">(</span>c<span class="token punctuation">)</span>                         <span class="token comment" spellcheck="true"># list unique elements</span>
set<span class="token punctuation">(</span>c<span class="token punctuation">)</span>                          <span class="token comment" spellcheck="true"># convert to a set</span>
dict<span class="token punctuation">(</span>c<span class="token punctuation">)</span>                         <span class="token comment" spellcheck="true"># convert to a regular dictionary</span>
c<span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span>                       <span class="token comment" spellcheck="true"># convert to a list of (elem, cnt) pairs</span>
Counter<span class="token punctuation">(</span>dict<span class="token punctuation">(</span>list_of_pairs<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># convert from a list of (elem, cnt) pairs</span>
c<span class="token punctuation">.</span>most_common<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token operator">-</span>n<span class="token number">-1</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>       <span class="token comment" spellcheck="true"># n least common elements</span>
<span class="token operator">+</span>c                              <span class="token comment" spellcheck="true"># remove zero and negative counts</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>提供了几个数学操作，可以结合 <code>Counter</code> 对象，以生产 multisets (计数器中大于0的元素）。 加和减，结合计数器，通过加上或者减去元素的相应计数。交集和并集返回相应计数的最小或最大值。每种操作都可以接受带符号的计数，但是输出会忽略掉结果为零或者小于零的计数。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> c <span class="token operator">=</span> Counter<span class="token punctuation">(</span>a<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">,</span> b<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> d <span class="token operator">=</span> Counter<span class="token punctuation">(</span>a<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> b<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> c <span class="token operator">+</span> d                       <span class="token comment" spellcheck="true"># add two counters together:  c[x] + d[x]</span>
Counter<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">'a'</span><span class="token punctuation">:</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">:</span> <span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> c <span class="token operator">-</span> d                       <span class="token comment" spellcheck="true"># subtract (keeping only positive counts)</span>
Counter<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">'a'</span><span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> c <span class="token operator">&amp;</span> d                       <span class="token comment" spellcheck="true"># intersection:  min(c[x], d[x]) </span>
Counter<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">'a'</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> c <span class="token operator">|</span> d                       <span class="token comment" spellcheck="true"># union:  max(c[x], d[x])</span>
Counter<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">'a'</span><span class="token punctuation">:</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>单目加和减（一元操作符）意思是从空计数器加或者减去。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> c <span class="token operator">=</span> Counter<span class="token punctuation">(</span>a<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span> b<span class="token operator">=</span><span class="token operator">-</span><span class="token number">4</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token operator">+</span>c
Counter<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">'a'</span><span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token operator">-</span>c
Counter<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">'b'</span><span class="token punctuation">:</span> <span class="token number">4</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>3.3 新版功能: 添加了对一元加，一元减和位置集合操作的支持。</p>
<p>注解</p>
<p>计数器主要是为了表达运行的正的计数而设计；但是，小心不要预先排除负数或者其他类型。为了帮助这些用例，这一节记录了最小范围和类型限制。</p>
<ul>
<li><code>Counter</code> 类是一个字典的子类，不限制键和值。值用于表示计数，但你实际上 <em>可以</em> 存储任何其他值。</li>
<li><code>most_common()</code> 方法在值需要排序的时候用。</li>
<li>原地操作比如 <code>c[key] += 1</code> ， 值类型只需要支持加和减。 所以分数，小数，和十进制都可以用，负值也可以支持。这两个方法 <code>update()</code> 和 <code>subtract()</code> 的输入和输出也一样支持负数和0。</li>
<li>Multiset多集合方法只为正值的使用情况设计。输入可以是负数或者0，但只输出计数为正的值。没有类型限制，但值类型需要支持加，减和比较操作。</li>
<li><code>elements()</code> 方法要求正整数计数。忽略0和负数计数。</li>
</ul>
<h3 id="deque-对象"><a href="#deque-对象" class="headerlink" title="deque 对象"></a><code>deque</code> 对象</h3><p><em>class</em> <code>collections.deque</code>([<em>iterable</em>[, <em>maxlen</em>]])</p>
<p>返回一个新的双向队列对象，从左到右初始化(用方法 <code>append()</code>) ，从 <em>iterable</em> （迭代对象) 数据创建。如果 <em>iterable</em> 没有指定，新队列为空。</p>
<p>Deque队列是由栈或者queue队列生成的（发音是 “deck”，”double-ended queue”的简称）。Deque 支持线程安全，内存高效添加(append)和弹出(pop)，从两端都可以，两个方向的大概开销都是 O(1) 复杂度。</p>
<p>虽然 <code>list</code> 对象也支持类似操作，不过这里优化了定长操作和 <code>pop(0)</code> 和 <code>insert(0, v)</code> 的开销。它们引起 O(n) 内存移动的操作，改变底层数据表达的大小和位置。</p>
<p>如果 <em>maxlen</em> 没有指定或者是 <code>None</code> ，deques 可以增长到任意长度。否则，deque就限定到指定最大长度。一旦限定长度的deque满了，当新项加入时，同样数量的项就从另一端弹出。限定长度deque提供类似Unix filter <code>tail</code> 的功能。它们同样可以用与追踪最近的交换和其他数据池活动。</p>
<p>双向队列(deque)对象支持以下方法：</p>
<ul>
<li><p><code>append</code>(<em>x</em>)</p>
<p>添加 <em>x</em> 到右端。</p>
</li>
<li><p><code>appendleft</code>(<em>x</em>)</p>
<p>添加 <em>x</em> 到左端。</p>
</li>
<li><p><code>clear</code>()</p>
<p>移除所有元素，使其长度为0.</p>
</li>
<li><p><code>copy</code>()</p>
<p>创建一份浅拷贝。</p>
<p>3.5 新版功能.</p>
</li>
<li><p><code>count</code>(<em>x</em>)</p>
<p>计算 deque 中元素等于 <em>x</em> 的个数。</p>
<p>3.2 新版功能.</p>
</li>
<li><p><code>extend</code>(<em>iterable</em>)</p>
<p>扩展deque的右侧，通过添加iterable参数中的元素。</p>
</li>
<li><p><code>extendleft</code>(<em>iterable</em>)</p>
<p>扩展deque的左侧，通过添加iterable参数中的元素。注意，左添加时，在结果中iterable参数中的顺序将被反过来添加。</p>
</li>
<li><p><code>index</code>(<em>x</em>[, <em>start</em>[, <em>stop</em>]])</p>
<p>返回 <em>x</em> 在 deque 中的位置（在索引 <em>start</em> 之后，索引 <em>stop</em> 之前）。 返回第一个匹配项，如果未找到则引发 <code>ValueError</code>。</p>
<p>3.5 新版功能.</p>
</li>
<li><p><code>insert</code>(<em>i</em>, <em>x</em>)</p>
<p>在位置 <em>i</em> 插入 <em>x</em> 。</p>
<p>如果插入会导致一个限长 deque 超出长度 <em>maxlen</em> 的话，就引发一个 <code>IndexError</code>。</p>
<p>3.5 新版功能.</p>
</li>
<li><p><code>pop</code>()</p>
<p>移去并且返回一个元素，deque 最右侧的那一个。 如果没有元素的话，就引发一个 <code>IndexError</code>。</p>
</li>
<li><p><code>popleft</code>()</p>
<p>移去并且返回一个元素，deque 最左侧的那一个。 如果没有元素的话，就引发 <code>IndexError</code>。</p>
</li>
<li><p><code>remove</code>(<em>value</em>)</p>
<p>移除找到的第一个 <em>value</em>。 如果没有的话就引发 <code>ValueError</code>。</p>
</li>
<li><p><code>reverse</code>()</p>
<p>将deque逆序排列。返回 <code>None</code> 。</p>
<p>3.2 新版功能.</p>
</li>
<li><p><code>rotate</code>(<em>n=1</em>)</p>
<p>向右循环移动 <em>n</em> 步。 如果 <em>n</em> 是负数，就向左循环。</p>
<p>如果deque不是空的，向右循环移动一步就等价于 <code>d.appendleft(d.pop())</code> ， 向左循环一步就等价于 <code>d.append(d.popleft())</code> 。</p>
</li>
</ul>
<p>Deque对象同样提供了一个只读属性:</p>
<ul>
<li><p><code>maxlen</code></p>
<p>Deque的最大尺寸，如果没有限定的话就是 <code>None</code> 。</p>
<p>3.1 新版功能.</p>
</li>
</ul>
<p>除了以上操作，deque 还支持迭代、封存、<code>len(d)</code>、<code>reversed(d)</code>、<code>copy.copy(d)</code>、<code>copy.deepcopy(d)</code>、成员检测运算符 <a href="https://www.bookstack.cn/read/python-3.10.0-zh/65eb63967e3f016e.md#in" target="_blank" rel="noopener"><code>in</code></a> 以及下标引用例如通过 <code>d[0]</code> 访问首个元素等。 索引访问在两端的复杂度均为 O(1) 但在中间则会低至 O(n)。 如需快速随机访问，请改用列表。</p>
<p>Deque从版本3.5开始支持 <code>__add__()</code>, <code>__mul__()</code>, 和 <code>__imul__()</code> 。</p>
<p>示例:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> collections <span class="token keyword">import</span> deque
<span class="token operator">>></span><span class="token operator">></span> d <span class="token operator">=</span> deque<span class="token punctuation">(</span><span class="token string">'ghi'</span><span class="token punctuation">)</span>                 <span class="token comment" spellcheck="true"># make a new deque with three items</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">for</span> elem <span class="token keyword">in</span> d<span class="token punctuation">:</span>                   <span class="token comment" spellcheck="true"># iterate over the deque's elements</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">print</span><span class="token punctuation">(</span>elem<span class="token punctuation">.</span>upper<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
G
H
I
<span class="token operator">>></span><span class="token operator">></span> d<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token string">'j'</span><span class="token punctuation">)</span>                    <span class="token comment" spellcheck="true"># add a new entry to the right side</span>
<span class="token operator">>></span><span class="token operator">></span> d<span class="token punctuation">.</span>appendleft<span class="token punctuation">(</span><span class="token string">'f'</span><span class="token punctuation">)</span>                <span class="token comment" spellcheck="true"># add a new entry to the left side</span>
<span class="token operator">>></span><span class="token operator">></span> d                                <span class="token comment" spellcheck="true"># show the representation of the deque</span>
deque<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'f'</span><span class="token punctuation">,</span> <span class="token string">'g'</span><span class="token punctuation">,</span> <span class="token string">'h'</span><span class="token punctuation">,</span> <span class="token string">'i'</span><span class="token punctuation">,</span> <span class="token string">'j'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> d<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>                          <span class="token comment" spellcheck="true"># return and remove the rightmost item</span>
<span class="token string">'j'</span>
<span class="token operator">>></span><span class="token operator">></span> d<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>                      <span class="token comment" spellcheck="true"># return and remove the leftmost item</span>
<span class="token string">'f'</span>
<span class="token operator">>></span><span class="token operator">></span> list<span class="token punctuation">(</span>d<span class="token punctuation">)</span>                          <span class="token comment" spellcheck="true"># list the contents of the deque</span>
<span class="token punctuation">[</span><span class="token string">'g'</span><span class="token punctuation">,</span> <span class="token string">'h'</span><span class="token punctuation">,</span> <span class="token string">'i'</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> d<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>                             <span class="token comment" spellcheck="true"># peek at leftmost item</span>
<span class="token string">'g'</span>
<span class="token operator">>></span><span class="token operator">></span> d<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>                            <span class="token comment" spellcheck="true"># peek at rightmost item</span>
<span class="token string">'i'</span>
<span class="token operator">>></span><span class="token operator">></span> list<span class="token punctuation">(</span>reversed<span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token comment" spellcheck="true"># list the contents of a deque in reverse</span>
<span class="token punctuation">[</span><span class="token string">'i'</span><span class="token punctuation">,</span> <span class="token string">'h'</span><span class="token punctuation">,</span> <span class="token string">'g'</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token string">'h'</span> <span class="token keyword">in</span> d                         <span class="token comment" spellcheck="true"># search the deque</span>
<span class="token boolean">True</span>
<span class="token operator">>></span><span class="token operator">></span> d<span class="token punctuation">.</span>extend<span class="token punctuation">(</span><span class="token string">'jkl'</span><span class="token punctuation">)</span>                  <span class="token comment" spellcheck="true"># add multiple elements at once</span>
<span class="token operator">>></span><span class="token operator">></span> d
deque<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'g'</span><span class="token punctuation">,</span> <span class="token string">'h'</span><span class="token punctuation">,</span> <span class="token string">'i'</span><span class="token punctuation">,</span> <span class="token string">'j'</span><span class="token punctuation">,</span> <span class="token string">'k'</span><span class="token punctuation">,</span> <span class="token string">'l'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> d<span class="token punctuation">.</span>rotate<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>                      <span class="token comment" spellcheck="true"># right rotation</span>
<span class="token operator">>></span><span class="token operator">></span> d
deque<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'l'</span><span class="token punctuation">,</span> <span class="token string">'g'</span><span class="token punctuation">,</span> <span class="token string">'h'</span><span class="token punctuation">,</span> <span class="token string">'i'</span><span class="token punctuation">,</span> <span class="token string">'j'</span><span class="token punctuation">,</span> <span class="token string">'k'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> d<span class="token punctuation">.</span>rotate<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>                     <span class="token comment" spellcheck="true"># left rotation</span>
<span class="token operator">>></span><span class="token operator">></span> d
deque<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'g'</span><span class="token punctuation">,</span> <span class="token string">'h'</span><span class="token punctuation">,</span> <span class="token string">'i'</span><span class="token punctuation">,</span> <span class="token string">'j'</span><span class="token punctuation">,</span> <span class="token string">'k'</span><span class="token punctuation">,</span> <span class="token string">'l'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> deque<span class="token punctuation">(</span>reversed<span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">)</span>               <span class="token comment" spellcheck="true"># make a new deque in reverse order</span>
deque<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'l'</span><span class="token punctuation">,</span> <span class="token string">'k'</span><span class="token punctuation">,</span> <span class="token string">'j'</span><span class="token punctuation">,</span> <span class="token string">'i'</span><span class="token punctuation">,</span> <span class="token string">'h'</span><span class="token punctuation">,</span> <span class="token string">'g'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> d<span class="token punctuation">.</span>clear<span class="token punctuation">(</span><span class="token punctuation">)</span>                        <span class="token comment" spellcheck="true"># empty the deque</span>
<span class="token operator">>></span><span class="token operator">></span> d<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>                          <span class="token comment" spellcheck="true"># cannot pop from an empty deque</span>
Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>
    File <span class="token string">"&lt;pyshell#6>"</span><span class="token punctuation">,</span> line <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">in</span> <span class="token operator">-</span>toplevel<span class="token operator">-</span>
        d<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>
IndexError<span class="token punctuation">:</span> pop <span class="token keyword">from</span> an empty deque
<span class="token operator">>></span><span class="token operator">></span> d<span class="token punctuation">.</span>extendleft<span class="token punctuation">(</span><span class="token string">'abc'</span><span class="token punctuation">)</span>              <span class="token comment" spellcheck="true"># extendleft() reverses the input order</span>
<span class="token operator">>></span><span class="token operator">></span> d
deque<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'c'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token string">'a'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="deque-用法"><a href="#deque-用法" class="headerlink" title="deque 用法"></a><code>deque</code> 用法</h4><p>这一节展示了deque的多种用法。</p>
<p>限长deque提供了类似Unix <code>tail</code> 过滤功能</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">tail</span><span class="token punctuation">(</span>filename<span class="token punctuation">,</span> n<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token string">'Return the last n lines of a file'</span>
    <span class="token keyword">with</span> open<span class="token punctuation">(</span>filename<span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span>
        <span class="token keyword">return</span> deque<span class="token punctuation">(</span>f<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>另一个用法是维护一个近期添加元素的序列，通过从右边添加和从左边弹出</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">moving_average</span><span class="token punctuation">(</span>iterable<span class="token punctuation">,</span> n<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token comment" spellcheck="true"># moving_average([40, 30, 50, 46, 39, 44]) --> 40.0 42.0 45.0 43.0</span>
    <span class="token comment" spellcheck="true"># http://en.wikipedia.org/wiki/Moving_average</span>
    it <span class="token operator">=</span> iter<span class="token punctuation">(</span>iterable<span class="token punctuation">)</span>
    d <span class="token operator">=</span> deque<span class="token punctuation">(</span>itertools<span class="token punctuation">.</span>islice<span class="token punctuation">(</span>it<span class="token punctuation">,</span> n<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    d<span class="token punctuation">.</span>appendleft<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
    s <span class="token operator">=</span> sum<span class="token punctuation">(</span>d<span class="token punctuation">)</span>
    <span class="token keyword">for</span> elem <span class="token keyword">in</span> it<span class="token punctuation">:</span>
        s <span class="token operator">+=</span> elem <span class="token operator">-</span> d<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>
        d<span class="token punctuation">.</span>append<span class="token punctuation">(</span>elem<span class="token punctuation">)</span>
        <span class="token keyword">yield</span> s <span class="token operator">/</span> n<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>一个 轮询调度器 可以通过在 <code>deque</code> 中放入迭代器来实现。值从当前迭代器的位置0被取出并暂存(yield)。 如果这个迭代器消耗完毕，就用 <code>popleft()</code> 将其从对列中移去；否则，就通过 <code>rotate()</code> 将它移到队列的末尾</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">roundrobin</span><span class="token punctuation">(</span><span class="token operator">*</span>iterables<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token string">"roundrobin('ABC', 'D', 'EF') --> A D E B F C"</span>
    iterators <span class="token operator">=</span> deque<span class="token punctuation">(</span>map<span class="token punctuation">(</span>iter<span class="token punctuation">,</span> iterables<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">while</span> iterators<span class="token punctuation">:</span>
        <span class="token keyword">try</span><span class="token punctuation">:</span>
            <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>
                <span class="token keyword">yield</span> next<span class="token punctuation">(</span>iterators<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
                iterators<span class="token punctuation">.</span>rotate<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
        <span class="token keyword">except</span> StopIteration<span class="token punctuation">:</span>
            <span class="token comment" spellcheck="true"># Remove an exhausted iterator.</span>
            iterators<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>rotate()</code> 方法提供了一种方式来实现 <code>deque</code> 切片和删除。 例如， 一个纯的Python <code>del d[n]</code> 实现依赖于 <code>rotate()</code> 来定位要弹出的元素</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">delete_nth</span><span class="token punctuation">(</span>d<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>
    d<span class="token punctuation">.</span>rotate<span class="token punctuation">(</span><span class="token operator">-</span>n<span class="token punctuation">)</span>
    d<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>
    d<span class="token punctuation">.</span>rotate<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>要实现 <code>deque</code> 切片， 使用一个类似的方法，应用 <code>rotate()</code> 将目标元素放到左边。通过 <code>popleft()</code> 移去老的条目（entries），通过 <code>extend()</code> 添加新的条目， 然后反向 rotate。这个方法可以最小代价实现命令式的栈操作，诸如 <code>dup</code>, <code>drop</code>, <code>swap</code>, <code>over</code>, <code>pick</code>, <code>rot</code>, 和 <code>roll</code> 。</p>
<h3 id="defaultdict-对象"><a href="#defaultdict-对象" class="headerlink" title="defaultdict 对象"></a><code>defaultdict</code> 对象</h3><p><em>class</em> <code>collections.defaultdict</code>(<em>default_factory=None</em>, <em>/</em>[, <em>…</em>])</p>
<p>返回一个新的类似字典的对象。 <code>defaultdict</code> 是内置 <code>dict</code> 类的子类。 它重载了一个方法并添加了一个可写的实例变量。 其余的功能与 <code>dict</code> 类相同因而不在此文档中写明。</p>
<p>本对象包含一个名为 <code>default_factory</code> 的属性，构造时，第一个参数用于为该属性提供初始值，默认为 <code>None</code>。所有其他参数（包括关键字参数）都相当于传递给 <code>dict</code> 的构造函数。</p>
<p><code>defaultdict</code> 对象除了支持标准 <code>dict</code> 的操作，还支持以下方法作为扩展：</p>
<ul>
<li><p><code>__missing__</code>(<em>key</em>)</p>
<p>如果 <code>default_factory</code> 属性为 <code>None</code>，则调用本方法会抛出 <code>KeyError</code> 异常，附带参数 <em>key</em>。</p>
<p>如果 <code>default_factory</code> 不为 <code>None</code>，则它会被（不带参数地）调用来为 <em>key</em> 提供一个默认值，这个值和 <em>key</em> 作为一对键值对被插入到字典中，并作为本方法的返回值返回。</p>
<p>如果调用 <code>default_factory</code> 时抛出了异常，这个异常会原封不动地向外层传递。</p>
<p>在无法找到所需键值时，本方法会被 <code>dict</code> 中的 <code>__getitem__()</code> 方法调用。无论本方法返回了值还是抛出了异常，都会被 <code>__getitem__()</code> 传递。</p>
<p>注意，<code>__missing__()</code> <em>不会</em> 被 <code>__getitem__()</code> 以外的其他方法调用。意味着 <code>get()</code> 会像正常的 dict 那样返回 <code>None</code>，而不是使用 <code>default_factory</code>。</p>
</li>
</ul>
<p><code>defaultdict</code> 对象支持以下实例变量：</p>
<ul>
<li><p><code>default_factory</code></p>
<p>本属性由 <code>__missing__()</code> 方法来调用。如果构造对象时提供了第一个参数，则本属性会被初始化成那个参数，如果未提供第一个参数，则本属性为 <code>None</code>。</p>
</li>
</ul>
<p>在 3.9 版更改: 增加了合并 (<code>|</code>) 与更新 (<code>|=</code>) 运算符，相关说明见 <a href="https://www.python.org/dev/peps/pep-0584" target="_blank" rel="noopener"><strong>PEP 584</strong></a>。</p>
<h4 id="defaultdict-例子"><a href="#defaultdict-例子" class="headerlink" title="defaultdict 例子"></a><code>defaultdict</code> 例子</h4><p>使用 <code>list</code> 作为 <code>default_factory</code>，很轻松地将（键-值对组成的）序列转换为（键-列表组成的）字典：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> s <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token string">'yellow'</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'blue'</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'yellow'</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'blue'</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'red'</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> d <span class="token operator">=</span> defaultdict<span class="token punctuation">(</span>list<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">for</span> k<span class="token punctuation">,</span> v <span class="token keyword">in</span> s<span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     d<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span>v<span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> sorted<span class="token punctuation">(</span>d<span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token string">'blue'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'red'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'yellow'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>当每个键第一次遇见时，它还没有在字典里面，所以自动创建该条目，即调用 <code>default_factory</code> 方法，返回一个空的 <code>list</code>。 <code>list.append()</code> 操作添加值到这个新的列表里。当再次存取该键时，就正常操作，<code>list.append()</code> 添加另一个值到列表中。这个计数比它的等价方法 <code>dict.setdefault()</code> 要快速和简单：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> d <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">for</span> k<span class="token punctuation">,</span> v <span class="token keyword">in</span> s<span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     d<span class="token punctuation">.</span>setdefault<span class="token punctuation">(</span>k<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span>v<span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> sorted<span class="token punctuation">(</span>d<span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token string">'blue'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'red'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'yellow'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>设置 <code>default_factory</code> 为 <code>int</code>，使 <code>defaultdict</code> 用于计数（类似其他语言中的 bag 或 multiset）：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> s <span class="token operator">=</span> <span class="token string">'mississippi'</span>
<span class="token operator">>></span><span class="token operator">></span> d <span class="token operator">=</span> defaultdict<span class="token punctuation">(</span>int<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">for</span> k <span class="token keyword">in</span> s<span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     d<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> sorted<span class="token punctuation">(</span>d<span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token string">'i'</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'m'</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'p'</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'s'</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>当一个字母首次遇到时，它会查询失败，则 <code>default_factory</code> 会调用 <code>int()</code> 来提供一个整数 0 作为默认值。后续的自增操作建立起对每个字母的计数。</p>
<p>函数 <code>int()</code> 总是返回 0，这是常数函数的特殊情况。一个更快和灵活的方法是使用 lambda 函数，可以提供任何常量值（不只是0）：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">def</span> <span class="token function">constant_factory</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">return</span> <span class="token keyword">lambda</span><span class="token punctuation">:</span> value
<span class="token operator">>></span><span class="token operator">></span> d <span class="token operator">=</span> defaultdict<span class="token punctuation">(</span>constant_factory<span class="token punctuation">(</span><span class="token string">'&lt;missing>'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> d<span class="token punctuation">.</span>update<span class="token punctuation">(</span>name<span class="token operator">=</span><span class="token string">'John'</span><span class="token punctuation">,</span> action<span class="token operator">=</span><span class="token string">'ran'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token string">'%(name)s %(action)s to %(object)s'</span> <span class="token operator">%</span> d
<span class="token string">'John ran to &lt;missing>'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>设置 <code>default_factory</code> 为 <code>set</code> 使 <code>defaultdict</code> 用于构建 set 集合：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> s <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token string">'red'</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'blue'</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'red'</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'blue'</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'red'</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'blue'</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> d <span class="token operator">=</span> defaultdict<span class="token punctuation">(</span>set<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">for</span> k<span class="token punctuation">,</span> v <span class="token keyword">in</span> s<span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     d<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>add<span class="token punctuation">(</span>v<span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> sorted<span class="token punctuation">(</span>d<span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token string">'blue'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'red'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="namedtuple-命名元组的工厂函数"><a href="#namedtuple-命名元组的工厂函数" class="headerlink" title="namedtuple() 命名元组的工厂函数"></a><code>namedtuple()</code> 命名元组的工厂函数</h3><p>命名元组赋予每个位置一个含义，提供可读性和自文档性。它们可以用于任何普通元组，并添加了通过名字获取值的能力，通过索引值也是可以的。</p>
<p><code>collections.namedtuple</code>(<em>typename</em>, <em>field_names</em>, <em>**,</em> rename=False<em>,</em> defaults=None<em>,</em> module=None*)</p>
<p>返回一个新的元组子类，名为 <em>typename</em> 。这个新的子类用于创建类元组的对象，可以通过字段名来获取属性值，同样也可以通过索引和迭代获取值。子类实例同样有文档字符串（类名和字段名）另外一个有用的 <code>__repr__()</code> 方法，以 <code>name=value</code> 格式列明了元组内容。</p>
<p><em>field_names</em> 是一个像 <code>[‘x’, ‘y’]</code> 一样的字符串序列。另外 <em>field_names</em> 可以是一个纯字符串，用空白或逗号分隔开元素名，比如 <code>'x y'</code> 或者 <code>'x, y'</code> 。</p>
<p>任何有效的Python 标识符都可以作为字段名，除了下划线开头的那些。有效标识符由字母，数字，下划线组成，但首字母不能是数字或下划线，另外不能是关键词 <code>keyword</code> 比如 <em>class</em>, <em>for</em>, <em>return</em>, <em>global</em>, <em>pass</em>, 或 <em>raise</em> 。</p>
<p>如果 <em>rename</em> 为真， 无效字段名会自动转换成位置名。比如 <code>['abc', 'def', 'ghi', 'abc']</code> 转换成 <code>['abc', '_1', 'ghi', '_3']</code> ， 消除关键词 <code>def</code> 和重复字段名 <code>abc</code> 。</p>
<p><em>defaults</em> 可以为 <code>None</code> 或者是一个默认值的 iterable 。如果一个默认值域必须跟其他没有默认值的域在一起出现，<em>defaults</em> 就应用到最右边的参数。比如如果域名 <code>['x', 'y', 'z']</code> 和默认值 <code>(1, 2)</code> ，那么 <code>x</code> 就必须指定一个参数值 ，<code>y</code> 默认值 <code>1</code> ， <code>z</code> 默认值 <code>2</code> 。</p>
<p>如果 <em>module</em> 值有定义，命名元组的 <code>__module__</code> 属性值就被设置。</p>
<p>命名元组实例没有字典，所以它们要更轻量，并且占用更小内存。</p>
<p>要支持封存操作，应当将命名元组类赋值给一个匹配 <em>typename</em> 的变量。</p>
<p>在 3.1 版更改: 添加了对 <em>rename</em> 的支持。</p>
<p>在 3.6 版更改: <em>verbose</em> 和 <em>rename</em> 参数成为 仅限关键字参数.</p>
<p>在 3.6 版更改: 添加了 <em>module</em> 参数。</p>
<p>在 3.7 版更改: 移除了 <em>verbose</em> 形参和 <code>_source</code> 属性。</p>
<p>在 3.7 版更改: 添加了 <em>defaults</em> 参数和 <code>_field_defaults</code> 属性。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token comment" spellcheck="true"># Basic example</span>
<span class="token operator">>></span><span class="token operator">></span> Point <span class="token operator">=</span> namedtuple<span class="token punctuation">(</span><span class="token string">'Point'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'x'</span><span class="token punctuation">,</span> <span class="token string">'y'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p <span class="token operator">=</span> Point<span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">,</span> y<span class="token operator">=</span><span class="token number">22</span><span class="token punctuation">)</span>     <span class="token comment" spellcheck="true"># instantiate with positional or keyword arguments</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+</span> p<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>             <span class="token comment" spellcheck="true"># indexable like the plain tuple (11, 22)</span>
<span class="token number">33</span>
<span class="token operator">>></span><span class="token operator">></span> x<span class="token punctuation">,</span> y <span class="token operator">=</span> p                <span class="token comment" spellcheck="true"># unpack like a regular tuple</span>
<span class="token operator">>></span><span class="token operator">></span> x<span class="token punctuation">,</span> y
<span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">22</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>x <span class="token operator">+</span> p<span class="token punctuation">.</span>y               <span class="token comment" spellcheck="true"># fields also accessible by name</span>
<span class="token number">33</span>
<span class="token operator">>></span><span class="token operator">></span> p                       <span class="token comment" spellcheck="true"># readable __repr__ with a name=value style</span>
Point<span class="token punctuation">(</span>x<span class="token operator">=</span><span class="token number">11</span><span class="token punctuation">,</span> y<span class="token operator">=</span><span class="token number">22</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>命名元组尤其有用于赋值 <code>csv</code> <code>sqlite3</code> 模块返回的元组</p>
<pre class="line-numbers language-python"><code class="language-python">EmployeeRecord <span class="token operator">=</span> namedtuple<span class="token punctuation">(</span><span class="token string">'EmployeeRecord'</span><span class="token punctuation">,</span> <span class="token string">'name, age, title, department, paygrade'</span><span class="token punctuation">)</span>
<span class="token keyword">import</span> csv
<span class="token keyword">for</span> emp <span class="token keyword">in</span> map<span class="token punctuation">(</span>EmployeeRecord<span class="token punctuation">.</span>_make<span class="token punctuation">,</span> csv<span class="token punctuation">.</span>reader<span class="token punctuation">(</span>open<span class="token punctuation">(</span><span class="token string">"employees.csv"</span><span class="token punctuation">,</span> <span class="token string">"rb"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>emp<span class="token punctuation">.</span>name<span class="token punctuation">,</span> emp<span class="token punctuation">.</span>title<span class="token punctuation">)</span>
<span class="token keyword">import</span> sqlite3
conn <span class="token operator">=</span> sqlite3<span class="token punctuation">.</span>connect<span class="token punctuation">(</span><span class="token string">'/companydata'</span><span class="token punctuation">)</span>
cursor <span class="token operator">=</span> conn<span class="token punctuation">.</span>cursor<span class="token punctuation">(</span><span class="token punctuation">)</span>
cursor<span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token string">'SELECT name, age, title, department, paygrade FROM employees'</span><span class="token punctuation">)</span>
<span class="token keyword">for</span> emp <span class="token keyword">in</span> map<span class="token punctuation">(</span>EmployeeRecord<span class="token punctuation">.</span>_make<span class="token punctuation">,</span> cursor<span class="token punctuation">.</span>fetchall<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>emp<span class="token punctuation">.</span>name<span class="token punctuation">,</span> emp<span class="token punctuation">.</span>title<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>除了继承元组的方法，命名元组还支持三个额外的方法和两个属性。为了防止字段名冲突，方法和属性以下划线开始。</p>
<p><em>classmethod</em> <code>somenamedtuple._make</code>(<em>iterable</em>)</p>
<p>类方法从存在的序列或迭代实例创建一个新实例。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> t <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">22</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> Point<span class="token punctuation">.</span>_make<span class="token punctuation">(</span>t<span class="token punctuation">)</span>
Point<span class="token punctuation">(</span>x<span class="token operator">=</span><span class="token number">11</span><span class="token punctuation">,</span> y<span class="token operator">=</span><span class="token number">22</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p><code>somenamedtuple._asdict</code>()</p>
<p>返回一个新的 <code>dict</code> ，它将字段名称映射到它们对应的值：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> p <span class="token operator">=</span> Point<span class="token punctuation">(</span>x<span class="token operator">=</span><span class="token number">11</span><span class="token punctuation">,</span> y<span class="token operator">=</span><span class="token number">22</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>_asdict<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span><span class="token string">'x'</span><span class="token punctuation">:</span> <span class="token number">11</span><span class="token punctuation">,</span> <span class="token string">'y'</span><span class="token punctuation">:</span> <span class="token number">22</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>在 3.1 版更改: 返回一个 <code>OrderedDict</code> 而不是 <code>dict</code> 。</p>
<p>在 3.8 版更改: 返回一个常规 <code>dict</code> 而不是 <code>OrderedDict</code>。 因为自 Python 3.7 起，常规字典已经保证有序。 如果需要 <code>OrderedDict</code> 的额外特性，推荐的解决方案是将结果转换为需要的类型: <code>OrderedDict(nt._asdict())</code>。</p>
<p><code>somenamedtuple._replace</code>(<em>**kwargs</em>)</p>
<p>返回一个新的命名元组实例，并将指定域替换为新的值</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> p <span class="token operator">=</span> Point<span class="token punctuation">(</span>x<span class="token operator">=</span><span class="token number">11</span><span class="token punctuation">,</span> y<span class="token operator">=</span><span class="token number">22</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>_replace<span class="token punctuation">(</span>x<span class="token operator">=</span><span class="token number">33</span><span class="token punctuation">)</span>
Point<span class="token punctuation">(</span>x<span class="token operator">=</span><span class="token number">33</span><span class="token punctuation">,</span> y<span class="token operator">=</span><span class="token number">22</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">for</span> partnum<span class="token punctuation">,</span> record <span class="token keyword">in</span> inventory<span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     inventory<span class="token punctuation">[</span>partnum<span class="token punctuation">]</span> <span class="token operator">=</span> record<span class="token punctuation">.</span>_replace<span class="token punctuation">(</span>price<span class="token operator">=</span>newprices<span class="token punctuation">[</span>partnum<span class="token punctuation">]</span><span class="token punctuation">,</span> timestamp<span class="token operator">=</span>time<span class="token punctuation">.</span>now<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>字符串元组列出了字段名。用于提醒和从现有元组创建一个新的命名元组类型。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>_fields            <span class="token comment" spellcheck="true"># view the field names</span>
<span class="token punctuation">(</span><span class="token string">'x'</span><span class="token punctuation">,</span> <span class="token string">'y'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> Color <span class="token operator">=</span> namedtuple<span class="token punctuation">(</span><span class="token string">'Color'</span><span class="token punctuation">,</span> <span class="token string">'red green blue'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> Pixel <span class="token operator">=</span> namedtuple<span class="token punctuation">(</span><span class="token string">'Pixel'</span><span class="token punctuation">,</span> Point<span class="token punctuation">.</span>_fields <span class="token operator">+</span> Color<span class="token punctuation">.</span>_fields<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> Pixel<span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">22</span><span class="token punctuation">,</span> <span class="token number">128</span><span class="token punctuation">,</span> <span class="token number">255</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>
Pixel<span class="token punctuation">(</span>x<span class="token operator">=</span><span class="token number">11</span><span class="token punctuation">,</span> y<span class="token operator">=</span><span class="token number">22</span><span class="token punctuation">,</span> red<span class="token operator">=</span><span class="token number">128</span><span class="token punctuation">,</span> green<span class="token operator">=</span><span class="token number">255</span><span class="token punctuation">,</span> blue<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>字典将字段名称映射到默认值。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> Account <span class="token operator">=</span> namedtuple<span class="token punctuation">(</span><span class="token string">'Account'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'type'</span><span class="token punctuation">,</span> <span class="token string">'balance'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> defaults<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> Account<span class="token punctuation">.</span>_field_defaults
<span class="token punctuation">{</span><span class="token string">'balance'</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">}</span>
<span class="token operator">>></span><span class="token operator">></span> Account<span class="token punctuation">(</span><span class="token string">'premium'</span><span class="token punctuation">)</span>
Account<span class="token punctuation">(</span>type<span class="token operator">=</span><span class="token string">'premium'</span><span class="token punctuation">,</span> balance<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>要获取这个名字域的值，使用 <code>getattr()</code> 函数 :</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> getattr<span class="token punctuation">(</span>p<span class="token punctuation">,</span> <span class="token string">'x'</span><span class="token punctuation">)</span>
<span class="token number">11</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>转换一个字典到命名元组，使用 ** 两星操作符 (所述如 解包实参列表):</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> d <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'x'</span><span class="token punctuation">:</span> <span class="token number">11</span><span class="token punctuation">,</span> <span class="token string">'y'</span><span class="token punctuation">:</span> <span class="token number">22</span><span class="token punctuation">}</span>
<span class="token operator">>></span><span class="token operator">></span> Point<span class="token punctuation">(</span><span class="token operator">**</span>d<span class="token punctuation">)</span>
Point<span class="token punctuation">(</span>x<span class="token operator">=</span><span class="token number">11</span><span class="token punctuation">,</span> y<span class="token operator">=</span><span class="token number">22</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>因为一个命名元组是一个正常的Python类，它可以很容易的通过子类更改功能。这里是如何添加一个计算域和定宽输出打印格式:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">class</span> <span class="token class-name">Point</span><span class="token punctuation">(</span>namedtuple<span class="token punctuation">(</span><span class="token string">'Point'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'x'</span><span class="token punctuation">,</span> <span class="token string">'y'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     __slots__ <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     @property
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">def</span> <span class="token function">hypot</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         <span class="token keyword">return</span> <span class="token punctuation">(</span>self<span class="token punctuation">.</span>x <span class="token operator">**</span> <span class="token number">2</span> <span class="token operator">+</span> self<span class="token punctuation">.</span>y <span class="token operator">**</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">**</span> <span class="token number">0.5</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">def</span> <span class="token function">__str__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         <span class="token keyword">return</span> <span class="token string">'Point: x=%6.3f  y=%6.3f  hypot=%6.3f'</span> <span class="token operator">%</span> <span class="token punctuation">(</span>self<span class="token punctuation">.</span>x<span class="token punctuation">,</span> self<span class="token punctuation">.</span>y<span class="token punctuation">,</span> self<span class="token punctuation">.</span>hypot<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">for</span> p <span class="token keyword">in</span> Point<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span> Point<span class="token punctuation">(</span><span class="token number">14</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token operator">/</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">print</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span>
Point<span class="token punctuation">:</span> x<span class="token operator">=</span> <span class="token number">3.000</span>  y<span class="token operator">=</span> <span class="token number">4.000</span>  hypot<span class="token operator">=</span> <span class="token number">5.000</span>
Point<span class="token punctuation">:</span> x<span class="token operator">=</span><span class="token number">14.000</span>  y<span class="token operator">=</span> <span class="token number">0.714</span>  hypot<span class="token operator">=</span><span class="token number">14.018</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>上面的子类设置 <code>__slots__</code> 为一个空元组。通过阻止创建实例字典保持了较低的内存开销。</p>
<p>子类化对于添加和存储新的名字域是无效的。应当通过 <code>_fields</code> 创建一个新的命名元组来实现它:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> Point3D <span class="token operator">=</span> namedtuple<span class="token punctuation">(</span><span class="token string">'Point3D'</span><span class="token punctuation">,</span> Point<span class="token punctuation">.</span>_fields <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token string">'z'</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>文档字符串可以自定义，通过直接赋值给 <code>__doc__</code> 属性:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> Book <span class="token operator">=</span> namedtuple<span class="token punctuation">(</span><span class="token string">'Book'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'id'</span><span class="token punctuation">,</span> <span class="token string">'title'</span><span class="token punctuation">,</span> <span class="token string">'authors'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> Book<span class="token punctuation">.</span>__doc__ <span class="token operator">+=</span> <span class="token string">': Hardcover book in active collection'</span>
<span class="token operator">>></span><span class="token operator">></span> Book<span class="token punctuation">.</span>id<span class="token punctuation">.</span>__doc__ <span class="token operator">=</span> <span class="token string">'13-digit ISBN'</span>
<span class="token operator">>></span><span class="token operator">></span> Book<span class="token punctuation">.</span>title<span class="token punctuation">.</span>__doc__ <span class="token operator">=</span> <span class="token string">'Title of first printing'</span>
<span class="token operator">>></span><span class="token operator">></span> Book<span class="token punctuation">.</span>authors<span class="token punctuation">.</span>__doc__ <span class="token operator">=</span> <span class="token string">'List of authors sorted by last name'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在 3.5 版更改: 文档字符串属性变成可写。</p>
<h3 id="OrderedDict-对象"><a href="#OrderedDict-对象" class="headerlink" title="OrderedDict 对象"></a><code>OrderedDict</code> 对象</h3><p>有序词典就像常规词典一样，但有一些与排序操作相关的额外功能。由于内置的 <code>dict</code> 类获得了记住插入顺序的能力（在 Python 3.7 中保证了这种新行为），它们变得不那么重要了。</p>
<p>一些与 <code>dict</code> 的不同仍然存在：</p>
<ul>
<li>常规的 <code>dict</code> 被设计为非常擅长映射操作。 跟踪插入顺序是次要的。</li>
<li><code>OrderedDict</code> 旨在擅长重新排序操作。 空间效率、迭代速度和更新操作的性能是次要的。</li>
<li>算法上， <code>OrderedDict</code> 可以比 <code>dict</code> 更好地处理频繁的重新排序操作。 这使其适用于跟踪最近的访问（例如在 LRU cache 中）。</li>
<li>对于 <code>OrderedDict</code> ，相等操作检查匹配顺序。</li>
<li><code>OrderedDict</code> 类的 <code>popitem()</code> 方法有不同的签名。它接受一个可选参数来指定弹出哪个元素。</li>
<li><code>OrderedDict</code> 类有一个 <code>move_to_end()</code> 方法，可以有效地将元素移动到任一端。</li>
<li>Python 3.8之前， <code>dict</code> 缺少 <code>__reversed__()</code> 方法。</li>
</ul>
<p><em>class</em> <code>collections.OrderedDict</code>([<em>items</em>])</p>
<p>返回一个 <code>dict</code> 子类的实例，它具有专门用于重新排列字典顺序的方法。</p>
<p>3.1 新版功能.</p>
<ul>
<li><p><code>popitem</code>(<em>last=True</em>)</p>
<p>有序字典的 <code>popitem()</code> 方法移除并返回一个 (key, value) 键值对。 如果 <em>last</em> 值为真，则按 LIFO 后进先出的顺序返回键值对，否则就按 FIFO 先进先出的顺序返回键值对。</p>
</li>
<li><p><code>move_to_end</code>(<em>key</em>, <em>last=True</em>)</p>
<p>将现有 <em>key</em> 移动到有序字典的任一端。 如果 <em>last</em> 为真值（默认）则将元素移至末尾；如果 <em>last</em> 为假值则将元素移至开头。如果 <em>key</em> 不存在则会触发 <code>KeyError</code>:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> d <span class="token operator">=</span> OrderedDict<span class="token punctuation">.</span>fromkeys<span class="token punctuation">(</span><span class="token string">'abcde'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> d<span class="token punctuation">.</span>move_to_end<span class="token punctuation">(</span><span class="token string">'b'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token string">''</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>d<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token string">'acdeb'</span>
<span class="token operator">>></span><span class="token operator">></span> d<span class="token punctuation">.</span>move_to_end<span class="token punctuation">(</span><span class="token string">'b'</span><span class="token punctuation">,</span> last<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token string">''</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>d<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token string">'bacde'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>3.2 新版功能.</p>
</li>
</ul>
<p>相对于通常的映射方法，有序字典还另外提供了逆序迭代的支持，通过 <code>reversed()</code> 。</p>
<p><code>OrderedDict</code> 之间的相等测试是顺序敏感的，实现为 <code>list(od1.items())==list(od2.items())</code> 。 <code>OrderedDict</code> 对象和其他的 <code>Mapping</code> 的相等测试，是顺序敏感的字典测试。这允许 <code>OrderedDict</code> 替换为任何字典可以使用的场所。</p>
<p>在 3.5 版更改: <code>OrderedDict</code> 的项(item)，键(key)和值(value) 视图 现在支持逆序迭代，通过 <code>reversed()</code> 。</p>
<p>在 3.6 版更改: <a href="https://www.python.org/dev/peps/pep-0468" target="_blank" rel="noopener"><strong>PEP 468</strong></a> 赞成将关键词参数的顺序保留， 通过传递给 <code>OrderedDict</code> 构造器和它的 <code>update()</code> 方法。</p>
<p>在 3.9 版更改: 增加了合并 (<code>|</code>) 与更新 (<code>|=</code>) 运算符，相关说明见 <a href="https://www.python.org/dev/peps/pep-0584" target="_blank" rel="noopener"><strong>PEP 584</strong></a>。</p>
<h4 id="OrderedDict-例子和用法"><a href="#OrderedDict-例子和用法" class="headerlink" title="OrderedDict 例子和用法"></a><code>OrderedDict</code> 例子和用法</h4><p>创建记住键值 <em>最后</em> 插入顺序的有序字典变体很简单。 如果新条目覆盖现有条目，则原始插入位置将更改并移至末尾:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">LastUpdatedOrderedDict</span><span class="token punctuation">(</span>OrderedDict<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token string">'Store items in the order the keys were last added'</span>
    <span class="token keyword">def</span> <span class="token function">__setitem__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">:</span>
        super<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>__setitem__<span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span>
        self<span class="token punctuation">.</span>move_to_end<span class="token punctuation">(</span>key<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>一个 <code>OrderedDict</code> 对于实现 <code>functools.lru_cache()</code> 的变体也很有用:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> time <span class="token keyword">import</span> time
<span class="token keyword">class</span> <span class="token class-name">TimeBoundedLRU</span><span class="token punctuation">:</span>
    <span class="token string">"LRU Cache that invalidates and refreshes old entries."</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> func<span class="token punctuation">,</span> maxsize<span class="token operator">=</span><span class="token number">128</span><span class="token punctuation">,</span> maxage<span class="token operator">=</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>cache <span class="token operator">=</span> OrderedDict<span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token comment" spellcheck="true"># { args : (timestamp, result)}</span>
        self<span class="token punctuation">.</span>func <span class="token operator">=</span> func
        self<span class="token punctuation">.</span>maxsize <span class="token operator">=</span> maxsize
        self<span class="token punctuation">.</span>maxage <span class="token operator">=</span> maxage
    <span class="token keyword">def</span> <span class="token function">__call__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> <span class="token operator">*</span>args<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> args <span class="token keyword">in</span> self<span class="token punctuation">.</span>cache<span class="token punctuation">:</span>
            self<span class="token punctuation">.</span>cache<span class="token punctuation">.</span>move_to_end<span class="token punctuation">(</span>args<span class="token punctuation">)</span>
            timestamp<span class="token punctuation">,</span> result <span class="token operator">=</span> self<span class="token punctuation">.</span>cache<span class="token punctuation">[</span>args<span class="token punctuation">]</span>
            <span class="token keyword">if</span> time<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> timestamp <span class="token operator">&lt;=</span> self<span class="token punctuation">.</span>maxage<span class="token punctuation">:</span>
                <span class="token keyword">return</span> result
        result <span class="token operator">=</span> self<span class="token punctuation">.</span>func<span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">)</span>
        self<span class="token punctuation">.</span>cache<span class="token punctuation">[</span>args<span class="token punctuation">]</span> <span class="token operator">=</span> time<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> result
        <span class="token keyword">if</span> len<span class="token punctuation">(</span>self<span class="token punctuation">.</span>cache<span class="token punctuation">)</span> <span class="token operator">></span> self<span class="token punctuation">.</span>maxsize<span class="token punctuation">:</span>
            self<span class="token punctuation">.</span>cache<span class="token punctuation">.</span>popitem<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> result<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="UserDict-对象"><a href="#UserDict-对象" class="headerlink" title="UserDict 对象"></a><code>UserDict</code> 对象</h3><p><code>UserDict</code> 类是用作字典对象的外包装。对这个类的需求已部分由直接创建 <code>dict</code> 的子类的功能所替代；不过，这个类处理起来更容易，因为底层的字典可以作为属性来访问。</p>
<p><em>class</em> <code>collections.UserDict</code>([<em>initialdata</em>])</p>
<p>模拟字典的类。 这个实例的内容保存在一个常规字典中，它可以通过 <code>UserDict</code> 实例的 <code>data</code> 属性来访问。 如果提供了 <em>initialdata*，则 <code>data</code> 会用其内容来初始化；请注意对 *initialdata</em> 的引用将不会被保留，以允许它被用于其他目的。</p>
<p><code>UserDict</code> 实例提供了以下属性作为扩展方法和操作的支持:</p>
<ul>
<li><p><code>data</code></p>
<p>一个真实的字典，用于保存 <code>UserDict</code> 类的内容。</p>
</li>
</ul>
<h3 id="UserList-对象"><a href="#UserList-对象" class="headerlink" title="UserList 对象"></a><code>UserList</code> 对象</h3><p>这个类封装了列表对象。它是一个有用的基础类，对于你想自定义的类似列表的类，可以继承和覆盖现有的方法，也可以添加新的方法。这样我们可以对列表添加新的行为。</p>
<p>对这个类的需求已部分由直接创建 <code>list</code> 的子类的功能所替代；不过，这个类处理起来更容易，因为底层的列表可以作为属性来访问。</p>
<p><em>class</em> <code>collections.UserList</code>([<em>list</em>])</p>
<p>模拟一个列表。这个实例的内容被保存为一个正常列表，通过 <code>UserList</code> 的 <code>data</code> 属性存取。实例内容被初始化为一个 <em>list</em> 的copy，默认为 <code>[]</code> 空列表。 <em>list</em> 可以是迭代对象，比如一个Python列表，或者一个 <code>UserList</code> 对象。</p>
<p><code>UserList</code> 提供了以下属性作为可变序列的方法和操作的扩展:</p>
<ul>
<li><p><code>data</code></p>
<p>一个 <code>list</code> 对象用于存储 <code>UserList</code> 的内容。</p>
</li>
</ul>
<p><strong>子类化的要求:</strong> <code>UserList</code> 的子类需要提供一个构造器，可以无参数调用，或者一个参数调用。返回一个新序列的列表操作需要创建一个实现类的实例。它假定了构造器可以以一个参数进行调用，这个参数是一个序列对象，作为数据源。</p>
<p>如果一个分离的类不希望依照这个需求，所有的特殊方法就必须重写；请参照源代码进行修改。</p>
<h3 id="UserString-对象"><a href="#UserString-对象" class="headerlink" title="UserString 对象"></a><code>UserString</code> 对象</h3><p><code>UserString</code> 类是用作字符串对象的外包装。对这个类的需求已部分由直接创建 <code>str</code> 的子类的功能所替代；不过，这个类处理起来更容易，因为底层的字符串可以作为属性来访问。</p>
<p><em>class</em> <code>collections.UserString</code>(<em>seq</em>)</p>
<p>模拟一个字符串对象。这个实例对象的内容保存为一个正常字符串，通过 <code>UserString</code> 的 <code>data</code> 属性存取。实例内容初始化设置为 <em>seq</em> 的copy。<em>seq</em> 参数可以是任何可通过内建 <code>str()</code> 函数转换为字符串的对象。</p>
<p><code>UserString</code> 提供了以下属性作为字符串方法和操作的额外支持：</p>
<ul>
<li><p><code>data</code></p>
<p>一个真正的 <code>str</code> 对象用来存放 <code>UserString</code> 类的内容。</p>
</li>
</ul>
<p>在 3.5 版更改: 新方法 <code>__getnewargs__</code>, <code>__rmod__</code>, <code>casefold</code>, <code>format_map</code>, <code>isprintable</code>, 和 <code>maketrans</code>。</p>
<h2 id="collections-abc-—-容器的抽象基类"><a href="#collections-abc-—-容器的抽象基类" class="headerlink" title="collections.abc —- 容器的抽象基类"></a><code>collections.abc</code> —- 容器的抽象基类</h2><p>3.3 新版功能: 该模块曾是 <code>collections</code> 模块的组成部分。</p>
<p><strong>源代码：</strong> <a href="https://github.com/python/cpython/tree/3.10/Lib/_collections_abc.py" target="_blank" rel="noopener">Lib/_collections_abc.py</a></p>
<hr>
<p>该模块定义了一些 抽象基类，它们可用于判断一个具体类是否具有某一特定的接口；例如，这个类是否可哈希，或其是否为映射类。</p>
<p>An <code>issubclass()</code> or <code>isinstance()</code> test for an interface works in one of three ways.</p>
<p>\1) A newly written class can inherit directly from one of the abstract base classes. The class must supply the required abstract methods. The remaining mixin methods come from inheritance and can be overridden if desired. Other methods may be added as needed:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">C</span><span class="token punctuation">(</span>Sequence<span class="token punctuation">)</span><span class="token punctuation">:</span>                      <span class="token comment" spellcheck="true"># Direct inheritance</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>             <span class="token comment" spellcheck="true"># Extra method not required by the ABC</span>
    <span class="token keyword">def</span> <span class="token function">__getitem__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> index<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  <span class="token comment" spellcheck="true"># Required abstract method</span>
    <span class="token keyword">def</span> <span class="token function">__len__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>             <span class="token comment" spellcheck="true"># Required abstract method</span>
    <span class="token keyword">def</span> <span class="token function">count</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         <span class="token comment" spellcheck="true"># Optionally override a mixin method</span>

<span class="token operator">>></span><span class="token operator">></span> issubclass<span class="token punctuation">(</span>C<span class="token punctuation">,</span> Sequence<span class="token punctuation">)</span>
<span class="token boolean">True</span>
<span class="token operator">>></span><span class="token operator">></span> isinstance<span class="token punctuation">(</span>C<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> Sequence<span class="token punctuation">)</span>
<span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>\2) Existing classes and built-in classes can be registered as “virtual subclasses” of the ABCs. Those classes should define the full API including all of the abstract methods and all of the mixin methods. This lets users rely on <code>issubclass()</code> or <code>isinstance()</code> tests to determine whether the full interface is supported. The exception to this rule is for methods that are automatically inferred from the rest of the API:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">D</span><span class="token punctuation">:</span>                                 <span class="token comment" spellcheck="true"># No inheritance</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>              <span class="token comment" spellcheck="true"># Extra method not required by the ABC</span>
    <span class="token keyword">def</span> <span class="token function">__getitem__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> index<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>   <span class="token comment" spellcheck="true"># Abstract method</span>
    <span class="token keyword">def</span> <span class="token function">__len__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>              <span class="token comment" spellcheck="true"># Abstract method</span>
    <span class="token keyword">def</span> <span class="token function">count</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>          <span class="token comment" spellcheck="true"># Mixin method</span>
    <span class="token keyword">def</span> <span class="token function">index</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>          <span class="token comment" spellcheck="true"># Mixin method</span>
Sequence<span class="token punctuation">.</span>register<span class="token punctuation">(</span>D<span class="token punctuation">)</span>                     <span class="token comment" spellcheck="true"># Register instead of inherit</span>


<span class="token operator">>></span><span class="token operator">></span> issubclass<span class="token punctuation">(</span>D<span class="token punctuation">,</span> Sequence<span class="token punctuation">)</span>
<span class="token boolean">True</span>
<span class="token operator">>></span><span class="token operator">></span> isinstance<span class="token punctuation">(</span>D<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> Sequence<span class="token punctuation">)</span>
<span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>In this example, class <code>D</code> does not need to define <code>__contains__</code>, <code>__iter__</code>, and <code>__reversed__</code> because the in-operator, the iteration logic, and the <code>reversed()</code> function automatically fall back to using <code>__getitem__</code> and <code>__len__</code>.</p>
<p>\3) Some simple interfaces are directly recognizable by the presence of the required methods (unless those methods have been set to <code>None</code>):</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">E</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__iter__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">def</span> <span class="token function">__next__</span><span class="token punctuation">(</span>next<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

<span class="token operator">>></span><span class="token operator">></span> issubclass<span class="token punctuation">(</span>E<span class="token punctuation">,</span> Iterable<span class="token punctuation">)</span>
<span class="token boolean">True</span>
<span class="token operator">>></span><span class="token operator">></span> isinstance<span class="token punctuation">(</span>E<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> Iterable<span class="token punctuation">)</span>
<span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>Complex interfaces do not support this last technique because an interface is more than just the presence of method names. Interfaces specify semantics and relationships between methods that cannot be inferred solely from the presence of specific method names. For example, knowing that a class supplies <code>__getitem__</code>, <code>__len__</code>, and <code>__iter__</code> is insufficient for distinguishing a <code>Sequence</code> from a <code>Mapping</code>.</p>
<h3 id="容器抽象基类"><a href="#容器抽象基类" class="headerlink" title="容器抽象基类"></a>容器抽象基类</h3><p>这个容器模块提供了以下 ABCs:</p>
<table>
<thead>
<tr>
<th align="left">抽象基类</th>
<th align="left">继承自</th>
<th align="left">抽象方法</th>
<th align="left">Mixin 方法</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>Container</code></td>
<td align="left"></td>
<td align="left"><code>**contains**</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>Hashable</code></td>
<td align="left"></td>
<td align="left"><code>**hash**</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>Iterable</code></td>
<td align="left"></td>
<td align="left"><code>**iter**</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>Iterator</code></td>
<td align="left"><code>Iterable</code></td>
<td align="left"><code>**next**</code></td>
<td align="left"><code>**iter**</code></td>
</tr>
<tr>
<td align="left"><code>Reversible</code></td>
<td align="left"><code>Iterable</code></td>
<td align="left"><code>**reversed**</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>Generator</code></td>
<td align="left"><code>Iterator</code></td>
<td align="left"><code>send</code>, <code>throw</code></td>
<td align="left"><code>close</code>, <code>**iter**</code>, <code>**next**</code></td>
</tr>
<tr>
<td align="left"><code>Sized</code></td>
<td align="left"></td>
<td align="left"><code>**len**</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>Callable</code></td>
<td align="left"></td>
<td align="left"><code>**call**</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>Collection</code></td>
<td align="left"><code>Sized</code>, <code>Iterable</code>, <code>Container</code></td>
<td align="left"><code>**contains**</code>, <code>**iter**</code>, <code>**len**</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>Sequence</code></td>
<td align="left"><code>Reversible</code>, <code>Collection</code></td>
<td align="left"><code>**getitem**</code>, <code>**len**</code></td>
<td align="left"><code>**contains**</code>, <code>**iter**</code>, <code>**reversed**</code>, <code>index</code>, and <code>count</code></td>
</tr>
<tr>
<td align="left"><code>MutableSequence</code></td>
<td align="left"><code>Sequence</code></td>
<td align="left"><code>**getitem**</code>, <code>**setitem**</code>, <code>**delitem**</code>, <code>**len**</code>, <code>insert</code></td>
<td align="left">继承自 <code>Sequence</code> 的方法，以及 <code>append</code>, <code>reverse</code>, <code>extend</code>, <code>pop</code>, <code>remove</code>，和 <code>**iadd**</code></td>
</tr>
<tr>
<td align="left"><code>ByteString</code></td>
<td align="left"><code>Sequence</code></td>
<td align="left"><code>**getitem**</code>, <code>**len**</code></td>
<td align="left">继承自 <code>Sequence</code> 的方法</td>
</tr>
<tr>
<td align="left"><code>Set</code></td>
<td align="left"><code>Collection</code></td>
<td align="left"><code>**contains**</code>, <code>**iter**</code>, <code>**len**</code></td>
<td align="left"><code>**le**</code>, <code>**lt**</code>, <code>**eq**</code>, <code>**ne**</code>, <code>**gt**</code>, <code>**ge**</code>, <code>**and**</code>, <code>**or**</code>, <code>**sub**</code>, <code>**xor**</code>, and <code>isdisjoint</code></td>
</tr>
<tr>
<td align="left"><code>MutableSet</code></td>
<td align="left"><code>Set</code></td>
<td align="left"><code>**contains**</code>, <code>**iter**</code>, <code>**len**</code>, <code>add</code>, <code>discard</code></td>
<td align="left">继承自 <code>Set</code> 的方法以及 <code>clear</code>, <code>pop</code>, <code>remove</code>, <code>**ior**</code>, <code>**iand**</code>, <code>**ixor**</code>，和 <code>**isub**</code></td>
</tr>
<tr>
<td align="left"><code>Mapping</code></td>
<td align="left"><code>Collection</code></td>
<td align="left"><code>**getitem**</code>, <code>**iter**</code>, <code>**len**</code></td>
<td align="left"><code>**contains**</code>, <code>keys</code>, <code>items</code>, <code>values</code>, <code>get</code>, <code>**eq**</code>, and <code>**ne**</code></td>
</tr>
<tr>
<td align="left"><code>MutableMapping</code></td>
<td align="left"><code>Mapping</code></td>
<td align="left"><code>**getitem**</code>, <code>**setitem**</code>, <code>**delitem**</code>, <code>**iter**</code>, <code>**len**</code></td>
<td align="left">继承自 <code>Mapping</code> 的方法以及 <code>pop</code>, <code>popitem</code>, <code>clear</code>, <code>update</code>，和 <code>setdefault</code></td>
</tr>
<tr>
<td align="left"><code>MappingView</code></td>
<td align="left"><code>Sized</code></td>
<td align="left"></td>
<td align="left"><code>**len**</code></td>
</tr>
<tr>
<td align="left"><code>ItemsView</code></td>
<td align="left"><code>MappingView</code>, <code>Set</code></td>
<td align="left"></td>
<td align="left"><code>**contains**</code>, <code>**iter**</code></td>
</tr>
<tr>
<td align="left"><code>KeysView</code></td>
<td align="left"><code>MappingView</code>, <code>Set</code></td>
<td align="left"></td>
<td align="left"><code>**contains**</code>, <code>**iter**</code></td>
</tr>
<tr>
<td align="left"><code>ValuesView</code></td>
<td align="left"><code>MappingView</code>, <code>Collection</code></td>
<td align="left"></td>
<td align="left"><code>**contains**</code>, <code>**iter**</code></td>
</tr>
<tr>
<td align="left"><code>Awaitable</code></td>
<td align="left"></td>
<td align="left"><code>**await**</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>Coroutine</code></td>
<td align="left"><code>Awaitable</code></td>
<td align="left"><code>send</code>, <code>throw</code></td>
<td align="left"><code>close</code></td>
</tr>
<tr>
<td align="left"><code>AsyncIterable</code></td>
<td align="left"></td>
<td align="left"><code>**aiter**</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>AsyncIterator</code></td>
<td align="left"><code>AsyncIterable</code></td>
<td align="left"><code>**anext**</code></td>
<td align="left"><code>**aiter**</code></td>
</tr>
<tr>
<td align="left"><code>AsyncGenerator</code></td>
<td align="left"><code>AsyncIterator</code></td>
<td align="left"><code>asend</code>, <code>athrow</code></td>
<td align="left"><code>aclose</code>, <code>**aiter**</code>, <code>**anext**</code></td>
</tr>
</tbody></table>
<p>These ABCs override <code>object.__subclasshook__()</code> to support testing an interface by verifying the required methods are present and have not been set to <code>None</code>. This only works for simple interfaces. More complex interfaces require registration or direct subclassing.</p>
<p>Checking <code>isinstance(obj, Iterable)</code> detects classes that are registered as <code>Iterable</code> or that have an <code>__iter__()</code> method, but it does not detect classes that iterate with the <code>__getitem__()</code> method. The only reliable way to determine whether an object is iterable is to call <code>iter(obj)</code>.</p>
<h3 id="Collections-Abstract-Base-Classes-—-Detailed-Descriptions"><a href="#Collections-Abstract-Base-Classes-—-Detailed-Descriptions" class="headerlink" title="Collections Abstract Base Classes — Detailed Descriptions"></a>Collections Abstract Base Classes — Detailed Descriptions</h3><p><em>class</em> <code>collections.abc.Container</code></p>
<p>提供了 <code>__contains__()</code> 方法的抽象基类。</p>
<p><em>class</em> <code>collections.abc.Hashable</code></p>
<p>提供了 <code>__hash__()</code> 方法的抽象基类。</p>
<p><em>class</em> <code>collections.abc.Sized</code></p>
<p>提供了 <code>__len__()</code> 方法的抽象基类。</p>
<p><em>class</em> <code>collections.abc.Callable</code></p>
<p>提供了 <code>__call__()</code> 方法的抽象基类。</p>
<p><em>class</em> <code>collections.abc.Iterable</code></p>
<p>提供了 <code>__iter__()</code> 方法的抽象基类。</p>
<p>使用 <code>isinstance(obj, Iterable)</code> 可以检测一个类是否已经注册到了 <code>Iterable</code> 或者实现了 <code>__iter__()</code> 函数，但是无法检测这个类是否能够使用 <code>__getitem__()</code> 方法进行迭代。检测一个对象是否是 iterable 的唯一可信赖的方法是调用 <code>iter(obj)</code>。</p>
<p><em>class</em> <code>collections.abc.Collection</code></p>
<p>集合了 Sized 和 Iterable 类的抽象基类。</p>
<p>3.6 新版功能.</p>
<p><em>class</em> <code>collections.abc.Iterator</code></p>
<p>提供了 <code>__iter__()</code> 和 <code>__next__()</code> 方法的抽象基类。参见 iterator 的定义。</p>
<p><em>class</em> <code>collections.abc.Reversible</code></p>
<p>为可迭代类提供了 <code>__reversed__()</code> 方法的抽象基类。</p>
<p>3.6 新版功能.</p>
<p><em>class</em> <code>collections.abc.Generator</code></p>
<p>生成器类，实现了 <a href="https://www.python.org/dev/peps/pep-0342" target="_blank" rel="noopener"><strong>PEP 342</strong></a> 中定义的协议，继承并扩展了迭代器，提供了 <code>send()</code>, <code>throw()</code> 和 <code>close()</code> 方法。</p>
<p>3.5 新版功能.</p>
<p><em>class</em> <code>collections.abc.Sequence</code></p>
<p><em>class</em> <code>collections.abc.MutableSequence</code></p>
<p><em>class</em> <code>collections.abc.ByteString</code></p>
<p>只读且可变的序列 sequences 的抽象基类。</p>
<p>实现笔记：一些混入（Maxin）方法比如 <code>__iter__()</code>, <code>__reversed__()</code> 和 <code>index()</code> 会重复调用底层的 <code>__getitem__()</code> 方法。因此，如果实现的 <code>__getitem__()</code> 是常数级访问速度，那么相应的混入方法会有一个线性的表现；然而，如果底层方法是线性实现（例如链表），那么混入方法将会是平方级的表现，这也许就需要被重构了。</p>
<p>在 3.5 版更改: index() 方法支持 <em>stop</em> 和 <em>start</em> 参数。</p>
<p><em>class</em> <code>collections.abc.Set</code></p>
<p><em>class</em> <code>collections.abc.MutableSet</code></p>
<p>只读且可变的集合的抽象基类。</p>
<p><em>class</em> <code>collections.abc.Mapping</code></p>
<p><em>class</em> <code>collections.abc.MutableMapping</code></p>
<p>只读且可变的映射 mappings 的抽象基类。</p>
<p><em>class</em> <code>collections.abc.MappingView</code></p>
<p><em>class</em> <code>collections.abc.ItemsView</code></p>
<p><em>class</em> <code>collections.abc.KeysView</code></p>
<p><em>class</em> <code>collections.abc.ValuesView</code></p>
<p>映射及其键和值的视图 views 的抽象基类。</p>
<p><em>class</em> <code>collections.abc.Awaitable</code></p>
<p>为可等待对象 awaitable 提供的类，可以被用于 <code>await</code> 表达式中。习惯上必须实现 <code>__await__()</code> 方法。</p>
<p>协程 对象和 <code>Coroutine</code> ABC 的实例都是这个 ABC 的实例。</p>
<p>注解</p>
<p>在 CPython 里，基于生成器的协程（使用 <code>types.coroutine()</code> 或 <code>asyncio.coroutine()</code> 包装的生成器）都是 <em>可等待对象</em>，即使他们不含有 <code>__await__()</code> 方法。使用 <code>isinstance(gencoro, Awaitable)</code> 来检测他们会返回 <code>False</code>。要使用 <code>inspect.isawaitable()</code> 来检测他们。</p>
<p>3.5 新版功能.</p>
<p><em>class</em> <code>collections.abc.Coroutine</code></p>
<p>用于协程兼容类的抽象基类。实现了如下定义在 协程对象: 里的方法： <code>send()</code>，<code>throw()</code> 和 <code>close()</code>。通常的实现里还需要实现 <code>__await__()</code> 方法。所有的 <code>Coroutine</code> 实例都必须是 <code>Awaitable</code> 实例。</p>
<p>注解</p>
<p>在 CPython 里，基于生成器的协程（使用 <code>types.coroutine()</code> 或 <code>asyncio.coroutine()</code> 包装的生成器）都是 <em>可等待对象</em>，即使他们不含有 <code>__await__()</code> 方法。使用 <code>isinstance(gencoro, Coroutine)</code> 来检测他们会返回 <code>False</code>。要使用 <code>inspect.isawaitable()</code> 来检测他们。</p>
<p>3.5 新版功能.</p>
<p><em>class</em> <code>collections.abc.AsyncIterable</code></p>
<p>提供了 <code>__aiter__</code> 方法的抽象基类。</p>
<p>3.5 新版功能.</p>
<p><em>class</em> <code>collections.abc.AsyncIterator</code></p>
<p>提供了 <code>__aiter__</code> 和 <code>__anext__</code> 方法的抽象基类。</p>
<p>3.5 新版功能.</p>
<p><em>class</em> <code>collections.abc.AsyncGenerator</code></p>
<p>为异步生成器类提供的抽象基类，这些类实现了定义在 <a href="https://www.python.org/dev/peps/pep-0525" target="_blank" rel="noopener"><strong>PEP 525</strong></a> 和 <a href="https://www.python.org/dev/peps/pep-0492" target="_blank" rel="noopener"><strong>PEP 492</strong></a> 里的协议。</p>
<p>3.6 新版功能.</p>
<h3 id="Examples-and-Recipes"><a href="#Examples-and-Recipes" class="headerlink" title="Examples and Recipes"></a>Examples and Recipes</h3><p>ABCs allow us to ask classes or instances if they provide particular functionality, for example:</p>
<pre class="line-numbers language-python"><code class="language-python">size <span class="token operator">=</span> None
<span class="token keyword">if</span> isinstance<span class="token punctuation">(</span>myvar<span class="token punctuation">,</span> collections<span class="token punctuation">.</span>abc<span class="token punctuation">.</span>Sized<span class="token punctuation">)</span><span class="token punctuation">:</span>
    size <span class="token operator">=</span> len<span class="token punctuation">(</span>myvar<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>有些抽象基类也可以用作混入类（mixin），这可以更容易地开发支持容器 API 的类。例如，要写一个支持完整 <a href="https://www.bookstack.cn/read/python-3.10.0-zh/7183cf74f5db7dc0.md#collections.abc.Set" target="_blank" rel="noopener"><code>Set</code></a> API 的类，只需要提供下面这三个方法： <code>__contains__()</code>, <code>__iter__()</code> 和 <code>__len__()</code>。抽象基类会补充上其余的方法，比如 <code>__and__()</code> 和 <code>isdisjoint()</code>:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">ListBasedSet</span><span class="token punctuation">(</span>collections<span class="token punctuation">.</span>abc<span class="token punctuation">.</span>Set<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">''' Alternate set implementation favoring space over speed
        and not requiring the set elements to be hashable. '''</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> iterable<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>elements <span class="token operator">=</span> lst <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        <span class="token keyword">for</span> value <span class="token keyword">in</span> iterable<span class="token punctuation">:</span>
            <span class="token keyword">if</span> value <span class="token operator">not</span> <span class="token keyword">in</span> lst<span class="token punctuation">:</span>
                lst<span class="token punctuation">.</span>append<span class="token punctuation">(</span>value<span class="token punctuation">)</span>
    <span class="token keyword">def</span> <span class="token function">__iter__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> iter<span class="token punctuation">(</span>self<span class="token punctuation">.</span>elements<span class="token punctuation">)</span>
    <span class="token keyword">def</span> <span class="token function">__contains__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> value <span class="token keyword">in</span> self<span class="token punctuation">.</span>elements
    <span class="token keyword">def</span> <span class="token function">__len__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> len<span class="token punctuation">(</span>self<span class="token punctuation">.</span>elements<span class="token punctuation">)</span>
s1 <span class="token operator">=</span> ListBasedSet<span class="token punctuation">(</span><span class="token string">'abcdef'</span><span class="token punctuation">)</span>
s2 <span class="token operator">=</span> ListBasedSet<span class="token punctuation">(</span><span class="token string">'defghi'</span><span class="token punctuation">)</span>
overlap <span class="token operator">=</span> s1 <span class="token operator">&amp;</span> s2            <span class="token comment" spellcheck="true"># The __and__() method is supported automatically</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>当把 <code>Set</code> 和 <code>MutableSet</code> 用作混入类时需注意：</p>
<ol>
<li>由于某些集合操作会创建新集合，默认的混入方法需要一种从可迭代对象里创建新实例的方式。 假定类构造器具有 <code>ClassName(iterable)</code> 形式的签名。 这样它将执行一个名为 <code>_from_iterable()</code> 的内部类方法，该方法会调用 <code>cls(iterable)</code> 来产生一个新集合。 如果 <code>Set</code> 混入类在具有不同构造器签名的类中被使用，你将需要通过类方法或常规方法来重载 <code>_from_iterable()</code>，以便基于可迭代对象参数来构造新的实例。</li>
<li>重载比较符时时（想必是为了速度，因为其语义都是固定的），只需要重定义 <code>__le__()</code> 和 <code>__ge__()</code> 函数，然后其他的操作会自动跟进。</li>
<li>混入集合类 <code>Set</code> 提供了一个 <code>_hash()</code> 方法为集合计算哈希值，然而， <code>__hash__()</code> 函数却没有被定义，因为并不是所有集合都是可哈希并且不可变的。为了使用混入类为集合添加哈希能力，可以同时继承 <code>Set()</code> 和 <code>Hashable()</code> 类，然后定义 <code>__hash__ = Set._hash</code>。</li>
</ol>
<h2 id="heapq-—-堆队列算法"><a href="#heapq-—-堆队列算法" class="headerlink" title="heapq —- 堆队列算法"></a><code>heapq</code> —- 堆队列算法</h2><p><strong>源码：</strong><a href="https://github.com/python/cpython/tree/3.10/Lib/heapq.py" target="_blank" rel="noopener">Lib/heapq.py</a></p>
<hr>
<p>这个模块提供了堆队列算法的实现，也称为优先队列算法。</p>
<p>堆是一个二叉树，它的每个父节点的值都只会小于或等于所有孩子节点（的值）。 它使用了数组来实现：从零开始计数，对于所有的 <em>k</em> ，都有 <code>heap[k] &lt;= heap[2*k+1]</code> 和 <code>heap[k] &lt;= heap[2*k+2]</code>。 为了便于比较，不存在的元素被认为是无限大。 堆最有趣的特性在于最小的元素总是在根结点：<code>heap[0]</code>。</p>
<p>这个API与教材的堆算法实现有所不同，具体区别有两方面：（a）我们使用了从零开始的索引。这使得节点和其孩子节点索引之间的关系不太直观但更加适合，因为 Python 使用从零开始的索引。 （b）我们的 pop 方法返回最小的项而不是最大的项（这在教材中称为“最小堆”；而“最大堆”在教材中更为常见，因为它更适用于原地排序）。</p>
<p>基于这两方面，把堆看作原生的Python list也没什么奇怪的： <code>heap[0]</code> 表示最小的元素，同时 <code>heap.sort()</code> 维护了堆的不变性！</p>
<p>要创建一个堆，可以使用list来初始化为 <code>[]</code> ，或者你可以通过一个函数 <code>heapify()</code> ，来把一个list转换成堆。</p>
<p>定义了以下函数：</p>
<p><code>heapq.heappush</code>(<em>heap</em>, <em>item</em>)</p>
<p>将 <em>item</em> 的值加入 <em>heap</em> 中，保持堆的不变性。</p>
<p><code>heapq.heappop</code>(<em>heap</em>)</p>
<p>弹出并返回 <em>heap</em> 的最小的元素，保持堆的不变性。如果堆为空，抛出 <code>IndexError</code> 。使用 <code>heap[0]</code> ，可以只访问最小的元素而不弹出它。</p>
<p><code>heapq.heappushpop</code>(<em>heap</em>, <em>item</em>)</p>
<p>将 <em>item</em> 放入堆中，然后弹出并返回 <em>heap</em> 的最小元素。该组合操作比先调用 <code>heappush()</code> 再调用 <code>heappop()</code> 运行起来更有效率。</p>
<p><code>heapq.heapify</code>(<em>x</em>)</p>
<p>将list <em>x</em> 转换成堆，原地，线性时间内。</p>
<p><code>heapq.heapreplace</code>(<em>heap</em>, <em>item</em>)</p>
<p>弹出并返回 <em>heap</em> 中最小的一项，同时推入新的 <em>item</em>。 堆的大小不变。 如果堆为空则引发 <code>IndexError</code>。</p>
<p>这个单步骤操作比 <code>heappop()</code> 加 <code>heappush()</code> 更高效，并且在使用固定大小的堆时更为适宜。 pop/push 组合总是会从堆中返回一个元素并将其替换为 <em>item</em>。</p>
<p>返回的值可能会比添加的 <em>item</em> 更大。 如果不希望如此，可考虑改用 <code>heappushpop()</code>。 它的 push/pop 组合会返回两个值中较小的一个，将较大的值留在堆中。</p>
<p>该模块还提供了三个基于堆的通用功能函数。</p>
<p><code>heapq.merge</code>(<em>\</em>iterables<em>,</em> key=None<em>,</em> reverse=False*)</p>
<p>将多个已排序的输入合并为一个已排序的输出（例如，合并来自多个日志文件的带时间戳的条目）。 返回已排序值的 iterator。</p>
<p>类似于 <code>sorted(itertools.chain(*iterables))</code> 但返回一个可迭代对象，不会一次性地将数据全部放入内存，并假定每个输入流都是已排序的（从小到大）。</p>
<p>具有两个可选参数，它们都必须指定为关键字参数。</p>
<p><em>key</em> 指定带有单个参数的 key function，用于从每个输入元素中提取比较键。 默认值为 <code>None</code> (直接比较元素)。</p>
<p><em>reverse</em> 为一个布尔值。 如果设为 <code>True</code>，则输入元素将按比较结果逆序进行合并。 要达成与 <code>sorted(itertools.chain(*iterables), reverse=True)</code> 类似的行为，所有可迭代对象必须是已从大到小排序的。</p>
<p>在 3.5 版更改: 添加了可选的 <em>key</em> 和 <em>reverse</em> 形参。</p>
<p><code>heapq.nlargest</code>(<em>n</em>, <em>iterable</em>, <em>key=None</em>)</p>
<p>从 <em>iterable</em> 所定义的数据集中返回前 <em>n</em> 个最大元素组成的列表。 如果提供了 <em>key</em> 则其应指定一个单参数的函数，用于从 <em>iterable</em> 的每个元素中提取比较键 (例如 <code>key=str.lower</code>)。 等价于: <code>sorted(iterable, key=key, reverse=True)[:n]</code>。</p>
<p><code>heapq.nsmallest</code>(<em>n</em>, <em>iterable</em>, <em>key=None</em>)</p>
<p>从 <em>iterable</em> 所定义的数据集中返回前 <em>n</em> 个最小元素组成的列表。 如果提供了 <em>key</em> 则其应指定一个单参数的函数，用于从 <em>iterable</em> 的每个元素中提取比较键 (例如 <code>key=str.lower</code>)。 等价于: <code>sorted(iterable, key=key)[:n]</code>。</p>
<p>后两个函数在 <em>n</em> 值较小时性能最好。 对于更大的值，使用 <code>sorted()</code> 函数会更有效率。 此外，当 <code>n==1</code> 时，使用内置的 <code>min()</code> 和 <code>max()</code> 函数会更有效率。 如果需要重复使用这些函数，请考虑将可迭代对象转为真正的堆。</p>
<h3 id="基本示例"><a href="#基本示例" class="headerlink" title="基本示例"></a>基本示例</h3><p>堆排序 可以通过将所有值推入堆中然后每次弹出一个最小值项来实现。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">def</span> <span class="token function">heapsort</span><span class="token punctuation">(</span>iterable<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     h <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">for</span> value <span class="token keyword">in</span> iterable<span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         heappush<span class="token punctuation">(</span>h<span class="token punctuation">,</span> value<span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">return</span> <span class="token punctuation">[</span>heappop<span class="token punctuation">(</span>h<span class="token punctuation">)</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>h<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> heapsort<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这类似于 <code>sorted(iterable)</code>，但与 <code>sorted()</code> 不同的是这个实现是不稳定的。</p>
<p>堆元素可以为元组。 这适用于将比较值（例如任务优先级）与跟踪的主记录进行赋值的场合:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> h <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> heappush<span class="token punctuation">(</span>h<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token string">'write code'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> heappush<span class="token punctuation">(</span>h<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">,</span> <span class="token string">'release product'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> heappush<span class="token punctuation">(</span>h<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'write spec'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> heappush<span class="token punctuation">(</span>h<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">'create tests'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> heappop<span class="token punctuation">(</span>h<span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'write spec'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="优先队列实现说明"><a href="#优先队列实现说明" class="headerlink" title="优先队列实现说明"></a>优先队列实现说明</h3><p>优先队列 是堆的常用场合，并且它的实现包含了多个挑战：</p>
<ul>
<li>排序稳定性：你该如何令相同优先级的两个任务按它们最初被加入时的顺序返回？</li>
<li>如果优先级相同且任务没有默认比较顺序，则 (priority, task) 对的元组比较将会中断。</li>
<li>如果任务优先级发生改变，你该如何将其移至堆中的新位置？</li>
<li>或者如果一个挂起的任务需要被删除，你该如何找到它并将其移出队列？</li>
</ul>
<p>针对前两项挑战的一种解决方案是将条目保存为包含优先级、条目计数和任务对象 3 个元素的列表。 条目计数可用来打破平局，这样具有相同优先级的任务将按它们的添加顺序返回。 并且由于没有哪两个条目计数是相同的，元组比较将永远不会直接比较两个任务。</p>
<p>不可比较任务问题的另一种解决方案是创建一个忽略任务条目并且只比较优先级字段的包装器类:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> dataclasses <span class="token keyword">import</span> dataclass<span class="token punctuation">,</span> field
<span class="token keyword">from</span> typing <span class="token keyword">import</span> Any
@dataclass<span class="token punctuation">(</span>order<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>
<span class="token keyword">class</span> <span class="token class-name">PrioritizedItem</span><span class="token punctuation">:</span>
    priority<span class="token punctuation">:</span> int
    item<span class="token punctuation">:</span> Any<span class="token operator">=</span>field<span class="token punctuation">(</span>compare<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其余的挑战主要包括找到挂起的任务并修改其优先级或将其完全移除。 找到一个任务可使用一个指向队列中条目的字典来实现。</p>
<p>移除条目或改变其优先级的操作实现起来更为困难，因为它会破坏堆结构不变量。 因此，一种可能的解决方案是将条目标记为已移除，再添加一个改变了优先级的新条目:</p>
<pre class="line-numbers language-python"><code class="language-python">pq <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>                         <span class="token comment" spellcheck="true"># list of entries arranged in a heap</span>
entry_finder <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>               <span class="token comment" spellcheck="true"># mapping of tasks to entries</span>
REMOVED <span class="token operator">=</span> <span class="token string">'&lt;removed-task>'</span>      <span class="token comment" spellcheck="true"># placeholder for a removed task</span>
counter <span class="token operator">=</span> itertools<span class="token punctuation">.</span>count<span class="token punctuation">(</span><span class="token punctuation">)</span>     <span class="token comment" spellcheck="true"># unique sequence count</span>
<span class="token keyword">def</span> <span class="token function">add_task</span><span class="token punctuation">(</span>task<span class="token punctuation">,</span> priority<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token string">'Add a new task or update the priority of an existing task'</span>
    <span class="token keyword">if</span> task <span class="token keyword">in</span> entry_finder<span class="token punctuation">:</span>
        remove_task<span class="token punctuation">(</span>task<span class="token punctuation">)</span>
    count <span class="token operator">=</span> next<span class="token punctuation">(</span>counter<span class="token punctuation">)</span>
    entry <span class="token operator">=</span> <span class="token punctuation">[</span>priority<span class="token punctuation">,</span> count<span class="token punctuation">,</span> task<span class="token punctuation">]</span>
    entry_finder<span class="token punctuation">[</span>task<span class="token punctuation">]</span> <span class="token operator">=</span> entry
    heappush<span class="token punctuation">(</span>pq<span class="token punctuation">,</span> entry<span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">remove_task</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token string">'Mark an existing task as REMOVED.  Raise KeyError if not found.'</span>
    entry <span class="token operator">=</span> entry_finder<span class="token punctuation">.</span>pop<span class="token punctuation">(</span>task<span class="token punctuation">)</span>
    entry<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> REMOVED
<span class="token keyword">def</span> <span class="token function">pop_task</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token string">'Remove and return the lowest priority task. Raise KeyError if empty.'</span>
    <span class="token keyword">while</span> pq<span class="token punctuation">:</span>
        priority<span class="token punctuation">,</span> count<span class="token punctuation">,</span> task <span class="token operator">=</span> heappop<span class="token punctuation">(</span>pq<span class="token punctuation">)</span>
        <span class="token keyword">if</span> task <span class="token keyword">is</span> <span class="token operator">not</span> REMOVED<span class="token punctuation">:</span>
            <span class="token keyword">del</span> entry_finder<span class="token punctuation">[</span>task<span class="token punctuation">]</span>
            <span class="token keyword">return</span> task
    <span class="token keyword">raise</span> KeyError<span class="token punctuation">(</span><span class="token string">'pop from an empty priority queue'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h3><p>堆是通过数组来实现的，其中的元素从 0 开始计数，对于所有的 <em>k</em> 都有 <code>a[k] &lt;= a[2*k+1]</code> 且 <code>a[k] &lt;= a[2*k+2]</code>。 为了便于比较，不存在的元素被视为无穷大。 堆最有趣的特性在于 <code>a[0]</code> 总是其中最小的元素。</p>
<p>上面的特殊不变量是用来作为一场锦标赛的高效内存表示。 下面的数字是 <em>k</em> 而不是 <code>a[k]</code>:</p>
<pre><code>                               0
              1                                 2
      3               4                5               6
  7       8       9       10      11      12      13      14
15 16   17 18   19 20   21 22   23 24   25 26   27 28   29 30</code></pre><p>在上面的树中，每个 <em>k</em> 单元都位于 <code>2*k+1</code> 和 <code>2*k+2</code> 之上。 体育运动中我们经常见到二元锦标赛模式，每个胜者单元都位于另两个单元之上，并且我们可以沿着树形图向下追溯胜者所遇到的所有对手。 但是，在许多采用这种锦标赛模式的计算机应用程序中，我们并不需要追溯胜者的历史。 为了获得更高的内存利用效率，当一个胜者晋级时，我们会用较低层级的另一条目来替代它，因此规则变为一个单元和它之下的两个单元包含三个不同条目，上方单元“胜过”了两个下方单元。</p>
<p>如果此堆的不变量始终受到保护，则序号 0 显然是最后的赢家。 删除它并找出“下一个”赢家的最简单算法方式是家某个输家（让我们假定是上图中的 30 号单元）移至 0 号位置，然后将这个新的 0 号沿树下行，不断进行值的交换，直到不变量重新建立。 这显然会是树中条目总数的对数。 通过迭代所有条目，你将得到一个 O(n log n) 复杂度的排序。</p>
<p>此排序有一个很好的特性就是你可以在排序进行期间高效地插入新条目，前提是插入的条目不比你最近取出的 0 号元素“更好”。 这在模拟上下文时特别有用，在这种情况下树保存的是所有传入事件，“胜出”条件是最小调度时间。 当一个事件将其他事件排入执行计划时，它们的调试时间向未来方向延长，这样它们可方便地入堆。 因此，堆结构很适宜用来实现调度器，我的 MIDI 音序器就是用的这个 :-)。</p>
<p>用于实现调度器的各种结构都得到了充分的研究，堆是非常适宜的一种，因为它们的速度相当快，并且几乎是恒定的，最坏的情况与平均情况没有太大差别。 虽然还存在其他总体而言更高效的实现方式，但其最坏的情况却可能非常糟糕。</p>
<p>堆在大磁盘排序中也非常有用。 你应该已经了解大规模排序会有多个“运行轮次”（即预排序的序列，其大小通常与 CPU 内存容量相关），随后这些轮次会进入合并通道，轮次合并的组织往往非常巧妙。 非常重要的一点是初始排序应产生尽可能长的运行轮次。 锦标赛模式是达成此目标的好办法。 如果你使用全部有用内存来进行锦标赛，替换和安排恰好适合当前运行轮次的条目，你将可以对于随机输入生成两倍于内存大小的运行轮次，对于模糊排序的输入还会有更好的效果。</p>
<p>另外，如果你输出磁盘上的第 0 个条目并获得一个可能不适合当前锦标赛的输入（因为其值要“胜过”上一个输出值），它无法被放入堆中，因此堆的尺寸将缩小。 被释放的内存可以被巧妙地立即重用以逐步构建第二个堆，其增长速度与第一个堆的缩减速度正好相同。 当第一个堆完全消失时，你可以切换新堆并启动新的运行轮次。 这样做既聪明又高效！</p>
<p>总之，堆是值得了解的有用内存结构。 我在一些应用中用到了它们，并且认为保留一个 ‘heap’ 模块是很有意义的。 :-)</p>
<h2 id="bisect-—-数组二分查找算法"><a href="#bisect-—-数组二分查找算法" class="headerlink" title="bisect —- 数组二分查找算法"></a><code>bisect</code> —- 数组二分查找算法</h2><p><strong>源代码：</strong> <a href="https://github.com/python/cpython/tree/3.10/Lib/bisect.py" target="_blank" rel="noopener">Lib/bisect.py</a></p>
<hr>
<p>这个模块对有序列表提供了支持，使得他们可以在插入新数据仍然保持有序。对于长列表，如果其包含元素的比较操作十分昂贵的话，这可以是对更常见方法的改进。这个模块叫做 <code>bisect</code> 因为其使用了基本的二分（bisection）算法。源代码也可以作为很棒的算法示例（边界判断也做好啦！）</p>
<p>定义了以下函数：</p>
<p><code>bisect.bisect_left</code>(<em>a</em>, <em>x</em>, <em>lo=0</em>, <em>hi=len(a)</em>, <em>**,</em> key=None*)</p>
<p>在 <em>a</em> 中找到 <em>x</em> 合适的插入点以维持有序。参数 <em>lo</em> 和 <em>hi</em> 可以被用于确定需要考虑的子集；默认情况下整个列表都会被使用。如果 <em>x</em> 已经在 <em>a</em> 里存在，那么插入点会在已存在元素之前（也就是左边）。如果 <em>a</em> 是列表（list）的话，返回值是可以被放在 <code>list.insert()</code> 的第一个参数的。</p>
<p>返回的插入点 <em>i</em> 将数组 <em>a</em> 分成两半，使得 <code>all(val &lt; x for val in a[lo : i])</code> 在左半边而 <code>all(val &gt;= x for val in a[i : hi])</code> 在右半边。</p>
<p><em>key</em> 指定带有单个参数的 key function，用于从每个输入元素中提取比较键。 默认值为 <code>None</code> (直接比较元素)。</p>
<p>在 3.10 版更改: 增加了 <em>key</em> 形参。</p>
<p><code>bisect.bisect_right</code>(<em>a</em>, <em>x</em>, <em>lo=0</em>, <em>hi=len(a)</em>, <em>**,</em> key=None*)</p>
<p><code>bisect.bisect</code>(<em>a</em>, <em>x</em>, <em>lo=0</em>, <em>hi=len(a)</em>)</p>
<p>类似于 <code>bisect_left()</code>，但是返回的插入点是 <em>a</em> 中已存在元素 <em>x</em> 的右侧。</p>
<p>返回的插入点 <em>i</em> 将数组 <em>a</em> 分成两半，使得左半边为 <code>all(val &lt;= x for val in a[lo : i])</code> 而右半边为 <code>all(val &gt; x for val in a[i : hi])</code>。</p>
<p><em>key</em> 指定带有单个参数的 key function，用于从每个输入元素中提取比较键。 默认值为 <code>None</code> (直接比较元素)。</p>
<p>在 3.10 版更改: 增加了 <em>key</em> 形参。</p>
<p><code>bisect.insort_left</code>(<em>a</em>, <em>x</em>, <em>lo=0</em>, <em>hi=len(a)</em>, <em>**,</em> key=None*)</p>
<p>按照已排序顺序将 <em>x</em> 插入到 <em>a</em> 中。</p>
<p><em>key</em> 指定带有单个参数的 key function，用于从每个输入元素中提取比较键。 默认值为 <code>None</code> (直接比较元素)。</p>
<p>此函数首先会运行 <code>bisect_left()</code> 来定位一个插入点。 然后，它会在 <em>a</em> 上运行 <code>insert()</code> 方法在正确的位置插入 <em>x</em> 以保持排序顺序。</p>
<p>请记住 <code>O(log n)</code> 搜索是由缓慢的 O(n) 抛入步骤主导的。</p>
<p>在 3.10 版更改: 增加了 <em>key</em> 形参。</p>
<p><code>bisect.insort_right</code>(<em>a</em>, <em>x</em>, <em>lo=0</em>, <em>hi=len(a)</em>, <em>**,</em> key=None*)</p>
<p><code>bisect.insort</code>(<em>a</em>, <em>x</em>, <em>lo=0</em>, <em>hi=len(a)</em>)</p>
<p>类似于 <code>insort_left()</code>，但是把 <em>x</em> 插入到 <em>a</em> 中已存在元素 <em>x</em> 的右侧。</p>
<p><em>key</em> 指定带有单个参数的 key function，用于从每个输入元素中提取比较键。 默认值为 <code>None</code> (直接比较元素)。</p>
<p>此函数首先会运行 <code>bisect_right()</code> 来定位一个插入点。 然后，它会在 <em>a</em> 上运行 <code>insert()</code> 方法在正确的位置插入 <em>x</em> 以保持排序顺序。</p>
<p>请记住 <code>O(log n)</code> 搜索是由缓慢的 O(n) 抛入步骤主导的。</p>
<p>在 3.10 版更改: 增加了 <em>key</em> 形参。</p>
<h3 id="性能说明"><a href="#性能说明" class="headerlink" title="性能说明"></a>性能说明</h3><p>当使用 <em>bisect()</em> 和 <em>insort()</em> 编写时间敏感的代码时，请记住以下概念。</p>
<ul>
<li>二分法对于搜索一定范围的值是很高效的。 对于定位特定的值，则字典的性能更好。</li>
<li><em>insort()</em> 函数的时间复杂度为 <code>O(n)</code> 因为对数时间的搜索步骤被线性时间的插入步骤所主导。</li>
<li>这些搜索函数都是无状态的并且会在它们被使用后丢弃键函数的结果。 因此，如果在一个循环中使用搜索函数，则键函数可能会在同一个数据元素上被反复调用。 如果键函数速度不快，请考虑用 <code>functools.cache()</code> 来包装它以避免重复计算。 另外，也可以考虑搜索一个预先计算好的键数组来定位插入点（如下面的示例节所演示的）。</li>
</ul>
<h3 id="搜索有序列表"><a href="#搜索有序列表" class="headerlink" title="搜索有序列表"></a>搜索有序列表</h3><p>上面的 <code>bisect()</code> 函数对于找到插入点是有用的，但在一般的搜索任务中可能会有点尴尬。下面 5 个函数展示了如何将其转变成有序列表中的标准查找函数</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">index</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token string">'Locate the leftmost value exactly equal to x'</span>
    i <span class="token operator">=</span> bisect_left<span class="token punctuation">(</span>a<span class="token punctuation">,</span> x<span class="token punctuation">)</span>
    <span class="token keyword">if</span> i <span class="token operator">!=</span> len<span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token operator">and</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> x<span class="token punctuation">:</span>
        <span class="token keyword">return</span> i
    <span class="token keyword">raise</span> ValueError
<span class="token keyword">def</span> <span class="token function">find_lt</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token string">'Find rightmost value less than x'</span>
    i <span class="token operator">=</span> bisect_left<span class="token punctuation">(</span>a<span class="token punctuation">,</span> x<span class="token punctuation">)</span>
    <span class="token keyword">if</span> i<span class="token punctuation">:</span>
        <span class="token keyword">return</span> a<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span>
    <span class="token keyword">raise</span> ValueError
<span class="token keyword">def</span> <span class="token function">find_le</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token string">'Find rightmost value less than or equal to x'</span>
    i <span class="token operator">=</span> bisect_right<span class="token punctuation">(</span>a<span class="token punctuation">,</span> x<span class="token punctuation">)</span>
    <span class="token keyword">if</span> i<span class="token punctuation">:</span>
        <span class="token keyword">return</span> a<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span>
    <span class="token keyword">raise</span> ValueError
<span class="token keyword">def</span> <span class="token function">find_gt</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token string">'Find leftmost value greater than x'</span>
    i <span class="token operator">=</span> bisect_right<span class="token punctuation">(</span>a<span class="token punctuation">,</span> x<span class="token punctuation">)</span>
    <span class="token keyword">if</span> i <span class="token operator">!=</span> len<span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
    <span class="token keyword">raise</span> ValueError
<span class="token keyword">def</span> <span class="token function">find_ge</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token string">'Find leftmost item greater than or equal to x'</span>
    i <span class="token operator">=</span> bisect_left<span class="token punctuation">(</span>a<span class="token punctuation">,</span> x<span class="token punctuation">)</span>
    <span class="token keyword">if</span> i <span class="token operator">!=</span> len<span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
    <span class="token keyword">raise</span> ValueError<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h3><p>函数 <code>bisect()</code> 还可以用于数字表查询。这个例子是使用 <code>bisect()</code> 从一个给定的考试成绩集合里，通过一个有序数字表，查出其对应的字母等级：90 分及以上是 ‘A’，80 到 89 是 ‘B’，以此类推</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">def</span> <span class="token function">grade</span><span class="token punctuation">(</span>score<span class="token punctuation">,</span> breakpoints<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">60</span><span class="token punctuation">,</span> <span class="token number">70</span><span class="token punctuation">,</span> <span class="token number">80</span><span class="token punctuation">,</span> <span class="token number">90</span><span class="token punctuation">]</span><span class="token punctuation">,</span> grades<span class="token operator">=</span><span class="token string">'FDCBA'</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     i <span class="token operator">=</span> bisect<span class="token punctuation">(</span>breakpoints<span class="token punctuation">,</span> score<span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">return</span> grades<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token punctuation">[</span>grade<span class="token punctuation">(</span>score<span class="token punctuation">)</span> <span class="token keyword">for</span> score <span class="token keyword">in</span> <span class="token punctuation">[</span><span class="token number">33</span><span class="token punctuation">,</span> <span class="token number">99</span><span class="token punctuation">,</span> <span class="token number">77</span><span class="token punctuation">,</span> <span class="token number">70</span><span class="token punctuation">,</span> <span class="token number">89</span><span class="token punctuation">,</span> <span class="token number">90</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token string">'F'</span><span class="token punctuation">,</span> <span class="token string">'A'</span><span class="token punctuation">,</span> <span class="token string">'C'</span><span class="token punctuation">,</span> <span class="token string">'C'</span><span class="token punctuation">,</span> <span class="token string">'B'</span><span class="token punctuation">,</span> <span class="token string">'A'</span><span class="token punctuation">,</span> <span class="token string">'A'</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>一种避免重复调用键函数的技巧是搜索一个预先计算好的键函数列表来找出记录的索引:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> data <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token string">'red'</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'blue'</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'yellow'</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'black'</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> data<span class="token punctuation">.</span>sort<span class="token punctuation">(</span>key<span class="token operator">=</span><span class="token keyword">lambda</span> r<span class="token punctuation">:</span> r<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>       <span class="token comment" spellcheck="true"># Or use operator.itemgetter(1).</span>
<span class="token operator">>></span><span class="token operator">></span> keys <span class="token operator">=</span> <span class="token punctuation">[</span>r<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token keyword">for</span> r <span class="token keyword">in</span> data<span class="token punctuation">]</span>         <span class="token comment" spellcheck="true"># Precompute a list of keys.</span>
<span class="token operator">>></span><span class="token operator">></span> data<span class="token punctuation">[</span>bisect_left<span class="token punctuation">(</span>keys<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token punctuation">(</span><span class="token string">'black'</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> data<span class="token punctuation">[</span>bisect_left<span class="token punctuation">(</span>keys<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token punctuation">(</span><span class="token string">'blue'</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> data<span class="token punctuation">[</span>bisect_left<span class="token punctuation">(</span>keys<span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token punctuation">(</span><span class="token string">'red'</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> data<span class="token punctuation">[</span>bisect_left<span class="token punctuation">(</span>keys<span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token punctuation">(</span><span class="token string">'yellow'</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="array-—-高效的数值数组"><a href="#array-—-高效的数值数组" class="headerlink" title="array — 高效的数值数组"></a>array — 高效的数值数组</h2><p>此模块定义了一种对象类型，可以紧凑地表示基本类型值的数组：字符、整数、浮点数等。 数组属于序列类型，其行为与列表非常相似，不同之处在于其中存储的对象类型是受限的。 类型在对象创建时使用单个字符的 <em>类型码</em> 来指定。 已定义的类型码如下：</p>
<table>
<thead>
<tr>
<th align="left">类型码</th>
<th align="left">C 类型</th>
<th align="left">Python 类型</th>
<th align="left">以字节表示的最小尺寸</th>
<th align="left">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>‘b’</code></td>
<td align="left">signed char</td>
<td align="left">int</td>
<td align="left">1</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>‘B’</code></td>
<td align="left">unsigned char</td>
<td align="left">int</td>
<td align="left">1</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>‘u’</code></td>
<td align="left">wchar_t</td>
<td align="left">Unicode 字符</td>
<td align="left">2</td>
<td align="left">(1)</td>
</tr>
<tr>
<td align="left"><code>‘h’</code></td>
<td align="left">signed short</td>
<td align="left">int</td>
<td align="left">2</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>‘H’</code></td>
<td align="left">unsigned short</td>
<td align="left">int</td>
<td align="left">2</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>‘i’</code></td>
<td align="left">signed int</td>
<td align="left">int</td>
<td align="left">2</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>‘I’</code></td>
<td align="left">unsigned int</td>
<td align="left">int</td>
<td align="left">2</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>‘l’</code></td>
<td align="left">signed long</td>
<td align="left">int</td>
<td align="left">4</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>‘L’</code></td>
<td align="left">unsigned long</td>
<td align="left">int</td>
<td align="left">4</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>‘q’</code></td>
<td align="left">signed long long</td>
<td align="left">int</td>
<td align="left">8</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>‘Q’</code></td>
<td align="left">unsigned long long</td>
<td align="left">int</td>
<td align="left">8</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>‘f’</code></td>
<td align="left">float</td>
<td align="left">float</td>
<td align="left">4</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>‘d’</code></td>
<td align="left">double</td>
<td align="left">float</td>
<td align="left">8</td>
<td align="left"></td>
</tr>
</tbody></table>
<p>注释：</p>
<ol>
<li><p>由于平台的不同它可能为 16 位或 32 位。</p>
<p>在 3.9 版更改: <code>array('u')</code> 现在使用 <code>wchar_t</code> 作为 C 类型而不再是已弃用的 <code>Py_UNICODE</code>。 这个改变不会影响其行为，因为 <code>Py_UNICODE</code> 自 Python 3.3 起就是 <code>wchar_t</code> 的别名。</p>
<p>Deprecated since version 3.3, will be removed in version 4.0.</p>
</li>
</ol>
<p>值的实际表示会由机器的架构决定（严格地说是由 C 实现决定）。 实际大小可通过 <code>itemsize</code> 属性来获取。</p>
<p>这个模块定义了以下类型：</p>
<p><em>class</em> <code>array.array</code>(<em>typecode</em>[, <em>initializer</em>])</p>
<p>一个包含由 <em>typecode</em> 限制类型的条目的新数组，并由可选的 <em>initializer</em> 值进行初始化，该值必须为一个列表、bytes-like object 或包含正确类型元素的可迭代对象。</p>
<p>如果给定一个列表或字符串，该 initializer 会被传给新数组的 <code>fromlist()</code>, <code>frombytes()</code> 或 <code>fromunicode()</code> 方法（见下文）以将初始条目添加到数组中。 否则会将可迭代对象作为 initializer 传给 <code>extend()</code> 方法。</p>
<p>引发一个 审计事件 <code>array.__new__</code> 附带参数 <code>typecode</code>, <code>initializer</code>。</p>
<pre><code>array.typecodes</code></pre><p>一个包含所有可用类型码的字符串。</p>
<p>数组对象支持普通的序列操作如索引、切片、拼接和重复等。 当使用切片赋值时，所赋的值必须为具有相同类型码的数组对象；所有其他情况都将引发 <code>TypeError</code>。 数组对象也实现了缓冲区接口，可以用于所有支持 字节类对象 的场合。</p>
<p>以下数据项和方法也受到支持：</p>
<pre><code>array.typecode</code></pre><p>用于创建数组的类型码字符。</p>
<pre><code>array.itemsize</code></pre><p>在内部表示中一个数组项的字节长度。</p>
<p><code>array.append</code>(<em>x</em>)</p>
<p>添加一个值为 <em>x</em> 的新项到数组末尾。</p>
<p><code>array.buffer_info</code>()</p>
<p>返回一个元组 <code>(address, length)</code> 以给出用于存放数组内容的缓冲区元素的当前内存地址和长度。 以字节表示的内存缓冲区大小可通过 <code>array.buffer_info()[1] * array.itemsize</code> 来计算。 这在使用需要内存地址的低层级（因此不够安全） I/O 接口时会很有用，例如某些 <code>ioctl()</code> 操作。 只要数组存在并且没有应用改变长度的操作，返回数值就是有效的。</p>
<p>注解</p>
<p>当在 C 或 C++ 编写的代码中使用数组对象时（这是有效使用此类信息的唯一方式），使用数组对象所支持的缓冲区接口更为适宜。 此方法仅保留用作向下兼容，应避免在新代码中使用。 </p>
<p><code>array.byteswap</code>()</p>
<p>“字节对调”所有数组项。 此方法只支持大小为 1, 2, 4 或 8 字节的值；对于其他值类型将引发 <code>RuntimeError</code>。 它适用于从不同字节序机器所生成的文件中读取数据的情况。</p>
<p><code>array.count</code>(<em>x</em>)</p>
<p>返回 <em>x</em> 在数组中的出现次数。</p>
<p><code>array.extend</code>(<em>iterable</em>)</p>
<p>将来自 <em>iterable</em> 的项添加到数组末尾。 如果 <em>iterable</em> 是另一个数组，它必须具有 <em>完全</em> 相同的类型码；否则将引发 <code>TypeError</code>。 如果 <em>iterable</em> 不是一个数组，则它必须为可迭代对象并且其元素必须为可添加到数组的适当类型。</p>
<p><code>array.frombytes</code>(<em>s</em>)</p>
<p>添加来自字符串的项，将字符串解读为机器值的数组（相当于使用 <code>fromfile()</code> 方法从文件中读取数据）。</p>
<p>3.2 新版功能: <code>fromstring()</code> 重命名为 <code>frombytes()</code> 以使其含义更清晰。</p>
<p><code>array.fromfile</code>(<em>f</em>, <em>n</em>)</p>
<p>从 file object <em>f</em> 中读取 <em>n</em> 项并将它们添加到数组末尾。 如果可用数据少于 <em>n</em> 项，则会引发 <code>EOFError</code>，但可用的项仍然会被插入数组。</p>
<p><code>array.fromlist</code>(<em>list</em>)</p>
<p>添加来自 list 的项。 这等价于 <code>for x in list: a.append(x)</code>，区别在于如果发生类型错误，数组将不会被改变。</p>
<p><code>array.fromunicode</code>(<em>s</em>)</p>
<p>使用来自给定 Unicode 字符串的数组扩展数组。 数组必须是类型为 <code>'u'</code> 的数组；否则将引发 <code>ValueError</code>。 请使用 <code>array.frombytes(unicodestring.encode(enc))</code> 来将 Unicode 数据添加到其他类型的数组。</p>
<p><code>array.index</code>(<em>x</em>[, <em>start</em>[, <em>stop</em>]])</p>
<p>返回最小的 <em>i</em> 使得 <em>i</em> 为数组中首次出现的 <em>x</em> 的索引号。 指定可选参数 <em>start</em> 和 <em>stop</em> 以便在数组的一个子部分内部搜索 <em>x</em>。 如果未找到 <em>x</em> 则会引发 <code>ValueError</code>。</p>
<p>在 3.10 版更改: 添加了可选的 <em>start</em> 和 <em>stop</em> 形参。</p>
<p><code>array.insert</code>(<em>i</em>, <em>x</em>)</p>
<p>将值 <em>x</em> 作为新项插入数组的 <em>i</em> 位置之前。 负值将被视为相对于数组末尾的位置。</p>
<p><code>array.pop</code>([<em>i</em>])</p>
<p>从数组中移除序号为 <em>i</em> 的项并将其返回。 可选参数值默认为 <code>-1</code>，因此默认将移除并返回末尾项。</p>
<p><code>array.remove</code>(<em>x</em>)</p>
<p>从数组中移除首次出现的 <em>x</em>。</p>
<p><code>array.reverse</code>()</p>
<p>反转数组中各项的顺序。</p>
<p><code>array.tobytes</code>()</p>
<p>将数组转换为一个机器值数组并返回其字节表示（即相当与通过 <code>tofile()</code> 方法写入到文件的字节序列。）</p>
<p>3.2 新版功能: <code>tostring()</code> 被重命名为 <code>tobytes()</code> 以使其含义更清晰。</p>
<p><code>array.tofile</code>(<em>f</em>)</p>
<p>将所有项（作为机器值）写入到 file object <em>f</em>。</p>
<p><code>array.tolist</code>()</p>
<p>将数组转换为包含相同项的普通列表。</p>
<p><code>array.tounicode</code>()</p>
<p>将数组转换为一个 Unicode 字符串。 数组必须是类型为 <code>'u'</code> 的数组；否则将引发 <code>ValueError</code>。 请使用 <code>array.tobytes().decode(enc)</code> 来从其他类型的数组生成 Unicode 字符串。</p>
<p>当一个数组对象被打印或转换为字符串时，它会表示为 <code>array(typecode, initializer)</code>。 如果数组为空则 <em>initializer</em> 会被省略，否则如果 <em>typecode</em> 为 <code>'u'</code> 则它是一个字符串，否则它是一个数字列表。 使用 <code>eval()</code> 保证能将字符串转换回具有相同类型和值的数组，只要 <code>array</code> 类已通过 <code>from array import array</code> 被引入。 例如:</p>
<pre class="line-numbers language-python"><code class="language-python">array<span class="token punctuation">(</span><span class="token string">'l'</span><span class="token punctuation">)</span>
array<span class="token punctuation">(</span><span class="token string">'u'</span><span class="token punctuation">,</span> <span class="token string">'hello \u2641'</span><span class="token punctuation">)</span>
array<span class="token punctuation">(</span><span class="token string">'l'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
array<span class="token punctuation">(</span><span class="token string">'d'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token number">3.14</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="weakref-—-弱引用"><a href="#weakref-—-弱引用" class="headerlink" title="weakref —- 弱引用"></a><code>weakref</code> —- 弱引用</h2><p><strong>源码：</strong> <a href="https://github.com/python/cpython/tree/3.10/Lib/weakref.py" target="_blank" rel="noopener">Lib/weakref.py</a></p>
<hr>
<p><code>weakref</code> 模块允许Python程序员创建对象的 <em>weak references</em> 。</p>
<p>在下文中，术语 <em>referent</em> 表示由弱引用引用的对象。</p>
<p>对对象的弱引用不能保证对象存活：当对像的引用只剩弱引用时， garbage collection 可以销毁引用并将其内存重用于其他内容。但是，在实际销毁对象之前，即使没有强引用，弱引用也一直能返回该对象。</p>
<p>弱引用的主要用途是实现保存大对象的高速缓存或映射，但又不希望大对象仅仅因为它出现在高速缓存或映射中而保持存活。</p>
<p>例如，如果您有许多大型二进制图像对象，则可能希望将名称与每个对象关联起来。如果您使用Python字典将名称映射到图像，或将图像映射到名称，则图像对象将保持活动状态，因为它们在字典中显示为值或键。 <code>weakref</code> 模块提供的 <code>WeakKeyDictionary</code> 和 <code>WeakValueDictionary</code> 类可以替代Python字典，使用弱引用来构造映射，这些映射不会仅仅因为它们出现在映射对象中而使对象保持存活。例如，如果一个图像对象是 <code>WeakValueDictionary</code> 中的值，那么当对该图像对象的剩余引用是弱映射对象所持有的弱引用时，垃圾回收可以回收该对象并将其在弱映射对象中相应的条目删除。</p>
<p><code>WeakKeyDictionary</code> 和 <code>WeakValueDictionary</code> 在它们的实现中使用弱引用，在弱引用上设置回调函数，当键或值被垃圾回收回收时通知弱字典。 <code>WeakSet</code> 实现了 <code>set</code> 接口，但像 <code>WeakKeyDictionary</code> 一样，只持有其元素的弱引用。</p>
<p><code>finalize</code> 提供了注册一个对象被垃圾收集时要调用的清理函数的方式。这比在原始弱引用上设置回调函数更简单，因为模块会自动确保对象被回收前终结器一直保持存活。</p>
<p>这些弱容器类型之一或者 <code>finalize</code> 就是大多数程序所需要的 - 通常不需要直接创建自己的弱引用。<code>weakref</code> 模块暴露了低级机制，以便于高级用途。</p>
<p>并非所有对象都可以被弱引用；可以被弱引用的对象包括类实例，用 Python（而不是用 C）编写的函数，实例方法、集合、冻结集合，某些 文件对象，生成器，类型对象，套接字，数组，双端队列，正则表达式模式对象以及代码对象等。</p>
<p>在 3.2 版更改: 添加了对thread.lock，threading.Lock和代码对象的支持。</p>
<p>几个内建类型如 <code>list</code> 和 <code>dict</code> 不直接支持弱引用，但可以通过子类化添加支持:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Dict</span><span class="token punctuation">(</span>dict<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">pass</span>
obj <span class="token operator">=</span> Dict<span class="token punctuation">(</span>red<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> green<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span> blue<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true"># this object is weak referenceable</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p><strong>CPython implementation detail:</strong> 其他内置类型例如 <code>tuple</code> 和 <code>int</code> 不支持弱引用，即使通过子类化也不支持。</p>
<p>Extension types can easily be made to support weak references; see Weak Reference Support.</p>
<p><em>class</em> <code>weakref.ref</code>(<em>object</em>[, <em>callback</em>])</p>
<p>返回对 <em>对象</em> 的弱引用。如果原始对象仍然存活，则可以通过调用引用对象来检索原始对象；如果引用的原始对象不再存在，则调用引用对象将得到 <code>None</code> 。如果提供了 <em>回调</em> 而且值不是 <code>None</code> ，并且返回的弱引用对象仍然存活，则在对象即将终结时将调用回调;弱引用对象将作为回调的唯一参数传递；指示物将不再可用。</p>
<p>许多弱引用也允许针对相同对象来构建。 为每个弱引用注册的回调将按从最近注册的回调到最早注册的回调的顺序被调用。</p>
<p>回调所引发的异常将记录于标准错误输出，但无法被传播；它们会按与对象的 <code>__del__()</code> 方法所引发的异常相同的方式被处理。</p>
<p>如果 <em>object</em> 可哈希，则弱引用也为 hashable。 即使在 <em>object</em> 被删除之后它们仍将保持其哈希值。 如果 <code>hash()</code> 在 <em>object</em> 被删除之后才首次被调用，则该调用将引发 <code>TypeError</code>。</p>
<p>弱引用支持相等检测，但不支持排序比较。 如果被引用对象仍然存在，两个引用具有与它们的被引用对象一致的相等关系（无论 <em>callback</em> 是否相同）。 如果删除了任一被引用对象，则仅在两个引用对象为同一对象时两者才相等。</p>
<p>这是一个可子类化的类型而非一个工厂函数。</p>
<ul>
<li><p><code>__callback__</code></p>
<p>这个只读属性会返回当前关联到弱引用的回调。 如果回调不存在或弱引用的被引用对象已不存在，则此属性的值为 <code>None</code>。</p>
</li>
</ul>
<p>在 3.4 版更改: 添加了 <code>__callback__</code> 属性。</p>
<p><code>weakref.proxy</code>(<em>object</em>[, <em>callback</em>])</p>
<p>返回 <em>object</em> 的一个使用弱引用的代理。 此函数支持在大多数上下文中使用代理，而不要求显式地对所使用的弱引用对象解除引用。 返回的对象类型将为 <code>ProxyType</code> 或 <code>CallableProxyType</code>，具体取决于 <em>object</em> 是否可调用。 Proxy 对象不是 hashable 对象，无论被引用对象是否可哈希；这可避免与它们的基本可变性质相关的多种问题，并可防止它们被用作字典键。 <em>callback</em> 与 <code>ref()</code> 函数的同名形参含义相同。</p>
<p>在 3.8 版更改: 扩展代理对象所支持的运算符，包括矩阵乘法运算符 <code>@</code> 和 <code>@=</code>。</p>
<p><code>weakref.getweakrefcount</code>(<em>object</em>)</p>
<p>返回指向 <em>object</em> 的弱引用和代理的数量。</p>
<p><code>weakref.getweakrefs</code>(<em>object</em>)</p>
<p>返回由指向 <em>object</em> 的所有弱引用和代理构成的列表。</p>
<p><em>class</em> <code>weakref.WeakKeyDictionary</code>([<em>dict</em>])</p>
<p>弱引用键的映射类。 当不再存在对键的强引用时，字典中的条目将被丢弃。 这可被用来将额外数据关联到一个应用中其他部分所拥有的对象而无需在那些对象中添加属性。 这对于重载了属性访问的对象来说特别有用。</p>
<p>在 3.9 版更改: 增加了对 <code>|</code> 和 <code>|=</code> 运算符的支持，相关说明见 <a href="https://www.python.org/dev/peps/pep-0584" target="_blank" rel="noopener"><strong>PEP 584</strong></a>。</p>
<p><code>WeakKeyDictionary</code> 对象具有一个额外方法可以直接公开内部引用。 这些引用不保证在它们被使用时仍然保持“存活”，因此这些引用的调用结果需要在使用前进行检测。 此方法可用于避免创建会导致垃圾回收器将保留键超出实际需要时长的引用。</p>
<p><code>WeakKeyDictionary.keyrefs</code>()</p>
<p>返回包含对键的弱引用的可迭代对象。</p>
<p><em>class</em> <code>weakref.WeakValueDictionary</code>([<em>dict</em>])</p>
<p>弱引用值的映射类。 当不再存在对该值的强引用时，字典中的条目将被丢弃。</p>
<p>在 3.9 版更改: 增加了对 <code>|</code> 和 <code>|=</code> 运算符的支持，相关说明见 <a href="https://www.python.org/dev/peps/pep-0584" target="_blank" rel="noopener"><strong>PEP 584</strong></a>。</p>
<p><code>WeakValueDictionary</code> 对象具有一个额外方法，此方法存在与 <code>WeakKeyDictionary</code> 对象的 <code>keyrefs()</code> 方法相同的问题。</p>
<p><code>WeakValueDictionary.valuerefs</code>()</p>
<p>返回包含对值的弱引用的可迭代对象。</p>
<p><em>class</em> <code>weakref.WeakSet</code>([<em>elements</em>])</p>
<p>保持对其元素弱引用的集合类。 当不再有对某个元素的强引用时元素将被丢弃。</p>
<p><em>class</em> <code>weakref.WeakMethod</code>(<em>method</em>)</p>
<p>一个模拟对绑定方法（即在类中定义并在实例中查找的方法）进行弱引用的自定义 <code>ref</code> 子类。 由于绑定方法是临时性的，标准弱引用无法保持它。 <code>WeakMethod</code> 包含特别代码用来重新创建绑定方法，直到对象或初始函数被销毁:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">class</span> <span class="token class-name">C</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">def</span> <span class="token function">method</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"method called!"</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> c <span class="token operator">=</span> C<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> r <span class="token operator">=</span> weakref<span class="token punctuation">.</span>ref<span class="token punctuation">(</span>c<span class="token punctuation">.</span>method<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> r<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> r <span class="token operator">=</span> weakref<span class="token punctuation">.</span>WeakMethod<span class="token punctuation">(</span>c<span class="token punctuation">.</span>method<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> r<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">&lt;</span>bound method C<span class="token punctuation">.</span>method of <span class="token operator">&lt;</span>__main__<span class="token punctuation">.</span>C object at <span class="token number">0x7fc859830220</span><span class="token operator">>></span>
<span class="token operator">>></span><span class="token operator">></span> r<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
method called!
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">del</span> c
<span class="token operator">>></span><span class="token operator">></span> gc<span class="token punctuation">.</span>collect<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token number">0</span>
<span class="token operator">>></span><span class="token operator">></span> r<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>3.4 新版功能.</p>
<p><em>class</em> <code>weakref.finalize</code>(<em>obj</em>, <em>func</em>, <em>/</em>, <em>\</em>args<em>,</em> <em>*kwargs</em>)</p>
<p>返回一个可调用的终结器对象，该对象将在 <em>obj</em> 作为垃圾回收时被调用。 与普通的弱引用不同，终结器将总是存活，直到引用对象被回收，这极大地简化了生存期管理。</p>
<p>终结器总是被视为 <em>存活</em> 直到它被调用（显式调用或在垃圾回收时隐式调用），调用之后它将 <em>死亡</em>。 调用存活的终结器将返回 <code>func(*arg, **kwargs)</code> 的求值结果，而调用死亡的终结器将返回 <code>None</code>。</p>
<p>在垃圾收集期间由终结器回调所引发异常将显示于标准错误输出，但无法被传播。 它们会按与对象的 <code>__del__()</code> 方法或弱引用的回调所引发异常相同的方式被处理。</p>
<p>当程序退出时，剩余的存活终结器会被调用，除非它们的 <code>atexit</code> 属性已被设为假值。 它们会按与创建时相反的顺序被调用。</p>
<p>终结器在 interpreter shutdown 的后期绝不会发起调用其回调函数，此时模块全局变量很可能已被替换为 <code>None</code>。</p>
<ul>
<li><p><code>__call__</code>()</p>
<p>如果 <em>self</em> 为存活状态则将其标记为已死亡，并返回调用 <code>func(*args, **kwargs)</code> 的结果。 如果 <em>self</em> 已死亡则返回 <code>None</code>。</p>
</li>
<li><p><code>detach</code>()</p>
<p>如果 <em>self</em> 为存活状态则将其标记为已死亡，并返回元组 <code>(obj, func, args, kwargs)</code>。 如果 <em>self</em> 已死亡则返 <code>None</code>。</p>
</li>
<li><p><code>peek</code>()</p>
<p>如果 <em>self</em> 为存活状态则返回元组 <code>(obj, func, args, kwargs)</code>。 如果 <em>self</em> 已死亡则返回 <code>None</code>。</p>
</li>
<li><p><code>alive</code></p>
<p>如果终结器为存活状态则该特征属性为真值，否则为假值。</p>
</li>
<li><p><code>atexit</code></p>
<p>一个可写的布尔型特征属性，默认为真值。 当程序退出时，它会调用所有 <code>atexit</code> 为真值的剩余存活终结器。 它们会按与创建时相反的顺序被调用。</p>
</li>
</ul>
<p>注解</p>
<p>很重要的一点是确保 <em>func</em>, <em>args</em> 和 <em>kwargs</em> 不拥有任何对 <em>obj</em> 的引用，无论是直接的或是间接的，否则的话 <em>obj</em> 将永远不会被作为垃圾回收。 特别地，<em>func</em> 不应当是 <em>obj</em> 的一个绑定方法。</p>
<p>3.4 新版功能.</p>
<pre><code>weakref.ReferenceType</code></pre><p>弱引用对象的类型对象。</p>
<pre><code>weakref.ProxyType</code></pre><p>不可调用对象的代理的类型对象。</p>
<pre><code>weakref.CallableProxyType</code></pre><p>可调用对象的代理的类型对象。</p>
<pre><code>weakref.ProxyTypes</code></pre><p>包含所有代理的类型对象的序列。 这可以用于更方便地检测一个对象是否是代理，而不必依赖于两种代理对象的名称。</p>
<p>参见</p>
<p><a href="https://www.python.org/dev/peps/pep-0205" target="_blank" rel="noopener"><strong>PEP 205</strong></a> - 弱引用</p>
<p>此特性的提议和理由，包括早期实现的链接和其他语言中类似特性的相关信息。</p>
<h3 id="弱引用对象"><a href="#弱引用对象" class="headerlink" title="弱引用对象"></a>弱引用对象</h3><p>弱引用对象没有 <code>ref.__callback__</code> 以外的方法和属性。 一个弱引用对象如果存在，就允许通过调用它来获取引用:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> weakref
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">class</span> <span class="token class-name">Object</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">pass</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> o <span class="token operator">=</span> Object<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> r <span class="token operator">=</span> weakref<span class="token punctuation">.</span>ref<span class="token punctuation">(</span>o<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> o2 <span class="token operator">=</span> r<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> o <span class="token keyword">is</span> o2
<span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果引用已不存在，则调用引用对象将返回 <code>None</code>:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">del</span> o<span class="token punctuation">,</span> o2
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>r<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
None<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>检测一个弱引用对象是否仍然存在应该使用表达式 <code>ref() is not None</code>。 通常，需要使用引用对象的应用代码应当遵循这样的模式:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># r is a weak reference object</span>
o <span class="token operator">=</span> r<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">if</span> o <span class="token keyword">is</span> None<span class="token punctuation">:</span>
    <span class="token comment" spellcheck="true"># referent has been garbage collected</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Object has been deallocated; can't frobnicate."</span><span class="token punctuation">)</span>
<span class="token keyword">else</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Object is still live!"</span><span class="token punctuation">)</span>
    o<span class="token punctuation">.</span>do_something_useful<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>使用单独的“存活”测试会在多线程应用中制造竞争条件；其他线程可能导致某个弱引用在该弱引用被调用前就失效；上述的写法在多线程应用和单线程应用中都是安全的。</p>
<p>特别版本的 <code>ref</code> 对象可以通过子类化来创建。 在 <code>WeakValueDictionary</code> 的实现中就使用了这种方式来减少映射中每个条目的内存开销。 这对于将附加信息关联到引用的情况最为适用，但也可以被用于在调用中插入额外处理来提取引用。</p>
<p>这个例子演示了如何将 <code>ref</code> 的一个子类用于存储有关对象的附加信息并在引用被访问时影响其所返回的值:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> weakref
<span class="token keyword">class</span> <span class="token class-name">ExtendedRef</span><span class="token punctuation">(</span>weakref<span class="token punctuation">.</span>ref<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> ob<span class="token punctuation">,</span> callback<span class="token operator">=</span>None<span class="token punctuation">,</span> <span class="token operator">/</span><span class="token punctuation">,</span> <span class="token operator">**</span>annotations<span class="token punctuation">)</span><span class="token punctuation">:</span>
        super<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span>ob<span class="token punctuation">,</span> callback<span class="token punctuation">)</span>
        self<span class="token punctuation">.</span>__counter <span class="token operator">=</span> <span class="token number">0</span>
        <span class="token keyword">for</span> k<span class="token punctuation">,</span> v <span class="token keyword">in</span> annotations<span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            setattr<span class="token punctuation">(</span>self<span class="token punctuation">,</span> k<span class="token punctuation">,</span> v<span class="token punctuation">)</span>
    <span class="token keyword">def</span> <span class="token function">__call__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token triple-quoted-string string">"""Return a pair containing the referent and the number of
        times the reference has been called.
        """</span>
        ob <span class="token operator">=</span> super<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>__call__<span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">if</span> ob <span class="token keyword">is</span> <span class="token operator">not</span> None<span class="token punctuation">:</span>
            self<span class="token punctuation">.</span>__counter <span class="token operator">+=</span> <span class="token number">1</span>
            ob <span class="token operator">=</span> <span class="token punctuation">(</span>ob<span class="token punctuation">,</span> self<span class="token punctuation">.</span>__counter<span class="token punctuation">)</span>
        <span class="token keyword">return</span> ob<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><p>这个简单的例子演示了一个应用如何使用对象 ID 来提取之前出现过的对象。 然后对象的 ID 可以在其它数据结构中使用，而无须强制对象保持存活，但处于存活状态的对象也仍然可以通过 ID 来提取。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> weakref
_id2obj_dict <span class="token operator">=</span> weakref<span class="token punctuation">.</span>WeakValueDictionary<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">remember</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">:</span>
    oid <span class="token operator">=</span> id<span class="token punctuation">(</span>obj<span class="token punctuation">)</span>
    _id2obj_dict<span class="token punctuation">[</span>oid<span class="token punctuation">]</span> <span class="token operator">=</span> obj
    <span class="token keyword">return</span> oid
<span class="token keyword">def</span> <span class="token function">id2obj</span><span class="token punctuation">(</span>oid<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">return</span> _id2obj_dict<span class="token punctuation">[</span>oid<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="终结器对象"><a href="#终结器对象" class="headerlink" title="终结器对象"></a>终结器对象</h3><p>使用 <code>finalize</code> 的主要好处在于它能更简便地注册回调函数，而无须保留所返回的终结器对象。 例如</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> weakref
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">class</span> <span class="token class-name">Object</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">pass</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> kenny <span class="token operator">=</span> Object<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> weakref<span class="token punctuation">.</span>finalize<span class="token punctuation">(</span>kenny<span class="token punctuation">,</span> <span class="token keyword">print</span><span class="token punctuation">,</span> <span class="token string">"You killed Kenny!"</span><span class="token punctuation">)</span>  
<span class="token operator">&lt;</span>finalize object at <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span> <span class="token keyword">for</span> <span class="token string">'Object'</span> at <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">></span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">del</span> kenny
You killed Kenny!<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>终结器也可以被直接调用。 但是终结器最多只能对回调函数发起一次调用。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">def</span> <span class="token function">callback</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> z<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"CALLBACK"</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">return</span> x <span class="token operator">+</span> y <span class="token operator">+</span> z
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> obj <span class="token operator">=</span> Object<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> f <span class="token operator">=</span> weakref<span class="token punctuation">.</span>finalize<span class="token punctuation">(</span>obj<span class="token punctuation">,</span> callback<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> z<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">assert</span> f<span class="token punctuation">.</span>alive
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">assert</span> f<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">6</span>
CALLBACK
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">assert</span> <span class="token operator">not</span> f<span class="token punctuation">.</span>alive
<span class="token operator">>></span><span class="token operator">></span> f<span class="token punctuation">(</span><span class="token punctuation">)</span>                     <span class="token comment" spellcheck="true"># callback not called because finalizer dead</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">del</span> obj                 <span class="token comment" spellcheck="true"># callback not called because finalizer dead</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>你可以使用 <code>detach()</code> 方法来注销一个终结器。 该方法将销毁终结器并返回其被创建时传给构造器的参数。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> obj <span class="token operator">=</span> Object<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> f <span class="token operator">=</span> weakref<span class="token punctuation">.</span>finalize<span class="token punctuation">(</span>obj<span class="token punctuation">,</span> callback<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> z<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> f<span class="token punctuation">.</span>detach<span class="token punctuation">(</span><span class="token punctuation">)</span>                                           
<span class="token punctuation">(</span><span class="token operator">&lt;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>Object object <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">></span><span class="token punctuation">,</span> <span class="token operator">&lt;</span>function callback <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">></span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token string">'z'</span><span class="token punctuation">:</span> <span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> newobj<span class="token punctuation">,</span> func<span class="token punctuation">,</span> args<span class="token punctuation">,</span> kwargs <span class="token operator">=</span> _
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">assert</span> <span class="token operator">not</span> f<span class="token punctuation">.</span>alive
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">assert</span> newobj <span class="token keyword">is</span> obj
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">assert</span> func<span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">6</span>
CALLBACK<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>除非你将 <code>atexit</code> 属性设为 <code>False</code>，否则终结器在程序退出时如果仍然存活就将被调用。 例如</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> obj <span class="token operator">=</span> Object<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> weakref<span class="token punctuation">.</span>finalize<span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token keyword">print</span><span class="token punctuation">,</span> <span class="token string">"obj dead or exiting"</span><span class="token punctuation">)</span>
<span class="token operator">&lt;</span>finalize object at <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span> <span class="token keyword">for</span> <span class="token string">'Object'</span> at <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">></span>
<span class="token operator">>></span><span class="token operator">></span> exit<span class="token punctuation">(</span><span class="token punctuation">)</span>
obj dead <span class="token operator">or</span> exiting<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="比较终结器与-del-方法"><a href="#比较终结器与-del-方法" class="headerlink" title="比较终结器与 __del__() 方法"></a>比较终结器与 <code>__del__()</code> 方法</h3><p>假设我们想创建一个类，用它的实例来代表临时目录。 当以下事件中的某一个发生时，这个目录应当与其内容一起被删除：</p>
<ul>
<li>对象被作为垃圾回收，</li>
<li>对象的 <code>remove()</code> 方法被调用，或</li>
<li>程序退出。</li>
</ul>
<p>我们可以尝试使用 <code>__del__()</code> 方法来实现这个类，如下所示:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">TempDir</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>name <span class="token operator">=</span> tempfile<span class="token punctuation">.</span>mkdtemp<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">def</span> <span class="token function">remove</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> self<span class="token punctuation">.</span>name <span class="token keyword">is</span> <span class="token operator">not</span> None<span class="token punctuation">:</span>
            shutil<span class="token punctuation">.</span>rmtree<span class="token punctuation">(</span>self<span class="token punctuation">.</span>name<span class="token punctuation">)</span>
            self<span class="token punctuation">.</span>name <span class="token operator">=</span> None
    @property
    <span class="token keyword">def</span> <span class="token function">removed</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> self<span class="token punctuation">.</span>name <span class="token keyword">is</span> None
    <span class="token keyword">def</span> <span class="token function">__del__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>remove<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>从 Python 3.4 开始，<code>__del__()</code> 方法不会再阻止循环引用被作为垃圾回收，并且模块全局变量在 interpreter shutdown 期间不会被强制设为 <code>None</code>。 因此这段代码在 CPython 上应该会正常运行而不会出现任何问题。</p>
<p>然而，<code>__del__()</code> 方法的处理会严重地受到具体实现的影响，因为它依赖于解释器垃圾回收实现方式的内部细节。</p>
<p>更健壮的替代方式可以是定义一个终结器，只引用它所需要的特定函数和对象，而不是获取对整个对象状态的访问权:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">TempDir</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>name <span class="token operator">=</span> tempfile<span class="token punctuation">.</span>mkdtemp<span class="token punctuation">(</span><span class="token punctuation">)</span>
        self<span class="token punctuation">.</span>_finalizer <span class="token operator">=</span> weakref<span class="token punctuation">.</span>finalize<span class="token punctuation">(</span>self<span class="token punctuation">,</span> shutil<span class="token punctuation">.</span>rmtree<span class="token punctuation">,</span> self<span class="token punctuation">.</span>name<span class="token punctuation">)</span>
    <span class="token keyword">def</span> <span class="token function">remove</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>_finalizer<span class="token punctuation">(</span><span class="token punctuation">)</span>
    @property
    <span class="token keyword">def</span> <span class="token function">removed</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token operator">not</span> self<span class="token punctuation">.</span>_finalizer<span class="token punctuation">.</span>alive<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>像这样定义后，我们的终结器将只接受一个对其完成正确清理目录任务所需细节的引用。 如果对象一直未被作为垃圾回收，终结器仍会在退出时被调用。</p>
<p>基于弱引用的终结器还具有另一项优势，就是它们可被用来为定义由第三方控制的类注册终结器，例如当一个模块被卸载时运行特定代码:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> weakref<span class="token punctuation">,</span> sys
<span class="token keyword">def</span> <span class="token function">unloading_module</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token comment" spellcheck="true"># implicit reference to the module globals from the function body</span>
weakref<span class="token punctuation">.</span>finalize<span class="token punctuation">(</span>sys<span class="token punctuation">.</span>modules<span class="token punctuation">[</span>__name__<span class="token punctuation">]</span><span class="token punctuation">,</span> unloading_module<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>注解</p>
<p>如果当程序退出时你恰好在守护线程中创建终结器对象，则有可能该终结器不会在退出时被调用。 但是，在一个守护线程中 <code>atexit.register()</code>, <code>try: ... finally: ...</code> 和 <code>with: ...</code> 同样不能保证执行清理。</p>
<h2 id="types-—-动态类型创建和内置类型名称"><a href="#types-—-动态类型创建和内置类型名称" class="headerlink" title="types —- 动态类型创建和内置类型名称"></a><code>types</code> —- 动态类型创建和内置类型名称</h2><p><strong>源代码:</strong> <a href="https://github.com/python/cpython/tree/3.10/Lib/types.py" target="_blank" rel="noopener">Lib/types.py</a></p>
<hr>
<p>此模块定义了一些工具函数，用于协助动态创建新的类型。</p>
<p>它还为某些对象类型定义了名称，这些名称由标准 Python 解释器所使用，但并不像内置的 <a href="https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#int" target="_blank" rel="noopener"><code>int</code></a> 或 <a href="https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#str" target="_blank" rel="noopener"><code>str</code></a> 那样对外公开。</p>
<p>最后，它还额外提供了一些类型相关但重要程度不足以作为内置对象的工具类和函数。</p>
<h3 id="动态类型创建"><a href="#动态类型创建" class="headerlink" title="动态类型创建"></a>动态类型创建</h3><p><code>types.new_class</code>(<em>name</em>, <em>bases=()</em>, <em>kwds=None</em>, <em>exec_body=None</em>)</p>
<p>使用适当的元类动态地创建一个类对象。</p>
<p>前三个参数是组成类定义头的部件：类名称，基类 (有序排列)，关键字参数 (例如 <code>metaclass</code>)。</p>
<p><em>exec_body</em> 参数是一个回调函数，用于填充新创建类的命名空间。 它应当接受类命名空间作为其唯一的参数并使用类内容直接更新命名空间。 如果未提供回调函数，则它就等效于传入 <code>lambda ns: None</code>。</p>
<p>3.3 新版功能.</p>
<p><code>types.prepare_class</code>(<em>name</em>, <em>bases=()</em>, <em>kwds=None</em>)</p>
<p>计算适当的元类并创建类命名空间。</p>
<p>参数是组成类定义头的部件：类名称，基类 (有序排列) 以及关键字参数 (例如 <code>metaclass</code>)。</p>
<p>返回值是一个 3 元组: <code>metaclass, namespace, kwds</code></p>
<p><em>metaclass</em> 是适当的元类，<em>namespace</em> 是预备好的类命名空间而 <em>kwds</em> 是所传入 <em>kwds</em> 参数移除每个 <code>'metaclass'</code> 条目后的已更新副本。 如果未传入 <em>kwds</em> 参数，这将为一个空字典。</p>
<p>3.3 新版功能.</p>
<p>在 3.6 版更改: 所返回元组中 <code>namespace</code> 元素的默认值已被改变。 现在当元类没有 <code>__prepare__</code> 方法时将会使用一个保留插入顺序的映射。</p>
<p><a href="https://www.python.org/dev/peps/pep-3115" target="_blank" rel="noopener"><strong>PEP 3115</strong></a> - Python 3000 中的元类</p>
<p>引入 <code>__prepare__</code> 命名空间钩子</p>
<p><code>types.resolve_bases</code>(<em>bases</em>)</p>
<p>动态地解析 MRO 条目，具体描述见 <a href="https://www.python.org/dev/peps/pep-0560" target="_blank" rel="noopener"><strong>PEP 560</strong></a>。</p>
<p>此函数会在 <em>bases</em> 中查找不是 <code>type</code> 的实例的项，并返回一个元组，其中每个具有 <code>__mro_entries__</code> 方法的此种对象对象将被替换为调用该方法解包后的结果。 如果一个 <em>bases</em> 项是 <code>type</code> 的实例，或它不具有 <code>__mro_entries__</code> 方法，则它将不加改变地被包含在返回的元组中。</p>
<p>3.7 新版功能.</p>
<p><a href="https://www.python.org/dev/peps/pep-0560" target="_blank" rel="noopener"><strong>PEP 560</strong></a> - 对 typing 模块和泛型类型的核心支持</p>
<h3 id="标准解释器类型"><a href="#标准解释器类型" class="headerlink" title="标准解释器类型"></a>标准解释器类型</h3><p>此模块为许多类型提供了实现 Python 解释器所要求的名称。 它刻意地避免了包含某些仅在处理过程中偶然出现的类型，例如 <code>listiterator</code> 类型。</p>
<p>此种名称的典型应用如 <code>isinstance()</code> 或 <code>issubclass()</code> 检测。</p>
<p>如果你要实例化这些类型中的任何一种，请注意其签名在不同 Python 版本之间可能出现变化。</p>
<p>以下类型有相应的标准名称定义：</p>
<pre><code>types.NoneType</code></pre><p><code>None</code> 的类型。</p>
<p>3.10 新版功能.</p>
<pre><code>types.FunctionType
types.LambdaType</code></pre><p>用户自定义函数以及由 <code>lambda</code> 表达式所创建函数的类型。</p>
<p>引发一个 审计事件 <code>function.__new__</code>，附带参数 <code>code</code>。</p>
<p>此审计事件只会被函数对象的直接实例化引发，而不会被普通编译所引发。</p>
<pre><code>types.GeneratorType</code></pre><p>generator 迭代器对象的类型，由生成器函数创建。</p>
<pre><code>types.CoroutineType</code></pre><p>coroutine 对象的类型，由 <code>async def</code> 函数创建。</p>
<p>3.5 新版功能.</p>
<pre><code>types.AsyncGeneratorType</code></pre><p>asynchronous generator 迭代器对象的类型，由异步生成器函数创建。</p>
<p>3.6 新版功能.</p>
<p><em>class</em> <code>types.CodeType</code>(<em>**kwargs</em>)</p>
<p>代码对象的类型，例如 <code>compile()</code> 的返回值。</p>
<p>引发 审计事件 <code>code.__new__</code> 附带参数 <code>code</code>, <code>filename</code>, <code>name</code>, <code>argcount</code>, <code>posonlyargcount</code>, <code>kwonlyargcount</code>, <code>nlocals</code>, <code>stacksize</code>, <code>flags</code>。</p>
<p>请注意被审计的参数可能与初始化代码所要求的名称或位置不相匹配。 审计事件只会被代码对象的直接实例化引发，而不会被普通编译所引发。</p>
<ul>
<li><p><code>replace</code>(<em>**kwargs</em>)</p>
<p>返回代码对象的一个副本，使用指定的新字段值。</p>
<p>3.8 新版功能.</p>
</li>
</ul>
<pre><code>types.CellType</code></pre><p>单元对象的类型：这种对象被用作函数中自由变量的容器。</p>
<p>3.8 新版功能.</p>
<pre><code>types.MethodType</code></pre><p>用户自定义类实例方法的类型。</p>
<pre><code>types.BuiltinFunctionType
types.BuiltinMethodType</code></pre><p>内置函数例如 <code>len()</code> 或 <code>sys.exit()</code> 以及内置类方法的类型。 （这里所说的“内置”是指“以 C 语言编写”。）</p>
<pre><code>types.WrapperDescriptorType</code></pre><p>某些内置数据类型和基类的方法的类型，例如 <code>object.__init__()</code> 或 <code>object.__lt__()</code>。</p>
<p>3.7 新版功能.</p>
<pre><code>types.MethodWrapperType</code></pre><p>某些内置数据类型和基类的 <em>绑定</em> 方法的类型。 例如 <code>object().__str__</code> 所属的类型。</p>
<p>3.7 新版功能.</p>
<pre><code>types.NotImplementedType</code></pre><p><code>NotImplemented</code> 的类型。</p>
<p>3.10 新版功能.</p>
<pre><code>types.MethodDescriptorType</code></pre><p>某些内置数据类型方法例如 <code>str.join()</code> 的类型。</p>
<p>3.7 新版功能.</p>
<pre><code>types.ClassMethodDescriptorType</code></pre><p>某些内置数据类型 <em>非绑定</em> 类方法例如 <code>dict.__dict__['fromkeys']</code> 的类型。</p>
<p>3.7 新版功能.</p>
<p><em>class</em> <code>types.ModuleType</code>(<em>name</em>, <em>doc=None</em>)</p>
<p>模块 的类型。 构造器接受待创建模块的名称并以其 docstring 作为可选参数。</p>
<p>注解</p>
<p>如果你希望设置各种由导入控制的属性，请使用 <code>importlib.util.module_from_spec()</code> 来创建一个新模块。</p>
<ul>
<li><p><code>__doc__</code></p>
<p>模块的 docstring。 默认为 <code>None</code>。</p>
</li>
<li><p><code>__loader__</code></p>
<p>用于加载模块的 loader。 默认为 <code>None</code>。</p>
<p>此属性会匹配保存在 attr:<strong>spec</strong> 对象中的 <code>importlib.machinery.ModuleSpec.loader</code>。</p>
<p>注解</p>
<p>未来的 Python 版本可能停止默认设置此属性。 为了避免这个潜在变化的影响，如果你明确地需要使用此属性则推荐改从 <code>__spec__</code> 属性读取或使用 <code>getattr(module, "__loader__", None)</code>。</p>
<p>在 3.4 版更改: 默认为 <code>None</code>。 之前该属性为可选项。</p>
</li>
<li><p><code>__name__</code></p>
<p>萨芬内容名称。 应当能匹配 <code>importlib.machinery.ModuleSpec.name</code>。</p>
</li>
<li><p><code>__package__</code></p>
<p>一个模块所属的 package。 如果模块为最高层级的（即不是任何特定包的组成部分）则该属性应设为 <code>''</code>，否则它应设为特定包的名称 (如果模块本身也是一个包则名称可以为 <code>__name__</code>)。 默认为 <code>None</code>。</p>
<p>此属性会匹配保存在 attr:<strong>spec</strong> 对象中的 <code>importlib.machinery.ModuleSpec.parent</code>。</p>
<p>注解</p>
<p>未来的 Python 版本可能停止默认设置此属性。 为了避免这个潜在变化的影响，如果你明确地需要使用此属性则推荐改从 <code>__spec__</code> 属性读取或使用 <code>getattr(module, "__package__", None)</code>。</p>
<p>在 3.4 版更改: 默认为 <code>None</code>。 之前该属性为可选项。</p>
</li>
<li><p><code>__spec__</code></p>
<p>模块的导入系统相关状态的记录。 应当是一个 <code>importlib.machinery.ModuleSpec</code> 的实例。</p>
<p>3.4 新版功能.</p>
</li>
</ul>
<pre><code>types.EllipsisType</code></pre><p><code>Ellipsis</code> 的类型。</p>
<p>3.10 新版功能.</p>
<p><em>class</em> <code>types.GenericAlias</code>(<em>t_origin</em>, <em>t_args</em>)</p>
<p>形参化泛型 的类型，例如 <code>list[int]</code>。</p>
<p><code>t_origin</code> 应当是一个非形参化的泛型类，例如 <code>list</code>, <code>tuple</code> 或 <code>dict</code>。 <code>t_args</code> 应当是一个形参化 <code>t_origin</code> 的 <code>tuple</code> (长度可以为 1):</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> types <span class="token keyword">import</span> GenericAlias
<span class="token operator">>></span><span class="token operator">></span> list<span class="token punctuation">[</span>int<span class="token punctuation">]</span> <span class="token operator">==</span> GenericAlias<span class="token punctuation">(</span>list<span class="token punctuation">,</span> <span class="token punctuation">(</span>int<span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token boolean">True</span>
<span class="token operator">>></span><span class="token operator">></span> dict<span class="token punctuation">[</span>str<span class="token punctuation">,</span> int<span class="token punctuation">]</span> <span class="token operator">==</span> GenericAlias<span class="token punctuation">(</span>dict<span class="token punctuation">,</span> <span class="token punctuation">(</span>str<span class="token punctuation">,</span> int<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>3.9 新版功能.</p>
<p>在 3.9.2 版更改: 此类型现在可以被子类化。</p>
<pre><code>types.UnionType</code></pre><p>合并类型表达式 的类型。</p>
<p>3.10 新版功能.</p>
<p><em>class</em> <code>types.TracebackType</code>(<em>tb_next</em>, <em>tb_frame</em>, <em>tb_lasti</em>, <em>tb_lineno</em>)</p>
<p>回溯对象的类型，例如 <code>sys.exc_info()[2]</code> 中的对象。</p>
<pre><code>types.FrameType</code></pre><p>帧对象的类型，例如 <code>tb.tb_frame</code> 中的对象，其中 <code>tb</code> 是一个回溯对象。</p>
<pre><code>types.GetSetDescriptorType</code></pre><p>使用 <code>PyGetSetDef</code> 在扩展模块中定义的对象的类型，例如 <code>FrameType.f_locals</code> 或 <code>array.array.typecode</code>。 此类型被用作对象属性的描述器；它的目的与 <code>property</code> 类型相同，但专门针对在扩展模块中定义的类。</p>
<pre><code>types.MemberDescriptorType</code></pre><p>使用 <code>PyMemberDef</code> 在扩展模块中定义的对象的类型，例如 <code>datetime.timedelta.days</code>。 此类型被用作使用标准转换函数的简单 C 数据成员的描述器；它的目的与 <code>property</code> 类型相同，但专门针对在扩展模块中定义的类。</p>
<p><strong>CPython implementation detail:</strong> 在 Python 的其它实现中，此类型可能与 <code>GetSetDescriptorType</code> 完全相同。</p>
<p><em>class</em> <code>types.MappingProxyType</code>(<em>mapping</em>)</p>
<p>一个映射的只读代理。 它提供了对映射条目的动态视图，这意味着当映射发生改变时，视图会反映这些改变。</p>
<p>3.3 新版功能.</p>
<p>在 3.9 版更改: 更新为支持 <a href="https://www.python.org/dev/peps/pep-0584" target="_blank" rel="noopener"><strong>PEP 584</strong></a> 所新增的合并 (<code>|</code>) 运算符，它会简单地委托给下层的映射。</p>
<ul>
<li><p><code>key in proxy</code></p>
<p>如果下层的映射中存在键 <em>key</em> 则返回 <code>True</code>，否则返回 <code>False</code>。</p>
</li>
<li><p><code>proxy[key]</code></p>
<p>返回下层的映射中以 <em>key</em> 为键的项。 如果下层的映射中不存在键 <em>key</em> 则引发 <code>KeyError</code>。</p>
</li>
<li><p><code>iter(proxy)</code></p>
<p>返回由下层映射的键为元素的迭代器。 这是 <code>iter(proxy.keys())</code> 的快捷方式。</p>
</li>
<li><p><code>len(proxy)</code></p>
<p>返回下层映射中的项数。</p>
</li>
<li><p><code>copy</code>()</p>
<p>返回下层映射的浅拷贝。</p>
</li>
<li><p><code>get</code>(<em>key</em>[, <em>default</em>])</p>
<p>如果 <em>key</em> 存在于下层映射中则返回 <em>key</em> 的值，否则返回 <em>default*。 如果 *default</em> 未给出则默认为 <code>None</code>，因而此方法绝不会引发 <code>KeyError</code>。</p>
</li>
<li><p><code>items</code>()</p>
<p>返回由下层映射的项 (<code>(键, 值)</code> 对) 组成的一个新视图。</p>
</li>
<li><p><code>keys</code>()</p>
<p>返回由下层映射的键组成的一个新视图。</p>
</li>
<li><p><code>values</code>()</p>
<p>返回由下层映射的值组成的一个新视图。</p>
</li>
<li><p><code>reversed(proxy)</code></p>
<p>返回一个包含下层映射的键的反向迭代器。</p>
<p>3.9 新版功能.</p>
</li>
</ul>
<h3 id="附加工具类和函数"><a href="#附加工具类和函数" class="headerlink" title="附加工具类和函数"></a>附加工具类和函数</h3><p><em>class</em> <code>types.SimpleNamespace</code></p>
<p>一个简单的 <code>object</code> 子类，提供了访问其命名空间的属性，以及一个有意义的 repr。</p>
<p>不同于 <code>object</code>，对于 <code>SimpleNamespace</code> 你可以添加和移除属性。 如果一个 <code>SimpleNamespace</code> 对象使用关键字参数进行初始化，这些参数会被直接加入下层命名空间。</p>
<p>此类型大致等价于以下代码:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">SimpleNamespace</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> <span class="token operator">/</span><span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>__dict__<span class="token punctuation">.</span>update<span class="token punctuation">(</span>kwargs<span class="token punctuation">)</span>
    <span class="token keyword">def</span> <span class="token function">__repr__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        items <span class="token operator">=</span> <span class="token punctuation">(</span>f<span class="token string">"{k}={v!r}"</span> <span class="token keyword">for</span> k<span class="token punctuation">,</span> v <span class="token keyword">in</span> self<span class="token punctuation">.</span>__dict__<span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token string">"{}({})"</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>type<span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">.</span>__name__<span class="token punctuation">,</span> <span class="token string">", "</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>items<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">def</span> <span class="token function">__eq__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> other<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> isinstance<span class="token punctuation">(</span>self<span class="token punctuation">,</span> SimpleNamespace<span class="token punctuation">)</span> <span class="token operator">and</span> isinstance<span class="token punctuation">(</span>other<span class="token punctuation">,</span> SimpleNamespace<span class="token punctuation">)</span><span class="token punctuation">:</span>
           <span class="token keyword">return</span> self<span class="token punctuation">.</span>__dict__ <span class="token operator">==</span> other<span class="token punctuation">.</span>__dict__
        <span class="token keyword">return</span> NotImplemented<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>SimpleNamespace</code> 可被用于替代 <code>class NS: pass</code>。 但是，对于结构化记录类型则应改用 <code>namedtuple()</code>。</p>
<p>3.3 新版功能.</p>
<p>在 3.9 版更改: repr 中的属性顺序由字母顺序改为插入顺序 (类似 <code>dict</code>)。</p>
<p><code>types.DynamicClassAttribute</code>(<em>fget=None</em>, <em>fset=None</em>, <em>fdel=None</em>, <em>doc=None</em>)</p>
<p>在类上访问 <strong>getattr</strong> 的路由属性。</p>
<p>这是一个描述器，用于定义通过实例与通过类访问时具有不同行为的属性。 当实例访问时保持正常行为，但当类访问属性时将被路由至类的 <strong>getattr</strong> 方法；这是通过引发 AttributeError 来完成的。</p>
<p>这允许有在实例上激活的特性属性，同时又有在类上的同名虚拟属性 。</p>
<p>3.4 新版功能.</p>
<h4 id="协程工具函数"><a href="#协程工具函数" class="headerlink" title="协程工具函数"></a>协程工具函数</h4><p><code>types.coroutine</code>(<em>gen_func</em>)</p>
<p>此函数可将 generator 函数转换为返回基于生成器的协程的 coroutine function。 基于生成器的协程仍然属于 generator iterator，但同时又可被视为 coroutine 对象兼 awaitable。 不过，它没有必要实现 <code>__await__()</code> 方法。</p>
<p>如果 <em>gen_func</em> 是一个生成器函数，它将被原地修改。</p>
<p>如果 <em>gen_func</em> 不是一个生成器函数，则它会被包装。 如果它返回一个 <code>collections.abc.Generator</code> 的实例，该实例将被包装在一个 <em>awaitable</em> 代理对象中。 所有其他对象类型将被原样返回。</p>
<p>3.5 新版功能.</p>
<h2 id="copy-—-浅层-shallow-和深层-deep-复制操作"><a href="#copy-—-浅层-shallow-和深层-deep-复制操作" class="headerlink" title="copy —- 浅层 (shallow) 和深层 (deep) 复制操作"></a><code>copy</code> —- 浅层 (shallow) 和深层 (deep) 复制操作</h2><p><strong>源代码:</strong> <a href="https://github.com/python/cpython/tree/3.10/Lib/copy.py" target="_blank" rel="noopener">Lib/copy.py</a></p>
<hr>
<p>Python 的赋值语句不复制对象，而是创建目标和对象的绑定关系。对于自身可变，或包含可变项的集合，有时要生成副本用于改变操作，而不必改变原始对象。本模块提供了通用的浅层复制和深层复制操作，（如下所述）。</p>
<p>接口摘要：</p>
<p><code>copy.copy</code>(<em>x</em>)</p>
<p>返回 <em>x</em> 的浅层复制。</p>
<p><code>copy.deepcopy</code>(<em>x</em>[, <em>memo</em>])</p>
<p>返回 <em>x</em> 的深层复制。</p>
<p><em>exception</em> <code>copy.Error</code></p>
<p>针对模块特定错误引发。</p>
<p>浅层与深层复制的区别仅与复合对象（即包含列表或类的实例等其他对象的对象）相关：</p>
<ul>
<li><em>浅层复制</em> 构造一个新的复合对象，然后（在尽可能的范围内）将原始对象中找到的对象的 <em>引用</em> 插入其中。</li>
<li><em>深层复制</em> 构造一个新的复合对象，然后，递归地将在原始对象里找到的对象的 <em>副本</em> 插入其中。</li>
</ul>
<p>深度复制操作通常存在两个问题, 而浅层复制操作并不存在这些问题：</p>
<ul>
<li>递归对象 (直接或间接包含对自身引用的复合对象) 可能会导致递归循环。</li>
<li>由于深层复制会复制所有内容，因此可能会过多复制（例如本应该在副本之间共享的数据）。</li>
</ul>
<p><code>deepcopy()</code> 函数用以下方式避免了这些问题：</p>
<ul>
<li>保留在当前复制过程中已复制的对象的 “备忘录” （<code>memo</code>） 字典；以及</li>
<li>允许用户定义的类重载复制操作或复制的组件集合。</li>
</ul>
<p>该模块不复制模块、方法、栈追踪（stack trace）、栈帧（stack frame）、文件、套接字、窗口、数组以及任何类似的类型。它通过不改变地返回原始对象来（浅层或深层地）“复制”函数和类；这与 <code>pickle</code> 模块处理这类问题的方式是相似的。</p>
<p>制作字典的浅层复制可以使用 <code>dict.copy()</code> 方法，而制作列表的浅层复制可以通过赋值整个列表的切片完成，例如，<code>copied_list = original_list[:]</code>。</p>
<p>类可以使用与控制序列化（pickling）操作相同的接口来控制复制操作，关于这些方法的描述信息请参考 <code>pickle</code> 模块。实际上，<code>copy</code> 模块使用的正是从 <code>copyreg</code> 模块中注册的 pickle 函数。</p>
<p>想要为一个类定义它自己的拷贝操作实现，可以通过定义特殊方法 <code>__copy__()</code> 和 <code>__deepcopy__()</code>。 调用前者以实现浅层拷贝操作；该方法不必传入额外参数。 调用后者以实现深层拷贝操作；它应转入一个参数，即 <code>memo</code> 字典。 如果 <code>__deepcopy__()</code> 实现需要创建一个组件的深层拷贝，它应当调用 <code>deepcopy()</code> 函数并以该组件作为第一个参数而以该 memo 字典作为第二个参数。。 memo 字典应当被当作不透明对象来处理。</p>
<h2 id="pprint-—-数据美化输出"><a href="#pprint-—-数据美化输出" class="headerlink" title="pprint — 数据美化输出"></a>pprint — 数据美化输出</h2><p><strong>源代码：</strong> <a href="https://github.com/python/cpython/tree/3.10/Lib/pprint.py" target="_blank" rel="noopener">Lib/pprint.py</a></p>
<hr>
<p><code>pprint</code> 模块提供了“美化打印”任意 Python 数据结构的功能，这种美化形式可用作对解释器的输入。 如果经格式化的结构包含非基本 Python 类型的对象，则其美化形式可能无法被加载。 包含文件、套接字或类对象，以及许多其他不能用 Python 字面值来表示的对象都有可能导致这样的结果。</p>
<p>格式化后的形式会在可能的情况下以单行来表示对象，并在无法在允许宽度内容纳对象的情况下将其分为多行。 如果你需要调整宽度限制则应显式地构造 <code>PrettyPrinter</code> 对象。</p>
<p>字典在计算其显示形式前会先根据键来排序。</p>
<p>在 3.9 版更改: 添加了对美化打印 <code>types.SimpleNamespace</code> 的支持。</p>
<p>在 3.10 版更改: 添加了对美化打印 <code>dataclasses.dataclass</code> 的支持。</p>
<p><code>pprint</code> 模块定义了一个类：</p>
<p><em>class</em> <code>pprint.PrettyPrinter</code>(<em>indent=1</em>, <em>width=80</em>, <em>depth=None</em>, <em>stream=None</em>, <em>**,</em> compact=False<em>,</em> sort_dicts=True<em>,</em> underscore_numbers=False*)</p>
<p>构造一个 <code>PrettyPrinter</code> 实例。 这个构造器支持一些关键字形参。</p>
<p><em>stream</em> (默认为 <code>sys.stdout</code>) 是一个 file-like object，通过调用该对象的 <code>write()</code> 方法可以将输出写入其中。</p>
<p>其他值可用来配置复杂数据结构嵌套要以何种形式被展示。</p>
<p><em>indent</em> (默认为 1) 指定要为每个缩进层级添加的缩进量。</p>
<p><em>depth</em> 控制可被打印的缩进层级数量；如果要打印的数据结构层级过深，则其所包含的下一层级将用 <code>...</code> 替换。 默认情况下，对于被格式化对象的层级深度没有任何限制。</p>
<p><em>width</em> (默认为 80) 指定输出中每行所允许的最大字符数。 如果一个数据结构无法在宽度限制之内被格式化，将显示尽可能多的内容。</p>
<p><em>compact</em> 影响长序列（列表、元组、集合等等）的格式化方式。 如果 <em>compact</em> 为假值（默认）则序列的每一项将格式化为单独的行。 如果 <em>compact</em> 为真值，则每个输出行格式化时将在 <em>width</em> 的限制之内尽可能地容纳多个条目。</p>
<p>如果 <em>sort_dicts</em> 为真值（默认），字典在格式化时将基于键进行排序，否则它们将按插入顺序显示。</p>
<p>如果 <em>underscore_numbers</em> 为真值，整数在格式化时将使用 <code>_</code> 字符作为千位分隔符，否则不显示下划线（默认）。</p>
<p>在 3.4 版更改: 增加了 <em>compact</em> 形参。</p>
<p>在 3.8 版更改: 增加了 <em>sort_dicts</em> 形参。</p>
<p>在 3.10 版更改: 添加了 <em>underscore_numbers</em> 形参。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> pprint
<span class="token operator">>></span><span class="token operator">></span> stuff <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'spam'</span><span class="token punctuation">,</span> <span class="token string">'eggs'</span><span class="token punctuation">,</span> <span class="token string">'lumberjack'</span><span class="token punctuation">,</span> <span class="token string">'knights'</span><span class="token punctuation">,</span> <span class="token string">'ni'</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> stuff<span class="token punctuation">.</span>insert<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> stuff<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> pp <span class="token operator">=</span> pprint<span class="token punctuation">.</span>PrettyPrinter<span class="token punctuation">(</span>indent<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> pp<span class="token punctuation">.</span>pprint<span class="token punctuation">(</span>stuff<span class="token punctuation">)</span>
<span class="token punctuation">[</span>   <span class="token punctuation">[</span><span class="token string">'spam'</span><span class="token punctuation">,</span> <span class="token string">'eggs'</span><span class="token punctuation">,</span> <span class="token string">'lumberjack'</span><span class="token punctuation">,</span> <span class="token string">'knights'</span><span class="token punctuation">,</span> <span class="token string">'ni'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
    <span class="token string">'spam'</span><span class="token punctuation">,</span>
    <span class="token string">'eggs'</span><span class="token punctuation">,</span>
    <span class="token string">'lumberjack'</span><span class="token punctuation">,</span>
    <span class="token string">'knights'</span><span class="token punctuation">,</span>
    <span class="token string">'ni'</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> pp <span class="token operator">=</span> pprint<span class="token punctuation">.</span>PrettyPrinter<span class="token punctuation">(</span>width<span class="token operator">=</span><span class="token number">41</span><span class="token punctuation">,</span> compact<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> pp<span class="token punctuation">.</span>pprint<span class="token punctuation">(</span>stuff<span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token string">'spam'</span><span class="token punctuation">,</span> <span class="token string">'eggs'</span><span class="token punctuation">,</span> <span class="token string">'lumberjack'</span><span class="token punctuation">,</span>
  <span class="token string">'knights'</span><span class="token punctuation">,</span> <span class="token string">'ni'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
 <span class="token string">'spam'</span><span class="token punctuation">,</span> <span class="token string">'eggs'</span><span class="token punctuation">,</span> <span class="token string">'lumberjack'</span><span class="token punctuation">,</span> <span class="token string">'knights'</span><span class="token punctuation">,</span>
 <span class="token string">'ni'</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> tup <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token string">'spam'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'eggs'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'lumberjack'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'knights'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'ni'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'dead'</span><span class="token punctuation">,</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">(</span><span class="token string">'parrot'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'fresh fruit'</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> pp <span class="token operator">=</span> pprint<span class="token punctuation">.</span>PrettyPrinter<span class="token punctuation">(</span>depth<span class="token operator">=</span><span class="token number">6</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> pp<span class="token punctuation">.</span>pprint<span class="token punctuation">(</span>tup<span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token string">'spam'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'eggs'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'lumberjack'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'knights'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'ni'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'dead'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>pprint</code> 模块还提供了一些快捷函数：</p>
<p><code>pprint.pformat</code>(<em>object</em>, <em>indent=1</em>, <em>width=80</em>, <em>depth=None</em>, <em>**,</em> compact=False<em>,</em> sort_dicts=True<em>,</em> underscore_numbers=False*)</p>
<p>将 <em>object</em> 的格式化表示作为字符串返回。 <em>indent</em>, <em>width</em>, <em>depth</em>, <em>compact</em>, <em>sort_dicts</em> 和 <em>underscore_numbers</em> 将作为格式化形参传递给 <code>PrettyPrinter</code> 构造器。</p>
<p>在 3.4 版更改: 增加了 <em>compact</em> 形参。</p>
<p>在 3.8 版更改: 增加了 <em>sort_dicts</em> 形参。</p>
<p>在 3.10 版更改: 添加了 <em>underscore_numbers</em> 形参。</p>
<p><code>pprint.pp</code>(<em>object</em>, <em>\</em>args<em>,</em> sort_dicts=False<em>,</em> <em>*kwargs</em>)</p>
<p>打印 <em>object</em> 的格式化表示并附带一个换行符。 如果 <em>sort_dicts</em> 为假值（默认），字典将按键的插入顺序显示，否则将按字典键排序。 <em>args</em> 和 <em>kwargs</em> 将作为格式化形参被传给 <code>pprint()</code>。</p>
<p>3.8 新版功能.</p>
<p><code>pprint.pprint</code>(<em>object</em>, <em>stream=None</em>, <em>indent=1</em>, <em>width=80</em>, <em>depth=None</em>, <em>**,</em> compact=False<em>,</em> sort_dicts=True<em>,</em> underscore_numbers=False*)</p>
<p>将 <em>object</em> 的格式化表示打印至 <em>stream*，末尾带一个换行符。 如果 *stream</em> 为 <code>None</code>，则使用 <code>sys.stdout</code>。 这可在交互式解释器而非 <code>print()</code> 函数中使用以便对值进行检查（你甚至可以在特定作用域内重赋值 <code>print = pprint.pprint</code> 以方便使用）。 <em>indent</em>, <em>width</em>, <em>depth</em>, <em>compact</em>, <em>sort_dicts</em> 和 <em>underscore_numbers</em> 将作为格式化形参传递给 <code>PrettyPrinter</code> 构造器。</p>
<p>在 3.4 版更改: 增加了 <em>compact</em> 形参。</p>
<p>在 3.8 版更改: 增加了 <em>sort_dicts</em> 形参。</p>
<p>在 3.10 版更改: 添加了 <em>underscore_numbers</em> 形参。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> pprint
<span class="token operator">>></span><span class="token operator">></span> stuff <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'spam'</span><span class="token punctuation">,</span> <span class="token string">'eggs'</span><span class="token punctuation">,</span> <span class="token string">'lumberjack'</span><span class="token punctuation">,</span> <span class="token string">'knights'</span><span class="token punctuation">,</span> <span class="token string">'ni'</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> stuff<span class="token punctuation">.</span>insert<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> stuff<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> pprint<span class="token punctuation">.</span>pprint<span class="token punctuation">(</span>stuff<span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token operator">&lt;</span>Recursion on list <span class="token keyword">with</span> id<span class="token operator">=</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">></span><span class="token punctuation">,</span>
 <span class="token string">'spam'</span><span class="token punctuation">,</span>
 <span class="token string">'eggs'</span><span class="token punctuation">,</span>
 <span class="token string">'lumberjack'</span><span class="token punctuation">,</span>
 <span class="token string">'knights'</span><span class="token punctuation">,</span>
 <span class="token string">'ni'</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>pprint.isreadable</code>(<em>object</em>)</p>
<p>确定 <em>object</em> 的格式化表示是否“可读”，或是否可被用来通过 <code>eval()</code> 重新构建对象的值。 此函数对于递归对象总是返回 <code>False</code>。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> pprint<span class="token punctuation">.</span>isreadable<span class="token punctuation">(</span>stuff<span class="token punctuation">)</span>
<span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><code>pprint.isrecursive</code>(<em>object</em>)</p>
<p>确定 <em>object</em> 是否需要递归表示。</p>
<p>此外还定义了一个支持函数：</p>
<p><code>pprint.saferepr</code>(<em>object</em>)</p>
<p>返回 <em>object</em> 的字符串表示，并为递归数据结构提供保护。 如果 <em>object</em> 的表示形式公开了一个递归条目，该递归引用会被表示为 <code>&lt;Recursion on typename with id=number&gt;</code>。 该表示因而不会进行其它格式化。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> pprint<span class="token punctuation">.</span>saferepr<span class="token punctuation">(</span>stuff<span class="token punctuation">)</span>
<span class="token string">"[&lt;Recursion on list with id=...>, 'spam', 'eggs', 'lumberjack', 'knights', 'ni']"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h3 id="PrettyPrinter-对象"><a href="#PrettyPrinter-对象" class="headerlink" title="PrettyPrinter 对象"></a>PrettyPrinter 对象</h3><p><code>PrettyPrinter</code> 的实例具有下列方法：</p>
<p><code>PrettyPrinter.pformat</code>(<em>object</em>)</p>
<p>返回 <em>object</em> 格式化表示。 这会将传给 <code>PrettyPrinter</code> 构造器的选项纳入考虑。</p>
<p><code>PrettyPrinter.pprint</code>(<em>object</em>)</p>
<p>在所配置的流上打印 <em>object</em> 的格式化表示，并附加一个换行符。</p>
<p>下列方法提供了与同名函数相对应的实现。 在实例上使用这些方法效率会更高一些，因为不需要创建新的 <code>PrettyPrinter</code> 对象。</p>
<p><code>PrettyPrinter.isreadable</code>(<em>object</em>)</p>
<p>确定对象的格式化表示是否“可读”，或者是否可使用 <code>eval()</code> 重建对象值。 请注意此方法对于递归对象将返回 <code>False</code>。 如果设置了 <code>PrettyPrinter</code> 的 <em>depth</em> 形参并且对象深度超出允许范围，此方法将返回 <code>False</code>。</p>
<p><code>PrettyPrinter.isrecursive</code>(<em>object</em>)</p>
<p>确定对象是否需要递归表示。</p>
<p>此方法作为一个钩子提供，允许子类修改将对象转换为字符串的方式。 默认实现使用 <code>saferepr()</code> 实现的内部方式。</p>
<p><code>PrettyPrinter.format</code>(<em>object</em>, <em>context</em>, <em>maxlevels</em>, <em>level</em>)</p>
<p>返回三个值：字符串形式的 <em>object</em> 已格式化版本，指明结果是否可读的旗标，以及指明是否检测到递归的旗标。 第一个参数是要表示的对象。 第二个是以对象 <code>id()</code> 为键的字典，这些对象是当前表示上下文的一部分（影响 <em>object</em> 表示的直接和间接容器）；如果需要呈现一个已经在 <em>context</em> 中表示的对象，则第三个返回值应当为 <code>True</code>。 对 <code>format()</code> 方法的递归调用应当将容器的附加条目添加到此字典中。 第三个参数 <em>maxlevels</em> 给出了对递归的请求限制；如果没有请求限制则其值将为 <code>0</code>。 此参数应当不加修改地传给递归调用。 第四个参数 <em>level</em> 给出于当前层级；传给递归调用的参数值应当小于当前调用的值。</p>
<h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h3><p>为了演示 <code>pprint()</code> 函数及其形参的几种用法，让我们从 PyPI 获取关于某个项目的信息:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> json
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> pprint
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> urllib<span class="token punctuation">.</span>request <span class="token keyword">import</span> urlopen
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">with</span> urlopen<span class="token punctuation">(</span><span class="token string">'https://pypi.org/pypi/sampleproject/json'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> resp<span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     project_info <span class="token operator">=</span> json<span class="token punctuation">.</span>load<span class="token punctuation">(</span>resp<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token string">'info'</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>pprint()</code> 以其基本形式显示了整个对象:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> pprint<span class="token punctuation">.</span>pprint<span class="token punctuation">(</span>project_info<span class="token punctuation">)</span>
<span class="token punctuation">{</span><span class="token string">'author'</span><span class="token punctuation">:</span> <span class="token string">'The Python Packaging Authority'</span><span class="token punctuation">,</span>
 <span class="token string">'author_email'</span><span class="token punctuation">:</span> <span class="token string">'pypa-dev@googlegroups.com'</span><span class="token punctuation">,</span>
 <span class="token string">'bugtrack_url'</span><span class="token punctuation">:</span> None<span class="token punctuation">,</span>
 <span class="token string">'classifiers'</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'Development Status :: 3 - Alpha'</span><span class="token punctuation">,</span>
                 <span class="token string">'Intended Audience :: Developers'</span><span class="token punctuation">,</span>
                 <span class="token string">'License :: OSI Approved :: MIT License'</span><span class="token punctuation">,</span>
                 <span class="token string">'Programming Language :: Python :: 2'</span><span class="token punctuation">,</span>
                 <span class="token string">'Programming Language :: Python :: 2.6'</span><span class="token punctuation">,</span>
                 <span class="token string">'Programming Language :: Python :: 2.7'</span><span class="token punctuation">,</span>
                 <span class="token string">'Programming Language :: Python :: 3'</span><span class="token punctuation">,</span>
                 <span class="token string">'Programming Language :: Python :: 3.2'</span><span class="token punctuation">,</span>
                 <span class="token string">'Programming Language :: Python :: 3.3'</span><span class="token punctuation">,</span>
                 <span class="token string">'Programming Language :: Python :: 3.4'</span><span class="token punctuation">,</span>
                 <span class="token string">'Topic :: Software Development :: Build Tools'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
 <span class="token string">'description'</span><span class="token punctuation">:</span> <span class="token string">'A sample Python project\n'</span>
                <span class="token string">'=======================\n'</span>
                <span class="token string">'\n'</span>
                <span class="token string">'This is the description file for the project.\n'</span>
                <span class="token string">'\n'</span>
                <span class="token string">'The file should use UTF-8 encoding and be written using '</span>
                <span class="token string">'ReStructured Text. It\n'</span>
                <span class="token string">'will be used to generate the project webpage on PyPI, and '</span>
                <span class="token string">'should be written for\n'</span>
                <span class="token string">'that purpose.\n'</span>
                <span class="token string">'\n'</span>
                <span class="token string">'Typical contents for this file would include an overview of '</span>
                <span class="token string">'the project, basic\n'</span>
                <span class="token string">'usage examples, etc. Generally, including the project '</span>
                <span class="token string">'changelog in here is not\n'</span>
                <span class="token string">'a good idea, although a simple "What\'s New" section for the '</span>
                <span class="token string">'most recent version\n'</span>
                <span class="token string">'may be appropriate.'</span><span class="token punctuation">,</span>
 <span class="token string">'description_content_type'</span><span class="token punctuation">:</span> None<span class="token punctuation">,</span>
 <span class="token string">'docs_url'</span><span class="token punctuation">:</span> None<span class="token punctuation">,</span>
 <span class="token string">'download_url'</span><span class="token punctuation">:</span> <span class="token string">'UNKNOWN'</span><span class="token punctuation">,</span>
 <span class="token string">'downloads'</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token string">'last_day'</span><span class="token punctuation">:</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'last_month'</span><span class="token punctuation">:</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'last_week'</span><span class="token punctuation">:</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
 <span class="token string">'home_page'</span><span class="token punctuation">:</span> <span class="token string">'https://github.com/pypa/sampleproject'</span><span class="token punctuation">,</span>
 <span class="token string">'keywords'</span><span class="token punctuation">:</span> <span class="token string">'sample setuptools development'</span><span class="token punctuation">,</span>
 <span class="token string">'license'</span><span class="token punctuation">:</span> <span class="token string">'MIT'</span><span class="token punctuation">,</span>
 <span class="token string">'maintainer'</span><span class="token punctuation">:</span> None<span class="token punctuation">,</span>
 <span class="token string">'maintainer_email'</span><span class="token punctuation">:</span> None<span class="token punctuation">,</span>
 <span class="token string">'name'</span><span class="token punctuation">:</span> <span class="token string">'sampleproject'</span><span class="token punctuation">,</span>
 <span class="token string">'package_url'</span><span class="token punctuation">:</span> <span class="token string">'https://pypi.org/project/sampleproject/'</span><span class="token punctuation">,</span>
 <span class="token string">'platform'</span><span class="token punctuation">:</span> <span class="token string">'UNKNOWN'</span><span class="token punctuation">,</span>
 <span class="token string">'project_url'</span><span class="token punctuation">:</span> <span class="token string">'https://pypi.org/project/sampleproject/'</span><span class="token punctuation">,</span>
 <span class="token string">'project_urls'</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token string">'Download'</span><span class="token punctuation">:</span> <span class="token string">'UNKNOWN'</span><span class="token punctuation">,</span>
                  <span class="token string">'Homepage'</span><span class="token punctuation">:</span> <span class="token string">'https://github.com/pypa/sampleproject'</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
 <span class="token string">'release_url'</span><span class="token punctuation">:</span> <span class="token string">'https://pypi.org/project/sampleproject/1.2.0/'</span><span class="token punctuation">,</span>
 <span class="token string">'requires_dist'</span><span class="token punctuation">:</span> None<span class="token punctuation">,</span>
 <span class="token string">'requires_python'</span><span class="token punctuation">:</span> None<span class="token punctuation">,</span>
 <span class="token string">'summary'</span><span class="token punctuation">:</span> <span class="token string">'A sample Python project'</span><span class="token punctuation">,</span>
 <span class="token string">'version'</span><span class="token punctuation">:</span> <span class="token string">'1.2.0'</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>结果可以被限制到特定的 <em>depth</em> (更深层的内容将使用省略号):</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> pprint<span class="token punctuation">.</span>pprint<span class="token punctuation">(</span>project_info<span class="token punctuation">,</span> depth<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span><span class="token string">'author'</span><span class="token punctuation">:</span> <span class="token string">'The Python Packaging Authority'</span><span class="token punctuation">,</span>
 <span class="token string">'author_email'</span><span class="token punctuation">:</span> <span class="token string">'pypa-dev@googlegroups.com'</span><span class="token punctuation">,</span>
 <span class="token string">'bugtrack_url'</span><span class="token punctuation">:</span> None<span class="token punctuation">,</span>
 <span class="token string">'classifiers'</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
 <span class="token string">'description'</span><span class="token punctuation">:</span> <span class="token string">'A sample Python project\n'</span>
                <span class="token string">'=======================\n'</span>
                <span class="token string">'\n'</span>
                <span class="token string">'This is the description file for the project.\n'</span>
                <span class="token string">'\n'</span>
                <span class="token string">'The file should use UTF-8 encoding and be written using '</span>
                <span class="token string">'ReStructured Text. It\n'</span>
                <span class="token string">'will be used to generate the project webpage on PyPI, and '</span>
                <span class="token string">'should be written for\n'</span>
                <span class="token string">'that purpose.\n'</span>
                <span class="token string">'\n'</span>
                <span class="token string">'Typical contents for this file would include an overview of '</span>
                <span class="token string">'the project, basic\n'</span>
                <span class="token string">'usage examples, etc. Generally, including the project '</span>
                <span class="token string">'changelog in here is not\n'</span>
                <span class="token string">'a good idea, although a simple "What\'s New" section for the '</span>
                <span class="token string">'most recent version\n'</span>
                <span class="token string">'may be appropriate.'</span><span class="token punctuation">,</span>
 <span class="token string">'description_content_type'</span><span class="token punctuation">:</span> None<span class="token punctuation">,</span>
 <span class="token string">'docs_url'</span><span class="token punctuation">:</span> None<span class="token punctuation">,</span>
 <span class="token string">'download_url'</span><span class="token punctuation">:</span> <span class="token string">'UNKNOWN'</span><span class="token punctuation">,</span>
 <span class="token string">'downloads'</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
 <span class="token string">'home_page'</span><span class="token punctuation">:</span> <span class="token string">'https://github.com/pypa/sampleproject'</span><span class="token punctuation">,</span>
 <span class="token string">'keywords'</span><span class="token punctuation">:</span> <span class="token string">'sample setuptools development'</span><span class="token punctuation">,</span>
 <span class="token string">'license'</span><span class="token punctuation">:</span> <span class="token string">'MIT'</span><span class="token punctuation">,</span>
 <span class="token string">'maintainer'</span><span class="token punctuation">:</span> None<span class="token punctuation">,</span>
 <span class="token string">'maintainer_email'</span><span class="token punctuation">:</span> None<span class="token punctuation">,</span>
 <span class="token string">'name'</span><span class="token punctuation">:</span> <span class="token string">'sampleproject'</span><span class="token punctuation">,</span>
 <span class="token string">'package_url'</span><span class="token punctuation">:</span> <span class="token string">'https://pypi.org/project/sampleproject/'</span><span class="token punctuation">,</span>
 <span class="token string">'platform'</span><span class="token punctuation">:</span> <span class="token string">'UNKNOWN'</span><span class="token punctuation">,</span>
 <span class="token string">'project_url'</span><span class="token punctuation">:</span> <span class="token string">'https://pypi.org/project/sampleproject/'</span><span class="token punctuation">,</span>
 <span class="token string">'project_urls'</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
 <span class="token string">'release_url'</span><span class="token punctuation">:</span> <span class="token string">'https://pypi.org/project/sampleproject/1.2.0/'</span><span class="token punctuation">,</span>
 <span class="token string">'requires_dist'</span><span class="token punctuation">:</span> None<span class="token punctuation">,</span>
 <span class="token string">'requires_python'</span><span class="token punctuation">:</span> None<span class="token punctuation">,</span>
 <span class="token string">'summary'</span><span class="token punctuation">:</span> <span class="token string">'A sample Python project'</span><span class="token punctuation">,</span>
 <span class="token string">'version'</span><span class="token punctuation">:</span> <span class="token string">'1.2.0'</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>此外，还可以设置建议的最大字符 <em>width</em>。 如果一个对象无法被拆分，则将超出指定宽度:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> pprint<span class="token punctuation">.</span>pprint<span class="token punctuation">(</span>project_info<span class="token punctuation">,</span> depth<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> width<span class="token operator">=</span><span class="token number">60</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span><span class="token string">'author'</span><span class="token punctuation">:</span> <span class="token string">'The Python Packaging Authority'</span><span class="token punctuation">,</span>
 <span class="token string">'author_email'</span><span class="token punctuation">:</span> <span class="token string">'pypa-dev@googlegroups.com'</span><span class="token punctuation">,</span>
 <span class="token string">'bugtrack_url'</span><span class="token punctuation">:</span> None<span class="token punctuation">,</span>
 <span class="token string">'classifiers'</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
 <span class="token string">'description'</span><span class="token punctuation">:</span> <span class="token string">'A sample Python project\n'</span>
                <span class="token string">'=======================\n'</span>
                <span class="token string">'\n'</span>
                <span class="token string">'This is the description file for the '</span>
                <span class="token string">'project.\n'</span>
                <span class="token string">'\n'</span>
                <span class="token string">'The file should use UTF-8 encoding and be '</span>
                <span class="token string">'written using ReStructured Text. It\n'</span>
                <span class="token string">'will be used to generate the project '</span>
                <span class="token string">'webpage on PyPI, and should be written '</span>
                <span class="token string">'for\n'</span>
                <span class="token string">'that purpose.\n'</span>
                <span class="token string">'\n'</span>
                <span class="token string">'Typical contents for this file would '</span>
                <span class="token string">'include an overview of the project, '</span>
                <span class="token string">'basic\n'</span>
                <span class="token string">'usage examples, etc. Generally, including '</span>
                <span class="token string">'the project changelog in here is not\n'</span>
                <span class="token string">'a good idea, although a simple "What\'s '</span>
                <span class="token string">'New" section for the most recent version\n'</span>
                <span class="token string">'may be appropriate.'</span><span class="token punctuation">,</span>
 <span class="token string">'description_content_type'</span><span class="token punctuation">:</span> None<span class="token punctuation">,</span>
 <span class="token string">'docs_url'</span><span class="token punctuation">:</span> None<span class="token punctuation">,</span>
 <span class="token string">'download_url'</span><span class="token punctuation">:</span> <span class="token string">'UNKNOWN'</span><span class="token punctuation">,</span>
 <span class="token string">'downloads'</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
 <span class="token string">'home_page'</span><span class="token punctuation">:</span> <span class="token string">'https://github.com/pypa/sampleproject'</span><span class="token punctuation">,</span>
 <span class="token string">'keywords'</span><span class="token punctuation">:</span> <span class="token string">'sample setuptools development'</span><span class="token punctuation">,</span>
 <span class="token string">'license'</span><span class="token punctuation">:</span> <span class="token string">'MIT'</span><span class="token punctuation">,</span>
 <span class="token string">'maintainer'</span><span class="token punctuation">:</span> None<span class="token punctuation">,</span>
 <span class="token string">'maintainer_email'</span><span class="token punctuation">:</span> None<span class="token punctuation">,</span>
 <span class="token string">'name'</span><span class="token punctuation">:</span> <span class="token string">'sampleproject'</span><span class="token punctuation">,</span>
 <span class="token string">'package_url'</span><span class="token punctuation">:</span> <span class="token string">'https://pypi.org/project/sampleproject/'</span><span class="token punctuation">,</span>
 <span class="token string">'platform'</span><span class="token punctuation">:</span> <span class="token string">'UNKNOWN'</span><span class="token punctuation">,</span>
 <span class="token string">'project_url'</span><span class="token punctuation">:</span> <span class="token string">'https://pypi.org/project/sampleproject/'</span><span class="token punctuation">,</span>
 <span class="token string">'project_urls'</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
 <span class="token string">'release_url'</span><span class="token punctuation">:</span> <span class="token string">'https://pypi.org/project/sampleproject/1.2.0/'</span><span class="token punctuation">,</span>
 <span class="token string">'requires_dist'</span><span class="token punctuation">:</span> None<span class="token punctuation">,</span>
 <span class="token string">'requires_python'</span><span class="token punctuation">:</span> None<span class="token punctuation">,</span>
 <span class="token string">'summary'</span><span class="token punctuation">:</span> <span class="token string">'A sample Python project'</span><span class="token punctuation">,</span>
 <span class="token string">'version'</span><span class="token punctuation">:</span> <span class="token string">'1.2.0'</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="reprlib-—-另一种-repr-实现"><a href="#reprlib-—-另一种-repr-实现" class="headerlink" title="reprlib —- 另一种 repr() 实现"></a><code>reprlib</code> —- 另一种 <code>repr()</code> 实现</h2><p><strong>源代码:</strong> <a href="https://github.com/python/cpython/tree/3.10/Lib/reprlib.py" target="_blank" rel="noopener">Lib/reprlib.py</a></p>
<hr>
<p><code>reprlib</code> 模块提供了一种对象表示的产生方式，它会对结果字符串的大小进行限制。 该方式被用于 Python 调试器，也适用于某些其他场景。</p>
<p>此模块提供了一个类、一个实例和一个函数：</p>
<p><em>class</em> <code>reprlib.Repr</code></p>
<p>该类提供了格式化服务 适用于实现与内置 <code>repr()</code> 相似的方法；其中附加了针对不同对象类型的大小限制，以避免生成超长的表示。</p>
<pre><code>reprlib.aRepr</code></pre><p>这是 <code>Repr</code> 的一个实例，用于提供如下所述的 <code>repr()</code> 函数。 改变此对象的属性将会影响 <code>repr()</code> 和 Python 调试器所使用的大小限制。</p>
<p><code>reprlib.repr</code>(<em>obj</em>)</p>
<p>这是 <code>aRepr</code> 的 <code>repr()</code> 方法。 它会返回与同名内置函数所返回字符串相似的字符串，区别在于附带了对多数类型的大小限制。</p>
<p>在大小限制工具以外，此模块还提供了一个装饰器，用于检测对 <code>__repr__()</code> 的递归调用并改用一个占位符来替换。</p>
<p><code>@``reprlib.recursive_repr</code>(<em>fillvalue=’…’</em>)</p>
<p>用于为 <code>__repr__()</code> 方法检测同一线程内部递归调用的装饰器。 如果执行了递归调用，则会返回 <em>fillvalue</em>，否则执行正常的 <code>__repr__()</code> 调用。 例如：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> reprlib <span class="token keyword">import</span> recursive_repr
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">class</span> <span class="token class-name">MyList</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     @recursive_repr<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">def</span> <span class="token function">__repr__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         <span class="token keyword">return</span> <span class="token string">'&lt;'</span> <span class="token operator">+</span> <span class="token string">'|'</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>map<span class="token punctuation">(</span>repr<span class="token punctuation">,</span> self<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">'>'</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> m <span class="token operator">=</span> MyList<span class="token punctuation">(</span><span class="token string">'abc'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> m<span class="token punctuation">.</span>append<span class="token punctuation">(</span>m<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> m<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token string">'x'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span>
<span class="token operator">&lt;</span><span class="token string">'a'</span><span class="token operator">|</span><span class="token string">'b'</span><span class="token operator">|</span><span class="token string">'c'</span><span class="token operator">|</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">|</span><span class="token string">'x'</span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>3.2 新版功能.</p>
<h3 id="Repr-对象"><a href="#Repr-对象" class="headerlink" title="Repr 对象"></a>Repr 对象</h3><p><code>Repr</code> 实例对象包含一些属性可以用于为不同对象类型的表示提供大小限制，还包含一些方法可以格式化特定的对象类型。</p>
<pre><code>Repr.maxlevel</code></pre><p>创建递归表示形式的深度限制。 默认为 <code>6</code>。</p>
<pre><code>Repr.maxdict
Repr.maxlist
Repr.maxtuple
Repr.maxset
Repr.maxfrozenset
Repr.maxdeque
Repr.maxarray</code></pre><p>表示命名对象类型的条目数量限制。 对于 <code>maxdict</code> 的默认值为 <code>4</code>，对于 <code>maxarray</code> 为 <code>5</code>，对于其他则为 <code>6</code>。</p>
<pre><code>Repr.maxlong</code></pre><p>表示整数的最大字符数量。 数码会从中间被丢弃。 默认值为 <code>40</code>。</p>
<pre><code>Repr.maxstring</code></pre><p>表示字符串的字符数量限制。 请注意字符源会使用字符串的“正常”表示形式：如果表示中需要用到转义序列，在缩短表示时它们可能会被破坏。 默认值为 <code>30</code>。</p>
<pre><code>Repr.maxother</code></pre><p>此限制用于控制在 <code>Repr</code> 对象上没有特定的格式化方法可用的对象类型的大小。 它会以类似 <code>maxstring</code> 的方式被应用。 默认值为 <code>20</code>。</p>
<p><code>Repr.repr</code>(<em>obj</em>)</p>
<p>内置 <code>repr()</code> 的等价形式，它使用实例专属的格式化。</p>
<p><code>Repr.repr1</code>(<em>obj</em>, <em>level</em>)</p>
<p>供 <code>repr()</code> 使用的递归实现。 此方法使用 <em>obj</em> 的类型来确定要调用哪个格式化方法，并传入 <em>obj</em> 和 <em>level*。 类型专属的方法应当调用 <code>repr1()</code> 来执行递归格式化，在递归调用中使用 <code>level - 1</code> 作为 *level</em> 的值。</p>
<p><code>Repr.repr_TYPE</code>(<em>obj</em>, <em>level</em>)</p>
<p>特定类型的格式化方法会被实现为基于类型名称来命名的方法。 在方法名称中，<strong>TYPE</strong> 会被替换为 <code>'_'.join(type(obj).__name__.split())</code>。 对这些方法的分派会由 <code>repr1()</code> 来处理。 需要对值进行递归格式化的类型专属方法应当调用 <code>self.repr1(subobj, level - 1)</code>。</p>
<h3 id="子类化-Repr-对象"><a href="#子类化-Repr-对象" class="headerlink" title="子类化 Repr 对象"></a>子类化 Repr 对象</h3><p>通过 <code>Repr.repr1()</code> 使用动态分派允许 <code>Repr</code> 的子类添加对额外内置对象类型的支持，或是修改对已支持类型的处理。 这个例子演示了如何添加对文件对象的特殊支持:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> reprlib
<span class="token keyword">import</span> sys
<span class="token keyword">class</span> <span class="token class-name">MyRepr</span><span class="token punctuation">(</span>reprlib<span class="token punctuation">.</span>Repr<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">repr_TextIOWrapper</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> obj<span class="token punctuation">,</span> level<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> obj<span class="token punctuation">.</span>name <span class="token keyword">in</span> <span class="token punctuation">{</span><span class="token string">'&lt;stdin>'</span><span class="token punctuation">,</span> <span class="token string">'&lt;stdout>'</span><span class="token punctuation">,</span> <span class="token string">'&lt;stderr>'</span><span class="token punctuation">}</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> obj<span class="token punctuation">.</span>name
        <span class="token keyword">return</span> repr<span class="token punctuation">(</span>obj<span class="token punctuation">)</span>
aRepr <span class="token operator">=</span> MyRepr<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>aRepr<span class="token punctuation">.</span>repr<span class="token punctuation">(</span>sys<span class="token punctuation">.</span>stdin<span class="token punctuation">)</span><span class="token punctuation">)</span>         <span class="token comment" spellcheck="true"># prints '&lt;stdin>'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="enum-—-对枚举的支持"><a href="#enum-—-对枚举的支持" class="headerlink" title="enum —- 对枚举的支持"></a><code>enum</code> —- 对枚举的支持</h2><p>3.4 新版功能.</p>
<p><strong>源代码：</strong> <a href="https://github.com/python/cpython/tree/3.10/Lib/enum.py" target="_blank" rel="noopener">Lib/enum.py</a></p>
<hr>
<p>枚举是与多个唯一常量值绑定的一组符号名（即成员）。枚举中的成员可以进行身份比较，并且枚举自身也可迭代。</p>
<p>注解</p>
<p>枚举成员名称的大小写</p>
<p>枚举表示的是常量，因此，建议枚举成员名称使用大写字母，本篇的示例将用此种风格。</p>
<h3 id="模块内容-1"><a href="#模块内容-1" class="headerlink" title="模块内容"></a>模块内容</h3><p>本模块定义了四个枚举类，用来定义名称与值的唯一组合: <code>Enum</code>、<code>IntEnum</code>、<code>Flag</code> 和 <code>IntFlag</code>。此外，还定义了一个装饰器，<code>unique()</code>， 和一个辅助类，<code>auto</code>。</p>
<p><em>class</em> <code>enum.Enum</code></p>
<p>创建枚举常量的基类。 </p>
<p><em>class</em> <code>enum.IntEnum</code></p>
<p>创建 <code>int</code> 子类枚举常量的基类。</p>
<p><em>class</em> <code>enum.IntFlag</code></p>
<p>创建可与位运算符搭配使用，又不失去 <code>IntFlag</code> 成员资格的枚举常量的基类。<code>IntFlag</code> 成员也是 <code>int</code> 的子类。</p>
<p><em>class</em> <code>enum.Flag</code></p>
<p>创建可与位运算符搭配使用，又不会失去 <code>Flag</code> 成员资格的枚举常量的基类。</p>
<p><code>enum.unique</code>()</p>
<p>确保一个名称只绑定一个值的 Enum 类装饰器。</p>
<p><em>class</em> <code>enum.auto</code></p>
<p>以合适的值代替 Enum 成员的实例。 初始值默认从 1 开始。</p>
<p>3.6 新版功能: <code>Flag</code>, <code>IntFlag</code>, <code>auto</code></p>
<h3 id="创建-Enum"><a href="#创建-Enum" class="headerlink" title="创建 Enum"></a>创建 Enum</h3><p>枚举是由 <code>class</code> 句法创建的，这种方式易读、易写。 <code>Enum</code> 以如下定义枚举：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> enum <span class="token keyword">import</span> Enum
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">class</span> <span class="token class-name">Color</span><span class="token punctuation">(</span>Enum<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     RED <span class="token operator">=</span> <span class="token number">1</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     GREEN <span class="token operator">=</span> <span class="token number">2</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     BLUE <span class="token operator">=</span> <span class="token number">3</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>注解</p>
<p>Enum 成员值</p>
<p>成员值可以是 <code>int</code>、<code>str</code> 等。若无需设定确切值，<code>auto</code> 实例可以自动为成员分配合适 的值。将 <code>auto</code> 与其他值混用时必须要慎重。</p>
<p>注解</p>
<p>命名法</p>
<ul>
<li>类 <code>Color</code> 是 <em>枚举</em> （或称为 <em>enum</em> ）。</li>
<li><code>Color.RED</code>、<code>Color.GREEN</code> 等属性是 <em>枚举成员</em> （或 <em>enum 成员</em>），也是常量。</li>
<li>枚举成员具有 <em>名称</em> 和 <em>值</em> (例如 <code>Color.RED</code> 的名称为 <code>RED</code>，<code>Color.BLUE</code> 的值为 <code>3</code> 等等)</li>
</ul>
<p>注解</p>
<p>虽然 Enum 由 <code>class</code> 语法创建，但 Enum 并不是常规的 Python 类。</p>
<p>枚举成员的字符串表现形式更容易理解：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>Color<span class="token punctuation">.</span>RED<span class="token punctuation">)</span>
Color<span class="token punctuation">.</span>RED<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>同时，它的 <code>repr</code> 包含更多信息：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>repr<span class="token punctuation">(</span>Color<span class="token punctuation">.</span>RED<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token operator">&lt;</span>Color<span class="token punctuation">.</span>RED<span class="token punctuation">:</span> <span class="token number">1</span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>枚举成员的 <em>类型</em> 就是它所属的枚举：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> type<span class="token punctuation">(</span>Color<span class="token punctuation">.</span>RED<span class="token punctuation">)</span>
<span class="token operator">&lt;</span>enum <span class="token string">'Color'</span><span class="token operator">></span>
<span class="token operator">>></span><span class="token operator">></span> isinstance<span class="token punctuation">(</span>Color<span class="token punctuation">.</span>GREEN<span class="token punctuation">,</span> Color<span class="token punctuation">)</span>
<span class="token boolean">True</span>
<span class="token operator">>></span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>Enum 成员还包含 name 属性：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>Color<span class="token punctuation">.</span>RED<span class="token punctuation">.</span>name<span class="token punctuation">)</span>
RED<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>枚举按定义的顺序进行迭代：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">class</span> <span class="token class-name">Shake</span><span class="token punctuation">(</span>Enum<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     VANILLA <span class="token operator">=</span> <span class="token number">7</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     CHOCOLATE <span class="token operator">=</span> <span class="token number">4</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     COOKIES <span class="token operator">=</span> <span class="token number">9</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     MINT <span class="token operator">=</span> <span class="token number">3</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">for</span> shake <span class="token keyword">in</span> Shake<span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">print</span><span class="token punctuation">(</span>shake<span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
Shake<span class="token punctuation">.</span>VANILLA
Shake<span class="token punctuation">.</span>CHOCOLATE
Shake<span class="token punctuation">.</span>COOKIES
Shake<span class="token punctuation">.</span>MINT<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>枚举成员可哈希，可用于字典和集合：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> apples <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token operator">>></span><span class="token operator">></span> apples<span class="token punctuation">[</span>Color<span class="token punctuation">.</span>RED<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'red delicious'</span>
<span class="token operator">>></span><span class="token operator">></span> apples<span class="token punctuation">[</span>Color<span class="token punctuation">.</span>GREEN<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'granny smith'</span>
<span class="token operator">>></span><span class="token operator">></span> apples <span class="token operator">==</span> <span class="token punctuation">{</span>Color<span class="token punctuation">.</span>RED<span class="token punctuation">:</span> <span class="token string">'red delicious'</span><span class="token punctuation">,</span> Color<span class="token punctuation">.</span>GREEN<span class="token punctuation">:</span> <span class="token string">'granny smith'</span><span class="token punctuation">}</span>
<span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="枚举成员及其属性的编程访问"><a href="#枚举成员及其属性的编程访问" class="headerlink" title="枚举成员及其属性的编程访问"></a>枚举成员及其属性的编程访问</h3><p>有时，要在程序中访问枚举成员（如，开发时不知道颜色的确切值，<code>Color.RED</code> 不适用的情况）。<code>Enum</code> 支持如下访问方式：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> Color<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token operator">&lt;</span>Color<span class="token punctuation">.</span>RED<span class="token punctuation">:</span> <span class="token number">1</span><span class="token operator">></span>
<span class="token operator">>></span><span class="token operator">></span> Color<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>
<span class="token operator">&lt;</span>Color<span class="token punctuation">.</span>BLUE<span class="token punctuation">:</span> <span class="token number">3</span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>用 <em>name</em> 访问枚举成员时，可使用项目名称：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> Color<span class="token punctuation">[</span><span class="token string">'RED'</span><span class="token punctuation">]</span>
<span class="token operator">&lt;</span>Color<span class="token punctuation">.</span>RED<span class="token punctuation">:</span> <span class="token number">1</span><span class="token operator">></span>
<span class="token operator">>></span><span class="token operator">></span> Color<span class="token punctuation">[</span><span class="token string">'GREEN'</span><span class="token punctuation">]</span>
<span class="token operator">&lt;</span>Color<span class="token punctuation">.</span>GREEN<span class="token punctuation">:</span> <span class="token number">2</span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>可访问枚举成员的 <code>name</code> 或 <code>value</code>：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> member <span class="token operator">=</span> Color<span class="token punctuation">.</span>RED
<span class="token operator">>></span><span class="token operator">></span> member<span class="token punctuation">.</span>name
<span class="token string">'RED'</span>
<span class="token operator">>></span><span class="token operator">></span> member<span class="token punctuation">.</span>value
<span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="重复的枚举成员和值"><a href="#重复的枚举成员和值" class="headerlink" title="重复的枚举成员和值"></a>重复的枚举成员和值</h3><p>两个枚举成员的名称不能相同：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">class</span> <span class="token class-name">Shape</span><span class="token punctuation">(</span>Enum<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     SQUARE <span class="token operator">=</span> <span class="token number">2</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     SQUARE <span class="token operator">=</span> <span class="token number">3</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
TypeError<span class="token punctuation">:</span> Attempted to reuse key<span class="token punctuation">:</span> <span class="token string">'SQUARE'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>但是，两个枚举成员可以有相同的值。假设，成员 A 和 B 的值相同（先定义的是 A），则 B 是 A 的别名。按值查找 A 和 B 的值返回的是 A。按名称查找 B，返回的也是 A：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">class</span> <span class="token class-name">Shape</span><span class="token punctuation">(</span>Enum<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     SQUARE <span class="token operator">=</span> <span class="token number">2</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     DIAMOND <span class="token operator">=</span> <span class="token number">1</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     CIRCLE <span class="token operator">=</span> <span class="token number">3</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     ALIAS_FOR_SQUARE <span class="token operator">=</span> <span class="token number">2</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> Shape<span class="token punctuation">.</span>SQUARE
<span class="token operator">&lt;</span>Shape<span class="token punctuation">.</span>SQUARE<span class="token punctuation">:</span> <span class="token number">2</span><span class="token operator">></span>
<span class="token operator">>></span><span class="token operator">></span> Shape<span class="token punctuation">.</span>ALIAS_FOR_SQUARE
<span class="token operator">&lt;</span>Shape<span class="token punctuation">.</span>SQUARE<span class="token punctuation">:</span> <span class="token number">2</span><span class="token operator">></span>
<span class="token operator">>></span><span class="token operator">></span> Shape<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>
<span class="token operator">&lt;</span>Shape<span class="token punctuation">.</span>SQUARE<span class="token punctuation">:</span> <span class="token number">2</span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>注解</p>
<p>不支持创建与已定义属性（其他成员、方法等）同名的成员，也不支持创建与现有成员同名的属性。</p>
<h3 id="确保唯一枚举值"><a href="#确保唯一枚举值" class="headerlink" title="确保唯一枚举值"></a>确保唯一枚举值</h3><p>默认情况下，枚举允许多个名称作为一个值的别名。如需禁用此行为，下述装饰器可以确保枚举中的值仅能只用一次：</p>
<pre><code>@enum.unique</code></pre><p>专用于枚举的 <code>class</code> 装饰器。 它会搜索一个枚举的 <code>__members__</code> 并收集所找到的任何别名；只要找到任何别名就会引发 <code>ValueError</code> 并附带相关细节信息:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> enum <span class="token keyword">import</span> Enum<span class="token punctuation">,</span> unique
<span class="token operator">>></span><span class="token operator">></span> @unique
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">class</span> <span class="token class-name">Mistake</span><span class="token punctuation">(</span>Enum<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     ONE <span class="token operator">=</span> <span class="token number">1</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     TWO <span class="token operator">=</span> <span class="token number">2</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     THREE <span class="token operator">=</span> <span class="token number">3</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     FOUR <span class="token operator">=</span> <span class="token number">3</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
ValueError<span class="token punctuation">:</span> duplicate values found <span class="token keyword">in</span> <span class="token operator">&lt;</span>enum <span class="token string">'Mistake'</span><span class="token operator">></span><span class="token punctuation">:</span> FOUR <span class="token operator">-</span><span class="token operator">></span> THREE<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="使用自动设定的值"><a href="#使用自动设定的值" class="headerlink" title="使用自动设定的值"></a>使用自动设定的值</h3><p>如果确切的值不重要，你可以使用 <code>auto</code>:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> enum <span class="token keyword">import</span> Enum<span class="token punctuation">,</span> auto
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">class</span> <span class="token class-name">Color</span><span class="token punctuation">(</span>Enum<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     RED <span class="token operator">=</span> auto<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     BLUE <span class="token operator">=</span> auto<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     GREEN <span class="token operator">=</span> auto<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> list<span class="token punctuation">(</span>Color<span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token operator">&lt;</span>Color<span class="token punctuation">.</span>RED<span class="token punctuation">:</span> <span class="token number">1</span><span class="token operator">></span><span class="token punctuation">,</span> <span class="token operator">&lt;</span>Color<span class="token punctuation">.</span>BLUE<span class="token punctuation">:</span> <span class="token number">2</span><span class="token operator">></span><span class="token punctuation">,</span> <span class="token operator">&lt;</span>Color<span class="token punctuation">.</span>GREEN<span class="token punctuation">:</span> <span class="token number">3</span><span class="token operator">></span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>值将由 <code>_generate_next_value_()</code> 来选择，该函数可以被重载:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">class</span> <span class="token class-name">AutoName</span><span class="token punctuation">(</span>Enum<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">def</span> <span class="token function">_generate_next_value_</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> start<span class="token punctuation">,</span> count<span class="token punctuation">,</span> last_values<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         <span class="token keyword">return</span> name
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">class</span> <span class="token class-name">Ordinal</span><span class="token punctuation">(</span>AutoName<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     NORTH <span class="token operator">=</span> auto<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     SOUTH <span class="token operator">=</span> auto<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     EAST <span class="token operator">=</span> auto<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     WEST <span class="token operator">=</span> auto<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> list<span class="token punctuation">(</span>Ordinal<span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token operator">&lt;</span>Ordinal<span class="token punctuation">.</span>NORTH<span class="token punctuation">:</span> <span class="token string">'NORTH'</span><span class="token operator">></span><span class="token punctuation">,</span> <span class="token operator">&lt;</span>Ordinal<span class="token punctuation">.</span>SOUTH<span class="token punctuation">:</span> <span class="token string">'SOUTH'</span><span class="token operator">></span><span class="token punctuation">,</span> <span class="token operator">&lt;</span>Ordinal<span class="token punctuation">.</span>EAST<span class="token punctuation">:</span> <span class="token string">'EAST'</span><span class="token operator">></span><span class="token punctuation">,</span> <span class="token operator">&lt;</span>Ordinal<span class="token punctuation">.</span>WEST<span class="token punctuation">:</span> <span class="token string">'WEST'</span><span class="token operator">></span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>注解</p>
<p>默认 <code>_generate_next_value_()</code> 方法的目标是提供所给出的最后一个 <code>int</code> 所在序列的下一个 <code>int</code>，但这种行为方式属于实现细节并且可能发生改变。</p>
<p>注解</p>
<p><code>_generate_next_value_()</code> 方法定义必须在任何其他成员之前。</p>
<h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><p>对枚举成员的迭代不会给出别名:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> list<span class="token punctuation">(</span>Shape<span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token operator">&lt;</span>Shape<span class="token punctuation">.</span>SQUARE<span class="token punctuation">:</span> <span class="token number">2</span><span class="token operator">></span><span class="token punctuation">,</span> <span class="token operator">&lt;</span>Shape<span class="token punctuation">.</span>DIAMOND<span class="token punctuation">:</span> <span class="token number">1</span><span class="token operator">></span><span class="token punctuation">,</span> <span class="token operator">&lt;</span>Shape<span class="token punctuation">.</span>CIRCLE<span class="token punctuation">:</span> <span class="token number">3</span><span class="token operator">></span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>特殊属性 <code>__members__</code> 是一个从名称到成员的只读有序映射。 它包含枚举中定义的所有名称，包括别名:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">for</span> name<span class="token punctuation">,</span> member <span class="token keyword">in</span> Shape<span class="token punctuation">.</span>__members__<span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     name<span class="token punctuation">,</span> member
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">(</span><span class="token string">'SQUARE'</span><span class="token punctuation">,</span> <span class="token operator">&lt;</span>Shape<span class="token punctuation">.</span>SQUARE<span class="token punctuation">:</span> <span class="token number">2</span><span class="token operator">></span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token string">'DIAMOND'</span><span class="token punctuation">,</span> <span class="token operator">&lt;</span>Shape<span class="token punctuation">.</span>DIAMOND<span class="token punctuation">:</span> <span class="token number">1</span><span class="token operator">></span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token string">'CIRCLE'</span><span class="token punctuation">,</span> <span class="token operator">&lt;</span>Shape<span class="token punctuation">.</span>CIRCLE<span class="token punctuation">:</span> <span class="token number">3</span><span class="token operator">></span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token string">'ALIAS_FOR_SQUARE'</span><span class="token punctuation">,</span> <span class="token operator">&lt;</span>Shape<span class="token punctuation">.</span>SQUARE<span class="token punctuation">:</span> <span class="token number">2</span><span class="token operator">></span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>__members__</code> 属性可被用于对枚举成员进行详细的程序化访问。 例如，找出所有别名:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token punctuation">[</span>name <span class="token keyword">for</span> name<span class="token punctuation">,</span> member <span class="token keyword">in</span> Shape<span class="token punctuation">.</span>__members__<span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">if</span> member<span class="token punctuation">.</span>name <span class="token operator">!=</span> name<span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token string">'ALIAS_FOR_SQUARE'</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h3 id="比较运算-1"><a href="#比较运算-1" class="headerlink" title="比较运算"></a>比较运算</h3><p>枚举成员是按标识号进行比较的:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> Color<span class="token punctuation">.</span>RED <span class="token keyword">is</span> Color<span class="token punctuation">.</span>RED
<span class="token boolean">True</span>
<span class="token operator">>></span><span class="token operator">></span> Color<span class="token punctuation">.</span>RED <span class="token keyword">is</span> Color<span class="token punctuation">.</span>BLUE
<span class="token boolean">False</span>
<span class="token operator">>></span><span class="token operator">></span> Color<span class="token punctuation">.</span>RED <span class="token keyword">is</span> <span class="token operator">not</span> Color<span class="token punctuation">.</span>BLUE
<span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>枚举值之间的排序比较 <em>不被</em> 支持。 Enum 成员不属于整数 :</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> Color<span class="token punctuation">.</span>RED <span class="token operator">&lt;</span> Color<span class="token punctuation">.</span>BLUE
Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>
  File <span class="token string">"&lt;stdin>"</span><span class="token punctuation">,</span> line <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">></span>
TypeError<span class="token punctuation">:</span> <span class="token string">'&lt;'</span> <span class="token operator">not</span> supported between instances of <span class="token string">'Color'</span> <span class="token operator">and</span> <span class="token string">'Color'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>相等比较的定义如下:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> Color<span class="token punctuation">.</span>BLUE <span class="token operator">==</span> Color<span class="token punctuation">.</span>RED
<span class="token boolean">False</span>
<span class="token operator">>></span><span class="token operator">></span> Color<span class="token punctuation">.</span>BLUE <span class="token operator">!=</span> Color<span class="token punctuation">.</span>RED
<span class="token boolean">True</span>
<span class="token operator">>></span><span class="token operator">></span> Color<span class="token punctuation">.</span>BLUE <span class="token operator">==</span> Color<span class="token punctuation">.</span>BLUE
<span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>与非枚举值的比较将总是不相等（同样地，<code>IntEnum</code> 被显式设计成不同的行为，参见下文）:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> Color<span class="token punctuation">.</span>BLUE <span class="token operator">==</span> <span class="token number">2</span>
<span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h3 id="允许的枚举成员和属性"><a href="#允许的枚举成员和属性" class="headerlink" title="允许的枚举成员和属性"></a>允许的枚举成员和属性</h3><p>以上示例使用整数作为枚举值。 使用整数相当简洁方便（并由 Functional API 默认提供），但并不强制要求使用。 在大部分用例中，开发者都关心枚举的实际值是什么。 但如果值 <em>确实</em> 重要，则枚举可以使用任意的值。</p>
<p>枚举属于 Python 的类，并可具有普通方法和特殊方法。 如果我们有这样一个枚举:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">class</span> <span class="token class-name">Mood</span><span class="token punctuation">(</span>Enum<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     FUNKY <span class="token operator">=</span> <span class="token number">1</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     HAPPY <span class="token operator">=</span> <span class="token number">3</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">def</span> <span class="token function">describe</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         <span class="token comment" spellcheck="true"># self is the member here</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         <span class="token keyword">return</span> self<span class="token punctuation">.</span>name<span class="token punctuation">,</span> self<span class="token punctuation">.</span>value
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">def</span> <span class="token function">__str__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         <span class="token keyword">return</span> <span class="token string">'my custom str! {0}'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>self<span class="token punctuation">.</span>value<span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     @classmethod
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">def</span> <span class="token function">favorite_mood</span><span class="token punctuation">(</span>cls<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         <span class="token comment" spellcheck="true"># cls here is the enumeration</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         <span class="token keyword">return</span> cls<span class="token punctuation">.</span>HAPPY
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>那么:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> Mood<span class="token punctuation">.</span>favorite_mood<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">&lt;</span>Mood<span class="token punctuation">.</span>HAPPY<span class="token punctuation">:</span> <span class="token number">3</span><span class="token operator">></span>
<span class="token operator">>></span><span class="token operator">></span> Mood<span class="token punctuation">.</span>HAPPY<span class="token punctuation">.</span>describe<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token string">'HAPPY'</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> str<span class="token punctuation">(</span>Mood<span class="token punctuation">.</span>FUNKY<span class="token punctuation">)</span>
<span class="token string">'my custom str! 1'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>对于允许内容的规则如下：以单下划线开头和结尾的名称是由枚举保留而不可使用；在枚举中定义的所有其他属性将成为该枚举的成员，例外项则包括特殊方法成员 (<code>__str__()</code>, <code>__add__()</code> 等)，描述符 (方法也属于描述符) 以及在 <code>_ignore_</code> 中列出的变量名。</p>
<p>注意：如果你的枚举定义了 <code>__new__()</code> 和/或 <code>__init__()</code> 那么给予枚举成员的任何值都会被传入这些方法。 </p>
<h3 id="受限的-Enum-子类化"><a href="#受限的-Enum-子类化" class="headerlink" title="受限的 Enum 子类化"></a>受限的 Enum 子类化</h3><p>一个新的 <code>Enum</code> 类必须基于一个 Enum 类，至多一个实体数据类型以及出于实际需要的任意多个基于 <code>object</code> 的 mixin 类。 这些基类的顺序为:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">EnumName</span><span class="token punctuation">(</span><span class="token punctuation">[</span>mix<span class="token operator">-</span><span class="token keyword">in</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span><span class="token punctuation">]</span> <span class="token punctuation">[</span>data<span class="token operator">-</span>type<span class="token punctuation">,</span><span class="token punctuation">]</span> base<span class="token operator">-</span>enum<span class="token punctuation">)</span><span class="token punctuation">:</span>    
    <span class="token keyword">pass</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>另外，仅当一个枚举未定义任何成员时才允许子类化该枚举。 因此禁止这样的写法:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">class</span> <span class="token class-name">MoreColor</span><span class="token punctuation">(</span>Color<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     PINK <span class="token operator">=</span> <span class="token number">17</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
TypeError<span class="token punctuation">:</span> MoreColor<span class="token punctuation">:</span> cannot extend enumeration <span class="token string">'Color'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>但是允许这样的写法:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">class</span> <span class="token class-name">Foo</span><span class="token punctuation">(</span>Enum<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">def</span> <span class="token function">some_behavior</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         <span class="token keyword">pass</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">class</span> <span class="token class-name">Bar</span><span class="token punctuation">(</span>Foo<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     HAPPY <span class="token operator">=</span> <span class="token number">1</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     SAD <span class="token operator">=</span> <span class="token number">2</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>允许子类化定义了成员的枚举将会导致违反类型与实例的某些重要的不可变规则。 在另一方面，允许在一组枚举之间共享某些通用行为也是有意义的。</p>
<h3 id="封存"><a href="#封存" class="headerlink" title="封存"></a>封存</h3><p>枚举可以被封存与解封:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> test<span class="token punctuation">.</span>test_enum <span class="token keyword">import</span> Fruit
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> pickle <span class="token keyword">import</span> dumps<span class="token punctuation">,</span> loads
<span class="token operator">>></span><span class="token operator">></span> Fruit<span class="token punctuation">.</span>TOMATO <span class="token keyword">is</span> loads<span class="token punctuation">(</span>dumps<span class="token punctuation">(</span>Fruit<span class="token punctuation">.</span>TOMATO<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>封存的常规限制同样适用：可封存枚举必须在模块的最高层级中定义，因为解封操作要求它们可以从该模块导入。</p>
<p>注解</p>
<p>使用 pickle 协议版本 4 可以方便地封存嵌套在其他类中的枚举。</p>
<p>通过在枚举类中定义 <code>__reduce_ex__()</code> 可以对 Enum 成员的封存/解封方式进行修改。</p>
<h3 id="功能性-API"><a href="#功能性-API" class="headerlink" title="功能性 API"></a>功能性 API</h3><p><code>Enum</code> 类属于可调用对象，它提供了以下功能性 API:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> Animal <span class="token operator">=</span> Enum<span class="token punctuation">(</span><span class="token string">'Animal'</span><span class="token punctuation">,</span> <span class="token string">'ANT BEE CAT DOG'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> Animal
<span class="token operator">&lt;</span>enum <span class="token string">'Animal'</span><span class="token operator">></span>
<span class="token operator">>></span><span class="token operator">></span> Animal<span class="token punctuation">.</span>ANT
<span class="token operator">&lt;</span>Animal<span class="token punctuation">.</span>ANT<span class="token punctuation">:</span> <span class="token number">1</span><span class="token operator">></span>
<span class="token operator">>></span><span class="token operator">></span> Animal<span class="token punctuation">.</span>ANT<span class="token punctuation">.</span>value
<span class="token number">1</span>
<span class="token operator">>></span><span class="token operator">></span> list<span class="token punctuation">(</span>Animal<span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token operator">&lt;</span>Animal<span class="token punctuation">.</span>ANT<span class="token punctuation">:</span> <span class="token number">1</span><span class="token operator">></span><span class="token punctuation">,</span> <span class="token operator">&lt;</span>Animal<span class="token punctuation">.</span>BEE<span class="token punctuation">:</span> <span class="token number">2</span><span class="token operator">></span><span class="token punctuation">,</span> <span class="token operator">&lt;</span>Animal<span class="token punctuation">.</span>CAT<span class="token punctuation">:</span> <span class="token number">3</span><span class="token operator">></span><span class="token punctuation">,</span> <span class="token operator">&lt;</span>Animal<span class="token punctuation">.</span>DOG<span class="token punctuation">:</span> <span class="token number">4</span><span class="token operator">></span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>该 API 的主义类似于 <code>namedtuple</code>。 调用 <code>Enum</code> 的第一个参数是枚举的名称。</p>
<p>第二个参数是枚举成员名称的 <em>来源</em>。 它可以是一个用空格分隔的名称字符串、名称序列、键/值对 2 元组的序列，或者名称到值的映射（例如字典）。 最后两种选项使得可以为枚举任意赋值；其他选项会自动以从 1 开始递增的整数赋值（使用 <code>start</code> 形参可指定不同的起始值）。 返回值是一个派生自 <code>Enum</code> 的新类。 换句话说，以上对 <code>Animal</code> 的赋值就等价于:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">class</span> <span class="token class-name">Animal</span><span class="token punctuation">(</span>Enum<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     ANT <span class="token operator">=</span> <span class="token number">1</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     BEE <span class="token operator">=</span> <span class="token number">2</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     CAT <span class="token operator">=</span> <span class="token number">3</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     DOG <span class="token operator">=</span> <span class="token number">4</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>默认以 <code>1</code> 而以 <code>0</code> 作为起始数值的原因在于 <code>0</code> 的布尔值为 <code>False</code>，但所有枚举成员都应被求值为 <code>True</code>。</p>
<p>对使用功能性 API 创建的枚举执行封存可能会很麻烦，因为要使用帧堆栈的实现细节来尝试并找出枚举是在哪个模块中创建的（例如当你使用了另一个模块中的工具函数就可能失败，在 IronPython 或 Jython 上也可能无效）。 解决办法是显式地指定模块名称，如下所示:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> Animal <span class="token operator">=</span> Enum<span class="token punctuation">(</span><span class="token string">'Animal'</span><span class="token punctuation">,</span> <span class="token string">'ANT BEE CAT DOG'</span><span class="token punctuation">,</span> module<span class="token operator">=</span>__name__<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>警告</p>
<p>如果未提供 <code>module</code>，且 Enum 无法确定是哪个模块，新的 Enum 成员将不可被解封；为了让错误尽量靠近源头，封存将被禁用。</p>
<p>新的 pickle 协议版本 4 在某些情况下同样依赖于 <code>__qualname__</code> 被设为特定位置以便 pickle 能够找到相应的类。 例如，类是否存在于全局作用域的 SomeData 类中:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> Animal <span class="token operator">=</span> Enum<span class="token punctuation">(</span><span class="token string">'Animal'</span><span class="token punctuation">,</span> <span class="token string">'ANT BEE CAT DOG'</span><span class="token punctuation">,</span> qualname<span class="token operator">=</span><span class="token string">'SomeData.Animal'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>完整的签名为:</p>
<pre class="line-numbers language-python"><code class="language-python">Enum<span class="token punctuation">(</span>value<span class="token operator">=</span><span class="token string">'NewEnumName'</span><span class="token punctuation">,</span> names<span class="token operator">=</span><span class="token operator">&lt;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">></span><span class="token punctuation">,</span> <span class="token operator">*</span><span class="token punctuation">,</span> module<span class="token operator">=</span><span class="token string">'...'</span><span class="token punctuation">,</span> qualname<span class="token operator">=</span><span class="token string">'...'</span><span class="token punctuation">,</span> type<span class="token operator">=</span><span class="token operator">&lt;</span>mixed<span class="token operator">-</span><span class="token keyword">in</span> <span class="token keyword">class</span><span class="token operator">></span><span class="token punctuation">,</span> start<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>值</p>
<p>将被新 Enum 类将记录为其名称的数据。</p>
<p>names</p>
<p>Enum 的成员。 这可以是一个空格或逗号分隔的字符串 (起始值将为 1，除非另行指定):</p>
<pre><code>'RED GREEN BLUE' | 'RED,GREEN,BLUE' | 'RED, GREEN, BLUE'</code></pre><p>或是一个名称的迭代器:</p>
<pre><code>['RED', 'GREEN', 'BLUE']</code></pre><p>或是一个 (名称, 值) 对的迭代器:</p>
<pre><code>[('CYAN', 4), ('MAGENTA', 5), ('YELLOW', 6)]</code></pre><p>或是一个映射:</p>
<pre><code>{'CHARTREUSE': 7, 'SEA_GREEN': 11, 'ROSEMARY': 42}</code></pre><p>module — 模块</p>
<p>新 Enum 类所在模块的名称。</p>
<p>qualname</p>
<p>新 Enum 类在模块中的具体位置。</p>
<p>type — 类型</p>
<p>要加入新 Enum 类的类型。</p>
<p>start</p>
<p>当只传入名称时要使用的起始数值。</p>
<p>在 3.5 版更改: 增加了 <em>start</em> 形参。</p>
<h3 id="派生的枚举"><a href="#派生的枚举" class="headerlink" title="派生的枚举"></a>派生的枚举</h3><h4 id="IntEnum"><a href="#IntEnum" class="headerlink" title="IntEnum"></a>IntEnum</h4><p>所提供的第一个变种 <code>Enum</code> 同时也是 <code>int</code> 的一个子类。 <code>IntEnum</code> 的成员可与整数进行比较；通过扩展，不同类型的整数枚举也可以相互进行比较:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> enum <span class="token keyword">import</span> IntEnum
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">class</span> <span class="token class-name">Shape</span><span class="token punctuation">(</span>IntEnum<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     CIRCLE <span class="token operator">=</span> <span class="token number">1</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     SQUARE <span class="token operator">=</span> <span class="token number">2</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">class</span> <span class="token class-name">Request</span><span class="token punctuation">(</span>IntEnum<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     POST <span class="token operator">=</span> <span class="token number">1</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     GET <span class="token operator">=</span> <span class="token number">2</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> Shape <span class="token operator">==</span> <span class="token number">1</span>
<span class="token boolean">False</span>
<span class="token operator">>></span><span class="token operator">></span> Shape<span class="token punctuation">.</span>CIRCLE <span class="token operator">==</span> <span class="token number">1</span>
<span class="token boolean">True</span>
<span class="token operator">>></span><span class="token operator">></span> Shape<span class="token punctuation">.</span>CIRCLE <span class="token operator">==</span> Request<span class="token punctuation">.</span>POST
<span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>不过，它们仍然不可与标准 <code>Enum</code> 枚举进行比较:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">class</span> <span class="token class-name">Shape</span><span class="token punctuation">(</span>IntEnum<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     CIRCLE <span class="token operator">=</span> <span class="token number">1</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     SQUARE <span class="token operator">=</span> <span class="token number">2</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">class</span> <span class="token class-name">Color</span><span class="token punctuation">(</span>Enum<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     RED <span class="token operator">=</span> <span class="token number">1</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     GREEN <span class="token operator">=</span> <span class="token number">2</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> Shape<span class="token punctuation">.</span>CIRCLE <span class="token operator">==</span> Color<span class="token punctuation">.</span>RED
<span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>IntEnum</code> 值在其他方面的行为都如你预期的一样类似于整数:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> int<span class="token punctuation">(</span>Shape<span class="token punctuation">.</span>CIRCLE<span class="token punctuation">)</span>
<span class="token number">1</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token string">'c'</span><span class="token punctuation">]</span><span class="token punctuation">[</span>Shape<span class="token punctuation">.</span>CIRCLE<span class="token punctuation">]</span>
<span class="token string">'b'</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token punctuation">[</span>i <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>Shape<span class="token punctuation">.</span>SQUARE<span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="IntFlag"><a href="#IntFlag" class="headerlink" title="IntFlag"></a>IntFlag</h4><p>所提供的下一个 <code>Enum</code> 的变种 <code>IntFlag</code> 同样是基于 <code>int</code> 的，不同之处在于 <code>IntFlag</code> 成员可使用按位运算符 (&amp;, |, ^, ~) 进行组合且结果仍然为 <code>IntFlag</code> 成员。 如果，正如名称所表明的，<code>IntFlag</code> 成员同时也是 <code>int</code> 的子类，并能在任何使用 <code>int</code> 的场合被使用。 <code>IntFlag</code> 成员进行除按位运算以外的其他运算都将导致失去 <code>IntFlag</code> 成员资格。</p>
<p>3.6 新版功能.</p>
<p>示例 <code>IntFlag</code> 类:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> enum <span class="token keyword">import</span> IntFlag
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">class</span> <span class="token class-name">Perm</span><span class="token punctuation">(</span>IntFlag<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     R <span class="token operator">=</span> <span class="token number">4</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     W <span class="token operator">=</span> <span class="token number">2</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     X <span class="token operator">=</span> <span class="token number">1</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> Perm<span class="token punctuation">.</span>R <span class="token operator">|</span> Perm<span class="token punctuation">.</span>W
<span class="token operator">&lt;</span>Perm<span class="token punctuation">.</span>R<span class="token operator">|</span>W<span class="token punctuation">:</span> <span class="token number">6</span><span class="token operator">></span>
<span class="token operator">>></span><span class="token operator">></span> Perm<span class="token punctuation">.</span>R <span class="token operator">+</span> Perm<span class="token punctuation">.</span>W
<span class="token number">6</span>
<span class="token operator">>></span><span class="token operator">></span> RW <span class="token operator">=</span> Perm<span class="token punctuation">.</span>R <span class="token operator">|</span> Perm<span class="token punctuation">.</span>W
<span class="token operator">>></span><span class="token operator">></span> Perm<span class="token punctuation">.</span>R <span class="token keyword">in</span> RW
<span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>对于组合同样可以进行命名:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">class</span> <span class="token class-name">Perm</span><span class="token punctuation">(</span>IntFlag<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     R <span class="token operator">=</span> <span class="token number">4</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     W <span class="token operator">=</span> <span class="token number">2</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     X <span class="token operator">=</span> <span class="token number">1</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     RWX <span class="token operator">=</span> <span class="token number">7</span>
<span class="token operator">>></span><span class="token operator">></span> Perm<span class="token punctuation">.</span>RWX
<span class="token operator">&lt;</span>Perm<span class="token punctuation">.</span>RWX<span class="token punctuation">:</span> <span class="token number">7</span><span class="token operator">></span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token operator">~</span>Perm<span class="token punctuation">.</span>RWX
<span class="token operator">&lt;</span>Perm<span class="token punctuation">.</span><span class="token operator">-</span><span class="token number">8</span><span class="token punctuation">:</span> <span class="token operator">-</span><span class="token number">8</span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>IntFlag</code> 和 <code>Enum</code> 的另一个重要区别在于如果没有设置任何旗标（值为 0），则其布尔值为 <code>False</code>:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> Perm<span class="token punctuation">.</span>R <span class="token operator">&amp;</span> Perm<span class="token punctuation">.</span>X
<span class="token operator">&lt;</span>Perm<span class="token number">.0</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token operator">></span>
<span class="token operator">>></span><span class="token operator">></span> bool<span class="token punctuation">(</span>Perm<span class="token punctuation">.</span>R <span class="token operator">&amp;</span> Perm<span class="token punctuation">.</span>X<span class="token punctuation">)</span>
<span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>由于 <code>IntFlag</code> 成员同时也是 <code>int</code> 的子类，因此它们可以相互组合:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> Perm<span class="token punctuation">.</span>X <span class="token operator">|</span> <span class="token number">8</span>
<span class="token operator">&lt;</span>Perm<span class="token number">.8</span><span class="token operator">|</span>X<span class="token punctuation">:</span> <span class="token number">9</span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h4 id="旗标"><a href="#旗标" class="headerlink" title="旗标"></a>旗标</h4><p>最后一个变种是 <code>Flag</code>。 与 <code>IntFlag</code> 类似，<code>Flag</code> 成员可使用按位运算符 (&amp;, |, ^, ~) 进行组合，与 <code>IntFlag</code> 不同的是它们不可与任何其它 <code>Flag</code> 枚举或 <code>int</code> 进行组合或比较。 虽然可以直接指定值，但推荐使用 <code>auto</code> 作为值以便让 <code>Flag</code> 选择适当的值。</p>
<p>3.6 新版功能.</p>
<p>与 <code>IntFlag</code> 类似，如果 <code>Flag</code> 成员的某种组合导致没有设置任何旗标，则其布尔值为 <code>False</code>:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> enum <span class="token keyword">import</span> Flag<span class="token punctuation">,</span> auto
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">class</span> <span class="token class-name">Color</span><span class="token punctuation">(</span>Flag<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     RED <span class="token operator">=</span> auto<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     BLUE <span class="token operator">=</span> auto<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     GREEN <span class="token operator">=</span> auto<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> Color<span class="token punctuation">.</span>RED <span class="token operator">&amp;</span> Color<span class="token punctuation">.</span>GREEN
<span class="token operator">&lt;</span>Color<span class="token number">.0</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token operator">></span>
<span class="token operator">>></span><span class="token operator">></span> bool<span class="token punctuation">(</span>Color<span class="token punctuation">.</span>RED <span class="token operator">&amp;</span> Color<span class="token punctuation">.</span>GREEN<span class="token punctuation">)</span>
<span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>单个旗标的值应当为二的乘方 (1, 2, 4, 8, …)，旗标的组合则无此限制:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">class</span> <span class="token class-name">Color</span><span class="token punctuation">(</span>Flag<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     RED <span class="token operator">=</span> auto<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     BLUE <span class="token operator">=</span> auto<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     GREEN <span class="token operator">=</span> auto<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     WHITE <span class="token operator">=</span> RED <span class="token operator">|</span> BLUE <span class="token operator">|</span> GREEN
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> Color<span class="token punctuation">.</span>WHITE
<span class="token operator">&lt;</span>Color<span class="token punctuation">.</span>WHITE<span class="token punctuation">:</span> <span class="token number">7</span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>对 “no flags set” 条件指定一个名称并不会改变其布尔值:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">class</span> <span class="token class-name">Color</span><span class="token punctuation">(</span>Flag<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     BLACK <span class="token operator">=</span> <span class="token number">0</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     RED <span class="token operator">=</span> auto<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     BLUE <span class="token operator">=</span> auto<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     GREEN <span class="token operator">=</span> auto<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> Color<span class="token punctuation">.</span>BLACK
<span class="token operator">&lt;</span>Color<span class="token punctuation">.</span>BLACK<span class="token punctuation">:</span> <span class="token number">0</span><span class="token operator">></span>
<span class="token operator">>></span><span class="token operator">></span> bool<span class="token punctuation">(</span>Color<span class="token punctuation">.</span>BLACK<span class="token punctuation">)</span>
<span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>注解</p>
<p>对于大多数新代码，强烈推荐使用 <code>Enum</code> 和 <code>Flag</code>，因为 <code>IntEnum</code> 和 <code>IntFlag</code> 打破了枚举的某些语义约定（例如可以同整数进行比较，并因而导致此行为被传递给其他无关的枚举）。 <code>IntEnum</code> 和 <code>IntFlag</code> 的使用应当仅限于 <code>Enum</code> 和 <code>Flag</code> 无法使用的场合；例如，当使用枚举替代整数常量时，或是与其他系统进行交互操作时。</p>
<h4 id="其他事项"><a href="#其他事项" class="headerlink" title="其他事项"></a>其他事项</h4><p>虽然 <code>IntEnum</code> 是 <code>enum</code> 模块的一部分，但要独立实现也应该相当容易:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">IntEnum</span><span class="token punctuation">(</span>int<span class="token punctuation">,</span> Enum<span class="token punctuation">)</span><span class="token punctuation">:</span>    
    <span class="token keyword">pass</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>这里演示了如何定义类似的派生枚举；例如一个混合了 <code>str</code> 而不是 <code>int</code> 的 <code>StrEnum</code>。</p>
<p>几条规则：</p>
<ol>
<li>当子类化 <code>Enum</code> 时，在基类序列中的混合类型必须出现于 <code>Enum</code> 本身之前，如以上 <code>IntEnum</code> 的例子所示。</li>
<li>虽然 <code>Enum</code> 可以拥有任意类型的成员，不过一旦你混合了附加类型，则所有成员必须为相应类型的值，如在上面的例子中即为 <code>int</code>。 此限制不适用于仅添加方法而未指定另一数据类型的混合类。</li>
<li>当混合了另一数据类型时，<code>value</code> 属性会 <em>不同于</em> 枚举成员自身，但它们仍保持等价且比较结果也相等。</li>
<li>%-style formatting: %s 和 %r 会分别调用 <code>Enum</code> 类的 <code>__str__()</code> 和 <code>__repr__()</code>；其他代码 (例如表示 IntEnum 的 %i 或 %h) 会将枚举成员视为对应的混合类型。</li>
<li>格式化字符串字面值, <code>str.format()</code> 和 <code>format()</code> 将使用混合类型的 <code>__format__()</code> 除非在子类中重载了 <code>__str__()</code> 或 <code>__format__()</code>，在这种情况下将使用被重载的方法或 <code>Enum</code> 的方法。 请使用 !s 和 !r 格式代码来强制使用 <code>Enum</code> 类的 <code>__str__()</code> 和 <code>__repr__()</code> 方法。</li>
</ol>
<h3 id="何时使用-new-与-init"><a href="#何时使用-new-与-init" class="headerlink" title="何时使用 __new__() 与 __init__()"></a>何时使用 <code>__new__()</code> 与 <code>__init__()</code></h3><p>当你想要定制 <code>Enum</code> 成员的实际值时必须使用 <code>__new__()</code>。 任何其他修改可以用 <code>__new__()</code> 也可以用 <code>__init__()</code>，应优先使用 <code>__init__()</code>。</p>
<p>举例来说，如果你要向构造器传入多个条目，但只希望将其中一个作为值:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">class</span> <span class="token class-name">Coordinate</span><span class="token punctuation">(</span>bytes<span class="token punctuation">,</span> Enum<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token triple-quoted-string string">"""
...     Coordinate with binary codes that can be indexed by the int code.
...     """</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">def</span> <span class="token function">__new__</span><span class="token punctuation">(</span>cls<span class="token punctuation">,</span> value<span class="token punctuation">,</span> label<span class="token punctuation">,</span> unit<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         obj <span class="token operator">=</span> bytes<span class="token punctuation">.</span>__new__<span class="token punctuation">(</span>cls<span class="token punctuation">,</span> <span class="token punctuation">[</span>value<span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         obj<span class="token punctuation">.</span>_value_ <span class="token operator">=</span> value
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         obj<span class="token punctuation">.</span>label <span class="token operator">=</span> label
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         obj<span class="token punctuation">.</span>unit <span class="token operator">=</span> unit
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         <span class="token keyword">return</span> obj
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     PX <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">'P.X'</span><span class="token punctuation">,</span> <span class="token string">'km'</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     PY <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'P.Y'</span><span class="token punctuation">,</span> <span class="token string">'km'</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     VX <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">'V.X'</span><span class="token punctuation">,</span> <span class="token string">'km/s'</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     VY <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">'V.Y'</span><span class="token punctuation">,</span> <span class="token string">'km/s'</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>Coordinate<span class="token punctuation">[</span><span class="token string">'PY'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
Coordinate<span class="token punctuation">.</span>PY
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>Coordinate<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
Coordinate<span class="token punctuation">.</span>VY<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="有趣的示例"><a href="#有趣的示例" class="headerlink" title="有趣的示例"></a>有趣的示例</h3><p>虽然 <code>Enum</code>, <code>IntEnum</code>, <code>IntFlag</code> 和 <code>Flag</code> 预期可覆盖大多数应用场景，但它们无法覆盖全部。 这里有一些不同类型枚举的方案，它们可以被直接使用，或是作为自行创建的参考示例。</p>
<h4 id="省略值"><a href="#省略值" class="headerlink" title="省略值"></a>省略值</h4><p>在许多应用场景中人们都不关心枚举的实际值是什么。 有几个方式可以定义此种类型的简单枚举：</p>
<ul>
<li>使用 <code>auto</code> 的实例作为值</li>
<li>使用 <code>object</code> 的实例作为值</li>
<li>使用描述性的字符串作为值</li>
<li>使用元组作为值并用自定义的 <code>__new__()</code> 以一个 <code>int</code> 值来替代该元组</li>
</ul>
<p>使用以上任何一种方法均可向用户指明值并不重要，并且使人能够添加、移除或重排序成员而不必改变其余成员的数值。</p>
<p>无论你选择何种方法，你都应当提供一个 <code>repr()</code> 并且它也需要隐藏（不重要的）值:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">class</span> <span class="token class-name">NoValue</span><span class="token punctuation">(</span>Enum<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">def</span> <span class="token function">__repr__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         <span class="token keyword">return</span> <span class="token string">'&lt;%s.%s>'</span> <span class="token operator">%</span> <span class="token punctuation">(</span>self<span class="token punctuation">.</span>__class__<span class="token punctuation">.</span>__name__<span class="token punctuation">,</span> self<span class="token punctuation">.</span>name<span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h5 id="使用-auto"><a href="#使用-auto" class="headerlink" title="使用 auto"></a>使用 <code>auto</code></h5><p>使用 <code>auto</code> 的形式如下:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">class</span> <span class="token class-name">Color</span><span class="token punctuation">(</span>NoValue<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     RED <span class="token operator">=</span> auto<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     BLUE <span class="token operator">=</span> auto<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     GREEN <span class="token operator">=</span> auto<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> Color<span class="token punctuation">.</span>GREEN
<span class="token operator">&lt;</span>Color<span class="token punctuation">.</span>GREEN<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h5 id="使用-object"><a href="#使用-object" class="headerlink" title="使用 object"></a>使用 <code>object</code></h5><p>使用 <code>object</code> 的形式如下:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">class</span> <span class="token class-name">Color</span><span class="token punctuation">(</span>NoValue<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     RED <span class="token operator">=</span> object<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     GREEN <span class="token operator">=</span> object<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     BLUE <span class="token operator">=</span> object<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> Color<span class="token punctuation">.</span>GREEN
<span class="token operator">&lt;</span>Color<span class="token punctuation">.</span>GREEN<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h5 id="使用描述性字符串"><a href="#使用描述性字符串" class="headerlink" title="使用描述性字符串"></a>使用描述性字符串</h5><p>使用字符串作为值的形式如下:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">class</span> <span class="token class-name">Color</span><span class="token punctuation">(</span>NoValue<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     RED <span class="token operator">=</span> <span class="token string">'stop'</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     GREEN <span class="token operator">=</span> <span class="token string">'go'</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     BLUE <span class="token operator">=</span> <span class="token string">'too fast!'</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> Color<span class="token punctuation">.</span>GREEN
<span class="token operator">&lt;</span>Color<span class="token punctuation">.</span>GREEN<span class="token operator">></span>
<span class="token operator">>></span><span class="token operator">></span> Color<span class="token punctuation">.</span>GREEN<span class="token punctuation">.</span>value
<span class="token string">'go'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h5 id="使用自定义的-new"><a href="#使用自定义的-new" class="headerlink" title="使用自定义的 __new__()"></a>使用自定义的 <code>__new__()</code></h5><p>使用自动编号 <code>__new__()</code> 的形式如下:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">class</span> <span class="token class-name">AutoNumber</span><span class="token punctuation">(</span>NoValue<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">def</span> <span class="token function">__new__</span><span class="token punctuation">(</span>cls<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         value <span class="token operator">=</span> len<span class="token punctuation">(</span>cls<span class="token punctuation">.</span>__members__<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         obj <span class="token operator">=</span> object<span class="token punctuation">.</span>__new__<span class="token punctuation">(</span>cls<span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         obj<span class="token punctuation">.</span>_value_ <span class="token operator">=</span> value
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         <span class="token keyword">return</span> obj
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">class</span> <span class="token class-name">Color</span><span class="token punctuation">(</span>AutoNumber<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     RED <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     GREEN <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     BLUE <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> Color<span class="token punctuation">.</span>GREEN
<span class="token operator">&lt;</span>Color<span class="token punctuation">.</span>GREEN<span class="token operator">></span>
<span class="token operator">>></span><span class="token operator">></span> Color<span class="token punctuation">.</span>GREEN<span class="token punctuation">.</span>value
<span class="token number">2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>要实现更通用的 <code>AutoNumber</code>，请添加 <code>*args</code> 到签名中:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">class</span> <span class="token class-name">AutoNumber</span><span class="token punctuation">(</span>NoValue<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">def</span> <span class="token function">__new__</span><span class="token punctuation">(</span>cls<span class="token punctuation">,</span> <span class="token operator">*</span>args<span class="token punctuation">)</span><span class="token punctuation">:</span>      <span class="token comment" spellcheck="true"># this is the only change from above</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         value <span class="token operator">=</span> len<span class="token punctuation">(</span>cls<span class="token punctuation">.</span>__members__<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         obj <span class="token operator">=</span> object<span class="token punctuation">.</span>__new__<span class="token punctuation">(</span>cls<span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         obj<span class="token punctuation">.</span>_value_ <span class="token operator">=</span> value
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         <span class="token keyword">return</span> obj
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这样当你从 <code>AutoNumber</code> 继承时你将可以编写你自己的 <code>__init__</code> 来处理任何附加参数:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">class</span> <span class="token class-name">Swatch</span><span class="token punctuation">(</span>AutoNumber<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> pantone<span class="token operator">=</span><span class="token string">'unknown'</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         self<span class="token punctuation">.</span>pantone <span class="token operator">=</span> pantone
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     AUBURN <span class="token operator">=</span> <span class="token string">'3497'</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     SEA_GREEN <span class="token operator">=</span> <span class="token string">'1246'</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     BLEACHED_CORAL <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># New color, no Pantone code yet!</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> Swatch<span class="token punctuation">.</span>SEA_GREEN
<span class="token operator">&lt;</span>Swatch<span class="token punctuation">.</span>SEA_GREEN<span class="token operator">></span>
<span class="token operator">>></span><span class="token operator">></span> Swatch<span class="token punctuation">.</span>SEA_GREEN<span class="token punctuation">.</span>pantone
<span class="token string">'1246'</span>
<span class="token operator">>></span><span class="token operator">></span> Swatch<span class="token punctuation">.</span>BLEACHED_CORAL<span class="token punctuation">.</span>pantone
<span class="token string">'unknown'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>注解</p>
<p>如果定义了 <code>__new__()</code> 则它会在创建 Enum 成员期间被使用；随后它将被 Enum 的 <code>__new__()</code> 所替换，该方法会在类创建后被用来查找现有成员。</p>
<h4 id="OrderedEnum"><a href="#OrderedEnum" class="headerlink" title="OrderedEnum"></a>OrderedEnum</h4><p>一个有序枚举，它不是基于 <code>IntEnum</code>，因此保持了正常的 <code>Enum</code> 不变特性（例如不可与其他枚举进行比较）:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">class</span> <span class="token class-name">OrderedEnum</span><span class="token punctuation">(</span>Enum<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">def</span> <span class="token function">__ge__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> other<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         <span class="token keyword">if</span> self<span class="token punctuation">.</span>__class__ <span class="token keyword">is</span> other<span class="token punctuation">.</span>__class__<span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>             <span class="token keyword">return</span> self<span class="token punctuation">.</span>value <span class="token operator">>=</span> other<span class="token punctuation">.</span>value
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         <span class="token keyword">return</span> NotImplemented
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">def</span> <span class="token function">__gt__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> other<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         <span class="token keyword">if</span> self<span class="token punctuation">.</span>__class__ <span class="token keyword">is</span> other<span class="token punctuation">.</span>__class__<span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>             <span class="token keyword">return</span> self<span class="token punctuation">.</span>value <span class="token operator">></span> other<span class="token punctuation">.</span>value
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         <span class="token keyword">return</span> NotImplemented
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">def</span> <span class="token function">__le__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> other<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         <span class="token keyword">if</span> self<span class="token punctuation">.</span>__class__ <span class="token keyword">is</span> other<span class="token punctuation">.</span>__class__<span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>             <span class="token keyword">return</span> self<span class="token punctuation">.</span>value <span class="token operator">&lt;=</span> other<span class="token punctuation">.</span>value
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         <span class="token keyword">return</span> NotImplemented
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">def</span> <span class="token function">__lt__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> other<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         <span class="token keyword">if</span> self<span class="token punctuation">.</span>__class__ <span class="token keyword">is</span> other<span class="token punctuation">.</span>__class__<span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>             <span class="token keyword">return</span> self<span class="token punctuation">.</span>value <span class="token operator">&lt;</span> other<span class="token punctuation">.</span>value
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         <span class="token keyword">return</span> NotImplemented
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">class</span> <span class="token class-name">Grade</span><span class="token punctuation">(</span>OrderedEnum<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     A <span class="token operator">=</span> <span class="token number">5</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     B <span class="token operator">=</span> <span class="token number">4</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     C <span class="token operator">=</span> <span class="token number">3</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     D <span class="token operator">=</span> <span class="token number">2</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     F <span class="token operator">=</span> <span class="token number">1</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> Grade<span class="token punctuation">.</span>C <span class="token operator">&lt;</span> Grade<span class="token punctuation">.</span>A
<span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>DuplicateFreeEnum</p>
<p>如果发现重复的成员名称则将引发错误而不是创建别名:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">class</span> <span class="token class-name">DuplicateFreeEnum</span><span class="token punctuation">(</span>Enum<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> <span class="token operator">*</span>args<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         cls <span class="token operator">=</span> self<span class="token punctuation">.</span>__class__
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         <span class="token keyword">if</span> any<span class="token punctuation">(</span>self<span class="token punctuation">.</span>value <span class="token operator">==</span> e<span class="token punctuation">.</span>value <span class="token keyword">for</span> e <span class="token keyword">in</span> cls<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>             a <span class="token operator">=</span> self<span class="token punctuation">.</span>name
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>             e <span class="token operator">=</span> cls<span class="token punctuation">(</span>self<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">.</span>name
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>             <span class="token keyword">raise</span> ValueError<span class="token punctuation">(</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                 <span class="token string">"aliases not allowed in DuplicateFreeEnum:  %r --> %r"</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                 <span class="token operator">%</span> <span class="token punctuation">(</span>a<span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">class</span> <span class="token class-name">Color</span><span class="token punctuation">(</span>DuplicateFreeEnum<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     RED <span class="token operator">=</span> <span class="token number">1</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     GREEN <span class="token operator">=</span> <span class="token number">2</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     BLUE <span class="token operator">=</span> <span class="token number">3</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     GRENE <span class="token operator">=</span> <span class="token number">2</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
ValueError<span class="token punctuation">:</span> aliases <span class="token operator">not</span> allowed <span class="token keyword">in</span> DuplicateFreeEnum<span class="token punctuation">:</span>  <span class="token string">'GRENE'</span> <span class="token operator">-</span><span class="token operator">-</span><span class="token operator">></span> <span class="token string">'GREEN'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>注解</p>
<p>这个例子适用于子类化 Enum 来添加或改变禁用别名以及其他行为。 如果需要的改变只是禁用别名，也可以选择使用 <code>unique()</code> 装饰器。</p>
<h4 id="Planet"><a href="#Planet" class="headerlink" title="Planet"></a>Planet</h4><p>如果定义了 <code>__new__()</code> 或 <code>__init__()</code> 则枚举成员的值将被传给这些方法:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">class</span> <span class="token class-name">Planet</span><span class="token punctuation">(</span>Enum<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     MERCURY <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">3.303e+23</span><span class="token punctuation">,</span> <span class="token number">2.4397e6</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     VENUS   <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">4.869e+24</span><span class="token punctuation">,</span> <span class="token number">6.0518e6</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     EARTH   <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">5.976e+24</span><span class="token punctuation">,</span> <span class="token number">6.37814e6</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     MARS    <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">6.421e+23</span><span class="token punctuation">,</span> <span class="token number">3.3972e6</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     JUPITER <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1.9e+27</span><span class="token punctuation">,</span>   <span class="token number">7.1492e7</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     SATURN  <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">5.688e+26</span><span class="token punctuation">,</span> <span class="token number">6.0268e7</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     URANUS  <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">8.686e+25</span><span class="token punctuation">,</span> <span class="token number">2.5559e7</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     NEPTUNE <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1.024e+26</span><span class="token punctuation">,</span> <span class="token number">2.4746e7</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> mass<span class="token punctuation">,</span> radius<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         self<span class="token punctuation">.</span>mass <span class="token operator">=</span> mass       <span class="token comment" spellcheck="true"># in kilograms</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         self<span class="token punctuation">.</span>radius <span class="token operator">=</span> radius   <span class="token comment" spellcheck="true"># in meters</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     @property
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">def</span> <span class="token function">surface_gravity</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         <span class="token comment" spellcheck="true"># universal gravitational constant  (m3 kg-1 s-2)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         G <span class="token operator">=</span> <span class="token number">6.67300E-11</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         <span class="token keyword">return</span> G <span class="token operator">*</span> self<span class="token punctuation">.</span>mass <span class="token operator">/</span> <span class="token punctuation">(</span>self<span class="token punctuation">.</span>radius <span class="token operator">*</span> self<span class="token punctuation">.</span>radius<span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> Planet<span class="token punctuation">.</span>EARTH<span class="token punctuation">.</span>value
<span class="token punctuation">(</span><span class="token number">5.976e+24</span><span class="token punctuation">,</span> <span class="token number">6378140.0</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> Planet<span class="token punctuation">.</span>EARTH<span class="token punctuation">.</span>surface_gravity
<span class="token number">9.802652743337129</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="TimePeriod"><a href="#TimePeriod" class="headerlink" title="TimePeriod"></a>TimePeriod</h4><p>一个演示如何使用 <code>_ignore_</code> 属性的例子:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> datetime <span class="token keyword">import</span> timedelta
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">class</span> <span class="token class-name">Period</span><span class="token punctuation">(</span>timedelta<span class="token punctuation">,</span> Enum<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token string">"different lengths of time"</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     _ignore_ <span class="token operator">=</span> <span class="token string">'Period i'</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     Period <span class="token operator">=</span> vars<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">367</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         Period<span class="token punctuation">[</span><span class="token string">'day_%d'</span> <span class="token operator">%</span> i<span class="token punctuation">]</span> <span class="token operator">=</span> i
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> list<span class="token punctuation">(</span>Period<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token operator">&lt;</span>Period<span class="token punctuation">.</span>day_0<span class="token punctuation">:</span> datetime<span class="token punctuation">.</span>timedelta<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">></span><span class="token punctuation">,</span> <span class="token operator">&lt;</span>Period<span class="token punctuation">.</span>day_1<span class="token punctuation">:</span> datetime<span class="token punctuation">.</span>timedelta<span class="token punctuation">(</span>days<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">></span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> list<span class="token punctuation">(</span>Period<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token operator">&lt;</span>Period<span class="token punctuation">.</span>day_365<span class="token punctuation">:</span> datetime<span class="token punctuation">.</span>timedelta<span class="token punctuation">(</span>days<span class="token operator">=</span><span class="token number">365</span><span class="token punctuation">)</span><span class="token operator">></span><span class="token punctuation">,</span> <span class="token operator">&lt;</span>Period<span class="token punctuation">.</span>day_366<span class="token punctuation">:</span> datetime<span class="token punctuation">.</span>timedelta<span class="token punctuation">(</span>days<span class="token operator">=</span><span class="token number">366</span><span class="token punctuation">)</span><span class="token operator">></span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="各种枚举有何区别？"><a href="#各种枚举有何区别？" class="headerlink" title="各种枚举有何区别？"></a>各种枚举有何区别？</h3><p>枚举具有自定义的元类，它会影响所派生枚举类及其实例（成员）的各个方面。</p>
<h4 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h4><p><code>EnumMeta</code> 元类负责提供 <code>__contains__()</code>, <code>__dir__()</code>, <code>__iter__()</code> 及其他方法以允许用户通过 <code>Enum</code> 类来完成一般类做不到的事情，例如 list(Color) 或 some_enum_var in Color。 <code>EnumMeta</code> 会负责确保最终 <code>Enum</code> 类中的各种其他方法是正确的 (例如 <code>__new__()</code>, <code>__getnewargs__()</code>, <code>__str__()</code> 和 <code>__repr__()</code>)。</p>
<h4 id="枚举成员（即实例）"><a href="#枚举成员（即实例）" class="headerlink" title="枚举成员（即实例）"></a>枚举成员（即实例）</h4><p>有关枚举成员最有趣的特点是它们都是单例对象。 <code>EnumMeta</code> 会在创建 <code>Enum</code> 类本身时将它们全部创建完成，然后准备好一个自定义的 <code>__new__()</code>，通过只返回现有的成员实例来确保不会再实例化新的对象。</p>
<h4 id="细节要点"><a href="#细节要点" class="headerlink" title="细节要点"></a>细节要点</h4><h5 id="支持的-dunder-名称"><a href="#支持的-dunder-名称" class="headerlink" title="支持的 __dunder__ 名称"></a>支持的 <code>__dunder__</code> 名称</h5><p><code>__members__</code> 是一个 <code>member_name</code>:<code>member</code> 条目的只读有序映射。 它只在类上可用。</p>
<p>如果指定了 <code>__new__()</code>，它必须创建并返回枚举成员；相应地设定成员的 <code>_value_</code> 也是一个很好的主意。 一旦所有成员都创建完成它就不会再被使用。</p>
<h5 id="支持的-sunder-名称"><a href="#支持的-sunder-名称" class="headerlink" title="支持的 _sunder_ 名称"></a>支持的 <code>_sunder_</code> 名称</h5><ul>
<li><code>_name_</code> — 成员的名称</li>
<li><code>_value_</code> — 成员的值；可以在 <code>__new__</code> 中设置 / 修改</li>
<li><code>_missing_</code> — 当未发现某个值时所使用的查找函数；可被重载</li>
<li><code>_ignore_</code> — 一个名称列表，可以为 <code>list</code> 或 <code>str</code>，它不会被转化为成员，并将从最终类中被移除</li>
<li><code>_order_</code> — 用于 Python 2/3 代码以确保成员顺序一致（类属性，在类创建期间会被移除）</li>
<li><code>_generate_next_value_</code> — 用于 Functional API 并通过 <code>auto</code> 为枚举成员获取适当的值；可被重载</li>
</ul>
<p>3.6 新版功能: <code>_missing_</code>, <code>_order_</code>, <code>_generate_next_value_</code></p>
<p>3.7 新版功能: <code>_ignore_</code></p>
<p>用来帮助 Python 2 / Python 3 代码保持同步提供 <code>_order_</code> 属性。 它将与枚举的实际顺序进行对照检查，如果两者不匹配则会引发错误:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">class</span> <span class="token class-name">Color</span><span class="token punctuation">(</span>Enum<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     _order_ <span class="token operator">=</span> <span class="token string">'RED GREEN BLUE'</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     RED <span class="token operator">=</span> <span class="token number">1</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     BLUE <span class="token operator">=</span> <span class="token number">3</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     GREEN <span class="token operator">=</span> <span class="token number">2</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
TypeError<span class="token punctuation">:</span> member order does <span class="token operator">not</span> match _order_<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>注解</p>
<p>在 Python 2 代码中 <code>_order_</code> 属性是必须的，因为定义顺序在被记录之前就会丢失。</p>
<h5 id="Private-names"><a href="#Private-names" class="headerlink" title="_Private__names"></a>_Private__names</h5><p>私有名称在 Python 3.10 中将成为普通属性而不再是错误或成员（具体取决于该名称是否以一个下划线结束）。 在 3.9 中使用这种名称将引发 <code>DeprecationWarning</code>。</p>
<h5 id="Enum-成员类型"><a href="#Enum-成员类型" class="headerlink" title="Enum 成员类型"></a><code>Enum</code> 成员类型</h5><p><code>Enum</code> 成员是其 <code>Enum</code> 类的实例，一般通过 <code>EnumClass.member</code> 的形式来访问。 在特定情况下它们也可通过 <code>EnumClass.member.member</code> 的形式来访问，但你绝对不应这样做，因为查找可能失败，或者更糟糕地返回你所查找的 <a href="https://www.bookstack.cn/read/python-3.10.0-zh/9a3cab107160daab.md#enum.Enum" target="_blank" rel="noopener"><code>Enum</code></a> 成员以外的对象（这也是成员应使用全大写名称的另一个好理由）:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">class</span> <span class="token class-name">FieldTypes</span><span class="token punctuation">(</span>Enum<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     name <span class="token operator">=</span> <span class="token number">0</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     value <span class="token operator">=</span> <span class="token number">1</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     size <span class="token operator">=</span> <span class="token number">2</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> FieldTypes<span class="token punctuation">.</span>value<span class="token punctuation">.</span>size
<span class="token operator">&lt;</span>FieldTypes<span class="token punctuation">.</span>size<span class="token punctuation">:</span> <span class="token number">2</span><span class="token operator">></span>
<span class="token operator">>></span><span class="token operator">></span> FieldTypes<span class="token punctuation">.</span>size<span class="token punctuation">.</span>value
<span class="token number">2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在 3.5 版更改.</p>
<h5 id="Enum-类和成员的布尔值"><a href="#Enum-类和成员的布尔值" class="headerlink" title="Enum 类和成员的布尔值"></a><code>Enum</code> 类和成员的布尔值</h5><p>混合了非 <code>Enum</code> 类型（例如 <code>int</code>, <code>str</code> 等）的 <code>Enum</code> 成员会按所混合类型的规则被求值；在其他情况下，所有成员都将被求值为 <code>True</code>。 要使你的自定义 Enum 的布尔值取决于成员的值，请在你的类中添加以下代码:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">__bool__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">return</span> bool<span class="token punctuation">(</span>self<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><code>Enum</code> 类总是会被求值为 <code>True</code>。</p>
<h5 id="带有方法的-Enum-类"><a href="#带有方法的-Enum-类" class="headerlink" title="带有方法的 Enum 类"></a>带有方法的 <code>Enum</code> 类</h5><p>如果你为你的 <code>Enum</code> 子类添加了额外的方法，如同上述的 Planet 类一样，这些方法将在对成员执行 <code>dir()</code> 时显示出来，但对类执行时则不会显示:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> dir<span class="token punctuation">(</span>Planet<span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token string">'EARTH'</span><span class="token punctuation">,</span> <span class="token string">'JUPITER'</span><span class="token punctuation">,</span> <span class="token string">'MARS'</span><span class="token punctuation">,</span> <span class="token string">'MERCURY'</span><span class="token punctuation">,</span> <span class="token string">'NEPTUNE'</span><span class="token punctuation">,</span> <span class="token string">'SATURN'</span><span class="token punctuation">,</span> <span class="token string">'URANUS'</span><span class="token punctuation">,</span> <span class="token string">'VENUS'</span><span class="token punctuation">,</span> <span class="token string">'__class__'</span><span class="token punctuation">,</span> <span class="token string">'__doc__'</span><span class="token punctuation">,</span> <span class="token string">'__members__'</span><span class="token punctuation">,</span> <span class="token string">'__module__'</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> dir<span class="token punctuation">(</span>Planet<span class="token punctuation">.</span>EARTH<span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token string">'__class__'</span><span class="token punctuation">,</span> <span class="token string">'__doc__'</span><span class="token punctuation">,</span> <span class="token string">'__module__'</span><span class="token punctuation">,</span> <span class="token string">'mass'</span><span class="token punctuation">,</span> <span class="token string">'name'</span><span class="token punctuation">,</span> <span class="token string">'radius'</span><span class="token punctuation">,</span> <span class="token string">'surface_gravity'</span><span class="token punctuation">,</span> <span class="token string">'value'</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h5 id="组合-Flag-的成员"><a href="#组合-Flag-的成员" class="headerlink" title="组合 Flag 的成员"></a>组合 <code>Flag</code> 的成员</h5><p>如果 Flag 成员的某种组合未被命名，则 <code>repr()</code> 将包含所有已命名的旗标和值中所有已命名的旗标组合:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">class</span> <span class="token class-name">Color</span><span class="token punctuation">(</span>Flag<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     RED <span class="token operator">=</span> auto<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     GREEN <span class="token operator">=</span> auto<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     BLUE <span class="token operator">=</span> auto<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     MAGENTA <span class="token operator">=</span> RED <span class="token operator">|</span> BLUE
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     YELLOW <span class="token operator">=</span> RED <span class="token operator">|</span> GREEN
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     CYAN <span class="token operator">=</span> GREEN <span class="token operator">|</span> BLUE
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> Color<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># named combination</span>
<span class="token operator">&lt;</span>Color<span class="token punctuation">.</span>YELLOW<span class="token punctuation">:</span> <span class="token number">3</span><span class="token operator">></span>
<span class="token operator">>></span><span class="token operator">></span> Color<span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span>      <span class="token comment" spellcheck="true"># not named combination</span>
<span class="token operator">&lt;</span>Color<span class="token punctuation">.</span>CYAN<span class="token operator">|</span>MAGENTA<span class="token operator">|</span>BLUE<span class="token operator">|</span>YELLOW<span class="token operator">|</span>GREEN<span class="token operator">|</span>RED<span class="token punctuation">:</span> <span class="token number">7</span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="graphlib-—-操作类似图的结构的功能"><a href="#graphlib-—-操作类似图的结构的功能" class="headerlink" title="graphlib —- 操作类似图的结构的功能"></a><code>graphlib</code> —- 操作类似图的结构的功能</h2><p><strong>源代码:</strong> <a href="https://github.com/python/cpython/tree/3.10/Lib/graphlib.py" target="_blank" rel="noopener">Lib/graphlib.py</a></p>
<hr>
<p><em>class</em> <code>graphlib.TopologicalSorter</code>(<em>graph=None</em>)</p>
<p>提供以拓扑方式对可哈希节点的图进行排序的功能。</p>
<p>拓扑排序是指图中顶点的线性排序，使得对于每条从顶点 u 到顶点 v 的有向边 u -&gt; v，顶点 u 都排在顶点 v 之前。 例如，图的顶点可以代表要执行的任务，而边代表某一个任务必须在另一个任务之前执行的约束条件；在这个例子中，拓扑排序只是任务的有效序列。 完全拓扑排序 当且仅当图不包含有向环，也就是说为有向无环图时，完全拓扑排序才是可能的。</p>
<p>如果提供了可选的 <em>graph</em> 参数则它必须为一个表示有向无环图的字典，其中的键为节点而值为包含图中该节点的所有上级节点（即具有指向键中的值的边的节点）的可迭代对象。 额外的节点可以使用 <code>add()</code> 方法添加到图中。</p>
<p>在通常情况下，对给定的图执行排序所需的步骤如下:</p>
<blockquote>
<ul>
<li>通过可选的初始图创建一个 <code>TopologicalSorter</code> 的实例。</li>
<li>添加额外的节点到图中。</li>
<li>在图上调用 <code>prepare()</code>。</li>
<li>当 <code>is_active()</code> 为 <code>True</code> 时，迭代 <code>get_ready()</code> 所返回的节点并加以处理。 完成处理后在每个节点上调用 <code>done()</code>。</li>
</ul>
</blockquote>
<p>在只需要对图中的节点进行立即排序并且不涉及并行性的情况下，可以直接使用便捷方法 <code>TopologicalSorter.static_order()</code>:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> graph <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"D"</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token string">"B"</span><span class="token punctuation">,</span> <span class="token string">"C"</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">"C"</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token string">"A"</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">"B"</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token string">"A"</span><span class="token punctuation">}</span><span class="token punctuation">}</span>
<span class="token operator">>></span><span class="token operator">></span> ts <span class="token operator">=</span> TopologicalSorter<span class="token punctuation">(</span>graph<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> tuple<span class="token punctuation">(</span>ts<span class="token punctuation">.</span>static_order<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token string">'A'</span><span class="token punctuation">,</span> <span class="token string">'C'</span><span class="token punctuation">,</span> <span class="token string">'B'</span><span class="token punctuation">,</span> <span class="token string">'D'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>这个类被设计用来在节点就绪时方便地支持对其并行处理。 例如:</p>
<pre class="line-numbers language-python"><code class="language-python">topological_sorter <span class="token operator">=</span> TopologicalSorter<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment" spellcheck="true"># Add nodes to 'topological_sorter'...</span>
topological_sorter<span class="token punctuation">.</span>prepare<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">while</span> topological_sorter<span class="token punctuation">.</span>is_active<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">for</span> node <span class="token keyword">in</span> topological_sorter<span class="token punctuation">.</span>get_ready<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token comment" spellcheck="true"># Worker threads or processes take nodes to work on off the</span>
        <span class="token comment" spellcheck="true"># 'task_queue' queue.</span>
        task_queue<span class="token punctuation">.</span>put<span class="token punctuation">(</span>node<span class="token punctuation">)</span>
    <span class="token comment" spellcheck="true"># When the work for a node is done, workers put the node in</span>
    <span class="token comment" spellcheck="true"># 'finalized_tasks_queue' so we can get more nodes to work on.</span>
    <span class="token comment" spellcheck="true"># The definition of 'is_active()' guarantees that, at this point, at</span>
    <span class="token comment" spellcheck="true"># least one node has been placed on 'task_queue' that hasn't yet</span>
    <span class="token comment" spellcheck="true"># been passed to 'done()', so this blocking 'get()' must (eventually)</span>
    <span class="token comment" spellcheck="true"># succeed.  After calling 'done()', we loop back to call 'get_ready()'</span>
    <span class="token comment" spellcheck="true"># again, so put newly freed nodes on 'task_queue' as soon as</span>
    <span class="token comment" spellcheck="true"># logically possible.</span>
    node <span class="token operator">=</span> finalized_tasks_queue<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token punctuation">)</span>
    topological_sorter<span class="token punctuation">.</span>done<span class="token punctuation">(</span>node<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li><p><code>add</code>(<em>node</em>, <em>\</em>predecessors*)</p>
<p>将一个新节点及其上级节点添加到图中。 <em>node</em> 以及 <em>predecessors</em> 中的所有元素都必须为可哈希对象。</p>
<p>如果附带相同的节点参数多次调用，则依赖项的集合将为所有被传入依赖项的并集。</p>
<p>可以添加不带依赖项的节点 (即不提供 <em>predecessors</em>) 或者重复提供依赖项。 如果有先前未提供的节点包含在 <em>predecessors</em> 中则它将被自动添加到图中并且不带自己的上级节点。</p>
<p>如果在 <code>prepare()</code> 之后被调用则会引发 <code>ValueError</code>。</p>
</li>
<li><p><code>prepare</code>()</p>
<p>将图标记为已完成并检查图中是否存在环。 如何检测到任何环，则将引发 <code>CycleError</code>，但 <code>get_ready()</code> 仍可被用来获取尽可能多的节点直到环阻塞了操作过程。 在调用此函数后，图将无法再修改，因此不能再使用 <code>add()</code> 添加更多的节点。</p>
</li>
<li><p><code>is_active</code>()</p>
<p>如果可以取得更多进展则返回 <code>True</code>，否则返回 <code>False</code>。 如果环没有阻塞操作，并且还存在尚未被 <code>TopologicalSorter.get_ready()</code> 返回的已就绪节点或者已标记为 <code>TopologicalSorter.done()</code> 的节点数量少于已被 <code>TopologicalSorter.get_ready()</code> 所返回的节点数量则还可以取得进展。</p>
<p>该类的 <code>__bool__()</code> 方法要使用此函数，因此除了:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">if</span> ts<span class="token punctuation">.</span>is_active<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>可能会简单地执行:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">if</span> ts<span class="token punctuation">:</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>如果之前未调用 <code>prepare()</code> 就调用此函数则会引发 <code>ValueError</code>。</p>
</li>
<li><p><code>done</code>(<em>\</em>nodes*)</p>
<p>将 <code>TopologicalSorter.get_ready()</code> 所返回的节点集合标记为已处理，解除对 <em>nodes</em> 中每个节点的后续节点的阻塞以便在将来通过对 <code>TopologicalSorter.get_ready()</code> 的调用来返回它们。</p>
<p>如果 <em>nodes</em> 中的任何节点已经被之前对该方法的调用标记为已处理或者如果未通过使用 <code>TopologicalSorter.add()</code> 将一个节点添加到图中，如果未调用 <code>prepare()</code> 即调用此方法或者如果节点尚未被 <code>get_ready()</code> 所返回则将引发 <code>ValueError</code>。</p>
</li>
<li><p><code>get_ready</code>()</p>
<p>返回由所有已就绪节点组成的 <code>tuple</code>。 初始状态下它将返回所有不带上级节点的节点，并且一旦通过调用 <code>TopologicalSorter.done()</code> 将它们标记为已处理，之后的调用将返回所有上级节点已被处理的新节点。 一旦无法再取得进展，则会返回空元组。</p>
<p>如果之前未调用 <code>prepare()</code> 就调用此函数则会引发 <code>ValueError</code>。</p>
</li>
<li><p><code>static_order</code>()</p>
<p>返回一个迭代器，它将按照拓扑顺序来迭代所有节点。 当使用此方法时，<code>prepare()</code> 和 <code>done()</code> 不应被调用。 此方法等价于:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">static_order</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
    self<span class="token punctuation">.</span>prepare<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">while</span> self<span class="token punctuation">.</span>is_active<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        node_group <span class="token operator">=</span> self<span class="token punctuation">.</span>get_ready<span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">yield</span> <span class="token keyword">from</span> node_group
        self<span class="token punctuation">.</span>done<span class="token punctuation">(</span><span class="token operator">*</span>node_group<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>所返回的特定顺序可能取决于条目被插入图中的顺序。 例如:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> ts <span class="token operator">=</span> TopologicalSorter<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> ts<span class="token punctuation">.</span>add<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> ts<span class="token punctuation">.</span>add<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">*</span>ts<span class="token punctuation">.</span>static_order<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> ts2 <span class="token operator">=</span> TopologicalSorter<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> ts2<span class="token punctuation">.</span>add<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> ts2<span class="token punctuation">.</span>add<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">*</span>ts2<span class="token punctuation">.</span>static_order<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这是由于实际上 “0” 和 “2” 在图中的级别相同（它们将在对 <code>get_ready()</code> 的同一次调用中被返回） 并且它们之间的顺序是由插入顺序决定的。</p>
<p>如果检测到任何环，则将引发 <code>CycleError</code>。</p>
</li>
</ul>
<p>3.9 新版功能.</p>
<h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p><code>graphlib</code> 模块定义了以下异常类:</p>
<p><em>exception</em> <code>graphlib.CycleError</code></p>
<p><code>ValueError</code> 的子类，当特定的图中存在环时将由 <code>TopologicalSorter.prepare()</code> 引发。 如果存在多个环，则将只报告其中一个未定义的选项并将其包括在异常中。</p>
<p>检测到的环可以通过异常实例的 <code>args</code> 属性的第二个元素来访问，它由一个节点列表组成，其中的每个节点在图中都是列表中下一个节点的直接上级节点。 在报告的列表中，开头和末尾的节点将是同一对象，以表明它是一个环。</p>
<h1 id="数字和数学模块"><a href="#数字和数学模块" class="headerlink" title="数字和数学模块"></a>数字和数学模块</h1><p>本章介绍的模块提供与数字和数学相关的函数和数据类型。 <code>numbers</code> 模块定义了数字类型的抽象层次结构。 <code>math</code> 和 <code>cmath</code> 模块包含浮点数和复数的各种数学函数。 <code>decimal</code> 模块支持使用任意精度算术的十进制数的精确表示。</p>
<p>本章包含以下模块的文档：</p>
<ul>
<li><code>numbers</code> —- 数字的抽象基类<ul>
<li>数字的层次</li>
<li>类型接口注释。<ul>
<li>加入更多数字的ABC</li>
<li>实现算术运算</li>
</ul>
</li>
</ul>
</li>
<li><code>math</code> —- 数学函数<ul>
<li>数论与表示函数</li>
<li>幂函数与对数函数</li>
<li>三角函数</li>
<li>角度转换</li>
<li>双曲函数</li>
<li>特殊函数</li>
<li>常量</li>
</ul>
</li>
<li><code>cmath</code> —- 关于复数的数学函数<ul>
<li>到极坐标和从极坐标的转换</li>
<li>幂函数与对数函数</li>
<li>三角函数</li>
<li>双曲函数</li>
<li>分类函数</li>
<li>常量</li>
</ul>
</li>
<li><code>decimal</code> —- 十进制定点和浮点运算<ul>
<li>快速入门教程</li>
<li>Decimal 对象<ul>
<li>逻辑操作数</li>
</ul>
</li>
<li>上下文对象</li>
<li>常量</li>
<li>舍入模式</li>
<li>信号</li>
<li>浮点数说明<ul>
<li>通过提升精度来解决舍入错误</li>
<li>特殊的值</li>
</ul>
</li>
<li>使用线程</li>
<li>例程</li>
<li>Decimal 常见问题</li>
</ul>
</li>
<li><code>fractions</code> —- 分数</li>
<li><code>random</code> —- 生成伪随机数<ul>
<li>簿记功能</li>
<li>用于字节数据的函数</li>
<li>整数用函数</li>
<li>序列用函数</li>
<li>实值分布</li>
<li>替代生成器</li>
<li>关于再现性的说明</li>
<li>例子</li>
<li>例程</li>
</ul>
</li>
<li><code>statistics</code> —- 数学统计函数<ul>
<li>平均值以及对中心位置的评估</li>
<li>对分散程度的评估</li>
<li>对两个输入之间关系的统计</li>
<li>函数细节</li>
<li>异常</li>
<li><code>NormalDist</code> 对象<ul>
<li><code>NormalDist</code> 示例和用法</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="numbers-—-数字的抽象基类"><a href="#numbers-—-数字的抽象基类" class="headerlink" title="numbers —- 数字的抽象基类"></a><code>numbers</code> —- 数字的抽象基类</h2><p><strong>源代码：</strong> <a href="https://github.com/python/cpython/tree/3.10/Lib/numbers.py" target="_blank" rel="noopener">Lib/numbers.py</a></p>
<hr>
<p><code>numbers</code> 模块 (<a href="https://www.python.org/dev/peps/pep-3141" target="_blank" rel="noopener"><strong>PEP 3141</strong></a>) 定义了数字 抽象基类 的层级结构，其中逐级定义了更多操作。 此模块中定义的类型都不可被实例化。</p>
<p><em>class</em> <code>numbers.Number</code></p>
<p>数字的层次结构的基础。 如果你只想确认参数 <em>x</em> 是不是数字而不关心其类型，则使用 <code>isinstance(x, Number)</code>。</p>
<h3 id="数字的层次"><a href="#数字的层次" class="headerlink" title="数字的层次"></a>数字的层次</h3><p><em>class</em> <code>numbers.Complex</code></p>
<p>这个类型的子类描述了复数并包括了适用于内置 <code>complex</code> 类型的操作。 这些操作有: 转换为 <code>complex</code> 和 <code>bool</code>, <code>real</code>, <code>imag</code>, <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>**</code>, <code>abs()</code>, <code>conjugate()</code>, <code>==</code> 以及 <code>!=</code>。 除 <code>-</code> 和 <code>!=</code> 之外所有操作都是抽象的。</p>
<ul>
<li><p><code>real</code></p>
<p>抽象的。得到该数字的实数部分。</p>
</li>
<li><p><code>imag</code></p>
<p>抽象的。得到该数字的虚数部分。</p>
</li>
<li><p><em>abstractmethod</em> <code>conjugate</code>()</p>
<p>抽象的。返回共轭复数。例如 <code>(1+3j).conjugate() == (1-3j)</code>。</p>
</li>
</ul>
<p><em>class</em> <code>numbers.Real</code></p>
<p>相对于 <code>Complex</code>，<code>Real</code> 加入了只有实数才能进行的操作。</p>
<p>简单的说，它们是：转化至 <code>float</code>，<code>math.trunc()</code>、 <code>round()</code>、 <code>math.floor()</code>、 <code>math.ceil()</code>、 <code>divmod()</code>、 <code>//</code>、 <code>%</code>、 <code>&lt;</code>、 <code>&lt;=</code>、 <code>&gt;</code>、 和 <code>&gt;=</code>。</p>
<p>实数同样默认支持 <code>complex()</code>、 <code>real</code>、 <code>imag</code> 和 <code>conjugate()</code>。</p>
<p><em>class</em> <code>numbers.Rational</code></p>
<p>子类型 <code>Real</code> 并加入 <code>numerator</code> 和 <code>denominator</code> 两种属性，这两种属性应该属于最低的级别。加入后，这默认支持 <code>float()</code>。</p>
<ul>
<li><p><code>numerator</code></p>
<p>抽象的。</p>
</li>
<li><p><code>denominator</code></p>
<p>抽象的。</p>
</li>
</ul>
<p><em>class</em> <code>numbers.Integral</code></p>
<p>子类型 <code>Rational</code> 还增加了到 <code>int</code> 的转换操作。 为 <code>float()</code>, <code>numerator</code> 和 <code>denominator</code> 提供了默认支持。 为 <code>pow()</code> 方法增加了求余和按位字符串运算的抽象方法: <code>&lt;&lt;</code>, <code>&gt;&gt;</code>, <code>&amp;</code>, <code>^</code>, <code>|</code>, <code>~</code>。</p>
<h3 id="类型接口注释。"><a href="#类型接口注释。" class="headerlink" title="类型接口注释。"></a>类型接口注释。</h3><p>实现者需要注意使相等的数字相等并拥有同样的值。当这两个数使用不同的扩展模块时，这其中的差异是很微妙的。例如，用 <code>fractions.Fraction</code> 实现 <code>hash()</code> 如下:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">__hash__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> self<span class="token punctuation">.</span>denominator <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>
        <span class="token comment" spellcheck="true"># Get integers right.</span>
        <span class="token keyword">return</span> hash<span class="token punctuation">(</span>self<span class="token punctuation">.</span>numerator<span class="token punctuation">)</span>
    <span class="token comment" spellcheck="true"># Expensive check, but definitely correct.</span>
    <span class="token keyword">if</span> self <span class="token operator">==</span> float<span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> hash<span class="token punctuation">(</span>float<span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">else</span><span class="token punctuation">:</span>
        <span class="token comment" spellcheck="true"># Use tuple's hash to avoid a high collision rate on</span>
        <span class="token comment" spellcheck="true"># simple fractions.</span>
        <span class="token keyword">return</span> hash<span class="token punctuation">(</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>numerator<span class="token punctuation">,</span> self<span class="token punctuation">.</span>denominator<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="加入更多数字的ABC"><a href="#加入更多数字的ABC" class="headerlink" title="加入更多数字的ABC"></a>加入更多数字的ABC</h4><p>当然，这里有更多支持数字的ABC，如果不加入这些，就将缺少层次感。你可以用如下方法在 <code>Complex</code> 和 <code>Real</code> 中加入 <code>MyFoo</code>:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">MyFoo</span><span class="token punctuation">(</span>Complex<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
MyFoo<span class="token punctuation">.</span>register<span class="token punctuation">(</span>Real<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h4 id="实现算术运算"><a href="#实现算术运算" class="headerlink" title="实现算术运算"></a>实现算术运算</h4><p>我们希望实现计算，因此，混合模式操作要么调用一个作者知道参数类型的实现，要么转变成为最接近的内置类型并对这个执行操作。对于子类 <code>Integral</code>，这意味着 <code>__add__()</code> 和 <code>__radd__()</code> 必须用如下方式定义：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">MyIntegral</span><span class="token punctuation">(</span>Integral<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__add__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> other<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> isinstance<span class="token punctuation">(</span>other<span class="token punctuation">,</span> MyIntegral<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> do_my_adding_stuff<span class="token punctuation">(</span>self<span class="token punctuation">,</span> other<span class="token punctuation">)</span>
        <span class="token keyword">elif</span> isinstance<span class="token punctuation">(</span>other<span class="token punctuation">,</span> OtherTypeIKnowAbout<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> do_my_other_adding_stuff<span class="token punctuation">(</span>self<span class="token punctuation">,</span> other<span class="token punctuation">)</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> NotImplemented
    <span class="token keyword">def</span> <span class="token function">__radd__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> other<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> isinstance<span class="token punctuation">(</span>other<span class="token punctuation">,</span> MyIntegral<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> do_my_adding_stuff<span class="token punctuation">(</span>other<span class="token punctuation">,</span> self<span class="token punctuation">)</span>
        <span class="token keyword">elif</span> isinstance<span class="token punctuation">(</span>other<span class="token punctuation">,</span> OtherTypeIKnowAbout<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> do_my_other_adding_stuff<span class="token punctuation">(</span>other<span class="token punctuation">,</span> self<span class="token punctuation">)</span>
        <span class="token keyword">elif</span> isinstance<span class="token punctuation">(</span>other<span class="token punctuation">,</span> Integral<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> int<span class="token punctuation">(</span>other<span class="token punctuation">)</span> <span class="token operator">+</span> int<span class="token punctuation">(</span>self<span class="token punctuation">)</span>
        <span class="token keyword">elif</span> isinstance<span class="token punctuation">(</span>other<span class="token punctuation">,</span> Real<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> float<span class="token punctuation">(</span>other<span class="token punctuation">)</span> <span class="token operator">+</span> float<span class="token punctuation">(</span>self<span class="token punctuation">)</span>
        <span class="token keyword">elif</span> isinstance<span class="token punctuation">(</span>other<span class="token punctuation">,</span> Complex<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> complex<span class="token punctuation">(</span>other<span class="token punctuation">)</span> <span class="token operator">+</span> complex<span class="token punctuation">(</span>self<span class="token punctuation">)</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> NotImplemented<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>Complex</code> 有 5 种不同的混合类型的操作。 我将上面提到的所有代码作为“模板”称作 <code>MyIntegral</code> 和 <code>OtherTypeIKnowAbout</code>。 <code>a</code> 是 <code>Complex</code> 的子类型 <code>A</code> 的实例 (<code>a : A &lt;: Complex</code>)，同时 <code>b : B &lt;: Complex</code>。 我将要计算 <code>a + b</code>:</p>
<blockquote>
<ol>
<li>如果 <code>A</code> 被定义成一个承认 <code>b</code> 的 <code>__add__()</code>，一切都没有问题。</li>
<li>如果 <code>A</code> 转回成“模板”失败，它将返回一个属于 <code>__add__()</code> 的值，我们需要避免 <code>B</code> 定义了一个更加智能的 <code>__radd__()</code>，因此模板需要返回一个属于 <code>__add__()</code> 的 <code>NotImplemented</code> 。（或者 <code>A</code> 可能完全不实现 <code>__add__()</code> 。）</li>
<li>接着看 <code>B</code> 的 <code>__radd__()</code> 。如果它承认 <code>a</code> ，一切都没有问题。</li>
<li>如果没有成功回退到模板，就没有更多的方法可以去尝试，因此这里将使用默认的实现。</li>
<li>如果 <code>B &lt;: A</code> ， Python 在 <code>A.__add__</code> 之前尝试 <code>B.__radd__</code> 。 这是可行的，是通过对 <code>A</code> 的认识实现的，因此这可以在交给 <code>Complex</code> 处理之前处理这些实例。</li>
</ol>
</blockquote>
<p>如果 <code>A &lt;: Complex</code> 和 <code>B &lt;: Real</code> 没有共享任何资源，那么适当的共享操作涉及内置的 <code>complex</code> ，并且分别获得 <code>__radd__()</code> ，因此 <code>a+b == b+a</code>。</p>
<p>由于对任何一直类型的大部分操作是十分相似的，可以定义一个帮助函数，即一个生成后续或相反的实例的生成器。例如，使用 <code>fractions.Fraction</code> 如下：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">_operator_fallbacks</span><span class="token punctuation">(</span>monomorphic_operator<span class="token punctuation">,</span> fallback_operator<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">forward</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> isinstance<span class="token punctuation">(</span>b<span class="token punctuation">,</span> <span class="token punctuation">(</span>int<span class="token punctuation">,</span> Fraction<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> monomorphic_operator<span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span>
        <span class="token keyword">elif</span> isinstance<span class="token punctuation">(</span>b<span class="token punctuation">,</span> float<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> fallback_operator<span class="token punctuation">(</span>float<span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">,</span> b<span class="token punctuation">)</span>
        <span class="token keyword">elif</span> isinstance<span class="token punctuation">(</span>b<span class="token punctuation">,</span> complex<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> fallback_operator<span class="token punctuation">(</span>complex<span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">,</span> b<span class="token punctuation">)</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> NotImplemented
    forward<span class="token punctuation">.</span>__name__ <span class="token operator">=</span> <span class="token string">'__'</span> <span class="token operator">+</span> fallback_operator<span class="token punctuation">.</span>__name__ <span class="token operator">+</span> <span class="token string">'__'</span>
    forward<span class="token punctuation">.</span>__doc__ <span class="token operator">=</span> monomorphic_operator<span class="token punctuation">.</span>__doc__
    <span class="token keyword">def</span> <span class="token function">reverse</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> isinstance<span class="token punctuation">(</span>a<span class="token punctuation">,</span> Rational<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token comment" spellcheck="true"># Includes ints.</span>
            <span class="token keyword">return</span> monomorphic_operator<span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span>
        <span class="token keyword">elif</span> isinstance<span class="token punctuation">(</span>a<span class="token punctuation">,</span> numbers<span class="token punctuation">.</span>Real<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> fallback_operator<span class="token punctuation">(</span>float<span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">,</span> float<span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">elif</span> isinstance<span class="token punctuation">(</span>a<span class="token punctuation">,</span> numbers<span class="token punctuation">.</span>Complex<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> fallback_operator<span class="token punctuation">(</span>complex<span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">,</span> complex<span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> NotImplemented
    reverse<span class="token punctuation">.</span>__name__ <span class="token operator">=</span> <span class="token string">'__r'</span> <span class="token operator">+</span> fallback_operator<span class="token punctuation">.</span>__name__ <span class="token operator">+</span> <span class="token string">'__'</span>
    reverse<span class="token punctuation">.</span>__doc__ <span class="token operator">=</span> monomorphic_operator<span class="token punctuation">.</span>__doc__
    <span class="token keyword">return</span> forward<span class="token punctuation">,</span> reverse
<span class="token keyword">def</span> <span class="token function">_add</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">"""a + b"""</span>
    <span class="token keyword">return</span> Fraction<span class="token punctuation">(</span>a<span class="token punctuation">.</span>numerator <span class="token operator">*</span> b<span class="token punctuation">.</span>denominator <span class="token operator">+</span>
                    b<span class="token punctuation">.</span>numerator <span class="token operator">*</span> a<span class="token punctuation">.</span>denominator<span class="token punctuation">,</span>
                    a<span class="token punctuation">.</span>denominator <span class="token operator">*</span> b<span class="token punctuation">.</span>denominator<span class="token punctuation">)</span>
__add__<span class="token punctuation">,</span> __radd__ <span class="token operator">=</span> _operator_fallbacks<span class="token punctuation">(</span>_add<span class="token punctuation">,</span> operator<span class="token punctuation">.</span>add<span class="token punctuation">)</span>
<span class="token comment" spellcheck="true"># ...</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="math-—-数学函数"><a href="#math-—-数学函数" class="headerlink" title="math —- 数学函数"></a><code>math</code> —- 数学函数</h2><p>该模块提供了对C标准定义的数学函数的访问。</p>
<p>这些函数不适用于复数；如果你需要计算复数，请使用 <code>cmath</code> 模块中的同名函数。将支持计算复数的函数区分开的目的，来自于大多数开发者并不愿意像数学家一样需要学习复数的概念。得到一个异常而不是一个复数结果使得开发者能够更早地监测到传递给这些函数的参数中包含复数，进而调查其产生的原因。</p>
<p>该模块提供了以下函数。除非另有明确说明，否则所有返回值均为浮点数。</p>
<h3 id="数论与表示函数"><a href="#数论与表示函数" class="headerlink" title="数论与表示函数"></a>数论与表示函数</h3><p><code>math.ceil</code>(<em>x</em>)</p>
<p>返回 <em>x</em> 的上限，即大于或者等于 <em>x</em> 的最小整数。如果 <em>x</em> 不是一个浮点数，则委托 <code>x.__ceil__()</code>, 返回一个 <code>Integral</code> 类的值。</p>
<p><code>math.comb</code>(<em>n</em>, <em>k</em>)</p>
<p>返回不重复且无顺序地从 <em>n</em> 项中选择 <em>k</em> 项的方式总数。</p>
<p>当 <code>k &lt;= n</code> 时取值为 <code>n! / (k! * (n - k)!)</code>；当 <code>k &gt; n</code> 时取值为零。</p>
<p>也称为二项式系数，因为它等价于表达式 <code>(1 + x) ** n</code> 的多项式展开中第 k 项的系数。</p>
<p>如果任一参数不为整数则会引发 <code>TypeError</code>。 如果任一参数为负数则会引发 <code>ValueError</code>。</p>
<p>3.8 新版功能.</p>
<p><code>math.copysign</code>(<em>x</em>, <em>y</em>)</p>
<p>返回一个基于 <em>x</em> 的绝对值和 <em>y</em> 的符号的浮点数。在支持带符号零的平台上，<code>copysign(1.0, -0.0)</code> 返回 <em>-1.0</em>.</p>
<p><code>math.fabs</code>(<em>x</em>)</p>
<p>返回 <em>x</em> 的绝对值。</p>
<p><code>math.factorial</code>(<em>x</em>)</p>
<p>以一个整数返回 <em>x</em> 的阶乘。 如果 <em>x</em> 不是整数或为负数时则将引发 <code>ValueError</code>。</p>
<p>3.9 版后已移除: 接受具有整数值的浮点数 (例如 <code>5.0</code>) 的行为已被弃用。</p>
<p><code>math.floor</code>(<em>x</em>)</p>
<p>返回 <em>x</em> 的向下取整，小于或等于 <em>x</em> 的最大整数。如果 <em>x</em> 不是浮点数，则委托 <code>x.__floor__()</code> ，它应返回 <code>Integral</code> 值。</p>
<p><code>math.fmod</code>(<em>x</em>, <em>y</em>)</p>
<p>返回 <code>fmod(x, y)</code> ，由平台C库定义。请注意，Python表达式 <code>x % y</code> 可能不会返回相同的结果。C标准的目的是 <code>fmod(x, y)</code> 完全（数学上；到无限精度）等于 <code>x - n*y</code> 对于某个整数 <em>n</em> ，使得结果具有 与 <em>x</em> 相同的符号和小于 <code>abs(y)</code> 的幅度。Python的 <code>x % y</code> 返回带有 <em>y</em> 符号的结果，并且可能不能完全计算浮点参数。 例如， <code>fmod(-1e-100, 1e100)</code> 是 <code>-1e-100</code> ，但Python的 <code>-1e-100 % 1e100</code> 的结果是 <code>1e100-1e-100</code> ，它不能完全表示为浮点数，并且取整为令人惊讶的 <code>1e100</code> 。 出于这个原因，函数 <code>fmod()</code> 在使用浮点数时通常是首选，而Python的 <code>x % y</code> 在使用整数时是首选。</p>
<p><code>math.frexp</code>(<em>x</em>)</p>
<p>以 <code>(m, e)</code> 对的形式返回 <em>x</em> 的尾数和指数。 <em>m</em> 是一个浮点数， <em>e</em> 是一个整数，正好是 <code>x == m * 2**e</code> 。 如果 <em>x</em> 为零，则返回 <code>(0.0, 0)</code> ，否则返回 <code>0.5 &lt;= abs(m) &lt; 1</code> 。这用于以可移植方式“分离”浮点数的内部表示。</p>
<p><code>math.fsum</code>(<em>iterable</em>)</p>
<p>返回迭代中的精确浮点值。通过跟踪多个中间部分和来避免精度损失:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> sum<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token number">0.9999999999999999</span>
<span class="token operator">>></span><span class="token operator">></span> fsum<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token number">1.0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>该算法的准确性取决于IEEE-754算术保证和舍入模式为半偶的典型情况。在某些非Windows版本中，底层C库使用扩展精度添加，并且有时可能会使中间和加倍，导致它在最低有效位中关闭。</p>
<p><code>math.gcd</code>(<em>\</em>integers*)</p>
<p>返回给定的整数参数的最大公约数。 如果有一个参数非零，则返回值将是能同时整除所有参数的最大正整数。 如果所有参数为零，则返回值为 <code>0</code>。 不带参数的 <code>gcd()</code> 返回 <code>0</code>。</p>
<p>3.5 新版功能.</p>
<p>在 3.9 版更改: 添加了对任意数量的参数的支持。 之前的版本只支持两个参数。</p>
<p><code>math.isclose</code>(<em>a</em>, <em>b</em>, <em>**,</em> rel_tol=1e-09<em>,</em> abs_tol=0.0*)</p>
<p>若 <em>a</em> 和 <em>b</em> 的值比较接近则返回 <code>True</code>，否则返回 <code>False</code>。</p>
<p>根据给定的绝对和相对容差确定两个值是否被认为是接近的。</p>
<p><em>rel_tol</em> 是相对容差 —— 它是 <em>a</em> 和 <em>b</em> 之间允许的最大差值，相对于 <em>a</em> 或 <em>b</em> 的较大绝对值。例如，要设置5％的容差，请传递 <code>rel_tol=0.05</code> 。默认容差为 <code>1e-09</code>，确保两个值在大约9位十进制数字内相同。 <em>rel_tol</em> 必须大于零。</p>
<p><em>abs_tol</em> 是最小绝对容差 —— 对于接近零的比较很有用。 <em>abs_tol</em> 必须至少为零。</p>
<p>如果没有错误发生，结果将是： <code>abs(a-b) &lt;= max(rel_tol * max(abs(a), abs(b)), abs_tol)</code> 。</p>
<p>IEEE 754特殊值 <code>NaN</code> ， <code>inf</code> 和 <code>-inf</code> 将根据IEEE规则处理。具体来说， <code>NaN</code> 不被认为接近任何其他值，包括 <code>NaN</code> 。 <code>inf</code> 和 <code>-inf</code> 只被认为接近自己。</p>
<p>3.5 新版功能.</p>
<p>参见</p>
<p><a href="https://www.python.org/dev/peps/pep-0485" target="_blank" rel="noopener"><strong>PEP 485</strong></a> —— 用于测试近似相等的函数</p>
<p><code>math.isfinite</code>(<em>x</em>)</p>
<p>如果 <em>x</em> 既不是无穷大也不是NaN，则返回 <code>True</code> ，否则返回 <code>False</code> 。 （注意 <code>0.0</code> 被认为 <em>是</em> 有限的。）</p>
<p>3.2 新版功能.</p>
<p><code>math.isinf</code>(<em>x</em>)</p>
<p>如果 <em>x</em> 是正或负无穷大，则返回 <code>True</code> ，否则返回 <code>False</code> 。</p>
<p><code>math.isnan</code>(<em>x</em>)</p>
<p>如果 <em>x</em> 是 NaN（不是数字），则返回 <code>True</code> ，否则返回 <code>False</code> 。</p>
<p><code>math.isqrt</code>(<em>n</em>)</p>
<p>返回非负整数 <em>n</em> 的整数平方根。 这就是对 <em>n</em> 的实际平方根向下取整，或者相当于使得 <em>a</em>² ≤ <em>n</em> 的最大整数 <em>a</em>。</p>
<p>对于某些应用来说，可以更适合取值为使得 <em>n</em> ≤ <em>a</em>² 的最小整数 <em>a</em> ，或者换句话说就是 <em>n</em> 的实际平方根向上取整。 对于正数 <em>n</em>，这可以使用 <code>a = 1 + isqrt(n - 1)</code> 来计算。</p>
<p>3.8 新版功能.</p>
<p><code>math.lcm</code>(<em>\</em>integers*)</p>
<p>返回给定的整数参数的最小公倍数。 如果所有参数均非零，则返回值将是为所有参数的整数倍的最小正整数。 如果参数之一为零，则返回值为 <code>0</code>。 不带参数的 <code>lcm()</code> 返回 <code>1</code>。</p>
<p>3.9 新版功能.</p>
<p><code>math.ldexp</code>(<em>x</em>, <em>i</em>)</p>
<p>返回 <code>x * (2**i)</code> 。 这基本上是函数 <code>frexp()</code> 的反函数。</p>
<p><code>math.modf</code>(<em>x</em>)</p>
<p>返回 <em>x</em> 的小数和整数部分。两个结果都带有 <em>x</em> 的符号并且是浮点数。</p>
<p><code>math.nextafter</code>(<em>x</em>, <em>y</em>)</p>
<p>返回 <em>x</em> 趋向于 <em>y</em> 的最接近的浮点数值。</p>
<p>如果 <em>x</em> 等于 <em>y</em> 则返回 <em>y</em>。</p>
<p>示例：</p>
<ul>
<li><code>math.nextafter(x, math.inf)</code> 的方向朝上：趋向于正无穷。</li>
<li><code>math.nextafter(x, -math.inf)</code> 的方向朝下：趋向于负无穷。</li>
<li><code>math.nextafter(x, 0.0)</code> 趋向于零。</li>
<li><code>math.nextafter(x, math.copysign(math.inf, x))</code> 趋向于零的反方向。</li>
</ul>
<p>3.9 新版功能.</p>
<p><code>math.perm</code>(<em>n</em>, <em>k=None</em>)</p>
<p>返回不重复且有顺序地从 <em>n</em> 项中选择 <em>k</em> 项的方式总数。</p>
<p>当 <code>k &lt;= n</code> 时取值为 <code>n! / (n - k)!</code>；当 <code>k &gt; n</code> 时取值为零。</p>
<p>如果 <em>k</em> 未指定或为 None，则 <em>k</em> 默认值为 <em>n</em> 并且函数将返回 <code>n!</code>。</p>
<p>如果任一参数不为整数则会引发 <code>TypeError</code>。 如果任一参数为负数则会引发 <code>ValueError</code>。</p>
<p>3.8 新版功能.</p>
<p><code>math.prod</code>(<em>iterable</em>, <em>**,</em> start=1*)</p>
<p>计算输入的 <em>iterable</em> 中所有元素的积。 积的默认 <em>start</em> 值为 <code>1</code>。</p>
<p>当可迭代对象为空时，返回起始值。 此函数特别针对数字值使用，并会拒绝非数字类型。</p>
<p>3.8 新版功能.</p>
<p><code>math.remainder</code>(<em>x</em>, <em>y</em>)</p>
<p>返回 IEEE 754 风格的 <em>x</em> 相对于 <em>y</em> 的余数。对于有限 <em>x</em> 和有限非零 <em>y</em> ，这是差异 <code>x - n*y</code> ，其中 <code>n</code> 是与商 <code>x / y</code> 的精确值最接近的整数。如果 <code>x / y</code> 恰好位于两个连续整数之间，则将最接近的 <em>偶数</em> 用作 <code>n</code> 。 余数 <code>r = remainder(x, y)</code> 因此总是满足 <code>abs(r) &lt;= 0.5 * abs(y)</code>。</p>
<p>特殊情况遵循IEEE 754：特别是 <code>remainder(x, math.inf)</code> 对于任何有限 <em>x</em> 都是 <em>x</em> ，而 <code>remainder(x, 0)</code> 和 <code>remainder(math.inf, x)</code> 引发 <code>ValueError</code> 适用于任何非NaN的 <em>x</em> 。如果余数运算的结果为零，则该零将具有与 <em>x</em> 相同的符号。</p>
<p>在使用IEEE 754二进制浮点的平台上，此操作的结果始终可以完全表示：不会引入舍入错误。</p>
<p>3.7 新版功能.</p>
<p><code>math.trunc</code>(<em>x</em>)</p>
<p>返回 <code>Real</code> 值 <em>x</em> 截断为 <code>Integral</code> （通常是整数）。 委托给 <code>x.__trunc__()</code>。</p>
<p><code>math.ulp</code>(<em>x</em>)</p>
<p>返回浮点数 <em>x</em> 的最小有效比特位的值:</p>
<ul>
<li>如果 <em>x</em> 是 NaN (非数字)，则返回 <em>x</em>。</li>
<li>如果 <em>x</em> 为负数，则返回 <code>ulp(-x)</code>。</li>
<li>如果 <em>x</em> 为正数，则返回 <em>x</em>。</li>
<li>如果 <em>x</em> 等于零，则返回 <em>去正规化的</em> 可表示最小正浮点数 (小于 <em>正规化的</em> 最小正浮点数 <code>sys.float_info.min</code>)。</li>
<li>如果 <em>x</em> 等于可表示最大正浮点数，则返回 <em>x</em> 的最低有效比特位的值，使得小于 <em>x</em> 的第一个浮点数为 <code>x - ulp(x)</code>。</li>
<li>在其他情况下 (<em>x</em> 是一个有限的正数)，则返回 <em>x</em> 的最低有效比特位的值，使得大于 <em>x</em> 的第一个浮点数为 <code>x + ulp(x)</code>。</li>
</ul>
<p>ULP 即 “Unit in the Last Place” 的缩写。</p>
<p>3.9 新版功能.</p>
<p>注意 <code>frexp()</code> 和 <code>modf()</code> 具有与它们的C等价函数不同的调用/返回模式：它们采用单个参数并返回一对值，而不是通过 ‘输出形参’ 返回它们的第二个返回参数（Python中没有这样的东西）。</p>
<p>对于 <code>ceil()</code> ， <code>floor()</code> 和 <code>modf()</code> 函数，请注意 <em>所有</em> 足够大的浮点数都是精确整数。Python浮点数通常不超过53位的精度（与平台C double类型相同），在这种情况下，任何浮点 <em>x</em> 与 <code>abs(x) &gt;= 2**52</code> 必然没有小数位。</p>
<h3 id="幂函数与对数函数"><a href="#幂函数与对数函数" class="headerlink" title="幂函数与对数函数"></a>幂函数与对数函数</h3><p><code>math.exp</code>(<em>x</em>)</p>
<p>返回 <em>e</em> 次 <em>x</em> 幂，其中 <em>e</em> = 2.718281… 是自然对数的基数。这通常比 <code>math.e ** x</code> 或 <code>pow(math.e, x)</code> 更精确。</p>
<p><code>math.expm1</code>(<em>x</em>)</p>
<p>返回 <em>e</em> 的 <em>x</em> 次幂，减1。这里 <em>e</em> 是自然对数的基数。对于小浮点数 <em>x</em> ， <code>exp(x) - 1</code> 中的减法可能导致 significant loss of precision； <code>expm1()</code> 函数提供了一种将此数量计算为全精度的方法:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> math <span class="token keyword">import</span> exp<span class="token punctuation">,</span> expm1
<span class="token operator">>></span><span class="token operator">></span> exp<span class="token punctuation">(</span><span class="token number">1e</span><span class="token operator">-</span><span class="token number">5</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span>  <span class="token comment" spellcheck="true"># gives result accurate to 11 places</span>
<span class="token number">1.0000050000069649e-05</span>
<span class="token operator">>></span><span class="token operator">></span> expm1<span class="token punctuation">(</span><span class="token number">1e</span><span class="token operator">-</span><span class="token number">5</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># result accurate to full precision</span>
<span class="token number">1.0000050000166668e-05</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>3.2 新版功能.</p>
<p><code>math.log</code>(<em>x</em>[, <em>base</em>])</p>
<p>使用一个参数，返回 <em>x</em> 的自然对数（底为 <em>e</em> ）。</p>
<p>使用两个参数，返回给定的 <em>base</em> 的对数 <em>x</em> ，计算为 <code>log(x)/log(base)</code> 。</p>
<p><code>math.log1p</code>(<em>x</em>)</p>
<p>返回 <em>1+x</em> 的自然对数（以 <em>e</em> 为底）。 以对于接近零的 <em>x</em> 精确的方式计算结果。</p>
<p><code>math.log2</code>(<em>x</em>)</p>
<p>返回 <em>x</em> 以2为底的对数。这通常比 <code>log(x, 2)</code> 更准确。</p>
<p>3.3 新版功能.</p>
<p>参见</p>
<p><code>int.bit_length()</code> 返回表示二进制整数所需的位数，不包括符号和前导零。</p>
<p><code>math.log10</code>(<em>x</em>)</p>
<p>返回 <em>x</em> 底为10的对数。这通常比 <code>log(x, 10)</code> 更准确。</p>
<p><code>math.pow</code>(<em>x</em>, <em>y</em>)</p>
<p>将返回 <code>x</code> 的 <code>y</code> 次幂。特殊情况尽可能遵循C99标准的附录’F’。特别是， <code>pow(1.0, x)</code> 和 <code>pow(x, 0.0)</code> 总是返回 <code>1.0</code> ，即使 <code>x</code> 是零或NaN。 如果 <code>x</code> 和 <code>y</code> 都是有限的， <code>x</code> 是负数， <code>y</code> 不是整数那么 <code>pow(x, y)</code> 是未定义的，并且引发 <code>ValueError</code> 。</p>
<p>与内置的 <code>**</code> 运算符不同， <code>math.pow()</code> 将其参数转换为 <code>float</code> 类型。使用 <code>**</code> 或内置的 <code>pow()</code> 函数来计算精确的整数幂。</p>
<p><code>math.sqrt</code>(<em>x</em>)</p>
<p>返回 <em>x</em> 的平方根。</p>
<h3 id="三角函数"><a href="#三角函数" class="headerlink" title="三角函数"></a>三角函数</h3><p><code>math.acos</code>(<em>x</em>)</p>
<p>返回以弧度为单位的 <em>x</em> 的反余弦值。 结果范围在 <code>0</code> 到 <code>pi</code> 之间。</p>
<p><code>math.asin</code>(<em>x</em>)</p>
<p>返回以弧度为单位的 <em>x</em> 的反正弦值。 结果范围在 <code>-pi/2</code> 到 <code>pi/2</code> 之间。</p>
<p><code>math.atan</code>(<em>x</em>)</p>
<p>返回以弧度为单位的 <em>x</em> 的反正切值。 结果范围在 <code>-pi/2</code> 到 <code>pi/2</code> 之间。.</p>
<p><code>math.atan2</code>(<em>y</em>, <em>x</em>)</p>
<p>以弧度为单位返回 <code>atan(y / x)</code> 。结果是在 <code>-pi</code> 和 <code>pi</code> 之间。从原点到点 <code>(x, y)</code> 的平面矢量使该角度与正X轴成正比。 <code>atan2()</code> 的点的两个输入的符号都是已知的，因此它可以计算角度的正确象限。 例如， <code>atan(1)</code> 和 <code>atan2(1, 1)</code> 都是 <code>pi/4</code> ，但 <code>atan2(-1, -1)</code> 是 <code>-3*pi/4</code> 。</p>
<p><code>math.cos</code>(<em>x</em>)</p>
<p>返回 <em>x</em> 弧度的余弦值。</p>
<p><code>math.dist</code>(<em>p</em>, <em>q</em>)</p>
<p>返回 <em>p</em> 与 <em>q</em> 两点之间的欧几里得距离，以一个坐标序列（或可迭代对象）的形式给出。 两个点必须具有相同的维度。</p>
<p>大致相当于：</p>
<pre><code>sqrt(sum((px - qx) ** 2.0 for px, qx in zip(p, q)))</code></pre><p>3.8 新版功能.</p>
<p><code>math.hypot</code>(<em>\</em>coordinates*)</p>
<p>返回欧几里得范数，<code>sqrt(sum(x**2 for x in coordinates))</code>。 这是从原点到坐标给定点的向量长度。</p>
<p>对于一个二维点 <code>(x, y)</code>，这等价于使用毕达哥拉斯定义 <code>sqrt(x*x + y*y)</code> 计算一个直角三角形的斜边。</p>
<p>在 3.8 版更改: 添加了对 n 维点的支持。 之前的版本只支持二维点。</p>
<p>在 3.10 版更改: 改进了算法的精确性，使得最大误差在 1 ulp (最后一位的单位数值) 以下。 更为常见的情况是，结果几乎总是能正确地舍入到 1/2 ulp 范围之内。</p>
<p><code>math.sin</code>(<em>x</em>)</p>
<p>返回 <em>x</em> 弧度的正弦值。</p>
<p><code>math.tan</code>(<em>x</em>)</p>
<p>返回 <em>x</em> 弧度的正切值。</p>
<h3 id="角度转换"><a href="#角度转换" class="headerlink" title="角度转换"></a>角度转换</h3><p><code>math.degrees</code>(<em>x</em>)</p>
<p>将角度 <em>x</em> 从弧度转换为度数。</p>
<p><code>math.radians</code>(<em>x</em>)</p>
<p>将角度 <em>x</em> 从度数转换为弧度。</p>
<h3 id="双曲函数"><a href="#双曲函数" class="headerlink" title="双曲函数"></a>双曲函数</h3><p>双曲函数 是基于双曲线而非圆来对三角函数进行模拟。</p>
<p><code>math.acosh</code>(<em>x</em>)</p>
<p>返回 <em>x</em> 的反双曲余弦值。</p>
<p><code>math.asinh</code>(<em>x</em>)</p>
<p>返回 <em>x</em> 的反双曲正弦值。</p>
<p><code>math.atanh</code>(<em>x</em>)</p>
<p>返回 <em>x</em> 的反双曲正切值。</p>
<p><code>math.cosh</code>(<em>x</em>)</p>
<p>返回 <em>x</em> 的双曲余弦值。</p>
<p><code>math.sinh</code>(<em>x</em>)</p>
<p>返回 <em>x</em> 的双曲正弦值。</p>
<p><code>math.tanh</code>(<em>x</em>)</p>
<p>返回 <em>x</em> 的双曲正切值。</p>
<h3 id="特殊函数"><a href="#特殊函数" class="headerlink" title="特殊函数"></a>特殊函数</h3><p><code>math.erf</code>(<em>x</em>)</p>
<p>返回 <em>x</em> 处的 error function 。</p>
<p><code>erf()</code> 函数可用于计算传统的统计函数，如 累积标准正态分布</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">phi</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token string">'Cumulative distribution function for the standard normal distribution'</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token number">1.0</span> <span class="token operator">+</span> erf<span class="token punctuation">(</span>x <span class="token operator">/</span> sqrt<span class="token punctuation">(</span><span class="token number">2.0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2.0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>3.2 新版功能.</p>
<p><code>math.erfc</code>(<em>x</em>)</p>
<p>返回 <em>x</em> 处的互补误差函数。 互补错误函数 定义为 <code>1.0 - erf(x)</code>。 它用于 <em>x</em> 的大值，从其中减去一个会导致 有效位数损失。</p>
<p>3.2 新版功能.</p>
<p><code>math.gamma</code>(<em>x</em>)</p>
<p>返回 <em>x</em> 处的 伽马函数 值。</p>
<p>3.2 新版功能.</p>
<p><code>math.lgamma</code>(<em>x</em>)</p>
<p>返回Gamma函数在 <em>x</em> 绝对值的自然对数。</p>
<p>3.2 新版功能.</p>
<h3 id="常量-1"><a href="#常量-1" class="headerlink" title="常量"></a>常量</h3><pre><code>math.pi</code></pre><p>数学常数 <em>π</em> = 3.141592…，精确到可用精度。</p>
<pre><code>math.e</code></pre><p>数学常数 <em>e</em> = 2.718281…，精确到可用精度。</p>
<pre><code>math.tau</code></pre><p>数学常数 <em>τ</em> = 6.283185…，精确到可用精度。Tau 是一个圆周常数，等于 2<em>π</em>，圆的周长与半径之比。更多关于 Tau 的信息可参考 Vi Hart 的视频 <a href="https://www.youtube.com/watch?v=jG7vhMMXagQ" target="_blank" rel="noopener">Pi is (still) Wrong</a>。吃两倍多的派来庆祝 Tau 日 吧！</p>
<p>3.6 新版功能.</p>
<pre><code>math.inf</code></pre><p>浮点正无穷大。 （对于负无穷大，使用 <code>-math.inf</code> 。）相当于 <code>float('inf')</code> 的输出。</p>
<p>3.5 新版功能.</p>
<pre><code>math.nan</code></pre><p>浮点“非数字”（NaN）值。 相当于 <code>float('nan')</code> 的输出。</p>
<p>3.5 新版功能.</p>
<p><strong>CPython implementation detail:</strong> <code>math</code> 模块主要包含围绕平台C数学库函数的简单包装器。特殊情况下的行为在适当情况下遵循C99标准的附录F。当前的实现将引发 <code>ValueError</code> 用于无效操作，如 <code>sqrt(-1.0)</code> 或 <code>log(0.0)</code> （其中C99附件F建议发出无效操作信号或被零除）， 和 <code>OverflowError</code> 用于溢出的结果（例如， <code>exp(1000.0)</code> ）。除非一个或多个输入参数是NaN，否则不会从上述任何函数返回NaN；在这种情况下，大多数函数将返回一个NaN，但是（再次遵循C99附件F）这个规则有一些例外，例如 <code>pow(float('nan'), 0.0)</code> 或 <code>hypot(float('nan'), float('inf'))</code> 。</p>
<p>请注意，Python不会将显式NaN与静默NaN区分开来，并且显式NaN的行为仍未明确。典型的行为是将所有NaN视为静默的。</p>
<h2 id="cmath-—-关于复数的数学函数"><a href="#cmath-—-关于复数的数学函数" class="headerlink" title="cmath —- 关于复数的数学函数"></a><code>cmath</code> —- 关于复数的数学函数</h2><p>这一模块提供了一些关于复数的数学函数。 该模块的函数的参数为整数、浮点数或复数。 这些函数的参数也可为一个拥有 <code>__complex__()</code> 或 <code>__float__()</code> 方法的 Python 对象，这些方法分别用于将对象转换为复数和浮点数，这些函数作用于转换后的结果。</p>
<p>注解</p>
<p>在具有对于有符号零的硬件和系统级支持的平台上，涉及支割线的函数在支割线的 <em>两侧</em> 都是连续的：零的符号可用来区别支割线的一侧和另一侧。 在不支持有符号零的平台上，连续性的规则见下文。</p>
<h3 id="到极坐标和从极坐标的转换"><a href="#到极坐标和从极坐标的转换" class="headerlink" title="到极坐标和从极坐标的转换"></a>到极坐标和从极坐标的转换</h3><p>使用 <em>矩形坐标</em> 或 <em>笛卡尔坐标</em> 在内部存储 Python 复数 <code>z</code>。 这完全取决于它的 <em>实部</em> <code>z.real</code> 和 <em>虚部</em> <code>z.imag</code>。 换句话说:</p>
<pre><code>z == z.real + z.imag*1j</code></pre><p><em>极坐标</em> 提供了另一种复数的表示方法。在极坐标中，一个复数 <em>z</em> 由模量 <em>r</em> 和相位角 <em>phi</em> 来定义。模量 <em>r</em> 是从 <em>z</em> 到坐标原点的距离，而相位角 <em>phi</em> 是以弧度为单位的，逆时针的，从正X轴到连接原点和 <em>z</em> 的线段间夹角的角度。</p>
<p>下面的函数可用于原生直角坐标与极坐标的相互转换。</p>
<p><code>cmath.phase</code>(<em>x</em>)</p>
<p>将 <em>x</em> 的相位 (也称为 <em>x</em> 的 <em>参数</em>) 返回为一个浮点数。<code>phase(x)</code> 相当于 <code>math.atan2(x.imag, x.real)</code>。 结果处于 [-<em>π</em>, <em>π</em>] 之间，以及这个操作的分支切断处于负实轴上，从上方连续。 在支持有符号零的系统上（这包涵大多数当前的常用系统），这意味着结果的符号与 <code>x.imag</code> 的符号相同，即使 <code>x.imag</code> 的值是 0:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> phase<span class="token punctuation">(</span>complex<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token number">3.141592653589793</span>
<span class="token operator">>></span><span class="token operator">></span> phase<span class="token punctuation">(</span>complex<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">0.0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token operator">-</span><span class="token number">3.141592653589793</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>注解</p>
<p>一个复数 <em>x</em> 的模数（绝对值）可以通过内置函数 <code>abs()</code> 计算。没有单独的 <code>cmath</code> 模块函数用于这个操作。</p>
<p><code>cmath.polar</code>(<em>x</em>)</p>
<p>在极坐标中返回 <em>x</em> 的表达方式。返回一个数对 <code>(r, phi)</code>，<em>r</em> 是 <em>x</em> 的模数，<em>phi</em> 是 <em>x</em> 的相位角。 <code>polar(x)</code> 相当于 <code>(abs(x), phase(x))</code>。</p>
<p><code>cmath.rect</code>(<em>r</em>, <em>phi</em>)</p>
<p>通过极坐标的 <em>r</em> 和 <em>phi</em> 返回复数 <em>x</em>。相当于 <code>r * (math.cos(phi) + math.sin(phi)*1j)</code>。</p>
<h3 id="幂函数与对数函数-1"><a href="#幂函数与对数函数-1" class="headerlink" title="幂函数与对数函数"></a>幂函数与对数函数</h3><p><code>cmath.exp</code>(<em>x</em>)</p>
<p>返回 <em>e</em> 的 <em>x</em> 次方，<em>e</em> 是自然对数的底数。</p>
<p><code>cmath.log</code>(<em>x</em>[, <em>base</em>])</p>
<p>返回给定 <em>base</em> 的 <em>x</em> 的对数。如果没有给定 <em>base*，返回 *x</em> 的自然对数。 从 0 到 -∞ 存在一条支割线，沿负实轴之上连续。</p>
<p><code>cmath.log10</code>(<em>x</em>)</p>
<p>返回底数为 10 的 <em>x</em> 的对数。它具有与 <code>log()</code> 相同的支割线。</p>
<p><code>cmath.sqrt</code>(<em>x</em>)</p>
<p>返回 <em>x</em> 的平方根。 它具有与 <code>log()</code> 相同的支割线。</p>
<h3 id="三角函数-1"><a href="#三角函数-1" class="headerlink" title="三角函数"></a>三角函数</h3><p><code>cmath.acos</code>(<em>x</em>)</p>
<p>返回 <em>x</em> 的反余弦。这里有两条支割线：一条沿着实轴从 1 向右延伸到 ∞，从下面连续延伸。另外一条沿着实轴从 -1 向左延伸到 -∞，从上面连续延伸。</p>
<p><code>cmath.asin</code>(<em>x</em>)</p>
<p>返回 <em>x</em> 的反正弦。它与 <code>acos()</code> 有相同的支割线。</p>
<p><code>cmath.atan</code>(<em>x</em>)</p>
<p>返回 <em>x</em> 的反正切。它具有两条支割线：一条沿着虚轴从 <code>1j</code> 延伸到 <code>∞j</code>，向右持续延伸。另一条是沿着虚轴从 <code>-1j</code> 延伸到 <code>-∞j</code> ，向左持续延伸。</p>
<p><code>cmath.cos</code>(<em>x</em>)</p>
<p>返回 <em>x</em> 的余弦。</p>
<p><code>cmath.sin</code>(<em>x</em>)</p>
<p>返回 <em>x</em> 的正弦。</p>
<p><code>cmath.tan</code>(<em>x</em>)</p>
<p>返回 <em>x</em> 的正切。</p>
<h3 id="双曲函数-1"><a href="#双曲函数-1" class="headerlink" title="双曲函数"></a>双曲函数</h3><p><code>cmath.acosh</code>(<em>x</em>)</p>
<p>返回 <em>x</em> 的反双曲余弦。它有一条支割线沿着实轴从 1 到 -∞ 向左延伸，从上方持续延伸。</p>
<p><code>cmath.asinh</code>(<em>x</em>)</p>
<p>返回 <em>x</em> 的反双曲正弦。它有两条支割线：一条沿着虚轴从 <code>1j</code> 向右持续延伸到 <code>∞j</code>。另一条是沿着虚轴从 <code>-1j</code> 向左持续延伸到 <code>-∞j</code>。</p>
<p><code>cmath.atanh</code>(<em>x</em>)</p>
<p>返回 <em>x</em> 的反双曲正切。它有两条支割线：一条是沿着实轴从 <code>1</code> 延展到 <code>∞</code>，从下面持续延展。另一条是沿着实轴从 <code>-1</code> 延展到 <code>-∞</code>，从上面持续延展。</p>
<p><code>cmath.cosh</code>(<em>x</em>)</p>
<p>返回 <em>x</em> 的双曲余弦值。</p>
<p><code>cmath.sinh</code>(<em>x</em>)</p>
<p>返回 <em>x</em> 的双曲正弦值。</p>
<p><code>cmath.tanh</code>(<em>x</em>)</p>
<p>返回 <em>x</em> 的双曲正切值。</p>
<h3 id="分类函数"><a href="#分类函数" class="headerlink" title="分类函数"></a>分类函数</h3><p><code>cmath.isfinite</code>(<em>x</em>)</p>
<p>如果 <em>x</em> 的实部和虚部都是有限的，则返回 <code>True</code>，否则返回 <code>False</code>。</p>
<p>3.2 新版功能.</p>
<p><code>cmath.isinf</code>(<em>x</em>)</p>
<p>如果 <em>x</em> 的实部或者虚部是无穷大的，则返回 <code>True</code>，否则返回 <code>False</code>。</p>
<p><code>cmath.isnan</code>(<em>x</em>)</p>
<p>如果 <em>x</em> 的实部或者虚部是 NaN，则返回 <code>True</code> ，否则返回 <code>False</code>。</p>
<p><code>cmath.isclose</code>(<em>a</em>, <em>b</em>, <em>**,</em> rel_tol=1e-09<em>,</em> abs_tol=0.0*)</p>
<p>若 <em>a</em> 和 <em>b</em> 的值比较接近则返回 <code>True</code>，否则返回 <code>False</code>。</p>
<p>根据给定的绝对和相对容差确定两个值是否被认为是接近的。</p>
<p><em>rel_tol</em> 是相对容差 —— 它是 <em>a</em> 和 <em>b</em> 之间允许的最大差值，相对于 <em>a</em> 或 <em>b</em> 的较大绝对值。例如，要设置5％的容差，请传递 <code>rel_tol=0.05</code> 。默认容差为 <code>1e-09</code>，确保两个值在大约9位十进制数字内相同。 <em>rel_tol</em> 必须大于零。</p>
<p><em>abs_tol</em> 是最小绝对容差 —— 对于接近零的比较很有用。 <em>abs_tol</em> 必须至少为零。</p>
<p>如果没有错误发生，结果将是： <code>abs(a-b) &lt;= max(rel_tol * max(abs(a), abs(b)), abs_tol)</code> 。</p>
<p>IEEE 754特殊值 <code>NaN</code> ， <code>inf</code> 和 <code>-inf</code> 将根据IEEE规则处理。具体来说， <code>NaN</code> 不被认为接近任何其他值，包括 <code>NaN</code> 。 <code>inf</code> 和 <code>-inf</code> 只被认为接近自己。</p>
<p>3.5 新版功能.</p>
<p>参见</p>
<p><a href="https://www.python.org/dev/peps/pep-0485" target="_blank" rel="noopener"><strong>PEP 485</strong></a> —— 用于测试近似相等的函数</p>
<h3 id="常量-2"><a href="#常量-2" class="headerlink" title="常量"></a>常量</h3><pre><code>cmath.pi</code></pre><p>数学常数 <em>π</em> ，作为一个浮点数。</p>
<pre><code>cmath.e</code></pre><p>数学常数 <em>e</em> ，作为一个浮点数。</p>
<pre><code>cmath.tau</code></pre><p>数学常数 <em>τ</em> ，作为一个浮点数。</p>
<p>3.6 新版功能.</p>
<pre><code>cmath.inf</code></pre><p>浮点正无穷大。相当于 <code>float('inf')</code>。</p>
<p>3.6 新版功能.</p>
<pre><code>cmath.infj</code></pre><p>具有零实部和正无穷虚部的复数。相当于 <code>complex(0.0, float('inf'))</code>。</p>
<p>3.6 新版功能.</p>
<pre><code>cmath.nan</code></pre><p>浮点“非数字”（NaN）值。相当于 <code>float('nan')</code>。</p>
<p>3.6 新版功能.</p>
<pre><code>cmath.nanj</code></pre><p>具有零实部和 NaN 虚部的复数。相当于 <code>complex(0.0, float('nan'))</code>。</p>
<p>3.6 新版功能.</p>
<p>请注意，函数的选择与模块 <code>math</code> 中的函数选择相似，但不完全相同。 拥有两个模块的原因是因为有些用户对复数不感兴趣，甚至根本不知道它们是什么。它们宁愿 <code>math.sqrt(-1)</code> 引发异常，也不想返回一个复数。 另请注意，被 <code>cmath</code> 定义的函数始终会返回一个复数，尽管答案可以表示为一个实数（在这种情况下，复数的虚数部分为零）。</p>
<p>关于支割线的注释：它们是沿着给定函数无法连续的曲线。它们是许多复变函数的必要特征。 假设您需要使用复变函数进行计算，您将会了解支割线的概念。 请参阅几乎所有关于复变函数的（不太基本）的书来获得启发。</p>
<h2 id="decimal-—-十进制定点和浮点运算"><a href="#decimal-—-十进制定点和浮点运算" class="headerlink" title="decimal —- 十进制定点和浮点运算"></a><code>decimal</code> —- 十进制定点和浮点运算</h2><p><strong>源码：</strong> <a href="https://github.com/python/cpython/tree/3.10/Lib/decimal.py" target="_blank" rel="noopener">Lib/decimal.py</a></p>
<hr>
<p><code>decimal</code> 模块为快速正确舍入的十进制浮点运算提供支持。 与 <code>float</code> 数据类型相比，它具有以下几个优点：</p>
<ul>
<li><p>Decimal 类型的“设计是基于考虑人类习惯的浮点数模型，并且因此具有以下最高指导原则 —— 计算机必须提供与人们在学校所学习的算术相一致的算术。” —— 摘自 decimal 算术规范描述。</p>
</li>
<li><p>Decimal 数字的表示是完全精确的。 相比之下，<code>1.1</code> 和 <code>2.2</code> 这样的数字在二进制浮点中没有精确的表示。 最终用户通常不希望 <code>1.1 + 2.2</code> 如二进制浮点数表示那样被显示为 <code>3.3000000000000003</code>。</p>
</li>
<li><p>精确性会延续到算术类操作中。 对于 decimal 浮点数，<code>0.1 + 0.1 + 0.1 - 0.3</code> 会精确地等于零。 而对于二进制浮点数，结果则为 <code>5.5511151231257827e-017</code> 。 虽然接近于零，但其中的误差将妨碍可靠的相等性检验，并且误差还会不断累积。 因此，decimal 更适合具有严格相等不变性要求的会计类应用。</p>
</li>
<li><p>十进制模块包含有效位的概念，因此 <code>1.30 + 1.20</code> 的结果是 <code>2.50</code> 。 保留尾随零以表示有效位。 这是货币的惯用表示方法。乘法则沿用 “教科书“ 中：保留被乘数中的所有数字的方法。 例如， <code>1.3 * 1.2</code> 结果是 <code>1.56</code> 而 <code>1.30 * 1.20</code> 结果是 <code>1.5600</code> 。</p>
</li>
<li><p>与基于硬件的二进制浮点不同，十进制模块具有用户可更改的精度（默认为28位），可以与给定问题所需的一样大：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> decimal <span class="token keyword">import</span> <span class="token operator">*</span>
<span class="token operator">>></span><span class="token operator">></span> getcontext<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>prec <span class="token operator">=</span> <span class="token number">6</span>
<span class="token operator">>></span><span class="token operator">></span> Decimal<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">/</span> Decimal<span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span>
Decimal<span class="token punctuation">(</span><span class="token string">'0.142857'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> getcontext<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>prec <span class="token operator">=</span> <span class="token number">28</span>
<span class="token operator">>></span><span class="token operator">></span> Decimal<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">/</span> Decimal<span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span>
Decimal<span class="token punctuation">(</span><span class="token string">'0.1428571428571428571428571429'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>二进制和 decimal 浮点数都是根据已发布的标准实现的。 虽然内置浮点类型只公开其功能的一小部分，但 decimal 模块公开了标准的所有必需部分。 在需要时，程序员可以完全控制舍入和信号处理。 这包括通过使用异常来阻止任何不精确操作来强制执行精确算术的选项。</p>
</li>
<li><p>decimal 模块旨在支持“无偏差，精确无舍入的十进制算术（有时称为定点数算术）和有舍入的浮点数算术”。 —— 摘自 decimal 算术规范说明。</p>
</li>
</ul>
<p>该模块的设计以三个概念为中心：decimal 数值，算术上下文和信号。</p>
<p>decimal 数值是不可变对象。 它由符号，系数和指数位组成。 为了保持有效位，系数位不会截去末尾零。 decimal 数值也包括特殊值例如 <code>Infinity</code> ，<code>-Infinity</code> 和 <code>NaN</code> 。 该标准还区分 <code>-0</code> 和 <code>+0</code> 。</p>
<p>算术的上下文是指定精度、舍入规则、指数限制、指示操作结果的标志以及确定符号是否被视为异常的陷阱启用器的环境。 舍入选项包括 <code>ROUND_CEILING</code> 、 <code>ROUND_DOWN</code> 、 <code>ROUND_FLOOR</code> 、 <code>ROUND_HALF_DOWN</code>, <code>ROUND_HALF_EVEN</code> 、 <code>ROUND_HALF_UP</code> 、 <code>ROUND_UP</code> 以及 <code>ROUND_05UP</code>.</p>
<p>信号是在计算过程中出现的异常条件组。 根据应用程序的需要，信号可能会被忽略，被视为信息，或被视为异常。 十进制模块中的信号有：<code>Clamped</code> 、 <code>InvalidOperation</code> 、 <code>DivisionByZero</code> 、 <code>Inexact</code> 、 <code>Rounded</code> 、 <code>Subnormal</code> 、 <code>Overflow</code> 、 <code>Underflow</code> 以及 <code>FloatOperation</code> 。</p>
<p>对于每个信号，都有一个标志和一个陷阱启动器。 遇到信号时，其标志设置为 1 ，然后，如果陷阱启用器设置为 1 ，则引发异常。 标志是粘性的，因此用户需要在监控计算之前重置它们。</p>
<p>参见</p>
<ul>
<li>IBM 的通用十进制算术规范描述 <a href="http://speleotrove.com/decimal/decarith.html" target="_blank" rel="noopener">The General Decimal Arithmetic Specification</a>。</li>
</ul>
<h3 id="快速入门教程"><a href="#快速入门教程" class="headerlink" title="快速入门教程"></a>快速入门教程</h3><p>通常使用 decimal 的方式是先导入该模块，通过 <code>getcontext()</code> 查看当前上下文，并在必要时为精度、舍入或启用的陷阱设置新值:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> decimal <span class="token keyword">import</span> <span class="token operator">*</span>
<span class="token operator">>></span><span class="token operator">></span> getcontext<span class="token punctuation">(</span><span class="token punctuation">)</span>
Context<span class="token punctuation">(</span>prec<span class="token operator">=</span><span class="token number">28</span><span class="token punctuation">,</span> rounding<span class="token operator">=</span>ROUND_HALF_EVEN<span class="token punctuation">,</span> Emin<span class="token operator">=</span><span class="token operator">-</span><span class="token number">999999</span><span class="token punctuation">,</span> Emax<span class="token operator">=</span><span class="token number">999999</span><span class="token punctuation">,</span>
        capitals<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> clamp<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> flags<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> traps<span class="token operator">=</span><span class="token punctuation">[</span>Overflow<span class="token punctuation">,</span> DivisionByZero<span class="token punctuation">,</span>
        InvalidOperation<span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> getcontext<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>prec <span class="token operator">=</span> <span class="token number">7</span>       <span class="token comment" spellcheck="true"># Set a new precision</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以基于整数、字符串、浮点数或元组构造 Decimal 实例。 基于整数或浮点数构造将执行该整数或浮点值的精确转换。 Decimal 数字包括特殊值例如 <code>NaN</code> 表示“非数字”，正的和负的 <code>Infinity</code> 和 <code>-0</code></p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> getcontext<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>prec <span class="token operator">=</span> <span class="token number">28</span>
<span class="token operator">>></span><span class="token operator">></span> Decimal<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span>
Decimal<span class="token punctuation">(</span><span class="token string">'10'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> Decimal<span class="token punctuation">(</span><span class="token string">'3.14'</span><span class="token punctuation">)</span>
Decimal<span class="token punctuation">(</span><span class="token string">'3.14'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> Decimal<span class="token punctuation">(</span><span class="token number">3.14</span><span class="token punctuation">)</span>
Decimal<span class="token punctuation">(</span><span class="token string">'3.140000000000000124344978758017532527446746826171875'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> Decimal<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
Decimal<span class="token punctuation">(</span><span class="token string">'3.14'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> Decimal<span class="token punctuation">(</span>str<span class="token punctuation">(</span><span class="token number">2.0</span> <span class="token operator">**</span> <span class="token number">0.5</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
Decimal<span class="token punctuation">(</span><span class="token string">'1.4142135623730951'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> Decimal<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">**</span> Decimal<span class="token punctuation">(</span><span class="token string">'0.5'</span><span class="token punctuation">)</span>
Decimal<span class="token punctuation">(</span><span class="token string">'1.414213562373095048801688724'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> Decimal<span class="token punctuation">(</span><span class="token string">'NaN'</span><span class="token punctuation">)</span>
Decimal<span class="token punctuation">(</span><span class="token string">'NaN'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> Decimal<span class="token punctuation">(</span><span class="token string">'-Infinity'</span><span class="token punctuation">)</span>
Decimal<span class="token punctuation">(</span><span class="token string">'-Infinity'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果 <code>FloatOperation</code> 信号被捕获，构造函数中的小数和浮点数的意外混合或排序比较会引发异常</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> c <span class="token operator">=</span> getcontext<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> c<span class="token punctuation">.</span>traps<span class="token punctuation">[</span>FloatOperation<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">True</span>
<span class="token operator">>></span><span class="token operator">></span> Decimal<span class="token punctuation">(</span><span class="token number">3.14</span><span class="token punctuation">)</span>
Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>
  File <span class="token string">"&lt;stdin>"</span><span class="token punctuation">,</span> line <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">></span>
decimal<span class="token punctuation">.</span>FloatOperation<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token string">'decimal.FloatOperation'</span><span class="token operator">></span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> Decimal<span class="token punctuation">(</span><span class="token string">'3.5'</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">3.7</span>
Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>
  File <span class="token string">"&lt;stdin>"</span><span class="token punctuation">,</span> line <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">></span>
decimal<span class="token punctuation">.</span>FloatOperation<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token string">'decimal.FloatOperation'</span><span class="token operator">></span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> Decimal<span class="token punctuation">(</span><span class="token string">'3.5'</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">3.5</span>
<span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>3.3 新版功能.</p>
<p>新 Decimal 的重要性仅由输入的位数决定。 上下文精度和舍入仅在算术运算期间发挥作用。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> getcontext<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>prec <span class="token operator">=</span> <span class="token number">6</span>
<span class="token operator">>></span><span class="token operator">></span> Decimal<span class="token punctuation">(</span><span class="token string">'3.0'</span><span class="token punctuation">)</span>
Decimal<span class="token punctuation">(</span><span class="token string">'3.0'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> Decimal<span class="token punctuation">(</span><span class="token string">'3.1415926535'</span><span class="token punctuation">)</span>
Decimal<span class="token punctuation">(</span><span class="token string">'3.1415926535'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> Decimal<span class="token punctuation">(</span><span class="token string">'3.1415926535'</span><span class="token punctuation">)</span> <span class="token operator">+</span> Decimal<span class="token punctuation">(</span><span class="token string">'2.7182818285'</span><span class="token punctuation">)</span>
Decimal<span class="token punctuation">(</span><span class="token string">'5.85987'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> getcontext<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>rounding <span class="token operator">=</span> ROUND_UP
<span class="token operator">>></span><span class="token operator">></span> Decimal<span class="token punctuation">(</span><span class="token string">'3.1415926535'</span><span class="token punctuation">)</span> <span class="token operator">+</span> Decimal<span class="token punctuation">(</span><span class="token string">'2.7182818285'</span><span class="token punctuation">)</span>
Decimal<span class="token punctuation">(</span><span class="token string">'5.85988'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果超出了 C 版本的内部限制，则构造一个 decimal 将引发 <code>InvalidOperation</code></p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> Decimal<span class="token punctuation">(</span><span class="token string">"1e9999999999999999999"</span><span class="token punctuation">)</span>
Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>
  File <span class="token string">"&lt;stdin>"</span><span class="token punctuation">,</span> line <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">></span>
decimal<span class="token punctuation">.</span>InvalidOperation<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token string">'decimal.InvalidOperation'</span><span class="token operator">></span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>在 3.3 版更改.</p>
<p>Decimal 数字能很好地与 Python 的其余部分交互。 以下是一个小小的 decimal 浮点数飞行马戏团：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> data <span class="token operator">=</span> list<span class="token punctuation">(</span>map<span class="token punctuation">(</span>Decimal<span class="token punctuation">,</span> <span class="token string">'1.34 1.87 3.45 2.35 1.00 0.03 9.25'</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> max<span class="token punctuation">(</span>data<span class="token punctuation">)</span>
Decimal<span class="token punctuation">(</span><span class="token string">'9.25'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> min<span class="token punctuation">(</span>data<span class="token punctuation">)</span>
Decimal<span class="token punctuation">(</span><span class="token string">'0.03'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> sorted<span class="token punctuation">(</span>data<span class="token punctuation">)</span>
<span class="token punctuation">[</span>Decimal<span class="token punctuation">(</span><span class="token string">'0.03'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> Decimal<span class="token punctuation">(</span><span class="token string">'1.00'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> Decimal<span class="token punctuation">(</span><span class="token string">'1.34'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> Decimal<span class="token punctuation">(</span><span class="token string">'1.87'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
 Decimal<span class="token punctuation">(</span><span class="token string">'2.35'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> Decimal<span class="token punctuation">(</span><span class="token string">'3.45'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> Decimal<span class="token punctuation">(</span><span class="token string">'9.25'</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> sum<span class="token punctuation">(</span>data<span class="token punctuation">)</span>
Decimal<span class="token punctuation">(</span><span class="token string">'19.29'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c <span class="token operator">=</span> data<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> str<span class="token punctuation">(</span>a<span class="token punctuation">)</span>
<span class="token string">'1.34'</span>
<span class="token operator">>></span><span class="token operator">></span> float<span class="token punctuation">(</span>a<span class="token punctuation">)</span>
<span class="token number">1.34</span>
<span class="token operator">>></span><span class="token operator">></span> round<span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>
Decimal<span class="token punctuation">(</span><span class="token string">'1.3'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> int<span class="token punctuation">(</span>a<span class="token punctuation">)</span>
<span class="token number">1</span>
<span class="token operator">>></span><span class="token operator">></span> a <span class="token operator">*</span> <span class="token number">5</span>
Decimal<span class="token punctuation">(</span><span class="token string">'6.70'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> a <span class="token operator">*</span> b
Decimal<span class="token punctuation">(</span><span class="token string">'2.5058'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> c <span class="token operator">%</span> a
Decimal<span class="token punctuation">(</span><span class="token string">'0.77'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>Decimal 也可以使用一些数学函数：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> getcontext<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>prec <span class="token operator">=</span> <span class="token number">28</span>
<span class="token operator">>></span><span class="token operator">></span> Decimal<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">.</span>sqrt<span class="token punctuation">(</span><span class="token punctuation">)</span>
Decimal<span class="token punctuation">(</span><span class="token string">'1.414213562373095048801688724'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> Decimal<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span>exp<span class="token punctuation">(</span><span class="token punctuation">)</span>
Decimal<span class="token punctuation">(</span><span class="token string">'2.718281828459045235360287471'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> Decimal<span class="token punctuation">(</span><span class="token string">'10'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>ln<span class="token punctuation">(</span><span class="token punctuation">)</span>
Decimal<span class="token punctuation">(</span><span class="token string">'2.302585092994045684017991455'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> Decimal<span class="token punctuation">(</span><span class="token string">'10'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>log10<span class="token punctuation">(</span><span class="token punctuation">)</span>
Decimal<span class="token punctuation">(</span><span class="token string">'1'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>quantize()</code> 方法将数字舍入为固定指数。 此方法对于将结果舍入到固定的位置的货币应用程序非常有用：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> Decimal<span class="token punctuation">(</span><span class="token string">'7.325'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>quantize<span class="token punctuation">(</span>Decimal<span class="token punctuation">(</span><span class="token string">'.01'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> rounding<span class="token operator">=</span>ROUND_DOWN<span class="token punctuation">)</span>
Decimal<span class="token punctuation">(</span><span class="token string">'7.32'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> Decimal<span class="token punctuation">(</span><span class="token string">'7.325'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>quantize<span class="token punctuation">(</span>Decimal<span class="token punctuation">(</span><span class="token string">'1.'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> rounding<span class="token operator">=</span>ROUND_UP<span class="token punctuation">)</span>
Decimal<span class="token punctuation">(</span><span class="token string">'8'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>如上所示，<code>getcontext()</code> 函数访问当前上下文并允许更改设置。 这种方法满足大多数应用程序的需求。</p>
<p>对于更高级的工作，使用 Context() 构造函数创建备用上下文可能很有用。 要使用备用活动，请使用 <code>setcontext()</code> 函数。</p>
<p>根据标准，<code>decimal</code> 模块提供了两个现成的标准上下文 <code>BasicContext</code> 和 <code>ExtendedContext</code> 。 前者对调试特别有用，因为许多陷阱都已启用：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> myothercontext <span class="token operator">=</span> Context<span class="token punctuation">(</span>prec<span class="token operator">=</span><span class="token number">60</span><span class="token punctuation">,</span> rounding<span class="token operator">=</span>ROUND_HALF_DOWN<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> setcontext<span class="token punctuation">(</span>myothercontext<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> Decimal<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">/</span> Decimal<span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span>
Decimal<span class="token punctuation">(</span><span class="token string">'0.142857142857142857142857142857142857142857142857142857142857'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> ExtendedContext
Context<span class="token punctuation">(</span>prec<span class="token operator">=</span><span class="token number">9</span><span class="token punctuation">,</span> rounding<span class="token operator">=</span>ROUND_HALF_EVEN<span class="token punctuation">,</span> Emin<span class="token operator">=</span><span class="token operator">-</span><span class="token number">999999</span><span class="token punctuation">,</span> Emax<span class="token operator">=</span><span class="token number">999999</span><span class="token punctuation">,</span>
        capitals<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> clamp<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> flags<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> traps<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> setcontext<span class="token punctuation">(</span>ExtendedContext<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> Decimal<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">/</span> Decimal<span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span>
Decimal<span class="token punctuation">(</span><span class="token string">'0.142857143'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> Decimal<span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span> <span class="token operator">/</span> Decimal<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
Decimal<span class="token punctuation">(</span><span class="token string">'Infinity'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> setcontext<span class="token punctuation">(</span>BasicContext<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> Decimal<span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span> <span class="token operator">/</span> Decimal<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>
  File <span class="token string">"&lt;pyshell#143>"</span><span class="token punctuation">,</span> line <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">in</span> <span class="token operator">-</span>toplevel<span class="token operator">-</span>
    Decimal<span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span> <span class="token operator">/</span> Decimal<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
DivisionByZero<span class="token punctuation">:</span> x <span class="token operator">/</span> <span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>上下文还具有用于监视计算期间遇到的异常情况的信号标志。 标志保持设置直到明确清除，因此最好通过使用 <code>clear_flags()</code> 方法清除每组受监控计算之前的标志。:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> setcontext<span class="token punctuation">(</span>ExtendedContext<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> getcontext<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>clear_flags<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> Decimal<span class="token punctuation">(</span><span class="token number">355</span><span class="token punctuation">)</span> <span class="token operator">/</span> Decimal<span class="token punctuation">(</span><span class="token number">113</span><span class="token punctuation">)</span>
Decimal<span class="token punctuation">(</span><span class="token string">'3.14159292'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> getcontext<span class="token punctuation">(</span><span class="token punctuation">)</span>
Context<span class="token punctuation">(</span>prec<span class="token operator">=</span><span class="token number">9</span><span class="token punctuation">,</span> rounding<span class="token operator">=</span>ROUND_HALF_EVEN<span class="token punctuation">,</span> Emin<span class="token operator">=</span><span class="token operator">-</span><span class="token number">999999</span><span class="token punctuation">,</span> Emax<span class="token operator">=</span><span class="token number">999999</span><span class="token punctuation">,</span>
        capitals<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> clamp<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> flags<span class="token operator">=</span><span class="token punctuation">[</span>Inexact<span class="token punctuation">,</span> Rounded<span class="token punctuation">]</span><span class="token punctuation">,</span> traps<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><em>flags</em> 条目显示对 <code>Pi</code> 的有理逼近被舍入（超出上下文精度的数字被抛弃）并且结果是不精确的（一些丢弃的数字不为零）。</p>
<p>使用上下文的 <code>traps</code> 字段中的字典设置单个陷阱：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> setcontext<span class="token punctuation">(</span>ExtendedContext<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> Decimal<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">/</span> Decimal<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
Decimal<span class="token punctuation">(</span><span class="token string">'Infinity'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> getcontext<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>traps<span class="token punctuation">[</span>DivisionByZero<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>
<span class="token operator">>></span><span class="token operator">></span> Decimal<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">/</span> Decimal<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>
  File <span class="token string">"&lt;pyshell#112>"</span><span class="token punctuation">,</span> line <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">in</span> <span class="token operator">-</span>toplevel<span class="token operator">-</span>
    Decimal<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">/</span> Decimal<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
DivisionByZero<span class="token punctuation">:</span> x <span class="token operator">/</span> <span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>大多数程序仅在程序开始时调整当前上下文一次。 并且，在许多应用程序中，数据在循环内单个强制转换为 <code>Decimal</code> 。 通过创建上下文集和小数，程序的大部分操作数据与其他 Python 数字类型没有区别。</p>
<h3 id="Decimal-对象"><a href="#Decimal-对象" class="headerlink" title="Decimal 对象"></a>Decimal 对象</h3><p><em>class</em> <code>decimal.Decimal</code>(<em>value=’0’</em>, <em>context=None</em>)</p>
<p>根据 <em>value</em> 构造一个新的 <code>Decimal</code> 对象。</p>
<p><em>value</em> 可以是整数，字符串，元组，<code>float</code> ，或另一个 <code>Decimal</code> 对象。 如果没有给出 <em>value*，则返回 <code>Decimal('0')</code>。 如果 *value</em> 是一个字符串，它应该在前导和尾随空格字符以及下划线被删除之后符合十进制数字字符串语法:</p>
<pre><code>sign           ::=  '+' | '-'
digit          ::=  '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9'
indicator      ::=  'e' | 'E'
digits         ::=  digit [digit]...
decimal-part   ::=  digits '.' [digits] | ['.'] digits
exponent-part  ::=  indicator [sign] digits
infinity       ::=  'Infinity' | 'Inf'
nan            ::=  'NaN' [digits] | 'sNaN' [digits]
numeric-value  ::=  decimal-part [exponent-part] | infinity
numeric-string ::=  [sign] numeric-value | [sign] nan</code></pre><p>当上面出现 <code>digit</code> 时也允许其他十进制数码。 其中包括来自各种其他语言系统的十进制数码（例如阿拉伯-印地语和天城文的数码）以及全宽数码 <code>'\uff10'</code> 到 <code>'\uff19'</code>。</p>
<p>如果 <em>value</em> 是一个 <code>tuple</code> ，它应该有三个组件，一个符号（ <code>0</code> 表示正数或 <code>1</code> 表示负数），一个数字的 <code>tuple</code> 和整数指数。 例如， <code>Decimal((0, (1, 4, 1, 4), -3))</code> 返回 <code>Decimal('1.414')</code>。</p>
<p>如果 <em>value</em> 是 <code>float</code> ，则二进制浮点值无损地转换为其精确的十进制等效值。 此转换通常需要53位或更多位数的精度。 例如， <code>Decimal(float('1.1'))</code> 转换为<code>Decimal(‘1.100000000000000088817841970012523233890533447265625’)</code>。</p>
<p><em>context</em> 精度不会影响存储的位数。 这完全由 <em>value</em> 中的位数决定。 例如，<code>Decimal('3.00000')</code> 记录所有五个零，即使上下文精度只有三。</p>
<p><em>context</em> 参数的目的是确定 <em>value</em> 是格式错误的字符串时该怎么做。 如果上下文陷阱 <code>InvalidOperation</code>，则引发异常；否则，构造函数返回一个新的 Decimal，其值为 <code>NaN</code>。</p>
<p>构造完成后， <code>Decimal</code> 对象是不可变的。</p>
<p>在 3.2 版更改: 现在允许构造函数的参数为 <code>float</code> 实例。</p>
<p>在 3.3 版更改: <code>float</code> 参数在设置 <code>FloatOperation</code> 陷阱时引发异常。 默认情况下，陷阱已关闭。</p>
<p>在 3.6 版更改: 允许下划线进行分组，就像代码中的整数和浮点文字一样。</p>
<p>十进制浮点对象与其他内置数值类型共享许多属性，例如 <code>float</code> 和 <code>int</code> 。 所有常用的数学运算和特殊方法都适用。 同样，十进制对象可以复制、pickle、打印、用作字典键、用作集合元素、比较、排序和强制转换为另一种类型（例如 <code>float</code> 或 <code>int</code> ）。</p>
<p>算术对十进制对象和算术对整数和浮点数有一些小的差别。 当余数运算符 <code>%</code> 应用于Decimal对象时，结果的符号是 <em>被除数</em> 的符号，而不是除数的符号:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">7</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">4</span>
<span class="token number">1</span>
<span class="token operator">>></span><span class="token operator">></span> Decimal<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">7</span><span class="token punctuation">)</span> <span class="token operator">%</span> Decimal<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span>
Decimal<span class="token punctuation">(</span><span class="token string">'-3'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>整数除法运算符 <code>//</code> 的行为类似，返回真商的整数部分（截断为零）而不是它的向下取整，以便保留通常的标识 <code>x == (x // y) * y + x % y</code>:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token operator">-</span><span class="token number">7</span> <span class="token operator">//</span> <span class="token number">4</span>
<span class="token operator">-</span><span class="token number">2</span>
<span class="token operator">>></span><span class="token operator">></span> Decimal<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">7</span><span class="token punctuation">)</span> <span class="token operator">//</span> Decimal<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span>
Decimal<span class="token punctuation">(</span><span class="token string">'-1'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>%</code> 和 <code>//</code> 运算符实现了 <code>remainder</code> 和 <code>divide-integer</code> 操作（分别），如规范中所述。</p>
<p>十进制对象通常不能与浮点数或 <code>fractions.Fraction</code> 实例在算术运算中结合使用：例如,尝试将 <code>Decimal</code> 加到 <code>float</code> ，将引发 <code>TypeError</code>。 但是，可以使用 Python 的比较运算符来比较 <code>Decimal</code> 实例 <code>x</code> 和另一个数字 <code>y</code> 。 这样可以避免在对不同类型的数字进行相等比较时混淆结果。</p>
<p>在 3.2 版更改: 现在完全支持 <code>Decimal</code> 实例和其他数字类型之间的混合类型比较。</p>
<p>除了标准的数字属性，十进制浮点对象还有许多专门的方法：</p>
<ul>
<li><p><code>adjusted</code>()</p>
<p>在移出系数最右边的数字之后返回调整后的指数，直到只剩下前导数字：<code>Decimal('321e+5').adjusted()</code> 返回 7 。 用于确定最高有效位相对于小数点的位置。</p>
</li>
<li><p><code>as_integer_ratio</code>()</p>
<p>返回一对 <code>(n, d)</code> 整数，表示给定的 <code>Decimal</code> 实例作为分数、最简形式项并带有正分母:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> Decimal<span class="token punctuation">(</span><span class="token string">'-3.14'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>as_integer_ratio<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">157</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>转换是精确的。 在 Infinity 上引发 OverflowError ，在 NaN 上引起 ValueError 。</p>
</li>
</ul>
<p>3.6 新版功能.</p>
<ul>
<li><p><code>as_tuple</code>()</p>
<p>返回一个 named tuple 表示的数字： <code>DecimalTuple(sign, digits, exponent)</code>。</p>
</li>
<li><p><code>canonical</code>()</p>
<p>返回参数的规范编码。 目前，一个 <code>Decimal</code> 实例的编码始终是规范的，因此该操作返回其参数不变。</p>
</li>
<li><p><code>compare</code>(<em>other</em>, <em>context=None</em>)</p>
<p>比较两个 Decimal 实例的值。 <code>compare()</code> 返回一个 Decimal 实例，如果任一操作数是 NaN ，那么结果是 NaN</p>
<pre class="line-numbers language-python"><code class="language-python">a <span class="token operator">or</span> b <span class="token keyword">is</span> a NaN  <span class="token operator">==</span><span class="token operator">></span> Decimal<span class="token punctuation">(</span><span class="token string">'NaN'</span><span class="token punctuation">)</span>
a <span class="token operator">&lt;</span> b            <span class="token operator">==</span><span class="token operator">></span> Decimal<span class="token punctuation">(</span><span class="token string">'-1'</span><span class="token punctuation">)</span>
a <span class="token operator">==</span> b           <span class="token operator">==</span><span class="token operator">></span> Decimal<span class="token punctuation">(</span><span class="token string">'0'</span><span class="token punctuation">)</span>
a <span class="token operator">></span> b            <span class="token operator">==</span><span class="token operator">></span> Decimal<span class="token punctuation">(</span><span class="token string">'1'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><code>compare_signal</code>(<em>other</em>, <em>context=None</em>)</p>
<p>除了所有 NaN 信号之外，此操作与 <code>compare()</code> 方法相同。 也就是说，如果两个操作数都不是信令NaN，那么任何静默的 NaN 操作数都被视为信令NaN。</p>
</li>
<li><p><code>compare_total</code>(<em>other</em>, <em>context=None</em>)</p>
<p>使用它们的抽象表示而不是它们的数值来比较两个操作数。 类似于 <code>compare()</code> 方法，但结果给出了一个总排序 <code>Decimal</code> 实例。 两个 <code>Decimal</code> 实例具有相同的数值但不同的表示形式在此排序中比较不相等：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> Decimal<span class="token punctuation">(</span><span class="token string">'12.0'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>compare_total<span class="token punctuation">(</span>Decimal<span class="token punctuation">(</span><span class="token string">'12'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
Decimal<span class="token punctuation">(</span><span class="token string">'-1'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>静默和发出信号的 NaN 也包括在总排序中。 这个函数的结果是 <code>Decimal('0')</code> 如果两个操作数具有相同的表示，或是 <code>Decimal('-1')</code> 如果第一个操作数的总顺序低于第二个操作数，或是 <code>Decimal('1')</code> 如果第一个操作数在总顺序中高于第二个操作数。 有关总排序的详细信息，请参阅规范。</p>
<p>此操作不受上下文影响且静默：不更改任何标志且不执行舍入。 作为例外，如果无法准确转换第二个操作数，则C版本可能会引发InvalidOperation。</p>
</li>
<li><p><code>compare_total_mag</code>(<em>other</em>, <em>context=None</em>)</p>
<p>比较两个操作数使用它们的抽象表示而不是它们的值，如 <code>compare_total()</code>，但忽略每个操作数的符号。 <code>x.compare_total_mag(y)</code> 相当于 <code>x.copy_abs().compare_total(y.copy_abs())</code>。</p>
<p>此操作不受上下文影响且静默：不更改任何标志且不执行舍入。 作为例外，如果无法准确转换第二个操作数，则C版本可能会引发InvalidOperation。</p>
</li>
<li><p><code>conjugate</code>()</p>
<p>只返回self，这种方法只符合 Decimal 规范。</p>
</li>
<li><p><code>copy_abs</code>()</p>
<p>返回参数的绝对值。 此操作不受上下文影响并且是静默的：没有更改标志且不执行舍入。</p>
</li>
<li><p><code>copy_negate</code>()</p>
<p>回到参数的否定。 此操作不受上下文影响并且是静默的：没有标志更改且不执行舍入。</p>
</li>
<li><p><code>copy_sign</code>(<em>other</em>, <em>context=None</em>)</p>
<p>返回第一个操作数的副本，其符号设置为与第二个操作数的符号相同。 例如：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> Decimal<span class="token punctuation">(</span><span class="token string">'2.3'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>copy_sign<span class="token punctuation">(</span>Decimal<span class="token punctuation">(</span><span class="token string">'-1.5'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
Decimal<span class="token punctuation">(</span><span class="token string">'-2.3'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>此操作不受上下文影响且静默：不更改任何标志且不执行舍入。 作为例外，如果无法准确转换第二个操作数，则C版本可能会引发InvalidOperation。</p>
</li>
<li><p><code>exp</code>(<em>context=None</em>)</p>
<p>返回给定数字的（自然）指数函数<code>e**x</code>的值。结果使用 <code>ROUND_HALF_EVEN</code> 舍入模式正确舍入。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> Decimal<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span>exp<span class="token punctuation">(</span><span class="token punctuation">)</span>
Decimal<span class="token punctuation">(</span><span class="token string">'2.718281828459045235360287471'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> Decimal<span class="token punctuation">(</span><span class="token number">321</span><span class="token punctuation">)</span><span class="token punctuation">.</span>exp<span class="token punctuation">(</span><span class="token punctuation">)</span>
Decimal<span class="token punctuation">(</span><span class="token string">'2.561702493119680037517373933E+139'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><code>from_float</code>(<em>f</em>)</p>
<p>将浮点数转换为十进制数的类方法。</p>
<p>注意， Decimal.from_float(0.1) 与 Decimal(‘0.1’) 不同。 由于 0.1 在二进制浮点中不能精确表示，因此该值存储为最接近的可表示值，即 0x1.999999999999ap-4 。 十进制的等效值是<code>0.1000000000000000055511151231257827021181583404541015625</code>。</p>
<p>注解</p>
<p>从 Python 3.2 开始，<code>Decimal</code> 实例也可以直接从 <code>float</code> 构造。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> Decimal<span class="token punctuation">.</span>from_float<span class="token punctuation">(</span><span class="token number">0.1</span><span class="token punctuation">)</span>
Decimal<span class="token punctuation">(</span><span class="token string">'0.1000000000000000055511151231257827021181583404541015625'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> Decimal<span class="token punctuation">.</span>from_float<span class="token punctuation">(</span>float<span class="token punctuation">(</span><span class="token string">'nan'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
Decimal<span class="token punctuation">(</span><span class="token string">'NaN'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> Decimal<span class="token punctuation">.</span>from_float<span class="token punctuation">(</span>float<span class="token punctuation">(</span><span class="token string">'inf'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
Decimal<span class="token punctuation">(</span><span class="token string">'Infinity'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> Decimal<span class="token punctuation">.</span>from_float<span class="token punctuation">(</span>float<span class="token punctuation">(</span><span class="token string">'-inf'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
Decimal<span class="token punctuation">(</span><span class="token string">'-Infinity'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>3.1 新版功能.</p>
</li>
<li><p><code>fma</code>(<em>other</em>, <em>third</em>, <em>context=None</em>)</p>
<p>混合乘法加法。 返回 self<em>other+third ，中间乘积 self</em>other 没有舍入。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> Decimal<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">.</span>fma<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span>
Decimal<span class="token punctuation">(</span><span class="token string">'11'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li><p><code>is_canonical</code>()</p>
<p>如果参数是规范的，则为返回 <code>True</code>，否则为 <code>False</code> 。 目前，<code>Decimal</code> 实例总是规范的，所以这个操作总是返回 <code>True</code> 。</p>
</li>
<li><p><code>is_finite</code>()</p>
<p>如果参数是一个有限的数，则返回为 <code>True</code> ；如果参数为无穷大或 NaN ，则返回为 <code>False</code>。</p>
</li>
<li><p><code>is_infinite</code>()</p>
<p>如果参数为正负无穷大，则返回为 <code>True</code> ，否则为 <code>False</code> 。</p>
</li>
<li><p><code>is_nan</code>()</p>
<p>如果参数为 NaN （无论是否静默），则返回为 <code>True</code> ，否则为 <code>False</code> 。</p>
</li>
<li><p><code>is_normal</code>(<em>context=None</em>)</p>
<p>如果参数是一个 <em>标准的</em> 有限数则返回 <code>True</code>。 如果参数为零、次标准数、无穷大或 NaN 则返回 <code>False</code>。</p>
</li>
<li><p><code>is_qnan</code>()</p>
<p>如果参数为静默 NaN，返回 <code>True</code>，否则返回 <code>False</code>。</p>
</li>
<li><p><code>is_signed</code>()</p>
<p>如果参数带有负号，则返回为 <code>True</code>，否则返回 <code>False</code>。注意，0 和 NaN 都可带有符号。</p>
</li>
<li><p><code>is_snan</code>()</p>
<p>如果参数为显式 NaN，则返回 <code>True</code>，否则返回 <code>False</code>。</p>
</li>
<li><p><code>is_subnormal</code>(<em>context=None</em>)</p>
<p>如果参数为次标准数，则返回 <code>True</code>，否则返回 <code>False</code>。</p>
</li>
<li><p><code>is_zero</code>()</p>
<p>如果参数是0（正负皆可），则返回 <code>True</code>，否则返回 <code>False</code>。</p>
</li>
<li><p><code>ln</code>(<em>context=None</em>)</p>
<p>返回操作数的自然对数（以 e 为底）。结果是使用 <code>ROUND_HALF_EVEN</code> 舍入模式正确舍入的。</p>
</li>
<li><p><code>log10</code>(<em>context=None</em>)</p>
<p>返回操作数的以十为底的对数。结果是使用 <code>ROUND_HALF_EVEN</code> 舍入模式正确舍入的。</p>
</li>
<li><p><code>logb</code>(<em>context=None</em>)</p>
<p>对于一个非零数，返回其运算数的调整后指数作为一个 <code>Decimal</code> 实例。 如果运算数为零将返回 <code>Decimal('-Infinity')</code> 并且产生 the <code>DivisionByZero</code> 标志。如果运算数是无限大则返回 <code>Decimal('Infinity')</code> 。</p>
</li>
<li><p><code>logical_and</code>(<em>other</em>, <em>context=None</em>)</p>
<p><code>logical_and()</code> 是需要两个 <em>逻辑运算数</em> 的逻辑运算。按位输出两运算数的 <code>and</code> 运算的结果。</p>
</li>
<li><p><code>logical_invert</code>(<em>context=None</em>)</p>
<p><code>logical_invert()</code> 是一个逻辑运算。结果是操作数的按位求反。</p>
</li>
<li><p><code>logical_or</code>(<em>other</em>, <em>context=None</em>)</p>
<p><code>logical_or()</code> 是需要两个 <em>logical operands</em> 的逻辑运算。结果是两个运算数的按位的 <code>or</code> 运算。</p>
</li>
<li><p><code>logical_xor</code>(<em>other</em>, <em>context=None</em>)</p>
<p><code>logical_xor()</code> 是需要两个 <em>逻辑运算数</em> 的逻辑运算。结果是按位输出的两运算数的异或运算。</p>
</li>
<li><p><code>max</code>(<em>other</em>, <em>context=None</em>)</p>
<p>像 <code>max(self, other)</code> 一样，除了在返回之前应用上下文舍入规则并且用信号通知或忽略 <code>NaN</code> 值（取决于上下文以及它们是发信号还是安静）。</p>
</li>
<li><p><code>max_mag</code>(<em>other</em>, <em>context=None</em>)</p>
<p>与 <code>max()</code> 方法相似，但是操作数使用绝对值完成比较。</p>
</li>
<li><p><code>min</code>(<em>other</em>, <em>context=None</em>)</p>
<p>像 <code>min(self, other)</code> 一样，除了在返回之前应用上下文舍入规则并且用信号通知或忽略 <code>NaN</code> 值（取决于上下文以及它们是发信号还是安静）。</p>
</li>
<li><p><code>min_mag</code>(<em>other</em>, <em>context=None</em>)</p>
<p>与 <code>min()</code> 方法相似，但是操作数使用绝对值完成比较。</p>
</li>
<li><p><code>next_minus</code>(<em>context=None</em>)</p>
<p>返回小于给定操作数的上下文中可表示的最大数字（或者当前线程的上下文中的可表示的最大数字如果没有给定上下文）。</p>
</li>
<li><p><code>next_plus</code>(<em>context=None</em>)</p>
<p>返回大于给定操作数的上下文中可表示的最小数字（或者当前线程的上下文中的可表示的最小数字如果没有给定上下文）。</p>
</li>
<li><p><code>next_toward</code>(<em>other</em>, <em>context=None</em>)</p>
<p>如果两运算数不相等，返回在第二个操作数的方向上最接近第一个操作数的数。如果两操作数数值上相等，返回将符号设置为与第二个运算数相同的第一个运算数的拷贝。</p>
</li>
<li><p><code>normalize</code>(<em>context=None</em>)</p>
<p>通过去除尾随的零并将所有结果等于 <code>Decimal('0')</code> 的转化为 <code>Decimal('0e0')</code> 来标准化数字。用于为等效类的属性生成规范值。比如， <code>Decimal('32.100')</code> 和 <code>Decimal('0.321000e+2')</code> 都被标准化为相同的值 <code>Decimal('32.1')</code>。</p>
</li>
<li><p><code>number_class</code>(<em>context=None</em>)</p>
<p>返回一个字符串描述运算数的 <em>class</em> 。返回值是以下十个字符串中的一个。</p>
<ul>
<li><code>"-Infinity"</code> ，指示运算数为负无穷大。</li>
<li><code>"-Normal"</code> ，指示该运算数是负正常数字。</li>
<li><code>"-Subnormal"</code> ，指示该运算数是负的次标准数。</li>
<li><code>"-Zero"</code> ，指示该运算数是负零。</li>
<li><code>"-Zero"</code> ，指示该运算数是正零。</li>
<li><code>"+Subnormal"</code> ，指示该运算数是正的次标准数。</li>
<li><code>"+Normal"</code> ，指示该运算数是正的标准数。</li>
<li><code>"+Infinity"</code> ，指示该运算数是正无穷。</li>
<li><code>"NaN"</code> ，指示该运算数是肃静 NaN （非数字）。</li>
<li><code>"sNaN"</code> ，指示该运算数是信号 NaN 。</li>
</ul>
</li>
<li><p><code>quantize</code>(<em>exp</em>, <em>rounding=None</em>, <em>context=None</em>)</p>
<p>返回的值等于舍入后的第一个运算数并且具有第二个操作数的指数。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> Decimal<span class="token punctuation">(</span><span class="token string">'1.41421356'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>quantize<span class="token punctuation">(</span>Decimal<span class="token punctuation">(</span><span class="token string">'1.000'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
Decimal<span class="token punctuation">(</span><span class="token string">'1.414'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>与其他运算不同，如果量化运算后的系数长度大于精度，那么会发出一个 <code>InvalidOperation</code> 信号。这保证了除非有一个错误情况，量化指数恒等于右手运算数的指数。</p>
<p>与其他运算不同，量化永不信号下溢，即使结果不正常且不精确。</p>
<p>如果第二个运算数的指数大于第一个运算数的指数那或许需要舍入。在这种情况下，舍入模式由给定 <code>rounding</code> 参数决定，其余的由给定 <code>context</code> 参数决定；如果参数都未给定，使用当前线程上下文的舍入模式。</p>
<p>每当结果的指数大于 <code>Emax</code> 或小于 <code>Etiny</code> 就会返回错误。</p>
</li>
<li><p><code>radix</code>()</p>
<p>返回 <code>Decimal(10)</code>，即 <code>Decimal</code> 类进行所有算术运算所用的数制（基数）。 这是为保持与规范描述的兼容性而加入的。</p>
</li>
<li><p><code>remainder_near</code>(<em>other</em>, <em>context=None</em>)</p>
<p>返回 <em>self</em> 除以 <em>other</em> 的余数。 这与 <code>self % other</code> 的区别在于所选择的余数要使其绝对值最小化。 更准确地说，返回值为 <code>self - n * other</code> 其中 <code>n</code> 是最接近 <code>self / other</code> 的实际值的整数，并且如果两个整数与实际值的差相等则会选择其中的偶数。</p>
<p>如果结果为零则其符号将为 <em>self</em> 的符号。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> Decimal<span class="token punctuation">(</span><span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">.</span>remainder_near<span class="token punctuation">(</span>Decimal<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
Decimal<span class="token punctuation">(</span><span class="token string">'-2'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> Decimal<span class="token punctuation">(</span><span class="token number">25</span><span class="token punctuation">)</span><span class="token punctuation">.</span>remainder_near<span class="token punctuation">(</span>Decimal<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
Decimal<span class="token punctuation">(</span><span class="token string">'5'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> Decimal<span class="token punctuation">(</span><span class="token number">35</span><span class="token punctuation">)</span><span class="token punctuation">.</span>remainder_near<span class="token punctuation">(</span>Decimal<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
Decimal<span class="token punctuation">(</span><span class="token string">'-5'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><code>rotate</code>(<em>other</em>, <em>context=None</em>)</p>
<p>返回对第一个操作数的数码按第二个操作数所指定的数量进行轮转的结果。 第二个操作数必须为 -precision 至 precision 精度范围内的整数。 第二个操作数的绝对值给出要轮转的位数。 如果第二个操作数为正值则向左轮转；否则向右轮转。 如有必要第一个操作数的系数会在左侧填充零以达到 precision 所指定的长度。 第一个操作数的符号和指数保持不变。</p>
</li>
<li><p><code>same_quantum</code>(<em>other</em>, <em>context=None</em>)</p>
<p>检测自身与 other 是否具有相同的指数或是否均为 <code>NaN</code>。</p>
<p>此操作不受上下文影响且静默：不更改任何标志且不执行舍入。 作为例外，如果无法准确转换第二个操作数，则C版本可能会引发InvalidOperation。</p>
</li>
<li><p><code>scaleb</code>(<em>other</em>, <em>context=None</em>)</p>
<p>返回第一个操作数使用第二个操作数对指数进行调整的结果。 等价于返回第一个操作数乘以 <code>10**other</code> 的结果。 第二个操作数必须为整数。</p>
</li>
<li><p><code>shift</code>(<em>other</em>, <em>context=None</em>)</p>
<p>返回第一个操作数的数码按第二个操作数所指定的数量进行移位的结果。 第二个操作数必须为 -precision 至 precision 范围内的整数。 第二个操作数的绝对值给出要移动的位数。 如果第二个操作数为正值则向左移位；否则向右移位。 移入系数的数码为零。 第一个操作数的符号和指数保持不变。</p>
</li>
<li><p><code>sqrt</code>(<em>context=None</em>)</p>
<p>返回参数的平方根精确到完整精度。</p>
</li>
<li><p><code>to_eng_string</code>(<em>context=None</em>)</p>
<p>转换为字符串，如果需要指数则会使用工程标注法。</p>
<p>工程标注法的指数是 3 的倍数。 这会在十进制位的左边保留至多 3 个数码，并可能要求添加一至两个末尾零。</p>
<p>例如，此方法会将 <code>Decimal('123E+1')</code> 转换为 <code>Decimal('1.23E+3')</code>。</p>
</li>
<li><p><code>to_integral</code>(<em>rounding=None</em>, <em>context=None</em>)</p>
<p>与 <code>to_integral_value()</code> 方法相同。 保留 <code>to_integral</code> 名称是为了与旧版本兼容。</p>
</li>
<li><p><code>to_integral_exact</code>(<em>rounding=None</em>, <em>context=None</em>)</p>
<p>舍入到最接近的整数，发出信号 <code>Inexact</code> 或者如果发生舍入则相应地发出信号 <code>Rounded</code>。 如果给出 <code>rounding</code> 形参则由其确定舍入模式，否则由给定的 <code>context</code> 来确定。 如果没有给定任何形参则会使用当前上下文的舍入模式。</p>
</li>
<li><p><code>to_integral_value</code>(<em>rounding=None</em>, <em>context=None</em>)</p>
<p>舍入到最接近的整数而不发出 <code>Inexact</code> 或 <code>Rounded</code> 信号。 如果给出 <em>rounding</em> 则会应用其所指定的舍入模式；否则使用所提供的 <em>context</em> 或当前上下文的舍入方法。</p>
</li>
</ul>
<h4 id="逻辑操作数"><a href="#逻辑操作数" class="headerlink" title="逻辑操作数"></a>逻辑操作数</h4><p><code>logical_and()</code>, <code>logical_invert()</code>, <code>logical_or()</code> 和 <code>logical_xor()</code> 方法期望其参数为 <em>逻辑操作数*。 *逻辑操作数</em> 是指数位与符号位均为零的 <code>Decimal</code> 实例，并且其数字位均为 <code>0</code> 或 <code>1</code>。</p>
<h3 id="上下文对象"><a href="#上下文对象" class="headerlink" title="上下文对象"></a>上下文对象</h3><p>上下文是算术运算所在的环境。 它们管理精度、设置舍入规则、确定将哪些信号视为异常，并限制指数的范围。</p>
<p>每个线程都有自己的当前上下文，可使用 <code>getcontext()</code> 和 <code>setcontext()</code> 函数来读取或修改：</p>
<p><code>decimal.getcontext</code>()</p>
<p>返回活动线程的当前上下文。</p>
<p><code>decimal.setcontext</code>(<em>c</em>)</p>
<p>将活动线程的当前上下文设为 <em>c</em>。</p>
<p>你也可以使用 <code>with</code> 语句和 <code>localcontext()</code> 函数来临时改变活动上下文。</p>
<p><code>decimal.localcontext</code>(<em>ctx=None</em>)</p>
<p>返回一个上下文管理器，它将在进入 with 语句时将活动线程的当前上下文设为 <em>ctx</em> 的一个副本并在退出 with 语句时恢复之前的上下文。 如果未指定上下文，则会使用当前上下文的一个副本。</p>
<p>例如，以下代码会将当前 decimal 精度设为 42 位，执行一个运算，然后自动恢复之前的上下文:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> decimal <span class="token keyword">import</span> localcontext
<span class="token keyword">with</span> localcontext<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">as</span> ctx<span class="token punctuation">:</span>
    ctx<span class="token punctuation">.</span>prec <span class="token operator">=</span> <span class="token number">42</span>   <span class="token comment" spellcheck="true"># Perform a high precision calculation</span>
    s <span class="token operator">=</span> calculate_something<span class="token punctuation">(</span><span class="token punctuation">)</span>
s <span class="token operator">=</span> <span class="token operator">+</span>s  <span class="token comment" spellcheck="true"># Round the final result back to the default precision</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>新的上下文也可使用下述的 <code>Context</code> 构造器来创建。 此外，模块还提供了三种预设的上下文:</p>
<p><em>class</em> <code>decimal.BasicContext</code></p>
<p>这是由通用十进制算术规范描述所定义的标准上下文。 精度设为九。 舍入设为 <code>ROUND_HALF_UP</code>。 清除所有旗标。 启用所有陷阱（视为异常），但 <code>Inexact</code>, <code>Rounded</code> 和 <code>Subnormal</code> 除外。</p>
<p>由于启用了许多陷阱，此上下文适用于进行调试。</p>
<p><em>class</em> <code>decimal.ExtendedContext</code></p>
<p>这是由通用十进制算术规范描述所定义的标准上下文。 精度设为九。 舍入设为 <code>ROUND_HALF_EVEN</code>。 清除所有旗标。 不启用任何陷阱（因此在计算期间不会引发异常）。</p>
<p>由于禁用了陷阱，此上下文适用于希望结果值为 <code>NaN</code> 或 <code>Infinity</code> 而不是引发异常的应用。 这允许应用在出现当其他情况下会中止程序的条件时仍能完成运行。</p>
<p><em>class</em> <code>decimal.DefaultContext</code></p>
<p>此上下文被 <code>Context</code> 构造器用作新上下文的原型。 改变一个字段（例如精度）的效果将是改变 <code>Context</code> 构造器所创建的新上下文的默认值。</p>
<p>此上下文最适用于多线程环境。 在线程开始前改变一个字段具有设置全系统默认值的效果。 不推荐在线程开始后改变字段，因为这会要求线程同步避免竞争条件。</p>
<p>在单线程环境中，最好完全不使用此上下文。 而是简单地电显式创建上下文，具体如下所述。</p>
<p>默认值为 <code>prec</code>=<code>28</code>, <code>rounding</code>=<code>ROUND_HALF_EVEN</code>，并为 <code>Overflow</code>, <code>InvalidOperation</code> 和 <code>DivisionByZero</code> 启用陷阱。</p>
<p>在已提供的三种上下文之外，还可以使用 <code>Context</code> 构造器创建新的上下文。</p>
<p><em>class</em> <code>decimal.Context</code>(<em>prec=None</em>, <em>rounding=None</em>, <em>Emin=None</em>, <em>Emax=None</em>, <em>capitals=None</em>, <em>clamp=None</em>, <em>flags=None</em>, <em>traps=None</em>)</p>
<p>创建一个新上下文。 如果某个字段未指定或为 <code>None</code>，则从 <code>DefaultContext</code> 拷贝默认值。 如果 <em>flags</em> 字段未指定或为 <code>None</code>，则清空所有旗标。</p>
<p><em>prec</em> 为一个 [<code>1</code>, <code>MAX_PREC</code>] 范围内的整数，用于设置该上下文中算术运算的精度。</p>
<p><em>rounding</em> 选项应为 Rounding Modes 小节中列出的常量之一。</p>
<p><em>traps</em> 和 <em>flags</em> 字段列出要设置的任何信号。 通常，新上下文应当只设置 traps 而让 flags 为空。</p>
<p><em>Emin</em> 和 <em>Emax</em> 字段给定指数所允许的外部上限。 <em>Emin</em> 必须在 [<code>MIN_EMIN</code>, <code>0</code>] 范围内，<em>Emax</em> 在 [<code>0</code>, <code>MAX_EMAX</code>] 范围内。</p>
<p><em>capitals</em> 字段为 <code>0</code> 或 <code>1</code> (默认值)。 如果设为 <code>1</code>，指数将附带打印大写的 <code>E</code>；其他情况则将使用小写的 <code>e</code>: <code>Decimal('6.02e+23')</code>。</p>
<p><em>clamp</em> 字段为 <code>0</code> (默认值) 或 <code>1</code>。 如果设为 <code>1</code>，则 <code>Decimal</code> 实例的指数 <code>e</code> 的表示范围在此上下文中将严格限制为 <code>Emin - prec + 1 &lt;= e &lt;= Emax - prec + 1</code>。 如果 <em>clamp</em> 为 <code>0</code> 则将适用较弱的条件: <code>Decimal</code> 实例调整后的指数最大值为 <code>Emax</code>。 当 <em>clamp</em> 为 <code>1</code> 时，一个较大的普通数值将在可能的情况下减小其指数并为其系统添加相应数量的零，以便符合指数值限制；这可以保持数字值但会丢失有效末尾零的信息。 例如:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> Context<span class="token punctuation">(</span>prec<span class="token operator">=</span><span class="token number">6</span><span class="token punctuation">,</span> Emax<span class="token operator">=</span><span class="token number">999</span><span class="token punctuation">,</span> clamp<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span>create_decimal<span class="token punctuation">(</span><span class="token string">'1.23e999'</span><span class="token punctuation">)</span>
Decimal<span class="token punctuation">(</span><span class="token string">'1.23000E+999'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><em>clamp</em> 值为 <code>1</code> 时即允许与在 IEEE 754 中描述的固定宽度十进制交换格式保持兼容性。</p>
<p><code>Context</code> 类定义了几种通用方法以及大量直接在给定上下文中进行算术运算的方法。 此外，对于上述的每种 <code>Decimal</code> 方法（不包括 <code>adjusted()</code> 和 <code>as_tuple()</code> 方法）都有一个相应的 <code>Context</code> 方法。 例如，对于一个 <code>Context</code> 的实例 <code>C</code> 和 <code>Decimal</code> 的实例 <code>x</code>，<code>C.exp(x)</code> 就等价于 <code>x.exp(context=C)</code>。 每个 <code>Context</code> 方法都接受一个 Python 整数（即 <code>int</code> 的实例）在任何接受 Decimal 的实例的地方使用。</p>
<ul>
<li><p><code>clear_flags</code>()</p>
<p>将所有旗标重置为 <code>0</code>。</p>
</li>
<li><p><code>clear_traps</code>()</p>
<p>将所有陷阱重置为零 <code>0</code>。</p>
<p>3.3 新版功能.</p>
</li>
<li><p><code>copy</code>()</p>
<p>返回上下文的一个副本。</p>
</li>
<li><p><code>copy_decimal</code>(<em>num</em>)</p>
<p>返回 Decimal 实例 num 的一个副本。</p>
</li>
<li><p><code>create_decimal</code>(<em>num</em>)</p>
<p>基于 <em>num</em> 创建一个新 Decimal 实例但使用 <em>self</em> 作为上下文。 与 <code>Decimal</code> 构造器不同，该上下文的精度、舍入方法、旗标和陷阱会被应用于转换过程。</p>
<p>此方法很有用处，因为常量往往被给予高于应用所需的精度。 另一个好处在于立即执行舍入可以消除超出当前精度的数位所导致的意外效果。 在下面的示例中，使用未舍入的输入意味着在总和中添加零会改变结果：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> getcontext<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>prec <span class="token operator">=</span> <span class="token number">3</span>
<span class="token operator">>></span><span class="token operator">></span> Decimal<span class="token punctuation">(</span><span class="token string">'3.4445'</span><span class="token punctuation">)</span> <span class="token operator">+</span> Decimal<span class="token punctuation">(</span><span class="token string">'1.0023'</span><span class="token punctuation">)</span>
Decimal<span class="token punctuation">(</span><span class="token string">'4.45'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> Decimal<span class="token punctuation">(</span><span class="token string">'3.4445'</span><span class="token punctuation">)</span> <span class="token operator">+</span> Decimal<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span> Decimal<span class="token punctuation">(</span><span class="token string">'1.0023'</span><span class="token punctuation">)</span>
Decimal<span class="token punctuation">(</span><span class="token string">'4.44'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>此方法实现了 IBM 规格描述中的转换为数字操作。 如果参数为字符串，则不允许有开头或末尾的空格或下划线。</p>
</li>
<li><p><code>create_decimal_from_float</code>(<em>f</em>)</p>
<p>基于浮点数 <em>f</em> 创建一个新的 Decimal 实例，但会使用 <em>self</em> 作为上下文来执行舍入。 与 <code>Decimal.from_float()</code> 类方法不同，上下文的精度、舍入方法、旗标和陷阱会应用到转换中。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> context <span class="token operator">=</span> Context<span class="token punctuation">(</span>prec<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">,</span> rounding<span class="token operator">=</span>ROUND_DOWN<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> context<span class="token punctuation">.</span>create_decimal_from_float<span class="token punctuation">(</span>math<span class="token punctuation">.</span>pi<span class="token punctuation">)</span>
Decimal<span class="token punctuation">(</span><span class="token string">'3.1415'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> context <span class="token operator">=</span> Context<span class="token punctuation">(</span>prec<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">,</span> traps<span class="token operator">=</span><span class="token punctuation">[</span>Inexact<span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> context<span class="token punctuation">.</span>create_decimal_from_float<span class="token punctuation">(</span>math<span class="token punctuation">.</span>pi<span class="token punctuation">)</span>
Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
decimal<span class="token punctuation">.</span>Inexact<span class="token punctuation">:</span> None<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>3.1 新版功能.</p>
</li>
<li><p><code>Etiny</code>()</p>
<p>返回一个等于 <code>Emin - prec + 1</code> 的值即次标准化结果中的最小指数值。 当发生向下溢出时，指数会设为 <code>Etiny</code>。</p>
</li>
<li><p><code>Etop</code>()</p>
<p>返回一个等于 <code>Emax - prec + 1</code> 的值。</p>
</li>
</ul>
<p>使用 decimal 的通常方式是创建 <code>Decimal</code> 实例然后对其应用算术运算,这些运算发生在活动线程的当前上下文中。 一种替代方式则是使用上下文的方法在特定上下文中进行计算。 这些方法类似于 <code>Decimal</code> 类的方法，在此仅简单地重新列出。</p>
<ul>
<li><p><code>abs</code>(<em>x</em>)</p>
<p>返回 <em>x</em> 的绝对值。</p>
</li>
<li><p><code>add</code>(<em>x</em>, <em>y</em>)</p>
<p>返回 <em>x</em> 与 <em>y</em> 的和。</p>
</li>
<li><p><code>canonical</code>(<em>x</em>)</p>
<p>返回相同的 Decimal 对象 <em>x</em>。</p>
</li>
<li><p><code>compare</code>(<em>x</em>, <em>y</em>)</p>
<p>对 <em>x</em> 与 <em>y</em> 进行数值比较。</p>
</li>
<li><p><code>compare_signal</code>(<em>x</em>, <em>y</em>)</p>
<p>对两个操作数进行数值比较。</p>
</li>
<li><p><code>compare_total</code>(<em>x</em>, <em>y</em>)</p>
<p>对两个操作数使用其抽象表示进行比较。</p>
</li>
<li><p><code>compare_total_mag</code>(<em>x</em>, <em>y</em>)</p>
<p>对两个操作数使用其抽象表示进行比较，忽略符号。</p>
</li>
<li><p><code>copy_abs</code>(<em>x</em>)</p>
<p>返回 <em>x</em> 的副本，符号设为 0。</p>
</li>
<li><p><code>copy_negate</code>(<em>x</em>)</p>
<p>返回 <em>x</em> 的副本，符号取反。</p>
</li>
<li><p><code>copy_sign</code>(<em>x</em>, <em>y</em>)</p>
<p>从 <em>y</em> 拷贝符号至 <em>x</em>。</p>
</li>
<li><p><code>divide</code>(<em>x</em>, <em>y</em>)</p>
<p>返回 <em>x</em> 除以 <em>y</em> 的结果。</p>
</li>
<li><p><code>divide_int</code>(<em>x</em>, <em>y</em>)</p>
<p>返回 <em>x</em> 除以 <em>y</em> 的结果，截短为整数。</p>
</li>
<li><p><code>divmod</code>(<em>x</em>, <em>y</em>)</p>
<p>两个数字相除并返回结果的整数部分。</p>
</li>
<li><p><code>exp</code>(<em>x</em>)</p>
<p>返回 e ** x。</p>
</li>
<li><p><code>fma</code>(<em>x</em>, <em>y</em>, <em>z</em>)</p>
<p>返回 <em>x</em> 乘以 <em>y</em> 再加 <em>z</em> 的结果。</p>
</li>
<li><p><code>is_canonical</code>(<em>x</em>)</p>
<p>如果 <em>x</em> 是规范的则返回 <code>True</code>；否则返回 <code>False</code>。</p>
</li>
<li><p><code>is_finite</code>(<em>x</em>)</p>
<p>如果 <em>x</em> 为有限的则返回<code>True</code>；否则返回 <code>False</code>。</p>
</li>
<li><p><code>is_infinite</code>(<em>x</em>)</p>
<p>如果 <em>x</em> 是无限的则返回 <code>True</code>；否则返回 <code>False</code>。</p>
</li>
<li><p><code>is_nan</code>(<em>x</em>)</p>
<p>如果 <em>x</em> 是 qNaN 或 sNaN 则返回 <code>True</code>；否则返回 <code>False</code>。</p>
</li>
<li><p><code>is_normal</code>(<em>x</em>)</p>
<p>如果 <em>x</em> 是标准数则返回 <code>True</code>；否则返回 <code>False</code>。</p>
</li>
<li><p><code>is_qnan</code>(<em>x</em>)</p>
<p>如果 <em>x</em> 是静默 NaN 则返回 <code>True</code>；否则返回 <code>False</code>。</p>
</li>
<li><p><code>is_signed</code>(<em>x</em>)</p>
<p><em>x</em> 是负数则返回 <code>True</code>；否则返回 <code>False</code>。</p>
</li>
<li><p><code>is_snan</code>(<em>x</em>)</p>
<p>如果 <em>x</em> 是显式 NaN 则返回 <code>True</code>；否则返回 <code>False</code>。</p>
</li>
<li><p><code>is_subnormal</code>(<em>x</em>)</p>
<p>如果 <em>x</em> 是次标准数则返回 <code>True</code>；否则返回 <code>False</code>。</p>
</li>
<li><p><code>is_zero</code>(<em>x</em>)</p>
<p>如果 <em>x</em> 为零则返回 <code>True</code>；否则返回 <code>False</code>。</p>
</li>
<li><p><code>ln</code>(<em>x</em>)</p>
<p>返回 <em>x</em> 的自然对数（以 e 为底）。</p>
</li>
<li><p><code>log10</code>(<em>x</em>)</p>
<p>返回 <em>x</em> 的以 10 为底的对数。</p>
</li>
<li><p><code>logb</code>(<em>x</em>)</p>
<p>返回操作数的 MSD 等级的指数。</p>
</li>
<li><p><code>logical_and</code>(<em>x</em>, <em>y</em>)</p>
<p>在操作数的每个数位间应用逻辑运算 <em>and</em>。</p>
</li>
<li><p><code>logical_invert</code>(<em>x</em>)</p>
<p>反转 <em>x</em> 中的所有数位。</p>
</li>
<li><p><code>logical_or</code>(<em>x</em>, <em>y</em>)</p>
<p>在操作数的每个数位间应用逻辑运算 <em>or</em>。</p>
</li>
<li><p><code>logical_xor</code>(<em>x</em>, <em>y</em>)</p>
<p>在操作数的每个数位间应用逻辑运算 <em>xor</em>。</p>
</li>
<li><p><code>max</code>(<em>x</em>, <em>y</em>)</p>
<p>对两个值执行数字比较并返回其中的最大值。</p>
</li>
<li><p><code>max_mag</code>(<em>x</em>, <em>y</em>)</p>
<p>对两个值执行忽略正负号的数字比较。</p>
</li>
<li><p><code>min</code>(<em>x</em>, <em>y</em>)</p>
<p>对两个值执行数字比较并返回其中的最小值。</p>
</li>
<li><p><code>min_mag</code>(<em>x</em>, <em>y</em>)</p>
<p>对两个值执行忽略正负号的数字比较。</p>
</li>
<li><p><code>minus</code>(<em>x</em>)</p>
<p>对应于 Python 中的单目前缀取负运算符执行取负操作。</p>
</li>
<li><p><code>multiply</code>(<em>x</em>, <em>y</em>)</p>
<p>返回 <em>x</em> 和 <em>y</em> 的积。</p>
</li>
<li><p><code>next_minus</code>(<em>x</em>)</p>
<p>返回小于 <em>x</em> 的最大数字表示形式。</p>
</li>
<li><p><code>next_plus</code>(<em>x</em>)</p>
<p>返回大于 <em>x</em> 的最小数字表示形式。</p>
</li>
<li><p><code>next_toward</code>(<em>x</em>, <em>y</em>)</p>
<p>返回 <em>x</em> 趋向于 <em>y</em> 的最接近的数字。</p>
</li>
<li><p><code>normalize</code>(<em>x</em>)</p>
<p>将 <em>x</em> 改写为最简形式。</p>
</li>
<li><p><code>number_class</code>(<em>x</em>)</p>
<p>返回 <em>x</em> 的类的表示。</p>
</li>
<li><p><code>plus</code>(<em>x</em>)</p>
<p>对应于 Python 中的单目前缀取正运算符执行取正操作。 此操作将应用上下文精度和舍入，因此它 <em>不是</em> 标识运算。</p>
</li>
<li><p><code>power</code>(<em>x</em>, <em>y</em>, <em>modulo=None</em>)</p>
<p>返回 <code>x</code> 的 <code>y</code> 次方，如果给出了模数 <code>modulo</code> 则取其余数。</p>
<p>如为两个参数则计算 <code>x**y</code>。 如果 <code>x</code> 为负值则 <code>y</code> 必须为整数。 除非 <code>y</code> 为整数且结果为有限值并可在 ‘precision’ 位内精确表示否则结果将是不精确的。 上下文的舍入模式将被使用。 结果在 Python 版中总是会被正确地舍入。</p>
<p><code>Decimal(0) ** Decimal(0)</code> 结果为 <code>InvalidOperation</code>，而如果 <code>InvalidOperation</code> 未被捕获，则结果为 <code>Decimal('NaN')</code>。</p>
<p>在 3.3 版更改: C 模块计算 <code>power()</code> 时会使用已正确舍入的 <code>exp()</code> 和 <code>ln()</code> 函数。 结果是经过良好定义的，但仅限于“几乎总是正确地舍入”。</p>
<p>带有三个参数时，计算 <code>(x**y) % modulo</code>。 对于三个参数的形式，参数将会应用以下限制：</p>
<blockquote>
<ul>
<li>三个参数必须都是整数</li>
<li><code>y</code> 必须是非负数</li>
<li><code>x</code> 或 <code>y</code> 至少有一个不为零</li>
<li><code>modulo</code> 必须不为零且至多有 ‘precision’ 位</li>
</ul>
</blockquote>
<p>来自 <code>Context.power(x, y, modulo)</code> 的结果值等于使用无限精度计算 <code>(x**y) % modulo</code> 所得到的值，但其计算过程更高效。 结果的指数为零，无论 <code>x</code>, <code>y</code> 和 <code>modulo</code> 的指数是多少。 结果值总是完全精确的。</p>
</li>
<li><p><code>quantize</code>(<em>x</em>, <em>y</em>)</p>
<p>返回的值等于 <em>x</em> (舍入后)，并且指数为 <em>y</em>。</p>
</li>
<li><p><code>radix</code>()</p>
<p>恰好返回 10，因为这是 Decimal 对象 :)</p>
</li>
<li><p><code>remainder</code>(<em>x</em>, <em>y</em>)</p>
<p>返回整除所得到的余数。</p>
<p>结果的符号，如果不为零，则与原始除数的符号相同。</p>
</li>
<li><p><code>remainder_near</code>(<em>x</em>, <em>y</em>)</p>
<p>返回 <code>x - y * n</code>，其中 <em>n</em> 为最接近 <code>x / y</code> 实际值的整数（如结果为 0 则其符号将与 <em>x</em> 的符号相同）。</p>
</li>
<li><p><code>rotate</code>(<em>x</em>, <em>y</em>)</p>
<p>返回 <em>x</em> 翻转 <em>y</em> 次的副本。</p>
</li>
<li><p><code>same_quantum</code>(<em>x</em>, <em>y</em>)</p>
<p>如果两个操作数具有相同的指数则返回 <code>True</code>。</p>
</li>
<li><p><code>scaleb</code>(<em>x</em>, <em>y</em>)</p>
<p>返回第一个操作数添加第二个值的指数后的结果。</p>
</li>
<li><p><code>shift</code>(<em>x</em>, <em>y</em>)</p>
<p>返回 <em>x</em> 变换 <em>y</em> 次的副本。</p>
</li>
<li><p><code>sqrt</code>(<em>x</em>)</p>
<p>非负数基于上下文精度的平方根。</p>
</li>
<li><p><code>subtract</code>(<em>x</em>, <em>y</em>)</p>
<p>返回 <em>x</em> 和 <em>y</em> 的差。</p>
</li>
<li><p><code>to_eng_string</code>(<em>x</em>)</p>
<p>转换为字符串，如果需要指数则会使用工程标注法。</p>
<p>工程标注法的指数是 3 的倍数。 这会在十进制位的左边保留至多 3 个数码，并可能要求添加一至两个末尾零。</p>
</li>
<li><p><code>to_integral_exact</code>(<em>x</em>)</p>
<p>舍入到一个整数。</p>
</li>
<li><p><code>to_sci_string</code>(<em>x</em>)</p>
<p>使用科学计数法将一个数字转换为字符串。</p>
</li>
</ul>
<h3 id="常量-3"><a href="#常量-3" class="headerlink" title="常量"></a>常量</h3><p>本节中的常量仅与 C 模块相关。 它们也被包含在纯 Python 版本以保持兼容性。</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">32位</th>
<th align="left">64位</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>decimal.``MAX_PREC</code></td>
<td align="left"><code>425000000</code></td>
<td align="left"><code>999999999999999999</code></td>
</tr>
<tr>
<td align="left"><code>decimal.``MAX_EMAX</code></td>
<td align="left"><code>425000000</code></td>
<td align="left"><code>999999999999999999</code></td>
</tr>
<tr>
<td align="left"><code>decimal.``MIN_EMIN</code></td>
<td align="left"><code>-425000000</code></td>
<td align="left"><code>-999999999999999999</code></td>
</tr>
<tr>
<td align="left"><code>decimal.``MIN_ETINY</code></td>
<td align="left"><code>-849999999</code></td>
<td align="left"><code>-1999999999999999997</code></td>
</tr>
</tbody></table>
<pre><code>decimal.HAVE_THREADS</code></pre><p>该值为 <code>True</code>。 已弃用，因为 Python 现在总是启用线程。</p>
<p>3.9 版后已移除.</p>
<pre><code>decimal.HAVE_CONTEXTVAR</code></pre><p>默认值为 <code>True</code>。 如果 Python 编译版本 <code>使用了 --without-decimal-contextvar 选项来配置</code>，则 C 版本会使用线程局部而非协程局部上下文并且该值为 <code>False</code>。 这在某些嵌套上下文场景中将会稍快一些。</p>
<p>3.9 新版功能: 向下移植到 3.7 和 3.8。</p>
<h3 id="舍入模式"><a href="#舍入模式" class="headerlink" title="舍入模式"></a>舍入模式</h3><pre><code>decimal.ROUND_CEILING</code></pre><p>舍入方向为 <code>Infinity</code>。</p>
<pre><code>decimal.ROUND_DOWN</code></pre><p>舍入方向为零。</p>
<pre><code>decimal.ROUND_FLOOR</code></pre><p>舍入方向为 <code>-Infinity</code>。</p>
<pre><code>decimal.ROUND_HALF_DOWN</code></pre><p>舍入到最接近的数，同样接近则舍入方向为零。</p>
<pre><code>decimal.ROUND_HALF_EVEN</code></pre><p>舍入到最接近的数，同样接近则舍入到最接近的偶数。</p>
<pre><code>decimal.ROUND_HALF_UP</code></pre><p>舍入到最接近的数，同样接近则舍入到零的反方向。</p>
<pre><code>decimal.ROUND_UP</code></pre><p>舍入到零的反方向。</p>
<pre><code>decimal.ROUND_05UP</code></pre><p>如果最后一位朝零的方向舍入后为 0 或 5 则舍入到零的反方向；否则舍入方向为零。</p>
<h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><p>信号代表在计算期间引发的条件。 每个信号对应于一个上下文旗标和一个上下文陷阱启用器。</p>
<p>上下文旗标将在遇到特定条件时被设定。 在完成计算之后，将为了获得信息而检测旗标（例如确定计算是否精确）。 在检测旗标后，请确保在开始下一次计算之前清除所有旗标。</p>
<p>如果为信号设定了上下文的陷阱启用器，则条件会导致特定的 Python 异常被引发。 举例来说，如果设定了 <code>DivisionByZero</code> 陷阱，则当遇到此条件时就将引发 <code>DivisionByZero</code> 异常。</p>
<p><em>class</em> <code>decimal.Clamped</code></p>
<p>修改一个指数以符合表示限制。</p>
<p>通常，限位将在一个指数超出上下文的 <code>Emin</code> 和 <code>Emax</code> 限制时发生。 在可能的情况下，会通过给系数添加零来将指数缩减至符合限制。</p>
<p><em>class</em> <code>decimal.DecimalException</code></p>
<p>其他信号的基类，并且也是 <code>ArithmeticError</code> 的一个子类。</p>
<p><em>class</em> <code>decimal.DivisionByZero</code></p>
<p>非无限数被零除的信号。</p>
<p>可在除法、取余队法或对一个数求负数次幂时发生。 如果此信号未被陷阱捕获，则返回 <code>Infinity</code> 或 <code>-Infinity</code> 并且由对计算的输入来确定正负符号。</p>
<p><em>class</em> <code>decimal.Inexact</code></p>
<p>表明发生了舍入且结果是不精确的。</p>
<p>有非零数位在舍入期间被丢弃的信号。 舍入结果将被返回。 此信号旗标或陷阱被用于检测结果不精确的情况。</p>
<p><em>class</em> <code>decimal.InvalidOperation</code></p>
<p>执行了一个无效的操作。</p>
<p>表明请求了一个无意义的操作。 如未被陷阱捕获则返回 <code>NaN</code>。 可能的原因包括:</p>
<pre class="line-numbers language-python"><code class="language-python">Infinity <span class="token operator">-</span> Infinity
<span class="token number">0</span> <span class="token operator">*</span> Infinity
Infinity <span class="token operator">/</span> Infinity
x <span class="token operator">%</span> <span class="token number">0</span>
Infinity <span class="token operator">%</span> x
sqrt<span class="token punctuation">(</span><span class="token operator">-</span>x<span class="token punctuation">)</span> <span class="token operator">and</span> x <span class="token operator">></span> <span class="token number">0</span>
<span class="token number">0</span> <span class="token operator">**</span> <span class="token number">0</span>
x <span class="token operator">**</span> <span class="token punctuation">(</span>non<span class="token operator">-</span>integer<span class="token punctuation">)</span>
x <span class="token operator">**</span> Infinity<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><em>class</em> <code>decimal.Overflow</code></p>
<p>数值的溢出。</p>
<p>表明在发生舍入之后的指数大于 <code>Emax</code>。 如果未被陷阱捕获，则结果将取决于舍入模式，或者向下舍入为最大的可表示有限数，或者向上舍入为 <code>Infinity</code>。 无论哪种情况，都将引发 <code>Inexact</code> 和 <code>Rounded</code> 信号。</p>
<p><em>class</em> <code>decimal.Rounded</code></p>
<p>发生了舍入，但或许并没有信息丢失。</p>
<p>一旦舍入丢弃了数位就会发出此信号；即使被丢弃的数位是零 (例如将 <code>5.00</code> 舍入为 <code>5.0</code>)。 如果未被陷阱捕获，则不经修改地返回结果。 此信号用于检测有效位数的丢弃。</p>
<p><em>class</em> <code>decimal.Subnormal</code></p>
<p>在舍入之前指数低于 <code>Emin</code>。</p>
<p>当操作结果是次标准数（即指数过小）时就会发出此信号。 如果未被陷阱捕获，则不经修改过返回结果。</p>
<p><em>class</em> <code>decimal.Underflow</code></p>
<p>数字向下溢出导致结果舍入到零。</p>
<p>当一个次标准数结果通过舍入转为零时就会发出此信号。 同时还将引发 <code>Inexact</code> 和 <code>Subnormal</code> 信号。</p>
<p><em>class</em> <code>decimal.FloatOperation</code></p>
<p>为 float 和 Decimal 的混合启用更严格的语义。</p>
<p>如果信号未被捕获（默认），则在 <code>Decimal</code> 构造器、<code>create_decimal()</code> 和所有比较运算中允许 float 和 Decimal 的混合。 转换和比较都是完全精确的。 发生的任何混合运算都将通过在上下文旗标中设置 <code>FloatOperation</code> 来静默地记录。 通过 <code>from_float()</code> 或 <code>create_decimal_from_float()</code> 进行显式转换则不会设置旗标。</p>
<p>在其他情况下（即信号被捕获），则只静默执行相等性比较和显式转换。 所有其他混合运算都将引发 <code>FloatOperation</code>。</p>
<p>以下表格总结了信号的层级结构:</p>
<pre><code>exceptions.ArithmeticError(exceptions.Exception)
    DecimalException
        Clamped
        DivisionByZero(DecimalException, exceptions.ZeroDivisionError)
        Inexact
            Overflow(Inexact, Rounded)
            Underflow(Inexact, Rounded, Subnormal)
        InvalidOperation
        Rounded
        Subnormal
        FloatOperation(DecimalException, exceptions.TypeError)</code></pre><h3 id="浮点数说明"><a href="#浮点数说明" class="headerlink" title="浮点数说明"></a>浮点数说明</h3><h4 id="通过提升精度来解决舍入错误"><a href="#通过提升精度来解决舍入错误" class="headerlink" title="通过提升精度来解决舍入错误"></a>通过提升精度来解决舍入错误</h4><p>使用十进制浮点数可以消除十进制表示错误（即能够完全精确地表示 <code>0.1</code> 这样的数）；然而，某些运算在非零数位超出给定的精度时仍然可能导致舍入错误。</p>
<p>舍入错误的影响可能因接近相互抵销的加减运算被放大从而导致丢失有效位。 Knuth 提供了两个指导性示例，其中出现了精度不足的浮点算术舍入，导致加法的交换律和分配律被打破：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Examples from Seminumerical Algorithms, Section 4.2.2.</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> decimal <span class="token keyword">import</span> Decimal<span class="token punctuation">,</span> getcontext
<span class="token operator">>></span><span class="token operator">></span> getcontext<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>prec <span class="token operator">=</span> <span class="token number">8</span>
<span class="token operator">>></span><span class="token operator">></span> u<span class="token punctuation">,</span> v<span class="token punctuation">,</span> w <span class="token operator">=</span> Decimal<span class="token punctuation">(</span><span class="token number">11111113</span><span class="token punctuation">)</span><span class="token punctuation">,</span> Decimal<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">11111111</span><span class="token punctuation">)</span><span class="token punctuation">,</span> Decimal<span class="token punctuation">(</span><span class="token string">'7.51111111'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token punctuation">(</span>u <span class="token operator">+</span> v<span class="token punctuation">)</span> <span class="token operator">+</span> w
Decimal<span class="token punctuation">(</span><span class="token string">'9.5111111'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> u <span class="token operator">+</span> <span class="token punctuation">(</span>v <span class="token operator">+</span> w<span class="token punctuation">)</span>
Decimal<span class="token punctuation">(</span><span class="token string">'10'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> u<span class="token punctuation">,</span> v<span class="token punctuation">,</span> w <span class="token operator">=</span> Decimal<span class="token punctuation">(</span><span class="token number">20000</span><span class="token punctuation">)</span><span class="token punctuation">,</span> Decimal<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">,</span> Decimal<span class="token punctuation">(</span><span class="token string">'6.0000003'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token punctuation">(</span>u<span class="token operator">*</span>v<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span>u<span class="token operator">*</span>w<span class="token punctuation">)</span>
Decimal<span class="token punctuation">(</span><span class="token string">'0.01'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> u <span class="token operator">*</span> <span class="token punctuation">(</span>v<span class="token operator">+</span>w<span class="token punctuation">)</span>
Decimal<span class="token punctuation">(</span><span class="token string">'0.0060000'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>decimal</code> 模块则可以通过充分地扩展精度来避免有效位的丢失：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> getcontext<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>prec <span class="token operator">=</span> <span class="token number">20</span>
<span class="token operator">>></span><span class="token operator">></span> u<span class="token punctuation">,</span> v<span class="token punctuation">,</span> w <span class="token operator">=</span> Decimal<span class="token punctuation">(</span><span class="token number">11111113</span><span class="token punctuation">)</span><span class="token punctuation">,</span> Decimal<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">11111111</span><span class="token punctuation">)</span><span class="token punctuation">,</span> Decimal<span class="token punctuation">(</span><span class="token string">'7.51111111'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token punctuation">(</span>u <span class="token operator">+</span> v<span class="token punctuation">)</span> <span class="token operator">+</span> w
Decimal<span class="token punctuation">(</span><span class="token string">'9.51111111'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> u <span class="token operator">+</span> <span class="token punctuation">(</span>v <span class="token operator">+</span> w<span class="token punctuation">)</span>
Decimal<span class="token punctuation">(</span><span class="token string">'9.51111111'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span>
<span class="token operator">>></span><span class="token operator">></span> u<span class="token punctuation">,</span> v<span class="token punctuation">,</span> w <span class="token operator">=</span> Decimal<span class="token punctuation">(</span><span class="token number">20000</span><span class="token punctuation">)</span><span class="token punctuation">,</span> Decimal<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">,</span> Decimal<span class="token punctuation">(</span><span class="token string">'6.0000003'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token punctuation">(</span>u<span class="token operator">*</span>v<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span>u<span class="token operator">*</span>w<span class="token punctuation">)</span>
Decimal<span class="token punctuation">(</span><span class="token string">'0.0060000'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> u <span class="token operator">*</span> <span class="token punctuation">(</span>v<span class="token operator">+</span>w<span class="token punctuation">)</span>
Decimal<span class="token punctuation">(</span><span class="token string">'0.0060000'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="特殊的值"><a href="#特殊的值" class="headerlink" title="特殊的值"></a>特殊的值</h4><p><code>decimal</code> 模块的数字系统提供了一些特殊的值，包括 <code>NaN</code>, <code>sNaN</code>, <code>-Infinity</code>, <code>Infinity</code> 以及两种零值 <code>+0</code> 和 <code>-0</code>。</p>
<p>无穷大可以使用 <code>Decimal('Infinity')</code> 来构建。 它们也可以在不捕获 <code>DivisionByZero</code> 信号捕获时通过除以零来产生。 类似地，当不捕获 <code>Overflow</code> 信号时，也可以通过舍入到超出最大可表示数字限制的方式产生无穷大的结果。</p>
<p>无穷大是有符号的（仿射）并可用于算术运算，它们会被当作极其巨大的不确定数字来处理。 例如，无穷大加一个常量结果也将为无穷大。</p>
<p>某些不存在有效结果的运算将会返回 <code>NaN</code>，或者如果捕获了 <code>InvalidOperation</code> 信号则会引发一个异常。 例如，<code>0/0</code> 会返回 <code>NaN</code> 表示结果“不是一个数字”。 这样的 <code>NaN</code> 是静默产生的，并且在产生之后参与其它计算时总是会得到 <code>NaN</code> 的结果。 这种行为对于偶而缺少输入的各类计算都很有用处 —- 它允许在将特定结果标记为无效的同时让计算继续运行。</p>
<p>另一种变体形式是 <code>sNaN</code>，它在每次运算后会发出信号而不是保持静默。 当对于无效结果需要中断计算进行特别处理时，这是一个很有用的返回值。</p>
<p>Python 中比较运算符的行为在涉及 <code>NaN</code> 时可能会令人有点惊讶。 相等性检测在操作数中有静默型或信号型 <code>NaN</code> 时总是会返回 <code>False</code> (即使是执行 <code>Decimal('NaN')==Decimal('NaN')</code>)，而不等性检测总是会返回 <code>True</code>。 当尝试使用 <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code> 或 <code>&gt;=</code> 运算符中的任何一个来比较两个 Decimal 值时，如果运算数中有 <code>NaN</code> 则将引发 <code>InvalidOperation</code> 信号，如果此信号未被捕获则将返回 <code>False</code>。 请注意通用十进制算术规范并未规定直接比较行为；这些涉及 <code>NaN</code> 的比较规则来自于 IEEE 854 标准 (见第 5.7 节表 3)。 要确保严格符合标准，请改用 <code>compare()</code> 和 <code>compare-signal()</code> 方法。</p>
<p>有符号零值可以由向下溢出的运算产生。 它们保留符号是为了让运算结果能以更高的精度传递。 由于它们的大小为零，正零和负零会被视为相等，且它们的符号具有信息。</p>
<p>在这两个不相同但却相等的有符号零之外，还存在几种零的不同表示形式，它们的精度不同但值也都相等。 这需要一些时间来逐渐适应。 对于习惯了标准浮点表示形式的眼睛来说，以下运算返回等于零的值并不是显而易见的：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token number">1</span> <span class="token operator">/</span> Decimal<span class="token punctuation">(</span><span class="token string">'Infinity'</span><span class="token punctuation">)</span>
Decimal<span class="token punctuation">(</span><span class="token string">'0E-1000026'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h3 id="使用线程"><a href="#使用线程" class="headerlink" title="使用线程"></a>使用线程</h3><p><code>getcontext()</code> 函数会为每个线程访问不同的 <code>Context</code> 对象。 具有单独线程上下文意味着线程可以修改上下文 (例如 <code>getcontext().prec=10</code>) 而不影响其他线程。</p>
<p>类似的 <code>setcontext()</code> 会为当前上下文的目标自动赋值。</p>
<p>如果在调用 <code>setcontext()</code> 之前调用了 <code>getcontext()</code>，则 <code>getcontext()</code> 将自动创建一个新的上下文在当前线程中使用。</p>
<p>新的上下文拷贝自一个名为 <em>DefaultContext</em> 的原型上下文。 要控制默认值以便每个线程在应用运行期间都使用相同的值，可以直接修改 <em>DefaultContext</em> 对象。 这应当在任何线程启动 <em>之前</em> 完成以使得调用 <code>getcontext()</code> 的线程之间不会产生竞争条件。 例如:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Set applicationwide defaults for all threads about to be launched</span>
DefaultContext<span class="token punctuation">.</span>prec <span class="token operator">=</span> <span class="token number">12</span>
DefaultContext<span class="token punctuation">.</span>rounding <span class="token operator">=</span> ROUND_DOWN
DefaultContext<span class="token punctuation">.</span>traps <span class="token operator">=</span> ExtendedContext<span class="token punctuation">.</span>traps<span class="token punctuation">.</span>copy<span class="token punctuation">(</span><span class="token punctuation">)</span>
DefaultContext<span class="token punctuation">.</span>traps<span class="token punctuation">[</span>InvalidOperation<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>
setcontext<span class="token punctuation">(</span>DefaultContext<span class="token punctuation">)</span>
<span class="token comment" spellcheck="true"># Afterwards, the threads can be started</span>
t1<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>
t2<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>
t3<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>
 <span class="token punctuation">.</span> <span class="token punctuation">.</span> <span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="例程"><a href="#例程" class="headerlink" title="例程"></a>例程</h3><p>以下是一些用作工具函数的例程，它们演示了使用 <code>Decimal</code> 类的各种方式:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">moneyfmt</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> places<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span> curr<span class="token operator">=</span><span class="token string">''</span><span class="token punctuation">,</span> sep<span class="token operator">=</span><span class="token string">','</span><span class="token punctuation">,</span> dp<span class="token operator">=</span><span class="token string">'.'</span><span class="token punctuation">,</span>
             pos<span class="token operator">=</span><span class="token string">''</span><span class="token punctuation">,</span> neg<span class="token operator">=</span><span class="token string">'-'</span><span class="token punctuation">,</span> trailneg<span class="token operator">=</span><span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">"""Convert Decimal to a money formatted string.
    places:  required number of places after the decimal point
    curr:    optional currency symbol before the sign (may be blank)
    sep:     optional grouping separator (comma, period, space, or blank)
    dp:      decimal point indicator (comma or period)
             only specify as blank when places is zero
    pos:     optional sign for positive numbers: '+', space or blank
    neg:     optional sign for negative numbers: '-', '(', space or blank
    trailneg:optional trailing minus indicator:  '-', ')', space or blank
    >>> d = Decimal('-1234567.8901')
    >>> moneyfmt(d, curr='$')
    '-$1,234,567.89'
    >>> moneyfmt(d, places=0, sep='.', dp='', neg='', trailneg='-')
    '1.234.568-'
    >>> moneyfmt(d, curr='$', neg='(', trailneg=')')
    '($1,234,567.89)'
    >>> moneyfmt(Decimal(123456789), sep=' ')
    '123 456 789.00'
    >>> moneyfmt(Decimal('-0.02'), neg='&lt;', trailneg='>')
    '&lt;0.02>'
    """</span>
    q <span class="token operator">=</span> Decimal<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">**</span> <span class="token operator">-</span>places      <span class="token comment" spellcheck="true"># 2 places --> '0.01'</span>
    sign<span class="token punctuation">,</span> digits<span class="token punctuation">,</span> exp <span class="token operator">=</span> value<span class="token punctuation">.</span>quantize<span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">.</span>as_tuple<span class="token punctuation">(</span><span class="token punctuation">)</span>
    result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    digits <span class="token operator">=</span> list<span class="token punctuation">(</span>map<span class="token punctuation">(</span>str<span class="token punctuation">,</span> digits<span class="token punctuation">)</span><span class="token punctuation">)</span>
    build<span class="token punctuation">,</span> next <span class="token operator">=</span> result<span class="token punctuation">.</span>append<span class="token punctuation">,</span> digits<span class="token punctuation">.</span>pop
    <span class="token keyword">if</span> sign<span class="token punctuation">:</span>
        build<span class="token punctuation">(</span>trailneg<span class="token punctuation">)</span>
    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>places<span class="token punctuation">)</span><span class="token punctuation">:</span>
        build<span class="token punctuation">(</span>next<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">if</span> digits <span class="token keyword">else</span> <span class="token string">'0'</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> places<span class="token punctuation">:</span>
        build<span class="token punctuation">(</span>dp<span class="token punctuation">)</span>
    <span class="token keyword">if</span> <span class="token operator">not</span> digits<span class="token punctuation">:</span>
        build<span class="token punctuation">(</span><span class="token string">'0'</span><span class="token punctuation">)</span>
    i <span class="token operator">=</span> <span class="token number">0</span>
    <span class="token keyword">while</span> digits<span class="token punctuation">:</span>
        build<span class="token punctuation">(</span>next<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        i <span class="token operator">+=</span> <span class="token number">1</span>
        <span class="token keyword">if</span> i <span class="token operator">==</span> <span class="token number">3</span> <span class="token operator">and</span> digits<span class="token punctuation">:</span>
            i <span class="token operator">=</span> <span class="token number">0</span>
            build<span class="token punctuation">(</span>sep<span class="token punctuation">)</span>
    build<span class="token punctuation">(</span>curr<span class="token punctuation">)</span>
    build<span class="token punctuation">(</span>neg <span class="token keyword">if</span> sign <span class="token keyword">else</span> pos<span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token string">''</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>reversed<span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">pi</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">"""Compute Pi to the current precision.
    >>> print(pi())
    3.141592653589793238462643383
    """</span>
    getcontext<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>prec <span class="token operator">+=</span> <span class="token number">2</span>  <span class="token comment" spellcheck="true"># extra digits for intermediate steps</span>
    three <span class="token operator">=</span> Decimal<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>      <span class="token comment" spellcheck="true"># substitute "three=3.0" for regular floats</span>
    lasts<span class="token punctuation">,</span> t<span class="token punctuation">,</span> s<span class="token punctuation">,</span> n<span class="token punctuation">,</span> na<span class="token punctuation">,</span> d<span class="token punctuation">,</span> da <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> three<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">24</span>
    <span class="token keyword">while</span> s <span class="token operator">!=</span> lasts<span class="token punctuation">:</span>
        lasts <span class="token operator">=</span> s
        n<span class="token punctuation">,</span> na <span class="token operator">=</span> n<span class="token operator">+</span>na<span class="token punctuation">,</span> na<span class="token operator">+</span><span class="token number">8</span>
        d<span class="token punctuation">,</span> da <span class="token operator">=</span> d<span class="token operator">+</span>da<span class="token punctuation">,</span> da<span class="token operator">+</span><span class="token number">32</span>
        t <span class="token operator">=</span> <span class="token punctuation">(</span>t <span class="token operator">*</span> n<span class="token punctuation">)</span> <span class="token operator">/</span> d
        s <span class="token operator">+=</span> t
    getcontext<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>prec <span class="token operator">-=</span> <span class="token number">2</span>
    <span class="token keyword">return</span> <span class="token operator">+</span>s               <span class="token comment" spellcheck="true"># unary plus applies the new precision</span>
<span class="token keyword">def</span> <span class="token function">exp</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">"""Return e raised to the power of x.  Result type matches input type.
    >>> print(exp(Decimal(1)))
    2.718281828459045235360287471
    >>> print(exp(Decimal(2)))
    7.389056098930650227230427461
    >>> print(exp(2.0))
    7.38905609893
    >>> print(exp(2+0j))
    (7.38905609893+0j)
    """</span>
    getcontext<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>prec <span class="token operator">+=</span> <span class="token number">2</span>
    i<span class="token punctuation">,</span> lasts<span class="token punctuation">,</span> s<span class="token punctuation">,</span> fact<span class="token punctuation">,</span> num <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span>
    <span class="token keyword">while</span> s <span class="token operator">!=</span> lasts<span class="token punctuation">:</span>
        lasts <span class="token operator">=</span> s
        i <span class="token operator">+=</span> <span class="token number">1</span>
        fact <span class="token operator">*=</span> i
        num <span class="token operator">*=</span> x
        s <span class="token operator">+=</span> num <span class="token operator">/</span> fact
    getcontext<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>prec <span class="token operator">-=</span> <span class="token number">2</span>
    <span class="token keyword">return</span> <span class="token operator">+</span>s
<span class="token keyword">def</span> <span class="token function">cos</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">"""Return the cosine of x as measured in radians.
    The Taylor series approximation works best for a small value of x.
    For larger values, first compute x = x % (2 * pi).
    >>> print(cos(Decimal('0.5')))
    0.8775825618903727161162815826
    >>> print(cos(0.5))
    0.87758256189
    >>> print(cos(0.5+0j))
    (0.87758256189+0j)
    """</span>
    getcontext<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>prec <span class="token operator">+=</span> <span class="token number">2</span>
    i<span class="token punctuation">,</span> lasts<span class="token punctuation">,</span> s<span class="token punctuation">,</span> fact<span class="token punctuation">,</span> num<span class="token punctuation">,</span> sign <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span>
    <span class="token keyword">while</span> s <span class="token operator">!=</span> lasts<span class="token punctuation">:</span>
        lasts <span class="token operator">=</span> s
        i <span class="token operator">+=</span> <span class="token number">2</span>
        fact <span class="token operator">*=</span> i <span class="token operator">*</span> <span class="token punctuation">(</span>i<span class="token number">-1</span><span class="token punctuation">)</span>
        num <span class="token operator">*=</span> x <span class="token operator">*</span> x
        sign <span class="token operator">*=</span> <span class="token operator">-</span><span class="token number">1</span>
        s <span class="token operator">+=</span> num <span class="token operator">/</span> fact <span class="token operator">*</span> sign
    getcontext<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>prec <span class="token operator">-=</span> <span class="token number">2</span>
    <span class="token keyword">return</span> <span class="token operator">+</span>s
<span class="token keyword">def</span> <span class="token function">sin</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">"""Return the sine of x as measured in radians.
    The Taylor series approximation works best for a small value of x.
    For larger values, first compute x = x % (2 * pi).
    >>> print(sin(Decimal('0.5')))
    0.4794255386042030002732879352
    >>> print(sin(0.5))
    0.479425538604
    >>> print(sin(0.5+0j))
    (0.479425538604+0j)
    """</span>
    getcontext<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>prec <span class="token operator">+=</span> <span class="token number">2</span>
    i<span class="token punctuation">,</span> lasts<span class="token punctuation">,</span> s<span class="token punctuation">,</span> fact<span class="token punctuation">,</span> num<span class="token punctuation">,</span> sign <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> x<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> x<span class="token punctuation">,</span> <span class="token number">1</span>
    <span class="token keyword">while</span> s <span class="token operator">!=</span> lasts<span class="token punctuation">:</span>
        lasts <span class="token operator">=</span> s
        i <span class="token operator">+=</span> <span class="token number">2</span>
        fact <span class="token operator">*=</span> i <span class="token operator">*</span> <span class="token punctuation">(</span>i<span class="token number">-1</span><span class="token punctuation">)</span>
        num <span class="token operator">*=</span> x <span class="token operator">*</span> x
        sign <span class="token operator">*=</span> <span class="token operator">-</span><span class="token number">1</span>
        s <span class="token operator">+=</span> num <span class="token operator">/</span> fact <span class="token operator">*</span> sign
    getcontext<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>prec <span class="token operator">-=</span> <span class="token number">2</span>
    <span class="token keyword">return</span> <span class="token operator">+</span>s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="Decimal-常见问题"><a href="#Decimal-常见问题" class="headerlink" title="Decimal 常见问题"></a>Decimal 常见问题</h3><p>Q. 总是输入 <code>decimal.Decimal('1234.5')</code> 是否过于笨拙。 在使用交互解释器时有没有最小化输入量的方式？</p>
<p>A. 有些用户会将构造器简写为一个字母：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> D <span class="token operator">=</span> decimal<span class="token punctuation">.</span>Decimal
<span class="token operator">>></span><span class="token operator">></span> D<span class="token punctuation">(</span><span class="token string">'1.23'</span><span class="token punctuation">)</span> <span class="token operator">+</span> D<span class="token punctuation">(</span><span class="token string">'3.45'</span><span class="token punctuation">)</span>
Decimal<span class="token punctuation">(</span><span class="token string">'4.68'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>Q. 在带有两个十进制位的定点数应用中，有些输入值具有许多位，需要被舍入。 另一些数则不应具有多余位，需要验证有效性。 这种情况应该用什么方法？</p>
<p>A. 用 <code>quantize()</code> 方法舍入到固定数量的十进制位。 如果设置了 <code>Inexact</code> 陷阱，它也适用于验证有效性：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> TWOPLACES <span class="token operator">=</span> Decimal<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">**</span> <span class="token operator">-</span><span class="token number">2</span>       <span class="token comment" spellcheck="true"># same as Decimal('0.01')</span>

<span class="token operator">>></span><span class="token operator">></span> <span class="token comment" spellcheck="true"># Round to two places</span>
<span class="token operator">>></span><span class="token operator">></span> Decimal<span class="token punctuation">(</span><span class="token string">'3.214'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>quantize<span class="token punctuation">(</span>TWOPLACES<span class="token punctuation">)</span>
Decimal<span class="token punctuation">(</span><span class="token string">'3.21'</span><span class="token punctuation">)</span>

<span class="token operator">>></span><span class="token operator">></span> <span class="token comment" spellcheck="true"># Validate that a number does not exceed two places</span>
<span class="token operator">>></span><span class="token operator">></span> Decimal<span class="token punctuation">(</span><span class="token string">'3.21'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>quantize<span class="token punctuation">(</span>TWOPLACES<span class="token punctuation">,</span> context<span class="token operator">=</span>Context<span class="token punctuation">(</span>traps<span class="token operator">=</span><span class="token punctuation">[</span>Inexact<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
Decimal<span class="token punctuation">(</span><span class="token string">'3.21'</span><span class="token punctuation">)</span>

<span class="token operator">>></span><span class="token operator">></span> Decimal<span class="token punctuation">(</span><span class="token string">'3.214'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>quantize<span class="token punctuation">(</span>TWOPLACES<span class="token punctuation">,</span> context<span class="token operator">=</span>Context<span class="token punctuation">(</span>traps<span class="token operator">=</span><span class="token punctuation">[</span>Inexact<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>
   <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
Inexact<span class="token punctuation">:</span> None<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>Q. 当我使用两个有效位的输入时，我要如何在一个应用中保持有效位不变？</p>
<p>A. 某些运算例如与整数相加、相减和相乘将会自动保留固定的小数位数。 其他运算，例如相除和非整数相乘则将会改变小数位数，需要再加上 <code>quantize()</code> 处理步骤：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> a <span class="token operator">=</span> Decimal<span class="token punctuation">(</span><span class="token string">'102.72'</span><span class="token punctuation">)</span>           <span class="token comment" spellcheck="true"># Initial fixed-point values</span>
<span class="token operator">>></span><span class="token operator">></span> b <span class="token operator">=</span> Decimal<span class="token punctuation">(</span><span class="token string">'3.17'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> a <span class="token operator">+</span> b                           <span class="token comment" spellcheck="true"># Addition preserves fixed-point</span>
Decimal<span class="token punctuation">(</span><span class="token string">'105.89'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> a <span class="token operator">-</span> b
Decimal<span class="token punctuation">(</span><span class="token string">'99.55'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> a <span class="token operator">*</span> <span class="token number">42</span>                          <span class="token comment" spellcheck="true"># So does integer multiplication</span>
Decimal<span class="token punctuation">(</span><span class="token string">'4314.24'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token punctuation">(</span>a <span class="token operator">*</span> b<span class="token punctuation">)</span><span class="token punctuation">.</span>quantize<span class="token punctuation">(</span>TWOPLACES<span class="token punctuation">)</span>     <span class="token comment" spellcheck="true"># Must quantize non-integer multiplication</span>
Decimal<span class="token punctuation">(</span><span class="token string">'325.62'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token punctuation">(</span>b <span class="token operator">/</span> a<span class="token punctuation">)</span><span class="token punctuation">.</span>quantize<span class="token punctuation">(</span>TWOPLACES<span class="token punctuation">)</span>     <span class="token comment" spellcheck="true"># And quantize division</span>
Decimal<span class="token punctuation">(</span><span class="token string">'0.03'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在开发定点数应用时，更方便的做法是定义处理 <code>quantize()</code> 步骤的函数：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">def</span> <span class="token function">mul</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> fp<span class="token operator">=</span>TWOPLACES<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">return</span> <span class="token punctuation">(</span>x <span class="token operator">*</span> y<span class="token punctuation">)</span><span class="token punctuation">.</span>quantize<span class="token punctuation">(</span>fp<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">def</span> <span class="token function">div</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> fp<span class="token operator">=</span>TWOPLACES<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">return</span> <span class="token punctuation">(</span>x <span class="token operator">/</span> y<span class="token punctuation">)</span><span class="token punctuation">.</span>quantize<span class="token punctuation">(</span>fp<span class="token punctuation">)</span>

<span class="token operator">>></span><span class="token operator">></span> mul<span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span>                       <span class="token comment" spellcheck="true"># Automatically preserve fixed-point</span>
Decimal<span class="token punctuation">(</span><span class="token string">'325.62'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> div<span class="token punctuation">(</span>b<span class="token punctuation">,</span> a<span class="token punctuation">)</span>
Decimal<span class="token punctuation">(</span><span class="token string">'0.03'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>Q. 表示同一个值有许多方式。 数字 <code>200</code>, <code>200.000</code>, <code>2E2</code> 和 <code>02E+4</code> 的值都相同但有精度不同。 是否有办法将它们转换为一个可识别的规范值？</p>
<p>A. <code>normalize()</code> 方法可将所有相同的值映射为统一表示形式：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> values <span class="token operator">=</span> map<span class="token punctuation">(</span>Decimal<span class="token punctuation">,</span> <span class="token string">'200 200.000 2E2 .02E+4'</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token punctuation">[</span>v<span class="token punctuation">.</span>normalize<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">for</span> v <span class="token keyword">in</span> values<span class="token punctuation">]</span>
<span class="token punctuation">[</span>Decimal<span class="token punctuation">(</span><span class="token string">'2E+2'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> Decimal<span class="token punctuation">(</span><span class="token string">'2E+2'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> Decimal<span class="token punctuation">(</span><span class="token string">'2E+2'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> Decimal<span class="token punctuation">(</span><span class="token string">'2E+2'</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>Q. 有些十进制值总是被打印为指数表示形式。 是否有办法得到一个非指数表示形式？</p>
<p>A. 对于某些值来说，指数表示形式是表示系数中有效位的唯一办法。 例如，将 <code>5.0E+3</code> 表示为 <code>5000</code> 可以让值保持恒定，但是无法显示原本的两位有效数字。</p>
<p>如果一个应用不必关心追踪有效位，则可以很容易地移除指数和末尾的零，丢弃有效位但让值保持不变：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">def</span> <span class="token function">remove_exponent</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">return</span> d<span class="token punctuation">.</span>quantize<span class="token punctuation">(</span>Decimal<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">if</span> d <span class="token operator">==</span> d<span class="token punctuation">.</span>to_integral<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">else</span> d<span class="token punctuation">.</span>normalize<span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token operator">>></span><span class="token operator">></span> remove_exponent<span class="token punctuation">(</span>Decimal<span class="token punctuation">(</span><span class="token string">'5E+3'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
Decimal<span class="token punctuation">(</span><span class="token string">'5000'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>Q. 是否有办法将一个普通浮点数转换为 <code>Decimal</code>？</p>
<p>A. 是的，任何二进制浮点数都可以精确地表示为 Decimal 值，但完全精确的转换可能需要比平常感觉更高的精度：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> Decimal<span class="token punctuation">(</span>math<span class="token punctuation">.</span>pi<span class="token punctuation">)</span>
Decimal<span class="token punctuation">(</span><span class="token string">'3.141592653589793115997963468544185161590576171875'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>Q. 在一个复杂的计算中，我怎样才能保证不会得到由精度不足和舍入异常所导致的虚假结果。</p>
<p>A. 使用 decimal 模块可以很容易地检测结果。 最好的做法是使用更高的精度和不同的舍入模式重新进行计算。 明显不同的结果表明存在精度不足、舍入模式问题、不符合条件的输入或是结果不稳定的算法。</p>
<p>Q. 我发现上下文精度的应用只针对运算结果而不针对输入。在混合使用不同精度的值时有什么需要注意的吗？</p>
<p>A. 是的。 原则上所有值都会被视为精确值，在这些值上进行的算术运算也是如此。 只有结果会被舍入。 对于输入来说其好处是“所输入即所得”。 而其缺点则是如果你忘记了输入没有被舍入，结果看起来可能会很奇怪：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> getcontext<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>prec <span class="token operator">=</span> <span class="token number">3</span>
<span class="token operator">>></span><span class="token operator">></span> Decimal<span class="token punctuation">(</span><span class="token string">'3.104'</span><span class="token punctuation">)</span> <span class="token operator">+</span> Decimal<span class="token punctuation">(</span><span class="token string">'2.104'</span><span class="token punctuation">)</span>
Decimal<span class="token punctuation">(</span><span class="token string">'5.21'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> Decimal<span class="token punctuation">(</span><span class="token string">'3.104'</span><span class="token punctuation">)</span> <span class="token operator">+</span> Decimal<span class="token punctuation">(</span><span class="token string">'0.000'</span><span class="token punctuation">)</span> <span class="token operator">+</span> Decimal<span class="token punctuation">(</span><span class="token string">'2.104'</span><span class="token punctuation">)</span>
Decimal<span class="token punctuation">(</span><span class="token string">'5.20'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>解决办法是提高精度或使用单目加法运算对输入执行强制舍入：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> getcontext<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>prec <span class="token operator">=</span> <span class="token number">3</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token operator">+</span>Decimal<span class="token punctuation">(</span><span class="token string">'1.23456789'</span><span class="token punctuation">)</span>      <span class="token comment" spellcheck="true"># unary plus triggers rounding</span>
Decimal<span class="token punctuation">(</span><span class="token string">'1.23'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>此外，还可以使用 <code>Context.create_decimal()</code> 方法在创建输入时执行舍入：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> Context<span class="token punctuation">(</span>prec<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">,</span> rounding<span class="token operator">=</span>ROUND_DOWN<span class="token punctuation">)</span><span class="token punctuation">.</span>create_decimal<span class="token punctuation">(</span><span class="token string">'1.2345678'</span><span class="token punctuation">)</span>
Decimal<span class="token punctuation">(</span><span class="token string">'1.2345'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>Q. CPython 实现对于巨大数字是否足够快速？</p>
<p>A. 是的。 在 CPython 和 PyPy3 实现中，decimal 模块的 C/CFFI 版本集成了高速 libmpdec 库用于实现任意精度正确舍入的十进制浮点算术 <a href="https://www.bookstack.cn/read/python-3.10.0-zh/4c889a3207dcceda.md#id4" target="_blank" rel="noopener">1</a>。 <code>libmpdec</code> 会对中等大小的数字使用 Karatsuba 乘法 而对非常巨大的数字使用 数字原理变换。</p>
<p>必须要对任意精度算术适配上下文。 <code>Emin</code> 和 <code>Emax</code> 应当总是设为最大值，<code>clamp</code> 应当总是设为 0 (默认值)。 设置 <code>prec</code> 需要十分谨慎。</p>
<p>进行大数字算术的最便捷方式也是使用 <code>prec</code> 的最大值:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> setcontext<span class="token punctuation">(</span>Context<span class="token punctuation">(</span>prec<span class="token operator">=</span>MAX_PREC<span class="token punctuation">,</span> Emax<span class="token operator">=</span>MAX_EMAX<span class="token punctuation">,</span> Emin<span class="token operator">=</span>MIN_EMIN<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> x <span class="token operator">=</span> Decimal<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">**</span> <span class="token number">256</span>
<span class="token operator">>></span><span class="token operator">></span> x <span class="token operator">/</span> <span class="token number">128</span>
Decimal<span class="token punctuation">(</span><span class="token string">'904625697166532776746648320380374280103671755200316906558262375061821325312'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>对于不精确的结果，在 64 位平台上 <code>MAX_PREC</code> 的值太大了，可用的内存将会不足:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> Decimal<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">3</span>
Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>
  File <span class="token string">"&lt;stdin>"</span><span class="token punctuation">,</span> line <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">></span>
MemoryError<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>在具有超量分配的系统上 (即 Linux)，一种更复杂的方式根据可用的 RAM 大小来调整 <code>prec</code>。 假设你有 8GB 的 RAM 并期望同时有 10 个操作数，每个最多使用 500MB:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> sys
<span class="token operator">>></span><span class="token operator">></span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token comment" spellcheck="true"># Maximum number of digits for a single operand using 500MB in 8-byte words</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token comment" spellcheck="true"># with 19 digits per word (4-byte and 9 digits for the 32-bit build):</span>
<span class="token operator">>></span><span class="token operator">></span> maxdigits <span class="token operator">=</span> <span class="token number">19</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">500</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token operator">**</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">//</span> <span class="token number">8</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token comment" spellcheck="true"># Check that this works:</span>
<span class="token operator">>></span><span class="token operator">></span> c <span class="token operator">=</span> Context<span class="token punctuation">(</span>prec<span class="token operator">=</span>maxdigits<span class="token punctuation">,</span> Emax<span class="token operator">=</span>MAX_EMAX<span class="token punctuation">,</span> Emin<span class="token operator">=</span>MIN_EMIN<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> c<span class="token punctuation">.</span>traps<span class="token punctuation">[</span>Inexact<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">True</span>
<span class="token operator">>></span><span class="token operator">></span> setcontext<span class="token punctuation">(</span>c<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token comment" spellcheck="true"># Fill the available precision with nines:</span>
<span class="token operator">>></span><span class="token operator">></span> x <span class="token operator">=</span> Decimal<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span>logical_invert<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">9</span>
<span class="token operator">>></span><span class="token operator">></span> sys<span class="token punctuation">.</span>getsizeof<span class="token punctuation">(</span>x<span class="token punctuation">)</span>
<span class="token number">524288112</span>
<span class="token operator">>></span><span class="token operator">></span> x <span class="token operator">+</span> <span class="token number">2</span>
Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>
  File <span class="token string">"&lt;stdin>"</span><span class="token punctuation">,</span> line <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">></span>
  decimal<span class="token punctuation">.</span>Inexact<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token string">'decimal.Inexact'</span><span class="token operator">></span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>总体而言（特别是在没有超量分配的系统上），如果期望所有计算都是精确的则推荐预估更严格的边界并设置 <code>Inexact</code> 陷阱。</p>
<h2 id="fractions-—-分数"><a href="#fractions-—-分数" class="headerlink" title="fractions —- 分数"></a><code>fractions</code> —- 分数</h2><p><strong>源代码</strong> <a href="https://github.com/python/cpython/tree/3.10/Lib/fractions.py" target="_blank" rel="noopener">Lib/fractions.py</a></p>
<hr>
<p><code>fractions</code> 模块支持分数运算。</p>
<p>分数实例可以由一对整数，一个分数，或者一个字符串构建而成。</p>
<p><em>class</em> <code>fractions.Fraction</code>(<em>numerator=0</em>, <em>denominator=1</em>)</p>
<p><em>class</em> <code>fractions.Fraction</code>(<em>other_fraction</em>)</p>
<p><em>class</em> <code>fractions.Fraction</code>(<em>float</em>)</p>
<p><em>class</em> <code>fractions.Fraction</code>(<em>decimal</em>)</p>
<p><em>class</em> <code>fractions.Fraction</code>(<em>string</em>)</p>
<p>第一个版本要求 <em>numerator</em> 和 <em>denominator</em> 是 <code>numbers.Rational</code> 的实例，并返回一个新的 <code>Fraction</code> 实例，其值为 <code>numerator/denominator</code>。 如果 <em>denominator</em> 为 <code>0</code> 将会引发 <code>ZeroDivisionError</code>。 第二个版本要求 <em>other_fraction</em> 是 <code>numbers.Rational</code> 的实例，并返回一个 <code>Fraction</code> 实例且与传入值相等。 下两个版本接受 <code>float</code> 或 <code>decimal.Decimal</code> 的实例，并返回一个 <code>Fraction</code> 实例且与传入值完全相等。 请注意由于二进制浮点数通常存在的问题，<code>Fraction(1.1)</code> 的参数并不会精确等于 11/10，因此 <code>Fraction(1.1)</code> 也 <em>不会</em> 返回用户所期望的 <code>Fraction(11, 10)</code>。 （请参阅下文中 <code>limit_denominator()</code> 方法的文档。） 构造器的最后一个版本接受一个字符串或 unicode 实例。 此实例的通常形式为:</p>
<pre><code>[sign] numerator ['/' denominator]</code></pre><p>其中的可选项 <code>sign</code> 可以为 ‘+’ 或 ‘-‘ 并且 <code>numerator</code> 和 <code>denominator</code> (如果存在) 是十进制数码的字符串。 此外，<code>float</code> 构造器所接受的任何表示一个有限值的字符串也都为 <code>Fraction</code> 构造器所接受。 不论哪种形式的输入字符串也都可以带有前缀和/或后缀的空格符。 这里是一些示例:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> fractions <span class="token keyword">import</span> Fraction
<span class="token operator">>></span><span class="token operator">></span> Fraction<span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">10</span><span class="token punctuation">)</span>
Fraction<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> Fraction<span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span>
Fraction<span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> Fraction<span class="token punctuation">(</span><span class="token punctuation">)</span>
Fraction<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> Fraction<span class="token punctuation">(</span><span class="token string">'3/7'</span><span class="token punctuation">)</span>
Fraction<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> Fraction<span class="token punctuation">(</span><span class="token string">' -3/7 '</span><span class="token punctuation">)</span>
Fraction<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> Fraction<span class="token punctuation">(</span><span class="token string">'1.414213 \t\n'</span><span class="token punctuation">)</span>
Fraction<span class="token punctuation">(</span><span class="token number">1414213</span><span class="token punctuation">,</span> <span class="token number">1000000</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> Fraction<span class="token punctuation">(</span><span class="token string">'-.125'</span><span class="token punctuation">)</span>
Fraction<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> Fraction<span class="token punctuation">(</span><span class="token string">'7e-6'</span><span class="token punctuation">)</span>
Fraction<span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">1000000</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> Fraction<span class="token punctuation">(</span><span class="token number">2.25</span><span class="token punctuation">)</span>
Fraction<span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> Fraction<span class="token punctuation">(</span><span class="token number">1.1</span><span class="token punctuation">)</span>
Fraction<span class="token punctuation">(</span><span class="token number">2476979795053773</span><span class="token punctuation">,</span> <span class="token number">2251799813685248</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> decimal <span class="token keyword">import</span> Decimal
<span class="token operator">>></span><span class="token operator">></span> Fraction<span class="token punctuation">(</span>Decimal<span class="token punctuation">(</span><span class="token string">'1.1'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
Fraction<span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>Fraction</code> 类继承自抽象基类 <code>numbers.Rational</code>，并实现了该类的所有方法和操作。 <code>Fraction</code> 实例是可哈希的，并应当被视为不可变对象。 此外，<code>Fraction</code> 还具有以下属性和方法：</p>
<p>在 3.2 版更改: <code>Fraction</code> 构造器现在接受 <code>float</code> 和 <code>decimal.Decimal</code> 实例。</p>
<p>在 3.9 版更改: 现在会使用 <code>math.gcd()</code> 函数来正规化 <em>numerator</em> 和 <em>denominator*。 <code>math.gcd()</code> 总是返回 <code>int</code> 类型。 在之前版本中，GCD 的类型取决于 *numerator</em> 和 <em>denominator</em> 的类型。</p>
<ul>
<li><p><code>numerator</code></p>
<p>最简分数形式的分子。</p>
</li>
<li><p><code>denominator</code></p>
<p>最简分数形式的分母。</p>
</li>
<li><p><code>as_integer_ratio</code>()</p>
<p>返回由两个整数组成的元组，两数之比等于该分数的值且其分母为正数。</p>
<p>3.8 新版功能.</p>
</li>
<li><p><code>from_float</code>(<em>flt</em>)</p>
<p>此类方法可构造一个 <code>Fraction</code> 来表示 <em>flt</em> 的精确值，该参数必须是一个 <code>float</code>。 请注意 <code>Fraction.from_float(0.3)</code> 的值并不等于 <code>Fraction(3, 10)</code>。</p>
<p>注解</p>
<p>从 Python 3.2 开始，在构造 <code>Fraction</code> 实例时可以直接使用 <code>float</code>。</p>
</li>
<li><p><code>from_decimal</code>(<em>dec</em>)</p>
<p>此类方法可构造一个 <code>Fraction</code> 来表示 <em>dec</em> 的精确值，该参数必须是一个 <code>decimal.Decimal</code> 实例。</p>
<p>注解</p>
<p>从 Python 3.2 开始，在构造 <code>Fraction</code> 实例时可以直接使用 <code>decimal.Decimal</code> 实例。</p>
</li>
<li><p><code>limit_denominator</code>(<em>max_denominator=1000000</em>)</p>
<p>找到并返回一个 <code>Fraction</code> 使得其值最接近 <code>self</code> 并且分母不大于 max_denominator。 此方法适用于找出给定浮点数的有理数近似值：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> fractions <span class="token keyword">import</span> Fraction
<span class="token operator">>></span><span class="token operator">></span> Fraction<span class="token punctuation">(</span><span class="token string">'3.1415926535897932'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>limit_denominator<span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span>
Fraction<span class="token punctuation">(</span><span class="token number">355</span><span class="token punctuation">,</span> <span class="token number">113</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>或是用来恢复被表示为一个浮点数的有理数：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> math <span class="token keyword">import</span> pi<span class="token punctuation">,</span> cos
<span class="token operator">>></span><span class="token operator">></span> Fraction<span class="token punctuation">(</span>cos<span class="token punctuation">(</span>pi<span class="token operator">/</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
Fraction<span class="token punctuation">(</span><span class="token number">4503599627370497</span><span class="token punctuation">,</span> <span class="token number">9007199254740992</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> Fraction<span class="token punctuation">(</span>cos<span class="token punctuation">(</span>pi<span class="token operator">/</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>limit_denominator<span class="token punctuation">(</span><span class="token punctuation">)</span>
Fraction<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> Fraction<span class="token punctuation">(</span><span class="token number">1.1</span><span class="token punctuation">)</span><span class="token punctuation">.</span>limit_denominator<span class="token punctuation">(</span><span class="token punctuation">)</span>
Fraction<span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><code>__floor__</code>()</p>
<p>返回最大的 <code>int</code> <code>&lt;= self</code>。 此方法也可通过 <code>math.floor()</code> 函数来使用：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> math <span class="token keyword">import</span> floor
<span class="token operator">>></span><span class="token operator">></span> floor<span class="token punctuation">(</span>Fraction<span class="token punctuation">(</span><span class="token number">355</span><span class="token punctuation">,</span> <span class="token number">113</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token number">3</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><code>__ceil__</code>()</p>
<p>返回最小的 <code>int</code> <code>&gt;= self</code>。 此方法也可通过 <code>math.ceil()</code> 函数来使用。</p>
</li>
<li><p><code>__round__</code>()</p>
<p><code>__round__</code>(<em>ndigits</em>)</p>
<p>第一个版本返回一个 <code>int</code> 使得其值最接近 <code>self</code>，位值为二分之一时只对偶数舍入。第二个版本会将 <code>self</code> 舍入到最接近 <code>Fraction(1, 10**ndigits)</code> 的倍数（如果 <code>ndigits</code> 为负值则为逻辑运算），位值为二分之一时同样只对偶数舍入。 此方法也可通过 <code>round()</code> 函数来使用。</p>
</li>
</ul>
<h2 id="random-—-生成伪随机数"><a href="#random-—-生成伪随机数" class="headerlink" title="random —- 生成伪随机数"></a><code>random</code> —- 生成伪随机数</h2><p><strong>源码：</strong> <a href="https://github.com/python/cpython/tree/3.10/Lib/random.py" target="_blank" rel="noopener">Lib/random.py</a></p>
<hr>
<p>该模块实现了各种分布的伪随机数生成器。</p>
<p>对于整数，从范围中有统一的选择。 对于序列，存在随机元素的统一选择、用于生成列表的随机排列的函数、以及用于随机抽样而无需替换的函数。</p>
<p>在实数轴上，有计算均匀、正态（高斯）、对数正态、负指数、伽马和贝塔分布的函数。 为了生成角度分布，可以使用 von Mises 分布。</p>
<p>几乎所有模块函数都依赖于基本函数 <code>random()</code> ，它在半开放区间 [0.0,1.0) 内均匀生成随机浮点数。 Python 使用 Mersenne Twister 作为核心生成器。 它产生 53 位精度浮点数，周期为 2**19937-1 ，其在 C 中的底层实现既快又线程安全。 Mersenne Twister 是现存最广泛测试的随机数发生器之一。 但是，因为完全确定性，它不适用于所有目的，并且完全不适合加密目的。</p>
<p>这个模块提供的函数实际上是 <code>random.Random</code> 类的隐藏实例的绑定方法。 你可以实例化自己的 <code>Random</code> 类实例以获取不共享状态的生成器。</p>
<p>如果你想使用自己设计的不同基础生成器，类 <code>Random</code> 也可以作为子类：在这种情况下，重载 <code>random()</code> 、 <code>seed()</code> 、 <code>getstate()</code> 以及 <code>setstate()</code> 方法。可选地，新生成器可以提供 <code>getrandbits()</code> 方法——这允许 <code>randrange()</code> 在任意大的范围内产生选择。</p>
<p><code>random</code> 模块还提供 <code>SystemRandom</code> 类，它使用系统函数 <code>os.urandom()</code> 从操作系统提供的源生成随机数。</p>
<p>参见</p>
<p>M. Matsumoto and T. Nishimura, “Mersenne Twister: A 623-dimensionally equidistributed uniform pseudorandom number generator”, ACM Transactions on Modeling and Computer Simulation Vol. 8, No. 1, January pp.3—30 1998.</p>
<p><a href="https://code.activestate.com/recipes/576707/" target="_blank" rel="noopener">Complementary-Multiply-with-Carry recipe</a> 用于兼容的替代随机数发生器，具有长周期和相对简单的更新操作。</p>
<h3 id="簿记功能"><a href="#簿记功能" class="headerlink" title="簿记功能"></a>簿记功能</h3><p><code>random.seed</code>(<em>a=None</em>, <em>version=2</em>)</p>
<p>初始化随机数生成器。</p>
<p>如果 <em>a</em> 被省略或为 <code>None</code> ，则使用当前系统时间。 如果操作系统提供随机源，则使用它们而不是系统时间（有关可用性的详细信息，请参阅 <code>os.urandom()</code> 函数）。</p>
<p>如果 <em>a</em> 是 int 类型，则直接使用。</p>
<p>对于版本2（默认的），<code>str</code> 、 <code>bytes</code> 或 <code>bytearray</code> 对象转换为 <code>int</code> 并使用它的所有位。</p>
<p>对于版本1（用于从旧版本的Python再现随机序列），用于 <code>str</code> 和 <code>bytes</code> 的算法生成更窄的种子范围。</p>
<p>在 3.2 版更改: 已移至版本2方案，该方案使用字符串种子中的所有位。</p>
<p>3.9 版后已移除: 在将来，<em>seed</em> 必须是下列类型之一: <em>NoneType</em>, <code>int</code>, <code>float</code>, <code>str</code>, <code>bytes</code> 或 <code>bytearray</code>。</p>
<p><code>random.getstate</code>()</p>
<p>返回捕获生成器当前内部状态的对象。 这个对象可以传递给 <code>setstate()</code> 来恢复状态。</p>
<p><code>random.setstate</code>(<em>state</em>)</p>
<p><em>state</em> 应该是从之前调用 <code>getstate()</code> 获得的，并且 <code>setstate()</code> 将生成器的内部状态恢复到 <code>getstate()</code> 被调用时的状态。</p>
<h3 id="用于字节数据的函数"><a href="#用于字节数据的函数" class="headerlink" title="用于字节数据的函数"></a>用于字节数据的函数</h3><p><code>random.randbytes</code>(<em>n</em>)</p>
<p>生成 <em>n</em> 个随机字节。</p>
<p>此方法不可用于生成安全凭据。 那应当使用 <code>secrets.token_bytes()</code>。</p>
<p>3.9 新版功能.</p>
<h3 id="整数用函数"><a href="#整数用函数" class="headerlink" title="整数用函数"></a>整数用函数</h3><p><code>random.randrange</code>(<em>stop</em>)</p>
<p><code>random.randrange</code>(<em>start</em>, <em>stop</em>[, <em>step</em>])</p>
<p>从 <code>range(start, stop, step)</code> 返回一个随机选择的元素。 这相当于 <code>choice(range(start, stop, step))</code> ，但实际上并没有构建一个 range 对象。</p>
<p>位置参数模式匹配 <code>range()</code> 。不应使用关键字参数，因为该函数可能以意外的方式使用它们。</p>
<p>在 3.2 版更改: <code>randrange()</code> 在生成均匀分布的值方面更为复杂。 以前它使用了像<code>int(random()*n)</code>这样的形式，它可以产生稍微不均匀的分布。</p>
<p>3.10 版后已移除: 非整数类型到相等整数的自动转换已被弃用。 目前 <code>randrange(10.0)</code> 会无损地转换为 <code>randrange(10)</code>。 在未来，这将引发 <code>TypeError</code>。</p>
<p>3.10 版后已移除: 针对非整数值例如 <code>randrange(10.5)</code> 或 <code>randrange('10')</code> 引发的异常将从 <code>ValueError</code> 修改为 <code>TypeError</code>。</p>
<p><code>random.randint</code>(<em>a</em>, <em>b</em>)</p>
<p>返回随机整数 <em>N</em> 满足 <code>a &lt;= N &lt;= b</code>。相当于 <code>randrange(a, b+1)</code>。</p>
<p><code>random.getrandbits</code>(<em>k</em>)</p>
<p>返回具有 <em>k</em> 个随机比特位的非负 Python 整数。 此方法随 MersenneTwister 生成器一起提供，其他一些生成器也可能将其作为 API 的可选部分提供。 在可能的情况下，<code>getrandbits()</code> 会启用 <code>randrange()</code> 来处理任意大的区间。</p>
<p>在 3.9 版更改: 此方法现在接受零作为 <em>k</em> 的值。</p>
<h3 id="序列用函数"><a href="#序列用函数" class="headerlink" title="序列用函数"></a>序列用函数</h3><p><code>random.choice</code>(<em>seq</em>)</p>
<p>从非空序列 <em>seq</em> 返回一个随机元素。 如果 <em>seq</em> 为空，则引发 <code>IndexError</code>。</p>
<p><code>random.choices</code>(<em>population</em>, <em>weights=None</em>, <em>**,</em> cum_weights=None<em>,</em> k=1*)</p>
<p>从<em>population*中选择替换，返回大小为 *k</em> 的元素列表。 如果 <em>population</em> 为空，则引发 <code>IndexError</code>。</p>
<p>如果指定了 <em>weight</em> 序列，则根据相对权重进行选择。 或者，如果给出 <em>cum_weights</em> 序列，则根据累积权重（可能使用 <code>itertools.accumulate()</code> 计算）进行选择。 例如，相对权重<code>[10, 5, 30, 5]</code>相当于累积权重<code>[10, 15, 45, 50]</code>。 在内部，相对权重在进行选择之前会转换为累积权重，因此提供累积权重可以节省工作量。</p>
<p>如果既未指定 <em>weight</em> 也未指定 <em>cum_weights</em> ，则以相等的概率进行选择。 如果提供了权重序列，则它必须与 <em>population</em> 序列的长度相同。 一个 <code>TypeError</code> 指定了 <em>weights</em> 和<em>cum_weights</em>。</p>
<p><em>weights</em> 或 <em>cum_weights</em> 可使用 <code>random()</code> 所返回的能与can use any numeric type that interoperates with the <code>float</code> 值进行相互运算的任何数字类型（包括整数、浮点数、分数但不包括 decimal）。 权重值应当非负且为有限的数值。 如果所有的权重值均为零则会引发 <code>ValueError</code>。</p>
<p>对于给定的种子，具有相等加权的 <code>choices()</code> 函数通常产生与重复调用 <code>choice()</code> 不同的序列。 <code>choices()</code> 使用的算法使用浮点运算来实现内部一致性和速度。 <code>choice()</code> 使用的算法默认为重复选择的整数运算，以避免因舍入误差引起的小偏差。</p>
<p>3.6 新版功能.</p>
<p>在 3.9 版更改: 如果所有权重均为负值则将引发 <code>ValueError</code>。</p>
<p><code>random.shuffle</code>(<em>x</em>[, <em>random</em>])</p>
<p>将序列 <em>x</em> 随机打乱位置。</p>
<p>可选参数 <em>random</em> 是一个0参数函数，在 [0.0, 1.0) 中返回随机浮点数；默认情况下，这是函数 <code>random()</code> 。</p>
<p>要改变一个不可变的序列并返回一个新的打乱列表，请使用<code>sample(x, k=len(x))</code>。</p>
<p>请注意，即使对于小的 <code>len(x)</code>，<em>x</em> 的排列总数也可以快速增长，大于大多数随机数生成器的周期。 这意味着长序列的大多数排列永远不会产生。 例如，长度为2080的序列是可以在 Mersenne Twister 随机数生成器的周期内拟合的最大序列。</p>
<p>Deprecated since version 3.9, will be removed in version 3.11: 可选形参 <em>random</em>。</p>
<p><code>random.sample</code>(<em>population</em>, <em>k</em>, <em>**,</em> counts=None*)</p>
<p>返回从总体序列或集合中选择的唯一元素的 <em>k</em> 长度列表。 用于无重复的随机抽样。</p>
<p>返回包含来自总体的元素的新列表，同时保持原始总体不变。 结果列表按选择顺序排列，因此所有子切片也将是有效的随机样本。 这允许抽奖获奖者（样本）被划分为大奖和第二名获胜者（子切片）。</p>
<p>总体成员不必是 hashable 或 unique 。 如果总体包含重复，则每次出现都是样本中可能的选择。</p>
<p>重复的元素可以一个个地直接列出，或使用可选的仅限关键字形参 <em>counts</em> 来指定。 例如，<code>sample(['red', 'blue'], counts=[4, 2], k=5)</code> 等价于 <code>sample(['red', 'red', 'red', 'red', 'blue', 'blue'], k=5)</code>。</p>
<p>要从一系列整数中选择样本，请使用 <code>range()</code> 对象作为参数。 对于从大量人群中采样，这种方法特别快速且节省空间：<code>sample(range(10000000), k=60)</code> 。</p>
<p>如果样本大小大于总体大小，则引发 <code>ValueError</code> 。</p>
<p>在 3.9 版更改: 增加了 <em>counts</em> 形参。</p>
<p>3.9 版后已移除: 在将来，<em>population</em> 必须是一个序列。 <code>set</code> 的实例将不再被支持。 集合必须先转换为 <code>list</code> 或 <code>tuple</code>，最好是固定顺序以使抽样是可重现的。</p>
<h3 id="实值分布"><a href="#实值分布" class="headerlink" title="实值分布"></a>实值分布</h3><p>以下函数生成特定的实值分布。如常用数学实践中所使用的那样, 函数参数以分布方程中的相应变量命名;大多数这些方程都可以在任何统计学教材中找到。</p>
<p><code>random.random</code>()</p>
<p>返回 [0.0, 1.0) 范围内的下一个随机浮点数。</p>
<p><code>random.uniform</code>(<em>a</em>, <em>b</em>)</p>
<p>返回一个随机浮点数 <em>N</em> ，当 <code>a &lt;= b</code> 时 <code>a &lt;= N &lt;= b</code> ，当 <code>b &lt; a</code> 时 <code>b &lt;= N &lt;= a</code> 。</p>
<p>取决于等式 <code>a + (b-a) * random()</code> 中的浮点舍入，终点 <code>b</code> 可以包括或不包括在该范围内。</p>
<p><code>random.triangular</code>(<em>low</em>, <em>high</em>, <em>mode</em>)</p>
<p>返回一个随机浮点数 <em>N</em> ，使得 <code>low &lt;= N &lt;= high</code> 并在这些边界之间使用指定的 <em>mode</em> 。 <em>low</em> 和 <em>high</em> 边界默认为零和一。 <em>mode</em> 参数默认为边界之间的中点，给出对称分布。</p>
<p><code>random.betavariate</code>(<em>alpha</em>, <em>beta</em>)</p>
<p>Beta 分布。 参数的条件是 <code>alpha &gt; 0</code> 和 <code>beta &gt; 0</code>。 返回值的范围介于 0 和 1 之间。</p>
<p><code>random.expovariate</code>(<em>lambd</em>)</p>
<p>指数分布。 <em>lambd</em> 是 1.0 除以所需的平均值，它应该是非零的。 （该参数本应命名为 “lambda” ，但这是 Python 中的保留字。）如果 <em>lambd</em> 为正，则返回值的范围为 0 到正无穷大；如果 <em>lambd</em> 为负，则返回值从负无穷大到 0。</p>
<p><code>random.gammavariate</code>(<em>alpha</em>, <em>beta</em>)</p>
<p>Gamma 分布。 （ <em>不是</em> gamma 函数！ ） 参数的条件是 <code>alpha &gt; 0</code> 和 <code>beta &gt; 0</code>。</p>
<p>概率分布函数是:</p>
<pre><code>          x ** (alpha - 1) * math.exp(-x / beta)
pdf(x) =  --------------------------------------
            math.gamma(alpha) * beta ** alpha</code></pre><p><code>random.gauss</code>(<em>mu</em>, <em>sigma</em>)</p>
<p>正态分布，也称高斯分布。 <em>mu</em> 为平均值，而 <em>sigma</em> 为标准差。 此函数要稍快于下面所定义的 <code>normalvariate()</code> 函数。</p>
<p>多线程注意事项：当两个线程同时调用此方法时，它们有可能将获得相同的返回值。 这可以通过三种办法来避免。 1) 让每个线程使用不同的随机数生成器实例。 2) 在所有调用外面加锁。 3) 改用速度较慢但是线程安全的 <code>normalvariate()</code> 函数。</p>
<p><code>random.lognormvariate</code>(<em>mu</em>, <em>sigma</em>)</p>
<p>对数正态分布。 如果你采用这个分布的自然对数，你将得到一个正态分布，平均值为 <em>mu</em> 和标准差为 <em>sigma</em> 。 <em>mu</em> 可以是任何值，<em>sigma</em> 必须大于零。</p>
<p><code>random.normalvariate</code>(<em>mu</em>, <em>sigma</em>)</p>
<p>正态分布。 <em>mu</em> 是平均值，<em>sigma</em> 是标准差。</p>
<p><code>random.vonmisesvariate</code>(<em>mu</em>, <em>kappa</em>)</p>
<p>冯·米塞斯分布。 <em>mu</em> 是平均角度，以弧度表示，介于0和 2*pi 之间，<em>kappa</em> 是浓度参数，必须大于或等于零。 如果 <em>kappa</em> 等于零，则该分布在 0 到 2<em>*pi</em> 的范围内减小到均匀的随机角度。</p>
<p><code>random.paretovariate</code>(<em>alpha</em>)</p>
<p>帕累托分布。 <em>alpha</em> 是形状参数。</p>
<p><code>random.weibullvariate</code>(<em>alpha</em>, <em>beta</em>)</p>
<p>威布尔分布。 <em>alpha</em> 是比例参数，<em>beta</em> 是形状参数。</p>
<h3 id="替代生成器"><a href="#替代生成器" class="headerlink" title="替代生成器"></a>替代生成器</h3><p><em>class</em> <code>random.Random</code>([<em>seed</em>])</p>
<p>该类实现了 <code>random</code> 模块所用的默认伪随机数生成器。</p>
<p>3.9 版后已移除: 在将来，<em>seed</em> 必须是下列类型之一: <code>NoneType</code>, <code>int</code>, <code>float</code>, <code>str</code>, <code>bytes</code> 或 <code>bytearray</code>。</p>
<p><em>class</em> <code>random.SystemRandom</code>([<em>seed</em>])</p>
<p>使用 <code>os.urandom()</code> 函数的类，用从操作系统提供的源生成随机数。 这并非适用于所有系统。 也不依赖于软件状态，序列不可重现。 因此，<code>seed()</code> 方法没有效果而被忽略。 <code>getstate()</code> 和 <code>setstate()</code> 方法如果被调用则引发 <code>NotImplementedError</code>。</p>
<h3 id="关于再现性的说明"><a href="#关于再现性的说明" class="headerlink" title="关于再现性的说明"></a>关于再现性的说明</h3><p>有时能够重现伪随机数生成器给出的序列是很有用处的。 通过重用一个种子值，只要没有运行多线程，相同的序列就应当可在多次运行中重现。</p>
<p>大多数随机模块的算法和种子函数都会在 Python 版本中发生变化，但保证两个方面不会改变：</p>
<ul>
<li>如果添加了新的播种方法，则将提供向后兼容的播种机。</li>
<li>当兼容的播种机被赋予相同的种子时，生成器的 <code>random()</code> 方法将继续产生相同的序列。</li>
</ul>
<h3 id="例子-2"><a href="#例子-2" class="headerlink" title="例子"></a>例子</h3><p>基本示例:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> random<span class="token punctuation">(</span><span class="token punctuation">)</span>                             <span class="token comment" spellcheck="true"># Random float:  0.0 &lt;= x &lt; 1.0</span>
<span class="token number">0.37444887175646646</span>
<span class="token operator">>></span><span class="token operator">></span> uniform<span class="token punctuation">(</span><span class="token number">2.5</span><span class="token punctuation">,</span> <span class="token number">10.0</span><span class="token punctuation">)</span>                   <span class="token comment" spellcheck="true"># Random float:  2.5 &lt;= x &lt;= 10.0</span>
<span class="token number">3.1800146073117523</span>
<span class="token operator">>></span><span class="token operator">></span> expovariate<span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">/</span> <span class="token number">5</span><span class="token punctuation">)</span>                   <span class="token comment" spellcheck="true"># Interval between arrivals averaging 5 seconds</span>
<span class="token number">5.148957571865031</span>
<span class="token operator">>></span><span class="token operator">></span> randrange<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span>                        <span class="token comment" spellcheck="true"># Integer from 0 to 9 inclusive</span>
<span class="token number">7</span>
<span class="token operator">>></span><span class="token operator">></span> randrange<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">101</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>                 <span class="token comment" spellcheck="true"># Even integer from 0 to 100 inclusive</span>
<span class="token number">26</span>
<span class="token operator">>></span><span class="token operator">></span> choice<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'win'</span><span class="token punctuation">,</span> <span class="token string">'lose'</span><span class="token punctuation">,</span> <span class="token string">'draw'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>      <span class="token comment" spellcheck="true"># Single random element from a sequence</span>
<span class="token string">'draw'</span>
<span class="token operator">>></span><span class="token operator">></span> deck <span class="token operator">=</span> <span class="token string">'ace two three four'</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> shuffle<span class="token punctuation">(</span>deck<span class="token punctuation">)</span>                        <span class="token comment" spellcheck="true"># Shuffle a list</span>
<span class="token operator">>></span><span class="token operator">></span> deck
<span class="token punctuation">[</span><span class="token string">'four'</span><span class="token punctuation">,</span> <span class="token string">'two'</span><span class="token punctuation">,</span> <span class="token string">'ace'</span><span class="token punctuation">,</span> <span class="token string">'three'</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> sample<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">40</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">]</span><span class="token punctuation">,</span> k<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># Four samples without replacement</span>
<span class="token punctuation">[</span><span class="token number">40</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>模拟:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token comment" spellcheck="true"># Six roulette wheel spins (weighted sampling with replacement)</span>
<span class="token operator">>></span><span class="token operator">></span> choices<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'red'</span><span class="token punctuation">,</span> <span class="token string">'black'</span><span class="token punctuation">,</span> <span class="token string">'green'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">18</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> k<span class="token operator">=</span><span class="token number">6</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token string">'red'</span><span class="token punctuation">,</span> <span class="token string">'green'</span><span class="token punctuation">,</span> <span class="token string">'black'</span><span class="token punctuation">,</span> <span class="token string">'black'</span><span class="token punctuation">,</span> <span class="token string">'red'</span><span class="token punctuation">,</span> <span class="token string">'black'</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token comment" spellcheck="true"># Deal 20 cards without replacement from a deck</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token comment" spellcheck="true"># of 52 playing cards, and determine the proportion of cards</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token comment" spellcheck="true"># with a ten-value:  ten, jack, queen, or king.</span>
<span class="token operator">>></span><span class="token operator">></span> dealt <span class="token operator">=</span> sample<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'tens'</span><span class="token punctuation">,</span> <span class="token string">'low cards'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> counts<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">16</span><span class="token punctuation">,</span> <span class="token number">36</span><span class="token punctuation">]</span><span class="token punctuation">,</span> k<span class="token operator">=</span><span class="token number">20</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> dealt<span class="token punctuation">.</span>count<span class="token punctuation">(</span><span class="token string">'tens'</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">20</span>
<span class="token number">0.15</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token comment" spellcheck="true"># Estimate the probability of getting 5 or more heads from 7 spins</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token comment" spellcheck="true"># of a biased coin that settles on heads 60% of the time.</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">def</span> <span class="token function">trial</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">return</span> choices<span class="token punctuation">(</span><span class="token string">'HT'</span><span class="token punctuation">,</span> cum_weights<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">0.60</span><span class="token punctuation">,</span> <span class="token number">1.00</span><span class="token punctuation">)</span><span class="token punctuation">,</span> k<span class="token operator">=</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">.</span>count<span class="token punctuation">(</span><span class="token string">'H'</span><span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token number">5</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> sum<span class="token punctuation">(</span>trial<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>10_000<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">/</span> 10_000
<span class="token number">0.4169</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token comment" spellcheck="true"># Probability of the median of 5 samples being in middle two quartiles</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">def</span> <span class="token function">trial</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">return</span> 2_500 <span class="token operator">&lt;=</span> sorted<span class="token punctuation">(</span>choices<span class="token punctuation">(</span>range<span class="token punctuation">(</span>10_000<span class="token punctuation">)</span><span class="token punctuation">,</span> k<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> 7_500
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> sum<span class="token punctuation">(</span>trial<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>10_000<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">/</span> 10_000
<span class="token number">0.7958</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>statistical bootstrapping 的示例，使用重新采样和替换来估计一个样本的均值的置信区间:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># http://statistics.about.com/od/Applications/a/Example-Of-Bootstrapping.htm</span>
<span class="token keyword">from</span> statistics <span class="token keyword">import</span> fmean <span class="token keyword">as</span> mean
<span class="token keyword">from</span> random <span class="token keyword">import</span> choices
data <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">41</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">,</span> <span class="token number">29</span><span class="token punctuation">,</span> <span class="token number">37</span><span class="token punctuation">,</span> <span class="token number">81</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">73</span><span class="token punctuation">,</span> <span class="token number">63</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">35</span><span class="token punctuation">,</span> <span class="token number">68</span><span class="token punctuation">,</span> <span class="token number">22</span><span class="token punctuation">,</span> <span class="token number">60</span><span class="token punctuation">,</span> <span class="token number">31</span><span class="token punctuation">,</span> <span class="token number">95</span><span class="token punctuation">]</span>
means <span class="token operator">=</span> sorted<span class="token punctuation">(</span>mean<span class="token punctuation">(</span>choices<span class="token punctuation">(</span>data<span class="token punctuation">,</span> k<span class="token operator">=</span>len<span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">'The sample mean of {mean(data):.1f} has a 90% confidence '</span>
      f<span class="token string">'interval from {means[5]:.1f} to {means[94]:.1f}'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>使用 重新采样排列测试 来确定统计学显著性或者使用 <a href="https://en.wikipedia.org/wiki/P-value" target="_blank" rel="noopener">p-值</a> 来观察药物与安慰剂的作用之间差异的示例:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Example from "Statistics is Easy" by Dennis Shasha and Manda Wilson</span>
<span class="token keyword">from</span> statistics <span class="token keyword">import</span> fmean <span class="token keyword">as</span> mean
<span class="token keyword">from</span> random <span class="token keyword">import</span> shuffle
drug <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">54</span><span class="token punctuation">,</span> <span class="token number">73</span><span class="token punctuation">,</span> <span class="token number">53</span><span class="token punctuation">,</span> <span class="token number">70</span><span class="token punctuation">,</span> <span class="token number">73</span><span class="token punctuation">,</span> <span class="token number">68</span><span class="token punctuation">,</span> <span class="token number">52</span><span class="token punctuation">,</span> <span class="token number">65</span><span class="token punctuation">,</span> <span class="token number">65</span><span class="token punctuation">]</span>
placebo <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">54</span><span class="token punctuation">,</span> <span class="token number">51</span><span class="token punctuation">,</span> <span class="token number">58</span><span class="token punctuation">,</span> <span class="token number">44</span><span class="token punctuation">,</span> <span class="token number">55</span><span class="token punctuation">,</span> <span class="token number">52</span><span class="token punctuation">,</span> <span class="token number">42</span><span class="token punctuation">,</span> <span class="token number">47</span><span class="token punctuation">,</span> <span class="token number">58</span><span class="token punctuation">,</span> <span class="token number">46</span><span class="token punctuation">]</span>
observed_diff <span class="token operator">=</span> mean<span class="token punctuation">(</span>drug<span class="token punctuation">)</span> <span class="token operator">-</span> mean<span class="token punctuation">(</span>placebo<span class="token punctuation">)</span>
n <span class="token operator">=</span> 10_000
count <span class="token operator">=</span> <span class="token number">0</span>
combined <span class="token operator">=</span> drug <span class="token operator">+</span> placebo
<span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>
    shuffle<span class="token punctuation">(</span>combined<span class="token punctuation">)</span>
    new_diff <span class="token operator">=</span> mean<span class="token punctuation">(</span>combined<span class="token punctuation">[</span><span class="token punctuation">:</span>len<span class="token punctuation">(</span>drug<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span> mean<span class="token punctuation">(</span>combined<span class="token punctuation">[</span>len<span class="token punctuation">(</span>drug<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
    count <span class="token operator">+=</span> <span class="token punctuation">(</span>new_diff <span class="token operator">>=</span> observed_diff<span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">'{n} label reshufflings produced only {count} instances with a difference'</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">'at least as extreme as the observed difference of {observed_diff:.1f}.'</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">'The one-sided p-value of {count / n:.4f} leads us to reject the null'</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">'hypothesis that there is no difference between the drug and the placebo.'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>多服务器队列的到达时间和服务交付模拟:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> heapq <span class="token keyword">import</span> heappush<span class="token punctuation">,</span> heappop
<span class="token keyword">from</span> random <span class="token keyword">import</span> expovariate<span class="token punctuation">,</span> gauss
<span class="token keyword">from</span> statistics <span class="token keyword">import</span> mean<span class="token punctuation">,</span> quantiles
average_arrival_interval <span class="token operator">=</span> <span class="token number">5.6</span>
average_service_time <span class="token operator">=</span> <span class="token number">15.0</span>
stdev_service_time <span class="token operator">=</span> <span class="token number">3.5</span>
num_servers <span class="token operator">=</span> <span class="token number">3</span>
waits <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
arrival_time <span class="token operator">=</span> <span class="token number">0.0</span>
servers <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0.0</span><span class="token punctuation">]</span> <span class="token operator">*</span> num_servers  <span class="token comment" spellcheck="true"># time when each server becomes available</span>
<span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>100_000<span class="token punctuation">)</span><span class="token punctuation">:</span>
    arrival_time <span class="token operator">+=</span> expovariate<span class="token punctuation">(</span><span class="token number">1.0</span> <span class="token operator">/</span> average_arrival_interval<span class="token punctuation">)</span>
    next_server_available <span class="token operator">=</span> heappop<span class="token punctuation">(</span>servers<span class="token punctuation">)</span>
    wait <span class="token operator">=</span> max<span class="token punctuation">(</span><span class="token number">0.0</span><span class="token punctuation">,</span> next_server_available <span class="token operator">-</span> arrival_time<span class="token punctuation">)</span>
    waits<span class="token punctuation">.</span>append<span class="token punctuation">(</span>wait<span class="token punctuation">)</span>
    service_duration <span class="token operator">=</span> gauss<span class="token punctuation">(</span>average_service_time<span class="token punctuation">,</span> stdev_service_time<span class="token punctuation">)</span>
    service_completed <span class="token operator">=</span> arrival_time <span class="token operator">+</span> wait <span class="token operator">+</span> service_duration
    heappush<span class="token punctuation">(</span>servers<span class="token punctuation">,</span> service_completed<span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">'Mean wait: {mean(waits):.1f}   Max wait: {max(waits):.1f}'</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Quartiles:'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>round<span class="token punctuation">(</span>q<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">for</span> q <span class="token keyword">in</span> quantiles<span class="token punctuation">(</span>waits<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>参见</p>
<p><a href="https://www.youtube.com/watch?v=Iq9DzN6mvYA" target="_blank" rel="noopener">Statistics for Hackers</a> <a href="https://us.pycon.org/2016/speaker/profile/295/" target="_blank" rel="noopener">Jake Vanderplas</a> 撰写的视频教程，使用一些基本概念进行统计分析，包括模拟、抽样、改组和交叉验证。</p>
<p><a href="http://nbviewer.jupyter.org/url/norvig.com/ipython/Economics.ipynb" target="_blank" rel="noopener">Economics Simulation</a> <a href="http://norvig.com/bio.html" target="_blank" rel="noopener">Peter Norvig</a> 编写的市场模拟，显示了该模块提供的许多工具和分布的有效使用（高斯、均匀、样本、beta变量、选择、三角和随机范围等）。</p>
<p><a href="http://nbviewer.jupyter.org/url/norvig.com/ipython/Probability.ipynb" target="_blank" rel="noopener">A Concrete Introduction to Probability (using Python)</a> <a href="http://norvig.com/bio.html" target="_blank" rel="noopener">Peter Norvig</a> 撰写的教程，涵盖了概率论基础知识，如何编写模拟，以及如何使用 Python 进行数据分析。</p>
<h3 id="例程-1"><a href="#例程-1" class="headerlink" title="例程"></a>例程</h3><p>默认的 <code>random()</code> 返回在 <em>0.0 ≤ x &lt; 1.0</em> 范围内 2⁻⁵³ 的倍数。 所有这些数值间隔相等并能精确表示为 Python 浮点数。 但是在此间隔上有许多其他可表示浮点数是不可能的选择。 例如，<code>0.05954861408025609</code> 就不是 2⁻⁵³ 的整数倍。</p>
<p>以下规范程序采取了一种不同的方式。 在间隔上的所有浮点数都是可能的选择。 它们的尾数取值来自 <em>2⁵² ≤ 尾数 &lt; 2⁵³</em> 范围内整数的均匀分布。 指数取值则来自几何分布，其中小于 <em>-53</em> 的指数的出现频率为下一个较大指数的一半。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> random <span class="token keyword">import</span> Random
<span class="token keyword">from</span> math <span class="token keyword">import</span> ldexp
<span class="token keyword">class</span> <span class="token class-name">FullRandom</span><span class="token punctuation">(</span>Random<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">random</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        mantissa <span class="token operator">=</span> 0x10_0000_0000_0000 <span class="token operator">|</span> self<span class="token punctuation">.</span>getrandbits<span class="token punctuation">(</span><span class="token number">52</span><span class="token punctuation">)</span>
        exponent <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">53</span>
        x <span class="token operator">=</span> <span class="token number">0</span>
        <span class="token keyword">while</span> <span class="token operator">not</span> x<span class="token punctuation">:</span>
            x <span class="token operator">=</span> self<span class="token punctuation">.</span>getrandbits<span class="token punctuation">(</span><span class="token number">32</span><span class="token punctuation">)</span>
            exponent <span class="token operator">+=</span> x<span class="token punctuation">.</span>bit_length<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">32</span>
        <span class="token keyword">return</span> ldexp<span class="token punctuation">(</span>mantissa<span class="token punctuation">,</span> exponent<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>该类中所有的 实值分布 都将使用新的方法:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> fr <span class="token operator">=</span> FullRandom<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> fr<span class="token punctuation">.</span>random<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token number">0.05954861408025609</span>
<span class="token operator">>></span><span class="token operator">></span> fr<span class="token punctuation">.</span>expovariate<span class="token punctuation">(</span><span class="token number">0.25</span><span class="token punctuation">)</span>
<span class="token number">8.87925541791544</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>该规范程序在概念上等效于在 <em>0.0 ≤ x &lt; 1.0</em> 范围内对所有 2⁻¹⁰⁷⁴ 的倍数进行选择的算法。 所有这样的数字间隔都相等，但大多必须向下舍入为最接近的 Python 浮点数表示形式。 （2⁻¹⁰⁷⁴ 这个数值是等于 <code>math.ulp(0.0)</code> 的未经正规化的最小正浮点数。）</p>
<h2 id="statistics-—-数学统计函数"><a href="#statistics-—-数学统计函数" class="headerlink" title="statistics —- 数学统计函数"></a><code>statistics</code> —- 数学统计函数</h2><p>3.4 新版功能.</p>
<p><strong>源代码:</strong> <a href="https://github.com/python/cpython/tree/3.10/Lib/statistics.py" target="_blank" rel="noopener">Lib/statistics.py</a></p>
<hr>
<p>该模块提供了用于计算数字 (<code>Real</code>-valued) 数据的数理统计量的函数。</p>
<p>此模块并不是诸如 NumPy ， SciPy 等第三方库或者诸如 Minitab ， SAS ， Matlab 等针对专业统计学家的专有全功能统计软件包的竞品。此模块针对图形和科学计算器的水平。</p>
<p>除非明确注释，这些函数支持 <code>int</code> ， <code>float</code> ， <code>Decimal</code> 和 <code>Fraction</code> 。当前不支持同其他类型（是否在数字塔中）的行为。混合类型的集合也是未定义的，并且依赖于实现。如果你输入的数据由混合类型组成，你应该能够使用 <code>map()</code> 来确保一个一致的结果，比如： <code>map(float, input_data)</code> 。</p>
<h3 id="平均值以及对中心位置的评估"><a href="#平均值以及对中心位置的评估" class="headerlink" title="平均值以及对中心位置的评估"></a>平均值以及对中心位置的评估</h3><p>这些函数用于计算一个总体或样本的平均值或者典型值。</p>
<table>
<thead>
<tr>
<th><code>mean()</code></th>
<th>数据的算术平均数（“平均数”）。</th>
</tr>
</thead>
<tbody><tr>
<td><code>fmean()</code></td>
<td>快速的，浮点算数平均数。</td>
</tr>
<tr>
<td><code>geometric_mean()</code></td>
<td>数据的几何平均数</td>
</tr>
<tr>
<td><code>harmonic_mean()</code></td>
<td>数据的调和均值</td>
</tr>
<tr>
<td><code>median()</code></td>
<td>数据的中位数（中间值）</td>
</tr>
<tr>
<td><code>median_low()</code></td>
<td>数据的低中位数</td>
</tr>
<tr>
<td><code>median_high()</code></td>
<td>数据的高中位数</td>
</tr>
<tr>
<td><code>median_grouped()</code></td>
<td>分组数据的中位数，即第50个百分点。</td>
</tr>
<tr>
<td><code>mode()</code></td>
<td>离散的或标称的数据的单个众数（出现最多的值）。</td>
</tr>
<tr>
<td><code>multimode()</code></td>
<td>离散的或标称的数据的众数（出现最多的值）列表。</td>
</tr>
<tr>
<td><code>quantiles()</code></td>
<td>将数据以相等的概率分为多个间隔。</td>
</tr>
</tbody></table>
<h3 id="对分散程度的评估"><a href="#对分散程度的评估" class="headerlink" title="对分散程度的评估"></a>对分散程度的评估</h3><p>这些函数用于计算总体或样本与典型值或平均值的偏离程度。</p>
<table>
<thead>
<tr>
<th><code>pstdev()</code></th>
<th>数据的总体标准差</th>
</tr>
</thead>
<tbody><tr>
<td><code>pvariance()</code></td>
<td>数据的总体方差</td>
</tr>
<tr>
<td><code>stdev()</code></td>
<td>数据的样本标准差</td>
</tr>
<tr>
<td><code>variance()</code></td>
<td>数据的样本方差</td>
</tr>
</tbody></table>
<h3 id="对两个输入之间关系的统计"><a href="#对两个输入之间关系的统计" class="headerlink" title="对两个输入之间关系的统计"></a>对两个输入之间关系的统计</h3><p>这些函数计算两个输入之间关系的统计值。</p>
<table>
<thead>
<tr>
<th><code>covariance()</code></th>
<th>两个变量的样本协方差。</th>
</tr>
</thead>
<tbody><tr>
<td><code>correlation()</code></td>
<td>两个变量的皮尔逊相关系数。</td>
</tr>
<tr>
<td><code>linear_regression()</code></td>
<td>简单线性回归的斜率和截距。</td>
</tr>
</tbody></table>
<h3 id="函数细节"><a href="#函数细节" class="headerlink" title="函数细节"></a>函数细节</h3><p>注释：这些函数不需要对提供给它们的数据进行排序。但是，为了方便阅读，大多数例子展示的是已排序的序列。</p>
<p><code>statistics.mean</code>(<em>data</em>)</p>
<p>返回 <em>data</em> 的样本算术平均数，形式为序列或迭代器。</p>
<p>算术平均数是数据之和与数据点个数的商。通常称作“平均数”，尽管它指示诸多数学平均数之一。它是数据的中心位置的度量。</p>
<p>若 <em>data</em> 为空，将会引发 <code>StatisticsError</code>。</p>
<p>一些用法示例：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> mean<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token number">2.8</span>
<span class="token operator">>></span><span class="token operator">></span> mean<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">2.5</span><span class="token punctuation">,</span> <span class="token number">3.25</span><span class="token punctuation">,</span> <span class="token number">5.75</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token number">2.625</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> fractions <span class="token keyword">import</span> Fraction <span class="token keyword">as</span> F
<span class="token operator">>></span><span class="token operator">></span> mean<span class="token punctuation">(</span><span class="token punctuation">[</span>F<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">,</span> F<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">21</span><span class="token punctuation">)</span><span class="token punctuation">,</span> F<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span> F<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
Fraction<span class="token punctuation">(</span><span class="token number">13</span><span class="token punctuation">,</span> <span class="token number">21</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> decimal <span class="token keyword">import</span> Decimal <span class="token keyword">as</span> D
<span class="token operator">>></span><span class="token operator">></span> mean<span class="token punctuation">(</span><span class="token punctuation">[</span>D<span class="token punctuation">(</span><span class="token string">"0.5"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> D<span class="token punctuation">(</span><span class="token string">"0.75"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> D<span class="token punctuation">(</span><span class="token string">"0.625"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> D<span class="token punctuation">(</span><span class="token string">"0.375"</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
Decimal<span class="token punctuation">(</span><span class="token string">'0.5625'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>注解</p>
<p>均值非常受异常值的影响并且这不是中心位置的可靠估计：均值不一定是数据点的典型示例。</p>
<p>样本均值给出了一个无偏向的真实总体均值的估计，因此当平均抽取所有可能的样本， <code>mean(sample)</code> 收敛于整个总体的真实均值。如果 <em>data</em> 代表整个总体而不是样本，那么 <code>mean(data)</code> 等同于计算真实整体均值 μ 。</p>
<p><code>statistics.fmean</code>(<em>data</em>)</p>
<p>将 <em>data</em> 转换成浮点数并且计算算术平均数。</p>
<p>此函数的运行速度比 <code>mean()</code> 函数快并且它总是返回一个 <code>float</code>。 <em>data</em> 可以为序列或可迭代对象。 如果输入数据集为空，则会引发 <code>StatisticsError</code>。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> fmean<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">3.5</span><span class="token punctuation">,</span> <span class="token number">4.0</span><span class="token punctuation">,</span> <span class="token number">5.25</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token number">4.25</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>3.8 新版功能.</p>
<p><code>statistics.geometric_mean</code>(<em>data</em>)</p>
<p>将 <em>data</em> 转换成浮点数并且计算几何平均数。</p>
<p>几何平均值使用值的乘积表示 <em>数据</em> 的中心趋势或典型值（与使用它们的总和的算术平均值相反）。</p>
<p>如果输入数据集为空、包含零或包含负值则将引发 <code>StatisticsError</code>。 <em>data</em> 可以是序列或可迭代对象。</p>
<p>无需做出特殊努力即可获得准确的结果。（但是，将来或许会修改。）</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> round<span class="token punctuation">(</span>geometric_mean<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">54</span><span class="token punctuation">,</span> <span class="token number">24</span><span class="token punctuation">,</span> <span class="token number">36</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>
<span class="token number">36.0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>3.8 新版功能.</p>
<p><code>statistics.harmonic_mean</code>(<em>data</em>, <em>weights=None</em>)</p>
<p>返回包含实数值的序列或可迭代对象 <em>data</em> 的调和平均数。 如果 <em>weights</em> 被省略或为 <em>None</em>，则会假定权重相等。</p>
<p>调和平均数是数据的倒数的算术平均值 <code>mean()</code> 的倒数。 例如，三个数值 <em>a</em>, <em>b</em> 和 <em>c</em> 的调和平均数将等于 <code>3/(1/a + 1/b + 1/c)</code>。 如果其中一个值为零，则结果也将为零。</p>
<p>调和平均数是均值的一种，是对数据的中心位置的度量。 它通常适用于求比率和比例（如速度）的均值。</p>
<p>假设一辆车在 40 km/hr 的速度下行驶了 10 km ，然后又以 60 km/hr 的速度行驶了 10 km 。车辆的平均速率是多少？</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> harmonic_mean<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">40</span><span class="token punctuation">,</span> <span class="token number">60</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token number">48.0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>假设一辆汽车以速度 40 公里/小时行驶了 5 公里，当道路变得畅通后，提速到 60 公里/小时行驶了行程中剩余的 30 km。 请问其平均速度是多少？</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> harmonic_mean<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">40</span><span class="token punctuation">,</span> <span class="token number">60</span><span class="token punctuation">]</span><span class="token punctuation">,</span> weights<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token number">56.0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>如果 <em>data</em> 为空、任意元素小于零，或者加权汇总值不为正数则会引发 <code>StatisticsError</code>。</p>
<p>当前算法在输入中遇到零时会提前退出。这意味着不会测试后续输入的有效性。（此行为将来可能会更改。）</p>
<p>3.6 新版功能.</p>
<p>在 3.10 版更改: 添加了对 <em>weights</em> 的支持。</p>
<p><code>statistics.median</code>(<em>data</em>)</p>
<p>使用普通的“取中间两数平均值”方法返回数值数据的中位数（中间值）。 如果 <em>data</em> 为空，则将引发 <code>StatisticsError</code>。 <em>data</em> 可以是序列或可迭代对象。</p>
<p>中位数是衡量中间位置的可靠方式，并且较少受到极端值的影响。 当数据点的总数为奇数时，将返回中间数据点：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> median<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token number">3</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>当数据点的总数为偶数时，中位数将通过对两个中间值求平均进行插值得出：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> median<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token number">4.0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>这适用于当你的数据是离散的，并且你不介意中位数不是实际数据点的情况。</p>
<p>如果数据是有序的（支持排序操作）但不是数字（不支持加法），请考虑改用 <code>median_low()</code> 或 <code>median_high()</code>。</p>
<p><code>statistics.median_low</code>(<em>data</em>)</p>
<p>返回数值数据的低中位数。 如果 <em>data</em> 为空则将引发 <code>StatisticsError</code>。 <em>data</em> 可以是序列或可迭代对象。</p>
<p>低中位数一定是数据集的成员。 当数据点总数为奇数时，将返回中间值。 当其为偶数时，将返回两个中间值中较小的那个。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> median_low<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token number">3</span>
<span class="token operator">>></span><span class="token operator">></span> median_low<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token number">3</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>当你的数据是离散的，并且你希望中位数是一个实际数据点而非插值结果时可以使用低中位数。</p>
<p><code>statistics.median_high</code>(<em>data</em>)</p>
<p>返回数据的高中位数。 如果 <em>data</em> 为空则将引发 <code>StatisticsError</code>。 <em>data</em> 可以是序列或可迭代对象。</p>
<p>高中位数一定是数据集的成员。 当数据点总数为奇数时，将返回中间值。 当其为偶数时，将返回两个中间值中较大的那个。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> median_high<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token number">3</span>
<span class="token operator">>></span><span class="token operator">></span> median_high<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token number">5</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>当你的数据是离散的，并且你希望中位数是一个实际数据点而非插值结果时可以使用高中位数。</p>
<p><code>statistics.median_grouped</code>(<em>data</em>, <em>interval=1</em>)</p>
<p>返回分组的连续数据的中位数，根据第 50 个百分点的位置使用插值来计算。 如果 <em>data</em> 为空则将引发 <code>StatisticsError</code>。 <em>data</em> 可以是序列或可迭代对象。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> median_grouped<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">52</span><span class="token punctuation">,</span> <span class="token number">52</span><span class="token punctuation">,</span> <span class="token number">53</span><span class="token punctuation">,</span> <span class="token number">54</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token number">52.5</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>在下面的示例中，数据已经过舍入，这样每个值都代表数据分类的中间点，例如 1 是 0.5—1.5 分类的中间点，2 是 1.5—2.5 分类的中间点，3 是 2.5—3.5 的中间点等待。 根据给定的数据，中间值应落在 3.5—4.5 分类之内，并可使用插值法来进行估算：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> median_grouped<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token number">3.7</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>可选参数 <em>interval</em> 表示分类间隔，默认值为 1。 改变分类间隔自然会改变插件结果：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> median_grouped<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">,</span> interval<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token number">3.25</span>
<span class="token operator">>></span><span class="token operator">></span> median_grouped<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">,</span> interval<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span>
<span class="token number">3.5</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>此函数不会检查数据点之间是否至少相隔 <em>interval</em> 的距离。</p>
<p><strong>CPython implementation detail:</strong> 在某些情况下，<code>median_grouped()</code> 可以会将数据点强制转换为浮点数。 此行为在未来有可能会发生改变。</p>
<p>参见</p>
<ul>
<li>“Statistics for the Behavioral Sciences”, Frederick J Gravetter and Larry B Wallnau (8th Edition).</li>
<li>Gnome Gnumeric 电子表格中的 SSMEDIAN 函数。</li>
</ul>
<p><code>statistics.mode</code>(<em>data</em>)</p>
<p>从离散或标称的 <em>data</em> 返回单个出现最多的数据点。 此众数（如果存在）是最典型的值，并可用来度量中心的位置。</p>
<p>如果存在具有相同频率的多个众数，则返回在 <em>data</em> 中遇到的第一个。 如果想要其中最小或最大的一个，请使用 <code>min(multimode(data))</code> 或 <code>max(multimode(data))</code>。 如果输入的 <em>data</em> 为空，则会引发 <code>StatisticsError</code>。</p>
<p><code>mode</code> 将假定是离散数据并返回一个单一的值。 这是通常的学校教学中标准的处理方式：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> mode<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token number">3</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>此众数的独特之处在于它是这个包中唯一还可应用于标称（非数字）数据的统计信息：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> mode<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">"red"</span><span class="token punctuation">,</span> <span class="token string">"blue"</span><span class="token punctuation">,</span> <span class="token string">"blue"</span><span class="token punctuation">,</span> <span class="token string">"red"</span><span class="token punctuation">,</span> <span class="token string">"green"</span><span class="token punctuation">,</span> <span class="token string">"red"</span><span class="token punctuation">,</span> <span class="token string">"red"</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token string">'red'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>在 3.8 版更改: 现在会通过返回所遇到的第一个众数来处理多模数据集。 之前它会在遇到超过一个的众数时引发 <code>StatisticsError</code>。</p>
<p><code>statistics.multimode</code>(<em>data</em>)</p>
<p>返回最频繁出现的值的列表，并按它们在 <em>data</em> 中首次出现的位置排序。 如果存在多个众数则将返回一个以上的众数，或者如果 <em>data</em> 为空则将返回空列表：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> multimode<span class="token punctuation">(</span><span class="token string">'aabbbbccddddeeffffgg'</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token string">'d'</span><span class="token punctuation">,</span> <span class="token string">'f'</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> multimode<span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>3.8 新版功能.</p>
<p><code>statistics.pstdev</code>(<em>data</em>, <em>mu=None</em>)</p>
<p>返回总体标准差（总体方差的平方根）。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> pstdev<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1.5</span><span class="token punctuation">,</span> <span class="token number">2.5</span><span class="token punctuation">,</span> <span class="token number">2.5</span><span class="token punctuation">,</span> <span class="token number">2.75</span><span class="token punctuation">,</span> <span class="token number">3.25</span><span class="token punctuation">,</span> <span class="token number">4.75</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token number">0.986893273527251</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><code>statistics.pvariance</code>(<em>data</em>, <em>mu=None</em>)</p>
<p>返回非空序列或包含实数值的可迭代对象 <em>data</em> 的总体方差。 方差或称相对于均值的二阶距，是对数据变化幅度（延展度或分散度）的度量。 方差值较大表明数据的散布范围较大；方差值较小表明它紧密聚集于均值附近。</p>
<p>如果给出了可选的第二个参数 <em>mu*，它通常是 *data</em> 的均值。 它也可以被用来计算相对于一个非均值点的二阶距。 如果该参数省略或为 <code>None</code> (默认值)，则会自动进行算术均值的计算。</p>
<p>使用此函数可根据所有数值来计算方差。 要根据一个样本来估算方差，通常 <code>variance()</code> 函数是更好的选择。</p>
<p>如果 <em>data</em> 为空则会引发 <code>StatisticsError</code>。</p>
<p>示例：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> data <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">0.25</span><span class="token punctuation">,</span> <span class="token number">0.25</span><span class="token punctuation">,</span> <span class="token number">1.25</span><span class="token punctuation">,</span> <span class="token number">1.5</span><span class="token punctuation">,</span> <span class="token number">1.75</span><span class="token punctuation">,</span> <span class="token number">2.75</span><span class="token punctuation">,</span> <span class="token number">3.25</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> pvariance<span class="token punctuation">(</span>data<span class="token punctuation">)</span>
<span class="token number">1.25</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>如果你已经计算过数据的平均值，你可以将其作为可选的第二个参数 <em>mu</em> 传入以避免重复计算：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> mu <span class="token operator">=</span> mean<span class="token punctuation">(</span>data<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> pvariance<span class="token punctuation">(</span>data<span class="token punctuation">,</span> mu<span class="token punctuation">)</span>
<span class="token number">1.25</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>同样也支持使用 Decimal 和 Fraction 值：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> decimal <span class="token keyword">import</span> Decimal <span class="token keyword">as</span> D
<span class="token operator">>></span><span class="token operator">></span> pvariance<span class="token punctuation">(</span><span class="token punctuation">[</span>D<span class="token punctuation">(</span><span class="token string">"27.5"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> D<span class="token punctuation">(</span><span class="token string">"30.25"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> D<span class="token punctuation">(</span><span class="token string">"30.25"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> D<span class="token punctuation">(</span><span class="token string">"34.5"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> D<span class="token punctuation">(</span><span class="token string">"41.75"</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
Decimal<span class="token punctuation">(</span><span class="token string">'24.815'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> fractions <span class="token keyword">import</span> Fraction <span class="token keyword">as</span> F
<span class="token operator">>></span><span class="token operator">></span> pvariance<span class="token punctuation">(</span><span class="token punctuation">[</span>F<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span> F<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span> F<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
Fraction<span class="token punctuation">(</span><span class="token number">13</span><span class="token punctuation">,</span> <span class="token number">72</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>注解</p>
<p>当调用时附带完整的总体数据时，这将给出总体方差 σ²。 而当调用时只附带一个样本时，这将给出偏置样本方差 s²，也被称为带有 N 个自由度的方差。</p>
<p>如果你通过某种方式知道了真实的总体平均值 μ，则可以使用此函数来计算一个样本的方差，并将已知的总体平均值作为第二个参数。 假设数据点是总体的一个随机样本，则结果将为总体方差的无偏估计值。</p>
<p><code>statistics.stdev</code>(<em>data</em>, <em>xbar=None</em>)</p>
<p>返回样本标准差（样本方差的平方根）。 </p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> stdev<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1.5</span><span class="token punctuation">,</span> <span class="token number">2.5</span><span class="token punctuation">,</span> <span class="token number">2.5</span><span class="token punctuation">,</span> <span class="token number">2.75</span><span class="token punctuation">,</span> <span class="token number">3.25</span><span class="token punctuation">,</span> <span class="token number">4.75</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token number">1.0810874155219827</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><code>statistics.variance</code>(<em>data</em>, <em>xbar=None</em>)</p>
<p>返回包含至少两个实数值的可迭代对象 <em>data</em> 的样本方差。 方差或称相对于均值的二阶矩，是对数据变化幅度（延展度或分散度）的度量。 方差值较大表明数据的散布范围较大；方差值较小表明它紧密聚集于均值附近。</p>
<p>如果给出了可选的第二个参数 <em>xbar*，它应当是 *data</em> 的均值。 如果该参数省略或为 <code>None</code> (默认值)，则会自动进行均值的计算。</p>
<p>当你的数据是总体数据的样本时请使用此函数。</p>
<p>如果 <em>data</em> 包含的值少于两个则会引发 <code>StatisticsError</code>。</p>
<p>示例：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> data <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">2.75</span><span class="token punctuation">,</span> <span class="token number">1.75</span><span class="token punctuation">,</span> <span class="token number">1.25</span><span class="token punctuation">,</span> <span class="token number">0.25</span><span class="token punctuation">,</span> <span class="token number">0.5</span><span class="token punctuation">,</span> <span class="token number">1.25</span><span class="token punctuation">,</span> <span class="token number">3.5</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> variance<span class="token punctuation">(</span>data<span class="token punctuation">)</span>
<span class="token number">1.3720238095238095</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>如果你已经计算过数据的平均值，你可以将其作为可选的第二个参数 <em>xbar</em> 传入以避免重复计算：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> m <span class="token operator">=</span> mean<span class="token punctuation">(</span>data<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> variance<span class="token punctuation">(</span>data<span class="token punctuation">,</span> m<span class="token punctuation">)</span>
<span class="token number">1.3720238095238095</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>此函数不会试图检查你所传入的 <em>xbar</em> 是否为真实的平均值。 使用任意值作为 <em>xbar</em> 可能导致无效或不可能的结果。</p>
<p>同样也支持使用 Decimal 和 Fraction 值：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> decimal <span class="token keyword">import</span> Decimal <span class="token keyword">as</span> D
<span class="token operator">>></span><span class="token operator">></span> variance<span class="token punctuation">(</span><span class="token punctuation">[</span>D<span class="token punctuation">(</span><span class="token string">"27.5"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> D<span class="token punctuation">(</span><span class="token string">"30.25"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> D<span class="token punctuation">(</span><span class="token string">"30.25"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> D<span class="token punctuation">(</span><span class="token string">"34.5"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> D<span class="token punctuation">(</span><span class="token string">"41.75"</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
Decimal<span class="token punctuation">(</span><span class="token string">'31.01875'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> fractions <span class="token keyword">import</span> Fraction <span class="token keyword">as</span> F
<span class="token operator">>></span><span class="token operator">></span> variance<span class="token punctuation">(</span><span class="token punctuation">[</span>F<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">,</span> F<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> F<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
Fraction<span class="token punctuation">(</span><span class="token number">67</span><span class="token punctuation">,</span> <span class="token number">108</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>注解</p>
<p>这是附带贝塞尔校正的样本方差 s²，也称为具有 N-1 自由度的方差。 假设数据点具有代表性（即为独立且均匀的分布），则结果应当是对总体方差的无偏估计。</p>
<p>如果你通过某种方式知道了真实的总体平均值 μ 则应当调用 <code>pvariance()</code> 函数并将该值作为 <em>mu</em> 形参传入以得到一个样本的方差。</p>
<p><code>statistics.quantiles</code>(<em>data</em>, <em>**,</em> n=4<em>,</em> method=’exclusive’*)</p>
<p>将 <em>data</em> 分隔为具有相等概率的 <em>n</em> 个连续区间。 返回分隔这些区间的 <code>n - 1</code> 个分隔点的列表。</p>
<p>将 <em>n</em> 设为 4 以使用四分位（默认值）。 将 <em>n</em> 设为 10 以使用十分位。 将 <em>n</em> 设为 100 以使用百分位，即给出 99 个分隔点来将 <em>data</em> 分隔为 100 个大小相等的组。 如果 <em>n</em> 小于 1 则将引发 <code>StatisticsError</code>。</p>
<p><em>data</em> 可以是包含样本数据的任意可迭代对象。 为了获得有意义的结果，<em>data</em> 中数据点的数量应当大于 <em>n</em>。 如果数据点的数量小于两个则将引发 <code>StatisticsError</code>。</p>
<p>分隔点是通过对两个最接近的数据点进行线性插值得到的。 例如，如果一个分隔点落在两个样本值 <code>100</code> 和 <code>112</code> 之间距离三分之一的位置，则分隔点的取值将为 <code>104</code>。</p>
<p><em>method</em> 用于计算分位值，它会由于 <em>data</em> 是包含还是排除总体的最低和最高可能值而有所不同。</p>
<p>默认 <em>method</em> 是 “唯一的” 并且被用于在总体中数据采样这样可以有比样本中找到的更多的极端值。落在 <em>m</em> 个排序数据点的第 <em>i-th</em> 个以下的总体部分被计算为 <code>i / (m + 1)</code> 。给定九个样本值，方法排序它们并且分配一下的百分位： 10%, 20%, 30%, 40%, 50%, 60%, 70%, 80%, 90% 。</p>
<p>将 <em>method</em> 设为 “inclusive” 可用于描述总体数据或已明确知道包含有总体数据中最极端值的样本。 <em>data</em> 中的最小值会被作为第 0 个百分位而最大值会被作为第 100 个百分位。 总体数据里处于 <em>m</em> 个已排序数据点中 <em>第 i 个</em> 以下的部分会以 <code>(i - 1) / (m - 1)</code> 来计算。 给定 11 个样本值，该方法会对它们进行排序并赋予以下百分位: 0%, 10%, 20%, 30%, 40%, 50%, 60%, 70%, 80%, 90%, 100%。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Decile cut points for empirically sampled data</span>
<span class="token operator">>></span><span class="token operator">></span> data <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">105</span><span class="token punctuation">,</span> <span class="token number">129</span><span class="token punctuation">,</span> <span class="token number">87</span><span class="token punctuation">,</span> <span class="token number">86</span><span class="token punctuation">,</span> <span class="token number">111</span><span class="token punctuation">,</span> <span class="token number">111</span><span class="token punctuation">,</span> <span class="token number">89</span><span class="token punctuation">,</span> <span class="token number">81</span><span class="token punctuation">,</span> <span class="token number">108</span><span class="token punctuation">,</span> <span class="token number">92</span><span class="token punctuation">,</span> <span class="token number">110</span><span class="token punctuation">,</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         <span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">75</span><span class="token punctuation">,</span> <span class="token number">105</span><span class="token punctuation">,</span> <span class="token number">103</span><span class="token punctuation">,</span> <span class="token number">109</span><span class="token punctuation">,</span> <span class="token number">76</span><span class="token punctuation">,</span> <span class="token number">119</span><span class="token punctuation">,</span> <span class="token number">99</span><span class="token punctuation">,</span> <span class="token number">91</span><span class="token punctuation">,</span> <span class="token number">103</span><span class="token punctuation">,</span> <span class="token number">129</span><span class="token punctuation">,</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         <span class="token number">106</span><span class="token punctuation">,</span> <span class="token number">101</span><span class="token punctuation">,</span> <span class="token number">84</span><span class="token punctuation">,</span> <span class="token number">111</span><span class="token punctuation">,</span> <span class="token number">74</span><span class="token punctuation">,</span> <span class="token number">87</span><span class="token punctuation">,</span> <span class="token number">86</span><span class="token punctuation">,</span> <span class="token number">103</span><span class="token punctuation">,</span> <span class="token number">103</span><span class="token punctuation">,</span> <span class="token number">106</span><span class="token punctuation">,</span> <span class="token number">86</span><span class="token punctuation">,</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         <span class="token number">111</span><span class="token punctuation">,</span> <span class="token number">75</span><span class="token punctuation">,</span> <span class="token number">87</span><span class="token punctuation">,</span> <span class="token number">102</span><span class="token punctuation">,</span> <span class="token number">121</span><span class="token punctuation">,</span> <span class="token number">111</span><span class="token punctuation">,</span> <span class="token number">88</span><span class="token punctuation">,</span> <span class="token number">89</span><span class="token punctuation">,</span> <span class="token number">101</span><span class="token punctuation">,</span> <span class="token number">106</span><span class="token punctuation">,</span> <span class="token number">95</span><span class="token punctuation">,</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         <span class="token number">103</span><span class="token punctuation">,</span> <span class="token number">107</span><span class="token punctuation">,</span> <span class="token number">101</span><span class="token punctuation">,</span> <span class="token number">81</span><span class="token punctuation">,</span> <span class="token number">109</span><span class="token punctuation">,</span> <span class="token number">104</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token punctuation">[</span>round<span class="token punctuation">(</span>q<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">for</span> q <span class="token keyword">in</span> quantiles<span class="token punctuation">(</span>data<span class="token punctuation">,</span> n<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">81.0</span><span class="token punctuation">,</span> <span class="token number">86.2</span><span class="token punctuation">,</span> <span class="token number">89.0</span><span class="token punctuation">,</span> <span class="token number">99.4</span><span class="token punctuation">,</span> <span class="token number">102.5</span><span class="token punctuation">,</span> <span class="token number">103.6</span><span class="token punctuation">,</span> <span class="token number">106.0</span><span class="token punctuation">,</span> <span class="token number">109.8</span><span class="token punctuation">,</span> <span class="token number">111.0</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>3.8 新版功能.</p>
<p><code>statistics.covariance</code>(<em>x</em>, <em>y</em>, <em>/</em>)</p>
<p>返回两个输入 <em>x</em> 和 <em>y</em> 的样本协方差。 样本协方差是对两个输入的同步变化性的度量。</p>
<p>两个输入必须具有相同的长度（不少于两个元素），否则会引发 <code>StatisticsError</code>。</p>
<p>示例：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> x <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> y <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> covariance<span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span>
<span class="token number">0.75</span>
<span class="token operator">>></span><span class="token operator">></span> z <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> covariance<span class="token punctuation">(</span>x<span class="token punctuation">,</span> z<span class="token punctuation">)</span>
<span class="token operator">-</span><span class="token number">7.5</span>
<span class="token operator">>></span><span class="token operator">></span> covariance<span class="token punctuation">(</span>z<span class="token punctuation">,</span> x<span class="token punctuation">)</span>
<span class="token operator">-</span><span class="token number">7.5</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>3.10 新版功能.</p>
<p><code>statistics.correlation</code>(<em>x</em>, <em>y</em>, <em>/</em>)</p>
<p>返回两个输入的 皮尔逊相关系数。 皮尔逊相关系数 <em>r</em> 的取值在 -1 到 +1 之间。 它衡量线性相关的强度和方向，其中 +1 表示非常强的正线性相关，-1 表示非常强的负线性相关，0 表示无线性相关。</p>
<p>两个输入必须具有相同的长度（不少于两个元素），并且不必为常量，否则会引发 <code>StatisticsError</code>。</p>
<p>示例：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> x <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> y <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> correlation<span class="token punctuation">(</span>x<span class="token punctuation">,</span> x<span class="token punctuation">)</span>
<span class="token number">1.0</span>
<span class="token operator">>></span><span class="token operator">></span> correlation<span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span>
<span class="token operator">-</span><span class="token number">1.0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>3.10 新版功能.</p>
<p><code>statistics.linear_regression</code>(<em>x</em>, <em>y</em>, <em>/</em>)</p>
<p>返回使用普通最小二乘法估计得到的 <a href="https://en.wikipedia.org/wiki/Simple_linear_regression" target="_blank" rel="noopener">简单线性回归</a> 参数的斜率和截距。 简单纯属回归通过此线性函数来描述自变量 <em>x</em> 和因变量 <em>y</em> 之间的关系。</p>
<blockquote>
<p><em>y = slope \</em> x + intercept + noise*</p>
</blockquote>
<p>其中 <code>slope</code> 和 <code>intercept</code> 是估计得到的回归参数，而 <code>noise</code> 代表不可由线性回归解释的数据变异性（它等于因变量的预测值和实际值之间的差异）。</p>
<p>两个输入必须具有相同的长度（不少于两个元素），并且自变量 <em>x</em> 不可为常量；否则会引发 <code>StatisticsError</code>。</p>
<p>例如，我们可以使用 <a href="https://en.wikipedia.org/wiki/Monty_Python#Films" target="_blank" rel="noopener">Monty Python 系列电影的发布日期</a> 在假定出品方保持现有步调的情况下预测到 2019 年时产出的 Monty Python 电影的累计数量。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> year <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1971</span><span class="token punctuation">,</span> <span class="token number">1975</span><span class="token punctuation">,</span> <span class="token number">1979</span><span class="token punctuation">,</span> <span class="token number">1982</span><span class="token punctuation">,</span> <span class="token number">1983</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> films_total <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> slope<span class="token punctuation">,</span> intercept <span class="token operator">=</span> linear_regression<span class="token punctuation">(</span>year<span class="token punctuation">,</span> films_total<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> round<span class="token punctuation">(</span>slope <span class="token operator">*</span> <span class="token number">2019</span> <span class="token operator">+</span> intercept<span class="token punctuation">)</span>
<span class="token number">16</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>3.10 新版功能.</p>
<h3 id="异常-1"><a href="#异常-1" class="headerlink" title="异常"></a>异常</h3><p>只定义了一个异常：</p>
<p><em>exception</em> <code>statistics.StatisticsError</code></p>
<p><code>ValueError</code> 的子类，表示统计相关的异常。</p>
<h3 id="NormalDist-对象"><a href="#NormalDist-对象" class="headerlink" title="NormalDist 对象"></a><code>NormalDist</code> 对象</h3><p><code>NormalDist</code> 工具可用于创建和操纵 <a href="http://www.stat.yale.edu/Courses/1997-98/101/ranvar.htm" target="_blank" rel="noopener">随机变量</a> 的正态分布。 这个类将数据度量值的平均值和标准差作为单一实体来处理。</p>
<p>正态分布的概念来自于 <a href="https://en.wikipedia.org/wiki/Central_limit_theorem" target="_blank" rel="noopener">中央极限定理</a> 并且在统计学中有广泛的应用。</p>
<p><em>class</em> <code>statistics.NormalDist</code>(<em>mu=0.0</em>, <em>sigma=1.0</em>)</p>
<p>返回一个新的 <em>NormalDist</em> 对象，其中 <em>mu</em> 代表 <a href="https://en.wikipedia.org/wiki/Arithmetic_mean" target="_blank" rel="noopener">算术平均值</a> 而 <em>sigma</em> 代表 <a href="https://en.wikipedia.org/wiki/Standard_deviation" target="_blank" rel="noopener">标准差</a>。</p>
<p>若 <em>sigma</em> 为负数，将会引发 <code>StatisticsError</code>。</p>
<ul>
<li><p><code>mean</code></p>
<p>一个只读特征属性，表示特定正态分布的 <a href="https://en.wikipedia.org/wiki/Arithmetic_mean" target="_blank" rel="noopener">算术平均值</a>。</p>
</li>
<li><p><code>median</code></p>
<p>一个只读特征属性，表示特定正态分布的 <a href="https://en.wikipedia.org/wiki/Median" target="_blank" rel="noopener">中位数</a>。</p>
</li>
<li><p><code>mode</code></p>
<p>一个只读特征属性，表示特定正态分布的 <a href="https://en.wikipedia.org/wiki/Mode_(statistics)" target="_blank" rel="noopener">众数</a>。</p>
</li>
<li><p><code>stdev</code></p>
<p>一个只读特征属性，表示特定正态分布的 <a href="https://en.wikipedia.org/wiki/Standard_deviation" target="_blank" rel="noopener">标准差</a>。</p>
</li>
<li><p><code>variance</code></p>
<p>一个只读特征属性，表示特定正态分布的 <a href="https://en.wikipedia.org/wiki/Variance" target="_blank" rel="noopener">方差</a>。 等于标准差的平方。</p>
</li>
<li><p><em>classmethod</em> <code>from_samples</code>(<em>data</em>)</p>
<p>传入使用 <code>fmean()</code> 和 <code>stdev()</code> 基于 <em>data</em> 估算出的 <em>mu</em> 和 <em>sigma</em> 形参创建一个正态分布实例。</p>
<p><em>data</em> 可以是任何 iterable 并且应当包含能被转换为 <code>float</code> 类型的值。 如果 <em>data</em> 不包含至少两个元素，则会引发 <code>StatisticsError</code>，因为估算中心值至少需要一个点而估算分散度至少需要两个点。</p>
</li>
<li><p><code>samples</code>(<em>n</em>, <em>**,</em> seed=None*)</p>
<p>对于给定的平均值和标准差生成 <em>n</em> 个随机样本。 返回一个由 <code>float</code> 值组成的 <code>list</code>。</p>
<p>当给定 <em>seed</em> 时，创建一个新的底层随机数生成器实例。 这适用于创建可重现的结果，即使对于多线程上下文也有效。</p>
</li>
<li><p><code>pdf</code>(<em>x</em>)</p>
<p>使用 <a href="https://en.wikipedia.org/wiki/Probability_density_function" target="_blank" rel="noopener">概率密度函数 (pdf)</a>，计算一个随机变量 <em>X</em> 趋向于给定值 <em>x</em> 的相对可能性。 在数学意义上，它是当 <em>dx</em> 趋向于零时比率 <code>P(x &lt;= X &lt; x+dx) / dx</code> 的极限。</p>
<p>相对可能性的计算方法是用一个狭窄区间内某个样本出现的概率除以区间的宽度（因此使用“密度”一词）。 由于可能性是相对于其他点的，它的值可以大于 1.0。</p>
</li>
<li><p><code>cdf</code>(<em>x</em>)</p>
<p>使用 <a href="https://en.wikipedia.org/wiki/Cumulative_distribution_function" target="_blank" rel="noopener">累积分布函数 (cdf)</a>，计算一个随机变量 <em>X</em> 小于等于 <em>x</em> 的概率。 在数学上，它表示为 <code>P(X &lt;= x)</code>。</p>
</li>
<li><p><code>inv_cdf</code>(<em>p</em>)</p>
<p>计算反向累积分布函数，也称为 <a href="https://en.wikipedia.org/wiki/Quantile_function" target="_blank" rel="noopener">分位数函数</a> 或 <a href="https://www.statisticshowto.datasciencecentral.com/inverse-distribution-function/" target="_blank" rel="noopener">百分点</a> 函数。 在数学上，它表示为 <code>x : P(X &lt;= x) = p</code>。</p>
<p>找出随机变量 <em>X</em> 的值 <em>x</em> 使得该变量小于等于该值的概率等于给定的概率 <em>p</em>。</p>
</li>
<li><p><code>overlap</code>(<em>other</em>)</p>
<p>测量两个正态概率分布之间的一致性。 返回介于 0.0 和 1.0 之间的值，给出 <a href="https://www.rasch.org/rmt/rmt101r.htm" target="_blank" rel="noopener">两个概率密度函数的重叠区域</a>。</p>
</li>
<li><p><code>quantiles</code>(<em>n=4</em>)</p>
<p>将指定正态分布划分为 <em>n</em> 个相等概率的连续分隔区。 返回这些分隔区对应的 (n - 1) 个分隔点的列表。</p>
<p>将 <em>n</em> 设为 4 以使用四分位（默认值）。 将 <em>n</em> 设为 10 以使用十分位。将 <em>n</em> 设为 100 以使用百分位，即给出 99 个分隔点来将正态分布分隔为 100 个大小相等的组。</p>
</li>
<li><p><code>zscore</code>(<em>x</em>)</p>
<p>计算 <a href="https://www.statisticshowto.com/probability-and-statistics/z-score/" target="_blank" rel="noopener">标准分</a> 即以高于或低于正态分布的平均值的标准差数值的形式来描述 <em>x</em>: <code>(x - mean) / stdev</code>.</p>
<p>3.9 新版功能.</p>
</li>
</ul>
<p><code>NormalDist</code> 的实例支持加上、减去、乘以或除以一个常量。 这些运算被用于转换和缩放。 例如：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> temperature_february <span class="token operator">=</span> NormalDist<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">2.5</span><span class="token punctuation">)</span>             <span class="token comment" spellcheck="true"># Celsius</span>
<span class="token operator">>></span><span class="token operator">></span> temperature_february <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">9</span><span class="token operator">/</span><span class="token number">5</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">32</span>                     <span class="token comment" spellcheck="true"># Fahrenheit</span>
NormalDist<span class="token punctuation">(</span>mu<span class="token operator">=</span><span class="token number">41.0</span><span class="token punctuation">,</span> sigma<span class="token operator">=</span><span class="token number">4.5</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>不允许一个常量除以 <code>NormalDist</code> 的实例，因为结果将不是正态分布。</p>
<p>由于正态分布是由独立变量的累加效应产生的，因此允许表示为 <code>NormalDist</code> 实例的 <a href="https://en.wikipedia.org/wiki/Sum_of_normally_distributed_random_variables" target="_blank" rel="noopener">两组独立正态分布的随机变量相加和相减</a>。 例如：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> birth_weights <span class="token operator">=</span> NormalDist<span class="token punctuation">.</span>from_samples<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">2.5</span><span class="token punctuation">,</span> <span class="token number">3.1</span><span class="token punctuation">,</span> <span class="token number">2.1</span><span class="token punctuation">,</span> <span class="token number">2.4</span><span class="token punctuation">,</span> <span class="token number">2.7</span><span class="token punctuation">,</span> <span class="token number">3.5</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> drug_effects <span class="token operator">=</span> NormalDist<span class="token punctuation">(</span><span class="token number">0.4</span><span class="token punctuation">,</span> <span class="token number">0.15</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> combined <span class="token operator">=</span> birth_weights <span class="token operator">+</span> drug_effects
<span class="token operator">>></span><span class="token operator">></span> round<span class="token punctuation">(</span>combined<span class="token punctuation">.</span>mean<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>
<span class="token number">3.1</span>
<span class="token operator">>></span><span class="token operator">></span> round<span class="token punctuation">(</span>combined<span class="token punctuation">.</span>stdev<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>
<span class="token number">0.5</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>3.8 新版功能.</p>
<h4 id="NormalDist-示例和用法"><a href="#NormalDist-示例和用法" class="headerlink" title="NormalDist 示例和用法"></a><code>NormalDist</code> 示例和用法</h4><p><code>NormalDist</code> 适合用来解决经典概率问题。</p>
<p>举例来说，如果 <a href="https://nces.ed.gov/programs/digest/d17/tables/dt17_226.40.asp" target="_blank" rel="noopener">SAT 考试的历史数据</a> 显示分数呈平均值为 1060 且标准差为 195 的正态分布，则可以确定考试分数处于 1100 和 1200 之间的学生的百分比舍入到最接近的整数应为：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> sat <span class="token operator">=</span> NormalDist<span class="token punctuation">(</span><span class="token number">1060</span><span class="token punctuation">,</span> <span class="token number">195</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> fraction <span class="token operator">=</span> sat<span class="token punctuation">.</span>cdf<span class="token punctuation">(</span><span class="token number">1200</span> <span class="token operator">+</span> <span class="token number">0.5</span><span class="token punctuation">)</span> <span class="token operator">-</span> sat<span class="token punctuation">.</span>cdf<span class="token punctuation">(</span><span class="token number">1100</span> <span class="token operator">-</span> <span class="token number">0.5</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> round<span class="token punctuation">(</span>fraction <span class="token operator">*</span> <span class="token number">100.0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>
<span class="token number">18.4</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>求 SAT 分数的 <a href="https://en.wikipedia.org/wiki/Quartile" target="_blank" rel="noopener">四分位</a> 和 <a href="https://en.wikipedia.org/wiki/Decile" target="_blank" rel="noopener">十分位</a>：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> list<span class="token punctuation">(</span>map<span class="token punctuation">(</span>round<span class="token punctuation">,</span> sat<span class="token punctuation">.</span>quantiles<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token number">928</span><span class="token punctuation">,</span> <span class="token number">1060</span><span class="token punctuation">,</span> <span class="token number">1192</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> list<span class="token punctuation">(</span>map<span class="token punctuation">(</span>round<span class="token punctuation">,</span> sat<span class="token punctuation">.</span>quantiles<span class="token punctuation">(</span>n<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token number">810</span><span class="token punctuation">,</span> <span class="token number">896</span><span class="token punctuation">,</span> <span class="token number">958</span><span class="token punctuation">,</span> <span class="token number">1011</span><span class="token punctuation">,</span> <span class="token number">1060</span><span class="token punctuation">,</span> <span class="token number">1109</span><span class="token punctuation">,</span> <span class="token number">1162</span><span class="token punctuation">,</span> <span class="token number">1224</span><span class="token punctuation">,</span> <span class="token number">1310</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>为了估算一个不易解析的模型分布，<code>NormalDist</code> 可以生成用于 <a href="https://en.wikipedia.org/wiki/Monte_Carlo_method" target="_blank" rel="noopener">蒙特卡洛模拟</a> 的输入样本：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">def</span> <span class="token function">model</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> z<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token number">3</span><span class="token operator">*</span>x <span class="token operator">+</span> <span class="token number">7</span><span class="token operator">*</span>x<span class="token operator">*</span>y <span class="token operator">-</span> <span class="token number">5</span><span class="token operator">*</span>y<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token punctuation">(</span><span class="token number">11</span> <span class="token operator">*</span> z<span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> n <span class="token operator">=</span> 100_000
<span class="token operator">>></span><span class="token operator">></span> X <span class="token operator">=</span> NormalDist<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">2.5</span><span class="token punctuation">)</span><span class="token punctuation">.</span>samples<span class="token punctuation">(</span>n<span class="token punctuation">,</span> seed<span class="token operator">=</span><span class="token number">3652260728</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> Y <span class="token operator">=</span> NormalDist<span class="token punctuation">(</span><span class="token number">15</span><span class="token punctuation">,</span> <span class="token number">1.75</span><span class="token punctuation">)</span><span class="token punctuation">.</span>samples<span class="token punctuation">(</span>n<span class="token punctuation">,</span> seed<span class="token operator">=</span><span class="token number">4582495471</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> Z <span class="token operator">=</span> NormalDist<span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">,</span> <span class="token number">1.25</span><span class="token punctuation">)</span><span class="token punctuation">.</span>samples<span class="token punctuation">(</span>n<span class="token punctuation">,</span> seed<span class="token operator">=</span><span class="token number">6582483453</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> quantiles<span class="token punctuation">(</span>map<span class="token punctuation">(</span>model<span class="token punctuation">,</span> X<span class="token punctuation">,</span> Y<span class="token punctuation">,</span> Z<span class="token punctuation">)</span><span class="token punctuation">)</span>       
<span class="token punctuation">[</span><span class="token number">1.4591308524824727</span><span class="token punctuation">,</span> <span class="token number">1.8035946855390597</span><span class="token punctuation">,</span> <span class="token number">2.175091447274739</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>当样本量较大并且成功试验的可能性接近 50% 时，正态分布可以被用来模拟 <a href="http://mathworld.wolfram.com/BinomialDistribution.html" target="_blank" rel="noopener">二项分布</a>。</p>
<p>例如，一次开源会议有 750 名与会者和两个可分别容纳 500 人的会议厅。 会上有一场关于 Python 的演讲和一场关于 Ruby 的演讲。 在往届会议中，65% 的与会者更愿意去听关于 Python 的演讲。 假定人群的偏好没有发生改变，那么 Python 演讲的会议厅不超出其容量上限的可能性是多少？</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> n <span class="token operator">=</span> <span class="token number">750</span>             <span class="token comment" spellcheck="true"># Sample size</span>
<span class="token operator">>></span><span class="token operator">></span> p <span class="token operator">=</span> <span class="token number">0.65</span>            <span class="token comment" spellcheck="true"># Preference for Python</span>
<span class="token operator">>></span><span class="token operator">></span> q <span class="token operator">=</span> <span class="token number">1.0</span> <span class="token operator">-</span> p         <span class="token comment" spellcheck="true"># Preference for Ruby</span>
<span class="token operator">>></span><span class="token operator">></span> k <span class="token operator">=</span> <span class="token number">500</span>             <span class="token comment" spellcheck="true"># Room capacity</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token comment" spellcheck="true"># Approximation using the cumulative normal distribution</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> math <span class="token keyword">import</span> sqrt
<span class="token operator">>></span><span class="token operator">></span> round<span class="token punctuation">(</span>NormalDist<span class="token punctuation">(</span>mu<span class="token operator">=</span>n<span class="token operator">*</span>p<span class="token punctuation">,</span> sigma<span class="token operator">=</span>sqrt<span class="token punctuation">(</span>n<span class="token operator">*</span>p<span class="token operator">*</span>q<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>cdf<span class="token punctuation">(</span>k <span class="token operator">+</span> <span class="token number">0.5</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span>
<span class="token number">0.8402</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token comment" spellcheck="true"># Solution using the cumulative binomial distribution</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> math <span class="token keyword">import</span> comb<span class="token punctuation">,</span> fsum
<span class="token operator">>></span><span class="token operator">></span> round<span class="token punctuation">(</span>fsum<span class="token punctuation">(</span>comb<span class="token punctuation">(</span>n<span class="token punctuation">,</span> r<span class="token punctuation">)</span> <span class="token operator">*</span> p<span class="token operator">**</span>r <span class="token operator">*</span> q<span class="token operator">**</span><span class="token punctuation">(</span>n<span class="token operator">-</span>r<span class="token punctuation">)</span> <span class="token keyword">for</span> r <span class="token keyword">in</span> range<span class="token punctuation">(</span>k<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span>
<span class="token number">0.8402</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token comment" spellcheck="true"># Approximation using a simulation</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> random <span class="token keyword">import</span> seed<span class="token punctuation">,</span> choices
<span class="token operator">>></span><span class="token operator">></span> seed<span class="token punctuation">(</span><span class="token number">8675309</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">def</span> <span class="token function">trial</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">return</span> choices<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">'Python'</span><span class="token punctuation">,</span> <span class="token string">'Ruby'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>p<span class="token punctuation">,</span> q<span class="token punctuation">)</span><span class="token punctuation">,</span> k<span class="token operator">=</span>n<span class="token punctuation">)</span><span class="token punctuation">.</span>count<span class="token punctuation">(</span><span class="token string">'Python'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> mean<span class="token punctuation">(</span>trial<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> k <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>10_000<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token number">0.8398</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在机器学习问题中也经常会出现正态分布。</p>
<p>Wikipedia 上有一个 <a href="https://en.wikipedia.org/wiki/Naive_Bayes_classifier#Sex_classification" target="_blank" rel="noopener">朴素贝叶斯分类器的好例子</a>。 挑战的问题是根据对多个正态分布的特征测量值包括身高、体重和足部尺码来预测一个人的性别。</p>
<p>我们得到了由八个人的测量值组成的训练数据集。 假定这些测量值是正态分布的，因此我们用 <code>NormalDist</code> 来总结数据：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> height_male <span class="token operator">=</span> NormalDist<span class="token punctuation">.</span>from_samples<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">5.92</span><span class="token punctuation">,</span> <span class="token number">5.58</span><span class="token punctuation">,</span> <span class="token number">5.92</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> height_female <span class="token operator">=</span> NormalDist<span class="token punctuation">.</span>from_samples<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">5.5</span><span class="token punctuation">,</span> <span class="token number">5.42</span><span class="token punctuation">,</span> <span class="token number">5.75</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> weight_male <span class="token operator">=</span> NormalDist<span class="token punctuation">.</span>from_samples<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">180</span><span class="token punctuation">,</span> <span class="token number">190</span><span class="token punctuation">,</span> <span class="token number">170</span><span class="token punctuation">,</span> <span class="token number">165</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> weight_female <span class="token operator">=</span> NormalDist<span class="token punctuation">.</span>from_samples<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">150</span><span class="token punctuation">,</span> <span class="token number">130</span><span class="token punctuation">,</span> <span class="token number">150</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> foot_size_male <span class="token operator">=</span> NormalDist<span class="token punctuation">.</span>from_samples<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> foot_size_female <span class="token operator">=</span> NormalDist<span class="token punctuation">.</span>from_samples<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>接下来，我们遇到一个特征测量值已知但性别未知的新人：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> ht <span class="token operator">=</span> <span class="token number">6.0</span>        <span class="token comment" spellcheck="true"># height</span>
<span class="token operator">>></span><span class="token operator">></span> wt <span class="token operator">=</span> <span class="token number">130</span>        <span class="token comment" spellcheck="true"># weight</span>
<span class="token operator">>></span><span class="token operator">></span> fs <span class="token operator">=</span> <span class="token number">8</span>          <span class="token comment" spellcheck="true"># foot size</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>从是男是女各 50% 的 <a href="https://en.wikipedia.org/wiki/Prior_probability" target="_blank" rel="noopener">先验概率</a> 出发，我们通过将该先验概率乘以给定性别的特征度量值的可能性累积值来计算后验概率：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> prior_male <span class="token operator">=</span> <span class="token number">0.5</span>
<span class="token operator">>></span><span class="token operator">></span> prior_female <span class="token operator">=</span> <span class="token number">0.5</span>
<span class="token operator">>></span><span class="token operator">></span> posterior_male <span class="token operator">=</span> <span class="token punctuation">(</span>prior_male <span class="token operator">*</span> height_male<span class="token punctuation">.</span>pdf<span class="token punctuation">(</span>ht<span class="token punctuation">)</span> <span class="token operator">*</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                   weight_male<span class="token punctuation">.</span>pdf<span class="token punctuation">(</span>wt<span class="token punctuation">)</span> <span class="token operator">*</span> foot_size_male<span class="token punctuation">.</span>pdf<span class="token punctuation">(</span>fs<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> posterior_female <span class="token operator">=</span> <span class="token punctuation">(</span>prior_female <span class="token operator">*</span> height_female<span class="token punctuation">.</span>pdf<span class="token punctuation">(</span>ht<span class="token punctuation">)</span> <span class="token operator">*</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                     weight_female<span class="token punctuation">.</span>pdf<span class="token punctuation">(</span>wt<span class="token punctuation">)</span> <span class="token operator">*</span> foot_size_female<span class="token punctuation">.</span>pdf<span class="token punctuation">(</span>fs<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>最终预测值应为最大后验概率值。 这种算法被称为 <a href="https://en.wikipedia.org/wiki/Maximum_a_posteriori_estimation" target="_blank" rel="noopener">maximum a posteriori</a> 或 MAP：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token string">'male'</span> <span class="token keyword">if</span> posterior_male <span class="token operator">></span> posterior_female <span class="token keyword">else</span> <span class="token string">'female'</span>
<span class="token string">'female'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://jackhcc.github.io" rel="external nofollow noreferrer">杰克成</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://jackhcc.github.io/posts/Language-Python-Lib1.html">https://jackhcc.github.io/posts/Language-Python-Lib1.html</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="https://jackhcc.github.io" target="_blank">杰克成</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/Python/">
                                    <span class="chip bg-color">Python</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/share/css/share.min.css">

<div id="article-share">
    
    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/medias/reward/aliqr.png" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/medias/reward/wxqr.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>
            
        </div>
    </div>

    
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/gitalk/gitalk.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/css/my-gitalk.css">

<div class="card gitalk-card" data-aos="fade-up">
    <div class="comment_headling" style="font-size: 20px; font-weight: 700; position: relative; left: 20px; top: 15px; padding-bottom: 5px;">
        <i class="fas fa-comments fa-fw" aria-hidden="true"></i>
        <span>评论</span>
    </div>
    <div id="gitalk-container" class="card-content"></div>
</div>

<script src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/gitalk/gitalk.min.js"></script>
<script>
    let gitalk = new Gitalk({
        clientID: '3821a0bbb773038a51fc',
        clientSecret: '4b30b507d67ec5497ec0e77f43f80cb3e0d7dd3a',
        repo: 'JackHCC.github.io',
        owner: 'JackHCC',
        admin: "JackHCC",
        id: '2021-11-03T19-18-39',
        distractionFreeMode: false  // Facebook-like distraction free mode
    });

    gitalk.render('gitalk-container');
</script>
    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/posts/Language-Python-Lib2.html">
                    <div class="card-image">
                        
                        
                        <img src="/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/medias/featureimages/7.jpg" class="responsive-img" alt="Python-Standard Library">
                        
                        <span class="card-title">Python-Standard Library</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            Python标准库详解【2】
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2021-11-04
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/Python/" class="post-category">
                                    Python
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Python/">
                        <span class="chip bg-color">Python</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/posts/basic-know-006.html">
                    <div class="card-image">
                        
                        
                        <img src="/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/medias/featureimages/7.jpg" class="responsive-img" alt="反爬虫详解">
                        
                        <span class="card-title">反爬虫详解</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            反爬虫机制与方法详解
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2021-11-02
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/Basic/" class="post-category">
                                    Basic
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Crawler/">
                        <span class="chip bg-color">Crawler</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/codeBlock/codeShrink.js"></script>


<!-- 代码块折行 -->

<style type="text/css">
code[class*="language-"], pre[class*="language-"] { white-space: pre !important; }
</style>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('4'),
            headingSelector: 'h1, h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h1, h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>



    <footer class="page-footer bg-color">
    <div class="container row center-align" style="margin-bottom: 15px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            <span id="year">2020</span>
            <a href="https://jackhcc.github.io" target="_blank">杰克成</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                class="white-color">3591.2k</span>&nbsp;字
            
            
            
            
            
            
            <span id="busuanzi_container_site_pv">
                |&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv"
                    class="white-color"></span>&nbsp;次
            </span>
            
            
            <span id="busuanzi_container_site_uv">
                |&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv"
                    class="white-color"></span>&nbsp;人
            </span>
            
            <br>
            
            <span id="sitetime">载入运行时间...</span>
            <script>
                function siteTime() {
                    var seconds = 1000;
                    var minutes = seconds * 60;
                    var hours = minutes * 60;
                    var days = hours * 24;
                    var years = days * 365;
                    var today = new Date();
                    var startYear = "2020";
                    var startMonth = "2";
                    var startDate = "27";
                    var startHour = "6";
                    var startMinute = "30";
                    var startSecond = "0";
                    var todayYear = today.getFullYear();
                    var todayMonth = today.getMonth() + 1;
                    var todayDate = today.getDate();
                    var todayHour = today.getHours();
                    var todayMinute = today.getMinutes();
                    var todaySecond = today.getSeconds();
                    var t1 = Date.UTC(startYear, startMonth, startDate, startHour, startMinute, startSecond);
                    var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
                    var diff = t2 - t1;
                    var diffYears = Math.floor(diff / years);
                    var diffDays = Math.floor((diff / days) - diffYears * 365);
                    var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours);
                    var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) /
                        minutes);
                    var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours -
                        diffMinutes * minutes) / seconds);
                    if (startYear == todayYear) {
                        document.getElementById("year").innerHTML = todayYear;
                        document.getElementById("sitetime").innerHTML = "本站已安全运行 " + diffDays + " 天 " + diffHours +
                            " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                    } else {
                        document.getElementById("year").innerHTML = startYear + " - " + todayYear;
                        document.getElementById("sitetime").innerHTML = "本站已安全运行 " + diffYears + " 年 " + diffDays +
                            " 天 " + diffHours + " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                    }
                }
                setInterval(siteTime, 1000);
            </script>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/JackHCC" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:jackcc0701@163.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>



    <a href="https://www.facebook.com/profile.php?id=100046343443643" class="tooltipped" target="_blank" data-tooltip="关注我的Facebook: https://www.facebook.com/profile.php?id=100046343443643" data-position="top" data-delay="50">
        <i class="fab fa-facebook-f"></i>
    </a>



    <a href="https://twitter.com/JackChe66021834" class="tooltipped" target="_blank" data-tooltip="关注我的Twitter: https://twitter.com/JackChe66021834" data-position="top" data-delay="50">
        <i class="fab fa-twitter"></i>
    </a>



    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=2508074836" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 2508074836" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>



    <a href="https://weibo.com/u/6885584679" class="tooltipped" target="_blank" data-tooltip="关注我的微博: https://weibo.com/u/6885584679" data-position="top" data-delay="50">
        <i class="fab fa-weibo"></i>
    </a>



    <a href="https://www.zhihu.com/people/8f8482f01f0d6a04e844efe32e0f0710" class="tooltipped" target="_blank" data-tooltip="关注我的知乎: https://www.zhihu.com/people/8f8482f01f0d6a04e844efe32e0f0710" data-position="top" data-delay="50">
        <i class="fab fa-zhihu1">知</i>
    </a>



</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/js/search.js"></script>
<script type="text/javascript">
$(function () {
    searchFunc("https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/" + "search.xml", 'searchInput', 'searchResult');
});
</script>
    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/materialize/materialize.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/aos/aos.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/js/matery.js"></script>

    <canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" ></canvas>
    <script type="text/javascript" src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script>
    <script type="text/javascript" src="/js/fireworks.js"></script>

    <script type="text/javascript">
        //只在桌面版网页启用特效
        var windowWidth = $(window).width();
        if (windowWidth > 768) {
            document.write('<script type="text/javascript" src="/js/sakura.js"><\/script>'); }
    </script>

    <!-- weather -->
	<script type="text/javascript">
	WIDGET = {FID: 'TToslpmkVO'}
	</script>
	<script type="text/javascript" src="https://apip.weatherdt.com/float/static/js/r.js?v=1111"></script>


    <!-- Global site tag (gtag.js) - Google Analytics -->


    <!-- Baidu Analytics -->

<script>
    var _hmt = _hmt || [];
    (function () {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
    })();
</script>

    <!-- Baidu Push -->

    
    
    <script async src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/others/busuanzi.pure.mini.js"></script>
    

    
        <script src="//code.tidio.co/kqhlkxviiccyoa0czpfpu4ijuey9hfre.js"></script>
        <script> 
            $(document).ready(function () {
                setInterval(change_Tidio, 50);  
                function change_Tidio() { 
                    var tidio=$("#tidio-chat iframe");
                    if(tidio.css("display")=="block"&& $(window).width()>977 ){
                        document.getElementById("tidio-chat-iframe").style.bottom= ($("div#backTop.top-scroll").css("display")=="none" &&$(window).width()>977)>0? "-40px" : ($("div.toc-title").length&&$(window).width()>977)>0?"85px":"20px";   
                        document.getElementById("tidio-chat-iframe").style.right="-15px";   
                        document.getElementById("tidio-chat-iframe").style.height=parseInt(tidio.css("height"))>=520?"520px":tidio.css("height");
                        document.getElementById("tidio-chat-iframe").style.zIndex="997";
                    } 
                    else if(tidio.css("display")=="block"&&$(window).width()>601 &&$(window).width()<992 ){
                        document.getElementById("tidio-chat-iframe").style.bottom= ($("div#backTop.top-scroll").css("display")=="none" && 601< $(window).width()<992)>0? "-40px":"20px" ;   
                        document.getElementById("tidio-chat-iframe").style.right="-15px"; 
                        document.getElementById("tidio-chat-iframe").style.zIndex="997";
                    }
                    else if(tidio.css("display")=="block"&&$(window).width()<601 && parseInt(tidio.css("height"))<230){
                        document.getElementById("tidio-chat-iframe").style.bottom= ($("div#backTop.top-scroll").css("display")=="none" && $(window).width()<601)>0? "-10px":"45px" ;   
                        document.getElementById("tidio-chat-iframe").style.zIndex="997";
                    }
                    if( tidio.css("display")=="block"&&$(window).width()<601 && parseInt(tidio.css("height"))>=230){
                        document.getElementById("tidio-chat-iframe").style.zIndex="998";
                    }
                } 
            }); 
        </script>
    

    

    
    <script type="text/javascript" color="0,0,255"
        pointColor="0,0,255" opacity='0.7'
        zIndex="-1" count="99"
        src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/background/canvas-nest.js"></script>
    

    

    
    <script type="text/javascript" src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/background/ribbon-dynamic.js" async="async"></script>
    
    
    
    <script src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/instantpage/instantpage.js" type="module"></script>
    

        <script src="//cdn.jsdelivr.net/npm/js-base64/base64.min.js"></script>
        <script>
        $('a').each(function() {
          const $this = $(this);
          const href = $this.attr('href');
          if (href && href.match('^((http|https|thunder|qqdl|ed2k|Flashget|qbrowser|ftp|rtsp|mms)://)')) {
            const strs = href.split('/');
            if (strs.length >= 3) {
                const host = strs[2];
                if (host !== 'your_domain' || window.location.host) {
                    $this.attr('href', '/go.html?u='+Base64.encode(href)+'').attr('rel', 'external nofollow noopener noreferrer');
                    if (true) {
                        $this.attr('target', '_blank');
                    }
                }
            }
          }
        });
        </script><script>!function(e){var c=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));function i(){for(var r=0;r<c.length;r++)t=c[r],0<=(n=t.getBoundingClientRect()).bottom&&0<=n.left&&n.top<=(e.innerHeight||document.documentElement.clientHeight)&&function(){var t,n,e,i,o=c[r];t=o,n=function(){c=c.filter(function(t){return o!==t})},e=new Image,i=t.getAttribute("data-original"),e.onload=function(){t.src=i,n&&n()},e.src=i}();var t,n}i(),e.addEventListener("scroll",function(){var t,n;t=i,n=e,clearTimeout(t.tId),t.tId=setTimeout(function(){t.call(n)},500)})}(this);</script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script></body>

</html>

