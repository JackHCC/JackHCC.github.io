<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="CTF-Reverse要点, JackHCC">
    <meta name="description" content="CTF逆向学习要点">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>CTF-Reverse要点 | JackHCC</title>
    <link rel="icon" type="image/png" href="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/medias/favicon.png">

    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/css/matery.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/css/my.css">
    
    <script src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/jquery/jquery.min.js"></script>
    
<meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="JackHCC" type="application/atom+xml">
<link rel="stylesheet" href="/css/prism-hopscotch.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper head-container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/medias/me.jpg" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">JackHCC</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="" class="waves-effect waves-light">

      
      <i class="fas fa-list" style="zoom: 0.6;"></i>
      
      <span>Tools</span>
      <i class="fas fa-chevron-down" aria-hidden="true" style="zoom: 0.6;"></i>
    </a>
    <ul class="sub-nav menus_item_child ">
      
      <li>
        <a href="https://creativecc.cn/" target="_blank" rel="noopener">
          
          <i class="fas fa-book" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>Creative工具导航</span>
        </a>
      </li>
      
      <li>
        <a href="https://blog.creativecc.cn/Arxiv-NLP-Reporter/" target="_blank" rel="noopener">
          
          <i class="fas fa-film" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>NLP每日论文</span>
        </a>
      </li>
      
      <li>
        <a href="http://chat.creativecc.cn/" target="_blank" rel="noopener">
          
          <i class="fas fa-music" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>RocketChat聊天室</span>
        </a>
      </li>
      
      <li>
        <a href="/contact">
          
          <i class="fas fa-comments" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>Contact留言板</span>
        </a>
      </li>
      
    </ul>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>

<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/medias/me.jpg" class="logo-img circle responsive-img">
        
        <div class="logo-name">JackHCC</div>
        <div class="logo-desc">
            
            Make the world betterrrr!!!
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="javascript:;">
			
				<i class="fa-fw fas fa-list"></i>
			
			Tools
			<span class="m-icon"><i class="fas fa-chevron-right"></i></span>
		</a>
            <ul  style="background:  ;" >
              
                <li>   
				
                  <a href="https://creativecc.cn/ " target="_blank" rel="noopener" style="margin-left:75px";>
				  
				   <i class="fa fas fa-book" style="position: absolute;left:50px" ></i>
			      
		          <span>Creative工具导航</span>
                  </a>
                </li>
              
                <li>   
				
                  <a href="https://blog.creativecc.cn/Arxiv-NLP-Reporter/ " target="_blank" rel="noopener" style="margin-left:75px";>
				  
				   <i class="fa fas fa-film" style="position: absolute;left:50px" ></i>
			      
		          <span>NLP每日论文</span>
                  </a>
                </li>
              
                <li>   
				
                  <a href="http://chat.creativecc.cn/ " target="_blank" rel="noopener" style="margin-left:75px";>
				  
				   <i class="fa fas fa-music" style="position: absolute;left:50px" ></i>
			      
		          <span>RocketChat聊天室</span>
                  </a>
                </li>
              
                <li>   
				
                  <a href="/contact " style="margin-left:75px";>
				  
				   <i class="fa fas fa-comments" style="position: absolute;left:50px" ></i>
			      
		          <span>Contact留言板</span>
                  </a>
                </li>
               
            </ul>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/JackHCC/JackHCC.github.io" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>

        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/JackHCC/JackHCC.github.io" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    
<script src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/cryptojs/crypto-js.min.js"></script>
<script>
    (function() {
        let pwd = '';
        if (pwd && pwd.length > 0) {
            if (pwd !== CryptoJS.SHA256(prompt('请输入访问本文章的密码')).toString(CryptoJS.enc.Hex)) {
                alert('密码错误，将返回主页！');
                location.href = '/';
            }
        }
    })();
</script>




<div class="bg-cover pd-header post-cover" style="background-image: url('https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/medias/featureimages/10.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">CTF-Reverse要点</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        margin: 35px 0 15px 0;
        padding-left: 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        height: calc(100vh - 250px);
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #toc-content .is-active-link::before {
        background-color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 30px;
        bottom: 146px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/CTF-Reverse/">
                                <span class="chip bg-color">CTF-Reverse</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/CTF/" class="post-category">
                                CTF
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2021-08-19
                </div>
                

                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-check fa-fw"></i>更新日期:&nbsp;&nbsp;
                    2021-08-30
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    4.4k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    18 分
                </div>
                

                
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="far fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>

        </div>
        <hr class="clearfix">
        <div class="card-content article-card-content">
            <div id="articleContent">
                <h1 id="软件逆向工程简介"><a href="#软件逆向工程简介" class="headerlink" title="软件逆向工程简介"></a>软件逆向工程简介</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote>
<p>Reverse engineering, also called back engineering, is the process by which a man-made object is deconstructed to reveal its designs, architecture, or to extract knowledge from the object;       ——  from <a href="https://en.wikipedia.org/wiki/Reverse_engineering" target="_blank" rel="noopener">wikipedia</a></p>
</blockquote>
<p>软件代码逆向主要指对软件的结构，流程，算法，代码等进行逆向拆解和分析。</p>
<h2 id="应用领域"><a href="#应用领域" class="headerlink" title="应用领域"></a>应用领域</h2><p>主要应用于软件维护，软件破解，漏洞挖掘，恶意代码分析。</p>
<h2 id="CTF竞赛中的逆向"><a href="#CTF竞赛中的逆向" class="headerlink" title="CTF竞赛中的逆向"></a>CTF竞赛中的逆向</h2><blockquote>
<p>涉及 Windows、Linux、Android 平台的多种编程技术，要求利用常用工具对源代码及二进制文件进行逆向分析，掌握 Android 移动应用APK文件的逆向分析，掌握加解密、内核编程、算法、反调试和代码混淆技术。<br>—— 《全国大学生信息安全竞赛参赛指南》</p>
</blockquote>
<h3 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h3><ul>
<li>熟悉如操作系统，汇编语言，加解密等相关知识</li>
<li>具有丰富的多种高级语言的编程经验</li>
<li>熟悉多种编译器的编译原理</li>
<li>较强的程序理解和逆向分析能力</li>
</ul>
<h2 id="常规逆向流程"><a href="#常规逆向流程" class="headerlink" title="常规逆向流程"></a>常规逆向流程</h2><ol>
<li>使用<code>strings/file/binwalk/IDA</code>等静态分析工具收集信息，并根据这些静态信息进行<code>google/github</code>搜索</li>
<li>研究程序的保护方法，如代码混淆，保护壳及反调试等技术，并设法破除或绕过保护</li>
<li>反汇编目标软件，快速定位到关键代码进行分析</li>
<li>结合动态调试，验证自己的初期猜想，在分析的过程中理清程序功能</li>
<li>针对程序功能，写出对应脚本，求解出flag</li>
</ol>
<h3 id="定位关键代码tips"><a href="#定位关键代码tips" class="headerlink" title="定位关键代码tips"></a>定位关键代码tips</h3><ol>
<li><p>分析控制流</p>
<p> 控制流可以参见IDA生成的控制流程图（CFG），沿着分支循环和函数调用，逐块地阅读反汇编代码进行分析。</p>
</li>
<li><p>利用数据、代码交叉引用</p>
<p> 比如输出的提示字符串，可以通过数据交叉引用找到对应的调用位置，进而找出关键代码。代码交叉引用比如图形界面程序获取用户输入，就可以使用对应的windowsAPI函数，我们就可以通过这些API函数调用位置找到关键代码。</p>
</li>
</ol>
<h3 id="逆向tips"><a href="#逆向tips" class="headerlink" title="逆向tips"></a>逆向tips</h3><ol>
<li><p>编码风格</p>
<p> 每个程序员的编码风格都有所不同，熟悉开发设计模式的同学能更迅速地分析出函数模块功能</p>
</li>
<li><p>集中原则</p>
<p> 程序员开发程序时，往往习惯将功能相关的代码或是数据写在同一个地方，而在反汇编代码中也能显示出这一情况，因此在分析时可以查看关键代码附近的函数和数据。</p>
</li>
<li><p>代码复用</p>
<p> 代码复用情况非常普遍，而最大的源代码仓库Github则是最主要的来源。在分析时可以找一些特征（如字符串，代码风格等）在Github搜索，可能会发现类似的代码，并据此恢复出分析时缺失的符号信息等。</p>
</li>
<li><p>七分逆向三分猜</p>
<p> 合理的猜测往往能事半功倍，遇到可疑函数却看不清里面的逻辑，不妨根据其中的蛛丝马迹猜测其功能，并依据猜测继续向下分析，在不断的猜测验证中，或许能帮助你更加接近代码的真相。</p>
</li>
<li><p>区分代码</p>
<p> 拿到反汇编代码，必须能区分哪些代码是人为编写的，而哪些是编译器自动附加的代码。人为编写的代码中，又有哪些是库函数代码，哪些才是出题人自己写的代码，出题人的代码又经过编译器怎样的优化？我们无须花费时间在出题人以外的代码上，这很重要。如果当你分析半天还在库函数里乱转，那不仅体验极差，也没有丝毫效果。</p>
</li>
<li><p>耐心</p>
<p> 无论如何，给予足够的时间，总是能将一个程序分析地透彻。但是也不应该过早地放弃分析。相信自己肯定能在抽茧剥丝的过程中突破问题。</p>
</li>
</ol>
<h3 id="动态分析"><a href="#动态分析" class="headerlink" title="动态分析"></a>动态分析</h3><p>动态分析的目的在于定位关键代码后，在程序运行的过程中，借由输出信息（寄存器，内存变化，程序输出）等来验证自己的推断或是理解程序功能</p>
<p>主要方法有：调试，符号执行，污点分析</p>
<h3 id="算法和数据结构识别"><a href="#算法和数据结构识别" class="headerlink" title="算法和数据结构识别"></a>算法和数据结构识别</h3><ul>
<li>常用算法识别</li>
</ul>
<p>如<code>Tea/XTea/XXTea/IDEA/RC4/RC5/RC6/AES/DES/IDEA/MD5/SHA256/SHA1</code>等加密算法，大数加减乘除、最短路等传统算法</p>
<ul>
<li>常用数据结构识别</li>
</ul>
<p>如图、树、哈希表等高级数据结构在汇编代码中的识别。</p>
<h3 id="代码混淆"><a href="#代码混淆" class="headerlink" title="代码混淆"></a>代码混淆</h3><p>比如使用<code>OLLVM</code>，<code>movfuscator</code>，<code>花指令</code>，<code>虚拟化</code>及<code>SMC</code>等工具技术对代码进行混淆，使得程序分析十分困难。</p>
<p>那么对应的也有反混淆技术，最主要的目的就是复原控制流。比如<code>模拟执行</code>和<code>符号执行</code></p>
<h3 id="保护壳"><a href="#保护壳" class="headerlink" title="保护壳"></a>保护壳</h3><p>保护壳类型有许多，简单的压缩壳可以归类为如下几种</p>
<ul>
<li><p>unpack -&gt; execute</p>
<p>直接将程序代码全部解压到内存中再继续执行程序代码</p>
</li>
<li><p>unpack -&gt; execute -&gt; unpack -&gt; execute …</p>
<p>解压部分代码，再边解压边执行</p>
</li>
<li><p>unpack -&gt; [decoder | encoded code] -&gt; decode -&gt; execute</p>
<p>程序代码有过编码，在解压后再运行函数将真正的程序代码解码执行</p>
</li>
</ul>
<p>对于脱壳也有相关的方法，比如<code>单步调试法</code>，<code>ESP定律</code>等等</p>
<h3 id="反调试"><a href="#反调试" class="headerlink" title="反调试"></a>反调试</h3><p>反调试意在通过检测调试器等方法避免程序被调试分析。比如使用一些API函数如<code>IsDebuggerPresent</code>检测调试器，使用<code>SEH异常处理</code>，时间差检测等方法。也可以通过覆写调试端口、自调试等方法进行保护。</p>
<h2 id="非常规逆向思路"><a href="#非常规逆向思路" class="headerlink" title="非常规逆向思路"></a>非常规逆向思路</h2><p>非常规逆向题设计的题目范围非常之广，可以是任意架构的任意格式文件。</p>
<ul>
<li>lua/python/java/lua-jit/haskell/applescript/js/solidity/webassembly/etc..</li>
<li>firmware/raw bin/etc..</li>
<li>chip8/avr/clemency/risc-v/etc.</li>
</ul>
<p>但是逆向工程的方法学里不惧怕这些未知的平台格式，遇到这样的非常规题，我们也有一些基本的流程可以通用</p>
<h3 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h3><ul>
<li>阅读文档。快速学习平台语言的方法就是去阅读官方文档。</li>
<li>官方工具。官方提供或建议的工具必然是最合适的工具</li>
<li>教程。在逆向方面，也许有许多前辈写出了专门针对该平台语言的逆向教程，因此也可以快速吸收这其中的知识。</li>
</ul>
<h3 id="找工具"><a href="#找工具" class="headerlink" title="找工具"></a>找工具</h3><p>主要找<code>文件解析工具</code>、<code>反汇编器</code>、<code>调试器</code>和<code>反编译器</code>。其中<code>反汇编器</code>是必需的，<code>调试器</code>也包含有相应的反汇编功能，而对于<code>反编译器</code>则要自求多福了，得之我幸失之我命。</p>
<p>找工具总结起来就是：Google大法好。合理利用Google搜索语法，进行关键字搜索可以帮助你更快更好地找到合适工具。</p>
<h1 id="常见加密算法和编码识别"><a href="#常见加密算法和编码识别" class="headerlink" title="常见加密算法和编码识别"></a>常见加密算法和编码识别</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在对数据进行变换的过程中，除了简单的字节操作之外，还会使用一些常用的编码加密算法，因此如果能够快速识别出对应的编码或者加密算法，就能更快的分析出整个完整的算法。CTF 逆向中通常出现的加密算法包括base64、TEA、AES、RC4、MD5等。</p>
<h2 id="Base64"><a href="#Base64" class="headerlink" title="Base64"></a>Base64</h2><p>Base64 是一种基于64个可打印字符来表示二进制数据的表示方法。转换的时候，将3字节的数据，先后放入一个24位的缓冲区中，先来的字节占高位。数据不足3字节的话，于缓冲器中剩下的比特用0补足。每次取出6比特，按照其值选择<code>ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/</code>中的字符作为编码后的输出，直到全部输入数据转换完成。</p>
<p>通常而言 Base64 的识别特征为索引表，当我们能找到 <code>ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/</code> 这样索引表，再经过简单的分析基本就能判定是 Base64 编码。</p>
<p>当然，有些题目 base64 的索引表是会变的，一些变种的 base64 主要 就是修改了这个索引表。</p>
<h2 id="Tea"><a href="#Tea" class="headerlink" title="Tea"></a>Tea</h2><p>在<a href="https://zh.wikipedia.org/wiki/%E5%AF%86%E7%A0%81%E5%AD%A6" target="_blank" rel="noopener">密码学</a>中，<strong>微型加密算法</strong>（Tiny Encryption Algorithm，TEA）是一种易于描述和<a href="https://zh.wikipedia.org/w/index.php?title=%E6%89%A7%E8%A1%8C&amp;action=edit&amp;redlink=1" target="_blank" rel="noopener">执行</a>的<a href="https://zh.wikipedia.org/wiki/%E5%A1%8A%E5%AF%86%E7%A2%BC" target="_blank" rel="noopener">块密码</a>，通常只需要很少的代码就可实现。其设计者是<a href="https://zh.wikipedia.org/wiki/%E5%89%91%E6%A1%A5%E5%A4%A7%E5%AD%A6" target="_blank" rel="noopener">剑桥大学计算机实验室</a>的<a href="https://zh.wikipedia.org/w/index.php?title=%E5%A4%A7%E5%8D%AB%C2%B7%E6%83%A0%E5%8B%92&amp;action=edit&amp;redlink=1" target="_blank" rel="noopener">大卫·惠勒</a>与<a href="https://zh.wikipedia.org/w/index.php?title=%E7%BD%97%E6%9D%B0%C2%B7%E5%B0%BC%E8%BE%BE%E5%A7%86&amp;action=edit&amp;redlink=1" target="_blank" rel="noopener">罗杰·尼达姆</a>。</p>
<p>参考代码：</p>
<pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdint.h></span></span>

<span class="token keyword">void</span> <span class="token function">encrypt</span> <span class="token punctuation">(</span>uint32_t<span class="token operator">*</span> v<span class="token punctuation">,</span> uint32_t<span class="token operator">*</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    uint32_t v0<span class="token operator">=</span>v<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> v1<span class="token operator">=</span>v<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> sum<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> i<span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">/* set up */</span>
    uint32_t delta<span class="token operator">=</span><span class="token number">0x9e3779b9</span><span class="token punctuation">;</span>                     <span class="token comment" spellcheck="true">/* a key schedule constant */</span>
    uint32_t k0<span class="token operator">=</span>k<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> k1<span class="token operator">=</span>k<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> k2<span class="token operator">=</span>k<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> k3<span class="token operator">=</span>k<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">/* cache key */</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">32</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                       <span class="token comment" spellcheck="true">/* basic cycle start */</span>
        sum <span class="token operator">+</span><span class="token operator">=</span> delta<span class="token punctuation">;</span>
        v0 <span class="token operator">+</span><span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>v1<span class="token operator">&lt;&lt;</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token operator">+</span> k0<span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>v1 <span class="token operator">+</span> sum<span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>v1<span class="token operator">>></span><span class="token number">5</span><span class="token punctuation">)</span> <span class="token operator">+</span> k1<span class="token punctuation">)</span><span class="token punctuation">;</span>
        v1 <span class="token operator">+</span><span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>v0<span class="token operator">&lt;&lt;</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token operator">+</span> k2<span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>v0 <span class="token operator">+</span> sum<span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>v0<span class="token operator">>></span><span class="token number">5</span><span class="token punctuation">)</span> <span class="token operator">+</span> k3<span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token punctuation">}</span>                                              <span class="token comment" spellcheck="true">/* end cycle */</span>
    v<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span>v0<span class="token punctuation">;</span> v<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>v1<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">decrypt</span> <span class="token punctuation">(</span>uint32_t<span class="token operator">*</span> v<span class="token punctuation">,</span> uint32_t<span class="token operator">*</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    uint32_t v0<span class="token operator">=</span>v<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> v1<span class="token operator">=</span>v<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> sum<span class="token operator">=</span><span class="token number">0xC6EF3720</span><span class="token punctuation">,</span> i<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* set up */</span>
    uint32_t delta<span class="token operator">=</span><span class="token number">0x9e3779b9</span><span class="token punctuation">;</span>                     <span class="token comment" spellcheck="true">/* a key schedule constant */</span>
    uint32_t k0<span class="token operator">=</span>k<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> k1<span class="token operator">=</span>k<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> k2<span class="token operator">=</span>k<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> k3<span class="token operator">=</span>k<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">/* cache key */</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span><span class="token number">32</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                         <span class="token comment" spellcheck="true">/* basic cycle start */</span>
        v1 <span class="token operator">-</span><span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>v0<span class="token operator">&lt;&lt;</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token operator">+</span> k2<span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>v0 <span class="token operator">+</span> sum<span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>v0<span class="token operator">>></span><span class="token number">5</span><span class="token punctuation">)</span> <span class="token operator">+</span> k3<span class="token punctuation">)</span><span class="token punctuation">;</span>
        v0 <span class="token operator">-</span><span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>v1<span class="token operator">&lt;&lt;</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token operator">+</span> k0<span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>v1 <span class="token operator">+</span> sum<span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>v1<span class="token operator">>></span><span class="token number">5</span><span class="token punctuation">)</span> <span class="token operator">+</span> k1<span class="token punctuation">)</span><span class="token punctuation">;</span>
        sum <span class="token operator">-</span><span class="token operator">=</span> delta<span class="token punctuation">;</span>                                   
    <span class="token punctuation">}</span>                                              <span class="token comment" spellcheck="true">/* end cycle */</span>
    v<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span>v0<span class="token punctuation">;</span> v<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>v1<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在 Tea 算法中其最主要的识别特征就是 拥有一个 image number ：0x9e3779b9 。当然，这 Tea 算法也有魔改的，感兴趣的可以看 2018 0ctf Quals milk-tea。</p>
<h2 id="RC4"><a href="#RC4" class="headerlink" title="RC4"></a>RC4</h2><p>在<a href="https://zh.wikipedia.org/wiki/%E5%AF%86%E7%A2%BC%E5%AD%B8" target="_blank" rel="noopener">密码学</a>中，<strong>RC4</strong>（来自Rivest Cipher 4的缩写）是一种<a href="https://zh.wikipedia.org/wiki/%E6%B5%81%E5%8A%A0%E5%AF%86" target="_blank" rel="noopener">流加密</a>算法，<a href="https://zh.wikipedia.org/wiki/%E5%AF%86%E9%92%A5" target="_blank" rel="noopener">密钥</a>长度可变。它加解密使用相同的密钥，因此也属于<a href="https://zh.wikipedia.org/wiki/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86" target="_blank" rel="noopener">对称加密算法</a>。RC4是<a href="https://zh.wikipedia.org/wiki/%E6%9C%89%E7%B7%9A%E7%AD%89%E6%95%88%E5%8A%A0%E5%AF%86" target="_blank" rel="noopener">有线等效加密</a>（WEP）中采用的加密算法，也曾经是<a href="https://zh.wikipedia.org/wiki/%E4%BC%A0%E8%BE%93%E5%B1%82%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener">TLS</a>可采用的算法之一。</p>
<pre class="line-numbers language-C"><code class="language-C">void rc4_init(unsigned char *s, unsigned char *key, unsigned long Len) //初始化函数
{
    int i =0, j = 0;
    char k[256] = {0};
    unsigned char tmp = 0;
    for (i=0;i<256;i++) {
        s[i] = i;
        k[i] = key[i%Len];
    }
    for (i=0; i<256; i++) {
        j=(j+s[i]+k[i])%256;
        tmp = s[i];
        s[i] = s[j]; //交换s[i]和s[j]
        s[j] = tmp;
    }
 }

void rc4_crypt(unsigned char *s, unsigned char *Data, unsigned long Len) //加解密
{
    int i = 0, j = 0, t = 0;
    unsigned long k = 0;
    unsigned char tmp;
    for(k=0;k<Len;k++) {
        i=(i+1)%256;
        j=(j+s[i])%256;
        tmp = s[i];
        s[i] = s[j]; //交换s[x]和s[y]
        s[j] = tmp;
        t=(s[i]+s[j])%256;
        Data[k] ^= s[t];
     }
} <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>通过分析初始化代码，可以看出初始化代码中，对字符数组s进行了初始化赋值，且赋值分别递增。之后对s进行了256次交换操作。通过识别初始化代码，可以知道rc4算法。</p>
<p>其伪代码表示为：</p>
<p>初始化长度为256的<a href="https://zh.wikipedia.org/wiki/S%E7%9B%92" target="_blank" rel="noopener">S盒</a>。第一个for循环将0到255的互不重复的元素装入S盒。第二个for循环根据密钥打乱S盒。</p>
<pre class="line-numbers language-c"><code class="language-c">  <span class="token keyword">for</span> i from <span class="token number">0</span> to <span class="token number">255</span>
     S<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token punctuation">:</span><span class="token operator">=</span> i
 endfor
 j <span class="token punctuation">:</span><span class="token operator">=</span> <span class="token number">0</span>
 <span class="token keyword">for</span><span class="token punctuation">(</span> i<span class="token operator">=</span><span class="token number">0</span> <span class="token punctuation">;</span> i<span class="token operator">&lt;</span><span class="token number">256</span> <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
     j <span class="token punctuation">:</span><span class="token operator">=</span> <span class="token punctuation">(</span>j <span class="token operator">+</span> S<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> key<span class="token punctuation">[</span>i mod keylength<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">256</span>
     swap values of S<span class="token punctuation">[</span>i<span class="token punctuation">]</span> and S<span class="token punctuation">[</span>j<span class="token punctuation">]</span>
 endfor<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>下面i,j是两个指针。每收到一个字节，就进行while循环。通过一定的算法（(a),(b)）定位S盒中的一个元素，并与输入字节异或，得到k。循环中还改变了S盒（(c)）。如果输入的是<a href="https://zh.wikipedia.org/wiki/%E6%98%8E%E6%96%87" target="_blank" rel="noopener">明文</a>，输出的就是<a href="https://zh.wikipedia.org/wiki/%E5%AF%86%E6%96%87" target="_blank" rel="noopener">密文</a>；如果输入的是密文，输出的就是明文。</p>
<pre class="line-numbers language-c"><code class="language-c"> i <span class="token punctuation">:</span><span class="token operator">=</span> <span class="token number">0</span>
 j <span class="token punctuation">:</span><span class="token operator">=</span> <span class="token number">0</span>
 <span class="token keyword">while</span> GeneratingOutput<span class="token punctuation">:</span>
     i <span class="token punctuation">:</span><span class="token operator">=</span> <span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> mod <span class="token number">256</span>   <span class="token comment" spellcheck="true">//a</span>
     j <span class="token punctuation">:</span><span class="token operator">=</span> <span class="token punctuation">(</span>j <span class="token operator">+</span> S<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> mod <span class="token number">256</span> <span class="token comment" spellcheck="true">//b</span>
     swap values of S<span class="token punctuation">[</span>i<span class="token punctuation">]</span> and S<span class="token punctuation">[</span>j<span class="token punctuation">]</span>  <span class="token comment" spellcheck="true">//c</span>
     k <span class="token punctuation">:</span><span class="token operator">=</span> inputByte <span class="token operator">^</span> S<span class="token punctuation">[</span><span class="token punctuation">(</span>S<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> S<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">256</span><span class="token punctuation">]</span>
     output K
 endwhile<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>此算法保证每256次循环中S盒的每个元素至少被交换过一次</p>
<h2 id="MD5"><a href="#MD5" class="headerlink" title="MD5"></a>MD5</h2><p><strong>MD5消息摘要算法</strong>（英语：MD5 Message-Digest Algorithm），一种被广泛使用的<a href="https://zh.wikipedia.org/wiki/%E5%AF%86%E7%A2%BC%E9%9B%9C%E6%B9%8A%E5%87%BD%E6%95%B8" target="_blank" rel="noopener">密码散列函数</a>，可以产生出一个128位（16<a href="https://zh.wikipedia.org/wiki/%E5%AD%97%E8%8A%82" target="_blank" rel="noopener">字节</a>）的散列值（hash value），用于确保信息传输完整一致。MD5由美国密码学家<a href="https://zh.wikipedia.org/wiki/%E7%BD%97%E7%BA%B3%E5%BE%B7%C2%B7%E6%9D%8E%E7%BB%B4%E6%96%AF%E7%89%B9" target="_blank" rel="noopener">罗纳德·李维斯特</a>（Ronald Linn Rivest）设计，于1992年公开，用以取代<a href="https://zh.wikipedia.org/wiki/MD4" target="_blank" rel="noopener">MD4</a>算法。这套算法的程序在 <a href="https://tools.ietf.org/html/rfc1321" target="_blank" rel="noopener">RFC 1321</a> 中被加以规范。</p>
<p>伪代码表示为：</p>
<pre><code>/Note: All variables are unsigned 32 bits and wrap modulo 2^32 when calculating
var int[64] r, k

//r specifies the per-round shift amounts
r[ 0..15]：= {7, 12, 17, 22,  7, 12, 17, 22,  7, 12, 17, 22,  7, 12, 17, 22} 
r[16..31]：= {5,  9, 14, 20,  5,  9, 14, 20,  5,  9, 14, 20,  5,  9, 14, 20}
r[32..47]：= {4, 11, 16, 23,  4, 11, 16, 23,  4, 11, 16, 23,  4, 11, 16, 23}
r[48..63]：= {6, 10, 15, 21,  6, 10, 15, 21,  6, 10, 15, 21,  6, 10, 15, 21}

//Use binary integer part of the sines of integers as constants:
for i from 0 to 63
    k[i] := floor(abs(sin(i + 1)) × 2^32)

//Initialize variables:
var int h0 := 0x67452301
var int h1 := 0xEFCDAB89
var int h2 := 0x98BADCFE
var int h3 := 0x10325476

//Pre-processing:
append "1" bit to message
append "0" bits until message length in bits ≡ 448 (mod 512)
append bit length of message as 64-bit little-endian integer to message

//Process the message in successive 512-bit chunks:
for each 512-bit chunk of message
    break chunk into sixteen 32-bit little-endian words w[i], 0 ≤ i ≤ 15

    //Initialize hash value for this chunk:
    var int a := h0
    var int b := h1
    var int c := h2
    var int d := h3

    //Main loop:
    for i from 0 to 63
        if 0 ≤ i ≤ 15 then
            f := (b and c) or ((not b) and d)
            g := i
        else if 16 ≤ i ≤ 31
            f := (d and b) or ((not d) and c)
            g := (5×i + 1) mod 16
        else if 32 ≤ i ≤ 47
            f := b xor c xor d
            g := (3×i + 5) mod 16
        else if 48 ≤ i ≤ 63
            f := c xor (b or (not d))
            g := (7×i) mod 16

        temp := d
        d := c
        c := b
        b := leftrotate((a + f + k[i] + w[g]),r[i]) + b
        a := temp
    Next i
    //Add this chunk's hash to result so far:
    h0 := h0 + a
    h1 := h1 + b 
    h2 := h2 + c
    h3 := h3 + d
End ForEach
var int digest := h0 append h1 append h2 append h3 //(expressed as little-endian)</code></pre><p>其鲜明的特征是：</p>
<pre class="line-numbers language-c"><code class="language-c">    h0 <span class="token operator">=</span> <span class="token number">0x67452301</span><span class="token punctuation">;</span>
    h1 <span class="token operator">=</span> <span class="token number">0xefcdab89</span><span class="token punctuation">;</span>
    h2 <span class="token operator">=</span> <span class="token number">0x98badcfe</span><span class="token punctuation">;</span>
    h3 <span class="token operator">=</span> <span class="token number">0x10325476</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="迷宫问题"><a href="#迷宫问题" class="headerlink" title="迷宫问题"></a>迷宫问题</h1><p>迷宫问题有以下特点:</p>
<ul>
<li>在内存中布置一张 “地图”</li>
<li>将用户输入限制在少数几个字符范围内.</li>
<li>一般只有一个迷宫入口和一个迷宫出口</li>
</ul>
<p>布置的地图可以由可显字符 (比如<code>#</code>和<code>*</code>)组合而成 (这非常明显, 查看字符串基本就知道这是个迷宫题了.), 也可以单纯用不可显的十六进制值进行表示. 可以将地图直接组成一条非常长的字符串, 或是一行一行分开布置. 如果是一行一行分开布置的话, 因为迷宫一般都会比较大, 所以用于按行(注意, 布置并非按顺序布置, 每行都对应一个具体的行号, 你需要确定行号才能还原迷宫地图) 布置迷宫的函数会明显重复多次.</p>
<p>而被限制的字符通常会是一些方便记忆的组合 (不是也没办法), 比如<code>w/s/a/d</code>, <code>h/j/k/l</code>, <code>l/r/u/d</code>这样的类似组合. 当然各个键具体的操作需要经过分析判断 (像那种只用一条字符串表示迷宫的, 就可以用<code>t</code>键表示向右移动<code>12</code>个字符这样). 对于二维的地图, 一般作者都会设置一个<code>X坐标</code>和一个<code>Y坐标</code>用于保存当前位置. 我们也可以根据这个特点来入手分析.</p>
<p>一般情况下, 迷宫是只有 1 个入口和 1 个出口, 像入口在最左上角<code>(0, 0)</code>位置, 而出口在最右下角<code>(max_X, max_Y)</code>处. 但也有可能是出口在迷宫的正中心, 用一个<code>Y</code>字符表示等等. 解答迷宫题的条件也是需要根据具体情况判断的.</p>
<p>当然迷宫的走法可能不止 1 条, 也有情况是有多条走法, 但是要求某一个走法比如说代价最小. 那么这就可以变相为一个算法问题.</p>
<h2 id="Volga-Quals-CTF-2014-Reverse-100"><a href="#Volga-Quals-CTF-2014-Reverse-100" class="headerlink" title="Volga Quals CTF 2014: Reverse 100"></a>Volga Quals CTF 2014: Reverse 100</h2><p>接下来我们以这道题进行示例, 这是一道简单的迷宫题. 该题对地图按行乱序布置, 使用的字符是<code>#</code>和<code>*</code>.</p>
<p>对应的<code>crackme</code>可以点击此处下载: <a href="https://github.com/ctf-wiki/ctf-challenges/blob/master/reverse/maze/2014_volga_quals/rev100" target="_blank" rel="noopener">rev100</a></p>
<p>对应的<code>idb</code>可以点击此处下载: <a href="https://github.com/ctf-wiki/ctf-challenges/blob/master/reverse/maze/2014_volga_quals/rev100.i64" target="_blank" rel="noopener">rev100.i64</a></p>
<p><img src="/images/loading.gif" data-original="../images/CTF/setmaze.png" alt=""></p>
<p>我们可以到<code>.rodata</code>段用光标选择所有的地图字符串, 按下<code>shift+E</code>提取所有的地图数据.</p>
<p><img src="/images/loading.gif" data-original="../images/CTF/extract_maze.png" alt=""></p>
<p>但是目前提取到的地图字符串, 从上往下并非是按顺序的, 因此我们需要回到 IDA 生成的伪 C 代码, 获取行号并重新排序组合起来.</p>
<p>最后得到的完整地图如下:</p>
<p>对应的<code>迷宫地图文件</code>可以点击此处下载: <a href="https://github.com/ctf-wiki/ctf-challenges/blob/master/reverse/maze/2014_volga_quals/maze_array.txt" target="_blank" rel="noopener">maze_array.txt</a></p>
<p><img src="/images/loading.gif" data-original="../images/CTF/maze_origin.png" alt=""></p>
<p>再来看迷宫移动所需要的字符:</p>
<p><img src="/images/loading.gif" data-original="../images/CTF/choice.png" alt=""></p>
<p>这里我们知道, 可以使用的字符有<code>L/R/U/D</code>, 分别对应于<code>左/右/上/下</code>.</p>
<p>再往下看</p>
<p><img src="/images/loading.gif" data-original="../images/CTF/check.png" alt=""></p>
<p>通过调试是可以知道, 这里其实是每次在用户输入<code>L/R/U/D</code>后, 先打印一次你的输入, 然后打印对应的<code>X/Y坐标</code>. 而最后的判定成功的条件, 就是当<code>pos_x == 89 &amp;&amp; pos_y == 28</code>. 那么我们就可以根据上述信息, 获得走出迷宫的路径.</p>
<p><img src="/images/loading.gif" data-original="../images/CTF/maze.jpg" alt=""></p>
<p>最后得到的迷宫路径就是</p>
<pre><code>RDDRRRRRRRRRRRRRRRRRRDDDDDDDDDDRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRUUUUUULLLLLLLLLDDRRRRR</code></pre><h1 id="虚拟机分析"><a href="#虚拟机分析" class="headerlink" title="虚拟机分析"></a>虚拟机分析</h1><p>有关虚拟机分析部分, 我们以一道简单的 crackme 来进行讲解.</p>
<p>对应的<code>crackme</code>可以点击此处下载: <a href="https://github.com/ctf-wiki/ctf-challenges/blob/master/reverse/vm/fuelvm/FuelVM.exe" target="_blank" rel="noopener">FuelVM.exe</a></p>
<p>对应的<code>keygenme</code>可以点击此处下载: <a href="https://github.com/ctf-wiki/ctf-challenges/blob/master/reverse/vm/fuelvm/fuelvm_keygen.py" target="_blank" rel="noopener">fuelvm_keygen.py</a></p>
<p>对应的<code>IDA数据库</code>可以点击此处下载: <a href="https://github.com/ctf-wiki/ctf-challenges/blob/master/reverse/vm/fuelvm/FuelVM.idb" target="_blank" rel="noopener">FuelVM.idb</a></p>
<p>本题作者设计了一个具有多种指令的简单虚拟机. 我们使用 IDA 来进行分析. 并为了方便讲解, 我对反汇编出的一些变量重新进行了命名.</p>
<h2 id="运行程序"><a href="#运行程序" class="headerlink" title="运行程序"></a>运行程序</h2><p>我们运行程序 FuelVM.exe. 界面如下所示</p>
<p><img src="/images/loading.gif" data-original="../images/CTF/start.png" alt=""></p>
<p>在这个界面中, 我们看到右两个输入框, 一个用于输入用户名 Name, 另一个则用于输入密钥 Key. 还有两个按钮, Go 用于提交输入, 而 Exit 则用于退出程序.</p>
<h2 id="获取用户输入"><a href="#获取用户输入" class="headerlink" title="获取用户输入"></a>获取用户输入</h2><p>那么我们就可以从这里入手. 程序想获取用户输入, 需要调用的一个 API 是<code>GetDlgItemTextA()</code></p>
<pre><code>UINT GetDlgItemTextA(
  HWND  hDlg,
  int   nIDDlgItem,
  LPSTR lpString,
  int   cchMax
);</code></pre><p>获取的输入字符串会保存在<code>lpString</code>里. 那么我们就可以打开 IDA 查找有交叉引用<code>GetDlgItemTextA()</code>的地方.</p>
<pre><code>.text:00401142                 push    0Ch             ; cchMax
.text:00401144                 push    offset inputName ; lpString
.text:00401149                 push    3F8h            ; nIDDlgItem
.text:0040114E                 push    [ebp+hWnd]      ; hDlg
.text:00401151                 call    GetDlgItemTextA
.text:00401156                 push    0Ch             ; cchMax
.text:00401158                 push    offset inputKey ; lpString
.text:0040115D                 push    3F9h            ; nIDDlgItem
.text:00401162                 push    [ebp+hWnd]      ; hDlg
.text:00401165                 call    GetDlgItemTextA
.text:0040116A                 mov     var_a, 0
.text:00401171                 call    process_input
.text:00401176                 jmp     short locExit</code></pre><p>如上, IDA 只有这里调用过<code>GetDlgItemTextA</code>并且调用了两次分别获取<code>inputName</code>和<code>inputKey</code>. 随后初始化了一个变量为 0, 因为还不明白这个变量的作用, 因此先重命名为<code>var_a</code>. 之后进行了一次函数调用并 jmp 跳转. 因为 jmp 跳转位置的代码是一些退出程序的代码, 因此我们可以断定上面的这个 call, 是在调用处理用户输入的函数. 因此将 jmp 的位置重命名为<code>locExit</code>, 函数则重命名为<code>process_input</code>.</p>
<h2 id="处理用户输入"><a href="#处理用户输入" class="headerlink" title="处理用户输入"></a>处理用户输入</h2><p>我们进入<code>process_input</code>函数, 该函数仅仅对输入字符串进行了很简单的处理.</p>
<pre class="line-numbers language-c"><code class="language-c">  result <span class="token operator">=</span> <span class="token function">strlength</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>inputName<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span> v1 <span class="token operator">>=</span> <span class="token number">7</span> <span class="token punctuation">)</span>                                <span class="token comment" spellcheck="true">// v1 = length of inputName</span>
  <span class="token punctuation">{</span>
    <span class="token operator">*</span><span class="token punctuation">(</span>_DWORD <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>lenOfName <span class="token operator">=</span> v1<span class="token punctuation">;</span>
    result <span class="token operator">=</span> <span class="token function">strlength</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>inputKey<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span> v2 <span class="token operator">>=</span> <span class="token number">7</span> <span class="token punctuation">)</span>                              <span class="token comment" spellcheck="true">// v2 = length of inputKey</span>
    <span class="token punctuation">{</span>
      i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
      <span class="token keyword">do</span>
      <span class="token punctuation">{</span>
        inputName<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">^</span><span class="token operator">=</span> i<span class="token punctuation">;</span>
        <span class="token operator">++</span>i<span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">while</span> <span class="token punctuation">(</span> i <span class="token operator">&lt;=</span> <span class="token operator">*</span><span class="token punctuation">(</span>_DWORD <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>lenOfName <span class="token punctuation">)</span><span class="token punctuation">;</span>
      unk_4031CE <span class="token operator">=</span> i<span class="token punctuation">;</span>
      dword_4031C8 <span class="token operator">=</span> dword_4035FF<span class="token punctuation">;</span>
      <span class="token function">initVM</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">initVM</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">__debugbreak</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">JUMPOUT</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span>_DWORD <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>word_4012CE<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> result<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>首先是这个<code>strlength()</code>函数. 函数使用<code>cld; repne scasb; not ecx; dec ecx</code>来计算字符串长度并将结果保存在<code>ecx</code>里. 是汇编基础知识就不多介绍. 所以我们将该函数重命名为<code>strlength</code></p>
<pre><code>.text:004011C2 arg_0           = dword ptr  8
.text:004011C2
.text:004011C2                 push    ebp
.text:004011C3                 mov     ebp, esp
.text:004011C5                 mov     edi, [ebp+arg_0]
.text:004011C8                 sub     ecx, ecx
.text:004011CA                 sub     al, al
.text:004011CC                 not     ecx
.text:004011CE                 cld
.text:004011CF                 repne scasb
.text:004011D1                 not     ecx
.text:004011D3                 dec     ecx
.text:004011D4                 leave
.text:004011D5                 retn    4
.text:004011D5 strlength       endp</code></pre><p>而在 IDA 生成的伪 C 代码处有<code>v1</code>和<code>v2</code>, 我对其进行了注解, 可以看汇编, 里面是使用<code>ecx</code>与<code>7</code>进行比较, 而<code>ecx</code>是字符串的长度, 于是我们可以知道, 这里对输入的要求是: <em>inputName 和 inputKey 的长度均不少于 7</em></p>
<p>当<code>inputName</code>和<code>inputKey</code>长度均不少于 7 时, 那么就可以对输入进行简单的变换. 以下是一个循环</p>
<pre class="line-numbers language-c"><code class="language-c">      i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
      <span class="token keyword">do</span>
      <span class="token punctuation">{</span>
        inputName<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">^</span><span class="token operator">=</span> i<span class="token punctuation">;</span>
        <span class="token operator">++</span>i<span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">while</span> <span class="token punctuation">(</span> i <span class="token operator">&lt;=</span> <span class="token operator">*</span><span class="token punctuation">(</span>_DWORD <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>lenOfName <span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>对应的 python 代码即</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">obfuscate</span><span class="token punctuation">(</span>username<span class="token punctuation">)</span><span class="token punctuation">:</span>
    s <span class="token operator">=</span> <span class="token string">""</span>
    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>username<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        s <span class="token operator">+=</span> chr<span class="token punctuation">(</span>ord<span class="token punctuation">(</span>username<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">^</span> i<span class="token punctuation">)</span>
    <span class="token keyword">return</span> s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>函数之后对一些变量进行了赋值 (这些并不重要, 就忽略不讲了.)</p>
<h2 id="注册-SEH"><a href="#注册-SEH" class="headerlink" title="注册 SEH"></a>注册 SEH</h2><pre><code>.text:004012B5                 push    offset seh_handler
.text:004012BA                 push    large dword ptr fs:0
.text:004012C1                 mov     large fs:0, esp
.text:004012C8                 call    initVM
.text:004012CD                 int     3               ; Trap to Debugger</code></pre><p><code>initVM</code>完成的是一些虚拟机启动前的初始化工作 (其实就是对一些寄存器和相关的部分赋初值), 我们之后来讨论. 这里我们关注的是 SEH 部分. 这里注册了一个 SEH 句柄, 异常处理函数我重命名为<code>seh_handler</code>, 并之后使用<code>int 3</code>手动触发异常. 而在<code>seh_handler</code>位置, IDA 并未正确识别出对应的代码</p>
<pre><code>.text:004012D7 seh_handler     db 64h                  ; DATA XREF: process_input+7Do
.text:004012D8                 dd 58Fh, 0C4830000h, 13066804h, 0FF640040h, 35h, 25896400h
.text:004012D8                 dd 0
.text:004012F4                 dd 1B8h, 0F7C93300h, 0F7C033F1h, 0FFC483E1h, 8F64FDEBh
.text:004012F4                 dd 5, 4C48300h, 40133068h, 35FF6400h, 0
.text:0040131C                 dd 258964h, 33000000h, 33198BC9h, 83E1F7C0h, 0FDEBFFC4h
.text:0040131C                 dd 58F64h, 83000000h, 5E6804C4h, 64004013h, 35FFh, 89640000h
.text:0040131C                 dd 25h, 0C033CC00h, 0C483E1F7h, 83FDEBFFh, 4035FF05h, 0D8B0200h
.text:0040131C                 dd 4035FFh, 3000B1FFh, 58F0040h, 4031C8h, 31C83D80h, 750A0040h
.text:0040131C                 dd 0B1FF4176h, 403000h, 31C8058Fh, 3D800040h, 4031C8h</code></pre><p>我们可以点击相应位置按下<code>c</code>键, 将这些数据转换成代码进行识别. (我们需要按下多次 c 键进行转换), 得到如下代码.</p>
<p>如下, 在<code>seh_handler</code>位置, 又用类似的方法注册了一个位于<code>401306h</code>的异常处理函数, 并通过<code>xor ecx,ecx; div ecx</code>手动触发了一个<code>除0异常</code>. 而在<code>loc_401301</code>位置, 这是一个反调试技巧, <code>jmp loc_401301+2</code>会使得<code>EIP</code>转向一条指令中间, 使得无法继续调试. 所以我们可以将<code>00401301~00401306</code>部分的代码<code>nop</code>掉, 然后在<code>00401306</code>位置创建一个新函数<code>seh_handler2</code></p>
<pre><code>seh_handler:                            ; DATA XREF: process_input+7Do
.text:004012D7                 pop     large dword ptr fs:0
.text:004012DE                 add     esp, 4
.text:004012E1                 push    401306h
.text:004012E6                 push    large dword ptr fs:0
.text:004012ED                 mov     large fs:0, esp
.text:004012F4                 mov     eax, 1
.text:004012F9                 xor     ecx, ecx
.text:004012FB                 div     ecx
.text:004012FD                 xor     eax, eax
.text:004012FF                 mul     ecx
.text:00401301
.text:00401301 loc_401301:                             ; CODE XREF: .text:00401304j
.text:00401301                 add     esp, 0FFFFFFFFh
.text:00401304                 jmp     short near ptr loc_401301+2
.text:00401306 ; ---------------------------------------------------------------------------
.text:00401306                 pop     large dword ptr fs:0
.text:0040130D                 add     esp, 4
.text:00401310                 push    401330h
.text:00401315                 push    large dword ptr fs:0
.text:0040131C                 mov     large fs:0, esp
.text:00401323                 xor     ecx, ecx
.text:00401325                 mov     ebx, [ecx]
.text:00401327                 xor     eax, eax
.text:00401329                 mul     ecx</code></pre><p>类似的, 还有<code>401330h</code>重命名为<code>seh_handler3</code>, 而<code>40135Eh</code>是最后一个注册的异常处理函数, 我们可以推测这才是虚拟机真正的 main 函数, 因此我们将<code>40135Eh</code>重命名为<code>vm_main</code>. (有关 SEH 和反调试的部分, 可以推荐大家自己去动态调试一番弄清楚)</p>
<h2 id="恢复堆栈平衡"><a href="#恢复堆栈平衡" class="headerlink" title="恢复堆栈平衡"></a>恢复堆栈平衡</h2><p>我们创建了一个<code>vm_main</code>函数 (重命名后还需要创建函数, IDA 才能识别), 然后按下<code>F5</code>提示失败, 失败的原因则是由于堆栈不平衡导致的. 因此我们可以点击 IDA 菜单项<code>Options-&gt;General</code>在右侧勾选<code>stack pointer</code>. 这样就会显示出对应的栈指针.</p>
<pre><code>.text:004017F2 000                 jmp     vm_main
.text:004017F7     ; ---------------------------------------------------------------------------
.text:004017F7 000                 push    0               ; uType
.text:004017F9 004                 push    offset aError   ; "Error"
.text:004017FE 008                 push    offset Text     ; "The key is wrong."
.text:00401803 00C                 push    0               ; hWnd
.text:00401805 010                 call    MessageBoxA
.text:0040180A
.text:0040180A     locret_40180A:                          ; CODE XREF: vm_main+492j
.text:0040180A 000                 leave
.text:0040180B -04                 leave
.text:0040180C -08                 leave
.text:0040180D -0C                 leave
.text:0040180E -10                 leave
.text:0040180F -14                 leave
.text:00401810 -18                 leave
.text:00401811 -1C                 retn
.text:00401811     vm_main         endp ; sp-analysis failed</code></pre><p>我们来到最下显示不平衡的位置. 最上的<code>jmp vm_main</code>表明虚拟机内在执行一个循环. 而<code>MessageBoxA</code>的调用则是显示最后弹出的错误信息. 而在<code>locret_40180A</code>位置处, 经过多次 leave 堆栈严重不平衡, 因此我们需要手动恢复堆栈平衡.</p>
<p>这里也很简单, 在<code>0040180A</code>位置已经堆栈平衡了 (000), 因此我们只需要将这一句<code>leave</code>修改为<code>retn</code>就可以了. 如下这样</p>
<pre><code>.text:0040180A     locret_40180A:                          ; CODE XREF: vm_main+492j
.text:0040180A 000                 retn
.text:0040180B     ; ---------------------------------------------------------------------------
.text:0040180B 004                 leave
.text:0040180C 004                 leave
.text:0040180D 004                 leave</code></pre><p>然后你就可以发现<code>vm_main</code>可以 F5 生成伪 C 代码了.</p>
<h2 id="虚拟机指令分析"><a href="#虚拟机指令分析" class="headerlink" title="虚拟机指令分析"></a>虚拟机指令分析</h2><p>说实话, 虚拟机的分析部分是一个比较枯燥的还原过程, 你需要比对各个小部分的操作来判断这是一个怎样的指令, 使用的是哪些寄存器. 像这个 crackme 中, vm 进行的是一个<code>取指-译码-执行</code>的循环. <code>译码</code>过程可给予我们的信息最多, 不同的指令都会在这里, 根据它们各自的<code>opcode</code>, 使用<code>if-else if-else</code>分支进行区分. 实际的还原过程并不复杂, 但有可能会因为虚拟机实现的指令数量而显得有些乏味.</p>
<p>最后分析出的结果如下:</p>
<table>
<thead>
<tr>
<th align="left">opcode</th>
<th align="left">value</th>
</tr>
</thead>
<tbody><tr>
<td align="left">push</td>
<td align="left">0x0a</td>
</tr>
<tr>
<td align="left">pop</td>
<td align="left">0x0b</td>
</tr>
<tr>
<td align="left">mov</td>
<td align="left">0x0c</td>
</tr>
<tr>
<td align="left">cmp</td>
<td align="left">0x0d</td>
</tr>
<tr>
<td align="left">inc</td>
<td align="left">0x0e</td>
</tr>
<tr>
<td align="left">dec</td>
<td align="left">0x0f</td>
</tr>
<tr>
<td align="left">and</td>
<td align="left">0x1b</td>
</tr>
<tr>
<td align="left">or</td>
<td align="left">0x1c</td>
</tr>
<tr>
<td align="left">xor</td>
<td align="left">0x1d</td>
</tr>
<tr>
<td align="left">check</td>
<td align="left">0xff</td>
</tr>
</tbody></table>
<p>我们再来看分析后的<code>initVM</code>函数</p>
<pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">initVM</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">int</span> result<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// eax@1</span>

  r1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  r2 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  r3 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  result <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> __int8<span class="token punctuation">)</span>inputName<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> __int8<span class="token punctuation">)</span>cur_index<span class="token punctuation">]</span><span class="token punctuation">;</span>
  r4 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> __int8<span class="token punctuation">)</span>inputName<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> __int8<span class="token punctuation">)</span>cur_index<span class="token punctuation">]</span><span class="token punctuation">;</span>
  vm_sp <span class="token operator">=</span> <span class="token number">0x32</span><span class="token punctuation">;</span>
  vm_pc <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  vm_flags_zf <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  vm_flags_sf <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token operator">++</span>cur_index<span class="token punctuation">;</span>
  <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里有 4 个通用寄存器 (<code>r1/r2/r3/r4</code>), 1 个<code>sp</code>指针和 1 个<code>pc</code>指针, 标志<code>zf</code>和<code>sf</code>. 先前我们不知道的<code>var_a</code>也被重命名为<code>cur_index</code>, 指向的是<code>inputName</code>当前正在处理的字符索引.</p>
<p>对于 VM 实现的多个指令我们就不再多说, 重点来看下<code>check</code>部分的操作.</p>
<pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> __fastcall <span class="token function">check</span><span class="token punctuation">(</span><span class="token keyword">int</span> a1<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">char</span> v1<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// al@1</span>
  <span class="token keyword">int</span> result<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// eax@4</span>

  v1 <span class="token operator">=</span> r1<span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> __int8<span class="token punctuation">)</span>r1 <span class="token operator">&lt;</span> <span class="token number">0x21u</span> <span class="token punctuation">)</span>
    v1 <span class="token operator">=</span> r1 <span class="token operator">+</span> <span class="token number">0x21</span><span class="token punctuation">;</span>
  <span class="token function">LOBYTE</span><span class="token punctuation">(</span>a1<span class="token punctuation">)</span> <span class="token operator">=</span> cur_index<span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span> v1 <span class="token operator">==</span> inputKey<span class="token punctuation">[</span>a1<span class="token punctuation">]</span> <span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> __int8<span class="token punctuation">)</span>cur_index <span class="token operator">>=</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> __int8<span class="token punctuation">)</span>lenOfName <span class="token punctuation">)</span>
      result <span class="token operator">=</span> <span class="token function">MessageBoxA</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> aGoodJobNowWrit<span class="token punctuation">,</span> Caption<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span>
      result <span class="token operator">=</span> <span class="token function">initVM</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">else</span>
  <span class="token punctuation">{</span>
    result <span class="token operator">=</span> <span class="token function">MessageBoxA</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> Text<span class="token punctuation">,</span> Caption<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果<code>r1</code>中的值跟<code>inputKey[cur_index]</code>相等, 那么会继续判断是否已经检查完了整个<code>inputName</code>, 如果没有出错且比对结束, 那么就会弹出<code>Good job! Now write a keygen.</code>的消息框. 否则会继续<code>initVM</code>进入下一轮循环.(出错了当然是弹出消息框提示错误了.)</p>
<p><code>cur_index</code>会在<code>initVM</code>中自增 1, 那么还记得之前在<code>process_input</code>里有执行 2 次<code>initVM</code>吗. 因为有执行 2 次<code>initVM</code>, 所以我们的<code>inputKey</code>的前 2 位可以是任意字符.</p>
<pre><code>      unk_4031CE = i;
      opcode = vm_pc;
      initVM();
      initVM();
      __debugbreak();
      JUMPOUT(*(_DWORD *)&amp;word_4012CE);</code></pre><p>故而我们分析完了整个虚拟机, 便可以开始着手编写<code>Keygen</code>.</p>
<p>对应的<code>keygenme</code>可以点击此处下载: <a href="https://github.com/ctf-wiki/ctf-challenges/blob/master/reverse/vm/fuelvm/fuelvm_keygen.py" target="_blank" rel="noopener">fuelvm_keygen.py</a></p>
<pre><code>$ python2 fuelvm_keygen.py ctf-wiki
[*] Password for user 'ctf-wiki' is: 4mRC*TKJI</code></pre><p>对应的<code>IDA数据库</code>可以点击此处下载: <a href="https://github.com/ctf-wiki/ctf-challenges/blob/master/reverse/vm/fuelvm/FuelVM.idb" target="_blank" rel="noopener">FuelVM.idb</a></p>
<h1 id="Unicorn-Engine-简介"><a href="#Unicorn-Engine-简介" class="headerlink" title="Unicorn Engine 简介"></a>Unicorn Engine 简介</h1><h2 id="什么是-Unicorn-引擎"><a href="#什么是-Unicorn-引擎" class="headerlink" title="什么是 Unicorn 引擎"></a>什么是 Unicorn 引擎</h2><p>Unicorn 是一个轻量级, 多平台, 多架构的 CPU 模拟器框架. 我们可以更好地关注 CPU 操作, 忽略机器设备的差异. 想象一下, 我们可以将其应用于这些情景: 比如我们单纯只是需要模拟代码的执行而非需要一个真的 CPU 去完成那些操作, 又或者想要更安全地分析恶意代码, 检测病毒特征, 或者想要在逆向过程中验证某些代码的含义. 使用 CPU 模拟器可以很好地帮助我们提供便捷.</p>
<p>它的亮点 (这也归功于 Unicorn 是基于 <a href="http://www.qemu.org/" target="_blank" rel="noopener">qemu</a> 而开发的) 有:</p>
<ul>
<li>支持多种架构: Arm, Arm64 (Armv8), M68K, Mips, Sparc, &amp; X86 (include X86_64).</li>
<li>对 Windows 和 <em>nix 系统 (已确认包含 Mac OSX, Linux,</em> BSD &amp; Solaris) 的原生支持</li>
<li>具有平台独立且简洁易于使用的 API</li>
<li>使用 JIT 编译技术, 性能表现优异</li>
</ul>
<p>你可以在 <a href="http://www.unicorn-engine.org/BHUSA2015-unicorn.pdf" target="_blank" rel="noopener">Black Hat USA 2015</a> 获悉有关 Unicorn 引擎的更多技术细节. Github 项目主页: <a href="https://github.com/unicorn-engine/unicorn" target="_blank" rel="noopener">unicorn</a></p>
<p>尽管它不同寻常, 但它无法模拟整个程序或系统, 也不支持系统调用. 你需要手动映射内存并写入数据进去, 随后你才能从指定地址开始模拟.</p>
<h2 id="应用的情景"><a href="#应用的情景" class="headerlink" title="应用的情景"></a>应用的情景</h2><p>什么时候能够用到 Unicorn 引擎呢?</p>
<ul>
<li>你可以调用恶意软件中一些有趣的函数, 而不用创建一个有害的进程.</li>
<li>用于 CTF 竞赛</li>
<li>用于模糊测试</li>
<li>用于 gdb 插件, 基于代码模拟执行的插件</li>
<li>模拟执行一些混淆代码</li>
</ul>
<h2 id="如何安装"><a href="#如何安装" class="headerlink" title="如何安装"></a>如何安装</h2><p>安装 Unicorn 最简单的方式就是使用 pip 安装, 只要在命令行中运行以下命令即可 (这是适合于喜爱用 python 的用户的安装方法, 对于那些想要使用 C 的用户, 则需要去官网查看文档编译源码包):</p>
<pre><code>pip install unicorn</code></pre><p>但如果你想用源代码进行本地编译的话, 你需要在<a href="http://www.unicorn-engine.org/download/" target="_blank" rel="noopener">下载</a>页面中下载源代码包, 然后可以按照以下命令执行:</p>
<ul>
<li>*nix 平台用户</li>
</ul>
<pre><code>$ cd bindings/python
$ sudo make install</code></pre><ul>
<li>Windows 平台用户</li>
</ul>
<pre><code>cd bindings/python
python setup.py install</code></pre><p>对于 Windows, 在执行完上述命令后, 还需要将<a href="http://www.unicorn-engine.org/download/" target="_blank" rel="noopener">下载</a>页面的<code>Windows core engine</code>的所有 dll 文件复制到<code>C:\locationtopython\Lib\site-packages\unicorn</code>位置处.</p>
<h2 id="使用-unicorn-的快速指南"><a href="#使用-unicorn-的快速指南" class="headerlink" title="使用 unicorn 的快速指南"></a>使用 unicorn 的快速指南</h2><p>我们将会展示如何使用 python 调用 unicorn 的 api 以及它是如何轻易地模拟二进制代码. 当然这里用的 api 仅是一小部分, 但对于入门已经足够了.</p>
<pre class="line-numbers language-python"><code class="language-python"> <span class="token number">1</span> <span class="token keyword">from</span> __future__ <span class="token keyword">import</span> print_function
 <span class="token number">2</span> <span class="token keyword">from</span> unicorn <span class="token keyword">import</span> <span class="token operator">*</span>
 <span class="token number">3</span> <span class="token keyword">from</span> unicorn<span class="token punctuation">.</span>x86_const <span class="token keyword">import</span> <span class="token operator">*</span>
 <span class="token number">4</span> 
 <span class="token number">5</span> <span class="token comment" spellcheck="true"># code to be emulated</span>
 <span class="token number">6</span> X86_CODE32 <span class="token operator">=</span> b<span class="token string">"\x41\x4a"</span> <span class="token comment" spellcheck="true"># INC ecx; DEC edx</span>
 <span class="token number">7</span> 
 <span class="token number">8</span> <span class="token comment" spellcheck="true"># memory address where emulation starts</span>
 <span class="token number">9</span> ADDRESS <span class="token operator">=</span> <span class="token number">0x1000000</span>
<span class="token number">10</span> 
<span class="token number">11</span> <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Emulate i386 code"</span><span class="token punctuation">)</span>
<span class="token number">12</span> <span class="token keyword">try</span><span class="token punctuation">:</span>
<span class="token number">13</span>     <span class="token comment" spellcheck="true"># Initialize emulator in X86-32bit mode</span>
<span class="token number">14</span>     mu <span class="token operator">=</span> Uc<span class="token punctuation">(</span>UC_ARCH_X86<span class="token punctuation">,</span> UC_MODE_32<span class="token punctuation">)</span>
<span class="token number">15</span> 
<span class="token number">16</span>     <span class="token comment" spellcheck="true"># map 2MB memory for this emulation</span>
<span class="token number">17</span>     mu<span class="token punctuation">.</span>mem_map<span class="token punctuation">(</span>ADDRESS<span class="token punctuation">,</span> <span class="token number">2</span> <span class="token operator">*</span> <span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">)</span>
<span class="token number">18</span> 
<span class="token number">19</span>     <span class="token comment" spellcheck="true"># write machine code to be emulated to memory</span>
<span class="token number">20</span>     mu<span class="token punctuation">.</span>mem_write<span class="token punctuation">(</span>ADDRESS<span class="token punctuation">,</span> X86_CODE32<span class="token punctuation">)</span>
<span class="token number">21</span> 
<span class="token number">22</span>     <span class="token comment" spellcheck="true"># initialize machine registers</span>
<span class="token number">23</span>     mu<span class="token punctuation">.</span>reg_write<span class="token punctuation">(</span>UC_X86_REG_ECX<span class="token punctuation">,</span> <span class="token number">0x1234</span><span class="token punctuation">)</span>
<span class="token number">24</span>     mu<span class="token punctuation">.</span>reg_write<span class="token punctuation">(</span>UC_X86_REG_EDX<span class="token punctuation">,</span> <span class="token number">0x7890</span><span class="token punctuation">)</span>
<span class="token number">25</span> 
<span class="token number">26</span>     <span class="token comment" spellcheck="true"># emulate code in infinite time &amp; unlimited instructions</span>
<span class="token number">27</span>     mu<span class="token punctuation">.</span>emu_start<span class="token punctuation">(</span>ADDRESS<span class="token punctuation">,</span> ADDRESS <span class="token operator">+</span> len<span class="token punctuation">(</span>X86_CODE32<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token number">28</span> 
<span class="token number">29</span>     <span class="token comment" spellcheck="true"># now print out some registers</span>
<span class="token number">30</span>     <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Emulation done. Below is the CPU context"</span><span class="token punctuation">)</span>
<span class="token number">31</span> 
<span class="token number">32</span>     r_ecx <span class="token operator">=</span> mu<span class="token punctuation">.</span>reg_read<span class="token punctuation">(</span>UC_X86_REG_ECX<span class="token punctuation">)</span>
<span class="token number">33</span>     r_edx <span class="token operator">=</span> mu<span class="token punctuation">.</span>reg_read<span class="token punctuation">(</span>UC_X86_REG_EDX<span class="token punctuation">)</span>
<span class="token number">34</span>     <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">">>> ECX = 0x%x"</span> <span class="token operator">%</span>r_ecx<span class="token punctuation">)</span>
<span class="token number">35</span>     <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">">>> EDX = 0x%x"</span> <span class="token operator">%</span>r_edx<span class="token punctuation">)</span>
<span class="token number">36</span> 
<span class="token number">37</span> <span class="token keyword">except</span> UcError <span class="token keyword">as</span> e<span class="token punctuation">:</span>
<span class="token number">38</span>     <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"ERROR: %s"</span> <span class="token operator">%</span> e<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>运行结果如下:</p>
<pre><code>$ python test1.py 
Emulate i386 code
Emulation done. Below is the CPU context
&gt;&gt;&gt; ECX = 0x1235
&gt;&gt;&gt; EDX = 0x788f</code></pre><p>样例里的注释已经非常直观, 但我们还是对每一行代码做出解释:</p>
<ul>
<li>行号 2~3: 在使用 Unicorn 前导入<code>unicorn</code>模块. 样例中使用了一些 x86 寄存器常量, 所以也需要导入<code>unicorn.x86_const</code>模块</li>
<li>行号 6: 这是我们需要模拟的二进制机器码, 使用十六进制表示, 代表的汇编指令是: “INC ecx” 和 “DEC edx”.</li>
<li>行号 9: 我们将模拟执行上述指令的所在虚拟地址</li>
<li>行号 14: 使用<code>Uc</code>类初始化 Unicorn, 该类接受 2 个参数: 硬件架构和硬件位数 (模式). 在样例中我们需要模拟执行 x86 架构的 32 位代码, 我 们使用变量<code>mu</code>来接受返回值.</li>
<li>行号 17: 使用<code>mem_map</code>方法根据在行号 9 处声明的地址, 映射 2MB 用于模拟执行的内存空间. 所有进程中的 CPU 操作都应该只访问该内存区域. 映射的内存具有默认的读, 写和执行权限.</li>
<li>行号 20: 将需要模拟执行的代码写入我们刚刚映射的内存中. <code>mem_write</code>方法接受 2 个参数: 要写入的内存地址和需要写入内存的代码.</li>
<li>行号 23~24: 使用<code>reg_write</code>方法设置<code>ECX</code>和<code>EDX</code>寄存器的值</li>
<li>行号 27: 使用<code>emu_start</code>方法开始模拟执行, 该 API 接受 4 个参数: 要模拟执行的代码地址, 模拟执行停止的内存地址 (这里是 <code>X86_CODE32</code>的最后 1 字节处), 模拟执行的时间和需要执行的指令数目. 如果我们像样例一样忽略后两个参数, Unicorn 将会默认以无穷时间和无穷指令数目的条件来模拟执行代码.</li>
<li>行号 32~35: 打印输出<code>ECX</code>和<code>EDX</code>寄存器的值. 我们使用函数<code>reg_read</code>来读取寄存器的值.</li>
</ul>
<p>要想查看更多的 python 示例, 可以查看文件夹 <a href="https://github.com/unicorn-engine/unicorn/tree/master/bindings/python" target="_blank" rel="noopener">bindings/python</a> 下的代码. 而 C 的示例则可以查看 <a href="https://github.com/unicorn-engine/unicorn/tree/master/samples" target="_blank" rel="noopener">sample</a> 文件夹下的代码.</p>
<h1 id="LD-PRELOAD"><a href="#LD-PRELOAD" class="headerlink" title="LD_PRELOAD"></a>LD_PRELOAD</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>正常情况下, Linux 动态加载器<code>ld-linux</code>(见 man 手册 ld-linux(8)) 会搜寻并装载程序所需的共享链接库文件, 而<code>LD_PRELOAD</code>是一个可选的环境变量, 包含一个或多个指向共享链接库文件的路径. 加载器会先于 C 语言运行库之前载入<code>LD_PRELOAD</code>指定的共享链接库，也就是所谓的预装载 (<code>preload</code>)。</p>
<p>预装载意味着会它的函数会比其他库文件中的同名函数先于调用, 也就使得库函数可以被阻截或替换掉. 多个共享链接库文件的路径可以用<code>冒号</code>或<code>空格</code>进行区分. 显然不会受到<code>LD_PRELOAD</code>影响的也就只有那些静态链接的程序了.</p>
<p>当然为避免用于恶意攻击, 在<code>ruid != euid</code>的情况下加载器是不会使用<code>LD_PRELOAD</code>进行预装载的.</p>
<p>更多阅读: <a href="https://blog.fpmurphy.com/2012/09/all-about-ld_preload.html#ixzz569cbyze4" target="_blank" rel="noopener">https://blog.fpmurphy.com/2012/09/all-about-ld_preload.html#ixzz569cbyze4</a></p>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p>下面以 2014 年<code>Hack In The Box Amsterdam: Bin 100</code>为例. 题目下载链接: <a href="https://github.com/ctf-wiki/ctf-challenges/blob/master/reverse/linux-re/2014_hitb/hitb_bin100.elf" target="_blank" rel="noopener">hitb_bin100.elf</a></p>
<p>这是一个 64 位的 ELF 文件. 运行结果如下图所示:</p>
<p><img src="/images/loading.gif" data-original="../images/CTF/run.png" alt=""></p>
<p>程序似乎在一直打印着一些句子. 并且没有停止下来的迹象. 我们就用 IDA 打开来看一下. 首先按下<code>Shift+F12</code>查找字符串.</p>
<p><img src="/images/loading.gif" data-original="../images/CTF/ida_strings.png" alt=""></p>
<p>显然, 除开一直在打印的句子外, 我们发现了一些有趣的字符串:</p>
<pre><code>.rodata:0000000000400A53 00000006 C KEY:
.rodata:0000000000400A5F 0000001F C OK YOU WIN. HERE'S YOUR FLAG:</code></pre><p>我们根据<code>OK YOU WIN. HERE'S YOUR FLAG:</code>的交叉引用来到关键代码处 (我删去了一些不必要的代码).</p>
<pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> __cdecl <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>envp<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token function">qmemcpy</span><span class="token punctuation">(</span>v23<span class="token punctuation">,</span> <span class="token operator">&amp;</span>unk_400A7E<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>v23<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  v3 <span class="token operator">=</span> v22<span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span> i <span class="token operator">=</span> <span class="token number">9LL</span><span class="token punctuation">;</span> i<span class="token punctuation">;</span> <span class="token operator">--</span>i <span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
    <span class="token operator">*</span><span class="token punctuation">(</span>_DWORD <span class="token operator">*</span><span class="token punctuation">)</span>v3 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    v3 <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  v20 <span class="token operator">=</span> <span class="token number">0x31337</span><span class="token punctuation">;</span>
  v21 <span class="token operator">=</span> <span class="token function">time</span><span class="token punctuation">(</span><span class="token number">0LL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">do</span>
  <span class="token punctuation">{</span>
    v11 <span class="token operator">=</span> <span class="token number">0LL</span><span class="token punctuation">;</span>
    <span class="token keyword">do</span>
    <span class="token punctuation">{</span>
      v5 <span class="token operator">=</span> <span class="token number">0LL</span><span class="token punctuation">;</span>
      v6 <span class="token operator">=</span> <span class="token function">time</span><span class="token punctuation">(</span><span class="token number">0LL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">srand</span><span class="token punctuation">(</span><span class="token number">233811181</span> <span class="token operator">-</span> v21 <span class="token operator">+</span> v6<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 初始化随机数种子</span>
      v7 <span class="token operator">=</span> v22<span class="token punctuation">[</span>v11<span class="token punctuation">]</span><span class="token punctuation">;</span>
      v22<span class="token punctuation">[</span>v11<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">^</span> v7<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 伪随机数</span>
      v8 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>funny<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">8</span> <span class="token operator">*</span> v11<span class="token punctuation">]</span><span class="token punctuation">;</span>
      <span class="token keyword">while</span> <span class="token punctuation">(</span> v5 <span class="token operator">&lt;</span> <span class="token function">strlen</span><span class="token punctuation">(</span>v8<span class="token punctuation">)</span> <span class="token punctuation">)</span>
      <span class="token punctuation">{</span>
        v9 <span class="token operator">=</span> v8<span class="token punctuation">[</span>v5<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token punctuation">(</span>_BYTE<span class="token punctuation">)</span>v9 <span class="token operator">==</span> <span class="token number">105</span> <span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
          v24<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token keyword">signed</span> <span class="token keyword">int</span><span class="token punctuation">)</span>v5<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">105</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">else</span>
        <span class="token punctuation">{</span>
          <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token punctuation">(</span>_DWORD<span class="token punctuation">)</span>v5 <span class="token operator">&amp;&amp;</span> v8<span class="token punctuation">[</span>v5 <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">32</span> <span class="token punctuation">)</span>
            v10 <span class="token operator">=</span> <span class="token function">__ctype_toupper_loc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 大写</span>
          <span class="token keyword">else</span>
            v10 <span class="token operator">=</span> <span class="token function">__ctype_tolower_loc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 小写</span>
          v24<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token keyword">signed</span> <span class="token keyword">int</span><span class="token punctuation">)</span>v5<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>v10<span class="token punctuation">)</span><span class="token punctuation">[</span>v9<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token operator">++</span>v5<span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      v24<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token keyword">signed</span> <span class="token keyword">int</span><span class="token punctuation">)</span>v5<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
      <span class="token operator">++</span>v11<span class="token punctuation">;</span>
      <span class="token function">__printf_chk</span><span class="token punctuation">(</span><span class="token number">1LL</span><span class="token punctuation">,</span> <span class="token string">" 鈾%80s 鈾玕n"</span><span class="token punctuation">,</span> v24<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 乱码的其实是一个音符</span>
      <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1u</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span> v11 <span class="token operator">!=</span> <span class="token number">36</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">--</span>v20<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span> v20 <span class="token punctuation">)</span><span class="token punctuation">;</span>
  v13 <span class="token operator">=</span> v22<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// key存储在v22数组内</span>
  <span class="token function">__printf_chk</span><span class="token punctuation">(</span><span class="token number">1LL</span><span class="token punctuation">,</span> <span class="token string">"KEY: "</span><span class="token punctuation">,</span> v12<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">do</span>
  <span class="token punctuation">{</span>
    v14 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> __int8<span class="token punctuation">)</span><span class="token operator">*</span>v13<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token function">__printf_chk</span><span class="token punctuation">(</span><span class="token number">1LL</span><span class="token punctuation">,</span> <span class="token string">"%02x "</span><span class="token punctuation">,</span> v14<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出key</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span> v13 <span class="token operator">!=</span> v23 <span class="token punctuation">)</span><span class="token punctuation">;</span>
  v15 <span class="token operator">=</span> <span class="token number">0LL</span><span class="token punctuation">;</span>
  <span class="token function">putchar</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">__printf_chk</span><span class="token punctuation">(</span><span class="token number">1LL</span><span class="token punctuation">,</span> <span class="token string">"OK YOU WIN. HERE'S YOUR FLAG: "</span><span class="token punctuation">,</span> v16<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">do</span>
  <span class="token punctuation">{</span>
    v17 <span class="token operator">=</span> v23<span class="token punctuation">[</span>v15<span class="token punctuation">]</span> <span class="token operator">^</span> v22<span class="token punctuation">[</span>v15<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 跟key的值有异或</span>
    <span class="token operator">++</span>v15<span class="token punctuation">;</span>
    <span class="token function">putchar</span><span class="token punctuation">(</span>v17<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 输出flag</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span> v15 <span class="token operator">!=</span> <span class="token number">36</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">putchar</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 输出换行</span>
  result <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>整个的代码流程主要就是在不断地循环输出<code>funny</code>里的句子, 满足循环条件后输出<code>key</code>, 并用<code>key</code>进行异或得到<code>flag</code>的值.</p>
<p>但我们可以发现, 整个循环的次数相对来说是比较少的. 所以我们可以采用一些方法, 让循环进行得更快一些. 比如说我手动 patch 一下, 不让程序输出字符串 (实际上<code>printf</code>的耗时是相当多的), 其次就是使用<code>LD_PRELOAD</code>使得程序的<code>sleep()</code>失效. 可以很明显地节省时间.</p>
<p>手动 patch 的过程比较简单. 我们可以找到代码位置, 然后用一些十六进制编辑器进行修改. 当然我们也可以使用<code>IDA</code>来进行 patch 工作.</p>
<pre><code>.text:00000000004007B7                 call    ___printf_chk
.text:00000000004007BC                 xor     eax, eax</code></pre><p>将光标点在<code>call ___printf_chk</code>上, 然后选择菜单<code>Edit-&gt;Patch Program-&gt;Assemble</code>(当然你可以使用其他 patch 方式. 效果都一样). 然后将其修改为<code>nop(0x90)</code>, 如下图所示</p>
<p><img src="/images/loading.gif" data-original="../images/CTF/ida_patch.png" alt=""></p>
<p>将<code>4007B7</code>到<code>4007BD</code>之间的汇编代码全部修改为<code>nop</code>即可. 然后选择菜单<code>Edit-&gt;Patch Program-&gt;Apply patches to input file</code>. 当然最好做一个备份 (即勾选<code>Create a backup</code>), 然后点击 OK 即可 (我重命名为了<code>patched.elf</code>, 下载链接: <a href="https://github.com/ctf-wiki/ctf-challenges/blob/master/reverse/linux-re/2014_hitb/patched.elf" target="_blank" rel="noopener">patched.elf</a>).</p>
<p><img src="/images/loading.gif" data-original="../images/CTF/ida_apply.png" alt=""></p>
<p>现在进入<code>LD_PRELOAD</code>部分. 这里我们简单编写一下 c 代码, 下载链接: <a href="https://github.com/ctf-wiki/ctf-challenges/blob/master/reverse/linux-re/2014_hitb/time.c" target="_blank" rel="noopener">time.c</a></p>
<pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> t <span class="token operator">=</span> <span class="token number">0x31337</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token keyword">int</span> sec<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    t <span class="token operator">+</span><span class="token operator">=</span> sec<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">time</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> t<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>然后使用命令<code>gcc --shared time.c -o time.so</code>生成动态链接文件. 当然也给出了下载链接: <a href="https://github.com/ctf-wiki/ctf-challenges/blob/master/reverse/linux-re/2014_hitb/time.so" target="_blank" rel="noopener">time.so</a></p>
<p>然后打开 linux 终端, 运行命令: <code>LD_PRELOAD=./time.so ./patched.elf</code></p>
<p><img src="/images/loading.gif" data-original="../images/CTF/ld_preload.png" alt=""></p>
<p>过一会, 你就能听到 CPU 疯狂运转的声音, 然后很快就出来了 flag.</p>
<h1 id="False-Disassembly"><a href="#False-Disassembly" class="headerlink" title="False Disassembly"></a>False Disassembly</h1><p>对于一些常用的反汇编器, 如<code>objdump</code>, 或是基于<code>objdump</code>的反汇编器项目. 都存在一些反汇编的缺陷. 有一些方式可以让<code>objdump</code>反汇编出的代码, 并没有那么的准确.</p>
<h2 id="跳到一条指令中间"><a href="#跳到一条指令中间" class="headerlink" title="跳到一条指令中间"></a>跳到一条指令中间</h2><p>最简单的方法就是利用<code>jmp</code>跳转到某一条指令中间执行, 也就是说真实的代码是从某条指令 “之中” 开始的, 但在反汇编时由于是针对整条指令而不能列出真正被运行的汇编指令代码.</p>
<p>说起来好像很拗口, 很难懂, 我们来看一个示例吧, 给出以下的汇编代码.</p>
<pre><code>start:
    jmp label+1
label:  
    DB 0x90
    mov eax, 0xf001</code></pre><p>这段代码<code>label</code>所在的第一条指令是<code>DB 0x90</code>. 我们来看看<code>objdump</code>对这段代码反汇编的结果:</p>
<pre><code>08048080 &lt;start&gt;:
  8048080:  e9 01 00 00 00  jmp 8048086 &lt;label+0x1&gt;
08048085 &lt;label&gt;:
  8048085:  90      nop
  8048086:  b8 01 f0 00 00  mov eax,0xf001</code></pre><p>看起来也没什么问题, <code>DB 0x90</code>被准确地反汇编成<code>90 nop</code>.</p>
<p>但是如果我们将<code>nop</code>指令修改为 1 字节以上的指令, 那么 objdump 就不会跟随我们的 jump 并正确的反汇编, 而是线性地从上往下继续汇编 (线性扫描算法). 比如我将<code>DB 0x90</code>改成了<code>DB 0xE9</code>, 来看看 objdump 再次反汇编的结果:</p>
<pre><code>08048080 &lt;start&gt;:
  8048080:  e9 01 00 00 00  jmp 8048086 &lt;label+0x1&gt;
08048085 &lt;label&gt;:
  8048085:  e9 b8 01 f0 00  jmp 8f48242 &lt;__bss_start+0xeff1b6&gt;</code></pre><p>对比之前的反汇编结果, 你很明显地看出来是什么情况了吧. <code>DB 0xE9</code>单纯只是一个数据, 也不会被执行, 而反汇编出的结果, 却将其视作一个指令, 之后的结果也因此而改变了.</p>
<p>objdump<code>忽略了jmp的目的地址处的代码</code>并直接汇编 jmp 后的指令, 这样我们真正的代码也就被很好地 “隐藏” 了起来</p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>该如何解决这个问题呢? 看起来最直接的方法就是将这个无用的<code>0xE9</code>用十六进制编辑器手动替换成<code>0x90</code>. 但是如果程序有进行文件校验, 计算 checksum 值, 那么这个方法就行不通了.</p>
<p>所以更好的解决办法是使用如 IDA 或类似有做控制流分析的反汇编器, 对于同样有问题的程序. 反汇编结果可能如下:</p>
<pre><code>  ---- section .text ----:
08048080    E9 01 00 00 00  jmp Label_08048086
                                                ; (08048086)
                                                ; (near + 0x1)
08048085    DB E9

Label_08048086:
08048086    B8 01 F0 00 00  mov eax, 0xF001
                                                ; xref ( 08048080 ) </code></pre><p>反汇编结果看上去还行</p>
<h2 id="运行时计算跳转地址"><a href="#运行时计算跳转地址" class="headerlink" title="运行时计算跳转地址"></a>运行时计算跳转地址</h2><p>这种方法, 甚至可以对抗分析控制流的反汇编器. 我们可以看一个示例代码, 更好地理解:</p>
<pre><code>; ----------------------------------------------------------------------------
    call earth+1
Return:
                    ; x instructions or random bytes here               x byte(s)
earth:              ; earth = Return + x
    xor eax, eax    ; align disassembly, using single byte opcode       1 byte
    pop eax         ; start of function: get return address ( Return )  1 byte
                    ; y instructions or random bytes here               y byte(s)
    add eax, x+2+y+2+1+1+z ; x+y+z+6                                    2 bytes
    push eax        ;                                                   1 byte
    ret             ;                                                   1 byte
                    ; z instructions or random bytes here               z byte(s)
; Code:
                    ; !! Code Continues Here !!
; ----------------------------------------------------------------------------</code></pre><p>程序通过<code>call+pop</code>来获取调用函数当时保存到栈上的返回地址, 其实就是调用函数前的<code>EIP</code>. 然后在函数返回处塞入垃圾数据. 但实际上在函数运行时已经将返回地址修改到了 Code 处. 因此<code>earth</code>函数返回会跳转到<code>Code</code>处继续运行，而不是<code>Return</code>处继续运行.</p>
<p>来看一个简易的 demo</p>
<pre><code>; ----------------------------------------------------------------------------
    call earth+1
earth:  
    DB 0xE9             ; 1 &lt;--- pushed return address,
                        ; E9 is opcode for jmp to disalign disas-
    ; sembly
    pop eax             ; 1 hidden
    nop                 ; 1
    add eax, 9          ; 2 hidden
    push eax            ; 1 hidden
    ret                 ; 1 hidden
    DB 0xE9             ; 1 opcode for jmp to misalign disassembly
Code:                   ; code continues here &lt;--- pushed return address + 9
    nop
    nop
    nop
    ret
; ----------------------------------------------------------------------------</code></pre><p>如果是使用 objdump 进行反汇编, 光是<code>call earth+1</code>就会出现问题, 如下:</p>
<pre><code>00000000 &lt;earth-0x5&gt;:
  0:    e8 01 00 00 00  call 6 &lt;earth+0x1&gt;
00000005 &lt;earth&gt;:
  5:    e9 58 90 05 09  jmp 9059062 &lt;earth+0x905905d&gt;
  a:    00 00           add %al,(%eax)
  c:    00 50 c3        add %dl,0xffffffc3(%eax)
  f:    e9 90 90 90 c3  jmp c39090a4 &lt;earth+0xc390909f&gt;</code></pre><p>来看一下<code>ida</code>的情况</p>
<pre><code>text:08000000   ; Segment permissions: Read/Execute
.text:08000000   _text  segment para public 'CODE' use32
.text:08000000      assume cs:_text
.text:08000000      ;org 8000000h
.text:08000000      assume  es:nothing, ss:nothing, ds:_text,
.text:08000000          fs:nothing, gs:nothing
.text:08000000      dd 1E8h
.text:08000004 ; -------------------------------------------------------------
.text:08000004      add cl, ch
.text:08000006      pop eax
.text:08000007      nop
.text:08000008      add eax, 9
.text:0800000D      push eax
.text:0800000E      retn
.text:0800000E ; -------------------------------------------------------------
.text:0800000F      dd 909090E9h
.text:08000013 ; -------------------------------------------------------------
.text:08000013      retn
.text:08000013 _text        ends
.text:08000013
.text:08000013
.text:08000013      end</code></pre><p>我们在最后的 3 个<code>nop</code>, 都被很好的隐藏起来. 不仅如此, 我们计算<code>EIP</code>的过程也被完美的隐藏了起来. 实际上整个反汇编的代码已经跟实际代码完全不同.</p>
<p>如何解决这项问题? 实际上并没有能够保证<code>100%</code>准确反汇编的工具, 当反汇编器做到代码模拟执行的时候也许能做到完全正确的汇编.</p>
<p>在现实情况, 这并不是特别大的问题. 因为针对交互性反汇编器. 你是可以指定代码起始的位置. 而且当调试的时候, 也能很好的看明白程序实际跳转的地址.</p>
<p>所以此时我们除开需要静态分析, 也需要动态调试.</p>
<blockquote>
<p>Reference: <a href="http://www.stonedcoder.org/~kd/lib/14-61-1-PB.pdf" target="_blank" rel="noopener">Beginners Guide to Basic Linux Anti Anti Debugging Techniques</a></p>
</blockquote>
<h1 id="Detecting-Breakpoints"><a href="#Detecting-Breakpoints" class="headerlink" title="Detecting Breakpoints"></a>Detecting Breakpoints</h1><p>gdb 通过替换目标地址的字节为<code>0xcc</code>来实现断点, 这里给出一个简单的检测<code>int 3</code>断点的示例:</p>
<pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Hello\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">volatile</span> <span class="token keyword">unsigned</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span><span class="token punctuation">)</span>foo<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0xff</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0xcc</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"BREAKPOINT\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>正常运行程序会输出 Hello, 但是如果之前有在<code>foo</code>函数这里设置<code>cc</code>断点并运行, gdb 则无法断下, 并会输出<code>BREAKPOINT</code>.</p>
<pre><code># gdb ./x
gdb&gt; bp foo
Breakpoint 1 at 0x804838c
gdb&gt; run
BREAKPOINT
Program exited with code 01.</code></pre><p>这个要绕过也很简单, 那就是需要阅读汇编代码并注意设置断点不要在<code>foo</code>函数入口处. 实际情况就要看检测断点的位置是哪里.</p>
<p>这种监视断点的反调试技术, 关键不在于如何绕过它, 而是在于如何检测它. 在这个示例中可以很轻松的发现, 程序也有打印出相应的信息. 在实际情况中, 程序不会输出任何信息, 断点也无法轻易地断下. 我们可以使用<code>perl</code>脚本过滤反汇编代码中有关<code>0xcc</code>的代码出来进行检查.</p>
<p>我们可以使用 perl 脚本过滤反汇编代码中有关 0xcc 的代码出来进行检查</p>
<pre class="line-numbers language-c"><code class="language-c">#<span class="token operator">!</span><span class="token operator">/</span>usr<span class="token operator">/</span>bin<span class="token operator">/</span>perl
<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>$_ <span class="token operator">=</span><span class="token operator">~</span> m<span class="token operator">/</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token operator">-</span>9a<span class="token operator">-</span>f<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">:</span>\s<span class="token operator">*</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token operator">-</span>9a<span class="token operator">-</span>f \t<span class="token punctuation">]</span><span class="token operator">*</span><span class="token punctuation">.</span><span class="token operator">*</span><span class="token number">0xcc</span><span class="token punctuation">)</span><span class="token operator">/</span> <span class="token punctuation">)</span><span class="token punctuation">{</span> print<span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>显示结果</p>
<pre><code># objdump -M intel -d xxx | ./antibp.pl
      80483be: 3d cc 00 00 00 cmp eax,0xcc</code></pre><p>检测到后, 既可以将 0xcc 修改成 0x00 或 0x90, 也可以做任何你想做的操作.</p>
<p>改变 0xcc 也同样可能带来问题, 就如上篇介绍一样, 程序如果有进行文件校验, 那么我们的改变是会被检测到的. 可能的情况下, 程序也不只是对函数入口点进行检测, 也会在一个循环里对整个函数进行检测.</p>
<p>因此你也可以用十六进制编辑器手动放置一个<code>ICEBP(0xF1)</code>字节到需要断下的位置 (而非<code>int 3</code>). 因为<code>ICEBP</code>也一样能让 gdb 断下来.</p>
<blockquote>
<p>Reference: <a href="http://www.stonedcoder.org/~kd/lib/14-61-1-PB.pdf" target="_blank" rel="noopener">Beginners Guide to Basic Linux Anti Anti Debugging Techniques</a></p>
</blockquote>
<h1 id="Detecting-debugging"><a href="#Detecting-debugging" class="headerlink" title="Detecting debugging"></a>Detecting debugging</h1><p>检测调试器的方法很多, 比如检测进程名之类. 这里我们介绍一种方法, 就是通过检测一些函数的调用情况来分析程序当前是否处于被调试状态</p>
<pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">ptrace</span><span class="token punctuation">(</span>PTRACE_TRACEME<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"DEBUGGING... Bye\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Hello\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>一个进程只能被一个进程 ptrace, 如果你自己调用 ptrace, 那么其它程序就无法通过 ptrace 调试或向你的程序注入代码.</p>
<p>如果程序当前被 gdb 调试, 那么 ptrace 函数就会返回错误, 也就侧面表明了检测到了调试器的存在.</p>
<h2 id="绕过方法-1"><a href="#绕过方法-1" class="headerlink" title="绕过方法 1"></a>绕过方法 1</h2><p>显然 ptrace 只能作用于使用 ptrace 的调试器, 我们可以用不使用 ptrace 的调试器.</p>
<p>我们也可以通过打补丁的方式将 ptrace 函数擦除, 更简单就是将 ptrace 的调用代码或是之后的校验给擦除了.</p>
<p>如果可执行文件 (实际情况下不太可能) 在编译时并没有启用 - s 选项(-s 选项能移除所有的符号表信息和重定位信息), 那么情况会变得简单很多. 我们从这个简单的情况来分析</p>
<pre><code># objdump -t test_debug | grep ptrace
080482c0    F *UND*     00000075    ptrace@@GLIBC_2.0</code></pre><p>ptrace 在<code>0x080482c0</code>位置被调用</p>
<pre><code># objdump -d -M intel test_debug |grep 80482c0
80482c0:    ff 25 04 96 04 08   jmp ds:0x8049604
80483d4:    e8 e7 fe ff ff  call 80482c0 &lt;_init+0x28&gt;</code></pre><p>那要是有启用 - s 选项, 该怎么处理呢? 这时我们需要使用 gdb</p>
<pre><code># gdb test_debug
gdb&gt; bp ptrace
Breakpoint 1 at 0x80482c0
gdb&gt; run
Breakpoint 1 at 0x400e02f0
......
0x400e02f0 &lt;ptrace&gt;: push %ebp
0x400e02f1 &lt;ptrace+1&gt;: mov %esp,%ebp
0x400e02f3 &lt;ptrace+3&gt;: sub $0x10,%esp
0x400e02f6 &lt;ptrace+6&gt;: mov %edi,0xfffffffc(%ebp)
0x400e02f9 &lt;ptrace+9&gt;: mov 0x8(%ebp),%edi
0x400e02fc &lt;ptrace+12&gt;: mov 0xc(%ebp),%ecx
------------------------------------------------------------------------------
Breakpoint 1, 0x400e02f0 in ptrace () from /lib/tls/libc.so.6</code></pre><p>我们简单地断在了 ptrace 处, 现在输入 finish 执行到当前函数返回, 回到 main 函数里</p>
<pre><code># gdb test_debug
gdb&gt; finish
00x80483d9 &lt;main+29&gt;:   add $0x10,%esp
0x80483dc   &lt;main+32&gt;:  test %eax,%eax
0x80483de   &lt;main+34&gt;:  jns 0x80483fa &lt;main+62&gt;
0x80483e0   &lt;main+36&gt;:  sub $0xc,%esp
0x80483e3   &lt;main+39&gt;:  push $0x80484e8
0x80483e8   &lt;main+44&gt;:  call 0x80482e0
------------------------------------------------------------------------------
0x080483d9 in main ()</code></pre><p>将函数返回结果 eax 修改为正确的返回结果, 就可以了</p>
<pre><code>gdb&gt; set $eax=0
gdb&gt; c
everything ok
Program exited with code 016.
_______________________________________________________________________________
No registers.
gdb&gt;</code></pre><h2 id="绕过方法-2"><a href="#绕过方法-2" class="headerlink" title="绕过方法 2"></a>绕过方法 2</h2><p>方法 2 就是编写自己的 ptrace 函数</p>
<p>如前几篇所述, <code>LD_PRELOAD</code>环境变量可以将可执行文件指向我们自己的 ptrace 函数.</p>
<p>我们写一个 ptrace 函数并生成目标文件</p>
<pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">// -- ptrace.c --</span>
<span class="token comment" spellcheck="true">// gcc -shared ptrace.c -o ptrace.so</span>
<span class="token keyword">int</span> <span class="token function">ptrace</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">,</span> <span class="token keyword">int</span> l<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">" PTRACE CALLED!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们接下来就可以通过设置环境变量 LD_PRELOAD 来使用我们自己的 ptrace 函数, 当然这里是可以在 gdb 中进行设置</p>
<pre><code>gdb&gt; set environment LD_PRELOAD ./ptrace.so
gdb&gt; run
PTRACE CALLED!
Hello World!
Program exited with code 015.
gdb&gt;</code></pre><p>可以看到程序无法检测到调试器了.</p>
<blockquote>
<p>Reference: <a href="http://www.stonedcoder.org/~kd/lib/14-61-1-PB.pdf" target="_blank" rel="noopener">Beginners Guide to Basic Linux Anti Anti Debugging Techniques</a></p>
</blockquote>
<hr>
<p><strong>脱壳技术</strong></p>
<hr>
<h1 id="保护壳简介"><a href="#保护壳简介" class="headerlink" title="保护壳简介"></a>保护壳简介</h1><h2 id="认识壳是什么"><a href="#认识壳是什么" class="headerlink" title="认识壳是什么"></a>认识壳是什么</h2><p><strong>壳</strong> 是在一些计算机软件里也有一段专门负责保护软件不被非法修改或反编译的程序。</p>
<p>它们一般都是先于程序运行，拿到控制权，然后完成它们保护软件的任务。</p>
<p><img src="/images/loading.gif" data-original="../images/CTF/what_is_pack.png" alt=""></p>
<p>由于这段程序和自然界的壳在功能上有很多相同的地方，基于命名的规则，就把这样的程序称为 <strong>壳</strong> 了。</p>
<h2 id="壳的分类"><a href="#壳的分类" class="headerlink" title="壳的分类"></a>壳的分类</h2><p>我们通常将 <strong>壳</strong> 分为两类，一类是压缩壳，另一类是加密壳。</p>
<h3 id="压缩壳"><a href="#压缩壳" class="headerlink" title="压缩壳"></a>压缩壳</h3><p>压缩壳早在 DOS 时代就已经出现了，但是当时因为计算能力有限，解压开销过大，并没有得到广泛的运用。</p>
<p>使用压缩壳可以帮助缩减 PE 文件的大小，隐藏了 PE 文件内部代码和资源，便于网络传输和保存。</p>
<p>通常压缩壳有两类用途，一种只是单纯用于压缩普通 PE 文件的压缩壳，而另一种则会对源文件进行较大变形，严重破坏 PE 文件头，经常用于压缩恶意程序。</p>
<p>常见的压缩壳有：Upx、ASpack、PECompat</p>
<h3 id="加密壳"><a href="#加密壳" class="headerlink" title="加密壳"></a>加密壳</h3><p>加密壳或称保护壳，应用有多种防止代码逆向分析的技术，它最主要的功能是保护 PE 免受代码逆向分析。</p>
<p>由于加密壳的主要目的不再是压缩文件资源，所以加密壳保护的 PE 程序通常比原文件大得多。</p>
<p>目前加密壳大量用于对安全性要求高，对破解敏感的应用程序，同时也有恶意程序用于避免（降低）杀毒软件的检测查杀。</p>
<p>常见的加密壳有：ASProtector、Armadillo、EXECryptor、Themida、VMProtect</p>
<h2 id="壳的加载过程"><a href="#壳的加载过程" class="headerlink" title="壳的加载过程"></a>壳的加载过程</h2><h3 id="保存入口参数"><a href="#保存入口参数" class="headerlink" title="保存入口参数"></a>保存入口参数</h3><ol>
<li>加壳程序初始化时保存各寄存器的值</li>
<li>外壳执行完毕，恢复各寄存器值</li>
<li>最后再跳到原程序执行</li>
</ol>
<p>通常用 <code>pushad</code> / <code>popad</code>、<code>pushfd</code> / <code>popfd</code> 指令对来保存和恢复现场环境</p>
<h3 id="获取所需函数-API"><a href="#获取所需函数-API" class="headerlink" title="获取所需函数 API"></a>获取所需函数 API</h3><ol>
<li>一般壳的输入表中只有 <code>GetProcAddress</code>、<code>GetModuleHandle</code> 和 <code>LoadLibrary</code> 这几个 API 函数</li>
<li>如果需要其他 API 函数，则通过 <code>LoadLibraryA(W)</code> 或 <code>LoadLibraryExA(W)</code> 将 DLL 文件映射到调用进程的地址空间中</li>
<li>如果 DLL 文件已被映射到调用进程的地址空间里，就可以调用 <code>GetModuleHandleA(W)</code> 函数获得 DLL 模块句柄</li>
<li>一旦 DLL 模块被加载，就可以调用 <code>GetProcAddress</code> 函数获取输入函数的地址</li>
</ol>
<h3 id="解密各区块数据"><a href="#解密各区块数据" class="headerlink" title="解密各区块数据"></a>解密各区块数据</h3><ol>
<li>处于保护源程序代码和数据的目的，一般会加密源程序文件的各个区块。在程序执行时外壳将这些区块数据解密，以让程序正常运行</li>
<li>外壳一般按区块加密，按区块解密，并将解密的数据放回在合适的内存位置</li>
</ol>
<h3 id="跳转回原程序入口点"><a href="#跳转回原程序入口点" class="headerlink" title="跳转回原程序入口点"></a>跳转回原程序入口点</h3><ol>
<li>在跳转回入口点之前，一般会恢复填写原 PE 文件输入表（IAT），并处理好重定位项（主要是 DLL 文件）</li>
<li>因为加壳时外壳自己构造了一个输入表，因此在这里需要重新对每一个 DLL 引入的所有函数重新获取地址，并填写到 IAT 表中</li>
<li>做完上述工作后，会将控制权移交原程序，并继续执行</li>
</ol>
<h1 id="单步跟踪法"><a href="#单步跟踪法" class="headerlink" title="单步跟踪法"></a>单步跟踪法</h1><p>单步跟踪法的原理就是通过 Ollydbg 的步过 (F8), 步入(F7) 和运行到 (F4) 功能, 完整走过程序的自脱壳过程, 跳过一些循环恢复代码的片段, 并用单步进入确保程序不会略过 OEP. 这样可以在软件自动脱壳模块运行完毕后, 到达 OEP, 并 dump 程序.</p>
<h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ol>
<li>打开程序按 F8 单步向下, 尽量实现向下的 jmp 跳转</li>
<li>会经常遇到大的循环, 这时要多用 F4 来跳过循环</li>
<li>如果函数载入时不远处就是一个 call(近 call), 那么我们尽量不要直接跳过, 而是进入这个 call</li>
<li>一般跳转幅度大的 jmp 指令, 都极有可能是跳转到了原程序入口点 (OEP)</li>
</ol>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>示例程序可以点击此处下载: <a href="https://github.com/ctf-wiki/ctf-challenges/blob/master/reverse/unpack/example/1_trace.zip" target="_blank" rel="noopener">1_trace.zip</a></p>
<p>单步跟踪法其实就是一步一步尽量从程序入口点往下走, 在单步的过程中注意 EIP 不要跑偏了, 但是对于一些比较复杂的壳而言, 单步的过程会显得异常枯燥而且容易把自己绕晕. 所以单步跟踪也常用于分析一些关键代码部分 (跟静态分析相结合), 而不是完全地从头分析到尾, 这有违逆向工程的理念.</p>
<p>用 Ollydbg 打开压缩包内的 Notepad.exe, 停在了下图位置. 入口点是一个<code>pushad</code>保存所有寄存器状态到栈中, 随后便是一个<code>call</code>调用位于<code>0040D00A</code>处的函数. 调用后便无条件跳转到<code>459DD4F7</code>处, 之后的<code>push ebp</code>和<code>retn</code>显然没有任何意义. 像这种入口点附近就是一个<code>call</code>的我们称为<code>近call</code>, 对于近 call 我们选择步进, 按下 F7(当然你也只能选择步进, 不然 EIP 就跑偏程序停止了).</p>
<p><img src="/images/loading.gif" data-original="../images/CTF/trace_01.png" alt=""></p>
<p>步进后又是一个<code>call</code>, 我们继续步进, 按 F7, 跟进后发现没有近 call 了, 我们可以看到程序在调<code>GetModuleHandleA</code>, <code>GetProcAddress</code>等 API, 继续向下分析.</p>
<p><img src="/images/loading.gif" data-original="../images/CTF/trace_02.png" alt=""></p>
<p>之后会遇到多个跳转，我们尽量满足向下的跳转，对于向上的跳转不予实现并利用 F4 跳出循环，直到<code>0040D3AF</code>处, 我们看以下的代码</p>
<pre><code>0040D3AF    61                  popad
0040D3B0    75 08               jnz short NotePad.0040D3BA
0040D3B2    B8 01000000         mov eax,0x1
0040D3B7    C2 0C00             retn 0xC
0040D3BA    68 CC104000         push NotePad.004010CC
0040D3BF    C3                  retn</code></pre><p>这里<code>popad</code>可以恢复在程序入口点处保存的寄存器状态, 然后<code>jnz</code>跳转到<code>0040D3BA</code>处, 这里是利用<code>push</code>和<code>retn</code>来将<code>EIP</code>改变为<code>004010CC</code>, 也就是说在壳解压完代码等资源完毕后, 将通过<code>jnz</code>跳转到<code>push</code>处, 然后通过<code>push</code>和<code>ret</code>将<code>EIP</code>设置为程序原来的入口点 (OEP) 并返回到 OEP 处, 然后继续执行原程序的代码. 我们执行到<code>retn</code>返回后, 可以看到如下:</p>
<p><img src="/images/loading.gif" data-original="../images/CTF/trace_03.png" alt=""></p>
<p>显然, 我们到了一堆被<code>Ollydbg</code>误认为是数据的地方继续执行, 显然<code>Ollydbg</code>分析错误了, 我们需要让<code>Ollydbg</code>重新分析, 我们可以右键选择<code>分析-&gt;从模块中删除分析</code>, 或是按下<code>ctrl+a</code>, 这时正确地显示出 OEP 处的汇编指令.</p>
<p><img src="/images/loading.gif" data-original="../images/CTF/trace_04.png" alt=""></p>
<h1 id="ESP-定律法"><a href="#ESP-定律法" class="headerlink" title="ESP 定律法"></a>ESP 定律法</h1><p>ESP 定律法是脱壳的利器, 是应用频率最高的脱壳方法之一.</p>
<h2 id="要点-1"><a href="#要点-1" class="headerlink" title="要点"></a>要点</h2><p>ESP 定律的原理在于利用程序中堆栈平衡来快速找到 OEP.</p>
<p>由于在程序自解密或者自解压过程中, 不少壳会先将当前寄存器状态压栈, 如使用<code>pushad</code>, 在解压结束后, 会将之前的寄存器值出栈, 如使用<code>popad</code>. 因此在寄存器出栈时, 往往程序代码被恢复, 此时硬件断点触发. 然后在程序当前位置, 只需要少许单步操作, 就很容易到达正确的 OEP 位置.</p>
<ol>
<li>程序刚载入开始 pushad/pushfd</li>
<li>将全部寄存器压栈后就设对 ESP 寄存器设硬件断点</li>
<li>运行程序, 触发断点</li>
<li>删除硬件断点开始分析</li>
</ol>
<h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h2><p>示例程序可以点击此处下载: <a href="https://github.com/ctf-wiki/ctf-challenges/blob/master/reverse/unpack/example/2_esp.zip" target="_blank" rel="noopener">2_esp.zip</a></p>
<p>还是上一篇的示例, 入口一句<code>pushad</code>, 我们按下 F8 执行<code>pushad</code>保存寄存器状态, 我们可以在右边的寄存器窗口里发现<code>ESP</code>寄存器的值变为了红色, 也即值发生了改变.</p>
<p><img src="/images/loading.gif" data-original="../images/CTF/esp_01.png" alt=""></p>
<p>我们鼠标右击<code>ESP</code>寄存器的值, 也就是图中的<code>0019FF64</code>, 选择<code>HW break[ESP]</code>后, 按下<code>F9</code>运行程序, 程序会在触发断点时断下. 如图来到了<code>0040D3B0</code>的位置. 这里就是上一篇我们单步跟踪时到达的位置, 剩余的就不再赘述.</p>
<p><img src="/images/loading.gif" data-original="../images/CTF/esp_02.png" alt=""></p>
<h1 id="一步到达-OEP-法"><a href="#一步到达-OEP-法" class="headerlink" title="一步到达 OEP 法"></a>一步到达 OEP 法</h1><p>所谓的一步到达 OEP 的脱壳方法, 是根据所脱壳的特征, 寻找其距离 OEP 最近的一处汇编指令, 然后下 int3 断点, 在程序走到 OEP 的时候 dump 程序.</p>
<p>如一些压缩壳往往 popad 指令距离 OEP 或者大 jmp 特别近, 因此使用 Ollydbg 的搜索功能, 可以搜索壳的特征汇编代码, 达到一步断点到达 OEP 的效果.</p>
<h2 id="要点-2"><a href="#要点-2" class="headerlink" title="要点"></a>要点</h2><ol>
<li>ctrl+f 查找 popad</li>
<li>ctrl+l 跳转到下一个匹配处</li>
<li>找到匹配处, 确认是壳解压完毕即将跳转到 OEP 部分, 则设下断点运行到该处</li>
<li>只适用于极少数压缩壳</li>
</ol>
<h2 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h2><p>示例程序可以点击此处下载: <a href="https://github.com/ctf-wiki/ctf-challenges/blob/master/reverse/unpack/example/3_direct2oep.zip" target="_blank" rel="noopener">3_direct2oep.zip</a></p>
<p>还是用的原先的 notepad.exe 来示例, 用<code>Ollydbg</code>打开后, 我们按下<code>ctrl+f</code>来查找指定的字符串, 像<code>popad</code>是典型的一个特征, 有部分壳它就常用<code>popad</code>来恢复状态, 所以如下图所示来搜索<code>popad</code>.</p>
<p><img src="/images/loading.gif" data-original="../images/CTF/direct2oep_01.png" alt=""></p>
<p>在本例中, 当搜索到的<code>popad</code>不符合我们的要求时, 可以按下<code>ctrl+l</code>来搜索下一个匹配处, 大概按下个三四次, 我们找到了跳转到 OEP 的位置处.</p>
<p><img src="/images/loading.gif" data-original="../images/CTF/direct2oep_02.png" alt=""></p>
<h1 id="内存镜像法"><a href="#内存镜像法" class="headerlink" title="内存镜像法"></a>内存镜像法</h1><p>内存镜像法是在加壳程序被加载时, 通过 OD 的<code>ALT+M</code>快捷键, 进入到程序虚拟内存区段. 然后通过加两次内存一次性断点, 到达程序正确 OEP 的位置.</p>
<p>内存镜像法的原理在于对于程序资源段和代码段下断点, 一般程序自解压或者自解密时, 会首先访问资源段获取所需资源, 然后在自动脱壳完成后, 转回程序代码段. 这时候下内存一次性断点, 程序就会停在 OEP 处.</p>
<h2 id="要点-3"><a href="#要点-3" class="headerlink" title="要点"></a>要点</h2><ol>
<li>选择菜单的<code>选项-&gt;调试选项-&gt;异常</code></li>
<li>勾选所有的忽略异常</li>
<li>按下<code>ALT+M</code>, 打开内存镜像, 找到程序的第一个<code>.rsrc</code>, 按 F2 下断点, 然后按<code>SHIFT+F9</code>运行到断点</li>
<li>再按<code>ALT+M</code>, 打开内存镜像, 找到程序的第一个<code>.rsrc</code>上面的<code>.text</code>(在示例中是<code>00401000</code>处), 按 F2 下断点. 然后按<code>SHIFT+F9</code>（或者是在没异常情况下按 F9）</li>
</ol>
<h2 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h2><p>示例程序可以点击此处下载: <a href="https://github.com/ctf-wiki/ctf-challenges/blob/master/reverse/unpack/example/4_memory.zip" target="_blank" rel="noopener">4_memory.zip</a></p>
<p>OD 载入程序, 在菜单栏的<code>选项-&gt;调试设置-&gt;异常标签页</code>中勾选所有的忽略异常</p>
<p><img src="/images/loading.gif" data-original="../images/CTF/memory_01.png" alt=""></p>
<p>按下<code>Alt+M</code>打开内存镜像, 找到资源段, 也就是<code>地址=00407000</code>, <code>大小=00005000</code>的<code>.rsrc</code>段, 选中 F2 下断</p>
<p><img src="/images/loading.gif" data-original="../images/CTF/memory_02.png" alt=""></p>
<p>回到 CPU 窗口, 按下 F9 运行, 程序断在了<code>0040D75F</code>处</p>
<p><img src="/images/loading.gif" data-original="../images/CTF/memory_03.png" alt=""></p>
<p>再次按下<code>Alt+M</code>打开内存镜像, 对<code>.text</code>代码段下断</p>
<p><img src="/images/loading.gif" data-original="../images/CTF/memory_04.png" alt=""></p>
<p>再继续运行, 程序断在了<code>004010CC</code>处, 也就是 OEP</p>
<p><img src="/images/loading.gif" data-original="../images/CTF/memory_05.png" alt=""></p>
<h1 id="最后一次异常法"><a href="#最后一次异常法" class="headerlink" title="最后一次异常法"></a>最后一次异常法</h1><p>最后一次异常法的原理是, 程序在自解压或自解密过程中, 可能会触发无数次的异常. 如果能定位到最后一次程序异常的位置, 可能就会很接近自动脱壳完成位置. 现在最后一次异常法脱壳可以利用 Ollydbg 的异常计数器插件, 先记录异常数目, 然后重新载入, 自动停在最后一次异常处.</p>
<h2 id="要点-4"><a href="#要点-4" class="headerlink" title="要点"></a>要点</h2><ol>
<li>点击<code>选项-&gt;调试选项—&gt;异常</code>, 把里面的√全部去掉! 按下<code>CTRL+F2</code>重载下程序</li>
<li>开始程序就是一个跳转, 在这里我们按<code>SHIFT+F9</code>, 直到程序运行, 记下从开始按<code>SHIFT+F9</code>到程序运行的次数<code>m</code>!</li>
<li><code>CTRL+F2</code>重载程序, 按<code>SHIFT+F9</code>(这次按的次数为程序运行的次数<code>m-1</code>次)</li>
<li>在 OD 的右下角我们看见有一个 “<code>SE 句柄</code>“, 这时我们按<code>CTRL+G</code>, 输入<code>SE 句柄</code>前的地址!</li>
<li>按 F2 下断点! 然后按<code>SHIFT+F9</code>来到断点处, F8 单步跟踪</li>
</ol>
<h2 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h2><p>示例程序可以点击此处下载: <a href="https://github.com/ctf-wiki/ctf-challenges/blob/master/reverse/unpack/example/5_last_exception.zip" target="_blank" rel="noopener">5_last_exception.zip</a></p>
<p>OD 载入程序, 在菜单<code>选项-&gt;调试设置-&gt;异常标签页</code>中取消勾选所有的忽略异常, 然后重载程序.</p>
<p><img src="/images/loading.gif" data-original="../images/CTF/exception_01.png" alt=""></p>
<p>我们按下<code>Shift+F9</code>, 记录按了多少次, 程序正常运行. 我们要得到的是倒数第二次按下是按了多少次. 在本例中</p>
<ul>
<li><code>shift+F9</code>一次, 到了<code>0040CCD2</code>的位置</li>
<li><code>shift+F9</code>两次, 程序正常运行</li>
</ul>
<p>那么我们重载程序, 只需按下 1 次 (<code>2-1=1</code>)<code>Shift+F9</code>, 来到<code>0040CCD2</code>的位置, 观察堆栈窗口, 这里有一个<code>SE处理程序: 0040CCD7</code></p>
<p><img src="/images/loading.gif" data-original="../images/CTF/exception_02.png" alt=""></p>
<p>我们在 CPU 窗口 (汇编指令), 按<code>Ctrl+G</code>, 输入<code>0040CCD7</code>, 然后在此处按下 F2. 也就是在<code>0040CCD7</code>处设置断点, 然后按下<code>Shift+F9</code>运行, 触发断点.</p>
<p><img src="/images/loading.gif" data-original="../images/CTF/exception_03.png" alt=""></p>
<p>触发断点后, 来单步跟踪. 向下都是一些循环和跳转, 我们使用 F4 跳过循环. 最后到达如下位置</p>
<p><img src="/images/loading.gif" data-original="../images/CTF/exception_04.png" alt=""></p>
<p>显然在最后的<code>mov ebp, 0041010CC; jmp ebp</code>是在跳转向 OEP, 我们跳转过去如下图所示:</p>
<p><img src="/images/loading.gif" data-original="../images/CTF/exception_05.png" alt=""></p>
<p>显然, 我们幸运地来到了 OEP 处.</p>
<h1 id="SFX-法"><a href="#SFX-法" class="headerlink" title="SFX 法"></a>SFX 法</h1><p>“SFX” 法利用了 Ollydbg 自带的 OEP 寻找功能, 可以选择直接让程序停在 OD 找到的 OEP 处, 此时壳的解压过程已经完毕, 可以直接 dump 程序.</p>
<h2 id="要点-5"><a href="#要点-5" class="headerlink" title="要点"></a>要点</h2><ol>
<li>设置 OD, 忽略所有异常, 也就是说异常选项卡里面都打上勾</li>
<li>切换到 SFX 选项卡, 选择 “字节模式跟踪实际入口 (速度非常慢)”, 确定</li>
<li>重载程序 (如果跳出是否 “压缩代码?” 选择 “否”, OD 直接到达 OEP)</li>
</ol>
<h2 id="示例-5"><a href="#示例-5" class="headerlink" title="示例"></a>示例</h2><p>示例程序可以点击此处下载: <a href="https://github.com/ctf-wiki/ctf-challenges/blob/master/reverse/unpack/example/6_sfx.zip" target="_blank" rel="noopener">6_sfx.zip</a></p>
<p>首先我们在菜单<code>选项-&gt;调试设置-&gt;异常标签页</code>中勾选所有忽略异常.</p>
<p><img src="/images/loading.gif" data-original="../images/CTF/sfx_01.png" alt=""></p>
<p>然后切换到<code>SFX</code>标签页, 点选 “字节方式跟踪真正入口处 (速度非常慢)”</p>
<p><img src="/images/loading.gif" data-original="../images/CTF/sfx_02.png" alt=""></p>
<p>重载程序，程序已经停在了代码入口点, 并且也不需要对 OEP 进行重新分析.</p>
<p><img src="/images/loading.gif" data-original="../images/CTF/sfx_03.png" alt=""></p>
<h1 id="DUMP-及-IAT-重建"><a href="#DUMP-及-IAT-重建" class="headerlink" title="DUMP 及 IAT 重建"></a>DUMP 及 IAT 重建</h1><h2 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h2><p>在找到程序 OEP 后, 我们需要将程序 dump 出来, 并重建<code>IAT</code>. <code>IAT</code>全名是<code>Import Address Table</code>, 表项指向函数实际地址.</p>
<h2 id="示例-6"><a href="#示例-6" class="headerlink" title="示例"></a>示例</h2><p>比如如下, 我们找到了 OEP, 到达了程序的真正入口点. 我们这时就需要将程序 dump 出来. 我们右键, 选择<code>"用OllyDump脱壳调试进程"</code>(不过你也可以使用<code>LoadPE</code>来 dump 出来):</p>
<p><img src="/images/loading.gif" data-original="../images/CTF/right_click.jpg" alt=""></p>
<p>弹出一个窗口, 看一下地址是否正确, 主要就是看看<code>入口点地址</code>有没有选对. 然后取消勾选<code>重建输入表</code>.</p>
<p><img src="/images/loading.gif" data-original="../images/CTF/dump.png" alt=""></p>
<p>将 dump 出的文件命名, 我这里是命名为<code>dump.exe</code>啦. 我们尝试来运行一下<code>dump.exe</code>, 可以发现程序无法正常运行, 对于一些简单的壳, 你 dump 出来发现无法正常运行, 如果你确实找到了正确的 OEP 并用<code>IDA</code>反编译查看结果良好, 那么你的第一想法就应该是程序的<code>IAT</code>出现了问题. 你就需要重建<code>IAT</code>.</p>
<p>我们需要使用<code>ImportREC</code>来帮助修复输入表.</p>
<p>打开<code>ImportREC</code>, 选择一个正在运行的进程<code>原版.exe</code>(<code>原版.exe</code>是我在 OD 中正在调试的进程, OD 中的<code>EIP</code>正处在<code>OEP</code>位置, 在用<code>Ollydump</code>之后不要关闭这个进程哦.). <code>ImportREC</code>修复输入表入口点需要知道<code>OEP</code>, 也就是要在窗口右侧中间的<code>OEP</code>输入框中进行输入</p>
<p><img src="/images/loading.gif" data-original="../images/CTF/importrec.png" alt=""></p>
<p>我们所知, 在 Ollydbg 里我们知道程序目前在的入口点是<code>0049C25C</code>, 而镜像基址是<code>00400000</code></p>
<p>因此我们这里需要填写<code>OEP</code>是<code>0009C25C</code></p>
<p>我们修改<code>ImportREC</code>中的<code>OEP</code>为<code>0009C25C</code>然后点击<code>AutoSearch</code>后, 弹出提示框 “发现可能是原 IAT 地址”</p>
<p><img src="/images/loading.gif" data-original="../images/CTF/auto_search.png" alt=""></p>
<p>我们点击<code>"Get Imports"</code>按钮便可以重建<code>IAT</code>. 左侧会显示<code>IAT</code>中各导入函数的地址以及是否有效. 显然在图中可以看到<code>ImportREC</code>找到了内存中<code>IAT</code>的位置并检测出各个函数都是有效的.</p>
<p><img src="/images/loading.gif" data-original="../images/CTF/get_imports.png" alt=""></p>
<p>我们点击<code>Fix Dump</code>, 然后打开先前使用<code>OllyDump</code>插件转储出来的文件，也就是<code>dump.exe</code>文件。</p>
<p>那么<code>ImportREC</code>就会帮助恢复导入表，并生成<code>dump_.exe</code>文件. <code>dump_.exe</code>可以正常运行</p>
<h1 id="手动查找-IAT-并使用-ImportREC-重建"><a href="#手动查找-IAT-并使用-ImportREC-重建" class="headerlink" title="手动查找 IAT 并使用 ImportREC 重建"></a>手动查找 IAT 并使用 ImportREC 重建</h1><p>示例程序可以从此链接下载: <a href="https://github.com/ctf-wiki/ctf-challenges/blob/master/reverse/unpack/example/manually_fix_iat.zip" target="_blank" rel="noopener">manually_fix_iat.zip</a></p>
<p>我们常用的<code>ImportREC</code>脱壳是使用的软件自带的<code>IAT auto search</code>, 但是如果我们要手动查找<code>IAT</code>的地址并<code>dump</code>出来, 又该怎么操作呢？</p>
<p>首先使用 ESP 定律, 可以很快地跳转到<code>OEP: 00401110</code>.</p>
<p><img src="/images/loading.gif" data-original="../images/CTF/upx-dll-unpack-1.png" alt=""></p>
<p>我们右键点击, 选择<code>查找-&gt;所有模块间的调用</code></p>
<p><img src="/images/loading.gif" data-original="../images/CTF/upx-dll-unpack-2.png" alt=""></p>
<p>显示出调用的函数列表, 我们双击其中的某个函数 (注意这里要双击的应该是程序的函数而不是系统函数)</p>
<p><img src="/images/loading.gif" data-original="../images/CTF/upx-dll-unpack-3.png" alt=""></p>
<p>我们来到了函数调用处</p>
<p><img src="/images/loading.gif" data-original="../images/CTF/upx-dll-unpack-4.png" alt=""></p>
<p>右键点击<code>跟随</code>, 进入函数</p>
<p><img src="/images/loading.gif" data-original="../images/CTF/upx-dll-unpack-5.png" alt=""></p>
<p>然后再右键点击<code>数据窗口中跟随-&gt;内存地址</code></p>
<p><img src="/images/loading.gif" data-original="../images/CTF/upx-dll-unpack-6.png" alt=""></p>
<p>这里因为显示是十六进制值, 不方便查看, 我们可以在数据窗口点击右键选择<code>长型-&gt;地址</code>, 就可以显示函数名</p>
<p><img src="/images/loading.gif" data-original="../images/CTF/upx-dll-unpack-7.png" alt=""></p>
<p>注意我们要向上翻到 IAT 表的起始位置, 可以看到最开始的函数地址是<code>004050D8</code>的<code>kernel.AddAtomA</code>, 我们向下找到最后一个函数, 也就是<code>user32.MessageBoxA</code>函数, 计算一下整个 IAT 表的大小。在 OD 的最下方有显示<code>块大小：0x7C</code>, 所以我们整个 IAT 块大小就是<code>0x7C</code></p>
<p><img src="/images/loading.gif" data-original="../images/CTF/upx-dll-unpack-8.png" alt=""></p>
<p>打开<code>ImportREC</code>, 选择我们正在调试的这个程序, 然后分别输入<code>OEP：1110, RVA:50D8, SIZE:7C</code>, 然后点击<code>获取输入表</code></p>
<p><img src="/images/loading.gif" data-original="../images/CTF/upx-dll-unpack-9.png" alt=""></p>
<p>这里在输入表窗口中右键选择<code>高级命令-&gt;选择代码块</code>.</p>
<p><img src="/images/loading.gif" data-original="../images/CTF/upx-dll-unpack-10.png" alt=""></p>
<p>然后会弹出窗口, 选择完整转储, 保存为<code>dump.exe</code>文件</p>
<p><img src="/images/loading.gif" data-original="../images/CTF/upx-dll-unpack-11.png" alt=""></p>
<p>dump 完成后, 选择<code>转储到文件</code>, 这里选择修复我们刚刚 dump 出的 dump.exe, 得到一个<code>dump\_.exe</code>. 这时整个脱壳就完成了</p>
<h1 id="DLL-文件脱壳"><a href="#DLL-文件脱壳" class="headerlink" title="DLL 文件脱壳"></a>DLL 文件脱壳</h1><p>例题文件你可以点击此处下载: <a href="https://github.com/ctf-wiki/ctf-challenges/blob/master/reverse/unpack/example/unpack_dll.zip" target="_blank" rel="noopener">unpack_dll.zip</a></p>
<p>因为<code>Dll</code>脱壳需要这一步骤. <code>Dll</code>脱壳的最关键的步骤在于<code>使用LordPE修改其Dll的标志</code>, 用<code>LordPE</code>打开<code>UnpackMe.dll</code>, 然后在特征值那里点击<code>...</code>, 然后取消勾选<code>DLL</code>标志, 保存后, 系统就会将该文件视作一个可执行文件.</p>
<p><img src="/images/loading.gif" data-original="../images/CTF/upx-dll-unpack-12.png" alt=""></p>
<p>我们将<code>UnpackMe.dll</code>后缀名改成<code>UnpackMe.exe</code>, 然后用 OD 载入.</p>
<p><img src="/images/loading.gif" data-original="../images/CTF/upx-dll-unpack-13.png" alt=""></p>
<p>一般在入口点, 程序都会保存一些信息, 这里就很简单, 只作了一个<code>cmp</code>. 要注意的一点是, 这里的<code>jnz</code>跳转直接就跳到了<code>unpacking</code>过程的末尾. 因此我们需要修改寄存器的<code>z</code>标志来使得跳转失效. 同时在<code>unpacking</code>过程的末尾设下一个断点以避免脱壳完然后直接运行.(程序会断在这个断点上, 但是脱壳已经完成, 代码都很清晰)</p>
<p><code>Dll</code>脱壳的基本步骤跟<code>exe</code>文件脱壳一样, 而在重建<code>IAT</code>时, 需要照着上篇 <a href="https://ctf-wiki.org/reverse/unpack/manually-fix-iat/index.html" target="_blank" rel="noopener">手动查找 IAT 并使用 ImportREC 重建</a> 所说的那样, 手动找到<code>IAT</code>表并用<code>ImportREC</code>进行重建. 只是要注意, 在脱壳完 dump 后, 要记得用 LordPE 把<code>DLL</code>标志恢复过来并将文件后缀名改为<code>.dll</code>.</p>
<hr>
<p><strong>反调试技术</strong></p>
<hr>
<h1 id="NtGlobalFlag"><a href="#NtGlobalFlag" class="headerlink" title="NtGlobalFlag"></a>NtGlobalFlag</h1><h2 id="关于-NtGlobalFlag"><a href="#关于-NtGlobalFlag" class="headerlink" title="关于 NtGlobalFlag"></a>关于 NtGlobalFlag</h2><p>在 32 位机器上, <code>NtGlobalFlag</code>字段位于<code>PEB</code>(进程环境块)<code>0x68</code>的偏移处, 64 位机器则是在偏移<code>0xBC</code>位置. 该字段的默认值为 0. 当调试器正在运行时, 该字段会被设置为一个特定的值. 尽管该值并不能十分可信地表明某个调试器真的有在运行, 但该字段常出于该目的而被使用.</p>
<p>该字段包含有一系列的标志位. 由调试器创建的进程会设置以下标志位:</p>
<pre><code>FLG_HEAP_ENABLE_TAIL_CHECK (0x10)
FLG_HEAP_ENABLE_FREE_CHECK (0x20)
FLG_HEAP_VALIDATE_PARAMETERS (0x40)</code></pre><h2 id="检测代码"><a href="#检测代码" class="headerlink" title="检测代码"></a>检测代码</h2><p>因此, 可以检查这几个标志位来检测调试器是否存在. 比如用形如以下的 32 位的代码在 32 位机器上进行检测:</p>
<pre><code>mov eax, fs:[30h] ;Process Environment Block
mov al, [eax+68h] ;NtGlobalFlag
and al, 70h
cmp al, 70h
je being_debugged</code></pre><p>以下是 64 位的代码在 64 位机器上的检测代码:</p>
<pre><code>push 60h
pop rsi
gs:lodsq                ;Process Environment Block
mov al, [rsi*2+rax-14h] ;NtGlobalFlag
and al, 70h
cmp al, 70h
je being_debugged</code></pre><p>要注意的是, 如果是一个 32 位程序在 64 位机器上运行, 那么实际上会存在两个 PEB: 一个是 32 位部分的而另一个是 64 位. 64 位的 PEB 的对应字段也会像在 32 位的那样而改变.</p>
<p>于是我们就还有以下的, 用 32 位的代码检测 64 位机器环境:</p>
<pre><code>mov eax, fs:[30h] ; Process Environment Block
;64-bit Process Environment Block
;follows 32-bit Process Environment Block
mov al, [eax+10bch] ;NtGlobalFlag
and al, 70h
cmp al, 70h
je being_debugged</code></pre><p>切记不要在没有掩盖其他位的情况下直接进行比较, 那样会无法检测到调试器.</p>
<p>在<code>ExeCryptor</code>就有使用<code>NtGlobalFlag</code>来检测调试器, 不过<code>NtGlobalFlag</code>的那 3 个标志位只有当程序是<code>由调试器创建</code>, 而非<code>由调试器附加</code>上去的进程时, 才会被设置.</p>
<h2 id="改变-NtGlobalFlag-初值"><a href="#改变-NtGlobalFlag-初值" class="headerlink" title="改变 NtGlobalFlag 初值"></a>改变 NtGlobalFlag 初值</h2><p>当然绕过这种检测的方法也十分简单, 那就是调试器想办法将该字段重新设置为 0. 然而这个默认的初值可以用以下四种方法任意一种改变:</p>
<ol>
<li><p>注册表<code>HKLM\System\CurrentControlSet\Control\SessionManager</code>的<code>GlobalFlag</code>的值会替换进行<code>NtGlobalFlag</code>字段. 尽管它随后还可能由 Windows 改变 (以下会介绍), 注册表键值会对系统中所有进程产生影响并在重启后生效.</p>
<p><img src="/images/loading.gif" data-original="../images/CTF/globalflag.png" alt=""></p>
<p>当然这也产生了另一种检测调试器的方法: 如果一个调试器为了隐藏自己, 而将注册表中的键值复制到<code>NtGlobalFlag</code>字段中, 然而注册表中的键值事先已经替换并且尚未重启生效. 那么调试器只是复制了一个假的值, 而非真正需要的那个. 如果程序知道真正的值而非注册表中的那个假的值, 那么就可以察觉到调试器的存在.</p>
<p>当然调试器也可以运行其他进程然后查询<code>NtGlobalFlag</code>字段来获取真正的值.</p>
</li>
<li><p>依旧是<code>GlobalFlag</code>, 不过这里的是<code>HKLM\Software\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\&lt;filename&gt;</code>. (映像劫持), 这里需要将<code>&lt;filename&gt;</code>替换为需要更改的可执行文件的文件名 (不需要指定路径). 设置好<code>GlobalFlag</code>后, 系统会将其值覆盖到<code>NtGlobalFlag</code>字段 (只单独为指定的进程覆盖). 不过也还是可以再次由 Windows 改变 (见下).</p>
</li>
<li><p>在加载配置表 (<code>Load Configuration Table</code>) 的两个字段: <code>GlobalFlagsClear</code>和<code>GlobalFlagsSet</code>.</p>
<p><code>GlobalFlagsClear</code>列出需要清空的标志位, 而<code>GlobalFlagsSet</code>则列出需要设置的标志位, 这些设置会在<code>GlobalFlag</code>应用之后再生效, 因此它可以覆盖掉<code>GlobalFlag</code>指定的值. 然而它无法覆盖掉 Windows 指定设置的标志位. 比如设置<code>FLG_USER_STACK_TRACE_DB (0x1000)</code>可以让 Windows 设置<code>FLG_HEAP_VALIDATE_PARAMETERS (0x40)</code>标志位, 就算<code>FLG_HEAP_VALIDATE_PARAMETERS</code>在加载配置表 (<code>Load Configuration Table</code>) 中被清空了, Windows 也会在随后的进程加载过程中重新设置.</p>
</li>
<li><p>当调试器创建进程时, Windows 会做出一些改变. 通过设置环境变量中的<code>_NO_DEBUG_HEAP</code>, <code>NtGlobalFlag</code>将会因为调试器而不会设置其中的 3 个堆的标志位. 当然它们依旧可以通过<code>GlobalFlag</code>或加载配置表中的<code>GlobalFlagsSet</code>继续设置.</p>
</li>
</ol>
<h2 id="如何绕过检测"><a href="#如何绕过检测" class="headerlink" title="如何绕过检测?"></a>如何绕过检测?</h2><p>有以下 3 种方法来绕过<code>NtGlobalFlag</code>的检测</p>
<ul>
<li>手动修改标志位的值 (<code>FLG_HEAP_ENABLE_TAIL_CHECK</code>, <code>FLG_HEAP_ENABLE_FREE_CHECK</code>, <code>FLG_HEAP_VALIDATE_PARAMETERS</code>)</li>
<li>在 Ollydbg 中使用<code>hide-debug</code>插件</li>
<li>在 Windbg 禁用调试堆的方式启动程序 (<code>windbg -hd program.exe</code>)</li>
</ul>
<h2 id="手动绕过示例"><a href="#手动绕过示例" class="headerlink" title="手动绕过示例"></a>手动绕过示例</h2><p>以下是一个演示如何手动绕过检测的示例</p>
<pre><code>.text:00403594     64 A1 30 00 00 00          mov     eax, large fs:30h   ; PEB struct loaded into EAX
.text:0040359A                                db      3Eh                 ; IDA Pro display error (the byte is actually used in the next instruction)
.text:0040359A     3E 8B 40 68                mov     eax, [eax+68h]      ; NtGlobalFlag (offset 0x68 relative to PEB) saved to EAX
.text:0040359E     83 E8 70                   sub     eax, 70h            ; Value 0x70 corresponds to all flags on (FLG_HEAP_ENABLE_TAIL_CHECK, FLG_HEAP_ENABLE_FREE_CHECK, FLG_HEAP_VALIDATE_PARAMETERS)
.text:004035A1     89 85 D8 E7 FF FF          mov     [ebp+var_1828], eax
.text:004035A7     83 BD D8 E7 FF FF 00       cmp     [ebp+var_1828], 0   ; Check whether 3 debug flags were on (result of substraction should be 0 if debugged)
.text:004035AE     75 05                      jnz     short loc_4035B5    ; No debugger, program continues...
.text:004035B0     E8 4B DA FF FF             call    s_selfDelete        ; ...else, malware deleted</code></pre><p>在 Ollydbg 中在偏移<code>0x40359A</code>设置断点, 运行程序触发断点. 然后打开<code>CommandLine</code>插件用<code>dump fs:[30]+0x68</code>dump 出<code>NtGlobalFlag</code>的内容</p>
<p><img src="/images/loading.gif" data-original="../images/CTF/manually_set_peb_ntglobalflag.png" alt=""></p>
<p>右键选择<code>Binary-&gt;Fill with 00's</code>将值<code>0x70</code>替换为<code>0x00</code>即可.</p>
<h1 id="Heap-Flags"><a href="#Heap-Flags" class="headerlink" title="Heap Flags"></a>Heap Flags</h1><h2 id="关于-Heap-flags"><a href="#关于-Heap-flags" class="headerlink" title="关于 Heap flags"></a>关于 Heap flags</h2><p><code>Heap flags</code>包含有两个与<code>NtGlobalFlag</code>一起初始化的标志: <code>Flags</code>和<code>ForceFlags</code>. 这两个字段的值不仅会受调试器的影响, 还会由 windows 版本而不同, 字段的位置也取决于 windows 的版本.</p>
<ul>
<li>Flags 字段:<ul>
<li>在 32 位 Windows NT, Windows 2000 和 Windows XP 中, <code>Flags</code>位于堆的<code>0x0C</code>偏移处. 在 32 位 Windows Vista 及更新的系统中, 它位于<code>0x40</code>偏移处.</li>
<li>在 64 位 Windows XP 中, <code>Flags</code>字段位于堆的<code>0x14</code>偏移处, 而在 64 位 Windows Vista 及更新的系统中, 它则是位于<code>0x70</code>偏移处.</li>
</ul>
</li>
<li>ForceFlags 字段:<ul>
<li>在 32 位 Windows NT, Windows 2000 和 Windows XP 中, <code>ForceFlags</code>位于堆的<code>0x10</code>偏移处. 在 32 位 Windows Vista 及更新的系统中, 它位于<code>0x44</code>偏移处.</li>
<li>在 64 位 Windows XP 中, <code>ForceFlags</code>字段位于堆的<code>0x18</code>偏移处, 而在 64 位 Windows Vista 及更新的系统中, 它则是位于<code>0x74</code>偏移处.</li>
</ul>
</li>
</ul>
<p>在所有版本的 Windows 中, <code>Flags</code>字段的值正常情况都设为<code>HEAP_GROWABLE(2)</code>, 而<code>ForceFlags</code>字段正常情况都设为<code>0</code>. 然而对于一个 32 位进程 (64 位程序不会有此困扰), 这两个默认值, 都取决于它的宿主进程(host process) 的 <a href="https://msdn.microsoft.com/en-us/library/ms933120.aspx" target="_blank" rel="noopener"><code>subsystem</code></a>版本 (这里不是指所说的比如 win10 的 linux 子系统). 只有当<code>subsystem</code>在<code>3.51</code>及更高的版本, 字段的默认值才如前所述. 如果是在<code>3.10-3.50</code>版本之间, 则两个字段的<code>HEAP_CREATE_ALIGN_16 (0x10000)</code>都会被设置. 如果版本低于<code>3.10</code>, 那么这个程序文件就根本不会被运行.</p>
<p>如果某操作将<code>Flags</code>和<code>ForgeFlags</code>字段的值分别设为<code>2</code>和<code>0</code>, 但是却未对<code>subsystem</code>版本进行检查, 那么就可以表明该动作是为了隐藏调试器而进行的.</p>
<p>当调试器存在时, 在<code>Windows NT</code>, <code>Windows 2000</code>和 32 位<code>Windows XP</code>系统下, <code>Flags</code>字段会设置以下标志:</p>
<pre><code>HEAP_GROWABLE (2)
HEAP_TAIL_CHECKING_ENABLED (0x20)
HEAP_FREE_CHECKING_ENABLED (0x40)
HEAP_SKIP_VALIDATION_CHECKS (0x10000000)
HEAP_VALIDATE_PARAMETERS_ENABLED (0x40000000)</code></pre><p>在 64 位<code>Windows XP</code>系统, <code>Windows Vista</code>及更新的系统版本, <code>Flags</code>字段则会设置以下标志 (少了<code>HEAP_SKIP_VALIDATION_CHECKS (0x10000000)</code>):</p>
<pre><code>HEAP_GROWABLE (2)
HEAP_TAIL_CHECKING_ENABLED (0x20)
HEAP_FREE_CHECKING_ENABLED (0x40)
HEAP_VALIDATE_PARAMETERS_ENABLED (0x40000000)</code></pre><p>而对于<code>ForgeFlags</code>字段, 正常情况则会设置以下标志:</p>
<pre><code>HEAP_TAIL_CHECKING_ENABLED (0x20)
HEAP_FREE_CHECKING_ENABLED (0x40)
HEAP_VALIDATE_PARAMETERS_ENABLED (0x40000000)</code></pre><p>因为<code>NtGlobalFlag</code>标志的关系, <code>heap</code>也会设置一些标志位</p>
<ul>
<li>如果在<code>NtGlobalFlag</code>字段中有设置<code>FLG_HEAP_ENABLE_TAIL_CHECK</code>标志, 那么在<code>heap</code>字段中就会设置<code>HEAP_TAIL_CHECKING_ENABLED</code>标志.</li>
<li>如果在<code>NtGlobalFlag</code>字段中有设置<code>FLG_HEAP_ENABLE_FREE_CHECK</code>标志, 那么在<code>heap</code>字段中就会设置<code>FLG_HEAP_ENABLE_FREE_CHECK</code>标志.</li>
<li>如果在<code>NtGlobalFlag</code>字段中有设置<code>FLG_HEAP_VALIDATE_PARAMETERS</code>标志, 那么在<code>heap</code>字段中就会设置<code>HEAP_VALIDATE_PARAMETERS_ENABLED</code>标志 (在<code>Windows NT</code>和<code>Windows 2000</code>中还会设置<code>HEAP_CREATE_ALIGN_16 (0x10000)</code>标志).</li>
</ul>
<p><code>heap flags</code>同样也如上节的<code>NtGlobalFlag</code>那样, 不过它受到注册表<code>HKLM\Software\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\&lt;filename&gt;</code>位置的<code>PageHeapFlags"</code>键的控制.</p>
<h2 id="获取-heap-位置"><a href="#获取-heap-位置" class="headerlink" title="获取 heap 位置"></a>获取 heap 位置</h2><p>有多种方法能获知<code>heap</code>的位置, 方法之一就是<code>kernel32</code>的<code>GetProcessHeap()</code>函数, 当然也可以用以下的 32 位汇编代码来检测 32 位环境 (实际上就有一些壳避免使用该 api 函数, 直接查询 PEB):</p>
<pre><code>mov eax, fs:[30h] ;Process Environment Block
mov eax, [eax+18h] ;get process heap base</code></pre><p>或使用以下 64 位代码来检测 64 位环境</p>
<pre><code>push 60h
pop rsi
gs:lodsq ;Process Environment Block
mov eax, [rax+30h] ;get process heap base</code></pre><p>或使用以下 32 位代码检测 64 位环境</p>
<pre><code>mov eax, fs:[30h] ;Process Environment Block
;64-bit Process Environment Block
;follows 32-bit Process Environment Block
mov eax, [eax+1030h] ;get process heap base</code></pre><p>另外一种方法则是使用<code>kernel32</code>的<code>GetProcessHeaps()</code>函数, 其实它只是简单的转给了<code>ntdll</code>的<code>RtlGetProcessHeaps()</code>函数, 这个函数会返回属于当前进程的堆的数组, 而数组的第一个堆, 就跟<code>kernel32</code>的<code>GetProcessHeap()</code>函数所返回的是一样的.</p>
<p>这个过程可以用 32 位代码检测 32 位 windows 环境来实现:</p>
<pre><code>push 30h
pop esi
fs:lodsd ;Process Environment Block
;get process heaps list base
mov esi, [esi+eax+5ch]
lodsd</code></pre><p>同上, 用 64 位代码检测 64 位 windows 环境的代码是:</p>
<pre><code>push 60h
pop rsi
gs:lodsq ;Process Environment Block
;get process heaps list base
mov esi, [rsi*2+rax+20h]
lodsd</code></pre><p>或使用 32 位代码检测 64 位 window 环境:</p>
<pre><code>mov eax, fs:[30h] ;Process Environment Block
;64-bit Process Environment Block
;follows 32-bit Process Environment Block
mov esi, [eax+10f0h] ;get process heaps list base
lodsd</code></pre><h2 id="检测-Flags-字段"><a href="#检测-Flags-字段" class="headerlink" title="检测 Flags 字段"></a>检测 Flags 字段</h2><p>那么显然, 检测调试器我们就可以从检测那几个<code>Flags</code>和<code>ForgeFlags</code>的标志位入手.</p>
<p>先看<code>Flags</code>字段的检测代码, 用 32 位代码检测 32 位 windows 环境, 且<code>subsystem</code>版本在<code>3.10-3.50</code>之间:</p>
<pre><code>call GetVersion
cmp al, 6
cmc
sbb ebx, ebx
and ebx, 34h
mov eax, fs:[30h] ;Process Environment Block
mov eax, [eax+18h] ;get process heap base
mov eax, [eax+ebx+0ch] ;Flags
;neither HEAP_CREATE_ALIGN_16
;nor HEAP_SKIP_VALIDATION_CHECKS
and eax, 0effeffffh
;HEAP_GROWABLE
;+ HEAP_TAIL_CHECKING_ENABLED
;+ HEAP_FREE_CHECKING_ENABLED
;+ HEAP_VALIDATE_PARAMETERS_ENABLED
cmp eax, 40000062h
je being_debugged</code></pre><p>32 位代码检测 32 位 windows 环境, 且<code>subsystem</code>为<code>3.51</code>及更高版本:</p>
<pre><code>call GetVersion
cmp al, 6
cmc
sbb ebx, ebx
and ebx, 34h
mov eax, fs:[30h] ;Process Environment Block
mov eax, [eax+18h] ;get process heap base
mov eax, [eax+ebx+0ch] ;Flags
;not HEAP_SKIP_VALIDATION_CHECKS
bswap eax
and al, 0efh
;HEAP_GROWABLE
;+ HEAP_TAIL_CHECKING_ENABLED
;+ HEAP_FREE_CHECKING_ENABLED
;+ HEAP_VALIDATE_PARAMETERS_ENABLED
;reversed by bswap
cmp eax, 62000040h
je being_debugged</code></pre><p>64 位代码检测 64 位 windows 环境 (64 位进程不必受<code>subsystem</code>版本困扰):</p>
<pre><code>push 60h
pop rsi
gs:lodsq ;Process Environment Block
mov ebx, [rax+30h] ;get process heap base
call GetVersion
cmp al, 6
sbb rax, rax
and al, 0a4h
;HEAP_GROWABLE
;+ HEAP_TAIL_CHECKING_ENABLED
;+ HEAP_FREE_CHECKING_ENABLED
;+ HEAP_VALIDATE_PARAMETERS_ENABLED
cmp d [rbx+rax+70h], 40000062h ;Flags
je being_debugged</code></pre><p>用 32 位代码检测 64 位 windows 环境:</p>
<pre><code>push 30h
pop eax
mov ebx, fs:[eax] ;Process Environment Block
;64-bit Process Environment Block
;follows 32-bit Process Environment Block
mov ah, 10h
mov ebx, [ebx+eax] ;get process heap base
call GetVersion
cmp al, 6
sbb eax, eax
and al, 0a4h
;Flags
;HEAP_GROWABLE
;+ HEAP_TAIL_CHECKING_ENABLED
;+ HEAP_FREE_CHECKING_ENABLED
;+ HEAP_VALIDATE_PARAMETERS_ENABLED
cmp [ebx+eax+70h], 40000062h
je being_debugged</code></pre><p>如果是直接通过<code>KUSER_SHARED_DATA</code>结构的<code>NtMajorVersion</code>字段 (位于 2G 用户空间的<code>0x7ffe026c</code>偏移处) 获取该值 (在所有 32 位 / 64 位版本的 Windows 都可以获取该值), 可以进一步混淆<code>kernel32</code>的<code>GetVersion()</code>函数调用操作.</p>
<h2 id="检测-ForgeFlags-字段"><a href="#检测-ForgeFlags-字段" class="headerlink" title="检测 ForgeFlags 字段"></a>检测 ForgeFlags 字段</h2><p>当然另一个方法就是检测<code>ForgeFlags</code>字段, 以下是 32 位代码检测 32 位 Windows 环境, <code>subsystem</code>版本在<code>3.10-3.50</code>之间:</p>
<pre><code>call GetVersion
cmp al, 6
cmc
sbb ebx, ebx
and ebx, 34h
mov eax, fs:[30h] ;Process Environment Block
mov eax, [eax+18h] ;get process heap base
mov eax, [eax+ebx+10h] ;ForceFlags
;not HEAP_CREATE_ALIGN_16
btr eax, 10h
;HEAP_TAIL_CHECKING_ENABLED
;+ HEAP_FREE_CHECKING_ENABLED
;+ HEAP_VALIDATE_PARAMETERS_ENABLED
cmp eax, 40000060h
je being_debugged</code></pre><p>32 位代码检测 32 位 windows 环境, 且<code>subsystem</code>为<code>3.51</code>及更高版本:</p>
<pre><code>call GetVersion
cmp al, 6
cmc
sbb ebx, ebx
and ebx, 34h
mov eax, fs:[30h] ;Process Environment Block
mov eax, [eax+18h] ;get process heap base
;ForceFlags
;HEAP_TAIL_CHECKING_ENABLED
;+ HEAP_FREE_CHECKING_ENABLED
;+ HEAP_VALIDATE_PARAMETERS_ENABLED
cmp [eax+ebx+10h], 40000060h
je being_debugged</code></pre><p>64 位代码检测 64 位 windows 环境 (64 位进程不必受<code>subsystem</code>版本困扰):</p>
<pre><code>push 60h
pop rsi
gs:lodsq ;Process Environment Block
mov ebx, [rax+30h] ;get process heap base
call GetVersion
cmp al, 6
sbb rax, rax
and al, 0a4h
;ForceFlags
;HEAP_TAIL_CHECKING_ENABLED
;+ HEAP_FREE_CHECKING_ENABLED
;+ HEAP_VALIDATE_PARAMETERS_ENABLED
cmp d [rbx+rax+74h], 40000060h
je being_debugged</code></pre><p>用 32 位代码检测 64 位 windows 环境:</p>
<pre><code>call GetVersion
cmp al, 6
push 30h
pop eax
mov ebx, fs:[eax] ;Process Environment Block
;64-bit Process Environment Block
;follows 32-bit Process Environment Block
mov ah, 10h
mov ebx, [ebx+eax] ;get process heap base
sbb eax, eax
and al, 0a4h
;ForceFlags
;HEAP_TAIL_CHECKING_ENABLED
;+ HEAP_FREE_CHECKING_ENABLED
;+ HEAP_VALIDATE_PARAMETERS_ENABLED
cmp [ebx+eax+74h], 40000060h
je being_debugged</code></pre><h1 id="The-Heap"><a href="#The-Heap" class="headerlink" title="The Heap"></a>The Heap</h1><p>堆在初始化时, 会检查<code>heap flags</code>, 并视一些标志位的有无设置而对环境作出额外的改变. 像<code>Themida</code>就有采用这种方法来检测调试器.</p>
<p>比如:</p>
<ul>
<li>如果设置了<code>HEAP_TAIL_CHECKING_ENABLED</code>标志 (见<code>Heap Flags</code>节), 那么在 32 位 windows 中就会在分配的堆块尾部附加 2 个<code>0xABABABAB</code>(64 位环境就是 4 个).</li>
<li>如果设置了<code>HEAP_FREE_CHECKING_ENABLED</code>(见<code>Heap Flags</code>节) 标志, 那么当需要额外的字节来填充堆块尾部时, 就会使用<code>0xFEEEFEEE</code>(或一部分) 来填充</li>
</ul>
<p>那么, 一种新的检测调试器的方法就是来检查这些值.</p>
<h2 id="堆指针已知"><a href="#堆指针已知" class="headerlink" title="堆指针已知"></a>堆指针已知</h2><p>如果已知一个堆指针, 那么我们可以直接检查堆块里的数据. 然而在<code>Windows Vista</code>及更高版本中采用了堆保护机制 (32 位 / 64 位都有), 使用了一个异或密钥来对堆块大小进行了加密. 虽然你可以选择是否使用密钥, 但是默认是使用的. 而且就堆块首部的位置, 在<code>Windows NT/2000/XP</code>和<code>Windows Vista及更高版本</code>之间也是不相同的. 因此我们还需要将<code>Windows版本</code>也考虑在内.</p>
<p>可以使用以下 32 位代码来检测 32 位环境:</p>
<pre><code>    xor ebx, ebx
    call GetVersion
    cmp al, 6
    sbb ebp, ebp
    jb l1
    ;Process Environment Block
    mov eax, fs:[ebx+30h]
    mov eax, [eax+18h] ;get process heap base
    mov ecx, [eax+24h] ;check for protected heap
    jecxz l1
    mov ecx, [ecx]
    test [eax+4ch], ecx
    cmovne ebx, [eax+50h] ;conditionally get heap key
l1: mov eax, &lt;heap ptr&gt;
    movzx edx, w [eax-8] ;size
    xor dx, bx
    movzx ecx, b [eax+ebp-1] ;overhead
    sub eax, ecx
    lea edi, [edx*8+eax]
    mov al, 0abh
    mov cl, 8
    repe scasb
    je being_debugged</code></pre><p>或使用以下 64 位代码检测 64 位环境:</p>
<pre><code>    xor ebx, ebx
    call GetVersion
    cmp al, 6
    sbb rbp, rbp
    jb l1
    ;Process Environment Block
    mov rax, gs:[rbx+60h]
    mov eax, [rax+30h] ;get process heap base
    mov ecx, [rax+40h] ;check for protected heap
    jrcxz l1
    mov ecx, [rcx+8]
    test [rax+7ch], ecx
    cmovne ebx, [rax+88h] ;conditionally get heap key
l1: mov eax, &lt;heap ptr&gt;
    movzx edx, w [rax-8] ;size
    xor dx, bx
    add edx, edx
    movzx ecx, b [rax+rbp-1] ;overhead
    sub eax, ecx
    lea edi, [rdx*8+rax]
    mov al, 0abh
    mov cl, 10h
    repe scasb
    je being_debugged</code></pre><p>这里没有使用 32 位代码检测 64 位环境的样例, 因为 64 位的堆无法由 32 位的堆函数解析.</p>
<h2 id="堆指针未知"><a href="#堆指针未知" class="headerlink" title="堆指针未知"></a>堆指针未知</h2><p>如果无法得知堆指针, 我们可以使用<code>kernel32</code>的<code>HeapWalk()</code>函数或<code>ntdll</code>的<code>RtlWalkHeap()</code>函数 (或甚至是<code>kernel32</code>的<code>GetCommandLine()</code>函数). 返回的堆大小的值会被自动解密, 因此就不需要再关心 windows 的版本</p>
<p>可以使用以下 32 位代码来检测 32 位环境:</p>
<pre><code>    mov ebx, offset l2
    ;get a pointer to a heap block
l1: push ebx
    mov eax, fs:[30h] ;Process Environment Block
    push d [eax+18h] ;save process heap base
    call HeapWalk
    cmp w [ebx+0ah], 4 ;find allocated block
    jne l1
    mov edi, [ebx] ;data pointer
    add edi, [ebx+4] ;data size
    mov al, 0abh
    push 8
    pop ecx
    repe scasb
    je being_debugged
    ...
l2: db 1ch dup (0) ;sizeof(PROCESS_HEAP_ENTRY)</code></pre><p>或使用以下 64 位代码检测 64 位环境:</p>
<pre><code>    mov rbx, offset l2
    ;get a pointer to a heap block
l1: push rbx
    pop rdx
    push 60h
    pop rsi
    gs:lodsq ;Process Environment Block
    ;get a pointer to process heap base
    mov ecx, [rax+30h]
    call HeapWalk
    cmp w [rbx+0eh], 4 ;find allocated block
    jne l1
    mov edi, [rbx] ;data pointer
    add edi, [rbx+8] ;data size
    mov al, 0abh
    push 10h
    pop rcx
    repe scasb
    je being_debugged
    ...
l2: db 28h dup (0) ;sizeof(PROCESS_HEAP_ENTRY)</code></pre><p>这里没有使用 32 位代码检测 64 位环境的样例, 因为 64 位的堆无法由 32 位的堆函数解析.</p>
<h1 id="Interrupt-3"><a href="#Interrupt-3" class="headerlink" title="Interrupt 3"></a>Interrupt 3</h1><p>无论何时触发了一个软件中断异常, 异常地址以及 EIP 寄存器的值都会同时指向产生异常的下一句指令. 但断点异常是其中的一个特例.</p>
<p>当<code>EXCEPTION_BREAKPOINT(0x80000003)</code>异常触发时, Windows 会认定这是由单字节的 “<code>CC</code>“ 操作码 (也即<code>Int 3</code>指令) 造成的. Windows 递减异常地址以指向所认定的 “<code>CC</code>“ 操作码, 随后传递该异常给异常处理句柄. 但是 EIP 寄存器的值并不会发生变化.</p>
<p>因此, 如果使用了 <code>CD 03</code>（这是 <code>Int 03</code> 的机器码表示），那么当异常处理句柄接受控制时, 异常地址是指向 <code>03</code> 的位置.</p>
<h1 id="sDebuggerPresent"><a href="#sDebuggerPresent" class="headerlink" title="sDebuggerPresent"></a>sDebuggerPresent</h1><h2 id="关于-IsDebuggerPresent"><a href="#关于-IsDebuggerPresent" class="headerlink" title="关于 IsDebuggerPresent"></a>关于 IsDebuggerPresent</h2><p>当调试器存在时, <code>kernel32</code>的<code>IsDebuggerPresent()</code>函数返回的是一个<code>非0值</code>.</p>
<pre><code>BOOL WINAPI IsDebuggerPresent(void);</code></pre><h2 id="检测代码-1"><a href="#检测代码-1" class="headerlink" title="检测代码"></a>检测代码</h2><p>它的检测方法非常简单, 比如用以下代码 (32 位还是 64 位都是相同的这份代码) 在 32 位 / 64 位环境中检测:</p>
<pre><code>call IsDebuggerPresent
test al, al
jne being_debugged</code></pre><p>实际上, 这个函数只是单纯地返回了<code>BeingDebugged</code>标志的值. 检查<code>BeingDebugged</code>标志位的方法也可以用以下 32 代码位代码检查 32 位环境来实现:</p>
<pre><code>mov eax, fs:[30h] ;Process Environment Block
cmp b [eax+2], 0 ;check BeingDebugged
jne being_debugged</code></pre><p>或使用 64 位代码检测 64 位环境</p>
<pre><code>push 60h
pop rsi
gs:lodsq ;Process Environment Block
cmp b [rax+2], 0 ;check BeingDebugged
jne being_debugged</code></pre><p>或使用 32 位代码检测 64 位环境</p>
<pre><code>mov eax, fs:[30h] ;Process Environment Block
;64-bit Process Environment Block
;follows 32-bit Process Environment Block
cmp b [eax+1002h], 0 ;check BeingDebugged
jne being_debugged</code></pre><h2 id="如何绕过"><a href="#如何绕过" class="headerlink" title="如何绕过"></a>如何绕过</h2><p>想要克服这些检测, 只需要将<code>BeingDebugged</code>标志设为<code>0</code>即可 (或改变一下返回值).</p>
<h1 id="CheckRemoteDebuggerPresent"><a href="#CheckRemoteDebuggerPresent" class="headerlink" title="CheckRemoteDebuggerPresent"></a>CheckRemoteDebuggerPresent</h1><h2 id="关于-CheckRemoteDebuggerPresent"><a href="#关于-CheckRemoteDebuggerPresent" class="headerlink" title="关于 CheckRemoteDebuggerPresent"></a>关于 CheckRemoteDebuggerPresent</h2><p><code>kernel32</code>的<code>CheckRemoteDebuggerPresent()</code>函数用于检测指定进程是否正在被调试. <code>Remote</code>在单词里是指同一个机器中的不同进程.</p>
<pre><code>BOOL WINAPI CheckRemoteDebuggerPresent(
  _In_    HANDLE hProcess,
  _Inout_ PBOOL  pbDebuggerPresent
);</code></pre><p>如果调试器存在 (通常是检测自己是否正在被调试), 该函数会将<code>pbDebuggerPresent</code>指向的值设为<code>0xffffffff</code>.</p>
<h2 id="检测代码-2"><a href="#检测代码-2" class="headerlink" title="检测代码"></a>检测代码</h2><p>可以用以下 32 位代码检测 32 位环境</p>
<pre><code>push eax
push esp
push -1 ;GetCurrentProcess()
call CheckRemoteDebuggerPresent
pop eax
test eax, eax
jne being_debugged</code></pre><p>或 64 位代码检测 64 位环境</p>
<pre><code>enter 20h, 0
mov edx, ebp
or rcx, -1 ;GetCurrentProcess()
call CheckRemoteDebuggerPresent
leave
test ebp, ebp
jne being_debugged</code></pre><h2 id="如何绕过-1"><a href="#如何绕过-1" class="headerlink" title="如何绕过"></a>如何绕过</h2><p>比如有如下的代码</p>
<pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    BOOL isDebuggerPresent <span class="token operator">=</span> FALSE<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">CheckRemoteDebuggerPresent</span><span class="token punctuation">(</span><span class="token function">GetCurrentProcess</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>isDebuggerPresent <span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>isDebuggerPresent <span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            std<span class="token punctuation">:</span><span class="token punctuation">:</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Stop debugging program!"</span> <span class="token operator">&lt;&lt;</span> std<span class="token punctuation">:</span><span class="token punctuation">:</span>endl<span class="token punctuation">;</span>
            <span class="token function">exit</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们可以直接修改<code>isDebuggerPresent</code>的值或修改跳转条件来绕过 (注意不是<code>CheckRemoteDebuggerPresent</code>的 izhi, 它的返回值是用于表示函数是否正确执行).</p>
<p>但如果要针对<code>CheckRemoteDebuggerPresent</code>这个 api 函数进行修改的话. 首先要知道<code>CheckRemoteDebuggerPresent</code>内部其实是通过调用<code>NtQueryInformationProcess</code>来完成功能的. 而我们就需要对<code>NtQueryInformationProcess</code>的返回值进行修改. 我们将在<a href="https://ctf-wiki.org/reverse/windows/anti-debug/ntqueryinformationprocess/" target="_blank" rel="noopener"> NtQueryInformationProcess 篇</a>进行介绍.</p>
<h1 id="NtQueryInformationProcess"><a href="#NtQueryInformationProcess" class="headerlink" title="NtQueryInformationProcess"></a>NtQueryInformationProcess</h1><pre><code>NTSTATUS WINAPI NtQueryInformationProcess(
  _In_      HANDLE           ProcessHandle,
  _In_      PROCESSINFOCLASS ProcessInformationClass,
  _Out_     PVOID            ProcessInformation,
  _In_      ULONG            ProcessInformationLength,
  _Out_opt_ PULONG           ReturnLength
);</code></pre><h2 id="ProcessDebugPort"><a href="#ProcessDebugPort" class="headerlink" title="ProcessDebugPort"></a>ProcessDebugPort</h2><p>未公开的<code>ntdll</code>的<code>NtQueryInformationProcess()</code>函数接受一个信息类的参数用于查询. <code>ProcessDebugPort(7)</code>是其中的一个信息类. <code>kernel32</code>的<code>CheckRemoteDebuggerPresent()</code>函数内部通过调用<code>NtQueryInformationProcess()</code>来检测调试, 而<code>NtQueryInformationProcess</code>内部则是查询<code>EPROCESS</code>结构体的<code>DebugPort</code>字段, 当进程正在被调试时, 返回值为<code>0xffffffff</code>.</p>
<p>可以用以下 32 位代码在 32 位环境进行检测:</p>
<pre><code>push eax
mov eax, esp
push 0
push 4 ;ProcessInformationLength
push eax
push 7 ;ProcessDebugPort
push -1 ;GetCurrentProcess()
call NtQueryInformationProcess
pop eax
inc eax
je being_debugged</code></pre><p>用以下 64 位代码在 64 位环境进行检测:</p>
<pre><code>xor ebp, ebp
enter 20h, 0
push 8 ;ProcessInformationLength
pop r9
push rbp
pop r8
push 7 ;ProcessDebugPort
pop rdx
or rcx, -1 ;GetCurrentProcess()
call NtQueryInformationProcess
leave
test ebp, ebp
jne being_debugged</code></pre><p>由于信息传自内核, 所以在用户模式下的代码没有轻松的方法阻止该函数检测调试器.</p>
<h2 id="ProcessDebugObjectHandle"><a href="#ProcessDebugObjectHandle" class="headerlink" title="ProcessDebugObjectHandle"></a>ProcessDebugObjectHandle</h2><p>Windows XP 引入了<code>debug对象</code>, 当一个调试会话启动, 会同时创建一个<code>debug</code>对象以及与之关联的句柄. 我们可以使用<code>ProcessDebugObjectHandle (0x1e)</code>类来查询这个句柄的值</p>
<p>可以用以下 32 位代码在 32 位环境进行检测:</p>
<pre><code>push 0
mov eax, esp
push 0
push 4 ;ProcessInformationLength
push eax
push 1eh ;ProcessDebugObjectHandle
push -1 ;GetCurrentProcess()
call NtQueryInformationProcess
pop eax
test eax, eax
jne being_debugged</code></pre><p>用以下 64 位代码在 64 位环境进行检测:</p>
<pre><code>xor ebp, ebp
enter 20h, 0
push 8 ;ProcessInformationLength
pop r9
push rbp
pop r8
push 1eh ;ProcessDebugObjectHandle
pop rdx
or rcx, -1 ;GetCurrentProcess()
call NtQueryInformationProcess
leave
test ebp, ebp
jne being_debugged</code></pre><h2 id="ProcessDebugFlags"><a href="#ProcessDebugFlags" class="headerlink" title="ProcessDebugFlags"></a>ProcessDebugFlags</h2><p><code>ProcessDebugFlags (0x1f)</code>类返回<code>EPROCESS</code>结构体的<code>NoDebugInherit</code>的相反数. 意思是, 当调试器存在时, 返回值为<code>0</code>, 不存在时则返回<code>1</code>.</p>
<p>可以用以下 32 位代码在 32 位环境进行检测:</p>
<pre><code>push eax
mov eax, esp
push 0
push 4 ;ProcessInformationLength
push eax
push 1fh ;ProcessDebugFlags
push -1 ;GetCurrentProcess()
call NtQueryInformationProcess
pop eax
test eax, eax
je being_debugged</code></pre><p>用以下 64 位代码在 64 位环境进行检测:</p>
<pre><code>xor ebp, ebp
enter 20h, 0
push 4 ;ProcessInformationLength
pop r9
push rbp
pop r8
push 1fh ;ProcessDebugFlags
pop rdx
or rcx, -1 ;GetCurrentProcess()
call NtQueryInformationProcess
leave
test ebp, ebp
je being_debugged</code></pre><h1 id="ZwSetInformationThread"><a href="#ZwSetInformationThread" class="headerlink" title="ZwSetInformationThread"></a>ZwSetInformationThread</h1><h2 id="关于-ZwSetInformationThread"><a href="#关于-ZwSetInformationThread" class="headerlink" title="关于 ZwSetInformationThread"></a>关于 ZwSetInformationThread</h2><p>ZwSetInformationThread 等同于 NtSetInformationThread，通过为线程设置 ThreadHideFromDebugger，可以禁止线程产生调试事件，代码如下</p>
<pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;Windows.h></span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>

<span class="token keyword">typedef</span> <span class="token function">DWORD</span><span class="token punctuation">(</span>WINAPI<span class="token operator">*</span> ZW_SET_INFORMATION_THREAD<span class="token punctuation">)</span> <span class="token punctuation">(</span>HANDLE<span class="token punctuation">,</span> DWORD<span class="token punctuation">,</span> PVOID<span class="token punctuation">,</span> ULONG<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token macro property">#<span class="token directive keyword">define</span> ThreadHideFromDebugger 0x11</span>
VOID <span class="token function">DisableDebugEvent</span><span class="token punctuation">(</span>VOID<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    HINSTANCE hModule<span class="token punctuation">;</span>
    ZW_SET_INFORMATION_THREAD ZwSetInformationThread<span class="token punctuation">;</span>
    hModule <span class="token operator">=</span> <span class="token function">GetModuleHandleA</span><span class="token punctuation">(</span><span class="token string">"Ntdll"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    ZwSetInformationThread <span class="token operator">=</span> <span class="token punctuation">(</span>ZW_SET_INFORMATION_THREAD<span class="token punctuation">)</span><span class="token function">GetProcAddress</span><span class="token punctuation">(</span>hModule<span class="token punctuation">,</span> <span class="token string">"ZwSetInformationThread"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">ZwSetInformationThread</span><span class="token punctuation">(</span><span class="token function">GetCurrentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> ThreadHideFromDebugger<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Begin\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">DisableDebugEvent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"End\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>关键代码为<code>ZwSetInformationThread(GetCurrentThread(), ThreadHideFromDebugger, 0, 0);</code>，如果处于调试状态，执行完该行代码，程序就会退出</p>
<h2 id="如何绕过-2"><a href="#如何绕过-2" class="headerlink" title="如何绕过"></a>如何绕过</h2><p>注意到该处 ZwSetInformationThread 函数的第 2 个参数为 ThreadHideFromDebugger，其值为 0x11。调试执行到该函数时，若发现第 2 个参数值为 0x11，跳过或者将 0x11 修改为其他值即可</p>
<h1 id="花指令"><a href="#花指令" class="headerlink" title="花指令"></a>花指令</h1><h2 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h2><p>花指令是企图隐藏掉不想被逆向工程的代码块 (或其它功能) 的一种方法, 在真实代码中插入一些垃圾代码的同时还保证原有程序的正确执行, 而程序无法很好地反编译, 难以理解程序内容, 达到混淆视听的效果.</p>
<h2 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h2><p>这里以<code>看雪.TSRC 2017CTF秋季赛</code>第二题作为讲解. 题目下载链接: <a href="https://github.com/ctf-wiki/ctf-challenges/blob/master/reverse/anti-debug/2017_pediy/ctf2017_Fpc.exe" target="_blank" rel="noopener">ctf2017_Fpc.exe</a></p>
<p>程序写了几个函数混淆视听, 将关键的验证逻辑加花指令防止了 IDA 的静态分析. 我们用 IDA 打开 Fpc 这道题, 程序会先打印一些提示信息, 然后获取用户的输入.</p>
<p><img src="/images/loading.gif" data-original="../images/CTF/main.png" alt=""></p>
<p>这里使用了不安全的<code>scanf</code>函数, 用户输入的缓冲区只有<code>0xCh</code>长, 我们双击<code>v1</code>进入栈帧视图</p>
<p><img src="/images/loading.gif" data-original="../images/CTF/stack.png" alt=""></p>
<p>因此我们可以通过溢出数据, 覆盖掉返回地址, 从而转移到任意地址继续执行.</p>
<p>这里我还需要解释一下, 就是<code>scanf</code>之前写的几个混淆视听的函数, 是一些简单的方程式但实际上是无解的. 程序将真正的验证逻辑加花混淆, 导致 IDA 无法很好的进行反编译. 所以我们这道题的思路就是, 通过溢出转到真正的验证代码处继续执行.</p>
<p>我们在分析时可以在代码不远处发现以下数据块.</p>
<p><img src="/images/loading.gif" data-original="../images/CTF/block.png" alt=""></p>
<p>因为 IDA 没能很好的识别数据, 因此我们可以将光标移到数据块的起始位置, 然后按下<code>C</code>键 (code) 将这块数据反汇编成代码</p>
<p><img src="/images/loading.gif" data-original="../images/CTF/real_code.png" alt=""></p>
<p>值得注意的是, 这段代码的位置是<code>0x00413131</code>, <code>0x41</code>是<code>'A'</code>的 ascii 码，而<code>0x31</code>是<code>'1'</code>的 ascii 码. 由于看雪比赛的限制, 用户输入只能是字母和数字, 所以我们也完全可以利用溢出漏洞执行这段代码</p>
<p>用 OD 打开, 然后<code>Ctrl+G</code>到达<code>0x413131</code>处设下断点, 运行后输入<code>12345612345611A</code>回车, 程序成功地到达<code>0x00413131</code>处. 然后<code>右键分析-&gt;从模块中删除分析</code>识别出正确代码</p>
<p><img src="/images/loading.gif" data-original="../images/CTF/entry.png" alt=""></p>
<p>断在<code>0x413131</code>处后, 点击菜单栏的<code>"查看"</code>, 选择<code>"RUN跟踪"</code>, 然后再点击<code>"调试"</code>, 选择<code>"跟踪步入"</code>, 程序会记录这段花指令执行的过程, 如下图所示:</p>
<p><img src="/images/loading.gif" data-original="../images/CTF/trace.png" alt=""></p>
<p>这段花指令本来很长, 但是使用 OD 的跟踪功能后, 花指令的执行流程就非常清楚. 整个过程中进行了大量的跳转, 我们只要取其中的有效指令拿出来分析即可.</p>
<p>需要注意的是, 在有效指令中, 我们依旧要满足一些条件跳转, 这样程序才能在正确的逻辑上一直执行下去.</p>
<p>比如<code>0x413420</code>处的<code>jnz ctf2017_.00413B03</code>. 我们就要重新来过, 并在<code>0x413420</code>设下断点</p>
<p><img src="/images/loading.gif" data-original="../images/CTF/jnz.png" alt=""></p>
<p>通过修改标志寄存器来满足跳转. 继续跟踪步入 (之后还有<code>0041362E jnz ctf2017_.00413B03</code>需要满足). 保证逻辑正确后, 将有效指令取出继续分析就好了</p>
<p><img src="/images/loading.gif" data-original="../images/CTF/register.png" alt=""></p>
<h1 id="反调试技术例题"><a href="#反调试技术例题" class="headerlink" title="反调试技术例题"></a>反调试技术例题</h1><p>我们现在来分析一道 2016 年 SecCon 的<code>anti-debugging</code>题, 题目下载链接: <a href="https://github.com/ctf-wiki/ctf-challenges/blob/master/reverse/anti-debug/2016_seccon/anti_debugging_100/bin.exe" target="_blank" rel="noopener">bin.exe</a></p>
<p>这是一个 32 位的 PE 文件, 是一个控制台程序, 我们直接运行, 会要求输入<code>password</code>. 当你输入一个错误的<code>password</code>时则会提示你<code>password is wrong</code>.</p>
<p><img src="/images/loading.gif" data-original="../images/CTF/run-1629299409941122.png" alt=""></p>
<p>我们用 IDA 打开来看下, 最快速的方式就是直接查看字符串, 根据<code>password is wrong</code>找到关键代码. IDA 显示的结果如下图:</p>
<p><img src="/images/loading.gif" data-original="../images/CTF/ida_strings-1629299409941124.png" alt=""></p>
<p>显然, 字符串表明程序中可能有各种检测, 比如检测进程名<code>ollydbg.exe</code>, <code>ImmunityDebugger.exe</code>, <code>idaq.exe</code>和<code>Wireshark.exe</code>. 然后也有其他的检测. 我们也看到了字符串<code>password is wrong</code>和<code>You password is correct</code>的字样. 同时还发现了一个很有可能就是待解密的 flag 的字符串. 那么我们就先根据<code>password is wrong</code>的交叉引用来到关键函数处.</p>
<p>如下所示: 程序果然使用了大量的反调试技巧.</p>
<pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> __cdecl <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>envp<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  v23 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token function">memset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>v24<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0x3Fu</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  v22 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Input password >"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  v3 <span class="token operator">=</span> <span class="token punctuation">(</span>FILE <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">sub_40223D</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">fgets</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>v23<span class="token punctuation">,</span> <span class="token number">64</span><span class="token punctuation">,</span> v3<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">strcpy</span><span class="token punctuation">(</span>v21<span class="token punctuation">,</span> <span class="token string">"I have a pen."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  v22 <span class="token operator">=</span> <span class="token function">strncmp</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>v23<span class="token punctuation">,</span> v21<span class="token punctuation">,</span> <span class="token number">0xDu</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 1. 直接比较明文字符串与输入字符串</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token operator">!</span>v22 <span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
    <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"Your password is correct."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token function">IsDebuggerPresent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span> <span class="token punctuation">)</span>     <span class="token comment" spellcheck="true">// 2. API: IsDebuggerPresent()</span>
    <span class="token punctuation">{</span>
      <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"But detected debugger!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token function">sub_401120</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0x70</span> <span class="token punctuation">)</span>         <span class="token comment" spellcheck="true">// 3. 检测PEB的0x68偏移处是否为0x70. 检测NtGlobalFlag()</span>
    <span class="token punctuation">{</span>
      <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"But detected NtGlobalFlag!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">/*  BOOL WINAPI CheckRemoteDebuggerPresent(
     *    _In_    HANDLE hProcess,
     *    _Inout_ PBOOL  pbDebuggerPresent
     *  );
     */</span>
    v4 <span class="token operator">=</span> <span class="token function">GetCurrentProcess</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">CheckRemoteDebuggerPresent</span><span class="token punctuation">(</span>v4<span class="token punctuation">,</span> <span class="token operator">&amp;</span>pbDebuggerPresent<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span> pbDebuggerPresent <span class="token punctuation">)</span>            <span class="token comment" spellcheck="true">// 4. API: CheckRemoteDebuggerPresent()</span>
    <span class="token punctuation">{</span>
      <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"But detected remotedebug.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    v13 <span class="token operator">=</span> <span class="token function">GetTickCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">==</span> <span class="token number">100</span><span class="token punctuation">;</span> <span class="token operator">++</span>i <span class="token punctuation">)</span>
      <span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">1u</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    v16 <span class="token operator">=</span> <span class="token number">1000</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token function">GetTickCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> v13 <span class="token operator">></span> <span class="token number">1000</span> <span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// 5. 检测时间差</span>
    <span class="token punctuation">{</span>
      <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"But detected debug.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    lpFileName <span class="token operator">=</span> <span class="token string">"\\\\.\\Global\\ProcmonDebugLogger"</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token function">CreateFileA</span><span class="token punctuation">(</span><span class="token string">"\\\\.\\Global\\ProcmonDebugLogger"</span><span class="token punctuation">,</span> <span class="token number">0x80000000</span><span class="token punctuation">,</span> <span class="token number">7u</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">3u</span><span class="token punctuation">,</span> <span class="token number">0x80u</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token punctuation">(</span>HANDLE<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span> <span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
      <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"But detect %s.\n"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>lpFileName<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 6. 检测ProcessMonitor</span>
      <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    v11 <span class="token operator">=</span> <span class="token function">sub_401130</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 7. API: CreateToolhelp32Snapshot()检测进程</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span> v11 <span class="token operator">==</span> <span class="token number">1</span> <span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
      <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"But detected Ollydbg.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span> v11 <span class="token operator">==</span> <span class="token number">2</span> <span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
      <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"But detected ImmunityDebugger.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span> v11 <span class="token operator">==</span> <span class="token number">3</span> <span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
      <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"But detected IDA.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span> v11 <span class="token operator">==</span> <span class="token number">4</span> <span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
      <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"But detected WireShark.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token function">sub_401240</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span> <span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 8. 通过vmware的I/O端口进行检测</span>
    <span class="token punctuation">{</span>
      <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"But detected VMware.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    v17 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    v20 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    v12 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    v19 <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">/</span> <span class="token number">0</span><span class="token punctuation">;</span>
    ms_exc<span class="token punctuation">.</span>registration<span class="token punctuation">.</span>TryLevel <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 9. SEH</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"But detected Debugged.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"password is wrong.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我在代码里写了注释, 列出了其中所使用的 9 个保护技术部分. 我们来逐一分析一下吧.</p>
<h2 id="比较明文字符串"><a href="#比较明文字符串" class="headerlink" title="比较明文字符串"></a>比较明文字符串</h2><pre class="line-numbers language-c"><code class="language-c"><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Input password >"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
v3 <span class="token operator">=</span> <span class="token punctuation">(</span>FILE <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">sub_40223D</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">fgets</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>v23<span class="token punctuation">,</span> <span class="token number">64</span><span class="token punctuation">,</span> v3<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">strcpy</span><span class="token punctuation">(</span>v21<span class="token punctuation">,</span> <span class="token string">"I have a pen."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
v22 <span class="token operator">=</span> <span class="token function">strncmp</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>v23<span class="token punctuation">,</span> v21<span class="token punctuation">,</span> <span class="token number">0xDu</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 1. 直接比较明文字符串与输入字符串</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token operator">!</span>v22 <span class="token punctuation">)</span>  <span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里就是输出<code>Input password &gt;</code>. 然后用<code>fgets()</code>获取用户输入的字符串, 将<code>I have a pen.</code>复制到<code>v21</code>的缓冲区中, 然后用<code>strncmp</code>比对用户输入与<code>I have a pen.</code>的内容, 并将比较结果返回给<code>v22</code>. 以下会根据<code>v22</code>, 也就是根据输入的<code>password</code>是否正确, 而进行跳转.</p>
<h2 id="IsDebuggerPresent"><a href="#IsDebuggerPresent" class="headerlink" title="IsDebuggerPresent()"></a>IsDebuggerPresent()</h2><pre class="line-numbers language-c"><code class="language-c"><span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"Your password is correct."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token function">IsDebuggerPresent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span> <span class="token punctuation">)</span>     <span class="token comment" spellcheck="true">// 2. API: IsDebuggerPresent()</span>
<span class="token punctuation">{</span>
    <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"But detected debugger!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>显然, 输入的<code>password</code>正确, 就会输出提示<code>Your password is correct.</code>. ??? 不觉得奇怪吗. 难道<code>I have a pen.</code>就是我们的 flag 了吗? 不不不当然不是. 这其实是一个陷阱, 既然你知道了<code>I have a pen.</code>那么就肯定有通过某种逆向手段在对程序进行分析. 所以接下来的部分就开始进行一些反调试或其他的检测手段 (实际中也可以出现这样的陷阱).</p>
<p>一开始的是<code>IsDebuggerPresent()</code>, 根据返回结果判断是否存在调试. 如果不太清楚的话, 可以返回去看 <a href="https://ctf-wiki.org/reverse/windows/anti-debug/isdebuggerpresent/" target="_blank" rel="noopener">IsDebuggerPresent()</a> 篇</p>
<h2 id="NtGlobalFlag-1"><a href="#NtGlobalFlag-1" class="headerlink" title="NtGlobalFlag"></a>NtGlobalFlag</h2><p>接下来是检测<code>NtGlobalFlag</code>这个字段的标志位. 通过检测 PEB 的字段值是否为<code>0x70</code>来检测调试器, 如果不太清楚的话, 可以返回去看 <a href="https://ctf-wiki.org/reverse/windows/anti-debug/ntglobalflag/" target="_blank" rel="noopener">NtGlobalFlag</a> 篇</p>
<pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token function">sub_401120</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0x70</span> <span class="token punctuation">)</span>         <span class="token comment" spellcheck="true">// 3. 检测PEB的0x68偏移处是否为0x70. 检测NtGlobalFlag()</span>
<span class="token punctuation">{</span>
    <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"But detected NtGlobalFlag!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>那我们来简单看一下<code>sub_401120()</code>好了</p>
<pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">sub_401120</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token operator">*</span><span class="token punctuation">(</span>_DWORD <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">__readfsdword</span><span class="token punctuation">(</span><span class="token number">48</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">0x68</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0x70</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>0x68</code>是 PEB 的<code>NtGlobalFlag</code>字段对应偏移值. <code>0x70</code>是<code>FLG_HEAP_ENABLE_TAIL_CHECK (0x10)</code>, <code>FLG_HEAP_ENABLE_FREE_CHECK (0x20)</code> 和<code>FLG_HEAP_VALIDATE_PARAMETERS (0x40)</code>这三个标志</p>
<h2 id="CheckRemoteDebuggerPresent-1"><a href="#CheckRemoteDebuggerPresent-1" class="headerlink" title="CheckRemoteDebuggerPresent"></a>CheckRemoteDebuggerPresent</h2><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">/*  BOOL WINAPI CheckRemoteDebuggerPresent(
 *    _In_    HANDLE hProcess,
 *    _Inout_ PBOOL  pbDebuggerPresent
 *  );
 */</span>
v4 <span class="token operator">=</span> <span class="token function">GetCurrentProcess</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">CheckRemoteDebuggerPresent</span><span class="token punctuation">(</span>v4<span class="token punctuation">,</span> <span class="token operator">&amp;</span>pbDebuggerPresent<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span> pbDebuggerPresent <span class="token punctuation">)</span>            <span class="token comment" spellcheck="true">// 4. API: CheckRemoteDebuggerPresent()</span>
<span class="token punctuation">{</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"But detected remotedebug.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里我顺便在注释里列出了<code>CheckRemoteDebuggerPresent()</code>这个 API 的函数原型. 如果检测到调试器的存在, 会将<code>pbDebuggerPresent</code>设置为一个非零值. 根据其值检测调试器 (<a href="https://ctf-wiki.org/reverse/windows/anti-debug/checkremotedebuggerpresent/" target="_blank" rel="noopener">CheckRemoteDebuggerPresent()</a> 篇)</p>
<h2 id="时间差检测"><a href="#时间差检测" class="headerlink" title="时间差检测"></a>时间差检测</h2><pre class="line-numbers language-c"><code class="language-c">v13 <span class="token operator">=</span> <span class="token function">GetTickCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">==</span> <span class="token number">100</span><span class="token punctuation">;</span> <span class="token operator">++</span>i <span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 睡眠</span>
    <span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">1u</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
v16 <span class="token operator">=</span> <span class="token number">1000</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token function">GetTickCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> v13 <span class="token operator">></span> <span class="token number">1000</span> <span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// 5. 检测时间差</span>
<span class="token punctuation">{</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"But detected debug.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>GetTickCount</code>会返回启动到现在的毫秒数, 循环里光是<code>sleep(1)</code>就进行了 100 次, 也就是 100 毫秒. 两次得到的时间作差如果大于 1000 毫秒, 时差明显大于所耗的时间, 也就间接检测到了调试.</p>
<h2 id="ProcessMonitor"><a href="#ProcessMonitor" class="headerlink" title="ProcessMonitor"></a>ProcessMonitor</h2><pre class="line-numbers language-c"><code class="language-c">lpFileName <span class="token operator">=</span> <span class="token string">"\\\\.\\Global\\ProcmonDebugLogger"</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token function">CreateFileA</span><span class="token punctuation">(</span><span class="token string">"\\\\.\\Global\\ProcmonDebugLogger"</span><span class="token punctuation">,</span> <span class="token number">0x80000000</span><span class="token punctuation">,</span> <span class="token number">7u</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">3u</span><span class="token punctuation">,</span> <span class="token number">0x80u</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token punctuation">(</span>HANDLE<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span> <span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"But detect %s.\n"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>lpFileName<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 6. 检测ProcessMonitor</span>
    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里通过检测设备文件<code>\\\\.\\Global\\ProcmonDebugLogger</code>来检测<code>ProcessMonitor</code></p>
<h2 id="检测进程名"><a href="#检测进程名" class="headerlink" title="检测进程名"></a>检测进程名</h2><p>这里通过执行<code>sub_401130()</code>函数来检测进程, 并根据检测到的不同进程, 返回相应的值.</p>
<pre class="line-numbers language-c"><code class="language-c">v11 <span class="token operator">=</span> <span class="token function">sub_401130</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 7. API: CreateToolhelp32Snapshot()检测进程</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span> v11 <span class="token operator">==</span> <span class="token number">1</span> <span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"But detected Ollydbg.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span> v11 <span class="token operator">==</span> <span class="token number">2</span> <span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"But detected ImmunityDebugger.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span> v11 <span class="token operator">==</span> <span class="token number">3</span> <span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"But detected IDA.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span> v11 <span class="token operator">==</span> <span class="token number">4</span> <span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"But detected WireShark.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们就来看一下<code>sub_401130()</code>函数</p>
<pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">signed</span> <span class="token keyword">int</span> <span class="token function">sub_401130</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  PROCESSENTRY32 pe<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// [sp+0h] [bp-138h]@1</span>
  HANDLE hSnapshot<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// [sp+130h] [bp-8h]@1</span>
  <span class="token keyword">int</span> i<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// [sp+134h] [bp-4h]@1</span>

  pe<span class="token punctuation">.</span>dwSize <span class="token operator">=</span> <span class="token number">296</span><span class="token punctuation">;</span>
  <span class="token function">memset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pe<span class="token punctuation">.</span>cntUsage<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0x124u</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  hSnapshot <span class="token operator">=</span> <span class="token function">CreateToolhelp32Snapshot</span><span class="token punctuation">(</span><span class="token number">2u</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span> i <span class="token operator">=</span> <span class="token function">Process32First</span><span class="token punctuation">(</span>hSnapshot<span class="token punctuation">,</span> <span class="token operator">&amp;</span>pe<span class="token punctuation">)</span><span class="token punctuation">;</span> i <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">=</span> <span class="token function">Process32Next</span><span class="token punctuation">(</span>hSnapshot<span class="token punctuation">,</span> <span class="token operator">&amp;</span>pe<span class="token punctuation">)</span> <span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token operator">!</span><span class="token function">_stricmp</span><span class="token punctuation">(</span>pe<span class="token punctuation">.</span>szExeFile<span class="token punctuation">,</span> <span class="token string">"ollydbg.exe"</span><span class="token punctuation">)</span> <span class="token punctuation">)</span>
      <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token operator">!</span><span class="token function">_stricmp</span><span class="token punctuation">(</span>pe<span class="token punctuation">.</span>szExeFile<span class="token punctuation">,</span> <span class="token string">"ImmunityDebugger.exe"</span><span class="token punctuation">)</span> <span class="token punctuation">)</span>
      <span class="token keyword">return</span> <span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token operator">!</span><span class="token function">_stricmp</span><span class="token punctuation">(</span>pe<span class="token punctuation">.</span>szExeFile<span class="token punctuation">,</span> <span class="token string">"idaq.exe"</span><span class="token punctuation">)</span> <span class="token punctuation">)</span>
      <span class="token keyword">return</span> <span class="token number">3</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token operator">!</span><span class="token function">_stricmp</span><span class="token punctuation">(</span>pe<span class="token punctuation">.</span>szExeFile<span class="token punctuation">,</span> <span class="token string">"Wireshark.exe"</span><span class="token punctuation">)</span> <span class="token punctuation">)</span>
      <span class="token keyword">return</span> <span class="token number">4</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里使用了 API: <code>CreateToolhelp32Snapshot</code>来获取当前的进程信息. 并在 for 循环里依次比对. 如果找到指定的进程名, 就直接返回相应的值. 然后根据返回值跳转到不同的分支里.</p>
<h2 id="检测-VMware"><a href="#检测-VMware" class="headerlink" title="检测 VMware"></a>检测 VMware</h2><p>检测 VMware 也是检测一些特征. 根据检测的结果进行判断.</p>
<pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token function">sub_401240</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span> <span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 8. 通过vmware的I/O端口进行检测</span>
<span class="token punctuation">{</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"But detected VMware.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>来看<code>sub_401240()</code>函数.</p>
<pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">signed</span> <span class="token keyword">int</span> <span class="token function">sub_401240</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">unsigned</span> __int32 v0<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// eax@1</span>

  v0 <span class="token operator">=</span> <span class="token function">__indword</span><span class="token punctuation">(</span><span class="token number">0x5658u</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这是 VMware 的一个 “后门”I/O 端口, <code>0x5658 = "VX"</code>. 如果程序在 VMware 内运行, 程序使用<code>In</code>指令通过<code>0x5658</code>端口读取数据时, <code>EBX</code>寄存器的值就会变为<code>0x564D5868</code>(<code>0x564D5868 == "VMXh"</code>)</p>
<p>看 IDA 反编译出的伪 C 代码并不很直观地体现这点, 我们看汇编代码就清楚了</p>
<pre><code>.text:0040127A                 push    edx
.text:0040127B                 push    ecx
.text:0040127C                 push    ebx
.text:0040127D                 mov     eax, 564D5868h   //  &lt;------
.text:00401282                 mov     ebx, 0
.text:00401287                 mov     ecx, 0Ah
.text:0040128C                 mov     edx, 5658h   //  &lt;------
.text:00401291                 in      eax, dx
.text:00401292                 pop     ebx
.text:00401293                 pop     ecx
.text:00401294                 pop     edx</code></pre><p>更多阅读: <a href="https://isc.sans.edu/diary/E-cards+don%3Ft+like+virtual+environments/3190" target="_blank" rel="noopener">E-cards don?t like virtual environments</a></p>
<h2 id="SEH"><a href="#SEH" class="headerlink" title="SEH"></a>SEH</h2><pre class="line-numbers language-c"><code class="language-c">v17 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
v20 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
v12 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
v19 <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">/</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 9. SEH</span>
ms_exc<span class="token punctuation">.</span>registration<span class="token punctuation">.</span>TryLevel <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">;</span>
<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"But detected Debugged.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>接下来这一段, 很奇怪不是吗. 这里<code>v19 = 1 / 0;</code>明显是不合常理的, 会产生一个除零异常. 而后面的<code>ms_exc.registration.TryLevel = -2;</code>这是解除异常, <code>TryLevel=TRYLEVEL_NONE (-2)</code> . 来看汇编代码.</p>
<pre><code>.text:004015B8                 mov     [ebp+var_88], 1
.text:004015C2                 mov     [ebp+var_7C], 1
.text:004015C9                 mov     [ebp+var_9C], 0
.text:004015D3                 mov     [ebp+ms_exc.registration.TryLevel], 0
.text:004015DA                 mov     eax, [ebp+var_7C]
.text:004015DD                 cdq
.text:004015DE                 idiv    [ebp+var_9C]
.text:004015E4                 mov     [ebp+var_80], eax
.text:004015E7                 mov     [ebp+ms_exc.registration.TryLevel], 0FFFFFFFEh
.text:004015EE                 jmp     short loc_40160A</code></pre><p>在这里的<code>idiv [ebp+var_9C]</code>触发异常后就由程序注册的异常处理函数接管, 而如果没有在异常处理程序入口设下断点的话, 程序就容易跑飞.</p>
<h2 id="获取-flag"><a href="#获取-flag" class="headerlink" title="获取 flag"></a>获取 flag</h2><p>但整个看下了. 怎么感觉关 flag 一点事都没有了呢? 还有没有记起之前在字符串窗口看到的疑似是那个待解密的 flag 的字符串? 实际上由于 IDA 反编译的限制, 使得反编译出的伪 C 代码并不正确. 比如在最后一段的<code>printf("But detected Debugged.\n");</code>这里, 我们来看具体的汇编代码.</p>
<pre><code>.text:00401627                 call    sub_4012E0
.text:0040162C                 movzx   eax, ax
.text:0040162F                 mov     [ebp+var_A8], eax
.text:00401635                 cmp     [ebp+var_A8], 0      // &lt;------
.text:0040163C                 jz      short loc_401652     // &lt;------
.text:0040163E                 push    offset aButDetectedD_2 ; "But detected Debugged.\n"
.text:00401643                 call    _printf
.text:00401648                 add     esp, 4
.text:0040164B                 push    1               ; int
.text:0040164D                 call    _exit</code></pre><p>实际上这一段代码并没有被 IDA 反编译出来. 而<code>loc_401652</code>位置则是一串代码, 亮点在于使用了一个<code>MessageBoxA</code>的函数. 而且函数参数之一就是我们的待解密 flag. 那么我们就可以在输入<code>I have a pen.</code>后, 在<code>if ( !v22 )</code>跳转的汇编代码部分, 将其手动改为跳转到 flag 解密及弹出<code>messagebox</code>的部分运行, 让程序自己帮忙解密并输出, 就可以了.</p>
<p>操作如下图所示:</p>
<p><img src="/images/loading.gif" data-original="../images/CTF/jmp.png" alt=""></p>
<p>这里是输入<code>I have a pen.</code>后的跳转部分, 因为正常跳转到的部分, 全是一些检测调试的内容, 所以我们直接跳到代码解密的部分. 也就是<code>00401663</code>的位置.</p>
<p><img src="/images/loading.gif" data-original="../images/CTF/target.png" alt=""></p>
<p>在<code>00401663</code>以上的<code>mov-cmp-jnz</code>也是一个验证部分, 就不管了, 直接跳到<code>00401663</code>这里的<code>mov ecx, 7</code>这里运行解密代码, 并顺着执行<code>MessageBoxA()</code>弹出消息框, 拿到 flag</p>
<p><img src="/images/loading.gif" data-original="../images/CTF/flag-1629299409942128.png" alt=""></p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://jackhcc.github.io" rel="external nofollow noreferrer">杰克成</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://jackhcc.github.io/posts/ctf-reverse.html">https://jackhcc.github.io/posts/ctf-reverse.html</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="https://jackhcc.github.io" target="_blank">杰克成</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/CTF-Reverse/">
                                    <span class="chip bg-color">CTF-Reverse</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/share/css/share.min.css">

<div id="article-share">
    
    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/medias/reward/aliqr.png" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/medias/reward/wxqr.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>
            
        </div>
    </div>

    
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/gitalk/gitalk.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/css/my-gitalk.css">

<div class="card gitalk-card" data-aos="fade-up">
    <div class="comment_headling" style="font-size: 20px; font-weight: 700; position: relative; left: 20px; top: 15px; padding-bottom: 5px;">
        <i class="fas fa-comments fa-fw" aria-hidden="true"></i>
        <span>评论</span>
    </div>
    <div id="gitalk-container" class="card-content"></div>
</div>

<script src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/gitalk/gitalk.min.js"></script>
<script>
    let gitalk = new Gitalk({
        clientID: '3821a0bbb773038a51fc',
        clientSecret: '4b30b507d67ec5497ec0e77f43f80cb3e0d7dd3a',
        repo: 'JackHCC.github.io',
        owner: 'JackHCC',
        admin: "JackHCC",
        id: '2021-08-19T22-44-38',
        distractionFreeMode: false  // Facebook-like distraction free mode
    });

    gitalk.render('gitalk-container');
</script>
    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/posts/ctf-pwn.html">
                    <div class="card-image">
                        
                        
                        <img src="/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/medias/featureimages/3.jpg" class="responsive-img" alt="CTF-Pwn Stack Overflow要点">
                        
                        <span class="card-title">CTF-Pwn Stack Overflow要点</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            CTF Pwn Stack Overflow学习要点
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2021-08-20
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/CTF/" class="post-category">
                                    CTF
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/CTF-Pwn/">
                        <span class="chip bg-color">CTF-Pwn</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/posts/blog-python14.html">
                    <div class="card-image">
                        
                        
                        <img src="/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/medias/featureimages/9.jpg" class="responsive-img" alt="Python-Redis详解">
                        
                        <span class="card-title">Python-Redis详解</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            Python Redis使用详解
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2021-08-18
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/Python/" class="post-category">
                                    Python
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Redis/">
                        <span class="chip bg-color">Redis</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/codeBlock/codeShrink.js"></script>


<!-- 代码块折行 -->

<style type="text/css">
code[class*="language-"], pre[class*="language-"] { white-space: pre !important; }
</style>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('4'),
            headingSelector: 'h1, h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h1, h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>


<script src="https://cdn.bootcss.com/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script>
    MathJax.Hub.Config({
        tex2jax: {inlineMath: [['$', '$'], ['\(', '\)']]}
    });
</script>


    <footer class="page-footer bg-color">
    <div class="container row center-align" style="margin-bottom: 15px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            <span id="year">2020</span>
            <a href="https://jackhcc.github.io" target="_blank">杰克成</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                class="white-color">3591.2k</span>&nbsp;字
            
            
            
            
            
            
            <span id="busuanzi_container_site_pv">
                |&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv"
                    class="white-color"></span>&nbsp;次
            </span>
            
            
            <span id="busuanzi_container_site_uv">
                |&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv"
                    class="white-color"></span>&nbsp;人
            </span>
            
            <br>
            
            <span id="sitetime">载入运行时间...</span>
            <script>
                function siteTime() {
                    var seconds = 1000;
                    var minutes = seconds * 60;
                    var hours = minutes * 60;
                    var days = hours * 24;
                    var years = days * 365;
                    var today = new Date();
                    var startYear = "2020";
                    var startMonth = "2";
                    var startDate = "27";
                    var startHour = "6";
                    var startMinute = "30";
                    var startSecond = "0";
                    var todayYear = today.getFullYear();
                    var todayMonth = today.getMonth() + 1;
                    var todayDate = today.getDate();
                    var todayHour = today.getHours();
                    var todayMinute = today.getMinutes();
                    var todaySecond = today.getSeconds();
                    var t1 = Date.UTC(startYear, startMonth, startDate, startHour, startMinute, startSecond);
                    var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
                    var diff = t2 - t1;
                    var diffYears = Math.floor(diff / years);
                    var diffDays = Math.floor((diff / days) - diffYears * 365);
                    var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours);
                    var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) /
                        minutes);
                    var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours -
                        diffMinutes * minutes) / seconds);
                    if (startYear == todayYear) {
                        document.getElementById("year").innerHTML = todayYear;
                        document.getElementById("sitetime").innerHTML = "本站已安全运行 " + diffDays + " 天 " + diffHours +
                            " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                    } else {
                        document.getElementById("year").innerHTML = startYear + " - " + todayYear;
                        document.getElementById("sitetime").innerHTML = "本站已安全运行 " + diffYears + " 年 " + diffDays +
                            " 天 " + diffHours + " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                    }
                }
                setInterval(siteTime, 1000);
            </script>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/JackHCC" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:jackcc0701@163.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>



    <a href="https://www.facebook.com/profile.php?id=100046343443643" class="tooltipped" target="_blank" data-tooltip="关注我的Facebook: https://www.facebook.com/profile.php?id=100046343443643" data-position="top" data-delay="50">
        <i class="fab fa-facebook-f"></i>
    </a>



    <a href="https://twitter.com/JackChe66021834" class="tooltipped" target="_blank" data-tooltip="关注我的Twitter: https://twitter.com/JackChe66021834" data-position="top" data-delay="50">
        <i class="fab fa-twitter"></i>
    </a>



    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=2508074836" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 2508074836" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>



    <a href="https://weibo.com/u/6885584679" class="tooltipped" target="_blank" data-tooltip="关注我的微博: https://weibo.com/u/6885584679" data-position="top" data-delay="50">
        <i class="fab fa-weibo"></i>
    </a>



    <a href="https://www.zhihu.com/people/8f8482f01f0d6a04e844efe32e0f0710" class="tooltipped" target="_blank" data-tooltip="关注我的知乎: https://www.zhihu.com/people/8f8482f01f0d6a04e844efe32e0f0710" data-position="top" data-delay="50">
        <i class="fab fa-zhihu1">知</i>
    </a>



</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/js/search.js"></script>
<script type="text/javascript">
$(function () {
    searchFunc("https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/" + "search.xml", 'searchInput', 'searchResult');
});
</script>
    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/materialize/materialize.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/aos/aos.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/js/matery.js"></script>

    <canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" ></canvas>
    <script type="text/javascript" src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script>
    <script type="text/javascript" src="/js/fireworks.js"></script>

    <script type="text/javascript">
        //只在桌面版网页启用特效
        var windowWidth = $(window).width();
        if (windowWidth > 768) {
            document.write('<script type="text/javascript" src="/js/sakura.js"><\/script>'); }
    </script>

    <!-- weather -->
	<script type="text/javascript">
	WIDGET = {FID: 'TToslpmkVO'}
	</script>
	<script type="text/javascript" src="https://apip.weatherdt.com/float/static/js/r.js?v=1111"></script>


    <!-- Global site tag (gtag.js) - Google Analytics -->


    <!-- Baidu Analytics -->

<script>
    var _hmt = _hmt || [];
    (function () {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
    })();
</script>

    <!-- Baidu Push -->

    
    
    <script async src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/others/busuanzi.pure.mini.js"></script>
    

    
        <script src="//code.tidio.co/kqhlkxviiccyoa0czpfpu4ijuey9hfre.js"></script>
        <script> 
            $(document).ready(function () {
                setInterval(change_Tidio, 50);  
                function change_Tidio() { 
                    var tidio=$("#tidio-chat iframe");
                    if(tidio.css("display")=="block"&& $(window).width()>977 ){
                        document.getElementById("tidio-chat-iframe").style.bottom= ($("div#backTop.top-scroll").css("display")=="none" &&$(window).width()>977)>0? "-40px" : ($("div.toc-title").length&&$(window).width()>977)>0?"85px":"20px";   
                        document.getElementById("tidio-chat-iframe").style.right="-15px";   
                        document.getElementById("tidio-chat-iframe").style.height=parseInt(tidio.css("height"))>=520?"520px":tidio.css("height");
                        document.getElementById("tidio-chat-iframe").style.zIndex="997";
                    } 
                    else if(tidio.css("display")=="block"&&$(window).width()>601 &&$(window).width()<992 ){
                        document.getElementById("tidio-chat-iframe").style.bottom= ($("div#backTop.top-scroll").css("display")=="none" && 601< $(window).width()<992)>0? "-40px":"20px" ;   
                        document.getElementById("tidio-chat-iframe").style.right="-15px"; 
                        document.getElementById("tidio-chat-iframe").style.zIndex="997";
                    }
                    else if(tidio.css("display")=="block"&&$(window).width()<601 && parseInt(tidio.css("height"))<230){
                        document.getElementById("tidio-chat-iframe").style.bottom= ($("div#backTop.top-scroll").css("display")=="none" && $(window).width()<601)>0? "-10px":"45px" ;   
                        document.getElementById("tidio-chat-iframe").style.zIndex="997";
                    }
                    if( tidio.css("display")=="block"&&$(window).width()<601 && parseInt(tidio.css("height"))>=230){
                        document.getElementById("tidio-chat-iframe").style.zIndex="998";
                    }
                } 
            }); 
        </script>
    

    

    
    <script type="text/javascript" color="0,0,255"
        pointColor="0,0,255" opacity='0.7'
        zIndex="-1" count="99"
        src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/background/canvas-nest.js"></script>
    

    

    
    <script type="text/javascript" src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/background/ribbon-dynamic.js" async="async"></script>
    
    
    
    <script src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/instantpage/instantpage.js" type="module"></script>
    

        <script src="//cdn.jsdelivr.net/npm/js-base64/base64.min.js"></script>
        <script>
        $('a').each(function() {
          const $this = $(this);
          const href = $this.attr('href');
          if (href && href.match('^((http|https|thunder|qqdl|ed2k|Flashget|qbrowser|ftp|rtsp|mms)://)')) {
            const strs = href.split('/');
            if (strs.length >= 3) {
                const host = strs[2];
                if (host !== 'your_domain' || window.location.host) {
                    $this.attr('href', '/go.html?u='+Base64.encode(href)+'').attr('rel', 'external nofollow noopener noreferrer');
                    if (true) {
                        $this.attr('target', '_blank');
                    }
                }
            }
          }
        });
        </script><script>!function(e){var c=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));function i(){for(var r=0;r<c.length;r++)t=c[r],0<=(n=t.getBoundingClientRect()).bottom&&0<=n.left&&n.top<=(e.innerHeight||document.documentElement.clientHeight)&&function(){var t,n,e,i,o=c[r];t=o,n=function(){c=c.filter(function(t){return o!==t})},e=new Image,i=t.getAttribute("data-original"),e.onload=function(){t.src=i,n&&n()},e.src=i}();var t,n}i(),e.addEventListener("scroll",function(){var t,n;t=i,n=e,clearTimeout(t.tId),t.tId=setTimeout(function(){t.call(n)},500)})}(this);</script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script></body>

</html>

