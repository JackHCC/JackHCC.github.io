<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="HarmonyOS开发：Java应用, JackHCC">
    <meta name="description" content="HarmonyOS Java应用开发手册">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>HarmonyOS开发：Java应用 | JackHCC</title>
    <link rel="icon" type="image/png" href="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/medias/favicon.png">

    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/css/matery.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/css/my.css">
    
    <script src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/jquery/jquery.min.js"></script>
    
<meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="JackHCC" type="application/atom+xml">
<link rel="stylesheet" href="/css/prism-hopscotch.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper head-container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/medias/me.jpg" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">JackHCC</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="" class="waves-effect waves-light">

      
      <i class="fas fa-list" style="zoom: 0.6;"></i>
      
      <span>Tools</span>
      <i class="fas fa-chevron-down" aria-hidden="true" style="zoom: 0.6;"></i>
    </a>
    <ul class="sub-nav menus_item_child ">
      
      <li>
        <a href="https://creativecc.cn/" target="_blank" rel="noopener">
          
          <i class="fas fa-book" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>Creative工具导航</span>
        </a>
      </li>
      
      <li>
        <a href="https://blog.creativecc.cn/Arxiv-NLP-Reporter/" target="_blank" rel="noopener">
          
          <i class="fas fa-film" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>NLP每日论文</span>
        </a>
      </li>
      
      <li>
        <a href="http://chat.creativecc.cn/" target="_blank" rel="noopener">
          
          <i class="fas fa-music" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>RocketChat聊天室</span>
        </a>
      </li>
      
      <li>
        <a href="/contact">
          
          <i class="fas fa-comments" style="margin-top: -20px; zoom: 0.6;"></i>
          
          <span>Contact留言板</span>
        </a>
      </li>
      
    </ul>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>

<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/medias/me.jpg" class="logo-img circle responsive-img">
        
        <div class="logo-name">JackHCC</div>
        <div class="logo-desc">
            
            Make the world betterrrr!!!
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="javascript:;">
			
				<i class="fa-fw fas fa-list"></i>
			
			Tools
			<span class="m-icon"><i class="fas fa-chevron-right"></i></span>
		</a>
            <ul  style="background:  ;" >
              
                <li>   
				
                  <a href="https://creativecc.cn/ " target="_blank" rel="noopener" style="margin-left:75px";>
				  
				   <i class="fa fas fa-book" style="position: absolute;left:50px" ></i>
			      
		          <span>Creative工具导航</span>
                  </a>
                </li>
              
                <li>   
				
                  <a href="https://blog.creativecc.cn/Arxiv-NLP-Reporter/ " target="_blank" rel="noopener" style="margin-left:75px";>
				  
				   <i class="fa fas fa-film" style="position: absolute;left:50px" ></i>
			      
		          <span>NLP每日论文</span>
                  </a>
                </li>
              
                <li>   
				
                  <a href="http://chat.creativecc.cn/ " target="_blank" rel="noopener" style="margin-left:75px";>
				  
				   <i class="fa fas fa-music" style="position: absolute;left:50px" ></i>
			      
		          <span>RocketChat聊天室</span>
                  </a>
                </li>
              
                <li>   
				
                  <a href="/contact " style="margin-left:75px";>
				  
				   <i class="fa fas fa-comments" style="position: absolute;left:50px" ></i>
			      
		          <span>Contact留言板</span>
                  </a>
                </li>
               
            </ul>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/JackHCC/JackHCC.github.io" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>

        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/JackHCC/JackHCC.github.io" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    
<script src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/cryptojs/crypto-js.min.js"></script>
<script>
    (function() {
        let pwd = '';
        if (pwd && pwd.length > 0) {
            if (pwd !== CryptoJS.SHA256(prompt('请输入访问本文章的密码')).toString(CryptoJS.enc.Hex)) {
                alert('密码错误，将返回主页！');
                location.href = '/';
            }
        }
    })();
</script>




<div class="bg-cover pd-header post-cover" style="background-image: url('https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/medias/featureimages/13.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">HarmonyOS开发：Java应用</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        margin: 35px 0 15px 0;
        padding-left: 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        height: calc(100vh - 250px);
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #toc-content .is-active-link::before {
        background-color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 30px;
        bottom: 146px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/Harmony/">
                                <span class="chip bg-color">Harmony</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/Harmony/" class="post-category">
                                Harmony
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2021-07-05
                </div>
                

                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-check fa-fw"></i>更新日期:&nbsp;&nbsp;
                    2021-09-04
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    28.9k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    112 分
                </div>
                

                
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="far fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>

        </div>
        <hr class="clearfix">
        <div class="card-content article-card-content">
            <div id="articleContent">
                <h1 id="JAVA-API"><a href="#JAVA-API" class="headerlink" title="JAVA API"></a>JAVA API</h1><p><a href="https://developer.harmonyos.com/cn/docs/documentation/overview-0000001054518434" target="_blank" rel="noopener">《Java API参考》</a></p>
<h1 id="开发概述"><a href="#开发概述" class="headerlink" title="开发概述"></a>开发概述</h1><h2 id="通用开发历程"><a href="#通用开发历程" class="headerlink" title="通用开发历程"></a>通用开发历程</h2><p>各类设备（手机/平板、智能穿戴、智慧屏等）通用的用户应用程序开发历程如下表所示。</p>
<table>
<thead>
<tr>
<th>任务</th>
<th>简介</th>
<th>相关资源</th>
</tr>
</thead>
<tbody><tr>
<td>开发Ability</td>
<td>Ability是HarmonyOS应用程序的重要组成部分，分为FA（Feature Ability）和PA（Particle Ability）两种类型：FA支持Page Ability：Page模板是FA唯一支持的模板，用于提供与用户交互的能力。PA支持Service Ability和Data Ability：Service模板用于提供后台运行任务的能力；Data模板用于对外部提供统一的数据访问抽象。进行HarmonyOS应用开发，首先要了解Ability如何使用。</td>
<td><a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/ability-page-concept-0000000000033573" target="_blank" rel="noopener">Page Ability</a><a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/ability-service-concept-0000000000044457" target="_blank" rel="noopener">Service Ability</a><a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/ability-data-concept-0000000000043058" target="_blank" rel="noopener">Data Ability</a></td>
</tr>
<tr>
<td>开发UI</td>
<td>FA需要提供UI用于与用户进行交互，HarmonyOS提供了Java UI和JS UI两种UI框架：Java UI提供了细粒度的UI编程接口，使应用开发更加灵活；JS UI提供了相对高层的UI描述，使应用开发更加简单。说明针对轻量级智能穿戴（Lite Wearable），现阶段只使用JS语言进行应用开发，详见<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-references/lite-wearable-experience-0000001056083157" target="_blank" rel="noopener">轻量级智能穿戴开发</a>。</td>
<td><a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/ui-java-overview-0000000000500404" target="_blank" rel="noopener">Java UI框架</a><a href="https://developer.harmonyos.com/cn/docs/documentation/doc-references/overview-0000001054199972" target="_blank" rel="noopener">Java API参考</a><a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/ui-js-overview-0000000000500376" target="_blank" rel="noopener">JS UI框架</a><a href="https://developer.harmonyos.com/cn/docs/documentation/doc-references/js-apis-overview-0000001056361791" target="_blank" rel="noopener">JS API参考</a></td>
</tr>
<tr>
<td>开发业务功能</td>
<td>媒体：视频、音频、图像、相机等功能的开发。安全：权限、生物特征识别等功能的开发。AI：图像超分、语音识别、码生成等功能的开发。网络连接：NFC、蓝牙、WLAN等功能的开发。设备管理：传感器、控制类小器件、位置等功能的开发。数据管理：数据库、分布式数据/文件服务、数据搜索等功能的开发。线程：线程管理、线程间通信等功能的开发。IDL：声明系统服务和Ability对外提供的服务接口，并生成相关代码。</td>
<td><a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/media-video-overview-0000000000031748" target="_blank" rel="noopener">媒体开发指南</a><a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/security-permissions-overview-0000000000029883" target="_blank" rel="noopener">安全开发指南</a><a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/ai-overview-0000001051150122" target="_blank" rel="noopener">AI开发指南</a><a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/connectivity-nfc-overview-0000000000030030" target="_blank" rel="noopener">网络与连接开发指南</a><a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/device-sensors-overview-0000001050197918" target="_blank" rel="noopener">设备管理开发指南</a><a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/database-relational-overview-0000000000030046" target="_blank" rel="noopener">数据管理开发指南</a><a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/thread-mgmt-overview-0000000000032127" target="_blank" rel="noopener">线程开发指南</a><a href="https://developer.harmonyos.com/cn/docs/documentation/doc-references/idl-overview-0000001050762835" target="_blank" rel="noopener">IDL接口使用指南</a></td>
</tr>
</tbody></table>
<h2 id="原子化服务开发历程"><a href="#原子化服务开发历程" class="headerlink" title="原子化服务开发历程"></a>原子化服务开发历程</h2><p>HarmonyOS除支持传统方式的需要安装的应用外，还支持提供特定功能的免安装的应用（即原子化服务），供用户在合适的场景、合适的设备上便捷使用。</p>
<p>原子化服务相对于传统方式的需要安装的应用更加轻量，同时提供更丰富的入口、更精准的分发。原子化服务的详细介绍请参见“<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/atomic-service-definition-0000001090840664" target="_blank" rel="noopener">原子化服务</a>”。</p>
<p>其基本开发历程如下表所示。</p>
<table>
<thead>
<tr>
<th>任务</th>
<th>开发历程</th>
<th>相关内容</th>
</tr>
</thead>
<tbody><tr>
<td>了解HarmonyOS</td>
<td>了解HarmonyOS的系统定位、技术特性、应用开发的基本概念和基础知识，熟悉HarmonyOS应用开发通用流程。</td>
<td><a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/harmonyos-overview-0000000000011903" target="_blank" rel="noopener">HarmonyOS概述</a><a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/basic-fundamentals-0000000000041611" target="_blank" rel="noopener">开发基础知识</a><a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/start-overview-0000000000029602" target="_blank" rel="noopener">快速入门</a></td>
</tr>
<tr>
<td>设计原子化服务</td>
<td>在设计阶段，需要满足原子化服务的设计规范，包括图标、卡片、分布式等规范。</td>
<td><a href="https://developer.harmonyos.com/cn/docs/design/des-guides/service-overview-0000001139795693" target="_blank" rel="noopener">原子化服务设计</a></td>
</tr>
<tr>
<td>掌握原子化服务约束</td>
<td>了解原子化服务之间的调用管控机制。</td>
<td><a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/mgmt-over-invocations-among-third-party-user-apps-0000001091596272" target="_blank" rel="noopener">三方应用调用管控机制</a></td>
</tr>
<tr>
<td>开发原子化服务基础体验</td>
<td>了解原子化服务总体开发规则、如何开发服务卡片等基础体验。</td>
<td><a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/atomic-service-development-requirements-0000001105286996" target="_blank" rel="noopener">原子化服务总体开发要求</a><a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/ability-service-widget-overview-0000001062607955" target="_blank" rel="noopener">服务卡片开发指南</a></td>
</tr>
<tr>
<td>开发原子化服务分布式体验</td>
<td>了解如何开发流转、分享等分布式体验。</td>
<td><a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/hop-overview-0000001092995092" target="_blank" rel="noopener">流转开发指南</a><a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/huawei-share-service-sharing-overview-0000001127181719" target="_blank" rel="noopener">华为分享接入指南</a></td>
</tr>
</tbody></table>
<h1 id="Ability"><a href="#Ability" class="headerlink" title="Ability"></a>Ability</h1><h2 id="Ability概述"><a href="#Ability概述" class="headerlink" title="Ability概述"></a>Ability概述</h2><p>Ability是应用所具备能力的抽象，也是应用程序的重要组成部分。一个应用可以具备多种能力（即可以包含多个Ability），HarmonyOS支持应用以Ability为单位进行部署。Ability可以分为FA（Feature Ability）和PA（Particle Ability）两种类型，每种类型为开发者提供了不同的模板，以便实现不同的业务功能。</p>
<ul>
<li><p>FA支持<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/ability-page-concept-0000000000033573" target="_blank" rel="noopener">Page Ability</a>：Page模板是FA唯一支持的模板，用于提供与用户交互的能力。一个Page实例可以包含一组相关页面，每个页面用一个AbilitySlice实例表示。</p>
</li>
<li><p>PA支持</p>
<p>Service Ability</p>
<p>和</p>
<p>Data Ability</p>
</li>
</ul>
<ul>
<li>Service模板：用于提供后台运行任务的能力。</li>
</ul>
<ul>
<li>Data模板：用于对外部提供统一的数据访问抽象。</li>
</ul>
<p>在<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/basic-config-file-overview-0000000000011951" target="_blank" rel="noopener">配置文件</a>（config.json）中注册Ability时，可以通过配置Ability元素中的“type”属性来指定Ability模板类型，示例如下。</p>
<p>其中，“type”的取值可以为“page”、“service”或“data”，分别代表Page模板、Service模板、Data模板。为了便于表述，后文中我们将基于Page模板、Service模板、Data模板实现的Ability分别简称为Page、Service、Data。</p>
<pre><code>{
    "module": {
        ...
        "abilities": [
            {
                ...
                "type": "page"
                ...
            }
        ]
        ...
    }
    ...
}</code></pre><h3 id="相关实例"><a href="#相关实例" class="headerlink" title="相关实例"></a>相关实例</h3><p>针对Ability开发，有以下Codelabs可供参考：</p>
<ul>
<li><p><a href="https://developer.huawei.com/consumer/cn/codelabsPortal/carddetails/HarmonyOS-EducationSystem" target="_blank" rel="noopener">分布式亲子早教系统</a>基于分布式能力，实现一个多屏互动、跨设备协同的亲子早教系统。</p>
</li>
<li><p><a href="https://developer.huawei.com/consumer/cn/codelabsPortal/carddetails/HarmonyOS-NewsClient" target="_blank" rel="noopener">分布式新闻客户端</a>基于HarmonyOS应用中Service Ability和Page Ability的使用，实现跨设备FA拉起。</p>
</li>
<li><p><a href="https://developer.huawei.com/consumer/cn/codelabsPortal/carddetails/HarmonyOS-DistributedVideo" target="_blank" rel="noopener">跨设备视频播放</a>基于分布式能力和IDL跨进程通信，实现视频跨设备播放、控制。</p>
</li>
<li><p><a href="https://developer.huawei.com/consumer/cn/codelabsPortal/carddetails/HarmonyOS-DistributedInput" target="_blank" rel="noopener">分布式输入法</a>基于分布式能力，将手机作为智慧屏的虚拟控制器，控制文字输入和遥控播放。</p>
</li>
<li><p><a href="https://developer.huawei.com/consumer/cn/codelabsPortal/carddetails/HarmonyOS-DistributedGamepad" target="_blank" rel="noopener">分布式游戏手柄</a>基于分布式能力，将手机作为智慧屏的虚拟手柄终端，组成全新的多人娱乐场景</p>
</li>
</ul>
<h2 id="Page-Ability"><a href="#Page-Ability" class="headerlink" title="Page Ability"></a>Page Ability</h2><h3 id="Page与AbilitySlice"><a href="#Page与AbilitySlice" class="headerlink" title="Page与AbilitySlice"></a>Page与AbilitySlice</h3><p>Page模板（以下简称“Page”）是FA唯一支持的模板，用于提供与用户交互的能力。一个Page可以由一个或多个AbilitySlice构成，AbilitySlice是指应用的单个页面及其控制逻辑的总和。</p>
<p>当一个Page由多个AbilitySlice共同构成时，这些AbilitySlice页面提供的业务能力应具有高度相关性。例如，新闻浏览功能可以通过一个Page来实现，其中包含了两个AbilitySlice：一个AbilitySlice用于展示新闻列表，另一个AbilitySlice用于展示新闻详情。Page和AbilitySlice的关系如图所示。</p>
<p><img src="/images/loading.gif" data-original="../images/harmonyos/-16273165182581902" alt=""></p>
<p>相比于桌面场景，移动场景下应用之间的交互更为频繁。通常，单个应用专注于某个方面的能力开发，当它需要其他能力辅助时，会调用其他应用提供的能力。例如，外卖应用提供了联系商家的业务功能入口，当用户在使用该功能时，会跳转到通话应用的拨号页面。与此类似，HarmonyOS支持不同Page之间的跳转，并可以指定跳转到目标Page中某个具体的AbilitySlice。</p>
<h3 id="AbilitySlice路由配置"><a href="#AbilitySlice路由配置" class="headerlink" title="AbilitySlice路由配置"></a>AbilitySlice路由配置</h3><p>虽然一个Page可以包含多个AbilitySlice，但是Page进入前台时界面默认只展示一个AbilitySlice。默认展示的AbilitySlice是通过<strong>setMainRoute()</strong>方法来指定的。如果需要更改默认展示的AbilitySlice，可以通过<strong>addActionRoute()</strong>方法为此AbilitySlice配置一条路由规则。此时，当其他Page实例期望导航到此AbilitySlice时，可以在<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/ability-intent-0000000000038799" target="_blank" rel="noopener">Intent</a>中指定Action，详见<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/ability-page-switching-0000000000037999#ZH-CN_TOPIC_0000001076963678__section1862412142519" target="_blank" rel="noopener">不同Page间导航</a>。</p>
<p>setMainRoute()方法与addActionRoute()方法的使用示例如下：</p>
<pre><code>public class MyAbility extends Ability {
    @Override
    public void onStart(Intent intent) {
        super.onStart(intent);
        // set the main route
        setMainRoute(MainSlice.class.getName());

        // set the action route
        addActionRoute("action.pay", PaySlice.class.getName());
        addActionRoute("action.scan", ScanSlice.class.getName());
    }
}</code></pre><p>addActionRoute()方法中使用的动作命名，需要在应用配置文件（config.json）中注册：</p>
<pre><code>{
    "module": {
        "abilities": [
            {
                "skills":[
                    {
                        "actions":[
                            "action.pay",
                            "action.scan"
                        ]
                    }
                ]
                ...
            }
        ]
        ...
    }
    ...
}</code></pre><h2 id="Page-Ability生命周期"><a href="#Page-Ability生命周期" class="headerlink" title="Page Ability生命周期"></a>Page Ability生命周期</h2><p>系统管理或用户操作等行为均会引起Page实例在其生命周期的不同状态之间进行转换。Ability类提供的回调机制能够让Page及时感知外界变化，从而正确地应对状态变化（比如释放资源），这有助于提升应用的性能和稳健性。</p>
<h3 id="Page生命周期回调"><a href="#Page生命周期回调" class="headerlink" title="Page生命周期回调"></a>Page生命周期回调</h3><p>Page生命周期的不同状态转换及其对应的回调，如图所示。</p>
<p><img src="/images/loading.gif" data-original="../images/harmonyos/-16273165219781904" alt=""></p>
<ul>
<li><strong>onStart()</strong>当系统首次创建Page实例时，触发该回调。对于一个Page实例，该回调在其生命周期过程中仅触发一次，Page在该逻辑后将进入INACTIVE状态。开发者必须重写该方法，并在此配置默认展示的AbilitySlice。</li>
</ul>
<pre><code>    @Override
    public void onStart(Intent intent) {
        super.onStart(intent);
        super.setMainRoute(FooSlice.class.getName());
    }</code></pre><ul>
<li><p><strong>onActive()</strong>Page会在进入INACTIVE状态后来到前台，然后系统调用此回调。Page在此之后进入ACTIVE状态，该状态是应用与用户交互的状态。Page将保持在此状态，除非某类事件发生导致Page失去焦点，比如用户点击返回键或导航到其他Page。当此类事件发生时，会触发Page回到INACTIVE状态，系统将调用onInactive()回调。此后，Page可能重新回到ACTIVE状态，系统将再次调用onActive()回调。因此，开发者通常需要成对实现onActive()和onInactive()，并在onActive()中获取在onInactive()中被释放的资源。</p>
</li>
<li><p><strong>onInactive()</strong>当Page失去焦点时，系统将调用此回调，此后Page进入INACTIVE状态。开发者可以在此回调中实现Page失去焦点时应表现的恰当行为。</p>
</li>
<li><p><strong>onBackground()</strong>如果Page不再对用户可见，系统将调用此回调通知开发者用户进行相应的资源释放，此后Page进入BACKGROUND状态。开发者应该在此回调中释放Page不可见时无用的资源，或在此回调中执行较为耗时的状态保存操作。</p>
</li>
<li><p><strong>onForeground()</strong>处于BACKGROUND状态的Page仍然驻留在内存中，当重新回到前台时（比如用户重新导航到此Page），系统将先调用onForeground()回调通知开发者，而后Page的生命周期状态回到INACTIVE状态。开发者应当在此回调中重新申请在onBackground()中释放的资源，最后Page的生命周期状态进一步回到ACTIVE状态，系统将通过onActive()回调通知开发者用户。</p>
</li>
<li><p>onStop()</p>
<p>系统将要销毁Page时，将会触发此回调函数，通知用户进行系统资源的释放。销毁Page的可能原因包括以下几个方面：</p>
<ul>
<li>用户通过系统管理能力关闭指定Page，例如使用任务管理器关闭Page。</li>
</ul>
</li>
<li><p>用户行为触发Page的terminateAbility()方法调用，例如使用应用的退出功能。</p>
</li>
<li><p>配置变更导致系统暂时销毁Page并重建。</p>
</li>
<li><p>系统出于资源管理目的，自动触发对处于BACKGROUND状态Page的销毁。</p>
</li>
</ul>
<h3 id="AbilitySlice生命周期"><a href="#AbilitySlice生命周期" class="headerlink" title="AbilitySlice生命周期"></a>AbilitySlice生命周期</h3><p>AbilitySlice作为Page的组成单元，其生命周期是依托于其所属Page生命周期的。AbilitySlice和Page具有相同的生命周期状态和同名的回调，当Page生命周期发生变化时，它的AbilitySlice也会发生相同的生命周期变化。此外，AbilitySlice还具有独立于Page的生命周期变化，这发生在同一Page中的AbilitySlice之间导航时，此时Page的生命周期状态不会改变。</p>
<p>AbilitySlice生命周期回调与Page的相应回调类似，因此不再赘述。由于AbilitySlice承载具体的页面，开发者必须重写AbilitySlice的onStart()回调，并在此方法中通过setUIContent()方法设置页面，如下所示：</p>
<pre><code>    @Override
    protected void onStart(Intent intent) {
        super.onStart(intent);

        setUIContent(ResourceTable.Layout_main_layout);
    }</code></pre><p>AbilitySlice实例创建和管理通常由应用负责，系统仅在特定情况下会创建AbilitySlice实例。例如，通过导航启动某个AbilitySlice时，是由系统负责实例化；但是在同一个Page中不同的AbilitySlice间导航时则由应用负责实例化。</p>
<h3 id="Page与AbilitySlice生命周期关联"><a href="#Page与AbilitySlice生命周期关联" class="headerlink" title="Page与AbilitySlice生命周期关联"></a>Page与AbilitySlice生命周期关联</h3><p>当AbilitySlice处于前台且具有焦点时，其生命周期状态随着所属Page的生命周期状态的变化而变化。当一个Page拥有多个AbilitySlice时，例如：MyAbility下有FooAbilitySlice和BarAbilitySlice，当前FooAbilitySlice处于前台并获得焦点，并即将导航到BarAbilitySlice，在此期间的生命周期状态变化顺序为：</p>
<ol>
<li>FooAbilitySlice从ACTIVE状态变为INACTIVE状态。</li>
<li>BarAbilitySlice则从INITIAL状态首先变为INACTIVE状态，然后变为ACTIVE状态（假定此前BarAbilitySlice未曾启动）。</li>
<li>FooAbilitySlice从INACTIVE状态变为BACKGROUND状态。</li>
</ol>
<p>对应两个slice的生命周期方法回调顺序为：</p>
<pre><code>FooAbilitySlice.onInactive() --&gt; BarAbilitySlice.onStart() --&gt; BarAbilitySlice.onActive() --&gt; FooAbilitySlice.onBackground()</code></pre><p>在整个流程中，MyAbility始终处于ACTIVE状态。但是，当Page被系统销毁时，其所有已实例化的AbilitySlice将联动销毁，而不仅是处于前台的AbilitySlice</p>
<h2 id="AbilitySlice间导航"><a href="#AbilitySlice间导航" class="headerlink" title="AbilitySlice间导航"></a>AbilitySlice间导航</h2><h3 id="同一Page内导航"><a href="#同一Page内导航" class="headerlink" title="同一Page内导航"></a>同一Page内导航</h3><p>当发起导航的AbilitySlice和导航目标的AbilitySlice处于同一个Page时，您可以通过present()方法实现导航。如下代码片段展示通过点击按钮导航到其他AbilitySlice的方法：</p>
<pre><code>@Override
protected void onStart(Intent intent) {

    ...
    Button button = ...;
    button.setClickedListener(listener -&gt; present(new TargetSlice(), new Intent()));
    ...

}</code></pre><p>如果开发者希望在用户从导航目标AbilitySlice返回时，能够获得其返回结果，则应当使用presentForResult()实现导航。用户从导航目标AbilitySlice返回时，系统将回调onResult()来接收和处理返回结果，开发者需要重写该方法。返回结果由导航目标AbilitySlice在其生命周期内通过setResult()进行设置。</p>
<pre><code>@Override
protected void onStart(Intent intent) {

    ...
    Button button = ...;
    button.setClickedListener(listener -&gt; presentForResult(new TargetSlice(), new Intent(), 0));
    ...

}

@Override
protected void onResult(int requestCode, Intent resultIntent) {
    if (requestCode == 0) {
        // Process resultIntent here.
    }
}</code></pre><p>系统为每个Page维护了一个AbilitySlice实例的栈，每个进入前台的AbilitySlice实例均会入栈。当开发者在调用present()或presentForResult()时指定的AbilitySlice实例已经在栈中存在时，则栈中位于此实例之上的AbilitySlice均会出栈并终止其生命周期。前面的示例代码中，导航时指定的AbilitySlice实例均是新建的，即便重复执行此代码（此时作为导航目标的这些实例是同一个类），也不会导致任何AbilitySlice出栈。</p>
<h3 id="不同Page间导航"><a href="#不同Page间导航" class="headerlink" title="不同Page间导航"></a>不同Page间导航</h3><p>AbilitySlice作为Page的内部单元，以Action的形式对外暴露，因此可以通过配置Intent的Action导航到目标AbilitySlice。Page间的导航可以使用startAbility()或startAbilityForResult()方法，获得返回结果的回调为onAbilityResult()。在Ability中调用setResult()可以设置返回结果。详细用法可参考<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/ability-intent-0000000000038799#ZH-CN_TOPIC_0000001076675608__section854420303150" target="_blank" rel="noopener">根据Operation的其他属性启动应用</a>中的示例</p>
<h2 id="跨设备迁移"><a href="#跨设备迁移" class="headerlink" title="跨设备迁移"></a>跨设备迁移</h2><p>跨设备迁移（下文简称“迁移”）支持将Page在同一用户的不同设备间迁移，以便支持用户无缝切换的诉求。以Page从设备A迁移到设备B为例，迁移动作主要步骤如下：</p>
<ol>
<li>设备A上的Page请求迁移。</li>
<li>HarmonyOS处理迁移任务，并回调设备A上Page的保存数据方法，用于保存迁移必须的数据。</li>
<li>HarmonyOS在设备B上启动同一个Page，并回调其恢复数据方法。</li>
</ol>
<p>开发者可以参考以下详细步骤开发具有迁移功能的Page。</p>
<h3 id="实现IAbilityContinuation接口"><a href="#实现IAbilityContinuation接口" class="headerlink" title="实现IAbilityContinuation接口"></a>实现IAbilityContinuation接口</h3><p>说明</p>
<p>一个应用可能包含多个Page，仅需要在支持迁移的Page中通过以下方法实现IAbilityContinuation接口。同时，此Page所包含的所有AbilitySlice也需要实现此接口。</p>
<ul>
<li><p><strong>onStartContinuation()</strong>Page请求迁移后，系统首先回调此方法，开发者可以在此回调中决策当前是否可以执行迁移，比如，弹框让用户确认是否开始迁移。</p>
</li>
<li><p><strong>onSaveData()</strong>如果onStartContinuation()返回true，则系统回调此方法，开发者在此回调中保存必须传递到另外设备上以便恢复Page状态的数据。</p>
</li>
<li><p><strong>onRestoreData()</strong>源侧设备上Page完成保存数据后，系统在目标侧设备上回调此方法，开发者在此回调中接受用于恢复Page状态的数据。注意，在目标侧设备上的Page会重新启动其生命周期，无论其启动模式如何配置。且系统回调此方法的时机在onStart()之前。</p>
</li>
<li><p><strong>onCompleteContinuation()</strong>目标侧设备上恢复数据一旦完成，系统就会在源侧设备上回调Page的此方法，以便通知应用迁移流程已结束。开发者可以在此检查迁移结果是否成功，并在此处理迁移结束的动作，例如，应用可以在迁移完成后终止自身生命周期。</p>
</li>
<li><p><strong>onRemoteTerminated()</strong>如果开发者使用continueAbilityReversibly()而不是continueAbility()，则此后可以在源侧设备上使用reverseContinueAbility()进行回迁。这种场景下，相当于同一个Page（的两个实例）同时在两个设备上运行，迁移完成后，如果目标侧设备上Page因任何原因终止，则源侧Page通过此回调接收终止通知。</p>
</li>
</ul>
<h3 id="请求迁移"><a href="#请求迁移" class="headerlink" title="请求迁移"></a>请求迁移</h3><p>实现IAbilityContinuation的Page可以在其生命周期内，调用continueAbility()或continueAbilityReversibly()请求迁移。两者的区别是，通过后者发起的迁移此后可以进行回迁。</p>
<pre><code>try {
    continueAbility();
} catch (IllegalStateException e) {
    // Maybe another continuation in progress.
    ...
}</code></pre><p>以Page从设备A迁移到设备B为例，详细的流程如下：</p>
<ol>
<li>设备A上的Page请求迁移。</li>
<li>系统回调设备A上Page及其AbilitySlice栈中所有AbilitySlice实例的IAbilityContinuation.onStartContinuation()方法，以确认当前是否可以立即迁移。</li>
<li>如果可以立即迁移，则系统回调设备A上Page及其AbilitySlice栈中所有AbilitySlice实例的IAbilityContinuation.onSaveData()方法，以便保存迁移后恢复状态必须的数据。</li>
<li>如果保存数据成功，则系统在设备B上启动同一个Page，并恢复AbilitySlice栈，然后回调IAbilityContinuation.onRestoreData()方法，传递此前保存的数据；此后设备B上此Page从onStart()开始其生命周期回调。</li>
<li>系统回调设备A上Page及其AbilitySlice栈中所有AbilitySlice实例的IAbilityContinuation.onCompleteContinuation()方法，通知数据恢复成功与否。</li>
</ol>
<h3 id="请求回迁"><a href="#请求回迁" class="headerlink" title="请求回迁"></a>请求回迁</h3><p>使用continueAbilityReversibly()请求迁移并完成后，源侧设备上已迁移的Page可以发起回迁，以便使用户活动重新回到此设备。</p>
<pre><code>try {
    reverseContinueAbility();
} catch (IllegalStateException e) {
    // Maybe another continuation in progress.
    ...
}</code></pre><p>以Page从设备A迁移到设备B后并请求回迁为例，详细的流程如下：</p>
<ol>
<li>设备A上的Page请求回迁。</li>
<li>系统回调设备B上Page及其AbilitySlice栈中所有AbilitySlice实例的IAbilityContinuation.onStartContinuation()方法，以确认当前是否可以立即迁移。</li>
<li>如果可以立即迁移，则系统回调设备B上Page及其AbilitySlice栈中所有AbilitySlice实例的IAbilityContinuation.onSaveData()方法，以便保存回迁后恢复状态必须的数据。</li>
<li>如果保存数据成功，则系统在设备A上Page恢复AbilitySlice栈，然后回调IAbilityContinuation.onRestoreData()方法，传递此前保存的数据。</li>
<li>如果数据恢复成功，则系统终止设备B上Page的生命周期。</li>
</ol>
<h3 id="相关实例-1"><a href="#相关实例-1" class="headerlink" title="相关实例"></a>相关实例</h3><p>针对Page Ability开发，有以下示例工程可供参考：</p>
<ul>
<li><a href="https://gitee.com/openharmony/app_samples/tree/master/ability/PageAbility" target="_blank" rel="noopener">PageAbility</a>本示例演示了同一Page Ability内和不同Page间的AbilitySlice导航，以及Page Ability的跨端迁移。</li>
</ul>
<p>针对跨设备迁移开发，有以下Codelabs可供参考：</p>
<ul>
<li><a href="https://developer.huawei.com/consumer/cn/codelabsPortal/carddetails/Distributed-Mail" target="_blank" rel="noopener">分布式邮件编辑</a>基于跨设备迁移和分布式文件能力，实现邮件的跨设备编辑和附件的调用</li>
</ul>
<h2 id="Service-Ability"><a href="#Service-Ability" class="headerlink" title="Service Ability"></a>Service Ability</h2><p>基于Service模板的Ability（以下简称“Service”）主要用于后台运行任务（如执行音乐播放、文件下载等），但不提供用户交互界面。Service可由其他应用或Ability启动，即使用户切换到其他应用，Service仍将在后台继续运行。</p>
<p>Service是单实例的。在一个设备上，相同的Service只会存在一个实例。如果多个Ability共用这个实例，只有当与Service绑定的所有Ability都退出后，Service才能够退出。由于Service是在主线程里执行的，因此，如果在Service里面的操作时间过长，开发者必须在Service里创建新的线程来处理（详见<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/inter-thread-overview-0000000000038958" target="_blank" rel="noopener">线程间通信</a>），防止造成主线程阻塞，应用程序无响应。</p>
<h3 id="创建Service"><a href="#创建Service" class="headerlink" title="创建Service"></a>创建Service</h3><p>介绍如何创建一个Service。</p>
<ol>
<li>创建Ability的子类，实现Service相关的生命周期方法。Service也是一种Ability，Ability为Service提供了以下生命周期方法，用户可以重写这些方法，来添加其他Ability请求与Service Ability交互时的处理方法。</li>
</ol>
<ul>
<li><p>onStart()该方法在创建Service的时候调用，用于Service的初始化。在Service的整个生命周期只会调用一次，调用时传入的Intent应为空。</p>
</li>
<li><p>onCommand()在Service创建完成之后调用，该方法在客户端每次启动该Service时都会调用，用户可以在该方法中做一些调用统计、初始化类的操作。</p>
</li>
<li><p>onConnect()在Ability和Service连接时调用，该方法返回IRemoteObject对象，用户可以在该回调函数中生成对应Service的IPC通信通道，以便Ability与Service交互。Ability可以多次连接同一个Service，系统会缓存该Service的IPC通信对象，只有第一个客户端连接Service时，系统才会调用Service的onConnect方法来生成IRemoteObject对象，而后系统会将同一个RemoteObject对象传递至其他连接同一个Service的所有客户端，而无需再次调用onConnect方法。</p>
</li>
<li><p>onDisconnect()在Ability与绑定的Service断开连接时调用。</p>
</li>
<li><p>onStop()在Service销毁时调用。Service应通过实现此方法来清理任何资源，如关闭线程、注册的侦听器等。</p>
</li>
</ul>
<p>创建Service的代码示例如下：</p>
<pre><code>public class ServiceAbility extends Ability {
    @Override
    public void onStart(Intent intent) {
        super.onStart(intent);
    }

    @Override
    public void onCommand(Intent intent, boolean restart, int startId) {
        super.onCommand(intent, restart, startId);
    }

    @Override
    public IRemoteObject onConnect(Intent intent) {
        return super.onConnect(intent);
    }

    @Override
    public void onDisconnect(Intent intent) {
        super.onDisconnect(intent);
    }

    @Override
    public void onStop() {
        super.onStop();
    }
}</code></pre><ol>
<li>注册Service。Service也需要在应用配置文件中进行注册，注册类型type需要设置为service。</li>
</ol>
<pre><code>{
    "module": {
        "abilities": [         
            {    
                "name": ".ServiceAbility",
                "type": "service",
                "visible": true
                ...
            }
        ]
        ...
    }
    ...
}</code></pre><h3 id="启动Service"><a href="#启动Service" class="headerlink" title="启动Service"></a>启动Service</h3><p>介绍通过startAbility()启动Service以及对应的停止方法。</p>
<ul>
<li>启动ServiceAbility为开发者提供了startAbility()方法来启动另外一个Ability。因为Service也是Ability的一种，开发者同样可以通过将<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/ability-intent-0000000000038799" target="_blank" rel="noopener">Intent</a>传递给该方法来启动Service。不仅支持启动本地Service，还支持启动远程Service。</li>
</ul>
<p>开发者可以通过构造包含DeviceId、BundleName与AbilityName的Operation对象来设置目标Service信息。这三个参数的含义如下：</p>
<ul>
<li><p>DeviceId：表示设备ID。如果是本地设备，则可以直接留空；如果是远程设备，可以通过ohos.distributedschedule.interwork.DeviceManager提供的getDeviceList获取设备列表，详见《API参考》。</p>
</li>
<li><p>BundleName：表示包名称。</p>
</li>
<li><p>AbilityName：表示待启动的Ability名称。</p>
</li>
</ul>
<p>启动本地设备Service的代码示例如下：</p>
<pre><code>Intent intent = new Intent();
Operation operation = new Intent.OperationBuilder()
        .withDeviceId("")
        .withBundleName("com.domainname.hiworld.himusic")
        .withAbilityName("com.domainname.hiworld.himusic.ServiceAbility")
        .build();
intent.setOperation(operation);
startAbility(intent);</code></pre><p>启动远程设备Service的代码示例如下：</p>
<pre><code>Intent intent = new Intent();
Operation operation = new Intent.OperationBuilder()
        .withDeviceId("deviceId")
        .withBundleName("com.domainname.hiworld.himusic")
        .withAbilityName("com.domainname.hiworld.himusic.ServiceAbility")
        .withFlags(Intent.FLAG_ABILITYSLICE_MULTI_DEVICE) // 设置支持分布式调度系统多设备启动的标识
        .build();
intent.setOperation(operation);
startAbility(intent);</code></pre><p>执行上述代码后，Ability将通过startAbility() 方法来启动Service。</p>
<ul>
<li><p>如果Service尚未运行，则系统会先调用onStart()来初始化Service，再回调Service的onCommand()方法来启动Service。</p>
</li>
<li><p>如果Service正在运行，则系统会直接回调Service的onCommand()方法来启动Service。</p>
</li>
<li><p>停止ServiceService一旦创建就会一直保持在后台运行，除非必须回收内存资源，否则系统不会停止或销毁Service。开发者可以在Service中通过terminateAbility()停止本Service或在其他Ability调用stopAbility()来停止Service。</p>
</li>
</ul>
<p>停止Service同样支持停止本地设备Service和停止远程设备Service，使用方法与启动Service一样。一旦调用停止Service的方法，系统便会尽快销毁Service</p>
<h3 id="连接Service"><a href="#连接Service" class="headerlink" title="连接Service"></a>连接Service</h3><p>如果Service需要与Page Ability或其他应用的Service Ability进行交互，则须创建用于连接的Connection。Service支持其他Ability通过connectAbility()方法与其进行连接。</p>
<p>在使用connectAbility()处理回调时，需要传入目标Service的<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/ability-intent-0000000000038799" target="_blank" rel="noopener">Intent</a>与IAbilityConnection的实例。IAbilityConnection提供了两个方法供开发者实现：onAbilityConnectDone()是用来处理连接Service成功的回调，onAbilityDisconnectDone()是用来处理Service异常死亡的回调。</p>
<p>创建连接Service回调实例的代码示例如下：</p>
<pre><code>// 创建连接Service回调实例
private IAbilityConnection connection = new IAbilityConnection() {
    // 连接到Service的回调
    @Override
    public void onAbilityConnectDone(ElementName elementName, IRemoteObject iRemoteObject, int resultCode) {
        // Client侧需要定义与Service侧相同的IRemoteObject实现类。开发者获取服务端传过来IRemoteObject对象，并从中解析出服务端传过来的信息。
    }

    // Service异常死亡的回调
    @Override
    public void onAbilityDisconnectDone(ElementName elementName, int resultCode) {
    }
};</code></pre><p>连接Service的代码示例如下：</p>
<pre><code>// 连接Service
Intent intent = new Intent();
Operation operation = new Intent.OperationBuilder()
        .withDeviceId("deviceId")
        .withBundleName("com.domainname.hiworld.himusic")
        .withAbilityName("com.domainname.hiworld.himusic.ServiceAbility")
        .build();
intent.setOperation(operation);
connectAbility(intent, connection);</code></pre><p>同时，Service侧也需要在onConnect()时返回IRemoteObject，从而定义与Service进行通信的接口。onConnect()需要返回一个IRemoteObject对象，HarmonyOS提供了IRemoteObject的默认实现，用户可以通过继承LocalRemoteObject来创建自定义的实现类。Service侧把自身的实例返回给调用侧的代码示例如下：</p>
<pre><code>// 创建自定义IRemoteObject实现类
private class MyRemoteObject extends LocalRemoteObject {
    MyRemoteObject(){
    }
}

// 把IRemoteObject返回给客户端
@Override
protected IRemoteObject onConnect(Intent intent) {
    return new MyRemoteObject();
}
相关实例</code></pre><p>针对Service Ability开发，有以下示例工程可供参考：</p>
<ul>
<li><a href="https://gitee.com/openharmony/app_samples/tree/master/ability/ServiceAbility" target="_blank" rel="noopener">ServiceAbility</a>本示例演示了Service Ability的启动、停止、连接、断开连接等操作，支持对跨设备的Service Ability进行操作</li>
</ul>
<h3 id="Service-Ability生命周期"><a href="#Service-Ability生命周期" class="headerlink" title="Service Ability生命周期"></a>Service Ability生命周期</h3><p>与Page类似，Service也拥有生命周期，如图所示。根据调用方法的不同，其生命周期有以下两种路径：</p>
<ul>
<li><p>启动Service该Service在其他Ability调用startAbility()时创建，然后保持运行。其他Ability通过调用stopAbility()来停止Service，Service停止后，系统会将其销毁。</p>
</li>
<li><p>连接Service该Service在其他Ability调用connectAbility()时创建，客户端可通过调用disconnectAbility()断开连接。多个客户端可以绑定到相同Service，而且当所有绑定全部取消后，系统即会销毁该Service。</p>
</li>
</ul>
<p><img src="/images/loading.gif" data-original="../images/harmonyos/-16273165321791906" alt=""></p>
<h3 id="前台Service"><a href="#前台Service" class="headerlink" title="前台Service"></a>前台Service</h3><p>一般情况下，Service都是在后台运行的，后台Service的优先级都是比较低的，当资源不足时，系统有可能回收正在运行的后台Service。</p>
<p>在一些场景下（如播放音乐），用户希望应用能够一直保持运行，此时就需要使用前台Service。前台Service会始终保持正在运行的图标在系统状态栏显示。</p>
<p>使用前台Service并不复杂，开发者只需在Service创建的方法里，调用keepBackgroundRunning()将Service与通知绑定。调用keepBackgroundRunning()方法前需要在配置文件中声明ohos.permission.KEEP_BACKGROUND_RUNNING权限，同时还需要在配置文件中添加对应的backgroundModes参数。在onStop()方法中调用cancelBackgroundRunning()方法可停止前台Service。</p>
<p>使用前台Service的onStart()代码示例如下：</p>
<pre><code>// 创建通知，其中1005为notificationId
NotificationRequest request = new NotificationRequest(1005);
NotificationRequest.NotificationNormalContent content = new NotificationRequest.NotificationNormalContent();
content.setTitle("title").setText("text");
NotificationRequest.NotificationContent notificationContent = new NotificationRequest.NotificationContent(content);
request.setContent(notificationContent);

// 绑定通知，1005为创建通知时传入的notificationId
keepBackgroundRunning(1005, request);</code></pre><p>在配置文件中，“module &gt; abilities”字段下对当前Service做如下配置：</p>
<pre><code>{    
    "name": ".ServiceAbility",
    "type": "service",
    "visible": true,
    "backgroundModes": ["dataTransfer", "location"]
}</code></pre><h2 id="Data-Ability"><a href="#Data-Ability" class="headerlink" title="Data Ability"></a>Data Ability</h2><p>使用Data模板的Ability（以下简称“Data”）有助于应用管理其自身和其他应用存储数据的访问，并提供与其他应用共享数据的方法。Data既可用于同设备不同应用的数据共享，也支持跨设备不同应用的数据共享。</p>
<p>数据的存放形式多样，可以是数据库，也可以是磁盘上的文件。Data对外提供对数据的增、删、改、查，以及打开文件等接口，这些接口的具体实现由开发者提供。</p>
<h4 id="URI介绍"><a href="#URI介绍" class="headerlink" title="URI介绍"></a>URI介绍</h4><p>Data的提供方和使用方都通过URI（Uniform Resource Identifier）来标识一个具体的数据，例如数据库中的某个表或磁盘上的某个文件。HarmonyOS的URI仍基于URI通用标准，格式如下：</p>
<p><img src="/images/loading.gif" data-original="../images/harmonyos/-16273165366421908" alt=""></p>
<ul>
<li><p>scheme：协议方案名，固定为“dataability”，代表Data Ability所使用的协议类型。</p>
</li>
<li><p>authority：设备ID。如果为跨设备场景，则为目标设备的ID；如果为本地设备场景，则不需要填写。</p>
</li>
<li><p>path：资源的路径信息，代表特定资源的位置信息。</p>
</li>
<li><p>query：查询参数。</p>
</li>
<li><p>fragment：可以用于指示要访问的子资源。</p>
</li>
</ul>
<p>URI示例：</p>
<ul>
<li><p>跨设备场景：dataability://<em>device_id</em>/<em>com.domainname.dataability.persondata</em>/<em>person</em>/<em>10</em></p>
</li>
<li><p>本地设备：dataability:///<em>com.domainname.dataability.persondata</em>/<em>person</em>/<em>10</em></p>
</li>
</ul>
<h3 id="创建Data"><a href="#创建Data" class="headerlink" title="创建Data"></a>创建Data</h3><p>使用Data模板的Ability形式仍然是Ability，因此，开发者需要为应用添加一个或多个Ability的子类，来提供程序与其他应用之间的接口。Data为结构化数据和文件提供了不同API接口供用户使用，因此，开发者需要首先确定好使用何种类型的数据。本章节主要讲述了创建Data的基本步骤和需要使用的接口。</p>
<p><strong>Data提供方可以自定义数据的增、删、改、查，以及文件打开等功能，并对外提供这些接口。</strong></p>
<h4 id="确定数据存储方式"><a href="#确定数据存储方式" class="headerlink" title="确定数据存储方式"></a>确定数据存储方式</h4><p>确定数据的存储方式，Data支持以下两种数据形式：</p>
<ul>
<li><p>文件数据：如文本、图片、音乐等。</p>
</li>
<li><p>结构化数据：如数据库等。</p>
</li>
</ul>
<h4 id="实现UserDataAbility"><a href="#实现UserDataAbility" class="headerlink" title="实现UserDataAbility"></a>实现UserDataAbility</h4><p>UserDataAbility用于接收其他应用发送的请求，提供外部程序访问的入口，从而实现应用间的数据访问。</p>
<p>实现UserDataAbility，需要在“Project”窗口当前工程的主目录（“entry &gt; src &gt; main &gt; java &gt; com.xxx.xxx”）选择“File &gt; New &gt; Ability &gt; Empty Data Ability”，设置“Data Name”后完成UserDataAbility的创建。</p>
<p>Data提供了文件存储和数据库存储两组接口供用户使用。</p>
<p><strong>文件存储</strong></p>
<p>开发者需要在Data中重写FileDescriptor openFile(Uri uri, String mode)方法来操作文件：uri为客户端传入的请求目标路径；mode为开发者对文件的操作选项，可选方式包含“r”(读), “w”(写), “rw”(读写)等。</p>
<p>ohos.rpc.MessageParcel类提供了一个静态方法，用于获取MessageParcel实例。开发者可通过获取到的MessageParcel实例，使用dupFileDescriptor()函数复制待操作文件流的文件描述符，并将其返回，供远端应用访问文件。</p>
<p>示例：根据传入的uri打开对应的文件</p>
<pre><code>private static final HiLogLabel LABEL_LOG = new HiLogLabel(HiLog.LOG_APP, 0xD00201, "Data_Log");

@Override
public FileDescriptor openFile(Uri uri, String mode) throws FileNotFoundException {
    // 创建messageParcel
    MessageParcel messageParcel = MessageParcel.obtain();
    File file = new File(uri.getDecodedPathList().get(0)); //get(0)是获取URI完整字段中查询参数字段。
    if (mode == null || !"rw".equals(mode)) {
        file.setReadOnly();
    }
    FileInputStream fileIs = new FileInputStream(file);
    FileDescriptor fd = null;
    try {
        fd = fileIs.getFD();
    } catch (IOException e) {
        HiLog.info(LABEL_LOG, "failed to getFD");
    }

    // 绑定文件描述符
    return messageParcel.dupFileDescriptor(fd);
}</code></pre><p><strong>数据库存储</strong></p>
<ol>
<li>初始化数据库连接。系统会在应用启动时调用onStart()方法创建Data实例。在此方法中，开发者应该创建数据库连接，并获取连接对象，以便后续和数据库进行操作。为了避免影响应用启动速度，开发者应当尽可能将非必要的耗时任务推迟到使用时执行，而不是在此方法中执行所有初始化。</li>
</ol>
<p>示例：初始化的时候连接数据库</p>
<pre><code>private static final String DATABASE_NAME = "UserDataAbility.db";
private static final String DATABASE_NAME_ALIAS = "UserDataAbility";
private static final HiLogLabel LABEL_LOG = new HiLogLabel(HiLog.LOG_APP, 0xD00201, "Data_Log");
private OrmContext ormContext = null;

@Override
public void onStart(Intent intent) {
    super.onStart(intent);
    DatabaseHelper manager = new DatabaseHelper(this);
    ormContext = manager.getOrmContext(DATABASE_NAME_ALIAS, DATABASE_NAME, BookStore.class);
}</code></pre><ol>
<li>编写数据库操作方法。Ability定义了6个方法供用户处理对数据库表数据的增删改查。这6个方法在Ability中已默认实现，开发者可按需重写。</li>
</ol>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>ResultSet query(Uri uri, String[] columns, DataAbilityPredicates predicates)</td>
<td>查询数据库</td>
</tr>
<tr>
<td>int insert(Uri uri, ValuesBucket value)</td>
<td>向数据库中插入单条数据</td>
</tr>
<tr>
<td>int batchInsert(Uri uri, ValuesBucket[] values)</td>
<td>向数据库中插入多条数据</td>
</tr>
<tr>
<td>int delete(Uri uri, DataAbilityPredicates predicates)</td>
<td>删除一条或多条数据</td>
</tr>
<tr>
<td>int update(Uri uri, ValuesBucket value, DataAbilityPredicates predicates)</td>
<td>更新数据库</td>
</tr>
<tr>
<td>DataAbilityResult[] executeBatch(ArrayList<dataabilityoperation> operations)</dataabilityoperation></td>
<td>批量操作数据库</td>
</tr>
</tbody></table>
<p>这些方法的使用说明如下：</p>
<ul>
<li>query()该方法接收三个参数，分别是查询的目标路径，查询的列名，以及查询条件，查询条件由类DataAbilityPredicates构建。根据传入的列名和查询条件查询用户表的代码示例如下：</li>
</ul>
<pre><code>public ResultSet query(Uri uri, String[] columns, DataAbilityPredicates predicates) {
    if (ormContext == null) {
        HiLog.error(LABEL_LOG, "failed to query, ormContext is null");
        return null;
    }

    // 查询数据库
    OrmPredicates ormPredicates = DataAbilityUtils.createOrmPredicates(predicates,User.class);
    ResultSet resultSet = ormContext.query(ormPredicates, columns);
    if (resultSet == null) {
        HiLog.info(LABEL_LOG, "resultSet is null");
    }

    // 返回结果
    return resultSet;
}</code></pre><p>insert()该方法接收两个参数，分别是插入的目标路径和插入的数据值。其中，插入的数据由ValuesBucket封装，服务端可以从该参数中解析出对应的属性，然后插入到数据库中。此方法返回一个int类型的值用于标识结果。接收到传过来的用户信息并把它保存到数据库中的代码示例如下：</p>
<pre><code>public int insert(Uri uri, ValuesBucket value) {
    // 参数校验
    if (ormContext == null) {
        HiLog.error(LABEL_LOG, "failed to insert, ormContext is null");
        return -1;
    }

    // 构造插入数据
    User user = new User();
    user.setUserId(value.getInteger("userId"));
    user.setFirstName(value.getString("firstName"));
    user.setLastName(value.getString("lastName"));
    user.setAge(value.getInteger("age"));
    user.setBalance(value.getDouble("balance"));

    // 插入数据库
    boolean isSuccessful = ormContext.insert(user);
    if (!isSuccessful) {
        HiLog.error(LABEL_LOG, "failed to insert");
        return -1;
    }
    isSuccessful = ormContext.flush();
    if (!isSuccessful) {
        HiLog.error(LABEL_LOG, "failed to insert flush");
        return -1;
    }
    DataAbilityHelper.creator(this, uri).notifyChange(uri);
    int id = Math.toIntExact(user.getRowId());
    return id;
}</code></pre><ul>
<li><p>batchInsert()该方法为批量插入方法，接收一个ValuesBucket数组用于单次插入一组对象。它的作用是提高插入多条重复数据的效率。该方法系统已实现，开发者可以直接调用。</p>
</li>
<li><p>delete()该方法用来执行删除操作。删除条件由类DataAbilityPredicates构建，服务端在接收到该参数之后可以从中解析出要删除的数据，然后到数据库中执行。根据传入的条件删除用户表数据的代码示例如下：</p>
</li>
</ul>
<pre><code>public int delete(Uri uri, DataAbilityPredicates predicates) {
    if (ormContext == null) {
        HiLog.error(LABEL_LOG, "failed to delete, ormContext is null");
        return -1;
    }

    OrmPredicates ormPredicates = DataAbilityUtils.createOrmPredicates(predicates,User.class);
    int value = ormContext.delete(ormPredicates);
    DataAbilityHelper.creator(this, uri).notifyChange(uri);
    return value;
}</code></pre><ul>
<li>update()此方法用来执行更新操作。用户可以在ValuesBucket参数中指定要更新的数据，在DataAbilityPredicates中构建更新的条件等。更新用户表的数据的代码示例如下：</li>
</ul>
<pre><code>public int update(Uri uri, ValuesBucket value, DataAbilityPredicates predicates) {
    if (ormContext == null) {
       HiLog.error(LABEL_LOG, "failed to update, ormContext is null");
       return -1;
   }

   OrmPredicates ormPredicates = DataAbilityUtils.createOrmPredicates(predicates,User.class);
   int index = ormContext.update(ormPredicates, value);
   HiLog.info(LABEL_LOG, "UserDataAbility update value:" + index);
   DataAbilityHelper.creator(this, uri).notifyChange(uri);
   return index;
}</code></pre><ul>
<li>executeBatch()此方法用来批量执行操作。DataAbilityOperation中提供了设置操作类型、数据和操作条件的方法，用户可自行设置自己要执行的数据库操作。该方法系统已实现，开发者可以直接调用。</li>
</ul>
<p>说明</p>
<p>上述代码示例中，初始化了数据库类BookStore.class，并通过实体类User.class对该数据库的表User进行增删改查操作。</p>
<p>关于对象关系映射数据库的具体逻辑，以及示例中BookStore.class与User.class的逻辑关系，可参考“<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/database-orm-guidelines-0000000000030063" target="_blank" rel="noopener">对象关系映射数据库开发指导</a>”。</p>
<h4 id="注册UserDataAbility"><a href="#注册UserDataAbility" class="headerlink" title="注册UserDataAbility"></a>注册UserDataAbility</h4><p>和Service类似，开发者必须在配置文件中注册Data。</p>
<p>配置文件中该字段在创建Data Ability时会自动创建，name与创建的Data Ability一致。</p>
<p>需要关注以下属性：</p>
<ul>
<li><p>type: 类型设置为data</p>
</li>
<li><p>uri: 对外提供的访问路径，全局唯一</p>
</li>
<li><p>permissions: 访问该data ability时需要申请的访问权限</p>
</li>
</ul>
<p>说明</p>
<p>如果权限非系统权限，需要在配置文件中进行自定义。请参考<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/security-permissions-guidelines-0000000000029886" target="_blank" rel="noopener">权限开发指导</a>中关于“自定义权限”的相关说明。</p>
<pre><code>{
    "name": ".UserDataAbility",
     "type": "data",
     "visible": true,
     "uri": "dataability://com.example.myapplication5.DataAbilityTest",
     "permissions": [
        "com.example.myapplication5.DataAbility.DATA"
     ]
}</code></pre><h3 id="访问Data"><a href="#访问Data" class="headerlink" title="访问Data"></a>访问Data</h3><p>开发者可以通过DataAbilityHelper类来访问当前应用或其他应用提供的共享数据。DataAbilityHelper作为客户端，与提供方的Data进行通信。Data接收到请求后，执行相应的处理，并返回结果。DataAbilityHelper提供了一系列与Data Ability对应的方法。</p>
<p>下面介绍DataAbilityHelper具体的使用步骤。</p>
<h4 id="声明使用权限"><a href="#声明使用权限" class="headerlink" title="声明使用权限"></a>声明使用权限</h4><p>如果待访问的Data声明了访问需要权限，则访问此Data需要在配置文件中声明需要此权限。声明请参考<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/security-permissions-guidelines-0000000000029886#ZH-CN_TOPIC_0000001072906209__table73291742539" target="_blank" rel="noopener">权限申请字段说明</a>。</p>
<pre><code>"reqPermissions": [
    {
        "name": "com.example.myapplication5.DataAbility.DATA"
    },
    // 访问文件还需要添加访问存储读写权限
    {
        "name": "ohos.permission.READ_USER_STORAGE"
    },
    {
        "name": "ohos.permission.WRITE_USER_STORAGE"
    }
]</code></pre><h4 id="创建DataAbilityHelper"><a href="#创建DataAbilityHelper" class="headerlink" title="创建DataAbilityHelper"></a>创建DataAbilityHelper</h4><p>DataAbilityHelper为开发者提供了creator()方法来创建DataAbilityHelper实例。该方法为静态方法，有多个重载。最常见的方法是通过传入一个context对象来创建DataAbilityHelper对象。</p>
<p>获取helper对象示例：</p>
<ol>
<li>DataAbilityHelper helper = DataAbilityHelper.creator(this);</li>
</ol>
<h4 id="访问Data-Ability"><a href="#访问Data-Ability" class="headerlink" title="访问Data Ability"></a>访问Data Ability</h4><p>DataAbilityHelper为开发者提供了一系列的接口来访问不同类型的数据（文件、数据库等）。</p>
<ul>
<li><strong>访问文件</strong>DataAbilityHelper为开发者提供了FileDescriptor openFile(Uri uri, String mode)方法来操作文件。此方法需要传入两个参数，其中uri用来确定目标资源路径，mode用来指定打开文件的方式，可选方式包含“r”(读), “w”(写), “rw”(读写)，“wt”(覆盖写)，“wa”(追加写)，“rwt”(覆盖写且可读)。</li>
</ul>
<p>该方法返回一个目标文件的FD（文件描述符），把文件描述符封装成流，开发者就可以对文件流进行自定义处理。</p>
<p>访问文件示例：</p>
<pre><code>// 读取文件描述符
FileDescriptor fd = helper.openFile(uri, "r");
FileInputStream fis = new FileInputStream(fd);

// 使用文件描述符封装成的文件流，进行文件操作</code></pre><ul>
<li><strong>访问数据库</strong>DataAbilityHelper为开发者提供了增、删、改、查以及批量处理等方法来操作数据库。</li>
</ul>
<p>说明</p>
<p>对数据库的操作方法，详见<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/database-relational-overview-0000000000030046" target="_blank" rel="noopener">数据管理</a>中各数据库类型的开发指南。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>ResultSet query(Uri uri, String[] columns, DataAbilityPredicates predicates)</td>
<td>查询数据库</td>
</tr>
<tr>
<td>int insert(Uri uri, ValuesBucket value)</td>
<td>向数据库中插入单条数据</td>
</tr>
<tr>
<td>int batchInsert(Uri uri, ValuesBucket[] values)</td>
<td>向数据库中插入多条数据</td>
</tr>
<tr>
<td>int delete(Uri uri, DataAbilityPredicates predicates)</td>
<td>删除一条或多条数据</td>
</tr>
<tr>
<td>int update(Uri uri, ValuesBucket value, DataAbilityPredicates predicates)</td>
<td>更新数据库</td>
</tr>
<tr>
<td>DataAbilityResult[] executeBatch(ArrayList<dataabilityoperation> operations)</dataabilityoperation></td>
<td>批量操作数据库</td>
</tr>
</tbody></table>
<p>这些方法的使用说明如下：</p>
<ul>
<li>query()查询方法，其中uri为目标资源路径，columns为想要查询的字段。开发者的查询条件可以通过DataAbilityPredicates来构建。查询用户表中id在101-103之间的用户，并把结果打印出来，代码示例如下：</li>
</ul>
<pre><code>DataAbilityHelper helper = DataAbilityHelper.creator(this);

// 构造查询条件
DataAbilityPredicates predicates = new DataAbilityPredicates();
predicates.between("userId", 101, 103);

// 进行查询
ResultSet resultSet = helper.query(uri, columns, predicates);

// 处理结果
resultSet.goToFirstRow();
do {
    // 在此处理ResultSet中的记录;
} while(resultSet.goToNextRow());</code></pre><ul>
<li>insert()新增方法，其中uri为目标资源路径，ValuesBucket为要新增的对象。插入一条用户信息的代码示例如下：</li>
</ul>
<pre><code>DataAbilityHelper helper = DataAbilityHelper.creator(this);

// 构造插入数据
ValuesBucket valuesBucket = new ValuesBucket();
valuesBucket.putString("name", "Tom");
valuesBucket.putInteger("age", 12);
helper.insert(uri, valuesBucket);</code></pre><ul>
<li>batchInsert(）批量插入方法，和insert()类似。批量插入用户信息的代码示例如下：</li>
</ul>
<pre><code>DataAbilityHelper helper = DataAbilityHelper.creator(this);

// 构造插入数据
ValuesBucket[] values = new ValuesBucket[2];
values[0] = new ValuesBucket();
values[0].putString("name", "Tom");
values[0].putInteger("age", 12);
values[1] = new ValuesBucket();
values[1].putString("name", "Tom1");
values[1].putInteger("age", 16);
helper.batchInsert(uri, values);</code></pre><ul>
<li>delete()删除方法，其中删除条件可以通过DataAbilityPredicates来构建。删除用户表中id在101-103之间的用户，代码示例如下：</li>
</ul>
<pre><code>DataAbilityHelper helper = DataAbilityHelper.creator(this);

// 构造删除条件
DataAbilityPredicates predicates = new DataAbilityPredicates();
predicates.between("userId", 101, 103);
helper.delete(uri, predicates);</code></pre><ul>
<li>update()更新方法，更新数据由ValuesBucket传入，更新条件由DataAbilityPredicates来构建。更新id为102的用户，代码示例如下：</li>
</ul>
<pre><code>DataAbilityHelper helper = DataAbilityHelper.creator(this);

// 构造更新条件
DataAbilityPredicates predicates = new DataAbilityPredicates();
predicates.equalTo("userId", 102);

// 构造更新数据
ValuesBucket valuesBucket = new ValuesBucket();
valuesBucket.putString("name", "Tom");
valuesBucket.putInteger("age", 12);
helper.update(uri, valuesBucket, predicates);</code></pre><ul>
<li>executeBatch()此方法用来执行批量操作。DataAbilityOperation中提供了设置操作类型、数据和操作条件的方法，开发者可自行设置自己要执行的数据库操作。插入多条数据的代码示例如下：</li>
</ul>
<pre><code>DataAbilityHelper helper = DataAbilityHelper.creator(abilityObj, insertUri);

// 构造批量操作
ValuesBucket value1 = initSingleValue();
DataAbilityOperation opt1 = DataAbilityOperation.newInsertBuilder(insertUri).withValuesBucket(value1).build();
ValuesBucket value2 = initSingleValue2();
DataAbilityOperation opt2 = DataAbilityOperation.newInsertBuilder(insertUri).withValuesBucket(value2).build();
ArrayList&lt;DataAbilityOperation&gt; operations = new ArrayList&lt;DataAbilityOperation&gt;();
operations.add(opt1);
operations.add(opt2);
DataAbilityResult[] result = helper.executeBatch(insertUri, operations);</code></pre><h4 id="相关实例-2"><a href="#相关实例-2" class="headerlink" title="相关实例"></a>相关实例</h4><p>针对Data Ability开发，有以下示例工程可供参考：</p>
<ul>
<li><a href="https://gitee.com/openharmony/app_samples/tree/master/ability/DataAbility" target="_blank" rel="noopener">DataAbility</a>本示例演示了如何使用Data Ability对数据库进行增、删、改、查，以及读取文本文件。</li>
</ul>
<p>针对Data Ability开发，有以下Codelabs可供参考：</p>
<ul>
<li><a href="https://developer.huawei.com/consumer/cn/codelabsPortal/carddetails/HarmonyOS-Relational-Database" target="_blank" rel="noopener">关系型数据库</a>基于Data Ability的关系型数据库和数据管理能力，实现数据库相关应用服务的快速开发。</li>
</ul>
<h2 id="Intent"><a href="#Intent" class="headerlink" title="Intent"></a>Intent</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>Intent是对象之间传递信息的载体。例如，当一个Ability需要启动另一个Ability时，或者一个AbilitySlice需要导航到另一个AbilitySlice时，可以通过Intent指定启动的目标同时携带相关数据。Intent的构成元素包括Operation与Parameters，具体描述参见表。</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>子属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Operation</td>
<td>Action</td>
<td>表示动作，通常使用系统预置Action，应用也可以自定义Action。例如IntentConstants.ACTION_HOME表示返回桌面动作。</td>
</tr>
<tr>
<td>Entity</td>
<td>表示类别，通常使用系统预置Entity，应用也可以自定义Entity。例如Intent.ENTITY_HOME表示在桌面显示图标。</td>
<td></td>
</tr>
<tr>
<td>Uri</td>
<td>表示Uri描述。如果在Intent中指定了Uri，则Intent将匹配指定的Uri信息，包括scheme, schemeSpecificPart, authority和path信息。</td>
<td></td>
</tr>
<tr>
<td>Flags</td>
<td>表示处理Intent的方式。例如Intent.FLAG_ABILITY_CONTINUATION标记在本地的一个Ability是否可以迁移到远端设备继续运行。</td>
<td></td>
</tr>
<tr>
<td>BundleName</td>
<td>表示包描述。如果在Intent中同时指定了BundleName和AbilityName，则Intent可以直接匹配到指定的Ability。</td>
<td></td>
</tr>
<tr>
<td>AbilityName</td>
<td>表示待启动的Ability名称。如果在Intent中同时指定了BundleName和AbilityName，则Intent可以直接匹配到指定的Ability。</td>
<td></td>
</tr>
<tr>
<td>DeviceId</td>
<td>表示运行指定Ability的设备ID。</td>
<td></td>
</tr>
<tr>
<td>Parameters</td>
<td>-</td>
<td>Parameters是一种支持自定义的数据结构，开发者可以通过Parameters传递某些请求所需的额外信息。</td>
</tr>
</tbody></table>
<p>当Intent用于发起请求时，根据指定元素的不同，分为两种类型：</p>
<ul>
<li><p>如果同时指定了BundleName与AbilityName，则根据Ability的全称（例如“com.demoapp.FooAbility”）来直接启动应用。</p>
</li>
<li><p>如果未同时指定BundleName和AbilityName，则根据Operation中的其他属性来启动应用。</p>
</li>
</ul>
<p>说明</p>
<p>Intent设置属性时，必须先使用Operation来设置属性。如果需要新增或修改属性，必须在设置Operation后再执行操作。</p>
<p>关于Intent最简单的使用方法，可参见<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/start-overview-0000000000029602" target="_blank" rel="noopener">快速入门</a>的示例代码。其中“<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/start-page-redirection-0000001051242367" target="_blank" rel="noopener">实现页面跳转</a>”重点描述了使用Intent实现两个页面跳转关系的操作。</p>
<h3 id="根据Ability的全称启动应用"><a href="#根据Ability的全称启动应用" class="headerlink" title="根据Ability的全称启动应用"></a>根据Ability的全称启动应用</h3><p>通过构造包含BundleName与AbilityName的Operation对象，可以启动一个Ability、并导航到该Ability。示例代码如下：</p>
<pre><code>Intent intent = new Intent();

// 通过Intent中的OperationBuilder类构造operation对象，指定设备标识（空串表示当前设备）、应用包名、Ability名称
Operation operation = new Intent.OperationBuilder()
        .withDeviceId("")
        .withBundleName("com.demoapp")
        .withAbilityName("com.demoapp.FooAbility")
        .build();

// 把operation设置到intent中
intent.setOperation(operation);
startAbility(intent);</code></pre><p>作为处理请求的对象，会在相应的回调方法中接收请求方传递的Intent对象。以导航到另一个Ability为例，导航的目标Ability可以在其onStart()回调的参数中获得Intent对象。</p>
<h3 id="根据Operation的其他属性启动应用"><a href="#根据Operation的其他属性启动应用" class="headerlink" title="根据Operation的其他属性启动应用"></a>根据Operation的其他属性启动应用</h3><p>有些场景下，开发者需要在应用中使用其他应用提供的某种能力，而不感知提供该能力的具体是哪一个应用。例如开发者需要通过浏览器打开一个链接，而不关心用户最终选择哪一个浏览器应用，则可以通过Operation的其他属性（除BundleName与AbilityName之外的属性）描述需要的能力。如果设备上存在多个应用提供同种能力，系统则弹出候选列表，由用户选择由哪个应用处理请求。以下示例展示使用Intent跨Ability查询天气信息。</p>
<p><strong>请求方</strong></p>
<p>在Ability中构造Intent以及包含Action的Operation对象，并调用startAbilityForResult()方法发起请求。然后重写onAbilityResult()回调方法，对请求结果进行处理。</p>
<pre><code>private void queryWeather() {
    Intent intent = new Intent();
    Operation operation = new Intent.OperationBuilder()
            .withAction(Intent.ACTION_QUERY_WEATHER)
            .build();
    intent.setOperation(operation);
    startAbilityForResult(intent, REQ_CODE_QUERY_WEATHER);
}

@Override
protected void onAbilityResult(int requestCode, int resultCode, Intent resultData) {
    switch (requestCode) {
        case REQ_CODE_QUERY_WEATHER:
            // Do something with result.
            ...
            return;
        default:
            ...
    }
}</code></pre><p><strong>处理方</strong></p>
<ol>
<li>作为处理请求的对象，首先需要在配置文件中声明对外提供的能力，以便系统据此找到自身并作为候选的请求处理者。</li>
</ol>
<pre><code>{
    "module": {
        ...
        "abilities": [
            {
                ...
                "skills":[
                    {
                        "actions":[
                            "ability.intent.QUERY_WEATHER"
                        ]
                    }
                ]
                ...
            }
        ]
        ...
    }
    ...
}</code></pre><ol>
<li>在Ability中配置路由以便支持以此action导航到对应的AbilitySlice。</li>
</ol>
<pre><code>@Override
protected void onStart(Intent intent) {
    ...
    addActionRoute(Intent.ACTION_QUERY_WEATHER, DemoSlice.class.getName());
    ...
}</code></pre><ol>
<li>在Ability中处理请求，并调用setResult()方法暂存返回结果。</li>
</ol>
<pre><code>@Override
protected void onActive() {
    ...
    Intent resultIntent = new Intent();
    setResult(0, resultIntent);   //0为当前Ability销毁后返回的resultCode。
    ...
}</code></pre><h3 id="相关实例-3"><a href="#相关实例-3" class="headerlink" title="相关实例"></a>相关实例</h3><p>针对Intent开发，有以下示例工程可供参考：</p>
<ul>
<li><p><a href="https://gitee.com/openharmony/app_samples/tree/master/ability/Intent" target="_blank" rel="noopener">Intent</a>本示例演示了如何根据Ability的全称启动应用和根据Operation的其他属性启动应用。</p>
</li>
<li><p><a href="https://gitee.com/openharmony/app_samples/tree/master/ability/AbilityIntent" target="_blank" rel="noopener">AbilityIntent</a>本示例通过Ability的全称和Operation的其他属性两种方式实现界面跳转以及数据传递</p>
</li>
</ul>
<h2 id="分布式任务调度"><a href="#分布式任务调度" class="headerlink" title="分布式任务调度"></a>分布式任务调度</h2><p>在HarmonyOS中，分布式任务调度平台对搭载HarmonyOS的多设备构筑的“超级虚拟终端”提供统一的组件管理能力，为应用定义统一的能力基线、接口形式、数据结构、服务描述语言，屏蔽硬件差异；支持远程启动、远程调用、业务无缝迁移等分布式任务。</p>
<p>分布式任务调度平台在底层实现<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/ability-ability-overview-0000000000029852" target="_blank" rel="noopener">Ability</a>（分布式任务调度的基本组件）跨设备的启动/关闭、连接及断开连接以及迁移等能力，实现跨设备的组件管理：</p>
<ul>
<li><p>启动和关闭：向开发者提供管理远程Ability的能力，即支持启动Page模板的Ability，以及启动、关闭Service和Data模板的Ability。</p>
</li>
<li><p>连接和断开连接：向开发者提供跨设备控制服务（Service和Data模板的Ability）的能力，开发者可以通过与远程服务连接及断开连接实现获取或注销跨设备管理服务的对象，达到和本地一致的服务调度。</p>
</li>
<li><p>迁移能力：向开发者提供跨设备业务的无缝迁移能力，开发者可以通过调用Page模板Ability的迁移接口，将本地业务无缝迁移到指定设备中，打通设备间壁垒。</p>
</li>
</ul>
<h3 id="约束与限制"><a href="#约束与限制" class="headerlink" title="约束与限制"></a>约束与限制</h3><ul>
<li><p>开发者需要在Intent中设置支持分布式的标记（例如：Intent.FLAG_ABILITYSLICE_MULTI_DEVICE表示该应用支持分布式调度），否则将无法获得分布式能力。</p>
</li>
<li><p>开发者通过在config.json中的reqPermissions字段里添加多设备协同访问的权限申请：三方应用使用{“name”: “ohos.permission.DISTRIBUTED_DATASYNC”}。</p>
</li>
<li><p>PA（Particle Ability，Service和Data模板的Ability）的调用支持连接及断开连接、启动及关闭这四类行为，在进行调度时：</p>
<ul>
<li>开发者必须在Intent中指定PA对应的bundleName和abilityName。</li>
</ul>
</li>
<li><p>当开发者需要跨设备启动、关闭或连接PA时，需要在Intent中指定对端设备的deviceId。开发者可通过如设备管理类DeviceManager提供的getDeviceList获取指定条件下匿名化处理的设备列表，实现对指定设备PA的启动/关闭以及连接管理。</p>
</li>
<li><p>FA（Feature Ability，Page模板的Ability）的调用支持启动和迁移行为，在进行调度时：</p>
<ul>
<li>当启动FA时，需要开发者在Intent中指定对端设备的deviceId、bundleName和abilityName。</li>
</ul>
</li>
<li><p>FA的迁移实现相同bundleName和abilityName的FA跨设备迁移，因此需要指定迁移设备的deviceId。</p>
</li>
<li><p>DevEco Studio远程模拟设备的功能无法调测分布式任务调度，需要在真机环境下进行测试</p>
</li>
</ul>
<h3 id="场景介绍"><a href="#场景介绍" class="headerlink" title="场景介绍"></a>场景介绍</h3><p>开发者在应用中集成分布式调度能力，通过调用指定能力的分布式接口，实现跨设备能力调度。根据Ability模板及意图的不同，分布式任务调度向开发者提供以下六种能力：启动远程FA、启动远程PA、关闭远程PA、连接远程PA、断开连接远程PA和FA跨设备迁移。下面以设备A（本地设备）和设备B（远端设备）为例，进行场景介绍：</p>
<ol>
<li>设备A启动设备B的FA：在设备A上通过本地应用提供的启动按钮，启动设备B上对应的FA。例如：设备A控制设备B打开相册，只需开发者在启动FA时指定打开相册的意图即可。</li>
<li>设备A启动设备B的PA：在设备A上通过本地应用提供的启动按钮，启动设备B上指定的PA。例如：开发者在启动远程服务时通过意图指定音乐播放服务，即可实现设备A启动设备B音乐播放的能力。</li>
<li>设备A关闭设备B的PA：在设备A上通过本地应用提供的关闭按钮，关闭设备B上指定的PA。类似启动的过程，开发者在关闭远程服务时通过意图指定音乐播放服务，即可实现关闭设备B上该服务的能力。</li>
<li>设备A连接设备B的PA：在设备A上通过本地应用提供的连接按钮，连接设备B上指定的PA。连接后，通过其他功能相关按钮实现控制对端PA的能力。通过连接关系，开发者可以实现跨设备的同步服务调度，实现如大型计算任务互助等价值场景。</li>
<li>设备A与设备B的PA断开连接：在设备A上通过本地应用提供断开连接的按钮，将之前已连接的PA断开连接。</li>
<li>设备A的FA迁移至设备B：设备A上通过本地应用提供的迁移按钮，将设备A的业务无缝迁移到设备B中。通过业务迁移能力，打通设备A和设备B间的壁垒，实现如文档跨设备编辑、视频从客厅到房间跨设备接续播放等场景。</li>
</ol>
<h3 id="接口说明"><a href="#接口说明" class="headerlink" title="接口说明"></a>接口说明</h3><p>分布式调度平台提供的连接和断开连接PA、启动远程FA、启动和关闭PA以及迁移FA的能力，是实现更多价值性场景的基础。</p>
<p><strong>连接远程PA</strong></p>
<p>connectAbility(Intent intent, IAbilityConnection conn)接口提供连接指定设备上PA的能力，Intent中指定待连接PA的设备deviceId、bundleName和abilityName。当连接成功后，通过在conn定义的onAbilityConnectDone回调中获取对端PA的服务代理，两者的连接关系则由conn维护。具体的参数定义如下表所示：</p>
<table>
<thead>
<tr>
<th>参数名</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>intent</td>
<td>ohos.aafwk.content.Intent</td>
<td>开发者需在intent对应的Operation中指定待连接PA的设备deviceId、bundleName和abilityName。</td>
</tr>
<tr>
<td>conn</td>
<td>ohos.aafwk.ability.IAbilityConnection</td>
<td>当连接成功或失败时，作为连接关系的回调接口。该接口提供连接完成和断开连接完成时的处理逻辑，开发者可根据具体的场景进行定义。</td>
</tr>
</tbody></table>
<p><strong>启动远程FA/PA</strong></p>
<p>startAbility(Intent intent)接口提供启动指定设备上FA和PA的能力，Intent中指定待启动FA/PA的设备deviceId、bundleName和abilityName。具体参数定义如下表所示：</p>
<table>
<thead>
<tr>
<th>参数名</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>intent</td>
<td>ohos.aafwk.content.Intent</td>
<td>当开发者需要调用该接口启动远程PA时，需要指定待启动PA的设备deviceId、bundleName和abilityName。若不指定设备deviceId，则无法跨设备调用PA。类似地，在启动FA时，也需要开发者指定启动FA的设备deviceId、bundleName和abilityName。</td>
</tr>
</tbody></table>
<p>分布式调度平台还会提供与上述功能相对应的断开远程PA的连接和关闭远程PA的接口，相关的参数与连接、启动的接口类似。</p>
<ul>
<li><p>断开远程PA连接：disconnectAbility(IAbilityConnection conn)。</p>
</li>
<li><p>关闭远程PA：stopAbility(Intent intent)。</p>
</li>
</ul>
<p><strong>迁移FA</strong></p>
<p>continueAbility(String deviceId)接口提供将本地FA迁移到指定设备上的能力，需要开发者在调用时指定目标设备的deviceId。具体参数定义如下表所示：</p>
<p>说明</p>
<p>Ability和AbilitySlice类均需要实现IAbilityContinuation及其方法，才可以实现FA迁移。</p>
<table>
<thead>
<tr>
<th>参数名</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>deviceId</td>
<td>String</td>
<td>当开发者需要调用该接口将本地FA迁移时，需要指定目标设备的deviceId。</td>
</tr>
</tbody></table>
<h3 id="开发步骤"><a href="#开发步骤" class="headerlink" title="开发步骤"></a>开发步骤</h3><ol>
<li>导入功能依赖的包。</li>
</ol>
<pre><code>// 以下依赖包含分布式调度平台开放的接口
// 用于：连接/断开连接远程PA、启动远程FA、通过连接关系实现对PA的控制
import ohos.aafwk.ability.AbilitySlice;
import ohos.aafwk.ability.IAbilityConnection;
import ohos.aafwk.content.Intent;
import ohos.aafwk.content.Operation;
import ohos.bundle.ElementName;
// 为了实现迁移能力，需要引入传递迁移所需数据的包以及实现迁移能力的接口
import ohos.aafwk.ability.IAbilityContinuation;
import ohos.aafwk.content.IntentParams;
// 为了实现跨设备指令及数据通信，需要使用RPC接口
import ohos.rpc.IRemoteObject;
import ohos.rpc.IRemoteBroker;
import ohos.rpc.MessageParcel;
import ohos.rpc.MessageOption;
import ohos.rpc.RemoteException;
import ohos.rpc.RemoteObject;
//（可选）多设备场景下涉及设备选择，为此需要引入组网设备发现的能力
import ohos.distributedschedule.interwork.DeviceInfo;
import ohos.distributedschedule.interwork.DeviceManager;
// (可选）设计界面相关的包函数，对FA界面及按钮进行绘制
import ohos.agp.components.Button;
import ohos.agp.components.Component;
import ohos.agp.components.Component.ClickedListener;
import ohos.agp.components.ComponentContainer.LayoutConfig;
import ohos.agp.components.element.ShapeElement;
import ohos.agp.components.PositionLayout;</code></pre><ol>
<li>（可选）编写一个基本的FA用于使用分布式能力。</li>
</ol>
<pre><code>// 调用AbilitySlice模板实现一个用于控制基础功能的FA，AbilitySlice的代码示例如下：
public class SampleSlice extends AbilitySlice {
    @Override
    public void onStart(Intent intent) {
        super.onStart(intent);
        // 开发者可以自行进行界面设计
        // 为按钮设置统一的背景色
        // 例如通过PositionLayout可以实现简单界面
        PositionLayout layout = new PositionLayout(this);
        LayoutConfig config = new LayoutConfig(LayoutConfig.MATCH_PARENT, LayoutConfig.MATCH_PARENT);
        layout.setLayoutConfig(config);
        ShapeElement buttonBg = new ShapeElement();
        buttonBg.setRgbColor(new RgbColor(0, 125, 255));
        addComponents(layout, buttonBg, config);
        super.setUIContent(layout);
    }

    @Override
    public void onInactive() {
        super.onInactive();
    }

    @Override
    public void onActive() {
        super.onActive();
    }

    @Override
    public void onBackground() {
        super.onBackground();
    }

    @Override
    public void onForeground(Intent intent) {
        super.onForeground(intent);
    }

    @Override
    public void onStop() {
        super.onStop();
    }
}</code></pre><p>说明</p>
<p>此步骤展示了一个简单FA的实现过程，实际开发中请开发者根据需要进行设计。</p>
<ol>
<li>使用分布式能力要求开发者在Ability对应的config.json中声明多设备协同访问的权限：三方应用使用{“name”: “ohos.permission.DISTRIBUTED_DATASYNC”}。一个三方应用部署的示例如下：</li>
</ol>
<pre><code>{
    "reqPermissions": [
        {
            "name": "ohos.permission.DISTRIBUTED_DATASYNC"
        }
    ]
}</code></pre><p>此外，对于三方应用还要求在实现Ability的代码中显式声明需要使用的权限，如下所示：</p>
<pre><code>public class SampleSlice extends AbilitySlice {
    @Override
    public void onStart(Intent intent) {
        // 开发者显示声明需要使用的权限
        requestPermissionsFromUser(new String[]{"ohos.permission.DISTRIBUTED_DATASYNC"}, 0);
        super.onStart(intent);        
    }
}</code></pre><ol>
<li>（可选）为不同的能力设置相应的控制按钮。</li>
</ol>
<pre><code>// 建议开发者按照自己的界面进行按钮设计

// 开发者可以自行实现如下createButton的方法，新建一个显示文字text，背景色为buttonBg以及大小尺寸位置符合config设置的按钮，用来与用户交互
// private Button createButton(String text, ShapeElement buttonBg, LayoutConfig config)
// 按照顺序在PositionLayout中依次添加按钮的示例
private void addComponents(PositionLayout linear, ShapeElement buttonBg, LayoutConfig config) {
    // 构建远程启动FA的按钮
    btnStartRemoteFA = createButton("StartRemoteFA", buttonBg, config);
    btnStartRemoteFA.setClickedListener(mStartRemoteFAListener);
    linear.addComponent(btnStartRemoteFA);
    // 构建远程启动PA的按钮
    btnStartRemotePA = createButton("StartRemotePA", buttonBg, config);
    btnStartRemotePA.setClickedListener(mStartRemotePAListener);
    linear.addComponent(btnStartRemotePA);
    // 构建远程关闭PA的按钮
    btnStopRemotePA = createButton("StopRemotePA", buttonBg, config);
    btnStopRemotePA.setClickedListener(mStopRemotePAListener);
    linear.addComponent(btnStopRemotePA);
    // 构建连接远程PA的按钮
    btnConnectRemotePA = createButton("ConnectRemotePA", buttonBg, config);
    btnConnectRemotePA.setClickedListener(mConnectRemotePAListener);
    linear.addComponent(btnConnectRemotePA);
    // 构建控制连接PA的按钮
    btnControlRemotePA = createButton("ControlRemotePA", buttonBg, config);
    btnControlRemotePA.setClickedListener(mControlPAListener);
    linear.addComponent(btnControlRemotePA);
    // 构建与远程PA断开连接的按钮
    btnDisconnectRemotePA = createButton("DisconnectRemotePA", buttonBg, config);
    btnDisconnectRemotePA.setClickedListener(mDisconnectRemotePAListener);
    linear.addComponent(btnDisconnectRemotePA);
    // 构建迁移FA的按钮
    btnContinueRemoteFA = createButton("ContinueRemoteFA", buttonBg, config);
    btnContinueRemoteFA.setClickedListener(mContinueAbilityListener);
    linear.addComponent(btnContinueRemoteFA);
}</code></pre><p>说明</p>
<p>此处只展示了基于按钮控制的能力调度方法，实际开发中请开发者根据需要选择能力调度方式。代码示例中未体现按钮如位置、样式等具体的设置方法，详请参考<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/ui-java-overview-0000000000500404" target="_blank" rel="noopener">JAVA UI框架</a>。</p>
<ol>
<li>通过设备管理DeviceManager提供的getDeviceList接口获取设备列表，用于指定目标设备。</li>
</ol>
<pre><code>// ISelectResult是一个自定义接口，用来处理指定设备deviceId后执行的行为
 interface ISelectResult {
     void onSelectResult(String deviceId);
 }

// 获得设备列表，开发者可在得到的在线设备列表中选择目标设备执行操作
private void scheduleRemoteAbility(ISelectResult listener) {
    // 调用DeviceManager的getDeviceList接口，通过FLAG_GET_ONLINE_DEVICE标记获得在线设备列表
    List&lt;DeviceInfo&gt; onlineDevices = DeviceManager.getDeviceList(DeviceInfo.FLAG_GET_ONLINE_DEVICE);
    // 判断组网设备是否为空
    if (onlineDevices.isEmpty()) {
        listener.onSelectResult(null);
        return;
    }
    int numDevices = onlineDevices.size();
    List&lt;String&gt; deviceIds = new ArrayList&lt;&gt;(numDevices);
    onlineDevices.forEach((device) -&gt; {
        deviceIds.add(device.getDeviceId());
    });
    // 以选择首个设备作为目标设备为例
    // 开发者也可按照具体场景，通过别的方式进行设备选择
    String selectDeviceId = deviceIds.get(0);
    listener.onSelectResult(selectDeviceId);    
}</code></pre><p>上述实例中涉及对在线组网设备的查询，该项能力需要开发者在对应的config.json中声明获取设备列表及设备信息的权限，如下所示：</p>
<pre><code>{
    "reqPermissions": [
        {
            "name": "ohos.permission.DISTRIBUTED_DEVICE_STATE_CHANGE"
        }, 
        {
            "name": "ohos.permission.GET_DISTRIBUTED_DEVICE_INFO"
        }, 
        {
            "name": "ohos.permission.GET_BUNDLE_INFO"
        }
    ]
}</code></pre><ol>
<li>为启动远程FA的按钮设置点击回调，实现启动远程FA的能力。</li>
</ol>
<pre><code>// 启动一个指定bundleName和abilityName的FA
private ClickedListener mStartRemoteFAListener = new ClickedListener() {
    @Override
    public void onClick(Component arg0) {
        // 启动远程PA
        scheduleRemoteAbility(new ISelectResult() {
            @Override
            void onSelectResult(String deviceId) {
                if (deviceId != null) {
                    // 通过scheduleRemoteAbility指定目标设备deviceId
                    // 指定待启动FA的bundleName和abilityName
                    // 例如：bundleName = "com.helloworld"
                    //       abilityName = "com.helloworld.SampleFeatureAbility"
                    // 设置分布式标记，表明当前涉及分布式能力
                    Operation operation = new Intent.OperationBuilder()
                            .withDeviceId(deviceId)
                            .withBundleName(bundleName)
                            .withAbilityName(abilityName)
                            .withFlags(Intent.FLAG_ABILITYSLICE_MULTI_DEVICE)
                            .build();
                    Intent intent = new Intent();
                    intent.setOperation(operation);
                    // 通过AbilitySlice包含的startAbility接口实现跨设备启动FA
                    startAbility(intent);
                }
            }
        });
    }
};</code></pre><ol>
<li>为启动和关闭PA定义回调，实现启动和关闭PA的能力。对于PA的启动、关闭、连接等操作都需要开发者提供目标设备的deviceId。开发者可以通过DeviceManager相关接口得到当前组网下的设备列表，并以弹窗的形式供用户选择，也可以按照实际需要实现其他个性化的处理方式。在点击事件回调函数中，需要开发者指定得到deviceId后的处理逻辑，即实现类似上例中listener.onSelectResult(String deviceId)的方法，代码示例如下：</li>
</ol>
<pre><code>// 启动远程PA
private ClickedListener mStartRemotePAListener = new ClickedListener() {
    @Override
    public void onClick(Component arg0) {
        // 启动远程PA
        scheduleRemoteAbility(new ISelectResult() {
            @Override
            void onSelectResult(String deviceId) {
                if (deviceId != null) {
                    // bundleName和abilityName与待启动PA对应
                    // 例如：bundleName = "com.helloworld"
                    //       abilityName = "com.helloworld.SampleParticleAbility"
                    Operation operation = new Intent.OperationBuilder()
                            .withDeviceId(deviceId)
                            .withBundleName(bundleName)
                            .withAbilityName(abilityName)
                            .withFlags(Intent.FLAG_ABILITYSLICE_MULTI_DEVICE)
                            .build();
                    Intent intentToStartPA = new Intent();
                    intentToStartPA.setOperation(operation);
                    startAbility(intentToStartPA);
                }
            }
        });
    }
};

// 关闭远程PA，和启动类似开发者需要指定待关闭PA对应的bundleName和abilityName
private ClickedListener mStopRemotePAListener = new ClickedListener() {
    @Override
    public void onClick(Component arg0) {
        scheduleRemoteAbility(new ISelectResult() {
            @Override
            void onSelectResult(String deviceId) {
                if (deviceId != null) {
                    // bundleName和abilityName与待关闭PA对应
                    // 例如：bundleName = "com.helloworld"
                    //       abilityName = "com.helloworld.SampleParticleAbility"
                    Operation operation = new Intent.OperationBuilder()
                            .withDeviceId(deviceId)
                            .withBundleName(bundleName)
                            .withAbilityName(abilityName)
                            .withFlags(Intent.FLAG_ABILITYSLICE_MULTI_DEVICE)
                            .build();
                    Intent intentToStopPA = new Intent();
                    intentToStopPA.setOperation(operation);
                    stopAbility(intentToStopPA);
                }
            }
        });
    }
};</code></pre><p>说明</p>
<p>启动和关闭的行为类似，开发者只需在Intent中指定待调度PA的deviceId、bundleName和abilityName，并以operation的形式封装到Intent内。通过AbilitySlice（Ability）包含的startAbility()和stopAbility()接口即可实现相应功能。</p>
<ol>
<li>设备A连接设备B侧的PA，利用连接关系调用该PA执行特定任务，以及断开连接。</li>
</ol>
<pre><code>// 当连接完成时，用来提供管理已连接PA的能力
private MyRemoteProxy mProxy = null;
// 用于管理连接关系
private IAbilityConnection mConn = new IAbilityConnection() {
    @Override
    public void onAbilityConnectDone(ElementName element, IRemoteObject remote, int resultCode) {
        // 跨设备PA连接完成后，会返回一个序列化的IRemoteObject对象
        // 通过该对象得到控制远端服务的代理
        mProxy = new MyRemoteProxy(remote);
        btnConnectRemotePA.setText("connectRemoteAbility done");
    }

    @Override
    public void onAbilityDisconnectDone(ElementName element, int resultCode) {
        // 当已连接的远端PA关闭时，会触发该回调
        // 支持开发者按照返回的错误信息进行PA生命周期管理
        disconnectAbility(mConn);
    }
};</code></pre><p>仅通过启动/关闭两种方式对PA进行调度无法应对需长期交互的场景，因此，分布式任务调度平台向开发者提供了跨设备PA连接及断开连接的能力。为了对已连接PA进行管理，开发者需要实现一个满足IAbilityConnection接口的连接状态检测实例，通过该实例可以对连接及断开连接完成时设置具体的处理逻辑，例如：获取控制对端PA的代理等。进一步为了使用该代理跨设备调度PA，开发者需要在本地及对端分别实现对外接口一致的代理。一个具备加法能力的代理示例如下：</p>
<pre><code>// 以连接提供加法计算能力的PA为例。为了提供跨设备连接能力，需要在本地发起连接侧和对端被连接侧分别实现代理
// 发起连接侧的代理示例如下：
public class MyRemoteProxy implements IRemoteBroker {
    private static final int ERR_OK = 0;
    private static final int COMMAND_PLUS = IRemoteObject.MIN_TRANSACTION_ID;
    private final IRemoteObject remote;

    public MyRemoteProxy(IRemoteObject remote) {
        this.remote = remote;
    }

    @Override
    public IRemoteObject asObject() {
        return remote;
    }

    public int plus(int a, int b) throws RemoteException {
        MessageParcel data = MessageParcel.obtain();
        MessageParcel reply = MessageParcel.obtain();
        // option不同的取值，决定采用同步或异步方式跨设备控制PA
        // 本例需要同步获取对端PA执行加法的结果，因此采用同步的方式，即MessageOption.TF_SYNC
        // 具体MessageOption的设置，可参考相关API文档
        MessageOption option = new MessageOption(MessageOption.TF_SYNC);
        data.writeInt(a);
        data.writeInt(b);

        try {
            remote.sendRequest(COMMAND_PLUS, data, reply, option);
            int errCode = reply.readInt();
            if (errCode != ERR_OK) {
                throw new RemoteException();
            }
            int result = reply.readInt();
            return result;
        }
finally {
            data.reclaim();
            reply.reclaim();
        }
    }
}</code></pre><p>此外，对端待连接的PA需要实现对应的客户端，代码示例如下所示：</p>
<pre><code>// 以计算加法为例，对端实现的客户端如下
public class MyRemote extends RemoteObject implements IRemoteBroker{
    private static final int ERR_OK = 0;
    private static final int ERROR = -1;
    private static final int COMMAND_PLUS = IRemoteObject.MIN_TRANSACTION_ID;

    public MyRemote() {
        super("MyService_Remote");
    }

    @Override
    public IRemoteObject asObject() {
        return this;
    }

    @Override
    public boolean onRemoteRequest(int code, MessageParcel data, MessageParcel reply, MessageOption option) {
        if (code != COMMAND_PLUS) {
            reply.writeInt(ERROR);
            return false;
        }
        int value1 = data.readInt();
        int value2 = data.readInt();
        int sum = value1 + value2;
        reply.writeInt(ERR_OK);
        reply.writeInt(sum);
        return true;
    }
}</code></pre><p>对端除了要实现如上所述的客户端外，待连接的PA还需要作如下修改：</p>
<pre><code>// 为了返回给连接方可调用的代理，需要在该PA中实例化客户端，例如作为该PA的成员变量
private MyRemote remote = new MyRemote();
// 当该PA接收到连接请求时，即将该客户端转化为代理返回给连接发起侧
@Override
protected IRemoteObject onConnect(Intent intent) {
    super.onConnect(intent);
    return remote.asObject();
}</code></pre><p>完成上述步骤后，可以通过点击事件实现连接、利用连接关系控制PA以及断开连接等行为，代码示例如下：</p>
<pre><code>// 连接远程PA
private ClickedListener mConnectRemotePAListener = new ClickedListener() {
    @Override
    public void onClick(Component arg0) {
        scheduleRemoteAbility(new ISelectResult() {
            @Override
            void onSelectResult(String deviceId) {
                if (deviceId != null) {
                    Intent connectPAIntent = new Intent();
                    // bundleName和abilityName与待连接的PA一一对应
                    // 例如：bundleName = "com.helloworld"
                    //       abilityName = "com.helloworld.SampleParticleAbility"
                    Operation operation = new Intent.OperationBuilder()
                            .withDeviceId(deviceId)
                            .withBundleName(bundleName)
                            .withAbilityName(abilityName)
                            .withFlags(Intent.FLAG_ABILITYSLICE_MULTI_DEVICE)
                            .build();
                    connectPAIntent.setOperation(operation);
                    connectAbility(connectPAIntent, mConn);
                }
            }
        });
    }
};
// 控制已连接PA执行加法
private ClickedListener mControlPAListener = new ClickedListener() {
    @Override
    public void onClick(Component arg0) {
        if (mProxy != null) {
            int ret = -1;
            try {
                ret = mProxy.plus(10, 20);
            } catch (RemoteException e) {
                HiLog.error(LABEL, "ControlRemotePA error");
            }
            btnControlRemotePA.setText("ControlRemotePA result = " + ret);
        }
    }
};
// 与远程PA断开连接
private ClickedListener mDisconnectRemotePAListener = new ClickedListener() {
    @Override
    public void onClick(Component arg0) {
        // 按钮复位
        btnConnectRemotePA.setText("ConnectRemotePA");
        btnControlRemotePA.setText("ControlRemotePA");
        disconnectAbility(mConn);
    }
};</code></pre><p>说明</p>
<p>通过连接/断开连接远程PA，与跨设备PA建立长期的管理关系。例如在本例中，通过连接关系得到远程PA的控制代理后，实现跨设备计算加法并将结果返回到本地显示。在实际开发中，开发者可以根据需要实现多种分布式场景，例如：跨设备位置/电量等信息的采集、跨设备计算资源互助等。</p>
<ol>
<li>设备A将运行时的FA迁移到设备B，实现业务在设备间无缝迁移。</li>
</ol>
<pre><code>// 跨设备迁移FA
// 本地FA设置当前运行任务
private ClickedListener mContinueAbilityListener = new ClickedListener() {
    @Override
    public void onClick(Component arg0) {
        // 用户选择设备后实现业务迁移
        scheduleRemoteAbility(new ISelectResult() {
            @Override
            public void onSelectResult(String deviceId) {
                continueAbility(deviceId);
            }
        });
    }
};</code></pre><p>FA的迁移还涉及到状态数据的传递，需要继承IAbilityContinuation接口，供开发者实现迁移过程中特定事件的管理能力，代码示例如下：</p>
<pre><code>public class SampleSlice extends AbilitySlice implements IAbilityContinuation {
    @Override
    public boolean onSaveData(IntentParams saveData) {
        String exampleData = String.valueOf(System.currentTimeMillis());
        saveData.setParam("continueParam", exampleData);
        return true;
    }

    @Override
    public boolean onRestoreData(IntentParams restoreData) {
        // 远端FA迁移传来的状态数据，开发者可以按照特定的场景对这些数据进行处理
        Object data = restoreData.getParam("continueParam");
        return true;
    }

    @Override
    public void onCompleteContinuation(int result) {
        btnContinueRemoteFA.setText("ContinueAbility Done");
    }
}</code></pre><p>通过自定义迁移事件相关的行为，最终实现对Ability的迁移。具体的定义可以参考相关的API文档，此处主要以较为常用的两个事件，包括迁移发起端完成迁移的回调onCompleteContinuation(int result)以及接收到远端迁移行为传递数据的回调onRestoreData(IntentParams restoreData)。其他还包括迁移到远端设备的FA关闭的回调onRemoteTerminated()、用于本地迁移发起时保存状态数据的回调onSaveData(IntentParams saveData)和本地发起迁移的回调onStartContinuation()。按照实际应用自定义特定场景对应的回调，可以完成多种场景下FA的迁移任务。</p>
<p>说明</p>
<ul>
<li><p>FA迁移可以打通设备间的壁垒，有助于不同能力的设备进行互助。前文以一个简单的例子介绍如何通过分布式任务调度提供的能力，实现FA跨设备的迁移（包括FA启动及状态数据的同步）。</p>
</li>
<li><p>FA迁移过程中，远端FA首先接收到发起端FA传输的数据，再执行启动，即onRestoreData()发生在onStart()之前，详见API参考。</p>
</li>
</ul>
<h3 id="相关实例-4"><a href="#相关实例-4" class="headerlink" title="相关实例"></a>相关实例</h3><p>针对分布式任务调度，有以下示例工程可供参考：</p>
<ul>
<li><a href="https://gitee.com/openharmony/app_samples/tree/master/ability/DistributedScheduler" target="_blank" rel="noopener">DistributedScheduler</a>本示例演示了分布式任务调度的六种场景：启动远程FA，启动远程PA，关闭远程PA，连接远程PA，断开连接远程PA， 和FA跨端迁移。</li>
</ul>
<p>针对分布式任务调度，有以下Codelabs可供参考：</p>
<ul>
<li><p><a href="https://developer.huawei.com/consumer/cn/codelabsPortal/carddetails/HarmonyOS-Distributed-scheduling" target="_blank" rel="noopener">分布式调度启动远程FA</a>基于分布式调度的能力，实现远程FA的启动。</p>
</li>
<li><p><a href="https://developer.huawei.com/consumer/cn/codelabsPortal/carddetails/HarmonyOS-EducationSystem" target="_blank" rel="noopener">分布式亲子早教系统</a>基于分布式能力，实现一个多屏互动、跨设备协同的亲子早教系统。</p>
</li>
<li><p><a href="https://developer.huawei.com/consumer/cn/codelabsPortal/carddetails/HarmonyOS-DistributedInput" target="_blank" rel="noopener">分布式输入法</a>基于分布式能力，将手机作为智慧屏的虚拟控制器，控制文字输入和遥控播放。</p>
</li>
<li><p><a href="https://developer.huawei.com/consumer/cn/codelabsPortal/carddetails/HarmonyOS-Distributed-map-navigation" target="_blank" rel="noopener">分布式地图导航</a>基于分布式能力，实现地图导航信息在手机-车机-智能穿戴设备之间流转</p>
</li>
</ul>
<h2 id="公共事件与通知"><a href="#公共事件与通知" class="headerlink" title="公共事件与通知"></a>公共事件与通知</h2><p>armonyOS通过CES（Common Event Service，公共事件服务）为应用程序提供订阅、发布、退订公共事件的能力，通过ANS（Advanced Notification Service，即通知增强服务）系统服务来为应用程序提供发布通知的能力。</p>
<ul>
<li><p>公共事件可分为系统公共事件和自定义公共事件。</p>
<ul>
<li>系统公共事件：系统将收集到的事件信息，根据系统策略发送给订阅该事件的用户程序。 例如：用户可感知亮灭屏事件，系统关键服务发布的系统事件（例如：USB插拔，网络连接，系统升级等）。</li>
</ul>
</li>
<li><p>自定义公共事件：应用自定义一些公共事件用来处理业务逻辑。</p>
</li>
<li><p>通知提供应用的即时消息或通信消息，用户可以直接删除或点击通知触发进一步的操作。</p>
</li>
<li><p>IntentAgent封装了一个指定行为的Intent，可以通过IntentAgent启动Ability和发布公共事件。</p>
</li>
</ul>
<p>应用如果需要接收公共事件，需要订阅相应的事件。</p>
<h3 id="约束与限制-1"><a href="#约束与限制-1" class="headerlink" title="约束与限制"></a>约束与限制</h3><p><strong>公共事件的约束与限制</strong></p>
<ul>
<li><p>目前公共事件仅支持动态订阅。部分系统事件需要具有指定的权限，具体的权限见API参考。</p>
</li>
<li><p>目前公共事件订阅不支持多用户。</p>
</li>
<li><p><a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/ability-notification-fwk-common-event-0000000000029871#ZH-CN_TOPIC_0000001050988893__li1490625910238" target="_blank" rel="noopener">ThreadMode</a>表示线程模型，目前仅支持HANDLER模式，即在当前UI线程上执行回调函数。</p>
</li>
<li><p>deviceId用来指定订阅本地公共事件还是远端公共事件。deviceId为null、空字符串或本地设备deviceId时，表示订阅本地公共事件，否则表示订阅远端公共事件。</p>
</li>
</ul>
<p><strong>通知的约束与限制</strong></p>
<ul>
<li><p>通知目前支持六种样式：普通文本、长文本、图片、社交、多行文本和媒体样式。创建通知时必须包含一种样式。</p>
</li>
<li><p>通知支持快捷回复。</p>
</li>
</ul>
<p><strong>IntentAgent的限制</strong></p>
<p>使用IntentAgent启动Ability时，Intent必须指定Ability的包名和类名</p>
<h3 id="场景介绍-1"><a href="#场景介绍-1" class="headerlink" title="场景介绍"></a>场景介绍</h3><p>每个应用都可以订阅自己感兴趣的公共事件，订阅成功后且公共事件发布后，系统会把其发送给应用。这些公共事件可能来自系统、其他应用和应用自身。HarmonyOS提供了一套完整的API，支持用户订阅、发布和接收公共事件。发布公共事件需要借助CommonEventData对象，接收公共事件需要继承CommonEventSubscriber类并实现onReceiveEvent回调函数。</p>
<h3 id="接口说明-1"><a href="#接口说明-1" class="headerlink" title="接口说明"></a>接口说明</h3><p>公共事件相关基础类包含<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/ability-notification-fwk-common-event-0000000000029871#ZH-CN_TOPIC_0000001050988893__li14451163813234" target="_blank" rel="noopener">CommonEventData</a>、<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/ability-notification-fwk-common-event-0000000000029871#ZH-CN_TOPIC_0000001050988893__li29381475233" target="_blank" rel="noopener">CommonEventPublishInfo</a>、<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/ability-notification-fwk-common-event-0000000000029871#ZH-CN_TOPIC_0000001050988893__li1490625910238" target="_blank" rel="noopener">CommonEventSubscribeInfo</a>、<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/ability-notification-fwk-common-event-0000000000029871#ZH-CN_TOPIC_0000001050988893__li75811198246" target="_blank" rel="noopener">CommonEventSubscriber</a>和<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/ability-notification-fwk-common-event-0000000000029871#ZH-CN_TOPIC_0000001050988893__li18241142552416" target="_blank" rel="noopener">CommonEventManager</a>。基础类之间的关系如下图所示：</p>
<p><img src="/images/loading.gif" data-original="../images/harmonyos/-16273165567261910" alt=""></p>
<ul>
<li><p>CommonEventData</p>
<p>CommonEventData封装公共事件相关信息。用于在发布、分发和接收时处理数据。在构造CommonEventData对象时，相关参数需要注意以下事项：</p>
<ul>
<li>code为有序公共事件的结果码，data为有序公共事件的结果数据，仅用于<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/ability-notification-fwk-common-event-0000000000029871#ZH-CN_TOPIC_0000001050988893__li1559091484011" target="_blank" rel="noopener">有序公共事件</a>场景。</li>
</ul>
</li>
<li><p>intent不允许为空，否则发布公共事件失败。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>接口名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>CommonEventData()</td>
<td>创建公共事件数据。</td>
</tr>
<tr>
<td>CommonEventData(Intent intent)</td>
<td>创建公共事件数据指定Intent。</td>
</tr>
<tr>
<td>CommonEventData(Intent intent, int code, String data)</td>
<td>创建公共事件数据，指定Intent、code和data。</td>
</tr>
<tr>
<td>getIntent()</td>
<td>获取公共事件Intent。</td>
</tr>
<tr>
<td>setCode(int code)</td>
<td>设置有序公共事件的结果码。</td>
</tr>
<tr>
<td>getCode()</td>
<td>获取有序公共事件的结果码。</td>
</tr>
<tr>
<td>setData(String data)</td>
<td>设置有序公共事件的详细结果数据。</td>
</tr>
<tr>
<td>getData()</td>
<td>获取有序公共事件的详细结果数据。</td>
</tr>
</tbody></table>
<ul>
<li><p>CommonEventPublishInfo</p>
<p>CommonEventPublishInfo封装公共事件发布相关属性、限制等信息，包括公共事件类型（有序或粘性）、接收者权限等。</p>
<ul>
<li>有序公共事件：主要场景是多个订阅者有依赖关系或者对处理顺序有要求，例如：高优先级订阅者可修改公共事件内容或处理结果，包括终止公共事件处理；或者低优先级订阅者依赖高优先级的处理结果等。有序公共事件的订阅者可以通过<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/ability-notification-fwk-common-event-0000000000029871#ZH-CN_TOPIC_0000001050988893__li1490625910238" target="_blank" rel="noopener">CommonEventSubscribeInfo</a>.setPriority()方法指定优先级，缺省为0，优先级范围[-1000, 1000]，值越大优先级越高。</li>
</ul>
</li>
<li><p>粘性公共事件：指公共事件的订阅动作是在公共事件发布之后进行，订阅者也能收到的公共事件类型。主要场景是由公共事件服务记录某些系统状态，如蓝牙、WLAN、充电等事件和状态。不使用粘性公共事件机制时，应用可以通过直接访问系统服务获取该状态；在状态变化时，系统服务、硬件需要提供类似observer等方式通知应用。发布粘性公共事件可以通过setSticky()方法设置， 发布粘性公共事件需要申请如下权限。声明请参考<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/security-permissions-guidelines-0000000000029886#ZH-CN_TOPIC_0000001072906209__table73291742539" target="_blank" rel="noopener">权限开发指导表1 reqPermissions权限申请字段说明</a>。</p>
</li>
</ul>
<pre><code>"reqPermissions": [
  {
    "name": "ohos.permission.COMMONEVENT_STICKY",
    "reason": "Obtain the required permission",
    "usedScene": {
      "ability": [
        ".MainAbility"
      ],
      "when": "inuse"
    }
  },
  {
    ...
  }
]</code></pre><table>
<thead>
<tr>
<th>接口名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>CommonEventPublishInfo()</td>
<td>创建公共事件信息。</td>
</tr>
<tr>
<td>CommonEventPublishInfo(CommonEventPublishInfo publishInfo)</td>
<td>拷贝一个公共事件信息。</td>
</tr>
<tr>
<td>setSticky(boolean sticky）</td>
<td>设置公共事件的粘性属性。</td>
</tr>
<tr>
<td>setOrdered(boolean ordered)</td>
<td>设置公共事件的有序属性。</td>
</tr>
<tr>
<td>setSubscriberPermissions(String[] subscriberPermissions)</td>
<td>设置公共事件订阅者的权限，多参数仅第一个生效。</td>
</tr>
</tbody></table>
<ul>
<li><strong>CommonEventSubscribeInfo</strong>CommonEventSubscribeInfo封装公共事件订阅相关信息，比如优先级、线程模式、事件范围等。</li>
</ul>
<p>线程模式（ThreadMode）：设置订阅者的回调方法执行的线程模式。ThreadMode有HANDLER，POST，ASYNC，BACKGROUND四种模式，目前只支持HANDLER模式。</p>
<ul>
<li><p>HANDLER：在Ability的主线程上执行。</p>
</li>
<li><p>POST：在事件分发线程执行。</p>
</li>
<li><p>ASYNC：在一个新创建的异步线程执行。</p>
</li>
<li><p>BACKGROUND：在后台线程执行。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>接口名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>CommonEventSubscribeInfo(MatchingSkills matchingSkills)</td>
<td>创建公共事件订阅器指定matchingSkills。</td>
</tr>
<tr>
<td>CommonEventSubscribeInfo(CommonEventSubscribeInfo)</td>
<td>拷贝公共事件订阅器对象。</td>
</tr>
<tr>
<td>setPriority(int priority)</td>
<td>设置优先级，用于有序公共事件。</td>
</tr>
<tr>
<td>setThreadMode(ThreadMode threadMode)</td>
<td>指定订阅者的回调函数运行在哪个线程上。</td>
</tr>
<tr>
<td>setPermission(String permission)</td>
<td>设置发布者必须具备的权限。</td>
</tr>
<tr>
<td>setDeviceId(String deviceId)</td>
<td>指定订阅哪台设备的公共事件。</td>
</tr>
</tbody></table>
<ul>
<li><p>CommonEventSubscriber</p>
<p>CommonEventSubscriber封装公共事件订阅者及相关参数。</p>
<ul>
<li>CommonEventSubscriber.AsyncCommonEventResult类处理有序公共事件异步执行，详见API参考。</li>
</ul>
</li>
<li><p>目前只能通过调用<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/ability-notification-fwk-common-event-0000000000029871#ZH-CN_TOPIC_0000001050988893__li18241142552416" target="_blank" rel="noopener">CommonEventManager</a>的subscribeCommonEvent()进行订阅。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>接口名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>CommonEventSubscriber(CommonEventSubscribeInfo subscribeInfo)</td>
<td>构造公共事件订阅者实例。</td>
</tr>
<tr>
<td>onReceiveEvent(CommonEventData data)</td>
<td>由开发者实现, 在接收到公共事件时被调用。</td>
</tr>
<tr>
<td>AsyncCommonEventResult goAsyncCommonEvent()</td>
<td>设置有序公共事件异步执行。</td>
</tr>
<tr>
<td>setCodeAndData(int code, String data)</td>
<td>设置有序公共事件的异步结果。</td>
</tr>
<tr>
<td>setData(String data)</td>
<td>设置有序公共事件的异步结果数据。</td>
</tr>
<tr>
<td>setCode(int code)</td>
<td>设置有序公共事件的异步结果码。</td>
</tr>
<tr>
<td>getData()</td>
<td>获取有序公共事件的异步结果数据。</td>
</tr>
<tr>
<td>getCode()</td>
<td>获取有序公共事件的异步结果码。</td>
</tr>
<tr>
<td>abortCommonEvent()</td>
<td>取消当前的公共事件，仅对有序公共事件有效，取消后，公共事件不再向下一个订阅者传递。</td>
</tr>
<tr>
<td>getAbortCommonEvent()</td>
<td>获取当前有序公共事件是否取消的状态。</td>
</tr>
<tr>
<td>clearAbortCommonEvent()</td>
<td>清除当前有序公共事件abort状态。</td>
</tr>
<tr>
<td>isOrderedCommonEvent()</td>
<td>查询当前公共事件的是否为有序公共事件。</td>
</tr>
<tr>
<td>isStickyCommonEvent()</td>
<td>查询当前公共事件是否为粘性公共事件。</td>
</tr>
</tbody></table>
<ul>
<li><strong>CommonEventManager</strong>CommonEventManager是为应用提供订阅、退订和发布公共事件的静态接口类。</li>
</ul>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>publishCommonEvent(CommonEventData eventData)</td>
<td>发布公共事件。</td>
</tr>
<tr>
<td>publishCommonEvent(CommonEventData event, CommonEventPublishInfo publishInfo)</td>
<td>发布公共事件指定发布信息。</td>
</tr>
<tr>
<td>publishCommonEvent(CommonEventData event, CommonEventPublishInfo publishInfo, CommonEventSubscriber resultSubscriber)</td>
<td>发布有序公共事件，指定发布信息和最后一个接收者。</td>
</tr>
<tr>
<td>subscribeCommonEvent(CommonEventSubscriber subscriber)</td>
<td>订阅公共事件。</td>
</tr>
<tr>
<td>unsubscribeCommonEvent(CommonEventSubscriber subscriber)</td>
<td>退订公共事件。</td>
</tr>
</tbody></table>
<h3 id="发布公共事件"><a href="#发布公共事件" class="headerlink" title="发布公共事件"></a>发布公共事件</h3><p>开发者可以发布四种公共事件：无序的公共事件、带权限的公共事件、有序的公共事件、粘性的公共事件。</p>
<p><strong>发布无序的公共事件：</strong>构造CommonEventData对象，设置Intent，通过构造operation对象把需要发布的公共事件信息传入intent对象。然后调用 CommonEventManager.publishCommonEvent(CommonEventData) 接口发布公共事件。</p>
<pre><code>try {
    Intent intent = new Intent();   
    Operation operation = new Intent.OperationBuilder()
            .withAction("com.my.test")
            .build();
    intent.setOperation(operation);
    CommonEventData eventData = new CommonEventData(intent);
    CommonEventManager.publishCommonEvent(eventData); 
    HiLog.info(LABEL_LOG, "Publish succeeded"); 
} catch (RemoteException e) {
    HiLog.error(LABEL_LOG, "Exception occurred during publishCommonEvent invocation."); 
}</code></pre><p><strong>发布携带权限的公共事件：</strong>构造CommonEventPublishInfo对象，设置订阅者的权限。</p>
<ul>
<li>订阅者在config.json中申请所需的权限，各字段含义详见<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/security-permissions-guidelines-0000000000029886#ZH-CN_TOPIC_0000001072906209__table73291742539" target="_blank" rel="noopener">权限申请字段说明</a>。</li>
</ul>
<p>说明</p>
<p>非系统已定义的权限，需要先在config.json中自定义，才可以申请使用。详见<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/security-permissions-guidelines-0000000000029886#ZH-CN_TOPIC_0000001072906209__table16180174018340" target="_blank" rel="noopener">权限定义字段说明</a></p>
<pre><code>"reqPermissions": [
  {
    "name": "com.example.MyApplication.permission",
    "reason": "Obtain the required permission",
    "usedScene": {
      "ability": [
        ".MainAbility"
      ],
      "when": "inuse"
    }
  }, 
  {
    ...
  }
]</code></pre><ul>
<li>发布带权限的公共事件示例代码如下：</li>
</ul>
<pre><code>Intent intent = new Intent();
Operation operation = new Intent.OperationBuilder()
        .withAction("com.my.test")
        .build();
intent.setOperation(operation);
CommonEventData eventData = new CommonEventData(intent);
CommonEventPublishInfo publishInfo = new CommonEventPublishInfo();
String[] permissions = {"com.example.MyApplication.permission"};
publishInfo.setSubscriberPermissions(permissions); // 设置权限
try {   
    CommonEventManager.publishCommonEvent(eventData, publishInfo); 
    HiLog.info(LABEL_LOG, "Publish succeeded"); 
} catch (RemoteException e) {
    HiLog.error(LABEL_LOG, "Exception occurred during publishCommonEvent invocation."); 
}</code></pre><p><strong>发布有序的公共事件：</strong>构造CommonEventPublishInfo对象，通过setOrdered(true)指定公共事件属性为有序公共事件，也可以指定一个最后的公共事件接收者。</p>
<pre><code>CommonEventSubscriber resultSubscriber = new MyCommonEventSubscriber();
CommonEventPublishInfo publishInfo = new CommonEventPublishInfo();
publishInfo.setOrdered(true); // 设置属性为有序公共事件
try {   
    CommonEventManager.publishCommonEvent(eventData, publishInfo, resultSubscriber); // 指定resultSubscriber为有序公共事件最后一个接收者。
} catch (RemoteException e) {
    HiLog.error(LABEL_LOG, "Exception occurred during publishCommonEvent invocation."); 
}
发布粘性公共事件：构造CommonEventPublishInfo对象，通过setSticky(true)指定公共事件属性为粘性公共事件。</code></pre><ol>
<li>发布者首先在config.json中申请发布粘性公共事件所需的权限，各字段含义详见<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/security-permissions-guidelines-0000000000029886#ZH-CN_TOPIC_0000001072906209__table73291742539" target="_blank" rel="noopener">权限申请字段说明</a>。</li>
</ol>
<pre><code>{
    "reqPermissions": [{
        "name": "ohos.permission.COMMONEVENT_STICKY",
        "reason": "Obtain the required permission",
        "usedScene": {
           "ability": [
            ".MainAbility"
           ],
           "when": "inuse"
        }
    }, {
    ...
    }]
}</code></pre><ol>
<li>发布粘性公共事件。</li>
</ol>
<pre><code>CommonEventPublishInfo publishInfo = new CommonEventPublishInfo();
publishInfo.setSticky(true); // 设置属性为粘性公共事件
try {   
    CommonEventManager.publishCommonEvent(eventData, publishInfo); 
} catch (RemoteException e) {
    HiLog.error(LABEL, "Exception occurred during publishCommonEvent invocation."); 
}</code></pre><h3 id="订阅公共事件"><a href="#订阅公共事件" class="headerlink" title="订阅公共事件"></a>订阅公共事件</h3><ol>
<li>创建CommonEventSubscriber派生类，在onReceiveEvent()回调函数中处理公共事件。</li>
</ol>
<p>说明</p>
<p>此处不能执行耗时操作，否则会阻塞UI线程，产生用户点击没有反应等异常。</p>
<pre><code>class MyCommonEventSubscriber extends CommonEventSubscriber { 
    MyCommonEventSubscriber(CommonEventSubscribeInfo info) { 
        super(info);   
    }
    @Override 
    public void onReceiveEvent(CommonEventData commonEventData) {
    } 
}</code></pre><ol>
<li>构造MyCommonEventSubscriber对象，调用CommonEventManager.subscribeCommonEvent()接口进行订阅。</li>
</ol>
<pre><code>String event = "com.my.test";
MatchingSkills matchingSkills = new MatchingSkills();
matchingSkills.addEvent(event); // 自定义事件
matchingSkills.addEvent(CommonEventSupport.COMMON_EVENT_SCREEN_ON); // 亮屏事件
CommonEventSubscribeInfo subscribeInfo = new CommonEventSubscribeInfo(matchingSkills);
MyCommonEventSubscriber subscriber = new MyCommonEventSubscriber(subscribeInfo);
try {
    CommonEventManager.subscribeCommonEvent(subscriber); 
} catch (RemoteException e) {
    HiLog.error(LABEL, "Exception occurred during subscribeCommonEvent invocation."); 
}</code></pre><p>如果订阅拥有指定权限应用发布的公共事件，发布者需要在config.json中申请权限，各字段含义详见<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/security-permissions-guidelines-0000000000029886#ZH-CN_TOPIC_0000001072906209__table73291742539" target="_blank" rel="noopener">权限申请字段说明</a>。</p>
<pre><code>"reqPermissions": [
    {
        "name": "ohos.abilitydemo.permission.PROVIDER",
        "reason": "Obtain the required permission",
        "usedScene": {
            "ability": ["com.hmi.ivi.systemsetting.MainAbility"],
            "when": "inuse"
        }
    }
]</code></pre><p>如果订阅的公共事件是有序的，可以调用setPriority(）指定优先级。</p>
<pre><code>String event = "com.my.test";
MatchingSkills matchingSkills = new MatchingSkills();
matchingSkills.addEvent(event); // 自定义事件

CommonEventSubscribeInfo subscribeInfo = new CommonEventSubscribeInfo(matchingSkills);
subscribeInfo.setPriority(100); // 设置优先级，优先级取值范围[-1000，1000]，值默认为0。
MyCommonEventSubscriber subscriber = new MyCommonEventSubscriber(subscribeInfo);
try {
     CommonEventManager.subscribeCommonEvent(subscriber); 
} catch (RemoteException e) {
     HiLog.error(LABEL, "Exception occurred during subscribeCommonEvent invocation."); 
}</code></pre><ol>
<li>针对在onReceiveEvent中不能执行耗时操作的限制，可以使用CommonEventSubscriber的goAsyncCommonEvent()来实现异步操作，函数返回后仍保持该公共事件活跃，且执行完成后必须调用AsyncCommonEventResult .finishCommonEvent()来结束。</li>
</ol>
<pre><code>EventRunner runner = EventRunner.create(); // EventRunner创建新线程，将耗时的操作放到新的线程上执行
MyEventHandler myHandler = new MyEventHandler(runner); // MyEventHandler为EventHandler的派生类，在不同线程间分发和处理事件和Runnable任务
@Override
public void onReceiveEvent(CommonEventData commonEventData){
    final AsyncCommonEventResult result = goAsyncCommonEvent();

    Runnable task = new Runnable() {
        @Override
        public void run() {
            ........         // 待执行的操作，由开发者定义
            result.finishCommonEvent(); // 调用finish结束异步操作
        }
    };
    myHandler.postTask(task);
} </code></pre><h3 id="退订公共事件"><a href="#退订公共事件" class="headerlink" title="退订公共事件"></a>退订公共事件</h3><p>在Ability的onStop()中调用CommonEventManager.unsubscribeCommonEvent()方法来退订公共事件。调用后，之前订阅的所有公共事件均被退订。</p>
<pre><code>try { 
    CommonEventManager.unsubscribeCommonEvent(subscriber);
 } catch (RemoteException e) {
    HiLog.error(LABEL, "Exception occurred during unsubscribeCommonEvent invocation.");
 }</code></pre><h3 id="相关实例-5"><a href="#相关实例-5" class="headerlink" title="相关实例"></a>相关实例</h3><p>针对公共事件开发，有以下示例工程可供参考：</p>
<ul>
<li><a href="https://gitee.com/openharmony/app_samples/tree/master/ability/CommonEvent" target="_blank" rel="noopener">CommonEvent</a>本示例演示了公共事件的订阅、发布和退订。</li>
</ul>
<p>针对公共事件，有以下Codelabs可供参考：</p>
<ul>
<li><p><a href="https://developer.huawei.com/consumer/cn/codelabsPortal/carddetails/HarmonyOS-EducationSystem" target="_blank" rel="noopener">分布式亲子早教系统</a>基于分布式能力，实现一个多屏互动、跨设备协同的亲子早教系统。</p>
</li>
<li><p><a href="https://developer.huawei.com/consumer/cn/codelabsPortal/carddetails/HarmonyOS-DistributedInput" target="_blank" rel="noopener">分布式输入法</a>基于分布式能力，将手机作为智慧屏的虚拟控制器，控制文字输入和遥控播放</p>
</li>
</ul>
<h2 id="通知开发指导"><a href="#通知开发指导" class="headerlink" title="通知开发指导"></a>通知开发指导</h2><h3 id="场景介绍-2"><a href="#场景介绍-2" class="headerlink" title="场景介绍"></a>场景介绍</h3><p>HarmonyOS提供了通知功能，即在一个应用的UI界面之外显示的消息，主要用来提醒用户有来自该应用中的信息。当应用向系统发出通知时，它将先以图标的形式显示在通知栏中，用户可以下拉通知栏查看通知的详细信息。常见的使用场景：</p>
<ul>
<li><p>显示接收到短消息、即时消息等。</p>
</li>
<li><p>显示应用的推送消息，如广告、版本更新等。</p>
</li>
<li><p>显示当前正在进行的事件，如播放音乐、导航、下载等。</p>
</li>
</ul>
<h3 id="接口说明-2"><a href="#接口说明-2" class="headerlink" title="接口说明"></a>接口说明</h3><p>通知相关基础类包含<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/ability-notification-fwk-notification-0000000000038804#ZH-CN_TOPIC_0000001050988895__li1552717269392" target="_blank" rel="noopener">NotificationSlot</a>、<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/ability-notification-fwk-notification-0000000000038804#ZH-CN_TOPIC_0000001050988895__li10626853134015" target="_blank" rel="noopener">NotificationRequest</a>和<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/ability-notification-fwk-notification-0000000000038804#ZH-CN_TOPIC_0000001050988895__li8128174954415" target="_blank" rel="noopener">NotificationHelper</a>。基础类之间的关系如下所示：</p>
<p><img src="/images/loading.gif" data-original="../images/harmonyos/-16273165641421912" alt=""></p>
<ul>
<li><strong>NotificationSlot</strong>NotificationSlot可以对提示音、振动、锁屏显示和重要级别等进行设置。一个应用可以创建一个或多个NotificationSlot，在发布通知时，通过绑定不同的NotificationSlot，实现不同用途。</li>
</ul>
<p>说明</p>
<p>NotificationSlot需要先通过NotificationHelper的addNotificationSlot(NotificationSlot)方法发布后，通知才能绑定使用；所有绑定该NotificationSlot的通知在发布后都具备相应的特性，对象在创建后，将无法更改这些设置，对于是否启动相应设置，用户有最终控制权。</p>
<p>不指定NotificationSlot时，当前通知会使用默认的NotificationSlot，默认的NotificationSlot优先级为LEVEL_DEFAULT。</p>
<table>
<thead>
<tr>
<th>接口名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>NotificationSlot(String id, String name, int level)</td>
<td>构造NotificationSlot。</td>
</tr>
<tr>
<td>setLevel(int level)</td>
<td>设置NotificationSlot的级别。</td>
</tr>
<tr>
<td>setName(String name)</td>
<td>设置NotificationSlot的命名。</td>
</tr>
<tr>
<td>setDescription(String description)</td>
<td>设置NotificationSlot的描述信息。</td>
</tr>
<tr>
<td>enableBypassDnd(boolean bypassDnd)</td>
<td>设置是否绕过系统的免打扰模式。</td>
</tr>
<tr>
<td>setEnableVibration(boolean vibration)</td>
<td>设置收到通知时是否使能振动。</td>
</tr>
<tr>
<td>setLockscreenVisibleness(int visibleness)</td>
<td>设置在锁屏场景下，收到通知后是否显示，以及显示的效果。</td>
</tr>
<tr>
<td>setEnableLight(boolean isLightEnabled)</td>
<td>设置收到通知时是否开启呼吸灯，前提是当前硬件支持呼吸灯。</td>
</tr>
<tr>
<td>setLedLightColor(int color)</td>
<td>设置收到通知时的呼吸灯颜色。</td>
</tr>
<tr>
<td>setSlotGroup(String groupId)</td>
<td>绑定当前NotificationSlot到一个NotificationSlot组。</td>
</tr>
</tbody></table>
<p>NotificationSlot的级别目前支持如下几种， 由低到高：</p>
<ul>
<li><p>LEVEL_NONE： 表示通知不发布。</p>
</li>
<li><p>LEVEL_MIN：表示通知可以发布，但是不显示在通知栏，不自动弹出，无提示音；该级别不适用于前台服务的场景。</p>
</li>
<li><p>LEVEL_LOW：表示通知可以发布且显示在通知栏，不自动弹出，无提示音。</p>
</li>
<li><p>LEVEL_DEFAULT：表示通知发布后可在通知栏显示，不自动弹出，触发提示音。</p>
</li>
<li><p>LEVEL_HIGH：表示通知发布后可在通知栏显示，自动弹出，触发提示音。</p>
</li>
<li><p><strong>NotificationRequest</strong>NotificationRequest用于设置具体的通知对象，包括设置通知的属性，如：通知的分发时间、小图标、大图标、自动删除等参数，以及设置具体的通知类型，如普通文本、长文本等。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>接口名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>NotificationRequest()</td>
<td>构建一个通知。</td>
</tr>
<tr>
<td>NotificationRequest(int notificationId)</td>
<td>构建一个通知，指定通知的id。通知的Id在应用内容具有唯一性，如果不指定，默认为0。</td>
</tr>
<tr>
<td>setNotificationId(int notificationId)</td>
<td>设置当前通知id。</td>
</tr>
<tr>
<td>setAutoDeletedTime(long time)</td>
<td>设置通知自动取消的时间戳。</td>
</tr>
<tr>
<td>setContent(NotificationRequest.NotificationContent content)</td>
<td>设置通知的具体类型。</td>
</tr>
<tr>
<td>setDeliveryTime(long deliveryTime)</td>
<td>设置通知分发的时间戳。</td>
</tr>
<tr>
<td>setSlotId(String slotId)</td>
<td>设置通知的NotificationSlot id。</td>
</tr>
<tr>
<td>setTapDismissed(boolean tapDismissed)</td>
<td>设置通知在用户点击后是否自动取消。</td>
</tr>
<tr>
<td>setLittleIcon(PixelMap smallIcon)</td>
<td>设置通知的小图标，在通知左上角显示。</td>
</tr>
<tr>
<td>setBigIcon(PixelMap bigIcon)</td>
<td>设置通知的大图标，在通知的右边显示。</td>
</tr>
<tr>
<td>setGroupValue(String groupValue)</td>
<td>设置分组通知，相同分组的通知在通知栏显示时，将会折叠在一组应用中显示。</td>
</tr>
<tr>
<td>addActionButton(NotificationActionButton actionButton)</td>
<td>设置通知添加通知ActionButton。</td>
</tr>
<tr>
<td>setIntentAgent(IntentAgent agent)</td>
<td>设置通知承载指定的IntentAgent，在通知中实现即将触发的事件。</td>
</tr>
</tbody></table>
<p><strong>具体的通知类型：</strong>目前支持六种类型，包括普通文本NotificationNormalContent、长文本NotificationLongTextContent、图片NotificationPictureContent、多行NotificationMultiLineContent、社交NotificationConversationalContent、媒体NotificationMediaContent。</p>
<table>
<thead>
<tr>
<th>类名</th>
<th>接口名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>NotificationNormalContent</td>
<td>setTitle(String title)</td>
<td>设置通知标题。</td>
</tr>
<tr>
<td>NotificationNormalContent</td>
<td>setText(String text)</td>
<td>设置通知内容。</td>
</tr>
<tr>
<td>NotificationNormalContent</td>
<td>setAdditionalText(String additionalText)</td>
<td>设置通知次要内容，是对通知内容的补充。</td>
</tr>
<tr>
<td>NotificationPictureContent</td>
<td>setBriefText(String briefText)</td>
<td>设置通知概要内容，是对通知内容的总结。</td>
</tr>
<tr>
<td>NotificationPictureContent</td>
<td>setExpandedTitle(String expandedTitle)</td>
<td>设置附加图片的通知展开时的标题。</td>
</tr>
<tr>
<td>NotificationPictureContent</td>
<td>setBigPicture(PixelMap bigPicture)</td>
<td>设置通知的图片内容，附加在setText(String text)下方。</td>
</tr>
<tr>
<td>NotificationLongTextContent</td>
<td>setLongText(String longText)</td>
<td>设置通知的长文本。</td>
</tr>
<tr>
<td>NotificationConversationalContent</td>
<td>setConversationTitle(String conversationTitle)</td>
<td>设置社交通知的标题。</td>
</tr>
<tr>
<td>NotificationConversationalContent</td>
<td>addConversationalMessage(ConversationalMessage message)</td>
<td>通知添加一条消息。</td>
</tr>
<tr>
<td>NotificationMultiLineContent</td>
<td>addSingleLine(String line)</td>
<td>在当前通知中添加一行文本。</td>
</tr>
<tr>
<td>NotificationMediaContent</td>
<td>setAVToken(AVToken avToken)</td>
<td>将媒体通知绑定指定的AVToken。</td>
</tr>
<tr>
<td>NotificationMediaContent</td>
<td>setShownActions(int[] actions)</td>
<td>设置媒体通知待展示的按钮。</td>
</tr>
</tbody></table>
<p>说明</p>
<p>通知发布后，通知的设置不可修改。如果下次发布通知使用相同的id，就会更新之前发布的通知。</p>
<ul>
<li><strong>NotificationHelper</strong>NotificationHelper封装了发布、更新、删除通知等静态方法。</li>
</ul>
<table>
<thead>
<tr>
<th>接口名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>publishNotification(NotificationRequest request)</td>
<td>发布一条通知。</td>
</tr>
<tr>
<td>publishNotification(String tag, NotificationRequest request)</td>
<td>发布一条带TAG的通知。</td>
</tr>
<tr>
<td>cancelNotification(int notificationId)</td>
<td>取消指定的通知。</td>
</tr>
<tr>
<td>cancelNotification(String tag, int notificationId)</td>
<td>取消指定的带TAG的通知。</td>
</tr>
<tr>
<td>cancelAllNotifications()</td>
<td>取消之前发布的所有通知。</td>
</tr>
<tr>
<td>addNotificationSlot(NotificationSlot slot)</td>
<td>创建一个NotificationSlot。</td>
</tr>
<tr>
<td>getNotificationSlot(String slotId)</td>
<td>获取NotificationSlot。</td>
</tr>
<tr>
<td>removeNotificationSlot(String slotId)</td>
<td>删除一个NotificationSlot。</td>
</tr>
<tr>
<td>getActiveNotifications()</td>
<td>获取当前应用发的活跃通知。</td>
</tr>
<tr>
<td>getActiveNotificationNums()</td>
<td>获取系统中当前应用发的活跃通知的数量。</td>
</tr>
<tr>
<td>setNotificationBadgeNum(int num)</td>
<td>设置通知的角标。</td>
</tr>
<tr>
<td>setNotificationBadgeNum()</td>
<td>设置当前应用中活跃状态通知的数量在角标显示。</td>
</tr>
</tbody></table>
<h3 id="开发步骤-1"><a href="#开发步骤-1" class="headerlink" title="开发步骤"></a>开发步骤</h3><p>通知的开发指导分为创建NotificationSlot、发布通知和取消通知等开发场景。</p>
<p><strong>创建NotificationSlot</strong></p>
<p>NotificationSlot可以设置公共通知的震动，锁屏模式，重要级别等，并通过调用NotificationHelper.addNotificationSlot()发布NotificationSlot对象。</p>
<pre><code>NotificationSlot slot = new NotificationSlot("slot_001", "slot_default", NotificationSlot.LEVEL_MIN); // 创建notificationSlot对象
slot.setDescription("NotificationSlotDescription");
slot.setEnableVibration(true); // 设置振动提醒
slot.setLockscreenVisibleness(NotificationRequest.VISIBLENESS_TYPE_PUBLIC);// 设置锁屏模式
slot.setEnableLight(true); // 设置开启呼吸灯提醒
slot.setLedLightColor(Color.RED.getValue());// 设置呼吸灯的提醒颜色
try {
   NotificationHelper.addNotificationSlot(slot);
} catch (RemoteException ex) {
   HiLog.error(LABEL, "Exception occurred during addNotificationSlot invocation.");
}</code></pre><p><strong>发布通知</strong></p>
<ol>
<li>构建NotificationRequest对象，应用发布通知前，通过NotificationRequest的setSlotId()方法与NotificationSlot绑定，使该通知在发布后都具备该对象的特征。</li>
</ol>
<pre><code>int notificationId = 1;
NotificationRequest request = new NotificationRequest(notificationId);
request.setSlotId(slot.getId());</code></pre><ol>
<li>调用setContent()设置通知的内容。</li>
</ol>
<pre><code>String title = "title";
String text = "There is a normal notification content.";
NotificationNormalContent content = new NotificationNormalContent();
content.setTitle(title)
       .setText(text);
NotificationRequest.NotificationContent notificationContent = new NotificationRequest.NotificationContent(content);
request.setContent(notificationContent); // 设置通知的内容</code></pre><ol>
<li>调用publishNotification()发布通知。</li>
</ol>
<pre><code>try {
   NotificationHelper.publishNotification(request);
} catch (RemoteException ex) {
   HiLog.error(LABEL, "Exception occurred during publishNotification invocation.");
}</code></pre><p><strong>取消通知</strong></p>
<p>取消通知分为取消指定单条通知和取消所有通知，应用只能取消自己发布的通知。</p>
<ul>
<li>调用cancelNotification()取消指定的单条通知。</li>
</ul>
<pre><code>int notificationId = 1;
try {
    NotificationHelper.cancelNotification(notificationId);
} catch (RemoteException ex) {
    HiLog.error(LABEL, "Exception occurred during cancelNotification invocation.");
}</code></pre><ul>
<li>调用cancelAllNotifications()取消所有通知。</li>
</ul>
<pre><code>try {
    NotificationHelper.cancelAllNotifications();
} catch (RemoteException ex) {
    HiLog.error(LABEL, "Exception occurred during cancelAllNotifications invocation.");
}</code></pre><h3 id="相关实例-6"><a href="#相关实例-6" class="headerlink" title="相关实例"></a>相关实例</h3><p>针对通知开发，有以下示例工程可供参考：</p>
<ul>
<li><a href="https://gitee.com/openharmony/app_samples/tree/master/ability/Notification" target="_blank" rel="noopener">Notification</a>通知功能，即在一个应用的UI界面之外显示的消息，主要用来提醒用户有来自该应用中的信息。本示例演示了如何发布通知和取消通知</li>
</ul>
<h2 id="IntentAgent开发指导"><a href="#IntentAgent开发指导" class="headerlink" title="IntentAgent开发指导"></a>IntentAgent开发指导</h2><h3 id="场景介绍-3"><a href="#场景介绍-3" class="headerlink" title="场景介绍"></a>场景介绍</h3><p>IntentAgent封装了一个指定行为的<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/ability-intent-0000000000038799" target="_blank" rel="noopener">Intent</a>，可以通过triggerIntentAgent接口主动触发，也可以与通知绑定被动触发。具体的行为包括：启动Ability和发布公共事件。例如：收到通知后，在点击通知后跳转到一个新的Ability，不点击则不会触发。</p>
<h3 id="接口说明-3"><a href="#接口说明-3" class="headerlink" title="接口说明"></a>接口说明</h3><p>IntentAgent相关基础类包括<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/ability-notification-fwk-intentagent-0000001050764907#ZH-CN_TOPIC_0000001050764907__li1179174919115" target="_blank" rel="noopener">IntentAgentHelper</a>、<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/ability-notification-fwk-intentagent-0000001050764907#ZH-CN_TOPIC_0000001050764907__li1717915251523" target="_blank" rel="noopener">IntentAgentInfo</a>、<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/ability-notification-fwk-intentagent-0000001050764907#ZH-CN_TOPIC_0000001050764907__li48031552527" target="_blank" rel="noopener">IntentAgentConstant</a>和<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/ability-notification-fwk-intentagent-0000001050764907#ZH-CN_TOPIC_0000001050764907__li1637513341734" target="_blank" rel="noopener">TriggerInfo</a>，基础类之间的关系如下图所示：</p>
<p><img src="/images/loading.gif" data-original="../images/harmonyos/-16273165698611914" alt=""></p>
<ul>
<li><strong>IntentAgentHelper</strong>IntentAgentHelper封装了获取、激发、取消IntentAgent等静态方法。</li>
</ul>
<table>
<thead>
<tr>
<th>接口名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>getIntentAgent(Context context, IntentAgentInfo paramsInfo)</td>
<td>获取一个IntentAgent实例。</td>
</tr>
<tr>
<td>triggerIntentAgent(Context context, IntentAgent agent, IntentAgent.Oncompleted onCompleted, EventHandler handler, TriggerInfo paramsInfo)</td>
<td>主动激发一个IntentAgent实例。</td>
</tr>
<tr>
<td>cancel(IntentAgent agent)</td>
<td>取消一个IntentAgent实例。</td>
</tr>
<tr>
<td>judgeEquality(IntentAgent agent, IntentAgent otherAgent)</td>
<td>判断两个IntentAgent实例是否相等。</td>
</tr>
<tr>
<td>getHashCode(IntentAgent agent)</td>
<td>获取一个IntentAgent实例的哈希码。</td>
</tr>
<tr>
<td>getBundleName(IntentAgent agent)</td>
<td>获取一个IntentAgent实例的包名。</td>
</tr>
<tr>
<td>getUid(IntentAgent agent)</td>
<td>获取一个IntentAgent实例的用户ID。</td>
</tr>
</tbody></table>
<ul>
<li><p>IntentAgentInfo</p>
<p>IntentAgentInfo类封装了获取一个IntentAgent实例所需的数据。使用构造函数IntentAgentInfo(int requestCode, OperationType operationType, List<flags> flags, List<intent> intents, IntentParams extraInfo)获取IntentAgentInfo对象。</intent></flags></p>
<ul>
<li>requestCode：使用者定义的一个私有值。</li>
</ul>
</li>
<li><p>operationType：为IntentAgentConstant.OperationType枚举中的值。</p>
</li>
<li><p>flags：为IntentAgentConstant.Flags枚举中的值。</p>
</li>
<li><p>intents：将被执行的意图列表。operationType的值为START_ABILITY，START_SERVICE和SEND_COMMON_EVENT时，intents列表只允许包含一个Intent；operationType的值为START_ABILITIES时，intents列表允许包含多个Intent</p>
</li>
<li><p>extraInfo：表明如何启动一个有页面的ability，可以为null，只在operationType的值为START_ABILITY和START_ABILITIES时有意义。</p>
</li>
<li><p><strong>IntentAgentConstant</strong>IntentAgentConstant类中包含OperationType和Flags两个枚举类：</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>类名</th>
<th>枚举值</th>
</tr>
</thead>
<tbody><tr>
<td>IntentAgentConstant.OperationType</td>
<td>UNKNOWN_TYPE：不识别的类型。START_ABILITY：开启一个有页面的Ability。START_ABILITIES：开启多个有页面的Ability。START_SERVICE：开启一个无页面的ability。SEND_COMMON_EVENT：发送一个公共事件。</td>
</tr>
<tr>
<td>IntentAgentConstant.Flags</td>
<td>ONE_TIME_FLAG：IntentAgent仅能使用一次。只在operationType的值为START_ABILITY，START_SERVICE和SEND_COMMON_EVENT时有意义。NO_BUILD_FLAG：如果描述IntentAgent对象不存在，则不创建它，直接返回null。只在operationType的值为START_ABILITY，START_SERVICE和SEND_COMMON_EVENT时有意义。CANCEL_PRESENT_FLAG：在生成一个新的IntentAgent对象前取消已存在的一个IntentAgent对象。只在operationType的值为START_ABILITY，START_SERVICE和SEND_COMMON_EVENT时有意义。UPDATE_PRESENT_FLAG：使用新的IntentAgent的额外数据替换已存在的IntentAgent中的额外数据。只在operationType的值为START_ABILITY，START_SERVICE和SEND_COMMON_EVENT时有意义。CONSTANT_FLAG：IntentAgent是不可变的。REPLACE_ELEMENT：当前Intent中的element属性可被IntentAgentHelper.triggerIntentAgent()中Intent的element属性取代。REPLACE_ACTION: 当前Intent中的action属性可被IntentAgentHelper.triggerIntentAgent()中Intent的action属性取代。REPLACE_URI：当前Intent中的uri属性可被IntentAgentHelper.triggerIntentAgent()中Intent的uri属性取代。REPLACE_ENTITIES：当前Intent中的entities属性可被IntentAgentHelper.triggerIntentAgent()中Intent的entities属性取代。REPLACE_BUNDLE：当前Intent中的bundleName属性可被IntentAgentHelper.triggerIntentAgent()中Intent的bundleName属性取代。</td>
</tr>
</tbody></table>
<ul>
<li><p>TriggerInfo</p>
<p>TriggerInfo类封装了主动激发一个IntentAgent实例所需的数据，使用构造函数TriggerInfo(String permission, IntentParams extraInfo, Intent intent, int code)获取TriggerInfo对象。</p>
<ul>
<li>permission：IntentAgent的接收者的权限名称，只在operationType的值为SEND_COMMON_EVENT时，该参数才有意义。</li>
</ul>
</li>
<li><p>extraInfo：激发IntentAgent时用户自定义的额外数据。</p>
</li>
<li><p>intent：额外的Intent。如果IntentAgentInfo成员变量flags包含CONSTANT_FLAG，则忽略该参数；如果flags包含REPLACE_ELEMENT，REPLACE_ACTION，REPLACE_URI，REPLACE_ENTITIES或REPLACE_BUNDLE，则使用额外Intent的element，action，uri，entities或bundleName属性替换原始Intent中对应的属性。如果intent是空，则不替换原始Intent的属性。</p>
</li>
<li><p>code：提供给IntentAgent目标的结果码。</p>
</li>
</ul>
<h3 id="开发步骤-2"><a href="#开发步骤-2" class="headerlink" title="开发步骤"></a>开发步骤</h3><p>获取IntentAgent的代码示例如下：</p>
<pre><code>// 指定要启动的Ability的BundleName和AbilityName字段
// 将Operation对象设置到Intent中
Operation operation = new Intent.OperationBuilder()
        .withDeviceId("")
        .withBundleName("com.testintentagent")
        .withAbilityName("com.testintentagent.entry.IntentAgentAbility")
        .build();
intent.setOperation(operation);
List&lt;Intent&gt; intentList = new ArrayList&lt;&gt;();
intentList.add(intent);
// 定义请求码
int requestCode = 200;
// 设置flags
List&lt;IntentAgentConstant.Flags&gt; flags = new ArrayList&lt;&gt;();
flags.add(IntentAgentConstant.Flags.UPDATE_PRESENT_FLAG);
// 指定启动一个有页面的Ability
IntentAgentInfo paramsInfo = new IntentAgentInfo(requestCode, IntentAgentConstant.OperationType.START_ABILITY, flags, intentList, null);
// 获取IntentAgent实例
IntentAgent agent = IntentAgentHelper.getIntentAgent(this, paramsInfo);
通知中添加IntentAgent的代码示例如下:
int notificationId = 1;
NotificationRequest request = new NotificationRequest(notificationId);
String title = "title";
String text = "There is a normal notification content.";
NotificationRequest.NotificationNormalContent content = new NotificationRequest.NotificationNormalContent();
content.setTitle(title)
       .setText(text);
NotificationContent notificationContent = new NotificationContent(content);
request.setContent(notificationContent); // 设置通知的内容
request.setIntentAgent(agent); // 设置通知的IntentAgent
主动激发IntentAgent的代码示例如下：
int code = 100;
IntentAgentHelper.triggerIntentAgent(this, agent, null, null, new TriggerInfo(null, null, null, code));</code></pre><h3 id="相关实例-7"><a href="#相关实例-7" class="headerlink" title="相关实例"></a>相关实例</h3><p>针对IntentAgent开发指导，有以下示例工程可供参考：</p>
<ul>
<li><a href="https://gitee.com/openharmony/app_samples/tree/master/ability/IntentAgent" target="_blank" rel="noopener">IntentAgent</a>本示例演示了如何通过IntentAgent启动Ability和发布公共事件。</li>
</ul>
<h2 id="服务卡片"><a href="#服务卡片" class="headerlink" title="服务卡片"></a>服务卡片</h2><p>服务卡片（以下简称“卡片”）是<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/glossary-0000000000029587#ZH-CN_TOPIC_0000001050749051__section5406185415236" target="_blank" rel="noopener">FA</a>的一种界面展示形式，将FA的重要信息或操作前置到卡片，以达到服务直达，减少体验层级目的。</p>
<p>卡片常用于嵌入到其他应用（当前只支持系统应用）中作为其界面的一部分显示，并支持拉起页面，发送消息等基础的交互功能。卡片使用方负责显示卡片。</p>
<p>示例如下图所示。</p>
<p><img src="/images/loading.gif" data-original="../images/harmonyos/-16273165751801916" alt=""></p>
<h4 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h4><ul>
<li><p><strong>卡片使用方</strong>显示卡片内容的宿主应用，控制卡片在宿主中展示的位置。</p>
</li>
<li><p><strong>卡片管理服务</strong>用于管理系统中所添加卡片的常驻代理服务，包括卡片对象的管理与使用，以及卡片周期性刷新等。</p>
</li>
<li><p><strong>卡片提供方</strong>提供卡片显示内容的HarmonyOS应用或原子化服务，控制卡片的显示内容、控件布局以及控件点击事件。</p>
</li>
</ul>
<p>说明</p>
<p>卡片使用方和提供方不要求常驻运行，在需要添加/删除/请求更新卡片时，卡片管理服务会拉起卡片提供方获取卡片信息。</p>
<h4 id="运作机制"><a href="#运作机制" class="headerlink" title="运作机制"></a>运作机制</h4><p><img src="/images/loading.gif" data-original="../images/harmonyos/-16273165783661918" alt=""></p>
<p><strong>卡片管理服务包含以下模块：</strong></p>
<ul>
<li><p>周期性刷新：在卡片添加后，根据卡片的刷新策略启动定时任务周期性触发卡片的刷新。</p>
</li>
<li><p>卡片缓存管理：在卡片添加到卡片管理服务后，对卡片的视图信息进行缓存，以便下次获取卡片时可以直接返回缓存数据，降低时延。</p>
</li>
<li><p>卡片生命周期管理：对于卡片切换到后台或者被遮挡时，暂停卡片的刷新；以及卡片的升级/卸载场景下对卡片数据的更新和清理。</p>
</li>
<li><p>卡片使用方对象管理：对卡片使用方的RPC对象进行管理，用于使用方请求进行校验以及对卡片更新后的回调处理。</p>
</li>
<li><p>通信适配层：负责与卡片使用方和提供方进行RPC通信。</p>
</li>
</ul>
<p><strong>卡片提供方包含以下模块：</strong></p>
<ul>
<li><p>卡片服务：由卡片提供方开发者实现，开发者实现onCreateForm、onUpdateForm和onDeleteForm处理创建卡片、更新卡片以及删除卡片等请求，提供相应的卡片服务。</p>
</li>
<li><p>卡片提供方实例管理模块：由卡片提供方开发者实现，负责对卡片管理服务分配的卡片实例进行持久化管理。</p>
</li>
<li><p>通信适配层：由HarmonyOS SDK提供，负责与卡片管理服务通信，用于将卡片的更新数据主动推送到卡片管理服务</p>
</li>
</ul>
<h4 id="场景介绍-4"><a href="#场景介绍-4" class="headerlink" title="场景介绍"></a>场景介绍</h4><p>卡片提供方控制卡片实际显示的内容、控件布局以及控件点击事件。开发者可以通过集成以下接口来提供卡片服务。</p>
<h4 id="接口说明-4"><a href="#接口说明-4" class="headerlink" title="接口说明"></a>接口说明</h4><p>HarmonyOS中的服务卡片为卡片提供方开发者提供以下接口能力。</p>
<table>
<thead>
<tr>
<th>类名</th>
<th>接口名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Ability</td>
<td>ProviderFormInfo onCreateForm(Intent intent)</td>
<td>卡片提供方接收创建卡片通知接口。</td>
</tr>
<tr>
<td>void onUpdateForm(long formId)</td>
<td>卡片提供方接收更新卡片通知接口。</td>
<td></td>
</tr>
<tr>
<td>void onDeleteForm(long formId)</td>
<td>卡片提供方接收删除卡片通知接口。</td>
<td></td>
</tr>
<tr>
<td>void onTriggerFormEvent(long formId, String message)</td>
<td>卡片提供方处理卡片事件接口（JS卡片使用）。</td>
<td></td>
</tr>
<tr>
<td>boolean updateForm(long formId, ComponentProvider component)</td>
<td>卡片提供方主动更新卡片（Java卡片使用）。</td>
<td></td>
</tr>
<tr>
<td>boolean updateForm(long formId, FormBindingData formBindingData)</td>
<td>卡片提供方主动更新卡片（JS卡片使用），仅更新formBindingData中携带的信息，卡片中其余信息保持不变。</td>
<td></td>
</tr>
<tr>
<td>void onCastTempForm(long formId)</td>
<td>卡片提供方接收临时卡片转常态卡片通知。</td>
<td></td>
</tr>
<tr>
<td>void onEventNotify(Map&lt;Long, Integer&gt; formEvents)</td>
<td>卡片提供方接收到事件通知，其中Ability.FORM_VISIBLE表示卡片可见通知，Ability.FORM_INVISIBLE表示卡片不可见通知。</td>
<td></td>
</tr>
<tr>
<td>ProviderFormInfo</td>
<td>ProviderFormInfo(int resId, Context context)</td>
<td>Java卡片返回对象构造函数。</td>
</tr>
<tr>
<td>ProviderFormInfo()</td>
<td>JS卡片返回对象构造函数。</td>
<td></td>
</tr>
<tr>
<td>void mergeActions(ComponentProvider componentProviderActions)</td>
<td>在提供方侧调用该接口，将开发者在ComponentProvider中设置的actions配置数据合并到当前对象中。</td>
<td></td>
</tr>
<tr>
<td>void setJsBindingData(FormBindingData data)</td>
<td>设置JS卡片的内容信息(JS卡片使用)。</td>
<td></td>
</tr>
</tbody></table>
<p>其中，onEventNotify仅系统应用才会回调，其他接口回调时机如下图：</p>
<p><img src="/images/loading.gif" data-original="../images/harmonyos/-16273165812141920" alt=""></p>
<p>说明</p>
<p>卡片管理服务不负责保持卡片的活跃状态（设置了定时更新的除外），当使用方作出相应的请求时，管理服务会拉起提供方并回调相应接口。</p>
<h4 id="Java卡片与JS卡片选型指导"><a href="#Java卡片与JS卡片选型指导" class="headerlink" title="Java卡片与JS卡片选型指导"></a>Java卡片与JS卡片选型指导</h4><p>Java/JS卡片场景能力差异如下表所示：</p>
<table>
<thead>
<tr>
<th>场景</th>
<th>Java卡片</th>
<th>JS卡片</th>
<th>支持的版本</th>
</tr>
</thead>
<tbody><tr>
<td>实时刷新（类似时钟）</td>
<td>Java使用ComponentProvider做实时刷新代价比较大</td>
<td>JS可以做到端侧刷新，但是需要定制化组件</td>
<td>HarmonyOS 2.0及以上</td>
</tr>
<tr>
<td>开发方式</td>
<td>Java UI在卡片提供方需要同时对数据和组件进行处理，生成ComponentProvider远端渲染</td>
<td>JS卡片在使用方加载渲染，提供方只要处理数据、组件和逻辑分离</td>
<td>HarmonyOS 2.0及以上</td>
</tr>
<tr>
<td>组件支持</td>
<td>Text、Image、DirectionalLayout、PositionLayout、DependentLayout</td>
<td>div、list、list-item、swiper、stack、image、text、span、progress、button（定制：chart 、clock、calendar）</td>
<td>HarmonyOS 2.0及以上</td>
</tr>
<tr>
<td>卡片内动效</td>
<td>不支持</td>
<td>暂不开放</td>
<td>HarmonyOS 2.0及以上</td>
</tr>
<tr>
<td>阴影模糊</td>
<td>不支持</td>
<td>支持</td>
<td>HarmonyOS 2.0及以上</td>
</tr>
<tr>
<td>动态适应布局</td>
<td>不支持</td>
<td>支持</td>
<td>HarmonyOS 2.0及以上</td>
</tr>
<tr>
<td>自定义卡片跳转页面</td>
<td>不支持</td>
<td>支持</td>
<td>HarmonyOS 2.0及以上</td>
</tr>
</tbody></table>
<p>综上所述，JS卡片比JAVA卡片支持的控件和能力都更丰富：</p>
<p>Java卡片：适合作为一个直达入口，没有复杂的页面和事件。</p>
<p>JS卡片：适合有复杂界面的卡片。</p>
<h4 id="约束与限制-2"><a href="#约束与限制-2" class="headerlink" title="约束与限制"></a>约束与限制</h4><p>对于同一个Page ability，在config.json中最多支持配置16张卡片</p>
<h3 id="Java卡片开发指导"><a href="#Java卡片开发指导" class="headerlink" title="Java卡片开发指导"></a>Java卡片开发指导</h3><ol>
<li>使用DevEco Studio创建卡片工程。卡片应用是一款特殊的元能力服务，其配置文件config.json中声明以下几项，系统能够识别该应用为一款卡片应用，并与系统进行绑定。</li>
</ol>
<p>config.json文件”abilities”配置forms模块细节如下，各属性详情可见表。</p>
<pre><code>"forms": [
  {
    "name": "Form_Java",
    "description": "form_description",
    "type": "Java",
    "colorMode": "auto",
    "isDefault": true,
    "updateEnabled": true,
    "scheduledUpateTime": "10:30",
    "updateDuration": 1,
    "defaultDimension": "2*2",
    "formVisibleNotify": true,
    "supportDimensions": [
      "1*2",
      "2*2",
      "2*4",
      "4*4"
    ],
    "landscapeLayouts": [
      "$layout:form_ability_layout_1_2",
      "$layout:form_ability_layout_2_2",
      "$layout:form_ability_layout_2_4",
      "$layout:form_ability_layout_4_4"
    ],
    "portraitLayouts": [
      "$layout:form_ability_layout_1_2",
      "$layout:form_ability_layout_2_2",
      "$layout:form_ability_layout_2_4",
      "$layout:form_ability_layout_4_4"
    ],
    "formConfigAbility": "ability://SecondFormAbility",
    "metaData": {
      "customizeData": [
        {
          "name": "originWidgetName",
          "value": "com.huawei.weather.testWidget"
        }
      ]
    }
  }
]</code></pre><p>说明</p>
<p>“forms”模块中的name为卡片名，即在onCreateForm中根据AbilitySlice.PARAM_FORM_NAME_KEY可取到的值。</p>
<p>除此之外，在卡片所在的”abilities”中还需要配置”visible”: true和”formsEnabled”: true。</p>
<table>
<thead>
<tr>
<th>属性名称</th>
<th>子属性名称</th>
<th>含义</th>
<th>数据类型</th>
<th>是否可缺省</th>
</tr>
</thead>
<tbody><tr>
<td>name</td>
<td>-</td>
<td>表示卡片的类名。字符串最大长度为127字节。</td>
<td>字符串</td>
<td>否</td>
</tr>
<tr>
<td>description</td>
<td>-</td>
<td>表示卡片的描述。取值可以是描述性内容，也可以是对描述性内容的资源索引，以支持多语言。字符串最大长度为255字节。</td>
<td>字符串</td>
<td>可缺省，缺省为空。</td>
</tr>
<tr>
<td>isDefault</td>
<td>-</td>
<td>表示该卡片是否为默认卡片，每个Ability有且只有一个默认卡片。true：默认卡片。false：非默认卡片。</td>
<td>布尔值</td>
<td>否</td>
</tr>
<tr>
<td>type</td>
<td>-</td>
<td>表示卡片的类型。取值范围如下：Java：Java卡片。JS：JS卡片。</td>
<td>字符串</td>
<td>否</td>
</tr>
<tr>
<td>colorMode</td>
<td>-</td>
<td>表示卡片的主题样式，取值范围如下：auto：自适应。dark：深色主题。light：浅色主题。</td>
<td>字符串</td>
<td>可缺省，缺省值为“auto”。</td>
</tr>
<tr>
<td>supportDimensions</td>
<td>-</td>
<td>表示卡片支持的外观规格，取值范围：1<em>2：表示1行2列的二宫格。2</em>2：表示2行2列的四宫格。2<em>4：表示2行4列的八宫格。4</em>4：表示4行4列的十六宫格。</td>
<td>字符串数组</td>
<td>否</td>
</tr>
<tr>
<td>defaultDimension</td>
<td>-</td>
<td>表示卡片的默认外观规格，取值必须在该卡片supportDimensions配置的列表中。</td>
<td>字符串</td>
<td>否</td>
</tr>
<tr>
<td>landscapeLayouts</td>
<td>-</td>
<td>表示卡片外观规格对应的横向布局文件，与supportDimensions中的规格一一对应。仅当卡片类型为Java卡片时，需要配置该标签。</td>
<td>字符串数组</td>
<td>否</td>
</tr>
<tr>
<td>portraitLayouts</td>
<td>-</td>
<td>表示卡片外观规格对应的竖向布局文件，与supportDimensions中的规格一一对应。仅当卡片类型为Java卡片时，需要配置该标签。</td>
<td>字符串数组</td>
<td>否</td>
</tr>
<tr>
<td>updateEnabled</td>
<td>-</td>
<td>表示卡片是否支持周期性刷新，取值范围：true：表示支持周期性刷新，可以在定时刷新（updateDuration）和定点刷新（scheduledUpdateTime）两种方式任选其一，优先选择定时刷新。false：表示不支持周期性刷新。</td>
<td>布尔类型</td>
<td>否</td>
</tr>
<tr>
<td>scheduledUpdateTime</td>
<td>-</td>
<td>表示卡片的定点刷新的时刻，采用24小时制，精确到分钟。</td>
<td>字符串</td>
<td>可缺省，缺省值为“0:0”。</td>
</tr>
<tr>
<td>updateDuration</td>
<td>-</td>
<td>表示卡片定时刷新的更新周期，单位为30分钟，取值为自然数。当取值为0时，表示该参数不生效。当取值为正整数N时，表示刷新周期为30*N分钟。</td>
<td>数值</td>
<td>可缺省，缺省值为“0”。</td>
</tr>
<tr>
<td>formConfigAbility</td>
<td>-</td>
<td>表示卡片的配置跳转链接，采用URI格式。</td>
<td>字符串</td>
<td>可缺省，缺省值为空。</td>
</tr>
<tr>
<td>jsComponentName</td>
<td>-</td>
<td>表示JS卡片的Component名称。字符串最大长度为127字节。仅当卡片类型为JS卡片时，需要配置该标签。</td>
<td>字符串</td>
<td>否</td>
</tr>
<tr>
<td>metaData</td>
<td>-</td>
<td>表示卡片的自定义信息，包含customizeData数组标签。</td>
<td>对象</td>
<td>可缺省，缺省值为空。</td>
</tr>
<tr>
<td>customizeData</td>
<td>-</td>
<td>表示自定义的卡片信息。</td>
<td>对象数组</td>
<td>可缺省，缺省值为空。</td>
</tr>
<tr>
<td>name</td>
<td>表示数据项的键名称。字符串最大长度为255字节。</td>
<td>字符串</td>
<td>可缺省，缺省值为空。</td>
<td></td>
</tr>
<tr>
<td>value</td>
<td>表示数据项的值。字符串最大长度为255字节。</td>
<td>字符串</td>
<td>可缺省，缺省值为空。</td>
<td></td>
</tr>
</tbody></table>
<ol>
<li>创建一个FormAbility，覆写卡片相关回调函数。</li>
</ol>
<ul>
<li><p>onCreateForm(Intent intent)</p>
</li>
<li><p>onUpdateForm(long formId)</p>
</li>
<li><p>onDeleteForm(long formId)</p>
</li>
<li><p>onCastTempForm(long formId)</p>
</li>
<li><p>onEventNotify(Map&lt;Long, Integer&gt; formEvents)</p>
</li>
</ul>
<p>在onCreateForm(Intent intent)中，当卡片使用方请求获取卡片时，卡片提供方会被拉起并调用onCreateForm(Intent intent)回调，intent中会带有卡片ID，卡片名称，临时卡片标记和卡片外观规格信息，分别通过AbilitySlice.PARAM_FORM_IDENTITY_KEY、AbilitySlice.PARAM_FORM_NAME_KEY、AbilitySlice.PARAM_FORM_TEMORARY_KEY和AbilitySlice.PARAM_FORM_DIMENSION_KEY按需获取。</p>
<p>提供方可以通过AbilitySlice.PARAM_FORM_CUSTOMIZE_KEY获取卡片使用方设置的自定义数据。</p>
<pre><code>public class FormAbility extends Ability {
    ......
    @Override
    public void onStart(Intent intent) {
        super.onStart(intent);
        ......
    }
    @Override
    protected ProviderFormInfo onCreateForm(Intent intent) {
        long formId = intent.getLongParam(AbilitySlice.PARAM_FORM_IDENTITY_KEY, 0);
        String formName = intent.getStringParam(AbilitySlice.PARAM_FORM_NAME_KEY);
        int specificationId = intent.getIntParam(AbilitySlice.PARAM_FORM_DIMENSION_KEY, 0);
        boolean tempFlag = intent.getBooleanParam(AbilitySlice.PARAM_FORM_TEMPORARY_KEY, false);

        // 获取自定义数据
        IntentParams intentParams = intent.getParam(AbilitySlice.PARAM_FORM_CUSTOMIZE_KEY);

        HiLog.info(LABEL_LOG, "onCreateForm: " + formId + " " + formName + " " + specificationId);
        // 开发者需要根据卡片的名称以及外观规格获取对应的xml布局并构造卡片对象，此处ResourceTable.Layout_form_ability_layout_2_2仅为示例
        ProviderFormInfo formInfo = new ProviderFormInfo(ResourceTable.Layout_form_ability_layout_2_2, this);
        // 获取卡片信息
        String formData = getInitFormData(formName, specificationId);
        ComponentProvider componentProvider = new ComponentProvider();
        componentProvider.setText(ResourceTable.Id_title, "formData-" + formData);
        formInfo.mergeActions(componentProvider);
        ......
        HiLog.info(LABEL_LOG, "onCreateForm finish.......");
        return formInfo;
    }

    @Override
    protected void onDeleteForm(long formId) {
        super.onDeleteForm(formId);
        // 删除卡片实例数据，需要由开发者实现
        deleteFormInfo(formId);
        ......
    }

    @Override
    // 若卡片支持定时更新/定点更新/卡片使用方主动请求更新功能，则提供方需要覆写该方法以支持数据更新
    protected void onUpdateForm(long formId) {
        super.onUpdateForm(formId);
        // 更新卡片信息，由开发者实现
        ......
    }

    @Override
    protected void onCastTempForm(long formId) {
        // 使用方将临时卡片转换为常态卡片触发，提供方需要做相应的处理，将数据持久化。
        super.onCastTempForm (formId);
        ......
    }

    @Override
    protected void onEventNotify(Map&lt;Long, Integer&gt; formEvents) {
        // 使用方发起可见或者不可见通知触发，提供方需要做相应的处理，比如卡片可见时刷新卡片，仅系统应用能收到该回调。
        super.onEventNotify(formEvents);
        ......
    }
}</code></pre><ol>
<li>卡片信息持久化。因大部分卡片提供方都不是常驻服务，只有在需要使用时才会被拉起获取卡片信息。且卡片框架支持对卡片进行多实例管理，卡片ID对应实例ID，因此若卡片提供方支持对卡片数据进行配置，则需要提供方对卡片的业务数据按照卡片ID进行持久化管理，以便在后续获取、更新以及拉起时能获取到正确的卡片业务数据。</li>
</ol>
<p>同时，需要适配onDeleteForm(int formId)卡片删除通知接口，在其中实现卡片实例数据的删除。和JS卡片相同，需要注意卡片使用方在请求卡片时传递给提供方应用的Intent数据中存在临时标记字段，表示此次请求的卡片是否为临时卡片，由于临时卡片的数据不会持久化的特殊性，某些场景比如卡片服务框架死亡重启，此时临时卡片数据在卡片服务框架中已经删除，且对应的卡片ID不会通知到提供方，所以卡片提供方需要自己负责清理长时间未删除的临时卡片数据。同时对应的卡片使用方可能会将之前请求的临时卡片转换为常态卡片。如果转换成功，卡片提供方也需要对对应的临时卡片ID进行处理，把卡片提供方记录的临时卡片数据转换为常态卡片数据，防止提供方在清理长时间未删除的临时卡片时，把已经转换为常态卡片的临时卡片信息删除，导致卡片信息丢失。</p>
<pre><code>@Override
protected ProviderFormInfo onCreateForm(Intent intent) {
    long formId = intent.getLongParam(AbilitySlice.PARAM_FORM_ID_KEY, -1L);
    String formName = intent.getStringParam(AbilitySlice.PARAM_FORM_NAME_KEY);
    int specificationId = intent.getIntParam(AbilitySlice.PARAM_FORM_DIMENSION_KEY, 0);
    boolean tempFlag = params.getBooleanParam(AbilitySlice.PARAM_FORM_TEMPORARY_KEY, false);
    HiLog.info(LABEL_LOG, "onCreateForm: " + formId + " " + formName + " " + specificationId);

    .......
    // 将创建的卡片信息持久化，以便在下次获取/更新该卡片实例时进行使用，该方法需要由开发者实现。
    storeFormInfo(formId, formName, specificationId, formData);
    ......
    HiLog.info(LABEL_LOG, "onCreateForm finish.......");
    return formInfo;
}
@Override
protected void onDeleteForm(long formId) {
    super.onDeleteForm(formId);
    // 由开发人员自行实现，删除卡片实例数据
    deleteFormInfo(formId);
    ......
}
@Override
protected void onCastTempForm(long formId) {
    // 使用方将临时卡片转换为常态卡片触发，提供方需要做相应的处理
    super.onCastTempForm (formId);
    ......
}</code></pre><ol>
<li>卡片数据更新。当需要卡片提供方更新数据时（如触发了定时更新，定点更新，或者卡片使用方主动请求更新），卡片提供方获取最新数据，并调用updateForm接口更新卡片。示例如下：</li>
</ol>
<pre><code>@Override
protected void onUpdateForm(long formId) {
    super.onUpdateForm(formId);
    ComponentProvider componentProvider = new ComponentProvider(ResourceTable.Layout_form_ability_layout_2_2, this);
    // 获取卡片实例需要更新的卡片数据，需要由开发者实现
    String formData = getUpdateFormData(formId);
    componentProvider.setText(ResourceTable.Id_title, "update formData-" + formData);
    updateForm(formId, componentProvider);
    ......
}</code></pre><p>卡片使用方点击拉起卡片页面，会在onStart(Intent intent)中携带formId（通过AbilitySlice.PARAM_FORM_IDENTITY_KEY获取），若需要在AbilitySlice中更新，也可以使用updateForm接口进行更新，示例如下：</p>
<pre><code>public class FormAbilitySlice extends AbilitySlice {
    ......
    @Override
    public void onStart(Intent intent) {
        super.onStart(intent);
        ......
        Button button = new Button(this);
        button.setText("Update form data");
        button.setClickedListener(component -&gt; {
            ......
            if (intent.hasParameter(AbilitySlice.PARAM_FORM_IDENTITY_KEY)) {
                int formId = intent.getIntParam(AbilitySlice.PARAM_FORM_ID_KEY, -1);
                ComponentProvider componentProvider = new ComponentProvider(ResourceTable.Layout_form_ability_layout_2_2, context);
                String formData = getUpdateFormData(formId);
                componentProvider.setText(ResourceTable.Id_modifylayout, "update formData-" + formData);
                getAbility().updateForm(formId, componentProvider);
            }
        });
        ......
    }
}</code></pre><ol>
<li>Java卡片控制事件。Java卡片当前通过IntentAgent能力支持对卡片控制设置事件，例如可以使用START_ABILITY、START_SERVICE这两类能力，在点击整张卡片时，跳转到提供卡片的ability。</li>
</ol>
<p>示例如下：</p>
<pre><code>@Override
protected ProviderFormInfo onCreateForm(Intent intent) {
    ......
    ProviderFormInfo formInfo = new ProviderFormInfo(ResourceTable.Layout_form_ability_layout_2_2, this);
    ComponentProvider componentProvider = new ComponentProvider();
    // 针对title控件设置事件
    componentProvider.setIntentAgent(ResourceTable.Id_title, startAbilityIntentAgent());
    formInfo.mergeActions(componentProvider);
    ......
    return formInfo;
}

// 设置触发的事件为系统预置的HarmonyOS betaApp应用
private IntentAgent startAbilityIntentAgent() {
    Intent intent = new Intent();
    Operation operation = new Intent.OperationBuilder()
            .withDeviceId("")
            .withBundleName("com.huawei.ohos.betaapp.link")
            .withAbilityName("com.huawei.ohos.betaapp.link.MainAbility")
            .build();
    intent.setOperation(operation);
    List&lt;Intent&gt; intentList = new ArrayList&lt;&gt;();
    intentList.add(intent);
    List&lt;Flags&gt; flags = new ArrayList&lt;&gt;();
    flags.add(Flags.UPDATE_PRESENT_FLAG);
    IntentAgentInfo paramsInfo = new IntentAgentInfo(200, IntentAgentConstant.OperationType.START_ABILITY, flags, intentList, null);
    IntentAgent intentAgent = IntentAgentHelper.getIntentAgent(this, paramsInfo);
    return intentAgent;
}</code></pre><ol>
<li>开发Java卡片布局。在使用DevEco Studio创建模块时会生成对应的Java UI xml布局文件，具体规则请参考《<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/ui-java-component-layout-xml-0000000000500395" target="_blank" rel="noopener">XML创建布局</a>》，需要注意设置ohos:remote=”true”。</li>
</ol>
<p>以下是天气卡片xml布局示例，供参考：</p>
<pre><code>&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;DependentLayout xmlns:ohos="http://schemas.huawei.com/res/ohos"
                 ohos:width="match_parent"
                 ohos:height="match_parent"
                 ohos:id="$+id:background"
                 ohos:orientation="vertical"
                 ohos:background_element="$media:weather"
                 ohos:remote="true"&gt;
        &lt;Text
                ohos:id="$+id:title"
                ohos:text="天气1"
                ohos:text_size="39px"
                ohos:text_color="#b0c4de"
                ohos:top_margin="42px"
                ohos:left_margin="20px"
                ohos:width="match_content"
                ohos:height="match_content"/&gt;
        &lt;Text
                ohos:id="$+id:temperature"
                ohos:text="35°"
                ohos:text_size="100px"
                ohos:text_color="#b0c4de"
                ohos:top_margin="25px"
                ohos:left_margin="20px"
                ohos:below="$id:title"
                ohos:width="match_content"
                ohos:height="match_content"/&gt;
        &lt;Text
                ohos:id="$+id:location"
                ohos:text="上海"
                ohos:text_size="39px"
                ohos:text_color="#b0c4de"
                ohos:top_margin="24px"
                ohos:left_margin="20px"
                ohos:below="$id:temperature"
                ohos:width="match_content"
                ohos:height="match_content"/&gt;
        &lt;Text
                ohos:id="$+id:textView4"
                ohos:text="9月4号 星期五"
                ohos:text_size="39px"
                ohos:text_color="#b0c4de"
                ohos:top_margin="10px"
                ohos:left_margin="20px"
                ohos:below="$id:location"
                ohos:width="match_content"
                ohos:height="match_content"/&gt;

        &lt;Text
                ohos:id="$+id:textView5"
                ohos:text="多云"
                ohos:text_size="39px"
                ohos:text_color="#b0c4de"
                ohos:top_margin="10px"
                ohos:left_margin="150px"
                ohos:below="$id:location"
                ohos:end_of="$id:textView4"
                ohos:align_parent_end="true"
                ohos:width="match_content"
                ohos:height="match_content"/&gt;

        &lt;Image
                ohos:id="$+id:imageView"
                ohos:width="160px"
                ohos:height="150px"
                ohos:top_margin="20px"
                ohos:left_margin="150px"
                ohos:below="$id:title"
                ohos:end_of="$id:temperature"
                ohos:image_src="$media:clouds"/&gt;
&lt;/DependentLayout&gt;</code></pre><h2 id="剪贴板"><a href="#剪贴板" class="headerlink" title="剪贴板"></a>剪贴板</h2><p>用户通过系统剪贴板服务，可实现应用之间的简单数据传递。例如：在应用A中复制的数据，可以在应用B中粘贴，反之亦可。</p>
<ul>
<li><p>HarmonyOS提供系统剪贴板服务的操作接口，支持用户程序从系统剪贴板中读取、写入和查询剪贴板数据，以及添加、移除系统剪贴板数据变化的回调。</p>
</li>
<li><p>HarmonyOS提供剪贴板数据的对象定义，包含内容对象和属性对象</p>
</li>
</ul>
<h3 id="场景介绍-5"><a href="#场景介绍-5" class="headerlink" title="场景介绍"></a>场景介绍</h3><p>同一设备的应用程序A、B之间可以借助系统剪贴板服务完成简单数据的传递，即应用程序A向剪贴板服务写入数据后，应用程序B可以从中读取出数据。</p>
<p><img src="/images/loading.gif" data-original="../images/harmonyos/-16273165884161922" alt=""></p>
<p>在使用剪贴板服务时，需要注意以下几点：</p>
<ul>
<li><p>只有在前台获取到焦点的应用才有读取系统剪贴板的权限（系统默认输入法应用除外）。</p>
</li>
<li><p>写入到剪贴板服务中的剪贴板数据不会随应用程序结束而销毁。</p>
</li>
<li><p>对同一用户而言，写入剪贴板服务的数据会被下一次写入的剪贴板数据所覆盖。</p>
</li>
<li><p>在同一设备内，剪贴板单次传递内容不应超过500KB。</p>
</li>
</ul>
<h3 id="接口说明-5"><a href="#接口说明-5" class="headerlink" title="接口说明"></a>接口说明</h3><p>SystemPasteboard提供系统剪贴板操作的相关接口，比如复制、粘贴、配置回调等。PasteData是剪贴板服务操作的数据对象，一个PasteData由若干个内容节点（PasteData.Record）和一个属性集合对象（PasteData.DataProperty）组成。Record是存放剪贴板数据内容信息的最小单位，每个Record都有其特定的MIME类型，如纯文本、HTML、URI、Intent。剪贴板数据的属性信息存在放PasteData.DataProperty中，包括标签、时间戳等。</p>
<p><strong>SystemPasteboard</strong></p>
<p>SystemPasteboard提供系统剪贴板服务的操作接口，比如复制、粘贴、配置回调等。</p>
<table>
<thead>
<tr>
<th>接口名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>getSystemPasteboard(Context context)</td>
<td>获取系统剪切板服务的对象实例。</td>
</tr>
<tr>
<td>getPasteData()</td>
<td>读取当前系统剪贴板中的数据。</td>
</tr>
<tr>
<td>hasPasteData()</td>
<td>判断当前系统剪贴板中是否有内容。</td>
</tr>
<tr>
<td>setPasteData(PasteData data)</td>
<td>将剪贴板数据写入到系统剪贴板。</td>
</tr>
<tr>
<td>clear()</td>
<td>清空系统剪贴板数据。</td>
</tr>
<tr>
<td>addPasteDataChangedListener(IPasteDataChangedListener listener)</td>
<td>用户程序添加系统剪贴板数据变化的回调，当系统剪贴板数据发生变化时，会触发用户程序的回调实现。</td>
</tr>
<tr>
<td>removePasteDataChangedListener(IPasteDataChangedListener listener)</td>
<td>用户程序移除系统剪贴板数据变化的回调。</td>
</tr>
</tbody></table>
<p><strong>PasteData</strong></p>
<p>PasteData是剪贴板服务操作的数据对象，其中内容节点定义为PasteData.Record，属性集合定义为PasteData.DataProperty。</p>
<table>
<thead>
<tr>
<th>接口名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>PasteData()</td>
<td>构造器，创建一个空内容数据对象。</td>
</tr>
<tr>
<td>creatPlainTextData(CharSequence text)</td>
<td>构建一个包含纯文本内容节点的数据对象。</td>
</tr>
<tr>
<td>creatHtmlData(String htmlText)</td>
<td>构建一个包含HTML内容节点的数据对象。</td>
</tr>
<tr>
<td>creatUriData(Uri uri)</td>
<td>构建一个包含URI内容节点的数据对象。</td>
</tr>
<tr>
<td>creatIntentData(Intent intent)</td>
<td>构建一个包含Intent内容节点的数据对象。</td>
</tr>
<tr>
<td>getPrimaryMimeType()</td>
<td>获取数据对象中首个内容节点的MIME类型，如果没有查询到内容，将返回一个空字符串。</td>
</tr>
<tr>
<td>getPrimaryText()</td>
<td>获取数据对象中首个内容节点的纯文本内容，如果没有查询到内容，将返回一个空对象。</td>
</tr>
<tr>
<td>addTextRecord(CharSequence text)</td>
<td>向数据对象中添加一个纯文本内容节点，该方法会自动更新数据属性中的MIME类型集合，最多只能添加128个内容节点。</td>
</tr>
<tr>
<td>addRecord(Record record)</td>
<td>向数据对象中添加一个内容节点，该方法会自动更新数据属性中的MIME类型集合，最多只能添加128个内容节点。</td>
</tr>
<tr>
<td>getRecordCount()</td>
<td>获取数据对象中内容节点的数量。</td>
</tr>
<tr>
<td>getRecordAt(int index)</td>
<td>获取数据对象在指定下标处的内容节点，如果操作失败会返回空对象。</td>
</tr>
<tr>
<td>removeRecordAt(int index)</td>
<td>移除数据对象在指定下标处的内容节点，如果操作成功会返回true，操作失败会返回false。</td>
</tr>
<tr>
<td>getMimeTypes()</td>
<td>获取数据对象中上所有内容节点的MIME类型列表，当内容节点为空时，返回列表为空对象。</td>
</tr>
<tr>
<td>getProperty()</td>
<td>获取该数据对象的属性集合成员。</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>常量名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>MIMETYPE_TEXT_PLAIN= “text/plain”</td>
<td>纯文本的MIME类型定义。</td>
</tr>
<tr>
<td>MIMETYPE_TEXT_HTML= “text/html”</td>
<td>HTML的MIME类型定义。</td>
</tr>
<tr>
<td>MIMETYPE_TEXT_URI= “text/uri”</td>
<td>URI的MIME类型定义。</td>
</tr>
<tr>
<td>MIMETYPE_TEXT_INTENT= “text/ohos.intent”</td>
<td>Intent的MIME类型定义。</td>
</tr>
<tr>
<td>MAX_RECORD_NUM=128</td>
<td>单个PasteData中所能包含的Record的数量上限。</td>
</tr>
</tbody></table>
<p><strong>PasteData.Record</strong></p>
<p>一个PasteData中包含若干个特定MIME类型的PasteData.Record，每个Record是存放剪贴板数据内容信息的最小单位。</p>
<table>
<thead>
<tr>
<th>接口名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>createPlainTextRecord(CharSequence text)</td>
<td>构造一个MIME类型为纯文本的内容节点。</td>
</tr>
<tr>
<td>createHtmlTextRecord(String htmlText)</td>
<td>构造一个MIME类型为HTML的内容节点。</td>
</tr>
<tr>
<td>createUriRecord(Uri uri)</td>
<td>构造一个MIME类型为URI的内容节点。</td>
</tr>
<tr>
<td>createIntentRecord(Intent intent)</td>
<td>构造一个MIME类型为Intent的内容节点。</td>
</tr>
<tr>
<td>getPlainText()</td>
<td>获取该内容节点中的文本内容，如果没有内容将返回空对象。</td>
</tr>
<tr>
<td>getHtmlText()</td>
<td>获取该内容节点中的HTML内容，如果没有内容将返回空对象。</td>
</tr>
<tr>
<td>getUri()</td>
<td>获取该内容节点中的URI内容，如果没有内容将返回空对象。</td>
</tr>
<tr>
<td>getIntent()</td>
<td>获取该内容节点中的Intent内容，如果没有内容将返回空对象。</td>
</tr>
<tr>
<td>getMimeType()</td>
<td>获取该内容节点的MIME类型。</td>
</tr>
<tr>
<td>convertToText(Context context)</td>
<td>将该内容节点的内容转为文本形式。</td>
</tr>
</tbody></table>
<p><strong>PasteData.DataProperty</strong></p>
<p>每个PasteData中都有一个PasteData.DataProperty成员，其中存放着该数据对象的属性集合，例如自定义标签、MIME类型集合列表等。</p>
<table>
<thead>
<tr>
<th>接口名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>getMimeTypes()</td>
<td>获取所属数据对象的MIME类型集合列表，当内容节点为空时，返回列表为空对象。</td>
</tr>
<tr>
<td>hasMimeType(String mimeType)</td>
<td>判断所属数据对象中是否包含特定MIME类型的内容。</td>
</tr>
<tr>
<td>getTimestamp()</td>
<td>获取所属数据对象被写入系统剪贴板时的时间戳，如果该数据对象尚未被写入，则返回0。</td>
</tr>
<tr>
<td>setTag(CharSequence tag)</td>
<td>设置自定义标签。</td>
</tr>
<tr>
<td>getTag()</td>
<td>获取自定义标签。</td>
</tr>
<tr>
<td>setAdditions(PacMap extraProps)</td>
<td>设置一些附加键值对信息。</td>
</tr>
<tr>
<td>getAdditions()</td>
<td>获取附加键值对信息。</td>
</tr>
</tbody></table>
<p><strong>IPasteDataChangedListener</strong></p>
<p>IPasteDataChangedListener是定义剪贴板数据变化回调的接口类，开发者需要实现此接口来编码触发回调时的处理逻辑。</p>
<table>
<thead>
<tr>
<th>接口名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>onChanged()</td>
<td>当系统剪贴板数据发生变化时的回调接口。</td>
</tr>
</tbody></table>
<h3 id="开发步骤-3"><a href="#开发步骤-3" class="headerlink" title="开发步骤"></a>开发步骤</h3><ol>
<li>应用A获取系统剪贴板服务。</li>
</ol>
<pre><code>SystemPasteboard pasteboard = SystemPasteboard.getSystemPasteboard(appContext);</code></pre><ol>
<li>应用A向系统剪贴板中写入一条纯文本数据。</li>
</ol>
<pre><code>if (pasteboard != null) {
    pasteboard.setPasteData(PasteData.creatPlainTextData("Hello, world!"));
}</code></pre><ol>
<li>应用B从系统剪贴板读取数据，将数据对象中的首个文本类型（纯文本/HTML）内容信息在控件中显示，忽略其他类型内容。</li>
</ol>
<pre><code>PasteData pasteData = pasteboard.getPasteData();
if (pasteData == null) {
    return;
}
DataProperty dataProperty = pasteData.getProperty();
boolean hasHtml = dataProperty.hasMimeType(PasteData.MIMETYPE_TEXT_HTML);
boolean hasText = dataProperty.hasMimeType(PasteData.MIMETYPE_TEXT_PLAIN);
if (hasHtml || hasText) {
    Text text = (Text) findComponentById(ResourceTable.Id_text);
    for (int i = 0; i &lt; pasteData.getRecordCount(); i++) {
        PasteData.Record record = pasteData.getRecordAt(i);
        String mimeType = record.getMimeType();
        if (mimeType.equals(PasteData.MIMETYPE_TEXT_HTML)) {
            text.setText(record.getHtmlText());
            break;
        } else if (mimeType.equals(PasteData.MIMETYPE_TEXT_PLAIN)) {
            text.setText(record.getPlainText().toString());
            break;
        } else {
            // skip records of other Mime type 
        }
    }
}</code></pre><ol>
<li>应用C注册添加系统剪贴板数据变化回调，当系统剪贴板数据发生变化时触发处理逻辑。</li>
</ol>
<pre><code>IPasteDataChangedListener listener = new IPasteDataChangedListener() {
    @Override
    public void onChanged() {
        PasteData pasteData = pasteboard.getPasteData();
        if (pasteData == null) {
            return;
        }
        // Operations to handle data change on the system pasteboard
    }
};
pasteboard.addPasteDataChangedListener(listener);</code></pre><h3 id="相关实例-8"><a href="#相关实例-8" class="headerlink" title="相关实例"></a>相关实例</h3><p>针对剪贴板开发指导，有以下示例工程可供参考：</p>
<ul>
<li><a href="https://gitee.com/openharmony/app_samples/tree/master/ability/Pasteboard" target="_blank" rel="noopener">Pasteboard</a>本示例演示了应用之间的数据剪贴</li>
</ul>
<h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><h1 id="UI"><a href="#UI" class="headerlink" title="UI"></a>UI</h1><h1 id="媒体"><a href="#媒体" class="headerlink" title="媒体"></a>媒体</h1><h1 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h1><h1 id="AI"><a href="#AI" class="headerlink" title="AI"></a>AI</h1><h1 id="网络连接"><a href="#网络连接" class="headerlink" title="网络连接"></a>网络连接</h1><h1 id="设备管理"><a href="#设备管理" class="headerlink" title="设备管理"></a>设备管理</h1><h1 id="数据管理"><a href="#数据管理" class="headerlink" title="数据管理"></a>数据管理</h1><h1 id="日志管理"><a href="#日志管理" class="headerlink" title="日志管理"></a>日志管理</h1><h1 id="原子化服务"><a href="#原子化服务" class="headerlink" title="原子化服务"></a>原子化服务</h1><h1 id="流转"><a href="#流转" class="headerlink" title="流转"></a>流转</h1><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://jackhcc.github.io" rel="external nofollow noreferrer">杰克成</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://jackhcc.github.io/posts/Harmony-05.html">https://jackhcc.github.io/posts/Harmony-05.html</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="https://jackhcc.github.io" target="_blank">杰克成</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/Harmony/">
                                    <span class="chip bg-color">Harmony</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/share/css/share.min.css">

<div id="article-share">
    
    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/medias/reward/aliqr.png" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/medias/reward/wxqr.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>
            
        </div>
    </div>

    
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/gitalk/gitalk.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/css/my-gitalk.css">

<div class="card gitalk-card" data-aos="fade-up">
    <div class="comment_headling" style="font-size: 20px; font-weight: 700; position: relative; left: 20px; top: 15px; padding-bottom: 5px;">
        <i class="fas fa-comments fa-fw" aria-hidden="true"></i>
        <span>评论</span>
    </div>
    <div id="gitalk-container" class="card-content"></div>
</div>

<script src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/gitalk/gitalk.min.js"></script>
<script>
    let gitalk = new Gitalk({
        clientID: '3821a0bbb773038a51fc',
        clientSecret: '4b30b507d67ec5497ec0e77f43f80cb3e0d7dd3a',
        repo: 'JackHCC.github.io',
        owner: 'JackHCC',
        admin: "JackHCC",
        id: '2021-07-05T01-19-40',
        distractionFreeMode: false  // Facebook-like distraction free mode
    });

    gitalk.render('gitalk-container');
</script>
    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/posts/basic-know-001.html">
                    <div class="card-image">
                        
                        
                        <img src="/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/medias/featureimages/3.jpg" class="responsive-img" alt="科普：计算机时间">
                        
                        <span class="card-title">科普：计算机时间</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            计算机时间背后的秘密
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2021-07-09
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/Basic/" class="post-category">
                                    Basic
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Basic/">
                        <span class="chip bg-color">Basic</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/posts/Harmony-04.html">
                    <div class="card-image">
                        
                        
                        <img src="/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/medias/featureimages/8.jpg" class="responsive-img" alt="HarmonyOS开发：基础入门">
                        
                        <span class="card-title">HarmonyOS开发：基础入门</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            HarmonyOS基础开发手册
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2021-07-04
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/Harmony/" class="post-category">
                                    Harmony
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Harmony/">
                        <span class="chip bg-color">Harmony</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/codeBlock/codeShrink.js"></script>


<!-- 代码块折行 -->

<style type="text/css">
code[class*="language-"], pre[class*="language-"] { white-space: pre !important; }
</style>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('4'),
            headingSelector: 'h1, h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h1, h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>



    <footer class="page-footer bg-color">
    <div class="container row center-align" style="margin-bottom: 15px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            <span id="year">2020</span>
            <a href="https://jackhcc.github.io" target="_blank">杰克成</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                class="white-color">3591.2k</span>&nbsp;字
            
            
            
            
            
            
            <span id="busuanzi_container_site_pv">
                |&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv"
                    class="white-color"></span>&nbsp;次
            </span>
            
            
            <span id="busuanzi_container_site_uv">
                |&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv"
                    class="white-color"></span>&nbsp;人
            </span>
            
            <br>
            
            <span id="sitetime">载入运行时间...</span>
            <script>
                function siteTime() {
                    var seconds = 1000;
                    var minutes = seconds * 60;
                    var hours = minutes * 60;
                    var days = hours * 24;
                    var years = days * 365;
                    var today = new Date();
                    var startYear = "2020";
                    var startMonth = "2";
                    var startDate = "27";
                    var startHour = "6";
                    var startMinute = "30";
                    var startSecond = "0";
                    var todayYear = today.getFullYear();
                    var todayMonth = today.getMonth() + 1;
                    var todayDate = today.getDate();
                    var todayHour = today.getHours();
                    var todayMinute = today.getMinutes();
                    var todaySecond = today.getSeconds();
                    var t1 = Date.UTC(startYear, startMonth, startDate, startHour, startMinute, startSecond);
                    var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
                    var diff = t2 - t1;
                    var diffYears = Math.floor(diff / years);
                    var diffDays = Math.floor((diff / days) - diffYears * 365);
                    var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours);
                    var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) /
                        minutes);
                    var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours -
                        diffMinutes * minutes) / seconds);
                    if (startYear == todayYear) {
                        document.getElementById("year").innerHTML = todayYear;
                        document.getElementById("sitetime").innerHTML = "本站已安全运行 " + diffDays + " 天 " + diffHours +
                            " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                    } else {
                        document.getElementById("year").innerHTML = startYear + " - " + todayYear;
                        document.getElementById("sitetime").innerHTML = "本站已安全运行 " + diffYears + " 年 " + diffDays +
                            " 天 " + diffHours + " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                    }
                }
                setInterval(siteTime, 1000);
            </script>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/JackHCC" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:jackcc0701@163.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>



    <a href="https://www.facebook.com/profile.php?id=100046343443643" class="tooltipped" target="_blank" data-tooltip="关注我的Facebook: https://www.facebook.com/profile.php?id=100046343443643" data-position="top" data-delay="50">
        <i class="fab fa-facebook-f"></i>
    </a>



    <a href="https://twitter.com/JackChe66021834" class="tooltipped" target="_blank" data-tooltip="关注我的Twitter: https://twitter.com/JackChe66021834" data-position="top" data-delay="50">
        <i class="fab fa-twitter"></i>
    </a>



    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=2508074836" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 2508074836" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>



    <a href="https://weibo.com/u/6885584679" class="tooltipped" target="_blank" data-tooltip="关注我的微博: https://weibo.com/u/6885584679" data-position="top" data-delay="50">
        <i class="fab fa-weibo"></i>
    </a>



    <a href="https://www.zhihu.com/people/8f8482f01f0d6a04e844efe32e0f0710" class="tooltipped" target="_blank" data-tooltip="关注我的知乎: https://www.zhihu.com/people/8f8482f01f0d6a04e844efe32e0f0710" data-position="top" data-delay="50">
        <i class="fab fa-zhihu1">知</i>
    </a>



</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/js/search.js"></script>
<script type="text/javascript">
$(function () {
    searchFunc("https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/" + "search.xml", 'searchInput', 'searchResult');
});
</script>
    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/materialize/materialize.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/aos/aos.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/js/matery.js"></script>

    <canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" ></canvas>
    <script type="text/javascript" src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script>
    <script type="text/javascript" src="/js/fireworks.js"></script>

    <script type="text/javascript">
        //只在桌面版网页启用特效
        var windowWidth = $(window).width();
        if (windowWidth > 768) {
            document.write('<script type="text/javascript" src="/js/sakura.js"><\/script>'); }
    </script>

    <!-- weather -->
	<script type="text/javascript">
	WIDGET = {FID: 'TToslpmkVO'}
	</script>
	<script type="text/javascript" src="https://apip.weatherdt.com/float/static/js/r.js?v=1111"></script>


    <!-- Global site tag (gtag.js) - Google Analytics -->


    <!-- Baidu Analytics -->

<script>
    var _hmt = _hmt || [];
    (function () {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
    })();
</script>

    <!-- Baidu Push -->

    
    
    <script async src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/others/busuanzi.pure.mini.js"></script>
    

    
        <script src="//code.tidio.co/kqhlkxviiccyoa0czpfpu4ijuey9hfre.js"></script>
        <script> 
            $(document).ready(function () {
                setInterval(change_Tidio, 50);  
                function change_Tidio() { 
                    var tidio=$("#tidio-chat iframe");
                    if(tidio.css("display")=="block"&& $(window).width()>977 ){
                        document.getElementById("tidio-chat-iframe").style.bottom= ($("div#backTop.top-scroll").css("display")=="none" &&$(window).width()>977)>0? "-40px" : ($("div.toc-title").length&&$(window).width()>977)>0?"85px":"20px";   
                        document.getElementById("tidio-chat-iframe").style.right="-15px";   
                        document.getElementById("tidio-chat-iframe").style.height=parseInt(tidio.css("height"))>=520?"520px":tidio.css("height");
                        document.getElementById("tidio-chat-iframe").style.zIndex="997";
                    } 
                    else if(tidio.css("display")=="block"&&$(window).width()>601 &&$(window).width()<992 ){
                        document.getElementById("tidio-chat-iframe").style.bottom= ($("div#backTop.top-scroll").css("display")=="none" && 601< $(window).width()<992)>0? "-40px":"20px" ;   
                        document.getElementById("tidio-chat-iframe").style.right="-15px"; 
                        document.getElementById("tidio-chat-iframe").style.zIndex="997";
                    }
                    else if(tidio.css("display")=="block"&&$(window).width()<601 && parseInt(tidio.css("height"))<230){
                        document.getElementById("tidio-chat-iframe").style.bottom= ($("div#backTop.top-scroll").css("display")=="none" && $(window).width()<601)>0? "-10px":"45px" ;   
                        document.getElementById("tidio-chat-iframe").style.zIndex="997";
                    }
                    if( tidio.css("display")=="block"&&$(window).width()<601 && parseInt(tidio.css("height"))>=230){
                        document.getElementById("tidio-chat-iframe").style.zIndex="998";
                    }
                } 
            }); 
        </script>
    

    

    
    <script type="text/javascript" color="0,0,255"
        pointColor="0,0,255" opacity='0.7'
        zIndex="-1" count="99"
        src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/background/canvas-nest.js"></script>
    

    

    
    <script type="text/javascript" src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/background/ribbon-dynamic.js" async="async"></script>
    
    
    
    <script src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/instantpage/instantpage.js" type="module"></script>
    

        <script src="//cdn.jsdelivr.net/npm/js-base64/base64.min.js"></script>
        <script>
        $('a').each(function() {
          const $this = $(this);
          const href = $this.attr('href');
          if (href && href.match('^((http|https|thunder|qqdl|ed2k|Flashget|qbrowser|ftp|rtsp|mms)://)')) {
            const strs = href.split('/');
            if (strs.length >= 3) {
                const host = strs[2];
                if (host !== 'your_domain' || window.location.host) {
                    $this.attr('href', '/go.html?u='+Base64.encode(href)+'').attr('rel', 'external nofollow noopener noreferrer');
                    if (true) {
                        $this.attr('target', '_blank');
                    }
                }
            }
          }
        });
        </script><script>!function(e){var c=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));function i(){for(var r=0;r<c.length;r++)t=c[r],0<=(n=t.getBoundingClientRect()).bottom&&0<=n.left&&n.top<=(e.innerHeight||document.documentElement.clientHeight)&&function(){var t,n,e,i,o=c[r];t=o,n=function(){c=c.filter(function(t){return o!==t})},e=new Image,i=t.getAttribute("data-original"),e.onload=function(){t.src=i,n&&n()},e.src=i}();var t,n}i(),e.addEventListener("scroll",function(){var t,n;t=i,n=e,clearTimeout(t.tId),t.tId=setTimeout(function(){t.call(n)},500)})}(this);</script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script></body>

</html>

